 Contents
C# 関連のドキュメント 作業開始
はじめに
型 プログラムの構成要素 主な言語の領域 チュートリアル
最初のレッスンを選択する ブラウザー ベースのチュートリアル
Hello world C# の数値 分岐とループ リスト コレクション
ローカル環境で作業する 環境を設定する
C# の数値 分岐とループ
リスト コレクション チュートリアル
概要
クラスの概要
オブジェクト指向プログラミング
レコード型を調べる
最上位レベルのステートメントを調べる オブジェクトのパターンを調べる
文字列補間を詳しく学習する - 対話形式 文字列補間を詳しく学習する - 自分の環境内で 文字列補間の高度なシナリオ
既定のインターフェイス メソッドでインターフェイスを安全に更新する

既定のインターフェイス メソッドを使用した mixin 機能を作成する インデックスと範囲を調べる
Null 許容参照型を操作する
アプリを Null 許容参照型にアップグレードする 非同期ストリームの生成と使用
パターン マッチングを使用したデータドリブン アルゴリズムの構築 コンソール アプリケーション
REST クライアント
C# と .NET での継承
LINQ の使用
属性の使用 C# の新機能
C# 9.0
C# 8.0
C# 7.0-7.3 コンパイラでの破壊的変更
C# バージョン履歴 言語とフレームワークの関係 バージョンと更新に関する考慮事項
C# の概念
C# 型システム
null 許容参照型
null 許容参照型を有効にするための方法を選択する 名前空間
基本型
クラス
タプルとその他の型の分解
インターフェイス
メソッド
プロパティ
インデクサー
破棄

ジェネリック
Iterators
デリゲートとイベント
デリゲートの概要
System.Delegate とデリゲートのキーワード 厳密に型指定されたデリゲート デリゲートの一般的なパターン イベントの概要
標準的な .NET イベント パターン 更新された .NET イベント パターン デリゲートとイベントの識別
統合言語クエリ (LINQ: Language-Integrated Query) LINQ の概要
クエリ式の基本
LINQ (C#)
C# での LINQ クエリの作成 オブジェクトのコレクションの照会 メソッドからクエリを返す クエリ結果をメモリに格納する クエリ結果のグループ化 入れ子になったグループの作成 グループ化操作でのサブクエリの実行 連続するキーで結果をグループ化する 実行時における述語フィルターの動的指定 内部結合の実行
グループ結合の実行 左外部結合の実行
join 句の結果の順序指定 複合キーを使用した結合 カスタム結合操作の実行 クエリ式の null 値の処理 クエリ式の例外の処理

非同期プログラミング
パターン マッチ 安全で効率的なコードを記述する 式ツリー
式ツリーの概要
式ツリーの説明 式ツリーをサポートするフレームワークの型 式の実行
式の解釈
式の構築
式の変換
まとめ
ネイティブ相互運用性 コードのドキュメントの作成 バージョン管理
操作方法に関する C# の記事 記事のインデックス 文字列を部分文字列に分割する 文字列を連結する
検索文字列
文字列の内容を変更する
文字列を比較する
パターン マッチングと is/as 演算子を使用して安全にキャストする
.NET Compiler Platform SDK (Roslyn API)
.NET Compiler Platform SDK (Roslyn APIs) の概要 コンパイラ API モデルを理解する
構文の使用
セマンティクスの使用
ワークスペースの使用 構文ビジュアライザーでコードを調べる
クイック スタート
構文の解析

セマンティック解析
構文の変換 チュートリアル
最初のアナライザーとコード修正を作成する C# プログラミング ガイド
概要
インサイド C# プログラム
C# プログラム内の内容 C# プログラムの一般構造 識別子名
C# のコーディング規則
Main() とコマンド ライン引数 概要
コマンド ライン引数
コマンド ライン引数を表示する方法 Main() の戻り値 最上位レベルのステートメント
プログラミングの概念 概要
非同期プログラミング 概要
非同期プログラミング モデル 非同期の戻り値の型 タスクの取り消し
タスクの一覧を取り消す
指定した時間の経過後のタスクのキャンセル 完了時の非同期タスクの処理 ファイルへの非同期アクセス
属性 概要
カスタム属性の作成 リフレクションを使用した属性へのアクセス

属性を使用して C/C++ の共用体を作成する方法 コレクション
共変性と反変性
概要
ジェネリック インターフェイスの分散
バリアント ジェネリック インターフェイスの作成
ジェネリック コレクションに対するインターフェイスでの分散の使用 デリゲートの分散
デリゲートでの分散の使用
Func および Action 汎用デリゲートでの分散の使用 式ツリー
概要
式ツリーを実行する方法 式ツリーを変更する方法 式ツリーを使用して動的クエリを作成する方法 式ツリーのデバッグ (Visual Studio) DebugView の構文
Iterators
統合言語クエリ (LINQ: Language-Integrated Query)
概要
C# の LINQ の概要
LINQ クエリの概要
LINQ とジェネリック型
LINQ クエリの基本操作
LINQ によるデータ変換
LINQ クエリ操作での型の関係
LINQ でのクエリ構文とメソッド構文
LINQ をサポートする C# の機能 チュートリアル: C# でのクエリの作成 (LINQ)
標準クエリ演算子の概要 概要
標準クエリ演算子のクエリ式構文

実行方法による標準クエリ演算子の分類 データの並べ替え
セット操作
データのフィルター処理
量指定子操作 射影操作 データのパーティション分割 結合操作 データのグループ化 生成操作
等価演算 要素操作 データ型の変換 連結演算 集計操作
LINQ to Objects
概要
LINQ と文字列 方法に関する記事
文字列での単語の出現回数をカウントする方法 (LINQ) 指定された単語のセットを含む文章を照会する方法 (LINQ) 文字列内の文字を照会する方法 (LINQ)
LINQ クエリと正規表現を組み合わせる方法
2 つのリストの差集合を見つける方法 (LINQ) 任意の単語またはフィールドを基準にテキスト データの並べ替えまたはフィルター処理を実
行する方法 (LINQ)
区切りファイルのフィールドの順序を変更する方法 (LINQ) 文字列コレクションを結合および比較する方法 (LINQ) 複数のソースからオブジェクト コレクションにデータを設定する方法 (LINQ) グループを使用して 1 つのファイルを複数のファイルに分割する方法 (LINQ) 異種ファイルのコンテンツを結合する方法 (LINQ)
CSV テキスト ファイルの列値を計算する方法 (LINQ)
LINQ とリフレクション

リフレクションを使用してアセンブリのメタデータを照会する方法 (LINQ) LINQ とファイル ディレクトリ
概要
指定された属性または名前のファイルを照会する方法 拡張子別にファイルをグループ化する方法 (LINQ) 一連のフォルダーの合計バイト数を照会する方法 (LINQ)
2 つのフォルダーの内容を比較する方法 (LINQ)
ディレクトリ ツリー内で最もサイズの大きいファイルを照会する方法 (LINQ) ディレクトリ ツリーで重複するファイルを照会する方法 (LINQ) フォルダー内のファイルの内容を照会する方法 (LINQ)
LINQ を使用して ArrayList を照会する方法
LINQ クエリのカスタム メソッドを追加する方法 LINQ to ADO.NET (ポータル ページ)
データ ソースの LINQ クエリの有効化
Visual Studio IDE およびツールの LINQ のサポート
リフレクション シリアル化 (C#)
概要
XML ファイルにオブジェクト データを書き込む方法 XML ファイルからオブジェクト データを読み取る方法 チュートリアル: オブジェクトの永続化 (Visual Basic)
ステートメント、式、および演算子 概要
ステートメント 式形式のメンバー 匿名関数
概要
クエリでラムダ式を使用する方法 等値と等価比較
等価比較 型の値の等価性を定義する方法 参照の等価性 (同値) をテストする方法

型
型の使用と定義
キャストと型変換
ボックス化とボックス化解除
バイト配列を int に変換する方法
文字列を数値に変換する方法
16 進文字列と数値型の間で変換する方法
dynamic 型の使用
チュートリアル: 動的オブジェクトの作成と使用 (C# および Visual Basic)
クラス、レコード、構造体 概要
クラス
レコード オブジェクト 継承 ポリモーフィズム
概要
Override キーワードと New キーワードによるバージョン管理 Override キーワードと New キーワードを使用する場合について ToString メソッドをオーバーライドする方法
メンバー
メンバーの概要
抽象クラスとシール クラス、およびクラス メンバー 静的クラスと静的クラス メンバー アクセス修飾子
フィールド
定数
抽象プロパティを定義する方法
C# で定数を定義する方法
プロパティ プロパティの概要 プロパティの使用

インターフェイスのプロパティ
アクセサーのアクセシビリティの制限 読み取り/書き込みのプロパティを宣言および使用する方法 自動実装プロパティ 自動実装するプロパティを使用して簡易クラスを実装する方法
メソッド
メソッドの概要
ローカル関数
ref 戻り値と ref ローカル変数 パラメーター
パラメーターを渡す
値型のパラメーターの引き渡し
参照型のパラメーターの引き渡し メソッドに構造体を渡すこととクラス参照を渡すことの違いを理解する方法
暗黙的に型指定されるローカル変数 クエリ式で暗黙的に型指定されるローカル変数および配列を使用する方法 拡張メソッド
カスタム拡張メソッドを実装して呼び出す方法 列挙型対応の新しいメソッドを作成する方法 名前付き引数と省略可能な引数
Office プログラミングで名前付き引数と省略可能な引数を使用する方法
コンストラクター コンストラクターの概要 コンストラクターの使用 インスタンス コンストラクター プライベート コンストラクター 静的コンストラクター
コピー コンストラクターを記述する方法
ファイナライザー
オブジェクト初期化子とコレクション初期化子 オブジェクト初期化子を使用してオブジェクトを初期化する方法 コレクション初期化子を使用してディクショナリを初期化する方法

入れ子にされた型
部分クラスと部分メソッド
匿名型 クエリで要素のプロパティのサブセットを返す方法
インターフェイス 概要
明示的なインターフェイスの実装
インターフェイス メンバーを明示的に実装する方法
2 つのインターフェイスのメンバーを明示的に実装する方法
デリゲート 概要
デリゲートの使用
名前付きメソッドを使用したデリゲートと匿名メソッド
デリゲートを結合する方法 (マルチキャスト デリゲート) (C# プログラミング ガイド) デリゲートを宣言し、インスタンス化して使用する方法
配列 概要
1 次元配列
多次元配列
ジャグ配列
配列での foreach の使用 引数としての配列の受け渡し 暗黙的に型指定される配列
文字列
文字列でのプログラミング 文字列が数値を表しているかどうかを確認する方法
インデクサー 概要
インデクサーの使用 インターフェイスのインデクサー プロパティとインデクサーの比較
イベント

概要 イベントのサブスクリプションとサブスクリプション解除を行う方法 .NET ガイドラインに準拠したイベントを発行する方法 派生クラスから基本クラス イベントを発生させる方法 インターフェイス イベントを実装する方法
カスタム イベント アクセサーを実装する方法
ジェネリック 概要
ジェネリック型の型パラメーター 型パラメーターの制約 汎用クラス
ジェネリック インターフェイス ジェネリック メソッド ジェネリックと配列 汎用デリゲート
C++ テンプレートと C# ジェネリックの違い ランタイムのジェネリック ジェネリックとリフレクション ジェネリックと属性
名前空間 概要
名前空間の使用
My 名前空間を使用する方法 unsafe コードとポインター
概要と制限事項 固定サイズ バッファー ポインター型
概要
ポインター変換 ポインターを使用してバイトの配列をコピーする方法
XML ドキュメント コメント 概要

ドキュメント コメント用の推奨タグ
XML ファイルの処理
ドキュメント タグの区切り記号
XML ドキュメント機能を使用する方法 ドキュメント タグのリファレンス
<c>
<code>
cref 属性 <example> <exception> <include> <inheritdoc> <list>
<para> <param> <paramref> <permission> <remarks> <returns> <see> <seealso> <summary> <typeparam> <typeparamref> <value>
例外と例外処理 概要
例外の使用
例外処理
例外の作成とスロー コンパイラにより生成された例外
try-catch を使用して例外を処理する方法

finally を使用してクリーンアップ コードを実行する方法
CLS 準拠でない例外をキャッチする方法 ファイル システムとレジストリ
概要
ディレクトリ ツリーを反復処理する方法 ファイル、フォルダー、およびドライブに関する情報を取得する方法 ファイルまたはフォルダーを作成する方法 ファイルおよびフォルダーのコピー、削除、および移動を行う方法 ファイル操作の [進行状況] ダイアログ ボックスを表示する方法 テキスト ファイルに書き込む方法
テキスト ファイルから読み取る方法
テキスト ファイルを一度に 1 行読み取る方法 レジストリにキーを作成する方法
相互運用性
.NET の相互運用性
相互運用性の概要
C# の機能を使用して Office 相互運用オブジェクトにアクセスする方法
COM 相互運用機能を使用したプログラミングでインデックス付きプロパティを使用する方法 プラットフォーム呼び出しを使用して WAV ファイルを再生する方法
チュートリアル: Office のプログラミング (C# および Visual Basic)
COM クラスの例
言語のリファレンス 概要
言語バージョンの構成 型
値型 概要
整数数値型 浮動小数点数値型 組み込みの数値変換 bool
char

列挙型 構造体型 タプル型
null 許容値型
参照型 参照型の機能 組み込みの参照型 class
interface
null 許容参照型
void
var 組み込み型 アンマネージ型 既定の値
Keywords
概要 修飾子
アクセス修飾子
クイック リファレンス
アクセシビリティ レベル
アクセシビリティ ドメイン
アクセシビリティ レベルの使用に関する制限事項 internal
private
protected
public
protected internal
private protected
abstract async const

event
extern
in (ジェネリック修飾子) new (メンバー修飾子) out (ジェネリック修飾子) override
readonly
sealed
static
unsafe
virtual
volatile
ステートメントのキーワード ステートメントのカテゴリ 選択ステートメント
if-else
switch
繰り返しステートメント
do
for foreach、in while
ジャンプ ステートメント
break continue goto return
例外処理ステートメント
throw try-catch try-finally try-catch-finally

Checked と Unchecked 概要
checked
unchecked fixed ステートメント lock ステートメント
メソッドのパラメーター パラメーターを渡す params
in (パラメーター修飾子) ref
out (パラメーター修飾子) 名前空間キーワード
namespace using
使用するためのコンテキスト using ディレクティブ
using static ディレクティブ using ステートメント
extern エイリアス 型テストのキーワード
is
ジェネリック型制約のキーワード new 制約
where
アクセス キーワード
base
this
リテラル キーワード
null
true および false default

コンテキスト キーワード クイック リファレンス add
get
Init
partial (型)
partial (メソッド) remove
set
when (フィルター条件) value
yield
クエリ キーワード クイック リファレンス from 句
where 句
select 句 group 句 into orderby 句 join 句 let句 ascending descending on
equals by
in
演算子および式 概要
算術演算子 ブール論理演算子

ビット処理シフト演算子 等値演算子
比較演算子
メンバー アクセス演算子と式 型のテスト演算子とキャスト式 ユーザー定義の変換演算子 ポインターに関連する演算子 代入演算子
ラムダ式
+ および += 演算子
- および -= 演算子
?: 演算子
! (null 非厳格) 演算子 ?? および ??= 演算子 => 演算子
:: 演算子
await 演算子
既定値式
delegate 演算子 nameof 式
new 演算子
sizeof 演算子 stackalloc 式
switch 式
true および false 演算子 with 式 演算子のオーバーロード
特殊文字 概要
$ -- 文字列補間
@ -- 逐語的識別子 コンパイラによって読み込まれる属性

グローバル属性
全般
呼び出し元情報
Null 許容のスタティック分析
プリプロセッサ ディレクティブ 概要
#if
#else
#elif
#endif
#define
#undef
#warning
#error
#line
#null 許容
#region #endregion #pragma
#pragma warning #pragma checksum
コンパイラ オプション 概要
csc.exe を使用したコマンド ラインからのビルド
Visual Studio のコマンドラインのための環境変数を設定する方法 カテゴリ別の C# コンパイラ オプションの一覧
アルファベット順の C# コンパイラ オプションの一覧
@ -addmodule -appconfig -baseaddress -bugreport

-checked -codepage -debug -define -delaysign -deterministic -doc -errorreport -filealign -fullpaths -help, -? -highentropyva -keycontainer -keyfile -langversion -lib
-link
-linkresource
-main -moduleassemblyname -noconfig
-nologo
-nostdlib
-nowarn -nowin32manifest -nullable
-optimize
-out
-pathmap
-pdb
-platform -preferreduilang

-publicsign -recurse -reference
-refout
-refonly
-resource -subsystemversion -target
-target:appcontainerexe -target:exe -target:library -target:module -target:winexe -target:winmdobj
-unsafe -utf8output -warn -warnaserror -win32icon -win32manifest -win32res
コンパイラ エラー
C# 6.0 のドラフト仕様 C#7.0-9.0の提案
チュートリアル

            C# ("シー シャープ" と読みます) は、最新のタイプ セーフなオブジェクト指向のプログラミング言語です。 C# を使用すると、.NET エコシステムで稼働する、安全で信頼性の高い多くの種類のアプリケーションを構築できます。 C# は C 言語ファミリーをルーツと しているため、C、C++、Java、JavaScript のプログラマーであればすぐに使いこなすことができます。 このツアーでは、C# 8 以 前の言語の主要なコンポーネントの概要について説明します。 対話型の例を通して言語を調べたい場合は、C# の概要に関 するチュートリアルを参照してください。
C# は、オブジェクト指向、"コンポーネント指向" のプログラミング言語です。 C# はこれらの概念を直接サポートする言語コンス トラクトを提供しているので、自然にソフトウェア コンポーネントを作成して使用することができます。 当初から、C# では、新しい ワークロードと新しいソフトウェア設計プラクティスをサポートする機能が追加されています。
C# には、堅牢で持続性のあるアプリケーションを作成するのに役立つ機能がいくつかあります。 "*ガベージ コレクション _" に は、到達できず、使用されていないオブジェクトによって占有されたメモリを自動的に回収する機能があります。 "null 許容型" を使用すると、割り当てられたオブジェクトを参照していない変数に対する保護が行われます。 "*例外処理*" には、エラーの 検出と復旧を行うための構造化された拡張可能なアプローチが用意されています。 "*ラムダ式*" では、関数型プログラミング 手法がサポートされます。 "*統合言語クエリ (LINQ)*" の構文を使用すると、任意のソースからのデータを操作するための一般 的なパターンが作成されます。 "*非同期操作*" の言語サポートからは、分散システムを構築するための構文が提供されます。 C#は"_統合型システム*"を備えています。 int や double などのプリミティブ型を含めたC#のすべての型は、ルートとなる 1つの object 型から派生しています。すべての型は、一般的な操作のセットを共有します。すべての型の値を一貫した方 法で格納、転送、操作することができます。 さらに、C# を使用すると、ユーザー定義の参照型と値型の両方がサポートされま す。 C# では、オブジェクトを動的に割り当てたり、軽量の構造体をインラインで格納したりすることもできます。 C# は、タイプ セーフとパフォーマンスの向上を実現するジェネリック メソッドと型をサポートします。 C# は反復子もサポートしているため、クライ アント コードのカスタム動作をコレクション クラスの実装側が定義できます。
C# では、プログラムとライブラリが互換性を保ちながら時間とともに進化できるように、"バージョン管理" に重点が置かれていま す。C#の設計でバージョン管理の考慮の影響を直接受けている側面として、別個の virtual 修飾子と override 修飾 子、メソッドのオーバーロードの解決規則、明示的なインターフェイス メンバー宣言のサポートなどがあります。
.NET のアーキテクチャ
C# プログラムは、.NET 上で実行されます。これは、共通言語ランタイム (CLR) と呼ばれる仮想実行システムであり、クラス ライ ブラリのセットです。 CLR は、国際規格である共通言語基盤 (CLI) の Microsoft による実装です。 CLI は、言語やライブラリ をシームレスに連携する実行および開発環境を構築するための基盤です。
C# で記述したソース コードは、CLI 仕様に準拠する中間言語 (IL) にコンパイルされます。 IL コードおよびリソース (ビットマップ や文字列など) は、アセンブリに保存されます。拡張子は一般的に .dll です。 アセンブリに含まれるマニフェストには、アセンブリ の種類、バージョン、およびカルチャに関する情報が規定されています。
C# プログラムを実行すると、アセンブリが CLR に読み込まれます。 CLR によって Just-In-Time (JIT) コンパイルが実行され、IL コードはネイティブのマシン語命令に変換されます。 CLR には、自動的なガベージ コレクション、例外処理、およびリソース管理 に関する他のサービスが用意されています。 CLR で実行されるコードは、"マネージド コード" と呼ばれることがあります。反対 に、特定のプラットフォームを対象にしたネイティブのマシン語にコンパイルされたコードは、"アンマネージド コード" と呼ばれること があります。
言語の相互運用性は、.NET の主要機能です。 C# コンパイラによって生成された IL コードは、共通型の仕様 (CTS) に準拠 しています。 C# から生成された IL コードは、F#、Visual Basic、C++ の .NET バージョンの他、20 を超える CTS 準拠言語で 生成されたコードと相互運用性があります。 1 つのアセンブリには、異なる .NET 言語で記述されたモジュールを複数含めること ができます。また、同じ言語で記述されている場合と同様に、型を参照することもできます。
    .NET には、実行時のサービス以外にも、広範なライブラリが用意されています。 これらのライブラリは、さまざまなワークロードを
C# 言語のツアー 2021/03/08 • • Edit Online
 
   サポートします。 これらは、ファイルの入出力、XML 解析のための文字列操作、Web アプリケーションのフレームワーク、 Windows フォーム コントロールなど、役に立つさまざまな機能を備えた名前空間に構成されています。 C# アプリケーションで は、一般に、.NET クラス ライブラリを広範囲に使用して、一般的な "配管工事" のような作業を処理しています。
.NET の詳細については、.NET の概要に関する記事を参照してください。 Hello world
"Hello, World" は、プログラミング言語を紹介するために伝統的に使用されているプログラムです。 これを C# で記述すると次 のようになります。
    using System;
class Hello {
    static void Main()
    {
        Console.WriteLine("Hello, World");
    }
}
  "Hello,World"プログラムは System 名前空間を参照する using ディレクティブで始まります。名前空間は、C#のプログラ ムとライブラリを階層的に整理するための手段です。 名前空間には、型と他の名前空間が含まれます。たとえば、 名 前空間には多数の型(プログラムで参照される Console クラスなど)と、他の多数の名前空間(IO や など) が含まれます。特定の名前空間を参照する using ディレクティブを使用すると、その名前空間のメンバーである型を修飾せ ずに使用できます。 using ディレクティブにより、プログラムで Console.WriteLine を System.Console.WriteLine の省略形 として使用できます。
"Hello,World"プログラムで宣言された Hello クラスにはメンバーが1つあります。Main という名前のメソッドです。 Main メソッドは static 修飾子を使用して宣言されています。インスタンスメソッドが this で囲んだ特定のオブジェクトインスタン スを参照できるのに対し、静的メソッドは特定のオブジェクトを参照せずに機能します。 規則により、 Main という名前の静的メ ソッドは C# プログラムのエントリ ポイントとして使用されます。
プログラムの出力は、 System 名前空間にある Console クラスの WriteLine メソッドによって生成されます。 このクラスは、コ ンパイラによって自動的に参照される、標準のクラス ライブラリで提供されています。
型と変数
C# には、値型 と 参照型 という 2 種類の型があります。 値の型の変数には、データが直接格納されます。 参照型の変数に は、データへの参照が格納され、これはオブジェクトとして知られています。 参照型を使用すると 2 つの変数が同じオブジェクト を参照でき、1 つの変数に対する演算によって、もう一方の変数によって参照されるオブジェクトに影響を与えることができま す。 値型の場合、各変数によって独自のデータ コピーが保持され、1 つの変数に対する演算によって別の変数に影響を与え ることはできません(ref と out のパラメーターの変数を除く)。
"識別子"は変数名です。識別子は、空白を含まないunicode文字のシーケンスです。先頭に @ が指定されている場 合、識別子は C# の予約語になります。 予約語を識別子として使用すると、他の言語と対話するときに役立つ場合がありま す。
C# の値の型はさらに、"単純型"、"列挙型"、"構造体型"、"null 許容値型"、"タプル値型" に分けられます。 C# の参照型 はさらに、"クラス型"、"インターフェイス型"、"配列型"、および "デリゲート型" に分けられます。
以下は、C# の型システムの概要です。
値型
単純型
        符号付きの整数: sbyte 、 short 、 int 、 long
System
 Collections

            符号なしの整数: byte 、   、 uint 、 ulong Unicode文字: char (UTF-16コード単位を表します) IEEE バイナリ浮動小数点数: float 、
高精度 10 進浮動小数点数:
ブール値: bool (ブール値を表します。値は true か false のどちらかです) 列挙型
形式 enum E {...} のユーザー定義型。 enum 型は、名前付き定数を持つ固有の型です。 enum 型に はそれぞれ基になる型があり、これは8つの整数型のいずれかでなければいけません。 enum 型の値のセッ トは、その基になる型の値のセットと同じです。
構造体の型
struct S {...} 形式のユーザー定義型 null 許容値型
null 値を持つその他すべての値型の拡張子 タプル値型
(T1, T2, ...) 形式のユーザー定義型 参照型
クラス型
その他すべての型の最終的な基底クラス: object
Unicode 文字列: string (一連の UTF-16 コード単位を表します)
class C {...} 形式のユーザー定義型 インターフェイス型
interface I {...} 形式のユーザー定義型 配列型
1 次元、多次元、ジャグ。 例: int[] 、 int[,] 、 int[][] デリゲート型
delegate int D(...) 形式のユーザー定義型
C# プログラムでは 型宣言 を使用して新しい型を作成します。 型宣言は、新しい型の名前とメンバーを指定します。 C# の型 カテゴリのうち 6 つはユーザー定義が可能です。それは、クラス型、構造体型、インターフェイス型、列挙型、デリゲート型、タプ ル値型です。
class 型は、データメンバー(フィールド)と関数メンバー(メソッド、プロパティ、その他)を含むデータ構造を定義します。ク ラス型では、単一継承とポリモーフィズムをサポートします。このメカニズムによって派生クラスが基底クラスを拡張して特殊化 できます。
struct 型は、データメンバーおよび関数メンバーで構造体を表す点において、クラス型に似ています。ただしクラスと異な り、構造体は値型で、通常はヒープ割り当てが不要です。 構造体型ではユーザー指定の継承がサポートされず、すべての 構造体型によって暗黙的に object 型が継承されます。
interface 型では、パブリックメンバーの名前付きセットとしてコントラクトが定義されます。 を実装する
class または struct は、インターフェイスのメンバーの実装を提供する必要があります。 は複数の基底イン ターフェイスから継承することがあり、 class または struct は複数のインターフェイスを実装することがあります。
delegate 型は、特定のパラメーターリストおよび戻り値を使用してメソッドへの参照を表します。デリゲートを使用すると、 変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。 デリゲートは、関数型言語 で提供される関数の型に似ています。 また、他のいくつかの言語で見られる関数ポインターの概念に似ています。 ただし、 関数ポインターとは異なり、デリゲートはオブジェクト指向で、タイプ セーフです。
class 、 struct 、 interface および delegate の型はすべてジェネリックをサポートし、他の型と共にパラメーター化できま す。
 double
 decimal
              interface
  interface
      C# では、あらゆる型の 1 次元および多次元の配列がサポートされています。 上記の型とは異なり、配列型は使用前に宣言
 ushort
 
     する必要がありません。 代わりに配列型は、角かっこで囲んだ型名を後に付けることにより構成されます。 たとえば、 int[] は int の1次元配列、int[,] は int の2次元配列、int[][] は int の1次元配列の1次元配列、または"ジャグ"
配列です。
null許容型は個別の定義を必要としません。null非許容型 T のそれぞれについて、対応するnull許容型 T? があり、こ れは追加値 null を保持することができます。 たとえば、 int? は 32 ビット整数または値 null を保持できる型であり、
string? は string または値 null を保持できる型です。
C# の型システムは、任意の型の値を として扱えるように統一されています。 C# における型はすべて、直接的または 間接的に object クラス型から派生し、 はすべての型の究極の基底クラスです。参照型の値は、値を単純に
object 型としてみなすことによってオブジェクトとして扱われます。値型の値は、ボックス化とボックス化解除操作を実行する ことによって、オブジェクトとして扱われます。 次の例では、 int 値は object 値に変換され、また int に戻されます。
値型の値が object 参照に割り当てられている場合は、値を保持するために"ボックス"が割り当てられます。このボックスは 参照型のインスタンスであり、そのボックスに値がコピーされます。 逆に、 object 参照が値型にキャストされると、参照先の
object が適切な値型のボックスかどうかが確認されます。確認が成功すると、ボックス内の値が値型にコピーされます。
C#の型システムが統一されたということは、実質的には値型が"オンデマンドで" object 参照として扱われるということです。 こうした統一性があるため、 object 型を使用する汎用的なライブラリは、参照型と値型の両方を含め、 object から派生す るすべての型で使用できます。
C# には、フィールド、配列要素、ローカル変数、パラメーターなどの、いくつかの種類の 変数 があります。 変数は格納場所を 表します。 各変数には型があり、次のように、この型によって変数に格納できる値が決まります。
null 非許容値型 型そのものの値
null 許容値型
null 値、またはその型そのものの値
object
null 参照、任意の参照型のオブジェクトへの参照、または任意の値型のボックス化された値への参照 クラス型
null 参照、そのクラス型のインスタンスへの参照、またはそのクラス型から派生したクラスのインスタンスへの参照 インターフェイスの型
null 参照、そのインターフェイスの型を実装するクラス型のインスタンスへの参照、またはそのインターフェイス型を 実装する値型のボックス化された値への参照
配列型
null 参照、その配列型のインスタンスへの参照、または互換性のある配列型のインスタンスへの参照
デリゲート型
null 参照、またはそのデリゲート型と互換性のあるインスタンスへの参照
プログラムの構造
C# における主要な組織的概念は、"*プログラム _"、"*名前空間*"、"*型*"、"*メンバー*"、および "*アセンブリ*" です。 プロ グラムは型を宣言します。型にはメンバーが含まれていて、複数の名前空間に編成することができます。 型の例には、クラス、 構造体、インターフェイスがあります。 メンバーの例には、フィールド、メソッド、プロパティ、およびイベントがあります。 C# プログラ ムはコンパイルされると、物理的にアセンブリにパッケージ化されます。 通常、アセンブリには、"*アプリケーション*" と "_*ライブラ リ**"のどちらを実装するかに応じて、それぞれ .exe または .dll のファイル拡張子が付けられます。
     object
  object
      int i = 123;
object o = i;    // Boxing
int j = (int)o;  // Unboxing
       小さな例として、次のコードを含むアセンブリについて考えてみます。

     using System;
namespace Acme.Collections
{
    public class Stack<T>
    {
Entry _top;
        public void Push(T data)
        {
            _top = new Entry(_top, data);
        }
        public T Pop()
        {
            if (_top == null)
            {
                throw new InvalidOperationException();
            }
            T result = _top.Data;
            _top = _top.Next;
            return result;
        }
class Entry {
} }
}
public Entry Next { get; set; }
public T Data { get; set; }
public Entry(Entry next, T data)
{
Next = next;
Data = data; }
  このクラスの完全修飾名は Acme.Collections.Stack です。 このクラスには複数のメンバーが含まれています: top という名 前のフィールドが1つ、Push と Pop という名前のメソッドが合わせて2つ、そして Entry という名前の入れ子になったクラス です。 Entry クラスにはさらに、3 つのメンバーが含まれています: next という名前のフィールド、 data という名前のフィール ド、およびコンストラクターです。 Stack は"ジェネリック"クラスです。これには、使用時に具象型に置き換えられる1つの型パ ラメーター T があります。
アセンブリには実行可能なコードが中間言語 (IL) の形式で含まれていて、シンボル情報がメタデータの形式で含まれています。 実行前に、.NET 共通言語ランタイムの Just-In-Time (JIT) コンパイラによって、アセンブリの IL コードはプロセッサ固有のコード に変換されます。
アセンブリはコードとメタデータの両方を含む自己記述的な機能的単位であるため、 #include ディレクティブおよびヘッダー ファ イルを C# に含める必要はありません。 特定のアセンブリに含まれているパブリックの型とメンバーは、単にプログラムのコンパイル 中にそのアセンブリを参照することにより、C#プログラムで利用可能になります。たとえば、このプログラムでは acme.dll アセン ブリの Acme.Collections.Stack クラスを使用しています。
    NOTE
"スタック" は "先入れ後出し" (FILO) コレクションです。 新しい要素がスタックの先頭に追加されます。 要素が削除されると、それはスタック の一番上から削除されます。
    
  このプログラムをコンパイルするには、前の例で定義されているスタック クラスを含むアセンブリを "参照" する必要があります。
C# プログラムは複数のソース ファイルに格納できます。 C# プログラムがコンパイルされると、すべてのソース ファイルがまとめて処 理され、ソース ファイルは自由に相互参照できます。 概念的には、処理される前にすべてのソース ファイルが 1 つの大きなファ イルに連結されるかのようになります。 C# では事前宣言をする必要がありません。ごく一部の例外を除いて、宣言の順序は重 要でないためです。 C# ではソース ファイルがパブリック型 1 つのみの宣言に制限されません。また、ソース ファイルの名前がソー ス ファイルで宣言された型に一致する必要もありません。
これらの組織ブロックについては、このツアーの他の記事をご覧ください。
       using System;
using Acme.Collections;
class Example
{
    public static void Main()
    {
} }
var s = new Stack<int>();
s.Push(1); // stack contains 1
s.Push(10); // stack contains 1, 10
s.Push(100); // stack contains 1, 10, 100
Console.WriteLine(s.Pop()); // stack contains 1, 10
Console.WriteLine(s.Pop()); // stack contains 1
Console.WriteLine(s.Pop()); // stack is empty
 
     C# は、オブジェクト指向言語として、カプセル化、継承、およびポリモーフィズムの概念をサポートしています。 クラスは 1 つの親 クラスから直接継承でき、任意の数のインターフェイスを実装できます。 親クラスの仮想メソッドをオーバーライドする場合、誤っ て再定義しないように、override キーワードを指定する必要があります。C#の構造体はコンパクトなクラスのようなもので す。インターフェイスを実装できるスタック割り当て型ですが、継承はサポートされていません。 C# には、主にデータ値を格納す る目的を持つクラス型であるレコードも用意されています。
クラスとオブジェクト
"クラス" は C# の最も基本的な型です。 クラスは、状態 (フィールド) とアクション (メソッドおよびその他の関数メンバー) を 1 つ の単位としてまとめたデータ構造です。 クラスには、オブジェクト とも呼ばれる、クラスの インスタンス の定義があります。 クラスで は、"継承"と "ポリモーフィズム" をサポートします。これによって "派生クラス" が "基底クラス" を拡張して特殊化できます。
新しいクラスはクラス宣言を使用して作成されます。 クラス宣言は、ヘッダーで始まります。 ヘッダーでは次を指定します。
クラスの属性と修飾子
クラスの名前
基底クラス (基底クラスから継承する場合) このクラスによって実装されるインターフェイス。
ヘッダーの後にはクラス本体が続きます。これは、区切り記号 { と } の間に記述するメンバー宣言のリストで構成されます。 次のコードは、 Point という名前の単純なクラスの宣言を示しています。
クラスのインスタンスは new 演算子を使用して作成されます。この演算子は新しいインスタンスのメモリを割り当て、コンストラク ターを呼び出してインスタンスを初期化し、インスタンスへの参照を返します。次のステートメントは、2つの Point オブジェクト を作成し、2 つの変数に、それらのオブジェクトへの参照を格納します。
オブジェクトで占有されたメモリは、そのオブジェクトに到達できなくなると自動的に解放されます。 C# では、オブジェクトの割り当 てを明示的に解除する必要がなく、また解除することもできません。
型パラメーター
ジェネリック クラスでは "*型パラメーター" を定義します。 型パラメーターは、山かっこで囲まれた型パラメーターの一連の名前で す。 型パラメーターは、クラス名の後にあります。 これで、クラスのメンバーを定義するクラス宣言の本体で型パラメーターを使用 できます。 次の例では、 Pair の型パラメーターは TFirst と TSecond です。
     public class Point
{
    public int X { get; }
    public int Y { get; }
    public Point(int x, int y) => (X, Y) = (x, y);
}
     var p1 = new Point(0, 0);
var p2 = new Point(10, 20);
   型とメンバー
2021/03/06 • • Edit Online
 
    型パラメーターを受け取るために宣言されるクラス型は、"ジェネリック クラス型" と呼ばれます。 構造体、インターフェイス、および デリゲートの型もジェネリックです。 ジェネリック クラスを使用する場合は、それぞれの型パラメーターの型引数を指定する必要が あります。
上記の Pair<int,string> のような、型引数が指定されたジェネリック型は"構築された型"と呼ばれます。 基底クラス
クラスの宣言で、基底クラスを指定する場合もあります。 クラス名と型パラメーターの後には、コロンと基底クラスの名前を指定し ます。基底クラスの指定の省略は、 型からの派生と同じです。次の例の Point3D の基底クラスは Point です。 最初の例の Point の基底クラスは です。
    var pair = new Pair<int, string>(1, "two");
int i = pair.First;     // TFirst int
string s = pair.Second; // TSecond string
   object
  object
     public class Point3D : Point
{
    public int Z { get; set; }
    public Point3D(int x, int y, int z) : base(x, y)
    {
Z = z; }
}
 クラスは、その基底クラスのメンバーを継承します。 継承は、クラスにその基底クラスのほぼすべてのメンバーが暗黙的に含まれ ることを意味します。 クラスは、インスタンス コンストラクター、静的コンストラクター、およびファイナライザーを継承しません。 派 生クラスでは、継承するメンバーに新しいメンバーを追加できますが、継承されたメンバーの定義を削除することはできません。 前述の例では、 Point3D は、 Point から X メンバーと Y メンバーを継承しており、各 Point3D インスタンスには、 X 、 Y 、Z の3つのプロパティが含まれています。
暗黙的な変換は、クラス型からその基底クラス型のいずれかに存在します。 クラス型の変数は、そのクラスのインスタンスまたは 任意の派生クラスのインスタンスを参照できます。 たとえば、前述のクラス宣言では、 Point 型の変数が Point または
Point3D を参照できます。
構造体
クラスは、継承とポリモーフィズムをサポートする型を定義します。 これにより、派生クラスの階層に基づいて高度なビヘイビアーを 作成できます。 これに対し、"*構造体" 型は、データ値を格納することを主な目的とするより単純な型です。 構造体では基 本データ型を宣言できません。これらは、暗黙的にSystem.ValueTypeから派生します。 struct 型から、他の struct 型 を派生させることはできません。 これらは、暗黙的にシールされています。
       Point a = new Point(10, 20);
Point b = new Point3D(10, 20, 30);
      public class Pair<TFirst, TSecond>
{
    public TFirst First { get; }
    public TSecond Second { get; }
    public Pair(TFirst first, TSecond second) =>
        (First, Second) = (first, second);
}
 
   インターフェイス
"*インターフェイス*" では、クラスと構造体によって実装できるコントラクトを定義します。 1 つのインターフェイスには、メソッド、プ ロパティ、イベント、およびインデクサーが含まれる場合があります。 インターフェイスは、定義するメンバーの実装を通常行いませ ん。インターフェイスを実装するクラスまたは構造体が提供する必要があるメンバーを指定するだけです。
インターフェイスでは"*多重継承*"を使用できます。次の例では、インターフェイス IComboBox は ITextBox と IListBox の両方から継承します。
       interface IControl
{
    void Paint();
}
interface ITextBox : IControl
{
    void SetText(string text);
}
interface IListBox : IControl
{
    void SetItems(string[] items);
}
interface IComboBox : ITextBox, IListBox { }
    クラスと構造体は、複数のインターフェイスを実装できます。 次の例では、クラス EditBox は IControl と IDataBound の両 方を実装しています。
    interface IDataBound
{
    void Bind(Binder b);
}
public class EditBox : IControl, IDataBound
{
    public void Paint() { }
    public void Bind(Binder b) { }
}
 クラスまたは構造体が特定のインターフェイスを実装する場合、そのクラスまたは構造体のインスタンスはそのインターフェイス型 に暗黙的に変換できます。 次に例を示します。
    EditBox editBox = new EditBox();
IControl control = editBox;
IDataBound dataBound = editBox;
 列挙型
   public struct Point
{
    public double X { get; }
    public double Y { get; }
    public Point(double x, double y) => (X, Y) = (x, y);
}
 
    "*列挙*"型では、一連の定数値を定義します。次の enum では、さまざまな根菜の定数の定義を宣言しています。
    public enum SomeRootVegetable
{
    HorseRadish,
    Radish,
    Turnip
}
 enum は組み合わせてフラグとして使用できるよう、定義することもできます。次の宣言では、4つの季節のフラグのセットを宣 言しています。任意に季節を組み合わせることも、すべての季節を含む All 値を含め、適用することも可能です。
    [Flags]
public enum Seasons
{
    None = 0,
    Summer = 1,
    Autumn = 2,
    Winter = 4,
    Spring = 8,
    All = Summer | Autumn | Winter | Spring
}
 次の例では、上記の両列挙型を宣言しています。
null 許容型
すべての型の変数は、"null 非許容" または "null 許容" として宣言できます。 null 許容の変数には、値がないことを示す null 値をさらに含めることができます。null許容値型(構造体または列挙型)は、System.Nullable<T>で表します。null 非許容の参照型と null 許容の参照型はいずれも、基になる参照型によって表します。 この区別は、コンパイラと一部のライブ
ラリに読み取られたメタデータによって表します。null許容の参照が、値を最初に null に対してチェックせずに逆参照される と、コンパイラによって警告が出されます。null非許容の参照が null である可能性のある値に割り当てられている場合に も、コンパイラによって警告が出されます。次の例では、null に初期化される"null許容int"を宣言しています。次いで、そ の値を 5 に設定しています。同じ概念を、"Null許容文字列"でも示しています。詳細については、「null許容値型」と 「null 許容参照型」を参照してください。
タプル
C# では、軽量のデータ構造に複数のデータ要素を簡潔な構文でグループ化できる、"タプル*" がサポートされます。 タプルは、 次の例のように、 ( と ) の間にメンバーの型と名前を宣言することで、インスタンス化できます。
    var turnip = SomeRootVegetable.Turnip;
var spring = Seasons.Spring;
var startingOnEquinox = Seasons.Spring | Seasons.Autumn;
var theYear = Seasons.All;
     int? optionalInt = default;
optionalInt = 5;
string? optionalText = default;
optionalText = "Hello World.";
 
  タプルは、次の記事で説明する構成要素を使用しない、複数のメンバーを持つデータ構造の代わりとなります。
       (double Sum, int Count) t2 = (4.5, 3);
Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}.");
// Output:
// Sum of 3 elements is 4.5.
 
     前の記事で説明した型は、次の構成要素を使用して構築されています: "*メンバー _"、"*式*"、"_ *ステートメント**"。 メンバー
class のメンバーは、"静的メンバー"または"インスタンスメンバー**"です。静的メンバーはクラスに属しており、インスタン ス メンバーはオブジェクト (クラスのインスタンス) に属しています。
クラスに格納できるメンバーの種類の概要を次の一覧に示します。
定数: クラスに関連付けられている定数値
フィールド: クラスに関連付けられている変数
メソッド : クラスによって実行可能なアクション
[プロパティ] :クラスの名前付きプロパティの読み取りと書き込みに関連付けられているアクション インデクサー: 配列など、クラスのインスタンスのインデックス作成に関連付けられているアクション イベント:クラスによって生成可能な通知
演算子: クラスによってサポートされている変換と式の演算子
コンストラクター: クラスのインスタンスまたはクラス自体を初期化するために必要なアクション ファイナライザー: クラスのインスタンスが完全に破棄される前に実行されるアクション
型: クラスで宣言される、入れ子にされた型
ユーザー補助
クラスの各メンバーにはアクセシビリティが関連付けられています。アクセシビリティにより、メンバーへのアクセスが可能なプログラム のテキストの範囲が制御されます。 アクセシビリティには 6 つの有効な形式があります。 アクセス修飾子の概要を次に示しま す。
:アクセスは制限されません。 :アクセスはこのクラスに制限されます。
:アクセスは、このクラスまたはこのクラスから派生したクラスに制限されます。 :現在のアセンブリ(.exe または .dll)にアクセスが制限されます。
 public
 private
 protected
 internal
 : アクセスは、このクラス、このクラスから派生したクラス、または同じアセンブリ内のクラスに制限されま private protected :アクセスは、このクラスまたは同じアセンブリ内のこの型から派生されたクラスに制限されます。
フィールド
"フィールド" は、クラスまたはクラスのインスタンスに関連付けられている変数です。
static 修飾子で宣言されているフィールドは、静的フィールドを定義します。 静的フィールドは、格納場所を 1 つだけ識別しま す。 クラスのインスタンスがいくつ作成されても、静的フィールドのコピーは 1 つだけです。
static 修飾子なしで宣言されているフィールドは、インスタンス フィールドを定義します。 クラスの各インスタンスには、そのクラス のすべてのインスタンス フィールドの個別のコピーが含まれています。
次の例では、 Color クラスの各インスタンスに、インスタンス フィールド R 、 G 、 B の個別のコピーが含まれていますが、静的 フィールド Black 、 White 、 Red 、 Green 、 Blue のコピーは 1 つだけです。
protected internal
す。
 プログラムの構成要素
2021/03/06 • • Edit Online
 
   前述の例のように、readonly 修飾子を使用して"読み取り専用フィールド"を宣言できます。読み取り専用フィールドへの割 り当ては、フィールドの宣言の一部として、または同じクラスのコンストラクター内でのみ可能です。
メソッド
"メソッド" は、オブジェクトまたはクラスによって実行可能な計算またはアクションを実装するメンバーです。 "静的メソッド" にはク
ラスを通じてアクセスします。 "インスタンス メソッド" にはクラスのインスタンスを通じてアクセスします。
メソッドには、メソッドに渡される値または変数参照を表す "パラメーター" の一覧が含まれている場合があります。 メソッドには、 メソッドによって計算され返される値の型を指定する "戻り値の型" が含まれます。 メソッドによって値が返されない場合、メソッ ドの戻り値の型は void です。
型と同様に、メソッドには型パラメーターのセットを含めることができます。その場合、メソッドの呼び出し時に型引数を指定する 必要があります。 型引数は、型とは異なり、多くの場合メソッド呼び出しの引数から推論できます。型引数を明示的に指定す る必要はありません。
メソッドの "シグネチャ" は、メソッドが宣言されているクラス内で一意である必要があります。 メソッドのシグネチャは、メソッドの名 前と、型パラメーターの数と、そのパラメーターの数、修飾子、および型とで構成されます。 メソッドのシグネチャに戻り値の型は 含まれません。
メソッド本体が単一の式である場合は、次の例に示すように、コンパクトな式形式を使用してメソッドを定義できます。
パラメーター
パラメーターは、値または変数参照をメソッドに渡すために使用されます。 メソッドのパラメーターは、メソッドの呼び出し時に指 定する "引数" から実際の値を取得します。 値パラメーター、参照パラメーター、出力パラメーター、およびパラメーター配列の 4 種類のパラメーターがあります。
"値パラメーター" は、入力引数を渡すために使われます。 値パラメーターは、パラメーターに渡された引数からその初期値を取 得するローカル変数に相当します。 値パラメーターに対する変更は、パラメーターに渡された引数には影響を与えません。
値パラメーターは省略可能であり、既定値を指定すると、対応する引数を省略できます。
"参照パラメーター" は、参照によって引数を渡すために使われます。 参照パラメーターに渡される引数は、明確な値を持つ変 数である必要があります。 メソッドの実行中に、参照パラメーターは引数の変数と同じ格納場所を表します。 参照パラメーター は、 ref 修飾子で宣言されます。 ref パラメーターの使用例を次に示します。
  public override string ToString() => "This is an object";
    public class Color
{
    public static readonly Color Black = new Color(0, 0, 0);
    public static readonly Color White = new Color(255, 255, 255);
    public static readonly Color Red = new Color(255, 0, 0);
    public static readonly Color Green = new Color(0, 255, 0);
    public static readonly Color Blue = new Color(0, 0, 255);
    public byte R;
    public byte G;
    public byte B;
    public Color(byte r, byte g, byte b)
    {
        R = r;
        G = g;
        B = b;
} }
 
   "出力パラメーター" は、参照によって引数を渡すために使われます。 参照パラメーターに似ていますが、呼び出し元が提供す る引数に値を明示的に割り当てる必要がない点が異なります。 出力パラメーターは、 out 修飾子で宣言されます。 次の例 では、C#7で導入された構文を使っている out パラメーターを示します。
    static void Divide(int x, int y, out int result, out int remainder)
{
result = x / y;
    remainder = x % y;
}
public static void OutUsage()
{
    Divide(10, 3, out int res, out int rem);
    Console.WriteLine($"{res} {rem}"); // "3 1"
}
  "パラメーター配列"は、引数の変数の数をメソッドに渡せるようにします。パラメーター配列は、params 修飾子で宣言されま す。 パラメーター配列として使用できるのは、メソッドの最後のパラメーターのみです。パラメーター配列の型は、1 次元配列の 型である必要があります。System.Consoleクラスの Write および WriteLine メソッドは、パラメーター配列の使用方法の 好例です。 これらのメソッドは次のように宣言されます。
パラメーター配列を使用するメソッド内では、パラメーター配列は、配列型の通常のパラメーターとまったく同じように動作しま す。 ただし、パラメーター配列を使用するメソッドの呼び出しでは、パラメーター配列の型の 1 つの引数またはパラメーター配列 の要素型の任意の数の引数を渡すことができます。 後者の場合、配列インスタンスが自動的に作成され、指定した引数を使 用して初期化されます。 次のような例があるとします。
これは、次の記述と同じです。
     public class Console
{
    public static void Write(string fmt, params object[] args) { }
    public static void WriteLine(string fmt, params object[] args) { }
    // ...
}
     int x, y, z;
x = 3;
y = 4;
z = 5;
Console.WriteLine("x={0} y={1} z={2}", x, y, z);
    static void Swap(ref int x, ref int y)
{
    int temp = x;
    x = y;
    y = temp;
}
public static void SwapExample()
{
    int i = 1, j = 2;
    Swap(ref i, ref j);
    Console.WriteLine($"{i} {j}");
// "2 1"
}
 
  メソッドの本体とローカル変数 メソッドの本体では、メソッドの呼び出し時に実行するステートメントを指定します。
メソッドの本体は、メソッドの呼び出しに固有の変数を宣言できます。 このような変数は "ローカル変数" と呼ばれます。 ローカ ル変数宣言は、型名、変数名、および (場合によっては) 初期値を指定します。 次の例では、初期値 0 を使用してローカル 変数 i を宣言し、初期値を使用せずにローカル変数 j を宣言します。
    class Squares
{
    public static void WriteSquares()
    {
        int i = 0;
        int j;
        while (i < 10)
        {
} }
}
j = i * i;
Console.WriteLine($"{i} x {i} = {j}");
i = i + 1;
 C#では、ローカル変数の値を取得する前に、ローカル変数を"明示的に割り当てる"必要があります。たとえば、前述の i の宣言に初期値が含まれていなかった場合、コンパイラによって後での i の使用に対するエラーが報告されます。これは、プロ グラム内のそれらのポイントで i が明示的に割り当てられていないためです。
メソッドでは、 return ステートメントを使用して、呼び出し元に制御を戻すことができます。 void を返すメソッドの場合、 return ステートメントでは式を指定できません。void以外を返すメソッドの場合、return ステートメントは戻り値を計算す
る式を含める必要があります。 静的メソッドとインスタンス メソッド
static 修飾子で宣言されているメソッドは"静的メソッド"です。静的メソッドは、特定のインスタンスでは動作せず、静的メ ンバーにのみ直接アクセスできます。
static 修飾子なしで宣言されているメソッドは"インスタンスメソッド"です。インスタンスメソッドは、特定のインスタンスで動 作し、静的メンバーとインスタンス メンバーの両方にアクセスできます。 インスタンス メソッドが呼び出されたインスタンスには、
this として明示的にアクセスできます。静的メソッドで this を参照するとエラーになります。 次の Entity クラスには、静的メンバーとインスタンスメンバーの両方があります。
         int x = 3, y = 4, z = 5;
string s = "x={0} y={1} z={2}";
object[] args = new object[3];
args[0] = x;
args[1] = y;
args[2] = z;
Console.WriteLine(s, args);
 
    各 Entity インスタンスには、シリアル番号(およびここに表示されていないその他の情報)が含まれています。 Entity コンス トラクターは (インスタンス メソッドと同様に)、次に使用可能なシリアル番号を持つ新しいインスタンスを初期化します。 コンスト ラクターはインスタンス メンバーであるため、 _serialNo インスタンス フィールドと s_nextSerialNo 静的フィールドの両方にアク セスできます。
静的メソッドである GetNextSerialNo と SetNextSerialNo は s_nextSerialNo 静的フィールドにアクセスできますが、 _serialNo インスタンスフィールドに直接アクセスするとエラーになります。
Entity クラスの使用例を次に示します。
静的メソッドである SetNextSerialNo と GetNextSerialNo はクラスで呼び出されますが、 GetSerialNo インスタンス メソッド はクラスのインスタンスで呼び出されます。
仮想メソッド、オーバーライド メソッド、および抽象メソッド
インスタンスメソッドの宣言に virtual 修飾子が含まれている場合、そのメソッドは"仮想メソッド"と呼ばれます。virtual修
飾子が存在しない場合、そのメソッドは "非仮想メソッド" と呼ばれます。 仮想メソッドが呼び出されると、その呼び出しが行われるインスタンスの "実行時の型" によって、呼び出す実際のメソッドの実
装が決定します。 非仮想メソッドの呼び出しでは、インスタンスの "コンパイル時の型" が決定要因です。
仮想メソッドは派生クラスで "オーバーライド" できます。 インスタンス メソッドの宣言に override 修飾子が含まれている場合、 メソッドは、同じシグネチャを持つ継承された仮想メソッドをオーバーライドします。 仮想メソッドの宣言には新しいメソッドが導 入されています。 オーバーライド メソッドの宣言では、そのメソッドの新しい実装を提供することで既存の継承された仮想メソッ ドを特殊化します。
"抽象メソッド"は、実装のない仮想メソッドです。抽象メソッドは abstract 修飾子を使用して宣言され、抽象クラス内での み許可されます。 抽象メソッドは、すべての非抽象派生クラスでオーバーライドする必要があります。
           Entity.SetNextSerialNo(1000);
Entity e1 = new Entity();
Entity e2 = new Entity();
Console.WriteLine(e1.GetSerialNo());          // Outputs "1000"
Console.WriteLine(e2.GetSerialNo());          // Outputs "1001"
Console.WriteLine(Entity.GetNextSerialNo());  // Outputs "1002"
         class Entity
{
    static int s_nextSerialNo;
    int _serialNo;
    public Entity()
    {
        _serialNo = s_nextSerialNo++;
    }
    public int GetSerialNo()
    {
        return _serialNo;
    }
    public static int GetNextSerialNo()
    {
        return s_nextSerialNo;
    }
    public static void SetNextSerialNo(int value)
    {
        s_nextSerialNo = value;
    }
}
 
   次の例では、式ツリー ノードを表す抽象クラス 、および定数、変数参照、算術演算の式ツリー ノードを実装する 3 つの派生クラス Constant 、 、 を宣言します (この例は、式ツリー型に似ていますが、関連 はありません)。
Expression
      VariableReference
Operation
  
    前述の 4 つのクラスは、算術式をモデル化するために使用できます。 たとえば、これらのクラスのインスタンスを使用して、式
  public abstract class Expression
{
    public abstract double Evaluate(Dictionary<string, object> vars);
}
public class Constant : Expression
{
    double _value;
    public Constant(double value)
    {
        _value = value;
    }
    public override double Evaluate(Dictionary<string, object> vars)
    {
        return _value;
    }
}
public class VariableReference : Expression
{
    string _name;
    public VariableReference(string name)
    {
        _name = name;
    }
    public override double Evaluate(Dictionary<string, object> vars)
    {
        object value = vars[_name] ?? throw new Exception($"Unknown variable: {_name}");
        return Convert.ToDouble(value);
    }
}
public class Operation : Expression
{
    Expression _left;
    char _op;
    Expression _right;
    public Operation(Expression left, char op, Expression right)
    {
        _left = left;
        _op = op;
        _right = right;
}
    public override double Evaluate(Dictionary<string, object> vars)
    {
} }
double x = _left.Evaluate(vars);
double y = _right.Evaluate(vars);
switch (_op)
{
    case '+': return x + y;
    case '-': return x - y;
    case '*': return x * y;
    case '/': return x / y;
    default: throw new Exception("Unknown operator");
}

 x + 3 を次のように表すことができます。
    Expression e = new Operation(
    new VariableReference("x"),
    '+',
    new Constant(3));
    Expression インスタンスの Evaluate メソッドが呼び出され、指定された式を評価して ドは、変数の名前 (エントリのキーとして) と値 (エントリの値として) が格納されている
Evaluate は抽象メソッドなので、 Expression から派生した非抽象クラスでは、 ます。
値を生成します。このメソッ
引数を受け取ります。 をオーバーライドする必要があり
double
 Dictionary
   Evaluate
   Evaluate の Constant の実装は、格納された定数を単に返します。 VariableReference の実装は、ディクショナリで変数 名を検索し、結果の値を返します。 Operation の実装は、( メソッドを再帰的に呼び出すことによって)まず左と右 のオペランドを評価し、指定された算術演算を実行します。
次のプログラムでは、 Expression クラスを使用して、式 x * (y + 2) の異なる値の x と y を評価します。
 Evaluate
       Expression e = new Operation(
    new VariableReference("x"),
    '*',
    new Operation(
        new VariableReference("y"),
        '+',
        new Constant(2)
) );
Dictionary<string, object> vars = new Dictionary<string, object>();
vars["x"] = 3;
vars["y"] = 5;
Console.WriteLine(e.Evaluate(vars)); // "21"
vars["x"] = 1.5;
vars["y"] = 9;
Console.WriteLine(e.Evaluate(vars)); // "16.5"
 メソッドのオーバーロード
メソッドの "オーバーロード" では、メソッドのシグネチャが一意であれば、同じクラス内の複数のメソッドに同じ名前を付けることが できます。 オーバーロードされたメソッドの呼び出しをコンパイルする場合、コンパイラは "オーバーロードの解決" を使用して、呼 び出すメソッドを決定します。 オーバーロードの解決では、引数に最適なメソッドが 1 つ検索されます。 最適な一致が 1 つも 見つからない場合は、エラーが報告されます。 次の例は、オーバーロードの解決が有効な場合を示しています。
UsageExample メソッド内の各呼び出しのコメントは、呼び出されるメソッドを示しています。
 
  この例に示すように、引数をパラメーターの厳密な型および型引数に明示的にキャストすることにより、特定のメソッドを常に選 択できます。
その他の関数メンバー
実行可能コードが含まれるメンバーは、クラスの "関数メンバー" と総称されます。 前のセクションでは、関数メンバーの主な種 類であるメソッドについて説明しました。 ここでは、C# でサポートされるその他の種類の関数メンバー (コンストラクター、プロパ ティ、インデクサー、イベント、演算子、およびファイナライザー) について説明します。
次の例では、オブジェクトの拡張可能なリストを実装する、 MyList<T> と呼ばれるジェネリック クラスを示します。 このクラスに は、最も一般的な種類の関数メンバーの例がいくつか含まれています。
       class OverloadingExample
{
    static void F() => Console.WriteLine("F()");
    static void F(object x) => Console.WriteLine("F(object)");
    static void F(int x) => Console.WriteLine("F(int)");
    static void F(double x) => Console.WriteLine("F(double)");
    static void F<T>(T x) => Console.WriteLine("F<T>(T)");
    static void F(double x, double y) => Console.WriteLine("F(double, double)");
    public static void UsageExample()
    {
} }
F();
F(1);
F(1.0);
F("abc");
F((double)1);
F((object)1);
F<int>(1);
F(1, 1);
// Invokes F()
// Invokes F(int)
// Invokes F(double)
// Invokes F<string>(string)
// Invokes F(double)
// Invokes F(object)
// Invokes F<int>(int)
// Invokes F(double, double)
  public class MyList<T>
{
    const int DefaultCapacity = 4;
    T[] _items;
    int _count;
    public MyList(int capacity = DefaultCapacity)
    {
        _items = new T[capacity];
    }
    public int Count => _count;
    public int Capacity
    {
        get =>  _items.Length;
        set
        {
            if (value < _count) value = _count;
            if (value != _items.Length)
            {
                T[] newItems = new T[value];
                Array.Copy(_items, 0, newItems, 0, _count);
                _items = newItems;
} }
    }
    public T this[int index]

public T this[int index]
    コンストラクター
C# は、インスタンス コンストラクターと静的コンストラクターの両方をサポートします。 "インスタンス コンストラクター" は、クラスの インスタンスを初期化するために必要なアクションを実装するメンバーです。 "静的コンストラクター" は、クラスを最初に読み込む ときに、そのクラス自体を初期化するために必要なアクションを実装するメンバーです。
コンストラクターは、戻り値の型がなく、含んでいるクラスと同じ名前を持つメソッドのように宣言されます。 コンストラクターの宣言 に static 修飾子が含まれている場合は、静的コンストラクターが宣言されます。それ以外の場合は、インスタンスコンストラ クターが宣言されます。
インスタンス コンストラクターはオーバーロード可能であり、省略可能なパラメーターを指定できます。 たとえば、 MyList<T> クラ スでは、1つの省略可能な int パラメータ―を伴う1つのインスタンスコンストラクターを宣言します。インスタンスコンストラク ターは、 new 演算子を使用して呼び出されます。 次のステートメントは、 MyList クラスのコンストラクターを使用して、2 つの MyList<string> インスタンスを割り当てます(省略可能な引数を使用した場合と使用していない場合の両方を示します)。
        MyList<string> list1 = new MyList<string>();
MyList<string> list2 = new MyList<string>(10);
      {
        get => _items[index];
        set
        {
            _items[index] = value;
            OnChanged();
        }
}
    public void Add(T item)
    {
        if (_count == Capacity) Capacity = _count * 2;
        _items[_count] = item;
        _count++;
        OnChanged();
    }
    protected virtual void OnChanged() =>
        Changed?.Invoke(this, EventArgs.Empty);
    public override bool Equals(object other) =>
        Equals(this, other as MyList<T>);
    static bool Equals(MyList<T> a, MyList<T> b)
    {
        if (Object.ReferenceEquals(a, null)) return Object.ReferenceEquals(b, null);
        if (Object.ReferenceEquals(b, null) || a._count != b._count)
            return false;
        for (int i = 0; i < a._count; i++)
        {
            if (!object.Equals(a._items[i], b._items[i]))
            {
                return false;
            }
}
        return true;
    }
    public event EventHandler Changed;
    public static bool operator ==(MyList<T> a, MyList<T> b) =>
        Equals(a, b);
    public static bool operator !=(MyList<T> a, MyList<T> b) =>
        !Equals(a, b);
}

 他のメンバーとは異なり、インスタンス コンストラクターは継承されません。 クラスには、そのクラス内で実際に宣言されたコンスト ラクター以外のインスタンス コンストラクターはありません。 クラスのインスタンス コンストラクターが指定されていない場合は、パラ メーターなしの空のコンストラクターが自動的に指定されます。
プロパティ
"プロパティ" は、フィールドが自然に拡張したものです。 フィールドとプロパティはどちらも型が関連付けられている名前付きのメン バーであり、それらにアクセスするための構文は同じです。 ただし、フィールドとは異なり、プロパティは格納場所を表しません。 その代わりに、プロパティには、値の読み取りまたは書き込みの際に実行されるステートメントを指定する "アクセサー" がありま す。
プロパティはフィールドのように宣言されますが、宣言はセミコロンで終わるのではなく、区切り記号 { と } の間に記述する get アクセサーまたは set アクセサーで終わる点が異なります。 get アクセサーと set アクセサーの両方があるプロパティは、"読み 取り/書き込みプロパティ" です。 get アクセサーのみがあるプロパティは、"読み取り専用" プロパティです。 set アクセサーのみが あるプロパティは、"書き込み専用" プロパティです。
get アクセサーは、プロパティの型の戻り値を持つパラメーターなしのメソッドに相当します。 set アクセサーは、1 つのパラメーター の名前付きの値を持ち、戻り値の型を持たないメソッドに相当します。 get アクセサーは、プロパティの値を計算します。 set ア クセサーは、プロパティの新しい値を提供します。プロパティが代入のターゲットである場合、あるいは ++ または -- のオペラン ドである場合は、set アクセサーが呼び出されます。 プロパティが参照されるその他のケースでは、get アクセサーが呼び出されま す。
MyList<T> クラスは2つのプロパティ(Count と Capacity)を宣言します。これらは、それぞれ読み取り専用プロパティと読み 取り/書き込みプロパティです。 次のコードは、これらのプロパティの使用例です。
フィールドおよびメソッドと同様に、C# はインスタンス プロパティと静的プロパティの両方をサポートします。 静的プロパティは static 修飾子で宣言され、インスタンス プロパティは修飾子なしで宣言されます。
プロパティのアクセサーは仮想にすることができます。 プロパティの宣言に virtual 、 abstract 、または override の各修飾 子が含まれている場合、その宣言はプロパティのアクセサーに適用されます。
インデクサー
"インデクサー" は、配列と同じ方法でオブジェクトのインデックスを作成できるようにするメンバーです。 インデクサーはプロパティの ように宣言されますが、メンバーの名前が、 this の後に区切り記号 [ と ] でパラメーター リストを囲んだものになる点が異 なります。 パラメーターは、インデクサーのアクセサーで使用できます。 プロパティと同様に、読み取り/書き込み、読み取り専 用、および書き込み専用のインデクサーを使用できます。また、インデクサーのアクセサーを仮想にすることができます。
MyList<T> クラスは、int パラメーターを受け取る1つの読み取り/書き込みインデクサーを宣言します。インデクサーを使用 すると、 int 値を持つ MyList<T> インスタンスのインデックスを作成できます。 次に例を示します。
      MyList<string> names = new MyList<string>();
names.Capacity = 100;   // Invokes set accessor
int i = names.Count;    // Invokes get accessor
int j = names.Capacity; // Invokes get accessor
          MyList<string> names = new MyList<string>();
names.Add("Liz");
names.Add("Martha");
names.Add("Beth");
for (int i = 0; i < names.Count; i++)
{
    string s = names[i];
    names[i] = s.ToUpper();
}
 インデクサーはオーバーロードすることができます。 パラメーターの数または型が異なる限り、クラスでは複数のインデクサーを宣言 できます。

 events
"イベント" は、クラスまたはオブジェクトで通知を提供できるようにするメンバーです。 イベントはフィールドのように宣言されます が、 event キーワードが宣言に含まれており、型がデリゲート型でなければならない点が異なります。
イベント メンバーを宣言するクラス内では、イベントはデリゲート型のフィールドと同じように動作します (イベントが抽象イベントで なく、アクセサーを宣言しない場合)。 フィールドは、イベントに追加されたイベント ハンドラーを表すデリゲートへの参照を格納し ます。イベントハンドラーが存在しない場合、フィールドは null です。
MyList<T> クラスは、Changed という1つのイベントメンバーを宣言します。このメンバーは新しい項目がリストに追加されたこ とを示します。Changedイベントは OnChanged 仮想メソッドによって発生します。このメソッドは、最初にイベントが null で あるかどうか (ハンドラーが存在しないこと) を確認します。 イベントを発生させるという概念は、イベントによって表されるデリゲー トの呼び出しとまったく同じです。 イベントを発生させるための特殊な言語コンストラクトはありません。
クライアントは、"イベントハンドラー"を使用してイベントに対応します。イベントハンドラーは、+= 演算子を使用してアタッチ され、 -= 演算子を使用して削除されます。 次の例では、 MyList<string> の Changed イベントにイベント ハンドラーをア タッチします。
         class EventExample
{
    static int s_changeCount;
    static void ListChanged(object sender, EventArgs e)
    {
        s_changeCount++;
    }
    public static void Usage()
    {
} }
var names = new MyList<string>();
names.Changed += new EventHandler(ListChanged);
names.Add("Liz");
names.Add("Martha");
names.Add("Beth");
Console.WriteLine(s_changeCount); // "3"
  イベントの基になる記憶域の制御が求められる高度なシナリオでは、イベントの宣言で add アクセサーと remove アクセサーを 明示的に指定できます。これらは、プロパティの set アクセサーに似ています。
オペレーター
"演算子" は、クラスのインスタンスに特定の式の演算子を適用する意味を定義するメンバーです。 単項演算子、2 項演算 子、および変換演算子の3種類を定義できます。すべての演算子は public および static として宣言する必要がありま す。
MyList<T> クラスでは、 と operator != の 2 つの演算子を宣言します。 これらのオーバーライドされた演算子 は、これらの演算子を インスタンスに適用する式に新しい意味を与えます。 具体的には、 Equals メソッドを使用し て含まれている各オブジェクトを比較する際に、演算子が2つの MyList<T> インスタンスの等価性を定義します。次の例で は、 == 演算子を使用して 2 つの MyList<int> インスタンスを比較します。
     operator ==
  MyList
  
       最初の は True を出力します。これは、2つのリストに、同じ値を持つ同じ数のオブジェクトが同じ順序
Console.WriteLine
   で含まれているためです。 スタンスを参照するため、最初の
ファイナライザー
で が定義されていない場合は、 a と b が異なる MyList<int> イン は False を出力します。
MyList<T>
operator ==
 Console.WriteLine
"ファイナライザー" は、クラスのインスタンスを最終処理するために必要なアクションを実装するメンバーです。 通常、アンマネー ジド リソースを解放するにはファイナライザーが必要です。 ファイナライザーではパラメーターとアクセシビリティ修飾子を使用できま せん。また、ファイナライザーを明示的に呼び出すことはできません。 インスタンスのファイナライザーは、ガベージ コレクション中に 自動的に呼び出されます。 詳細については、ファイナライザーに関する記事を参照してください。
ガベージ コレクターは、オブジェクトを収集してファイナライザーを実行するタイミングを決定する際に広く許容されます。 具体的 には、ファイナライザーの呼び出しのタイミングは確定的ではなく、ファイナライザーは任意のスレッドで実行される可能性がありま す。 これらの理由およびそれ以外の理由のため、他のソリューションが実現できない場合にのみ、クラスはファイナライザーを実装 する必要があります。
using ステートメントは、オブジェクトを破棄するためのより適切な方法を提供します。 式
"式" は "オペランド" と "演算子" で構成されます。 式の演算子は、オペランドに適用する演算を表します。 演算子の例とし て、 + 、 - 、 * 、 / 、および new などがあります。 オペランドの例としては、リテラル、フィールド、ローカル変数、式などがあり ます。
式に複数の演算子が含まれている場合、演算子の "優先順位" によって、個々の演算子を評価する順序が制御されます。 たとえば、式 x + y * z の評価は x + (y * z) ですが、これは * 演算子が + 演算子より高い優先順位だからです。
1 つのオペランドが同じ優先順位を持つ 2 つの演算子の間で発生した場合、演算子の 結合性 によって演算が実行される順 序が決定されます。
代入演算子および null 合体演算子を除くすべてのバイナリ演算子は、"左からの結合"、つまり演算は左から右に実行さ れます。たとえば、x+y+z は (x+y)+z と評価されます。
代入演算子、null合体 ?? および ??= 演算子、および条件演算子 ?: は、"右からの結合"、つまり演算は右から左 に実行されます。たとえば、x=y=z は x=(y=z) と評価されます。
優先順位と結合性は、かっこを使用して制御することができます。 たとえば、 x + y * z は最初に y と z を掛け、そして 結果を x に足しますが、(x+y)*z では最初に x と y を足してから z を掛けます。
ほとんどの演算子は オーバーロードできます。 演算子をオーバーロードすると、ユーザー定義演算子の実装を、1 つまたは両 方のオペランドがユーザー定義のクラスまたは構造体型である演算子に指定することができます。
C# では、算術、論理、ビットごとやシフトの演算に加えて、等値や順序の比較を実行するための多数の演算子を提供してい ます。
優先度順に並べられた C# 演算子の完全な一覧については、「C# 演算子」を参照してください。 ステートメント
           MyList<int> a = new MyList<int>();
a.Add(1);
a.Add(2);
MyList<int> b = new MyList<int>();
b.Add(1);
b.Add(2);
Console.WriteLine(a == b);  // Outputs "True"
b.Add(3);
Console.WriteLine(a == b);  // Outputs "False"
 
 プログラムの処理は、"ステートメント" を使用して表されます。 C# はさまざまな種類のステートメントをサポートしており、その多く は埋め込みステートメントとして定義されています。
"ブロック" を使用すると、1 つのステートメントしか使用できないコンテキストで複数のステートメントを記述できます。 ブロック は、区切り記号 { と } の間に記述されたステートメントのリストから成ります。
"宣言ステートメント" は、ローカル変数および定数の宣言に使用します。 "式ステートメント"は、式の評価に使用します。ステートメントとして使用できる式には、メソッドの呼び出し、new 演算子
を使用したオブジェクトの割り当て、 = 演算子と複合代入演算子を使用した代入、 ++ 演算子と -- 演算子を使用し
たインクリメント演算とデクリメント演算、および await 式があります。
"選択ステートメント" は、式の値に基づいて、実行できる多数のステートメントから 1 つを選択するために使用します。 この グループには、 if および switch ステートメントが含まれています。
"繰り返しステートメント" は、埋め込みステートメントを繰り返し実行するために使用します。 このグループには、 while 、 do 、 for 、および foreach ステートメントが含まれています。
"ジャンプ ステートメント" は、制御を移すために使用します。 このグループには、 break 、 continue 、 goto 、 throw 、 return 、および yield ステートメントが含まれています。
try ... catch ステートメントはブロックの実行中に発生した例外をキャッチするために使用し、 try ... finally ステートメン
トは例外が発生したかどうかにかかわらず常に実行される終了処理コードを指定するために使用します。
checked および unchecked ステートメントは、整数型の算術演算および変換に対するオーバーフローチェックコンテキスト
を制御するために使用します。
lock ステートメントは、指定のオブジェクトに対する相互排他ロックを取得し、ステートメントを実行してからロックを解放す
るために使用します。
using ステートメントは、リソースを取得し、ステートメントを実行してからそのリソースを破棄するために使用します。
使用できるステートメントの種類を次に示します。
ローカル変数の宣言。 ローカル定数の宣言。 式ステートメント。
if ステートメント。
switch ステートメント。
while ステートメント。
do ステートメント。
for ステートメント。
foreach ステートメント。
break ステートメント。
continue ステートメント。
goto ステートメント。
return ステートメント。
yield ステートメント。
throw ステートメントと try ステートメント。 checked および unchecked ステートメント。 lock ステートメント。
using ステートメント。
                 
           配列、コレクション、および LINQ
C# と .NET には、さまざまなコレクション型が用意されています。 配列には、言語によって定義された構文があります。 ジェネリッ ク コレクション型は、System.Collections.Generic 名前空間に一覧表示されます。 特化されたコレクションには、スタック フ レーム上の連続メモリにアクセスするための System.Span<T>、およびマネージド ヒープ上の連続メモリにアクセスするための System.Memory<T> が含まれます。 配列、Span<T>、Memory<T> を含むコレクションはすべて、反復の統一原則を共 有します。 System.Collections.Generic.IEnumerable<T> インターフェイスを使用します。 この統合原則は、LINQ クエリま たはその他のアルゴリズムで任意のコレクション型を使用できることを意味します。 IEnumerable<T> を使用してメソッドを記述 します。それらのアルゴリズムは任意のコレクションで動作します。
配列
"*配列 _" とは、算出されたインデックスを介してアクセスされる多くの変数を含むデータ構造です。 配列に含まれる変数は配
列の "*要素*" とも呼ばれ、すべて同じ型です。 この型は配列の "*要素型*" と呼ばれます。
配列型は参照型で、配列変数の宣言は、配列インスタンスへの参照の領域を確保します。 実際の配列インスタンスは、 new 演算子を使用して実行時に動的に作成されます。 new 操作によって、新しい配列インスタンスの"*長さ*"が指定さ
れ、それはインスタンスの有効期間中は固定です。 配列の要素のインデックスは、 0 から Length - 1 までです。 new 演算 子は配列の要素を自動的に既定値に初期化します。たとえば、すべての数値型はゼロ、すべての参照型は null です。
次の例では、 int 要素の配列を作成し、その配列を初期化し、配列の内容を出力します。
     int[] a = new int[10];
for (int i = 0; i < a.Length; i++)
{
a[i] = i * i; }
for (int i = 0; i < a.Length; i++)
{
    Console.WriteLine($"a[{i}] = {a[i]}");
}
 この例では、"1 次元配列" を作成し、操作対象とします。 C# では、"*多次元配列*" もサポートされます。 配列型の次元数 は、配列型の "*ランク*" とも呼ばれ、配列型の角かっこ内のコンマの数に 1 を加えたものです。 次の例では、1 次元、2 次 元、および 3 次元の配列をそれぞれ割り当てます。
a1 配列は 10の要素、 a2 配列は 50(10×5)の要素、 a3 配列は 100(10×5×2)の要素を含みます。 配列の要 素型には、配列型を含む任意の型を指定できます。 配列型の要素を持つ配列は、"*ジャグ配列*" と呼ばれることがありま す。要素の配列の長さがすべて同じである必要がないからです。 次の例では、 int の配列の配列を割り当てます。
    int[] a1 = new int[10];
int[,] a2 = new int[10, 5];
int[,,] a3 = new int[10, 5, 2];
     int[][] a = new int[3][];
a[0] = new int[10];
a[1] = new int[5];
a[2] = new int[20];
 主な言語の領域
2021/03/06 • • Edit Online
 
    最初の行で3つの要素を持つ配列を作成しますが、各々は int[] 型で null 初期値を持ちます。次の行では、3つの要 素を、それぞれ異なる長さの配列インスタンスへの参照で初期化します。
new 演算子では、配列要素の初期値を、区切り記号 { と } のあいだに記述された式の一覧である"*配列初期化子*" を使用して指定することができます。次の例は、int[] を割り当て3つの要素で初期化します。
配列の長さは、 { と } の間にある式の数から推論されます。 配列の初期化をさらに短縮して、配列型の記述を省略するこ とができます。
前述の例はどちらも、次のコードと同等です。
foreach ステートメントを使用すると、任意のコレクションの要素を列挙できます。次のコードは、前の例の配列を列挙するも のです。
foreach ステートメントはIEnumerable<T>インターフェイスを使用しているので、任意のコレクションに対して機能します。 文字列補間
C# の "*文字列補間*" を使用すると、書式文字列内に結果が配置される式を定義することで、文字列の書式を設定できま す。 たとえば、次の例では、特定の日の気温を気象データのセットから出力しています。
補間文字列は $ トークンを使用して宣言されます。 文字列補間では、 { と } の間の式が評価され、結果が に 変換され、角かっこ内のテキストが式の文字列の結果に置き換えられます。 最初の式 内 にある : は、"_書式文字列*"を指定するものです。前の例では、それによって、日付を"MM-DD-YYYY"形式で出力する ように指定されています。
パターン マッチング
C# 言語には、オブジェクトの状態を照会し、その状態に基づいてコードを実行するための "*パターン マッチング _" 式が用意さ れています。型と、プロパティおよびフィールドの値を調べれば、実行されるアクションを特定することができます。 switch 式は、 パターン マッチングの主な式です。
  int[] a = new int[] { 1, 2, 3 };
   int[] a = { 1, 2, 3 };
     int[] t = new int[3];
t[0] = 1;
t[1] = 2;
t[2] = 3;
int[] a = t;
      foreach (int item in a)
{
    Console.WriteLine(item);
}
      Console.WriteLine($"The low and high temperature on {weatherData.Date:MM-DD-YYYY}");
Console.WriteLine($"    was {weatherData.LowTemp} and {weatherData.HighTemp}.");
// Output (similar to):
// The low and high temperature on 08-11-2020
//     was 5 and 30.
  string
 {weatherData.Date:MM-DD-YYYY}
 
  デリゲートおよびラムダ式
"*デリゲート型*" は、特定のパラメーター リストおよび戻り値の型を持つメソッドへの参照を表します。 デリゲートを使用すると、 変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。 デリゲートは、他の言語で検 出された関数ポインターの概念に似ています。 ただし、関数ポインターとは異なり、デリゲートはオブジェクト指向で、タイプ セー フです。
次の例では、 Function という名前のデリゲート型を宣言して使用します。
     delegate double Function(double x);
class Multiplier
{
    double _factor;
    public Multiplier(double factor) => _factor = factor;
    public double Multiply(double x) => x * _factor;
}
class DelegateExample
{
    static double[] Apply(double[] a, Function f)
    {
        var result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
}
    public static void Main()
    {
} }
double[] a = { 0.0, 0.5, 1.0 };
double[] squares = Apply(a, (x) => x * x);
double[] sines = Apply(a, Math.Sin);
Multiplier m = new Multiplier(2.0);
double[] doubles = Apply(a, m.Multiply);
    Function デリゲート型のインスタンスは、 引数を取得して double 値を返す任意のメソッドを参照できます。
Apply メソッドは、指定された を の要素に適用し、 double[] を結果とともに返します。 Main メソッ ドでは、 Apply は double[] に 3 つの異なる関数を適用するために使用されます。
デリゲートは、静的メソッド(前述の例の Square や Math.Sin など)またはインスタンスメソッド(前述の例の m.Multiply な ど) のいずれかを参照できます。 インスタンス メソッドを参照するデリゲートはまた、特定のオブジェクトを参照し、インスタンス メ ソッドがデリゲートから呼び出されると、そのオブジェクトは呼び出しで this になります。
宣言時に作成される "インライン メソッド" である匿名関数を使用してデリゲートを作成することもできます。 匿名関数では、周 囲のメソッドのローカル変数を確認できます。 次の例では、クラスは作成されません。
デリゲートでは、自身が参照するメソッドのクラスについては認識も考慮もしません。 重要なのは、参照されるメソッドがデリゲー トと同じパラメーターと戻り値の型を持つことです。
async / await
C#では、async と await の2つのキーワードを使用した非同期プログラムがサポートされます。メソッドが非同期であること を宣言するには、メソッド宣言に async 修飾子を追加します。 await 演算子からは、結果が完了するまで非同期に待機
double
 Function
  double[]
      double[] doubles = Apply(a, (double x) => x * 2.0);
 
     するようにコンパイラに対して指示が出されます。 制御が呼び出し元に返されます。そして、メソッドから、非同期処理の状態を 管理する構造体が返されます。 構造体は通常は System.Threading.Tasks.Task<TResult> ですが、awaiter パターンをサ ポートする任意の型とすることができます。 これらの機能を使用すると、その同期相手として読み取られるが非同期で実行され るコードを記述できます。 たとえば、次のコードでは Microsoft Docs のホームページがダウンロードされます。
    public async Task<int> RetrieveDocsHomePage()
{
    var client = new HttpClient();
    byte[] content = await client.GetByteArrayAsync("https://docs.microsoft.com/");
    Console.WriteLine($"{nameof(RetrieveDocsHomePage)}: Finished downloading.");
    return content.Length;
}
 この小さなサンプルは、非同期プログラミングの主な機能を示しています。
メソッドの宣言には、 async 修飾子が含まれています。
メソッドの本体では、 GetByteArrayAsync メソッドの戻り値に対して await が適用されます。
return ステートメント内で指定された型は、メソッドの Task<T> 宣言の型引数と一致しています ( Task を返すメソッド の場合は、引数なしで return ステートメントが使用されます)。
属性
C# プログラムにおける型、メンバー、およびその他のエンティティは、動作の特定の側面を制御する修飾子をサポートします。 た とえばメソッドのアクセシビリティは、 public 、 protected 、 internal 、および private 修飾子を使用して制御されます。 C# はこの機能を一般化し、宣言情報のユーザー定義型をプログラム エンティティに追加して実行時に取得できるようにしま す。 プログラムでは、"_ 属性*" を定義して使用することにより、この追加の宣言情報を指定します。
次の例では、プログラムのエンティティに配置して関連するドキュメントへのリンクを提供することができる HelpAttribute 属性を 宣言しています。
             public class HelpAttribute : Attribute
{
    string _url;
    string _topic;
    public HelpAttribute(string url) => _url = url;
    public string Url => _url;
    public string Topic
    {
        get => _topic;
        set => _topic = value;
    }
}
 すべての属性クラスは、.NET ライブラリによって提供される Attribute 基底クラスから派生します。 属性は、関連付けられた宣 言の直前に、名前を任意の変数とともに角かっこで囲んで与えることにより、適用できます。 属性の名前が Attribute 内で 終わる場合、属性の参照時に、名前のその部分は省略可能です。 たとえば、 HelpAttribute は次のように使用できます。
  
       この例では HelpAttribute を Widget クラスにアタッチしています。 別の HelpAttribute をクラス内の Display メソッドに 追加しています。 属性クラスのパブリック コンストラクターは、属性がプログラム エンティティにアタッチされたときに提供する必要が ある情報を制御します。その属性クラスのパブリックの読み取り/書き込みプロパティを参照することにより(Topic プロパティへの 参照のような)、追加情報を提供することができます。
属性によって定義されるメタデータは、実行時にリフレクションを使用して読み取り、操作することができます。 この手法を使用 して特定の属性が要求されると、プログラム ソースで提供される情報で属性クラスのコンストラクターが呼び出されます。 結果と して得られる属性インスタンスが返されます。 追加情報がプロパティを通じて提供された場合、属性インスタンスが返される前 に、これらのプロパティは指定された値に設定されます。
Widget クラスとその Display メソッドに関連付けられた HelpAttribute インスタンスを取得する方法を、次のコードサンプ ルに示します。
       Type widgetType = typeof(Widget);
object[] widgetClassAttributes = widgetType.GetCustomAttributes(typeof(HelpAttribute), false);
if (widgetClassAttributes.Length > 0)
{
    HelpAttribute attr = (HelpAttribute)widgetClassAttributes[0];
    Console.WriteLine($"Widget class help URL : {attr.Url} - Related topic : {attr.Topic}");
}
System.Reflection.MethodInfo displayMethod = widgetType.GetMethod(nameof(Widget.Display));
object[] displayMethodAttributes = displayMethod.GetCustomAttributes(typeof(HelpAttribute), false);
if (displayMethodAttributes.Length > 0)
{
    HelpAttribute attr = (HelpAttribute)displayMethodAttributes[0];
    Console.WriteLine($"Display method help URL : {attr.Url} - Related topic : {attr.Topic}");
}
 詳細情報
C# の詳細については、チュートリアルのいずれかをお試しください。
   [ ]
    [Help("https://docs.microsoft.com/dotnet/csharp/tour-of-csharp/features")]
public class Widget
{
    [Help("https://docs.microsoft.com/dotnet/csharp/tour-of-csharp/features",
    Topic = "Display")]
    public void Display(string text) { }
}
 
                            C# の概要に関するチュートリアルへようこそ。 これらのレッスンは、お使いのブラウザーで実行できる、対話形式のコードから開始 します。 これらの対話型レッスンを開始する前に、C# 101 ビデオ シリーズで C# の基本を学習できます。
最初のレッスンでは、小規模なコード スニペットを使用して C# の概念を説明します。 C# 構文の基礎や、文字列、数値、 ブール値などのデータ型の使用方法を学習します。 すべて対話形式で、数分のうちにコードを記述して実行することになりま す。 この最初のレッスンでは、プログラミングや C# 言語について事前の知識をお持ちでないことを前提としています。
これらのチュートリアルは、さまざまな環境で試すことができます。 学習する概念は同じです。 違いは、どのエクスペリエンスをご 希望かです。
ブラウザーの docs プラットフォームの場合: このエクスペリエンスでは、docs ページに実行可能な C# コードのウィンドウが埋め 込まれます。 ブラウザーで C# コードを記述し、実行します。
Microsoft Learn エクスペリエンス。 このラーニングパスには、C# の基本を学習するいくつかのモジュールが含まれています。 Binder での Jupyter。 Binder の Jupyter Notebook で C# コードを試すことができます。
ローカル コンピューター。 .NET Core SDK をオンラインで探索した後、お使いのマシンにダウンロードして、プログラムをビルド することができます。
Hello World レッスンに続くすべての入門用チュートリアルは、オンライン ブラウザー エクスペリエンスを使用するか独自のローカル 開発環境で使用できます。 各チュートリアルの最後に、次のレッスンをオンラインまたは自分のコンピューターのどちらで続行する かを決定します。 環境を設定し、ご利用のコンピューターで次のチュートリアルを続行するためのリンクがあります。
Hello World
「HelloWorld」チュートリアルでは、最も基本的なC#プログラムを作成します。 string 型とテキストの操作方法について学
習します。 Microsoft Learn または Binder での Jupyter でもパスを使用することができます。 C# における数値
C# における数値チュートリアルでは、コンピューターに数値が格納されるしくみとさまざまな数値型で計算するしくみが紹介され ます。 丸め処理の基礎と、C# で算術演算を実行する方法を学習します。 このチュートリアルもご利用のコンピューターでローカ ルで実行するために使用できます。
このチュートリアルは、Hello world レッスンを修了していることが前提条件となります。 分岐とループ
分岐とループ チュートリアルでは、変数に格納されている値に基づき、コード実行のさまざまなパスを選択することの基本を説明 します。 プログラムが決定して異なる操作を選択する上で基本となる、制御フローの基礎を学習します。 このチュートリアルもご 利用のコンピューターでローカルで実行するために使用できます。
このチュートリアルは、Hello world レッスンと C# における数値レッスンを修了していることが前提条件となります。 リスト コレクション
「リスト コレクション」レッスンでは、データのシーケンスを格納するリスト コレクション型について説明します。 項目の追加方法や 削除方法、項目の検索方法、リストを並べ替える方法を学習します。 さまざまな種類のリストを紹介します。 このチュートリア ルもご利用のコンピューターでローカルで実行するために使用できます。
 C#の概要 2021/03/06 • • Edit Online
 
    このチュートリアルは、上に挙げたレッスンを修了していることが前提条件となります。
101 個の LINQ サンプル
このサンプルには dotnet-try グローバルツールが必要です。 ツールをインストールし、try-samples リポジトリを複製すると、対 話形式で実行できる一連の 101 個のサンプルを通じて、統合言語クエリ (LINQ) を学習できます。 さまざまな方法でデータ シーケンスのクエリ、探索、および変換を行うことができます。

                コンピューターでチュートリアルを実行する最初の手順は、開発環境を設定することです。 次の方法のいずれかを選択します。
.NET CLI と好みのテキストまたはコード エディターを使用するには、.NET のチュートリアル「Hello World を 10 分で」を参照 してください。 このチュートリアルでは、Windows、Linux、または macOS で開発環境を設定するための手順について説明 しています。
.NET CLI と Visual Studio Code を使用するには、.NET SDK と Visual Studio Code をインストールします。
Visual Studio 2019 を使用するには、「チュートリアル: Visual Studio でシンプルな C# コンソール アプリを作成する」を参 照してください。
アプリケーション開発の基本フロー
これらのチュートリアルの手順は、.NET CLI を使用してアプリケーションを作成、構築、および実行していることを前提としていま す。 次のコマンドを使用します。
dotnet new を使用して、アプリケーションを作成します。 このコマンドによってアプリケーションに必要なファイルとアセットが 生成されます。C#の概要チュートリアルではすべて、アプリケーションの種類 console が使用されます。基本を習得した ら、他の種類のアプリケーションに応用できます。
を使用して、実行可能ファイルをビルドします。 を使用して、実行可能ファイルを実行します。
これらのチュートリアルに Visual Studio 2019 を使用している場合、チュートリアルでこれらの CLI コマンドのいずれかを実行す るように指示されたら、次の Visual Studio のメニューを選択します。
[ファイル] > [新規] > [プロジェクト] を選択して、アプリケーションを作成します。 [ビルド] > [ソリューションのビルド] を選択して、実行可能ファイルをビルドします。 [デバッグ] > [デバッグなしで開始] を選択して、実行可能ファイルを実行します。
チュートリアルを選択する 最初に次のいずれかのチュートリアルを選択します。
C# における数値
C# における数値チュートリアルでは、コンピューターに数値が格納されるしくみとさまざまな数値型で計算するしくみが紹介され
ます。 丸めの基本と C# を使用した数学計算方法を学習します。 このチュートリアルでは、Hello world レッスンを修了していることが前提条件となります。
分岐とループ
分岐とループ チュートリアルでは、変数に格納されている値に基づき、コード実行のさまざまなパスを選択することの基本を説明 します。 プログラムが決定して異なる操作を選択する上で基本となる、制御フローの基礎を学習します。
このチュートリアルでは、Hello world レッスンと C# における数値レッスンを修了していることが前提条件となります。
リスト コレクション
「リスト コレクション」レッスンでは、データのシーケンスを格納するリスト コレクション型について説明します。 項目の追加方法や
   dotnet build
 dotnet run
ローカル環境を設定する
2021/03/06 • • Edit Online
 
 削除方法、項目の検索方法、リストを並べ替える方法を学習します。 さまざまな種類のリストを紹介します。 このチュートリアルでは、上に挙げたレッスンを終了していることを前提としています。

    このチュートリアルでは、対話形式で C# の数値型について説明します。 少量のコードを記述したら、そのコードをコンパイルし て実行します。 このチュートリアルには、C# の数値と算術演算に関する一連のレッスンが含まれています。 これらのレッスンで は、C# 言語の基本を説明します。
前提条件
このチュートリアルでは、ローカル開発用にセットアップされたコンピューターがあることを想定しています。 Windows、Linux、また は macOS で、.NET CLI を使用してアプリケーションを作成、ビルド、実行できます。 Mac または Windows では、Visual Studio 2019 を使用できます。 セットアップの手順については、「ローカル環境をセットアップする」を参照してください。
整数の演算の確認
「numbers-quickstart」という名前のディレクトリを作成します。 それを現在のディレクトリにして、次のコマンドを実行します。
好みのエディターで Program.cs を開き、ファイルの内容を次のコードで置き換えます。
コマンド ウィンドウで「 dotnet run 」を入力し、このコードを実行します。 整数を使用した基本的な算術演算の1つを確認しました。 int 型は、整数を表します(ゼロ、正の整数、または負の整
数)。加算には + 記号を使用します。他の一般的な整数の算術演算には次のものがあります。
- :減算 * :乗算 / :除算
まずは、上記の各種演算を実行してみます。 c の値を記述した行の後に、次の数行を追加します。
  dotnet new console -n NumbersInCSharp -o .
     using System;
int a = 18;
int b = 6;
int c = a + b;
Console.WriteLine(c);
      // subtraction
c = a - b;
Console.WriteLine(c);
// multiplication
c = a * b;
Console.WriteLine(c);
// division
c = a / b;
Console.WriteLine(c);
  コマンド ウィンドウで「 dotnet run 」を入力し、このコードを実行します。
C# で整数と浮動小数点数を操作する 2021/03/06 • • Edit Online
 
 必要であれば、同じ行で複数の算術演算を記述することもできます。 例として   を試してみてくださ い。 変数と定数を混在させることができます。
最初の手順が完了しました。 次のセクションを始める前に、現在のコードを別の "メソッド" に移動しましょう。 メソッドは、グルー プ化された一連のステートメントであり、名前が付けられています。メソッドを呼び出すには、メソッドの名前の後に () を記述 します。 コードをメソッドに整理しておくと、新しい例の作業を簡単に始めることができます。 完成したコードは次のようになりま す。
    TIP
C# (または何らかのプログラミング言語) について詳しく学習するに従い、コードを記述する際にミスをすることもあるでしょう。 は、そうした エラーを発見して報告します。 エラー メッセージが含まれる場合は、例のコードと自分のウィンドウのコードをよく調べて、修正する箇所を見 つけます。 こうした実習が C# コードの構造を理解するのに役立ちます。
     using System;
WorkWithIntegers();
void WorkWithIntegers()
{
    int a = 18;
    int b = 6;
    int c = a + b;
    Console.WriteLine(c);
    // subtraction
    c = a - b;
    Console.WriteLine(c);
    // multiplication
    c = a * b;
    Console.WriteLine(c);
    // division
    c = a / b;
    Console.WriteLine(c);
}
  WorkWithIntegers(); の行でメソッドを呼び出しています。その後のコードでメソッドが宣言され、定義されています。 演算の順序の確認
WorkingWithIntegers() の呼び出しをコメントアウトします。こうしておくと、このセクションの作業を進めるにあたって出力が すっきりします。
C#では、// の後ろがコメントになります。コードとしては実行せずにソースコード内に残したい任意のテキストを、コメントに することができます。コンパイラは、コメントから実行可能コードを生成しません。 WorkWithIntegers() はメソッドであるため、コ メントアウトする必要があるのは 1 行だけです。
C# 言語は、数学で学んだ規則と同じ規則で各演算の優先順位を定義します。 乗算と除算は、加算と減算よりも優先され ます。 WorkWithIntegers() の呼び出しの後に次のコードを追加し、 dotnet run を実行して、それを調べます。
   //WorkWithIntegers();
     c = a + b - 12 * 17;
 
  出力を見ると、加算の前に乗算が実行されていることがわかります。
最初に実行したい演算を囲むように丸かっこを追加することで、演算の順序を変えることができます。 次の行を追加して、もう 一度実行します。
さまざまな演算を多数組み合わせて、他にも試してみましょう。 次の行のようなものを何か追加します。 もう一度 dotnet run を実行してください。
整数について面白い動作をしていることに気づいたでしょうか。 結果に小数点や小数部分が含まれると予想される場合でも、 整数の除算は常に整数の結果を算出します。
この動作を確認できない場合は、次のコードを試してください。
もう一度 dotnet run を入力して結果を確認します。
続行する前に、このセクションで記述したコードをすべて新しいメソッドに移します。新しいメソッドを OrderPrecedence としま す。 コードは次のようになります。
    d = (a + b) * c;
Console.WriteLine(d);
      d = (a + b) - 6 * c + (12 * 4) / 3 + 12;
Console.WriteLine(d);
     int e = 7;
int f = 4;
int g = 3;
int h = (e + f) / g;
Console.WriteLine(h);
      int a = 5;
int b = 4;
int c = 2;
int d = a + b * c;
Console.WriteLine(d);
 
    整数の有効桁数と制限の確認 この最後のサンプルでは、整数の除算における結果の切り捨てについて確認します。modulo演算子(% 文字)を使用し
て、剰余 を得ることができます。 OrderPrecedence() のメソッド呼び出しの後で、次のコードを試します。
C#の整数型は算術における整数ともう1つ異なる点があります。それは int 型には最小値と最大値の制限があるということ です。 次のコードを追加して、それらの制限を確認します。
     int a = 7;
int b = 4;
int c = 3;
int d = (a + b) / c;
int e = (a + b) % c;
Console.WriteLine($"quotient: {d}");
Console.WriteLine($"remainder: {e}");
   using System;
// WorkWithIntegers();
OrderPrecedence();
void WorkWithIntegers()
{
    int a = 18;
    int b = 6;
    int c = a + b;
    Console.WriteLine(c);
    // subtraction
    c = a - b;
    Console.WriteLine(c);
    // multiplication
    c = a * b;
    Console.WriteLine(c);
    // division
    c = a / b;
    Console.WriteLine(c);
}
void OrderPrecedence()
{
    int a = 5;
    int b = 4;
    int c = 2;
    int d = a + b * c;
    Console.WriteLine(d);
    d = (a + b) * c;
    Console.WriteLine(d);
    d = (a + b) - 6 * c + (12 * 4) / 3 + 12;
    Console.WriteLine(d);
    int e = 7;
    int f = 4;
    int g = 3;
    int h = (e + f) / g;
    Console.WriteLine(h);
}

  計算によってこれらの制限を超える値が作られると、アンダーフロー または オーバーフロー の状態になります。 計算の結果が 1 つの制限からもう 1 つの制限に折り返されているように見えます。 次の 2 行を追加して、例を確認します。
計算の結果が最小値の (負の) 整数に極めて近いことに注目してください。 これは min + 2 と同じです。 加算演算が許容さ れた整数値を オーバーフロー しました。 整数がオーバーフローして最大値から最小値に ”折り返され” たため、計算結果が非 常に大きな負の値になっています。
他にもさまざまな制限や有効桁数を持つ数値型があり、 int 型がご自分のニーズと合わない場合は、そちらも使用できます。 次に、その他の型について説明します。 次のセクションを始める前に、このセクションで記述したコードを別のメソッドに移しま す。これに TestLimits という名前を付けます。
double 型の処理
double 数値型は、倍精度浮動小数点数を表します。こうした用語を初めて見た人もいるかもしれません。浮動小数点 数は、非常に大きな、または非常に小さな、整数ではない数値を表すのに役立ちます。 倍精度 は、値の保管に使用される 二進数の数値を表す相対語です。 倍精度 数値は、単精度 に比べ、二進数の数値が 2 倍になります。 最近のコンピュー ターでは、単精度よりも倍精度の数値を使用する方が一般的です。 単精度 数値は、 float キーワードを使用して宣言さ れます。 確認してみましょう。 次のコードを追加して結果を確認します。
計算結果に商の小数部分が含まれていることに注目してください。 double 型を使用して、もう少し複雑な式を試します。
double 値は整数値よりも範囲が大きくなります。 これまでに記述したコードの下で、次のコードを試します。
これらの値は指数表記で出力されます。 E の左側は有効数字です。右側の数値は指数であり、10の累乗です。算術に おける 10 進数と同じように、C# における double には丸め誤差が発生することがあります。 次のコードを試してみましょう。
    int what = max + 3;
Console.WriteLine($"An example of overflow: {what}");
        double a = 5;
double b = 4;
double c = 2;
double d = (a + b) / c;
Console.WriteLine(d);
     double e = 19;
double f = 23;
double g = 8;
double h = (e + f) / g;
Console.WriteLine(h);
     double max = double.MaxValue;
double min = double.MinValue;
Console.WriteLine($"The range of double is {min} to {max}");
     double third = 1.0 / 3.0;
Console.WriteLine(third);
 0.3 の循環小数は 1/3 と完全に同じではありません。
   int max = int.MaxValue;
int min = int.MinValue;
Console.WriteLine($"The range of integers is {min} to {max}");
 
        課題
 double 型を使用して、大きい値や小さい値、乗算、除算などの計算してみましょう。もっと複雑な計算を試してみてくださ い。しばらく試してみたあとは、これまでに記述したコードを新しいメソッドに移します。新しいメソッドに WorkWithDoubles とい う名前を付けます。
10 進型を扱う C#の基本的な数値型である整数とdoubleについて見てきました。もう1つ知っておくべき型として、decimal 型がありま
す。 decimal 型は、 double 型よりも範囲は小さいですが、有効桁数が大きい型です。 では、始めましょう。
double 型よりも範囲が小さいことに注目してください。次のコードを実行すると、decimal型では有効桁数がより大きいことを 確認できます。
数値の末尾の M は、定数では decimal 型を使用する必要があることを示しています。それ以外の場合、コンパイラは double 型を想定します。
decimal 型を使用した演算では、小数点の右側の桁数がより多いことに注目してください。
課題
さまざまな数値型を確認したので、次は半径が 2.50 センチメートルの円の面積を計算するコードを記述してみます。 円の面 積は、半径の 2 乗 x 円周率です。 ヒント: .NET には Math.PI という円周率の定数があり、その値を使用できます。 Math.PI は、 名前空間で宣言されているすべての定数と同様に、 double 値です。 そのため、この課題では decimal 値の代わりに を使用してください。
答えは 19 と 20 の間になるはずです。 GitHub にある完成版のサンプル コードで答えを確認できます。 お好みで他の数式を試してみてください。
これで "C# の数値" に関するクイックスタートは終了です。 続けて独自の開発環境で分岐とループのクイックスタートに進むこと ができます。
C# の数値の詳細については、次の記事で学習できます。
整数数値型 浮動小数点数値型 組み込みの数値変換
        decimal min = decimal.MinValue;
decimal max = decimal.MaxValue;
Console.WriteLine($"The range of the decimal type is {min} to {max}");
      double a = 1.0;
double b = 3.0;
Console.WriteLine(a / b);
decimal c = 1.0M;
decimal d = 3.0M;
Console.WriteLine(c / d);
       NOTE
文字 M は、 double キーワードと decimal キーワードの間で最も視覚的に区別される文字として選択されています。
      System.Math
 double

    このチュートリアルでは、変数を調べ、その変数に基づいて実行パスを変更するコードを記述する方法について説明します。 C# コードを記述し、コードをコンパイルおよび実行して結果を確認します。 チュートリアルには、C# における分岐構造とループ構造 を確認する一連のレッスンが含まれています。 これらのレッスンでは、C# 言語の基本を説明します。
前提条件
このチュートリアルでは、ローカル開発用にセットアップされたコンピューターがあることを想定しています。 Windows、Linux、また は macOS で、.NET CLI を使用してアプリケーションを作成、ビルド、実行できます。 Mac と Windows では、Visual Studio 2019 を使用できます。 セットアップの手順については、「ローカル環境をセットアップする」を参照してください。
if ステートメントを使用した条件判定 「branches-tutorial」という名前のディレクトリを作成します。 それを現在のディレクトリにして、次のコマンドを実行します。
このコマンドにより、現在のディレクトリに新しい .NET コンソール アプリケーションが作成されます。 好みのエディターで Program.cs を開き、内容を次のコードで置き換えます。
コンソール ウィンドウで「 dotnet run 」と入力し、このコードを試します。 "答えは 10 を超えています" というメッセージが コンソー ルに出力されるはずです。合計が10未満になるように b の宣言を変更します。
もう一度「 dotnet run 」を入力します。 計算結果が 10 未満であるため、何も出力されません。 判定中の 条件 が false に なっています。 if ステートメントの考えられる分岐の1つであるtrue分岐のみを記述したため、実行すべきコードがありませ ん。
この最初のサンプルは、 if とブール型の機能を示しています。 ブール値 は、 true または false という 2 つの値のいずれか を持つことができる変数です。C#ではブール変数の専用の型として bool を定義しています。 if ステートメントは、bool
  dotnet new console -n BranchesAndLoops -o .
     using System;
int a = 5;
int b = 6;
if (a + b > 10)
    Console.WriteLine("The answer is greater than 10.");
    int b = 3;
      TIP
C# (または何らかのプログラミング言語) について詳しく学習するに従い、コードを記述する際にミスをすることもあるでしょう。 コンパイラは、エ ラーを発見して報告します。 エラーの出力とそのエラーを生成したコードをよく確認してください。 通常、コンパイラ エラーは問題を発見する のに役立ちます。
 分岐およびループ ステートメントを使用した条
件付きロジックについて説明します
2021/03/06 • • Edit Online
 
 の値を確認します。 値が true の場合、 if に続くステートメントを実行します。 それ以外の場合はスキップします。 条件を 確認してその条件に基づいてステートメントを実行するというこのプロセスは機能的です。
if と else を組み合わせた使用 true分岐とfalse分岐で別々のコードを実行するには、条件がfalseのときに実行する else 分岐を作成します。 else
分岐を試してみてください。 次のコードの最後の 2 行を追加します (最初の 4 行は既にあるはずです)。
else キーワードに続くステートメントは、判定中の条件が false のときにのみ実行されます。 if と else をブール条件と 組み合わせれば、 true と false の条件を両方処理するのに必要な機能がすべて整います。
インデントは重要ではないため、条件に基づいて実行するブロック内に 1 つ以上のステートメントがある場合には、 { と } を 使用して示します。通常、C#プログラマーは if と else の句にはこの中かっこを使用します。次の例は、作成したものと同 じ内容です。 上のコードを、次のコードに一致するように変更します。
    int a = 5;
int b = 3;
if (a + b > 10)
    Console.WriteLine("The answer is greater than 10");
else
    Console.WriteLine("The answer is not greater than 10");
     IMPORTANT
if と else のステートメント内にあるインデントは、人が読みやすいようにするためのものです。 C# 言語はインデントや空白文字を重要 なものとして扱いません。 if や else のキーワードに続くステートメントは、条件に基づいて実行されます。 このチュートリアルのすべての サンプルでは、一般的な記述方法に従い、ステートメントの制御フローに基づいて行にインデントを挿入しています。
     int a = 5;
int b = 3;
if (a + b > 10)
{
    Console.WriteLine("The answer is greater than 10");
}
else {
    Console.WriteLine("The answer is not greater than 10");
}
     TIP
このチュートリアルの残りの箇所では、一般に認められている記述方法に従って、すべてのコード サンプルで中かっこを使用しています。
 さらに複雑な条件を判定できます。 これまでに記述したコードの後に、次のコードを追加します。

  == シンボルは、"同等性"をテストします。 == を使用すると、同等性のテストが a = 5 で確認した割り当てと区別されま す。
&& は"and"(および)を表します。これは、true分岐でステートメントを実行するには、両方の条件がtrueになる必要がある ことを意味しています。 また、これらの例では、ステートメントが { と } で囲まれていれば、各条件分岐に複数のステートメン トを持つことができることを示しています。 || を使用して"or"(または)を表すこともできます。これまでに記述したコードの下 に、次のコードを追加します。
    if ((a + b + c > 10) || (a == b))
{
    Console.WriteLine("The answer is greater than 10");
    Console.WriteLine("Or the first number is equal to the second");
}
else {
    Console.WriteLine("And the first number is not equal to the second");
}
Console.WriteLine("The answer is not greater than 10");
 a 、 b 、および c の値を変更し、探索する && と || を切り替えます。 && 演算子と || 演算子がどのように機能するか をより深く理解できます。
最初の手順が完了しました。 次のセクションを開始する前に、現在のコードを別のメソッドに移動してみましょう。 移動しておく と、新しい例で作業を開始するときに楽になります。 ExploreIf() というメソッドに既存のコードを入れます。それをプログラム の先頭で呼び出します。 それらの変更を終えると、コードは次のようになるはずです。
    int c = 4;
if ((a + b + c > 10) && (a == b))
{
    Console.WriteLine("The answer is greater than 10");
    Console.WriteLine("And the first number is equal to the second");
}
else {
    Console.WriteLine("Or the first number is not equal to the second");
}
Console.WriteLine("The answer is not greater than 10");
 
     ExploreIf() の呼び出しをコメントアウトします。こうしておくと、このセクションの作業を進めるにあたって出力がすっきりしま す。
C#では、// の後ろがコメントになります。コードとしては実行せずにソースコード内に残したい任意のテキストを、コメントに することができます。 コンパイラは、コメントから実行可能コードを生成しません。
ループを使用した処理の繰り返し
このセクションではループを使用してステートメントを繰り返し実行します。 ExploreIf の呼び出しの後に、次のコードを追加 します。
  //ExploreIf();
      int counter = 0;
while (counter < 10)
{
    Console.WriteLine($"Hello World! The counter is {counter}");
counter++; }
   using System;
ExploreIf();
void ExploreIf()
{
    int a = 5;
    int b = 3;
    if (a + b > 10)
    {
        Console.WriteLine("The answer is greater than 10");
    }
else {
        Console.WriteLine("The answer is not greater than 10");
    }
    int c = 4;
    if ((a + b + c > 10) && (a > b))
    {
        Console.WriteLine("The answer is greater than 10");
        Console.WriteLine("And the first number is greater than the second");
    }
else {
        Console.WriteLine("Or the first number is not greater than the second");
    }
    if ((a + b + c > 10) || (a > b))
    {
        Console.WriteLine("The answer is greater than 10");
        Console.WriteLine("Or the first number is greater than the second");
    }
else {
        Console.WriteLine("And the first number is not greater than the second");
    }
}
Console.WriteLine("The answer is not greater than 10");
Console.WriteLine("The answer is not greater than 10");

 while ステートメントは、条件を確認して while に続くステートメントまたはステートメントブロックを実行します。条件が false になるまで、条件の確認とステートメントの実行を繰り返します。
この例では、もう1つ新しい演算子が使用されています。 counter 変数のあとにある ++ は、インクリメント演算子です。 counter の値に1を足し、その値を counter 変数に格納します。
while ループは、条件を判定してから while に続くコードを実行します。 do ... while ループは、最初にコードを実行して からその条件を確認します。 do while ループを次のコードで示します。
この do ループと先述の while ループの出力は同じ結果になります。 for ループの処理
C# では for ループがよく使用されます。 次のコードを試してみましょう。
前のコードは、既に使用した while ループや do ループと同じ機能を持っています。 for ステートメントは3つの部分に分 かれてその機能を制御します。
最初の部分は、for 初期化子 です。 int index = 0; は、 index がループ変数であることを宣言し、その初期値を 0 に 設定しています。
2 つ目の部分は、for 条件 です。 index < 10 は、counter の値が 10 未満である間は for ループが実行され続けることを 宣言しています。
最後の部分は、for 反復子 です。 index++ は、 for ステートメントに続くブロックを実行したあとにループ変数を変更する方 法を指定しています。ここでは、ブロックが実行されるごとに index が1ずつ増加するよう指定しています。
自分で試してみてください。 次のバリエーションをそれぞれ試してみます。
初期化子を変更して別の値で開始する。 条件を変更して別の値で停止する。
完了したら次に進み、学習したことを使用して自分でいくつかのコードを記述してみましょう。
このチュートリアルでは説明していないループ ステートメントが1つあります。 foreach ステートメントです。 foreach ステートメン トは、一連の項目内のすべての項目に対してステートメントを繰り返します。 これは、"コレクション" で最もよく使用されます。次 のチュートリアルで説明します。
       IMPORTANT
コードを実行したときに while のループ条件が false に切り替わることを確認してください。 それ以外の場合は、プログラムが終了すること のない を作成します。 CTRL-C またはその他の方法でプログラムを強制的に終了する必要があるため、このサンプルでは実践しませ ん。
     int counter = 0;
do
{
    Console.WriteLine($"Hello World! The counter is {counter}");
    counter++;
} while (counter < 10);
     for (int index = 0; index < 10; index++)
{
    Console.WriteLine($"Hello World! The index is {index}");
}
      
        入れ子になったループの作成
while 、 do 、または for ループを別のループ内に入れ子にして、外側のループの各項目を内側のループの各項目と組み合 わせて使用してマトリックスを作成することができます。 行と列を表す一連の英数字ペアを作成してみましょう。
1つの for ループで行を生成できます。
別のループで列を生成できます。
一方のループをもう一方のループ内に入れ子にして、ペアを形成することができます。
外側のループは、内側のループが完全に実行されるたびに 1 回インクリメントされることがわかります。 行と列の入れ子を逆に し、自分で変更を確認します。終わったら、このセクションのコードを ExploreLoops() というメソッドに入れます。
分岐とループの組み合わせ
C#言語における if ステートメントとループ構造を見てきました。では、1から20の整数のうち3で割り切れる数の合計を求
める C# コードを記述できるか確認してみましょう。 次にいくつかヒントを示します。
% 演算子は、除算演算の剰余を算出します。
if ステートメントは、数を合計に入れるべきかどうか確認する条件を作ります。
for ループは、1から20までのすべての数を1つずつ確認する一連の手順を繰り返すのに役立ちます。
ご自身で試してみてください。 そして自分がとった方法を確認してください。 答えは 63 になるはずです。 GitHub で完成版の コードを表示すると、考えられる答えの 1 つを確認できます。
これで "分岐とループ" に関するチュートリアルは終了です。 続けて独自の開発環境で配列とコレクションのチュートリアルに進むことができます。 次の記事でこれらの概念の詳細を学習できます。
if と else ステートメント while ステートメント do ステートメント
for ステートメント
    for (int row = 1; row < 11; row++)
{
    Console.WriteLine($"The row is {row}");
}
     for (char column = 'a'; column < 'k'; column++)
{
    Console.WriteLine($"The column is {column}");
}
     for (int row = 1; row < 11; row++)
{
    for (char column = 'a'; column < 'k'; column++)
    {
        Console.WriteLine($"The cell is ({row}, {column})");
    }
}
  
         このチュートリアルでは、C# 言語の概要と List<T> クラスの基本を説明します。 前提条件
このチュートリアルでは、ローカル開発用にセットアップされたコンピューターがあることを想定しています。 Windows、Linux、また は macOS で、.NET CLI を使用してアプリケーションを作成、ビルド、実行できます。 Mac と Windows では、Visual Studio 2019 を使用できます。 セットアップの手順については、「ローカル環境をセットアップする」を参照してください。
基本のリストの例
list-tutorial という名前のディレクトリを作成します。 それを現在のディレクトリとし、 dotnet new console を実行します。
好みのエディターで Program.cs を開き、既存のコードを次のコードで置き換えます。
     using System;
using System.Collections.Generic;
var names = new List<string> { "<name>", "Ana", "Felipe" };
foreach (var name in names)
{
    Console.WriteLine($"Hello {name.ToUpper()}!");
}
   <name> をユーザー名で置き換えます。 Program.cs を保存します。 コンソール ウィンドウに「 dotnet run 」と入力して試しま す。
文字列のリストを作成し、そのリストに 3 つの名前を追加し、それらの名前をすべて大文字で出力しました。 先のチュートリアル で学習した概念を使用して、リストをループしています。
名前を表示するコードは、文字列補間機能を使用します。 string の前に文字 $ を配置すると、文字列宣言にC#コード を埋め込むことができます。 実際の文字列は、生成する値でその C# コードを置き換えます。 この例では、ToUpper メソッドを 呼び出したため、文字列は {name.ToUpper()} をそれぞれの名前に置き換え、文字を大文字に変換しています。
続けて確認していきましょう。
リスト コンテンツを変更する
作成したコレクションは List<T> 型を使用します。 この型は、要素のシーケンスを格納します。 要素の型を山かっこの内側で 指定します。
この List<T> 型の重要な点は増減が可能で、要素を追加したり削除したりできることです。 このコードを、プログラムの最後に 追加します。
  リスト型を使用したデータ コレクションの管理
について説明します
2021/03/06 • • Edit Online
 
     さらに 2 つの名前をリストの末尾に追加しました。 また、1 つを削除しました。 ファイルを保存し、「 dotnet run 」と入力して試 します。
List<T>を使用すると、インデックスでも個々の項目を参照できます。リスト名に続く [ と ] のトークンの間にインデックスを 記述します。 C# では、初めのインデックスには 0 を使用します。 追加したコードのすぐ下に次のコードを追加して試します。
リストの末尾を越えてインデックスにアクセスすることはできません。 インデックスは 0 から始まるため、有効なインデックスの最大 値はリスト内の項目の数より 1 小さくなることに注意してください。 Count プロパティを使用すれば、リストの長さを確認できま す。 次のコードを、プログラムの最後に追加します。
ファイルを保存し、もう一度「 dotnet run 」と入力して結果を確認します。 リストを検索して並び替える
サンプルでは比較的小さいリストを使用していますが、ご利用のアプリケーションでは、より多くの (場合によっては何千もの) 要 素が含まれるリストを作成することもよくあるかもしれません。 そうした大規模なコレクションの中から要素を見つけるには、別々 の項目をリストで検索する必要があります。 IndexOf メソッドは項目を検索し、その項目のインデックスを返します。 項目がリス トにない場合、 IndexOf は -1 を返します。 次のコードを、プログラムの最後に追加します。
    Console.WriteLine($"My name is {names[0]}");
Console.WriteLine($"I've added {names[2]} and {names[3]} to the list");
   Console.WriteLine($"The list has {names.Count} people in it");
       var index = names.IndexOf("Felipe");
if (index == -1)
{
    Console.WriteLine($"When an item is not found, IndexOf returns {index}");
}
else {
    Console.WriteLine($"The name {names[index]} is at index {index}");
}
index = names.IndexOf("Not Found");
if (index == -1)
{
    Console.WriteLine($"When an item is not found, IndexOf returns {index}");
}
else {
    Console.WriteLine($"The name {names[index]} is at index {index}");
}
 同じように、リスト内の項目を並び替えできます。 Sort メソッドは、リスト内のすべての項目を正規順序 (文字列の場合はアル ファベット順) で並び替えます。 次のコードを、プログラムの最後に追加します。
   Console.WriteLine();
names.Add("Maria");
names.Add("Bill");
names.Remove("Ana");
foreach (var name in names)
{
    Console.WriteLine($"Hello {name.ToUpper()}!");
}
 
   ファイルを保存し、「 dotnet run 」と入力してこの最新バージョンを試します。
次のセクションを開始する前に、現在のコードを別のメソッドに移動してみましょう。 移動しておくと、新しい例で作業を開始す るときに楽になります。 記述したすべてのコードを、 WorkWithStrings() という新しいメソッドに収めます。 プログラムの先頭で、 そのメソッドを呼び出します。 完成したコードは次のようになります。
    names.Sort();
foreach (var name in names)
{
    Console.WriteLine($"Hello {name.ToUpper()}!");
}
 
     その他の型のリスト
ここまでは、リスト内で string 型を使用してきました。別の型を使用してList<T>を作成してみましょう。数値のセットを作 成します。
プログラムで WorkWithStrings() を呼び出している場所の後に、以下を追加します。
    var fibonacciNumbers = new List<int> {1, 1};
   using System;
using System.Collections.Generic;
WorkWithString();
void WorkWithString()
{
    var names = new List<string> { "<name>", "Ana", "Felipe" };
    foreach (var name in names)
    {
        Console.WriteLine($"Hello {name.ToUpper()}!");
    }
    Console.WriteLine();
    names.Add("Maria");
    names.Add("Bill");
    names.Remove("Ana");
    foreach (var name in names)
    {
        Console.WriteLine($"Hello {name.ToUpper()}!");
    }
    Console.WriteLine($"My name is {names[0]}");
    Console.WriteLine($"I've added {names[2]} and {names[3]} to the list");
    Console.WriteLine($"The list has {names.Count} people in it");
    var index = names.IndexOf("Felipe");
    if (index == -1)
    {
        Console.WriteLine($"When an item is not found, IndexOf returns {index}");
    }
else {
        Console.WriteLine($"The name {names[index]} is at index {index}");
    }
    index = names.IndexOf("Not Found");
    if (index == -1)
    {
        Console.WriteLine($"When an item is not found, IndexOf returns {index}");
    }
else {
        Console.WriteLine($"The name {names[index]} is at index {index}");
    }
    names.Sort();
    foreach (var name in names)
    {
        Console.WriteLine($"Hello {name.ToUpper()}!");
    }
}

   これにより整数のリストが作成され、最初の 2 つの整数が値 1 に設定されます。 これらは、数列の 1 つである フィボナッチ数列 の最初の 2 つの値です。 次のフィボナッチ数はそれぞれ、その直前の 2 つの数値の合計を取得することによって得られます。 こ のコードを追加します。
ファイルを保存し、「 dotnet run 」と入力して結果を確認します。
課題
このレッスンと以前のレッスンの中から、いくつかの概念を理解できているかどうかを確認してみましょう。 ここまでフィボナッチ数を 使用して作成してきたコードを使ってください。 シーケンスの最初の 20 個の数を生成するコードを記述してみましょう。 (ヒント: フィボナッチ数の 20 番目の数は 6765 です。)
課題完了
GitHub にある完成したサンプル コードを表示することで、ソリューションの例を確認できます。
ループの繰り返しごとに、リストの最後の 2 つの整数を取得して合計し、その値をリストに追加しています。 このループは、20 個 の項目がリストに追加されるまで繰り返されます。
おつかれさまでした。リストについてのチュートリアルはこれで終了です。 追加のチュートリアルを、ご自分の開発環境で続けて行 うことができます。
List 型の使用方法の詳細については、コレクションに関する.NET基礎の記事を参照してください。その他の多くのコレクショ ン型についても学習できます。
    var previous = fibonacciNumbers[fibonacciNumbers.Count - 1];
var previous2 = fibonacciNumbers[fibonacciNumbers.Count - 2];
fibonacciNumbers.Add(previous + previous2);
foreach (var item in fibonacciNumbers)
    Console.WriteLine(item);
      TIP
このセクションにだけ集中したいときは、 WorkingWithStrings(); を呼び出すコードはコメント アウトしてかまいません。 // WorkingWithStrings(); のように、呼び出しの前に / 文字を 2 つ記述します。
   
                C# のチュートリアルへようこそ。 まずは、お使いのブラウザーで実行できる、対話形式のレッスンを開始します。 後のチュートリア ルやより高度なチュートリアルでは、.NET の開発ツールを操作してコンピューター上で C# プログラムを作成する方法について説 明します。
C# の新機能を詳しく学習する
文字列補間: 文字列補間を使用して C# で書式設定された文字列を作成する方法について説明します。 Null 許容参照型: Null 許容参照型を使って null 参照の意図を表現する方法について説明します。
Null 許容参照型を利用するようプロジェクトを更新する: null 許容参照型を利用するよう既存のプロジェクトをアップグレー ドする手法について説明します。
パターン マッチングを使ってデータの機能を拡張する: パターン マッチングを使って、型をそのコア機能を超えて拡張する方法 を示します。
インデックスと範囲を使用してデータ シーケンスを操作する: 連続したデータ コンテナーの単一の要素または範囲にアクセス するための新しい便利な構文を説明します。
全般的なチュートリアル
次のチュートリアルで、.NET Core を使用して C# プログラムをビルドできます。
コンソール アプリケーション: コンソール I/O、コンソール アプリケーションの構造、およびタスクベースの非同期プログラミング モ デルの基礎について説明します。
REST クライアント: Web 通信、JSON シリアル化、および C# 言語でのオブジェクト指向の機能について説明します。
C# と .NET での継承: C# における継承について説明します。基本クラス、抽象基本クラス、および派生クラスを定義するた めの継承の使用が含まれます。
LINQ の操作: LINQ の多くの機能と、それをサポートする言語要素について説明します。 属性の使用: C# における属性の作成方法と使用方法について説明します。
文字列補間チュートリアルでは、文字列に値を挿入する方法について説明します。 埋め込みの C# 式が含まれる挿入文 字列の作成方法と、結果の文字列が生じる式の結果のテキスト表示の制御方法を学ぶことになります。 このチュートリアル もご利用のコンピューターでローカルで実行するために使用できます。
C# のチュートリアル 2021/03/06 • • Edit Online
 
    このチュートリアルでは、コンソール アプリケーションを構築し、C# 言語に含まれるオブジェクト指向の基本的な機能について確 認します。
前提条件
このチュートリアルでは、ローカル開発用にセットアップされたコンピューターがあることを想定しています。 Windows、Linux、また は macOS で、.NET CLI を使用してアプリケーションを作成、ビルド、実行できます。 Windows では、Visual Studio 2019 を 使用できます。 セットアップの手順については、「ローカル環境をセットアップする」を参照してください。
アプリケーションを作成する
ターミナル ウィンドウで、「classes」という名前のディレクトリを作成します。 ここにアプリケーションを構築します。 このディレクトリに 移動し、コンソール ウィンドウで「 dotnet new console 」と入力します。 このコマンドにより、アプリケーションが作成されます。 Program.cs を開きます。 内容は次のようになります。
     using System;
namespace classes
{
    class Program
    {
} }
static void Main(string[] args)
{
    Console.WriteLine("Hello World!");
}
 このチュートリアルでは、銀行口座を表す新しい型を作成します。 通常、開発者は各クラスを別々のテキスト ファイルで定義し ます。 この方法なら、プログラムのサイズが大きくなっても管理が容易です。 classes ディレクトリに「BankAccount.cs」という名 前の新しいファイルを作成します。
このファイルには、"銀行口座" の定義が含まれます。 オブジェクト指向プログラミングを使用して "*クラス**" の形式で型を作 成することにより、コードを整理します。これらのクラスには、特定のエンティティを表すコードが含まれています。 BankAccount クラスは銀行口座を表します。 コードでは、メソッドとプロパティを使用した特定の操作を実装します。 このチュートリアルでは、 銀行口座は次の動作をサポートします。
1. 銀行口座を一意に特定する 10 桁の数字をサポートしています。
2. 口座の名前、または所有者の名前を格納する文字列をサポートしています。 3. 残高を取得できます。
4. 預金を許可します。
5. 引き出しを許可します。
6. 初期残高は正の値である必要があります。
7. 引き出しによって残高が負の値になることはありません。
 銀行口座の型を定義する
クラスおよびオブジェクトを使用したオブジェク
ト指向プログラミングについて確認します
2021/03/08 • • Edit Online
 
 動作を定義するクラスの基本を作成することから開始できます。 File:New コマンドを使用して、新しいファイルを作成します。 BankAccount.cs という名前を付けます。 BankAccount.cs ファイルに次のコードを追加します。
    using System;
namespace classes
{
    public class BankAccount
    {
} }
public string Number { get; }
public string Owner { get; set; }
public decimal Balance { get; }
public void MakeDeposit(decimal amount, DateTime date, string note)
{
}
public void MakeWithdrawal(decimal amount, DateTime date, string note)
{
}
  先に進む前に、構築したものを確認してみましょう。 namespace 宣言は、コードを論理的に整理する方法を提供します。この チュートリアルで取り扱うコードは比較的小さいため、1 つの名前空間にすべてのコードを配置します。
public class BankAccount は、これから作成するクラスまたは型を定義します。 クラス宣言のあとにある { と } の内側は すべて、クラスの状態と動作を定義しています。 BankAccount クラスには、5つの"メンバー"があります。最初の3つは"*プ ロパティ*" です。 プロパティはデータ要素であり、検証やその他の規則を適用するコードを持つことができます。 最後の 2 つは "_*メソッド**" です。 メソッドは 1 つの機能を実行するコード ブロックです。 各メンバーの名前を確認すると、開発者がそのクラ スの作用を把握するための十分な情報が得られます。
新しいアカウントを開く
実装する最初の機能は、銀行口座を開く機能です。 顧客が口座を開く場合、初期残高や口座の (1 名または複数名の) 所有者の情報を入力する必要があります。
BankAccount 型の新しいオブジェクトを作成することは、それらの値を割り当てる"*コンストラクター"を定義することを意味し ます。 " *コンストラクター**" はクラスと同じ名前を持つメンバーです。 これは、そのクラス型のオブジェクトを初期化するために使 用されます。 BankAccount 型に次のコンストラクターを追加します。 MakeDeposit クラス宣言の上に次のコードを配置しま す。
new を使用してオブジェクトを作成すると、コンストラクターが呼び出されます。Program.csの Console.WriteLine("Hello World!"); の行を次のコードで置き換えます ( <name> を自分の名前に置き換えます)。
これまでに構築したものを実行してみましょう。 Visual Studio を使用している場合は、 [実行] メニューから [デバッグなしで 開始] を選択します。 コマンド ラインを使用している場合は、プロジェクトを作成したディレクトリで dotnet run を入力しま
         public BankAccount(string name, decimal initialBalance)
{
    this.Owner = name;
    this.Balance = initialBalance;
}
       var account = new BankAccount("<name>", 1000);
Console.WriteLine($"Account {account.Number} was created for {account.Owner} with {account.Balance} initial balance.");
  
  す。
口座番号が空であることに気付かれましたか? 次にこの問題を解決します。 口座番号はオブジェクトが作成されるときに割り当 てられる必要があります。しかし、それを作成する責任を呼び出し元に負わせるべきではありません。 BankAccount クラスの コードは、新しい口座番号の割り当て方を知っている必要があります。 そのための簡単な方法は、10 桁の数字で始めることで す。 そして、新しい口座番号が作成されるごとに値を 1 増加します。 最後に、オブジェクトが作成されるときに現在の口座番 号を格納します。
BankAccount クラスにメンバーの宣言を追加します。 BankAccount クラスの先頭の左中かっこ { の後に、次のコードを配置 します。
これがデータ メンバーです。 これは private であり、 BankAccount クラス内のコードのみがこれにアクセスできます。 この方法 により、プライベートな実装(口座番号の生成方法)から(口座番号を持つなどの)パブリックな責任を分離できます。 static でもあるため、すべての BankAccount オブジェクトによって共有されます。静的でない変数の値は BankAccount オブジェクト のインスタンスごとに一意です。 次の 2 行をコンストラクターに追加して、口座番号を割り当てます。 それらは
this.Balance = initialBalance という行の後に配置します。
「 dotnet run 」と入力して結果を表示します。 預金と引き出しを作成する
銀行口座クラスは、預金と引き出しを許可して正しく動作するようにする必要があります。 口座のすべてのトランザクションを記 録する履歴を作成して、預金と引き出しを実装しましょう。 これには、単純にトランザクションごとに残高を更新する方法に比 べていくつかのメリットがあります。 履歴は、すべてのトランザクションを監査して毎日の残高を管理するために使用できます。 必 要に応じてすべてのトランザクションの履歴から残高を計算することにより、1 つのトランザクションの中で修正されたすべてのエ ラーが正しく残高に反映されて次の計算に使用されます。
トランザクションを表す新しい型を作成するところから始めましょう。 これは一切の責任を持たない単純型です。 いくつかのプロ パティが必要になります。 「Transaction.cs」という名前の新しいファイルを作成します。 これに次のコードを追加します。
     private static int accountNumberSeed = 1234567890;
           this.Number = accountNumberSeed.ToString();
accountNumberSeed++;
      using System;
namespace classes
{
    public class Transaction
    {
        public decimal Amount { get; }
        public DateTime Date { get; }
        public string Notes { get; }
        public Transaction(decimal amount, DateTime date, string note)
        {
} }
}
this.Amount = amount;
this.Date = date;
this.Notes = note;
   BankAccount クラスに Transaction オブジェクトのList<T>を追加しましょう。BankAccount.csファイルのコンストラクターの 後に次の宣言を追加します。

   List<T> クラスでは、別の名前空間をインポートする必要があります。 BankAccount.cs の最初に次を追加します。
  using System.Collections.Generic;
  それでは、 Balance を正しく計算しましょう。 現在の残高は、すべての取引の値を合計することによって確認できます。 現 在、このコードで取得できるのは口座の初期残高のみであるため、 Balance プロパティを更新する必要があります。 BankAccount.csの public decimal Balance { get; } の行を、次のコードに置き換えます。
      public decimal Balance
{
get {
        return balance;
    }
}
decimal balance = 0;
foreach (var item in allTransactions)
{
    balance += item.Amount;
}
 この例は、プロパティ の重要な一面を示しています。 これで、別のプログラマーが値を要求したときに残高が計算されるように なりました。 この計算処理は、すべてのトランザクションを列挙して、その合計値を現在の残高として提供します。
次に MakeDeposit メソッドと MakeWithdrawal メソッドを実装します。これらのメソッドは、初期残高が正の値でなければなら ず、引き出し後の残高が負の値になってはいけない、という最後の 2 つの規則を適用します。
これにより、例外 の概念が導入されます。 メソッドが作業を正常に完了できないことを示す標準的な方法は、例外をスローす ることです。例外の型とそれに関連付けられたメッセージがエラーを説明します。 MakeDeposit メソッドは、預金額が負の値に なる場合に例外をスローします。 MakeWithdrawal メソッドは、引き出し額が負の値になる場合、または引き出しを適用した 結果、残高が負の値になる場合に例外をスローします。 allTransactions リストの宣言の後に、次のコードを追加します。
         public void MakeDeposit(decimal amount, DateTime date, string note)
{
    if (amount <= 0)
    {
        throw new ArgumentOutOfRangeException(nameof(amount), "Amount of deposit must be positive");
    }
    var deposit = new Transaction(amount, date, note);
    allTransactions.Add(deposit);
}
public void MakeWithdrawal(decimal amount, DateTime date, string note)
{
    if (amount <= 0)
    {
        throw new ArgumentOutOfRangeException(nameof(amount), "Amount of withdrawal must be positive");
    }
    if (Balance - amount < 0)
    {
        throw new InvalidOperationException("Not sufficient funds for this withdrawal");
    }
    var withdrawal = new Transaction(-amount, date, note);
    allTransactions.Add(withdrawal);
}
  private List<Transaction> allTransactions = new List<Transaction>();
 
   throw ステートメントが例外をスローします。現在のブロックの実行が終了し、コントロールによってコールスタックで最初に一 致した catch ブロックに転送されます。あとで catch ブロックを追加してこのコードをテストします。
残高を直接更新するのではなく、最初のトランザクションを追加するようにするため、コンストラクターを 1 か所変更する必要が あります。既に MakeDeposit メソッドは記述したので、このメソッドをコンストラクターから呼び出します。完成したコンストラク ターは次のようになります。
     public BankAccount(string name, decimal initialBalance)
{
    this.Number = accountNumberSeed.ToString();
    accountNumberSeed++;
    this.Owner = name;
    MakeDeposit(initialBalance, DateTime.Now, "Initial balance");
}
  DateTime.Now は、現在の日付と時刻を返すプロパティです。 新しい BankAccount を作成するコードの後で、 Main メソッ ドにいくつかの預金と引き出しを追加することで、これをテストします。
次に、残高が負の値になっている口座を作成してみることで、エラー条件のキャッチをテストします。 追加したコードの後に、次 のコードを追加します。
    account.MakeWithdrawal(500, DateTime.Now, "Rent payment");
Console.WriteLine(account.Balance);
account.MakeDeposit(100, DateTime.Now, "Friend paid me back");
Console.WriteLine(account.Balance);
     // Test that the initial balances must be positive.
try
{
    var invalidAccount = new BankAccount("invalid", -55);
}
catch (ArgumentOutOfRangeException e)
{
    Console.WriteLine("Exception caught creating account with negative balance");
    Console.WriteLine(e.ToString());
}
 try と catch のステートメントを使用して、例外をスローする可能性のあるコードブロックをマークし、想定したエラーをキャッ チします。同じ方法で、残高が負の値になっている場合に例外をスローするコードをテストします。 Main メソッドの末尾に、 次のコードを追加します。
    // Test for a negative balance.
try
{
    account.MakeWithdrawal(750, DateTime.Now, "Attempt to overdraw");
}
catch (InvalidOperationException e)
{
    Console.WriteLine("Exception caught trying to overdraw");
    Console.WriteLine(e.ToString());
}
  ファイルを保存し、「 dotnet run 」と入力して試します。
課題 - すべてのトランザクションをログに記録する

          このチュートリアルを完了すると、トランザクション履歴の   を作成する   メソッドを記述できるように なります。このメソッドを BankAccount 型に追加します。
string
GetAccountHistory
       public string GetAccountHistory()
{
    var report = new System.Text.StringBuilder();
    decimal balance = 0;
    report.AppendLine("Date\t\tAmount\tBalance\tNote");
    foreach (var item in allTransactions)
    {
        balance += item.Amount;
report.AppendLine($"{item.Date.ToShortDateString()}\t{item.Amount}\t{balance}\t{item.Notes}"); }
    return report.ToString();
}
 これは、StringBuilder クラスを使用して、各トランザクションを 1 行で表す文を含んだ文字列をフォーマットします。 文字列を フォーマットするコードについては、このチュートリアルで先述しました。新しい文字の1つは \t です。これはタブを挿入して出 力をフォーマットします。
次の行を追加して、Program.cs でテストします。
プログラムを実行して結果を確認します。
次の手順
うまくいかない場合は、このチュートリアルのソースを GitHub リポジトリで確認できます。 オブジェクト指向プログラミングのチュートリアルに進むことができます。 次の記事でこれらの概念の詳細を学習できます。
if と else ステートメント while ステートメント do ステートメント
for ステートメント
  Console.WriteLine(account.GetAccountHistory());
 
     C# はオブジェクト指向言語です。 オブジェクト指向プログラミングで使用される 4 つの主要な手法は次のとおりです。
"抽象化" とは、関連するプロパティ、メソッド、およびその他のメンバーのグループが 1 つの単位またはオブジェクトとして扱わ れることを意味します。
"カプセル化" とは、型コンシューマーから不要な詳細を隠すことです。
"継承" は、既存のクラスに基づいて新しいクラスを作成する機能です。
"ポリモーフィズム" とは、同じプロパティまたはメソッドを異なる方法で実装している複数のクラスを、交換して使用できること です。
前のチュートリアルのクラスの概要では、"抽象化"と"カプセル化"の両方について説明しました。 BankAccount クラスによっ て、銀行口座の概念に対する抽象化が提供されました。 その実装は、 BankAccount クラスを使用したコードのいずれにも影 響を与えずに変更できました。 BankAccount 、 Transaction クラスの両方で、これらの概念をコードで記述するために必要な コンポーネントのカプセル化が提供されます。
このチュートリアルでは、このアプリケーションを拡張し、"継承" と "ポリモーフィズム" を使用して新機能を追加します。 また、前 のチュートリアルで学習した"抽象化"と"カプセル化"の手法を活用して、BankAccount クラスに機能を追加します。
さまざまな種類の口座を作成する
このプログラムを構築した後、あなたは機能を追加するように要求されます。 これは、銀行口座の種類が 1 つしかない場合に 適しています。 時間の経過と共に、ニーズが変化し、関連する口座の種類が要求されます。
月末ごとに利息がつく、利息つき口座。 残高が負の値になる可能性のある与信枠。ただし、残高がある場合は、毎月利息を請求されます。 前払いのギフト カード口座。1 回の預金で始まり、支払いのみが可能です。 毎月初めに 1 回補充できます。
これらの各種口座はすべて、前のチュートリアルで定義した BankAccount クラスに似ています。そのコードをコピーし、クラスの 名前を変更して、変更を加えることができます。 この手法は短期的にはうまくいきますが、時間の経過と共に作業量が多くなり ます。 あらゆる変更を、影響を受けるすべてのクラス間でコピーする必要があります。
代わりに、前のチュートリアルで作成した BankAccount クラスからメソッドとデータを継承する、新しい銀行口座の種類を作成 できます。これらの新しいクラスでは、各種類に必要な特定の動作で BankAccount クラスを拡張できます。
            public class InterestEarningAccount : BankAccount
{
}
public class LineOfCreditAccount : BankAccount
{
}
public class GiftCardAccount : BankAccount
{
}
  これらの各クラスは、共有の"基底クラス"である BankAccount クラスから、共有の動作を"継承"します。その"派生クラス" ごとに、新しい異なる機能の実装を記述します。 これらの派生クラスには、 BankAccount クラスで定義されているすべての動作 が既に備わっています。
 新しいクラスは、それぞれ別のソース ファイルに作成することをお勧めします。 Visual Studio では、プロジェクトを右クリックして
オブジェクト指向プログラミング (C#) 2021/03/16 • • Edit Online
 
  [クラスの追加] を選択すると、新しいファイルに新しいクラスを追加できます。 Visual Studio Code では、 [ファイル] 、 [新規] の順に選択すると新しいソース ファイルを作成できます。 どちらのツールでも、クラスと一致するようにファイル名を指定しま す。InterestEarningAccount.cs、LineOfCreditAccount.cs、GiftCardAccount.cs です。
前述のサンプルのようなクラスを作成すると、どの派生クラスもコンパイルされないことがわかります。 コンストラクターによって、オブ ジェクトの初期化が行われます。 派生クラスのコンストラクターでは、派生クラスを初期化し、その派生クラスに含まれる基底クラ スのオブジェクトを初期化する方法を指定する必要があります。 通常、適切な初期化は追加のコードなしで行われます。
BankAccount クラスでは、次のシグネチャを持つ1つのパブリックコンストラクターが宣言されます。
コンストラクターを自分で定義した場合、コンパイラによって既定のコンストラクターが生成されることはありません。 これは、各派 生クラスで明示的にこのコンストラクターを呼び出す必要があることを意味します。 基底クラスのコンストラクターに引数を渡すこ とができるコンストラクターを宣言します。 次のコードは、 InterestEarningAccount のコンストラクターを示しています。
この新しいコンストラクターのパラメーターは、基底クラスのコンストラクターのパラメーターと型と名前が一致しています。
: base() 構文を使用して、基底クラスのコンストラクターへの呼び出しを示すことができます。 複数のコンストラクターを定義す
るクラスもあります。この構文を使用することで、呼び出す基底クラスのコンストラクターを選択できます。 コンストラクターを更新 したら、各派生クラスのコードを開発できます。 新しいクラスの要件は、次のように記述できます。
利息つき口座:
月末の残高の 2% が振り込まれます。
与信枠: 残高を負の値にすることができますが、与信限度額よりも絶対値を大きくすることはできません。 月末の残高が 0 ではない場合は、毎月利息を請求されます。 与信限度額を超えた引き出しごとに手数料が発生します。
ギフト カード口座:
毎月 1 回、月の最終日に指定した金額を補充できます。
これら 3 種類の口座には、すべて月末ごとに実行されるアクションがあることがわかります。 ただし、口座の種類ごとに異なるタ スクが実行されます。このコードを実装するために、"ポリモーフィズム"を使用します。 BankAccount クラスで1つの virtual メソッドを作成します。
前のコードでは、 キーワードを使用して、派生クラスで異なる実装を提供できる基底クラスのメソッドを宣言する方法 を示しています。 メソッドは、任意の派生クラスで再実装することを選択できるメソッドです。 派生クラスでは、
キーワードを使用して新しい実装を定義します。 通常、これは "基底クラスの実装のオーバーライド" と呼ばれま す。 キーワードによって、派生クラスで動作をオーバーライドする可能性があることを指定できます。 また、派生クラス で動作をオーバーライドしなければならない abstract メソッドを宣言することもできます。基底クラスでは abstract メソッド の実装が提供されません。 次に、作成した 2 つの新しいクラスの実装を定義する必要があります。 まずは
InterestEarningAccount です。
   public BankAccount(string name, decimal initialBalance)
      public InterestEarningAccount(string name, decimal initialBalance) : base(name, initialBalance)
{
}
      public virtual void PerformMonthEndTransactions() { }
  virtual
  virtual
 override
 virtual
   
   LineOfCreditAccount に次のコードを追加します。このコードでは、残高の符号を反転させて、口座から引き出される正の利 息請求額を計算しています。
    public override void PerformMonthEndTransactions()
{
    if (Balance < 0)
    {
} }
// Negate the balance to get a positive interest charge:
var interest = -Balance * 0.07m;
MakeWithdrawal(interest, DateTime.Now, "Charge monthly interest");
  GiftCardAccount クラスには、月末の機能を実装するために2つの変更が必要です。最初に、毎月追加できる省略可能 な金額を含めるようにコンストラクターを変更します。
このコンストラクターでは の値に対して既定値が指定されています。これにより、毎月の預金がない場合に呼 び出し元は 0 を省略できます。次に、 メソッドをオーバーライドして、毎月の預金がコンスト ラクターで 0 以外の値に設定されていた場合にそれを追加するようにします。
このオーバーライドにより、コンストラクターで設定された毎月の預金が適用されます。次のコードを Main メソッドに追加して、 GiftCardAccount と InterestEarningAccount に対するこれらの変更内容をテストします。
    private decimal _monthlyDeposit = 0m;
public GiftCardAccount(string name, decimal initialBalance, decimal monthlyDeposit = 0) : base(name,
initialBalance)
    => _monthlyDeposit = monthlyDeposit;
  monthlyDeposit
 PerformMonthEndTransactions
    public override void PerformMonthEndTransactions()
{
    if (_monthlyDeposit != 0)
    {
        MakeDeposit(_monthlyDeposit, DateTime.Now, "Add monthly deposit");
    }
}
      public override void PerformMonthEndTransactions()
{
    if (Balance > 500m)
    {
        var interest = Balance * 0.05m;
        MakeDeposit(interest, DateTime.Now, "apply monthly interest");
    }
}
 
   結果を確認しましょう。 次に、 LineOfCreditAccount に対して類似した一連のテスト コードを追加します。
    var lineOfCredit = new LineOfCreditAccount("line of credit", 0);
// How much is too much to borrow?
lineOfCredit.MakeWithdrawal(1000m, DateTime.Now, "Take out monthly advance");
lineOfCredit.MakeDeposit(50m, DateTime.Now, "Pay back small amount");
lineOfCredit.MakeWithdrawal(5000m, DateTime.Now, "Emergency funds for repairs");
lineOfCredit.MakeDeposit(150m, DateTime.Now, "Partial restoration on repairs");
lineOfCredit.PerformMonthEndTransactions();
Console.WriteLine(lineOfCredit.GetAccountHistory());
 上記のコードを追加してプログラムを実行すると、次のようなエラーが表示されます。
    Unhandled exception. System.ArgumentOutOfRangeException: Amount of deposit must be positive (Parameter
'amount')
   at OOProgramming.BankAccount.MakeDeposit(Decimal amount, DateTime date, String note) in
BankAccount.cs:line 42
   at OOProgramming.BankAccount..ctor(String name, Decimal initialBalance) in BankAccount.cs:line 31
   at OOProgramming.LineOfCreditAccount..ctor(String name, Decimal initialBalance) in
LineOfCreditAccount.cs:line 9
   at OOProgramming.Program.Main(String[] args) in Program.cs:line 29
     NOTE
実際の出力には、プロジェクトを含むフォルダーへの完全なパスが含まれています。 簡潔にするため、フォルダー名は省略されています。 ま た、コード形式によっては、行番号が若干異なる場合があります。
   このコードが失敗したのは、 BankAccount によって初期残高は 0 より大きいと仮定されているためです。 BankAccount クラス に織り込まれているもう 1 つの前提は、残高を負の値にすることはできないということです。 代わりに、口座残高を超える引き 出しは拒否されます。 これらの前提はどちらも変更する必要があります。 与信枠口座は 0 から始まり、通常は残高が負にな ります。 また、顧客がお金を借りすぎた場合、手数料が発生します。 そのトランザクションは承認されます。追加料金がかかる だけです。最初の規則は、最小残高を指定する省略可能な引数を BankAccount コンストラクターに追加することによって実 装できます。既定では、 0です。2番目の規則には、派生クラスで既定のアルゴリズムを変更できるようにするメカニズムが必 要です。 ある意味では、基底クラスが派生型に、過剰な引き出しがあった場合にどうするかを "尋ね" ます。 既定の動作で は、例外をスローすることによってトランザクションを拒否します。
まず、省略可能な minimumBalance パラメーターを含む2番目のコンストラクターを追加しましょう。この新しいコンストラクター では、既存のコンストラクターで実行されるすべてのアクションが実行されます。 さらに、最小残高のプロパティも設定されます。 既存のコンストラクターの本体をコピーすることもできます。 ただし、今後は 2 か所を変更しなければならなくなります。 代わり に、"コンストラクター チェーン" を使用して、1 つのコンストラクターが別のコンストラクターを呼び出すようにすることができます。 次のコードは、2 つのコンストラクターと新しい追加フィールドを示しています。
     var giftCard = new GiftCardAccount("gift card", 100, 50);
giftCard.MakeWithdrawal(20, DateTime.Now, "get expensive coffee");
giftCard.MakeWithdrawal(50, DateTime.Now, "buy groceries");
giftCard.PerformMonthEndTransactions();
// can make additional deposits:
giftCard.MakeDeposit(27.50m, DateTime.Now, "add some additional spending money");
Console.WriteLine(giftCard.GetAccountHistory());
var savings = new InterestEarningAccount("savings account", 10000);
savings.MakeDeposit(750, DateTime.Now, "save some money");
savings.MakeDeposit(1250, DateTime.Now, "Add more savings");
savings.MakeWithdrawal(250, DateTime.Now, "Needed to pay monthly bills");
savings.PerformMonthEndTransactions();
Console.WriteLine(savings.GetAccountHistory());
 
    上記のコードには、2つの新しい手法が示されています。まず、minimumBalance フィールドは としてマークされてい ます。 これは、オブジェクトを構築した後はこの値を変更できないことを意味します。 の作成後に
を変更することはできません。 次に、2 つのパラメーターを受け取るコンストラクターでは、実装として が使用されています。 : this() 式によって、3 つのパラメーターを持つ別のコンスト ラクターを呼び出します。 この手法を使用すると、オブジェクトを初期化するための実装を 1 つ用意して、クライアント コードでは
多数のコンストラクターの中からいずれかを選択できるようにすることができます。
この実装では、初期残高が 0 よりも大きい場合にのみ MakeDeposit が呼び出されます。 これにより、預金は正である必要
があるという規則を守りつつ、残高 0 で与信枠口座を開設することができます。
これで BankAccount クラスに最小残高用の読み取り専用フィールドが設定されたので、最後の変更として、 MakeWithdrawal
メソッドのハードコーディングされた 0 を minimumBalance に変更します。
クラスを拡張した後、次のコードに示すように、新しい基底コンストラクターを呼び出すように コンストラクターを変更できます。
LineOfCreditAccount コンストラクターでは、 minimumBalance パラメーターの意味と一致するように、 creditLimit パラメー ターの符号が変更されることがわかります。
過剰な引き出しに対する異なる規則
追加する最後の機能により、 LineOfCreditAccount で、与信限度額の超過に対してトランザクションを拒否するのではなく、 手数料を請求できるようになります。
1 つの手法は、必要な動作を実装する仮想関数を定義することです。 BankAccount クラスでは、 MakeWithdrawal メソッド が 2 つのメソッドにリファクターされます。 新しいメソッドでは、引き出しによって残高が最小値を下回る場合に、指定されたアク ションが実行されます。既存の MakeWithdrawal メソッドには、次のコードが含まれています。
minimumBalance
 : this(name, initialBalance, 0) { }
BankAccount
readonly
         if (Balance - amount < minimumBalance)
  BankAccount
 LineOfCreditAccount
    public LineOfCreditAccount(string name, decimal initialBalance, decimal creditLimit) : base(name,
initialBalance, -creditLimit)
{
}
           private readonly decimal minimumBalance;
public BankAccount(string name, decimal initialBalance) : this(name, initialBalance, 0) { }
public BankAccount(string name, decimal initialBalance, decimal minimumBalance)
{
    this.Number = accountNumberSeed.ToString();
    accountNumberSeed++;
    this.Owner = name;
    this.minimumBalance = minimumBalance;
    if (initialBalance > 0)
}
MakeDeposit(initialBalance, DateTime.Now, "Initial balance");
 
  見つかったコードを次のコードと置き換えます。
    public void MakeWithdrawal(decimal amount, DateTime date, string note)
{
    if (amount <= 0)
    {
        throw new ArgumentOutOfRangeException(nameof(amount), "Amount of withdrawal must be positive");
    }
    var overdraftTransaction = CheckWithdrawalLimit(Balance - amount < minimumBalance);
    var withdrawal = new Transaction(-amount, date, note);
    allTransactions.Add(withdrawal);
    if (overdraftTransaction != null)
        allTransactions.Add(overdraftTransaction);
}
protected virtual Transaction? CheckWithdrawalLimit(bool isOverdrawn)
{
    if (isOverdrawn)
    {
        throw new InvalidOperationException("Not sufficient funds for this withdrawal");
    }
else {
        return default;
    }
}
  追加されたメソッドは protected です。これは、派生クラスからのみ呼び出せることを意味します。この宣言によって、他のクラ イアントがこのメソッドを呼び出せなくなります。これは virtual でもあるため、派生クラスで動作を変更できます。戻り値の型 は です。 ? の注釈は、メソッドが null を返す可能性があることを示します。 次の実装を
に追加して、引き出しの限度額を超えたときに手数料を請求します。
このオーバーライドでは、残高が過剰に引き出された場合に手数料のトランザクションが返されます。 引き出しが限度額を超え ていない場合は、メソッドから null トランザクションが返されます。これは手数料が発生していないことを示します。 Program クラスの Main メソッドに次のコードを追加して、これらの変更をテストします。
  Transaction?
 LineOfCreditAccount
    protected override Transaction? CheckWithdrawalLimit(bool isOverdrawn) =>
    isOverdrawn
    ? new Transaction(-20, DateTime.Now, "Apply overdraft fee")
    : default;
     public void MakeWithdrawal(decimal amount, DateTime date, string note)
{
    if (amount <= 0)
    {
        throw new ArgumentOutOfRangeException(nameof(amount), "Amount of withdrawal must be positive");
    }
    if (Balance - amount < minimumBalance)
    {
        throw new InvalidOperationException("Not sufficient funds for this withdrawal");
    }
    var withdrawal = new Transaction(-amount, date, note);
    allTransactions.Add(withdrawal);
}
 
    プログラムを実行し、結果を確認します。
まとめ
うまくいかない場合は、このチュートリアルのソースを GitHub リポジトリで確認できます。 このチュートリアルでは、オブジェクト指向プログラミングで使用される多くの手法を示しました。
各クラスで多くの詳細情報を private にしたとき、"抽象化"を使用しました。
異なる種類の口座ごとにクラスを定義したとき、"カプセル化" を使用しました。 これらのクラスによって、その種類の口座の動 作が記述されました。
BankAccount クラスに既に作成されている実装を活用してコードを節約したとき、"継承"を使用しました。 派生クラスでオーバーライドしてその口座の種類に固有の動作を作成できる virtual メソッドを作成したとき、"ポリモーフィ ズム" を使用しました。
お疲れさまでした。これで、C# の概要に関する全チュートリアルを完了しました。 さらに学習する場合は、その他のチュートリア ルをお試しください。
      var lineOfCredit = new LineOfCreditAccount("line of credit", 0, 2000);
// How much is too much to borrow?
lineOfCredit.MakeWithdrawal(1000m, DateTime.Now, "Take out monthly advance");
lineOfCredit.MakeDeposit(50m, DateTime.Now, "Pay back small amount");
lineOfCredit.MakeWithdrawal(5000m, DateTime.Now, "Emergency funds for repairs");
lineOfCredit.MakeDeposit(150m, DateTime.Now, "Partial restoration on repairs");
lineOfCredit.PerformMonthEndTransactions();
Console.WriteLine(lineOfCredit.GetAccountHistory());
 
          C# 9 で導入された "レコード" は、クラスまたは構造体の代わりに作成できる新しい参照型です。 レコードがクラスと異なるの は、レコード型では "値ベースの等値性" が使用されることです。 レコード型の 2 つの変数は、レコード型の定義が同じで、すべ てのフィールドについて、両方のレコードの値が等しい場合、等しいと見なされます。 クラス型の 2 つの変数は、参照されている オブジェクトが同じクラス型であり、変数で同じオブジェクトが参照されている場合に等しくなります。 値ベースの等値性により、 レコード型では他にもいくつかの機能が必要になると思われます。 class ではなく record を宣言すると、コンパイラによってそ れらのメンバーの多くが生成されます。
このチュートリアルで学習する内容は次のとおりです。
class または record を宣言する必要があるかどうかを判断する。 レコード型と位置指定レコード型を宣言する。 レコードのコンパイラによって生成されたメソッドを独自のメソッドに置き換える。
[前提条件]
C# 9.0 以降のコンパイラが含まれる .NET 5 以降が実行されるように、コンピューターを設定する必要があります。 C# 9.0 コン
パイラは、Visual Studio 2019 バージョン 16.8 以降または .NET 5.0 SDK 以降で使用できます。 レコードの特性
"レコード"を定義するには、 class または struct キーワードの代わりに、 record キーワードを使用して型を宣言します。 レコードは参照型であり、値ベースの等値性のセマンティクスに従います。 値のセマンティクスを適用するため、コンパイラによりレ コード型用のいくつかのメソッドが生成されます。
Object.Equals(Object) のオーバーライド。 パラメーターがレコード型である仮想 Equals メソッド。 Object.GetHashCode() のオーバーライド。
operator == と operator != のメソッド。 レコード型によって実装される System.IEquatable<T>。
さらに、レコードでは Object.ToString() のオーバーライドが提供されます。 コンパイラにより、Object.ToString() を使用してレ コードを表示するためのメソッドが合成されます。 このチュートリアルでコードを記述しながら、それらのメンバーについて調べま す。レコードでは、レコードの非破壊的な変化を可能にする with 式がサポートされています。
また、より簡潔な構文を使用して "位置指定レコード" を宣言することもできます。 位置指定レコードを宣言すると、コンパイラ によってさらに多くのメソッドが合成されます。
パラメーターがレコード宣言の位置指定パラメーターと一致するプライマリ コンストラクター。 プライマリ コンストラクターの各パラメーターに対するパブリック初期化専用プロパティ。 レコードからプロパティを抽出するための Deconstruct メソッド。
温度データを作成する
レコードを使用するのが望ましいシナリオには、データと統計に関するものが含まれます。 このチュートリアルでは、さまざまな用途 の "度日数" を計算するアプリケーションを作成します。 "度日数" とは、日、週、または月の単位での熱量 (または熱量不足) の尺度です。 度日数を使用して、エネルギー使用量を追跡および予測します。 暑い日が多いほど空調の使用量が増え、寒 い日が多いほど暖房の使用量が増えることを意味します。 度日数は、プラントの作成を管理したり、季節の変化に応じてプラ
        レコード型を作成する
2021/03/17 • • Edit Online
 
 ントの成長に関連付けたりするのに役立ちます。 度日数は、気候に合わせて場所を変える種の動物の移動を追跡するのに 役立ちます。
数式は、特定の日の平均気温と基準温度に基づいています。 ある期間の度日数を計算するには、その期間の各日の最高 気温と最低気温が必要になります。 それでは、新しいアプリケーションの作成を始めましょう。 新しいコンソール アプリケーション を作成します。 "DailyTemperature.cs" という名前の新しいファイルに新しいレコード型を作成します。
上記のコードでは、"位置指定レコード"が定義されています。2つのプロパティ HighTemp と LowTemp を含む参照型を作成 しました。 それらのプロパティは "初期化専用プロパティ" であり、コンストラクター内で、またはプロパティ初期化子を使用して、 設定できることを意味します。 型には、2 つのプロパティと一致する 2 つのパラメーターを持つ "プライマリ コ ンストラクター" もあります。 レコードを初期化するには、プライマリ コンストラクターを使用します。
  public record DailyTemperature(double HighTemp, double LowTemp);
    DailyTemperature
 DailyTemperature
    private static DailyTemperature[] data = new DailyTemperature[]
{
    new DailyTemperature(HighTemp: 57, LowTemp: 30),
    new DailyTemperature(60, 35),
    new DailyTemperature(63, 33),
    new DailyTemperature(68, 29),
    new DailyTemperature(72, 47),
    new DailyTemperature(75, 55),
    new DailyTemperature(77, 55),
    new DailyTemperature(72, 58),
    new DailyTemperature(70, 47),
    new DailyTemperature(77, 59),
    new DailyTemperature(85, 65),
    new DailyTemperature(87, 65),
    new DailyTemperature(85, 72),
    new DailyTemperature(83, 68),
    new DailyTemperature(77, 65),
    new DailyTemperature(72, 58),
    new DailyTemperature(77, 55),
    new DailyTemperature(76, 53),
    new DailyTemperature(80, 60),
    new DailyTemperature(85, 66)
};
 位置指定レコードも含めて、独自のプロパティやメソッドをレコードに追加することができます。 毎日の平均気温を計算する必 要があります。そのプロパティを DailyTemperature レコードに追加できます。
このデータを使用できることを確認してみましょう。次のコードを Main メソッドに追加します。
アプリケーションを実行すると、次のような出力が表示されます (スペースの都合で何行か削除されています)。
     public record DailyTemperature(double HighTemp, double LowTemp)
{
    public double Mean => (HighTemp + LowTemp) / 2.0;
}
     foreach (var item in data)
    Console.WriteLine(item);
 
   上記のコードは、コンパイラによって合成された ToString のオーバーライドからの出力を示したものです。別のテキストを使用 する場合は、独自のバージョンを記述することで、コンパイラによって ToString バージョンが自動的に合成されなくすることがで きます。
度日数を計算する
度日数を計算するには、基準温度と特定の日の平均気温との差を計算します。 ある期間の暑さを測定するには、平均気温 が基準値を下回っている日を破棄します。 ある期間の寒さを測定するには、平均気温が基準値を上回っている日を破棄しま す。 たとえば、米国では、暖房と冷房の両方の度日数に対する基準として 65F が使用されています。 これは、暖房や冷房の 必要がない温度です。 ある日の平均気温が 70F の場合、その日は 5 冷房度日数で、0 暖房度日数です。 逆に、平均気 温が 55F の場合は、その日は 10 暖房度日数で、0 冷房度日数です。
これらの数式を、レコード型の小さな階層として表すことができます。つまり、度日を表す 1 つの抽象型と、暖房度日数と冷房 度日数のための 2 つの具象型です。 これらの型は、位置指定レコードにすることもできます。 それらは、プライマリ コンストラク ターの引数として、基準温度と一連の毎日の気温レコードを受け取ります。
     public abstract record DegreeDays(double BaseTemperature, IEnumerable<DailyTemperature> TempRecords);
public record HeatingDegreeDays(double BaseTemperature, IEnumerable<DailyTemperature> TempRecords)
    : DegreeDays(BaseTemperature, TempRecords)
{
    public double DegreeDays => TempRecords.Where(s => s.Mean < BaseTemperature).Sum(s => BaseTemperature -
s.Mean); }
public sealed record CoolingDegreeDays(double BaseTemperature, IEnumerable<DailyTemperature> TempRecords) : DegreeDays(BaseTemperature, TempRecords)
{
    public double DegreeDays => TempRecords.Where(s => s.Mean > BaseTemperature).Sum(s => s.Mean -
BaseTemperature);
}
    抽象 DegreeDays レコードは、 HeatingDegreeDays レコードと CoolingDegreeDays レコードの両方に対する共有基底クラス です。 派生レコードでのプライマリ コンストラクターの宣言により、基本レコードの初期化を管理する方法が示されています。 派 生レコードにより、基本レコードのプライマリ コンストラクターに含まれるすべてのパラメーターに対するパラメーターが宣言されてい ます。 基本レコードにより、それらのプロパティが宣言されて初期化されます。 派生レコードによってそれらは隠ぺいされません が、基本レコードで宣言されていないパラメーターのプロパティのみが作成されて初期化されます。 この例では、派生レコードに よって新しいプライマリコンストラクターパラメーターが追加されることはありません。 Main メソッドに次のコードを追加すること で、コードをテストします。
    var heatingDegreeDays = new HeatingDegreeDays(65, data);
Console.WriteLine(heatingDegreeDays);
var coolingDegreeDays = new CoolingDegreeDays(65, data);
Console.WriteLine(coolingDegreeDays);
 次のような出力が表示されます。
   DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }
DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
 
    コンパイラ合成メソッドを定義する
コードで、その期間における暖房度日数と冷房度日数の正しい値を計算します。 ただし、この例では、レコードに対する合成 メソッドの一部を置き換える必要がある理由を示します。 クローン メソッドを除き、あるレコード型でのどのコンパイラ合成メソッド についても、独自のバージョンを宣言できます。 クローン メソッドにはコンパイラによって生成される名前があり、別の実装を提供 することはできません。 これらの合成メソッドには、コピー コンストラクター、System.IEquatable<T> インターフェイスのメンバー、 等値テストと非等値テスト、GetHashCode() が含まれます。 このために、 PrintMembers を合成します。 独自の ToString を宣言することもできますが、継承のシナリオには PrintMembers の方が適しています。 独自バージョンの合成メソッドを提供す るには、シグネチャが合成メソッドと一致している必要があります。
コンソール出力の TempRecords 要素は役に立ちません。型が表示されるだけで、他には何も表示されません。合成メソッド PrintMembers の独自の実装を提供することにより、この動作を変更できます。 シグネチャは、 record の宣言に適用される
修飾子によって異なります。
        の場合、シグネチャは private bool PrintMembers(StringBuilder builder); です
レコード型が
レコード型が   ではなく、 から派生している場合は (つまり、基本レコードが宣言されていない場合)、シグネ
チャは レコード型が
となります ではなく、別のレコードから派生している場合は、シグネチャは
となります
sealed
object
  protected virtual bool PrintMembers(StringBuilder builder);
 sealed
 protected override bool PrintMembers(StringBuilder builder);
  これらのルールは、 PrintMembers の目的を理解することで把握するのが最も簡単です。 PrintMembers により、レコード型の 各プロパティに関する情報が文字列に追加されます。 コントラクトでは、表示にメンバーを追加するための基本レコードが必要 であり、派生メンバーによってそれらのメンバーが追加されるものと想定されています。 各レコード型により、 HeatingDegreeDays に対する次の例のような ToString のオーバーライドが合成されます。
      public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
   コレクションの型が出力されない DegreeDays レコードで、 PrintMembers メソッドを宣言します。
コンパイラのバージョンと一致するように、シグネチャで virtual protected メソッドを宣言します。 アクセサーが間違っていても 気にしないでください。言語によって正しいシグネチャが適用されます。 合成メソッドの正しい修飾子を忘れた場合は、適切な シグネチャを取得するのに役立つ警告またはエラーがコンパイラによって表示されます。
    protected virtual bool PrintMembers(StringBuilder stringBuilder)
{
    stringBuilder.Append($"BaseTemperature = {BaseTemperature}");
    return true;
}
  非破壊的な変化
sealed
     HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
 
  位置指定レコードの合成メンバーによって、レコードの状態が変更されることはありません。 目標は、変更不可能なレコードを より簡単に作成できるようにすることです。前に示した HeatingDegreeDays と CoolingDegreeDays の宣言をもう一度見てみ ましょう。 追加されたメンバーにより、レコードの値に対する計算は行われますが、状態は変更されません。 位置指定レコード を使用すると、変更不可能な参照型をより簡単に作成できます。
変更不可能な参照型を作成するということは、非破壊的な変化を使用することを意味します。 with 式を使用して、既存の レコード インスタンスに似た新しいレコード インスタンスを作成します。 これらの式は、コピーの構築にコピーを変更する割り当て を追加したものです。 結果として、既存のレコードから各プロパティがコピーされ、必要に応じて変更が加えられた、新しいレ コード インスタンスが作成されます。 元のレコードは変更されません。
with 式を示すいくつかの機能をプログラムに追加してみましょう。最初に、同じデータを使用して、成長度日数を計算する 新しいレコードを作成してみます。 "成長度日数" の場合は、通常、基準として 41F を使用し、基準を上回る温度を測定し ます。 同じデータを使用するため、 coolingDegreeDays に似た新しいレコードを作成しますが、異なる基準温度を使用しま す。
計算された度数と、より高い基準温度で生成された値を比較できます。 レコードは "参照型" であり、これらのコピーは簡易コ ピーであることに注意してください。 データの配列はコピーされず、両方のレコードで同じデータが参照されています。 その事実 は、他のもう 1 つのシナリオでの利点になります。 成長度日数の場合、過去 5 日間の合計を追跡しておくと便利です。
with 式を使用して、異なるソースデータで新しいレコードを作成できます。次のコードを使用すると、これらの累積のコレク ションが作成されてから、値が表示されます。
       // Growing degree days measure warming to determine plant growing rates
var growingDegreeDays = coolingDegreeDays with { BaseTemperature = 41 };
Console.WriteLine(growingDegreeDays);
     // showing moving accumulation of 5 days using range syntax
List<CoolingDegreeDays> movingAccumulation = new();
int rangeSize = (data.Length > 5) ? 5 : data.Length;
for (int start = 0; start < data.Length - rangeSize; start++)
{
    var fiveDayTotal = growingDegreeDays with { TempRecords = data[start..(start + rangeSize)] };
    movingAccumulation.Add(fiveDayTotal);
}
Console.WriteLine();
Console.WriteLine("Total degree days in the last five days");
foreach(var item in movingAccumulation)
{
    Console.WriteLine(item);
}
 with 式を使用して、レコードのコピーを作成することもできます。 with 式の中かっこの間には、プロパティを指定しないでくだ さい。 それはコピーを作成することを意味し、プロパティは変更されません。
完成したアプリケーションを実行して結果を確認します。
まとめ
このチュートリアルでは、レコードのいくつかの側面を見てきました。 レコードにより、基本的な用途がデータの格納である参照型 に対する、簡潔な構文が提供されます。 オブジェクト指向のクラスの場合は、基本的な用途は役割を定義することです。 この チュートリアルで焦点を当てた "位置指定レコード" を使用すると、簡潔な構文を使用して、レコードの初期化専用プロパティを 宣言できます。 コンパイラにより、レコードのコピーと比較のために、レコードの複数のメンバーが合成されます。 レコード型の必 要に応じて他のメンバーを追加できます。 コンパイラによって生成されるどのメンバーも状態が変化しないことがわかっている場 合は、変更不可能なレコード型を作成できます。 また、 with 式を使用すると、非破壊的な変化に簡単に対応できます。
  var growingDegreeDaysCopy = growingDegreeDays with { };
 
   レコードにより、型を定義する別の方法が追加されます。 オブジェクトの役割と動作に焦点を当てたオブジェクト指向の階層を 作成するには、 class 定義を使用します。 データを格納する、効率的にコピーするのに十分に小さいデータ構造の場合は、 型を作成します。 値ベースの等値性と比較が必要で、値をコピーする必要はなく、参照変数を使用したい場合は、
型を作成します。
レコードの詳細な説明については、レコード型に関する C# 言語のリファレンス記事と提案されるレコード型の仕様の記事を参 照してください。
 struct
  record

     このチュートリアルで学習する内容は次のとおりです。
最上位レベルのステートメントの使用を制御するルールについて学習する。 最上位レベルのステートメントを使用してアルゴリズムを探索する。 探索を再利用可能なコンポーネントにリファクタリングする。
必須コンポーネント
お使いのマシンを、.NET 5 が実行されるように設定する必要があります。これには C# 9 コンパイラが含まれます。 C# 9 コンパイ
ラは Visual Studio 2019 バージョン 16.9 プレビュー 1 または .NET 5.0 SDK 以降で使用できます。 このチュートリアルでは、.NET と、C# と Visual Studio または .NET Core CLI のいずれかに精通していることを前提としていま
す。
実際に使ってみる
最上位レベルのステートメントを使用すると、プログラムのエントリ ポイントをクラスの静的メソッドに配置することによって必要とさ れる余分な手続きを避けることができます。 新しいコンソール アプリケーションの一般的な開始点は、次のコードのようになりま す。
    using System;
namespace Application
{
    class Program
    {
} }
static void Main(string[] args)
{
    Console.WriteLine("Hello World!");
}
  上記のコードは、 dotnet new console コマンドを実行し、新しいコンソール アプリケーションを作成した結果です。 これらの 11 行には、実行可能コードが 1 行しか含まれていません。 そのプログラムは、新しい最上位レベルのステートメント機能を使用し て簡素化できます。 これにより、このプログラム内の 2 つを除くすべての行を削除できます。
このアクションにより、新しいアイデアの探索を開始するのに必要なものが簡素化されます。 最上位レベルのステートメントをスク リプト作成シナリオで、あるいは探索するために使用できます。 基本的な作業が完了したら、コードのリファクタリングを開始し、 ビルドした再利用可能なコンポーネントに対してメソッド、クラス、またはその他のアセンブリを作成できます。 最上位レベルのス テートメントを使用すれば、迅速な実験と初心者向けチュートリアルが可能になります。 また、実験から完全なプログラムへのス
    using System;
Console.WriteLine("Hello World!");
 チュートリアル: 学習しながらコードをビルドす
るために最上位レベルのステートメントを使用し
てアイデアを探索する
2021/03/06 • • Edit Online
 
 ムーズなパスが得られます。
最上位レベルのステートメントは、ファイルに示される順序で実行されます。 最上位レベルのステートメントは、アプリケーション内
の 1 つのソース ファイルのみで使用できます。 複数のファイルで使用すると、コンパイラでエラーが発生します。 マジック .NET 回答マシンをビルドする
このチュートリアルでは、"はい" か "いいえ" の質問にランダムな回答で答えるコンソール アプリケーションをビルドします。 機能は 少しずつビルドしていきます。 一般的なプログラムの構造に必要な手続きではなく、タスクに専念できます。 その後、機能に問 題がなければ、必要に応じてアプリケーションをリファクタリングすることができます。
まず、質問をコンソールに書き戻すことをお勧めします。 まず、次のコードを記述します。
args 変数は宣言しません。最上位レベルのステートメントを含む単一のソースファイルの場合、コンパイラでコマンドライン引 数を意味する args が認識されます。すべてのC#プログラムの場合と同じように、引数の型は string[] となります。
次の dotnet run コマンドを実行して、コードをテストすることができます。
コマンドラインの -- の後の引数は、プログラムに渡されます。 args 変数の型を確認できます。それが、コンソールに出力さ れた内容であるためです。
コンソールに質問を書き込むには、引数を列挙し、それらをスペースで区切る必要があります。 WriteLine 呼び出しを次の コードに置き換えます。
これで、プログラムを実行すると、質問が引数の文字列として正しく表示されるようになります。
ランダムな回答で答える
質問を問い返した後、ランダムな回答を生成するコードを追加できます。 まず、考えられる答えの配列を追加します。
    using System;
Console.WriteLine(args);
     dotnet run -- Should I use top level statements in all my programs?
   System.String[]
      Console.WriteLine();
foreach(var s in args)
{
    Console.Write(s);
    Console.Write(' ');
}
Console.WriteLine();
 
  この配列には 12 個の答えが含まれており、6 個は肯定的であいまいなものであり、残りの 6 個は否定的なものです。 次に、 配列からランダムな回答を生成して表示する以下のコードを追加します。
アプリケーションをもう一度実行して、結果を確認することができます。 次の出力のようになるはずです。
このコードで質問に回答しますが、もう 1 つ機能を追加してみましょう。 たとえば、質問アプリを使用して、答えについての考え 方をシミュレートしたいとします。 これは、ASCII アニメーションを少し追加し、作業を一時中断して行うことができます。 質問を 問い返す行の後に、次のコードを追加します。
    var index = new Random().Next(answers.Length - 1);
Console.WriteLine(answers[index]);
     dotnet run -- Should I use top level statements in all my programs?
Should I use top level statements in all my programs?
Better not tell you now.
     for (int i = 0; i < 20; i++)
{
    Console.Write("| -");
    await Task.Delay(50);
    Console.Write("\b\b\b");
    Console.Write("/ \\");
    await Task.Delay(50);
    Console.Write("\b\b\b");
    Console.Write("- |");
    await Task.Delay(50);
    Console.Write("\b\b\b");
    Console.Write("\\ /");
    await Task.Delay(50);
    Console.Write("\b\b\b");
}
Console.WriteLine();
 using ステートメントをソースファイルの先頭に追加する必要もあります。
using ステートメントは、ファイル内の他のどのステートメントよりも前にある必要があります。それ以外の場合、コンパイラエ ラーになります。 プログラムをもう一度実行して、アニメーションを表示することができます。 これにより、エクスペリエンスが向上し ます。 ご自分の好みに合わせて遅延の長さを試してください。
  using System.Threading.Tasks;
 上のコードにより、スペースで区切られた一連の回転する行が作成されます。 await キーワードを追加すると、 async 修飾
   string[] answers =
{
    "It is certain.",       "Reply hazy, try again.",
    "It is decidedly so.",  "Ask again later.",
    "Without a doubt.",     "Better not tell you now.",
    "Yes – definitely.",    "Cannot predict now.",
"Don’t count on it.",
"My reply is no.",
"My sources say no.",
"Outlook not so good.",
    "You may rely on it.",  "Concentrate and ask again.", "Very doubtful.",
    "As I see it, yes.",
    "Most likely.",
    "Outlook good.",
"Yes.",
    "Signs point to yes.",
};
 
   子を持ち、System.Threading.Tasks.Task を返すメソッドとしてプログラムのエントリ ポイントを生成するようにコンパイラに指示 されます。このプログラムからは値が返されないため、プログラムのエントリポイントにより Task が返されます。プログラムから整 数値が返された場合は、最上位レベルのステートメントの末尾に return ステートメントを追加します。 その return ステートメン トにより、返す整数値が指定されます。最上位レベルのステートメントに await 式が含まれている場合は、戻り値の型が System.Threading.Tasks.Task<TResult> になります。
今後のリファクタリング プログラムのコードは次のようになるはずです。
    using System;
using System.Threading.Tasks;
Console.WriteLine();
foreach(var s in args)
{
    Console.Write(s);
    Console.Write(' ');
}
Console.WriteLine();
for (int i = 0; i < 20; i++)
{
    Console.Write("| -");
    await Task.Delay(50);
    Console.Write("\b\b\b");
    Console.Write("/ \\");
    await Task.Delay(50);
    Console.Write("\b\b\b");
    Console.Write("- |");
    await Task.Delay(50);
    Console.Write("\b\b\b");
    Console.Write("\\ /");
    await Task.Delay(50);
    Console.Write("\b\b\b");
}
Console.WriteLine();
string[] answers =
{
    "It is certain.",
    "It is decidedly so.",  "Ask again later.",
    "Without a doubt.",     "Better not tell you now.",
    "Yes – definitely.",    "Cannot predict now.",
    "You may rely on it.",  "Concentrate and ask again.", "Very doubtful.",
    "As I see it, yes.",
    "Most likely.",
    "Outlook good.",
    "Yes.",
    "Signs point to yes.",
};
var index = new Random().Next(answers.Length - 1);
Console.WriteLine(answers[index]);
"Reply hazy, try again.",
"Don’t count on it.",
"My reply is no.",
"My sources say no.",
"Outlook not so good.",
 上のコードは適切です。 正常に動作する。 しかし、再利用することはできません。 これでアプリケーションが動作するようになっ たので、次は再利用可能な部分を取得します。
候補の 1 つとして、待機中のアニメーションを表示するコードがあります。 このスニペットはメソッドになることがあります。 まず、ファイルにローカル関数を作成します。 現在のアニメーションを次のコードに置き換えます。

  前のコードで、main メソッド内にローカル関数が作成されています。 それでも再利用することはできません。 そのため、そのコー ドをクラスに抽出します。 utilities.cs という名前の新しいファイルを作成し、次のコードを追加します。
    using System;
using System.Threading.Tasks;
namespace MyNamespace
{
    public static class Utilities
    {
        public static async Task ShowConsoleAnimation()
        {
            for (int i = 0; i < 20; i++)
            {
                Console.Write("| -");
                await Task.Delay(50);
                Console.Write("\b\b\b");
                Console.Write("/ \\");
                await Task.Delay(50);
                Console.Write("\b\b\b");
                Console.Write("- |");
                await Task.Delay(50);
                Console.Write("\b\b\b");
                Console.Write("\\ /");
                await Task.Delay(50);
                Console.Write("\b\b\b");
}
            Console.WriteLine();
        }
} }
 最上位レベルのステートメントは 1 つのファイルにのみ含めることができ、そのファイルには名前空間や型を含めることはできませ ん。
最後に、アニメーション コードをクリーンアップして、いくつか重複しているものを削除することができます。
   await ShowConsoleAnimation();
static async Task ShowConsoleAnimation()
{
    for (int i = 0; i < 20; i++)
    {
        Console.Write("| -");
        await Task.Delay(50);
        Console.Write("\b\b\b");
        Console.Write("/ \\");
        await Task.Delay(50);
        Console.Write("\b\b\b");
        Console.Write("- |");
        await Task.Delay(50);
        Console.Write("\b\b\b");
        Console.Write("\\ /");
        await Task.Delay(50);
        Console.Write("\b\b\b");
}
    Console.WriteLine();
}
 
  これでアプリケーションが完成し、後で使用するために再利用可能な部分がリファクタリングされました。 以下のメイン プログラム の完成版で示されているように、最上位レベルのステートメントから新しいユーティリティ メソッドを呼び出すことができます。
    using System;
using MyNamespace;
Console.WriteLine();
foreach(var s in args)
{
    Console.Write(s);
    Console.Write(' ');
}
Console.WriteLine();
await Utilities.ShowConsoleAnimation();
string[] answers =
{
    "It is certain.",       "Reply hazy, try again.",
    "It is decidedly so.",  "Ask again later.",
    "Without a doubt.",     "Better not tell you now.",
    "Yes – definitely.",    "Cannot predict now.",
"Don’t count on it.",
"My reply is no.",
"My sources say no.",
"Outlook not so good.",
    "You may rely on it.",  "Concentrate and ask again.", "Very doubtful.",
    "As I see it, yes.",
    "Most likely.",
    "Outlook good.",
"Yes.",
    "Signs point to yes.",
};
var index = new Random().Next(answers.Length - 1);
Console.WriteLine(answers[index]);
  これにより、 Utilities.ShowConsoleAnimation の呼び出しが追加され、別の using ステートメントが追加されます。 まとめ
最上位レベルのステートメントを利用すると、新しいアルゴリズムを探索するのに使用するシンプルなプログラムをより簡単に作成 できます。 異なるコード スニペットを試すことで、アルゴリズムを試してみることができます。 動作について学習したら、コードをよ り保守しやすいようにリファクタリングできます。
最上位レベルのステートメントを使用すると、コンソール アプリケーションに基づくプログラムが簡素化されます。 これには、Azure Functions、GitHub Actions、およびその他の小規模なユーティリティが含まれます。
   foreach (string s in new[] { "| -", "/ \\", "- |", "\\ /", })
{
    Console.Write(s);
    await Task.Delay(50);
    Console.Write("\b\b\b");
}
 
      C# のパターン マッチング機能には、アルゴリズムを表すための構文が用意されています。 これらの手法を使用して、クラスの動 作を実装できます。 オブジェクト指向のクラス設計と、データ指向の実装を組み合わせることで、現実のオブジェクトをモデル化 しながら、簡潔なコードを提供できます。
このチュートリアルで学習する内容は次のとおりです。
データ パターンを使用して、オブジェクト指向のクラスを表現します。
C# のパターン マッチング機能を使用して、それらのパターンを実装します。 コンパイラの診断機能を利用して、実装を検証します。
前提条件
コンピューターを、C# 9.0 コンパイラが含まれる .NET 5 が実行されるように設定する必要があります。 C# 9.0 コンパイラ
は、Visual Studio 2019 バージョン 16.8 プレビュー以降または .NET 5.0 SDK プレビュー以降で使用できます。 運河の水門のシミュレーションを構築する
このチュートリアルでは、運河の水門をシミュレートする C# クラスを構築します。 簡単に言うと、運河の水門は、水面の高さが 異なる 2 つの水路の間を通過するときに船を上げ下げする仕組みです。 水門には、2 つのゲートと、水位を変更するためのメ カニズムがあります。
通常の操作では、船が一方のゲートから進入するとき、水門の水位は船が進入する側の水位と一致しています。 水門内に 入ると、船が水門から出て行く側の水位と一致するように、水位が変更されます。 水位がその側と一致すると、出口側のゲー トが開きます。 安全対策により、オペレーターは運河を危険な状態にできないようになっています。 水位は、両方のゲートが閉 じられている場合にのみ変更できます。 開くことができるのは最大で 1 つのゲートです。 ゲートを開くには、水門内の水位が、 開かれるゲートの外側の水位と一致している必要があります。
この動作をモデル化するC#クラスを構築できます。 CanalLock クラスにより、いずれかのゲートを開いたり閉じたりするコマンド がサポートされます。 他に、水を上げ下げするためのコマンドがあります。 また、このクラスにより、両方のゲートと水位の現在の 状態を読み取るためのプロパティもサポートされる必要があります。 これらのメソッドにより安全対策を実装します。
クラスを定義する
CanalLock クラスをテストするコンソールアプリケーションを作成します。VisualStudioまたは.NETCLIを使用して、.NET5 用の新しいコンソールプロジェクトを作成します。次に、新しいクラスを追加し、CanalLock という名前を指定します。次に、 パブリック API を設計しますが、メソッドは実装しないでおきます。
   パターン マッチングを使用して、より良いコー
ドのためのクラスの動作を構築する
2021/03/06 • • Edit Online
 
  上のコードにより、両方のゲートが閉じていて、水位が低になるように、オブジェクトが初期化されます。 次に、クラスの最初の実 装を作成するときのガイドにするため、 Main メソッドに次のテスト コードを記述します。
   public enum WaterLevel
{
Low,
High }
public class CanalLock
{
    // Query canal lock state:
    public WaterLevel CanalLockWaterLevel { get; private set; } = WaterLevel.Low;
    public bool HighWaterGateOpen { get; private set; } = false;
    public bool LowWaterGateOpen { get; private set; } = false;
    // Change the upper gate.
    public void SetHighGate(bool open)
    {
        throw new NotImplementedException();
    }
    // Change the lower gate.
    public void SetLowGate(bool open)
    {
        throw new NotImplementedException();
    }
    // Change water level.
    public void SetWaterLevel(WaterLevel newLevel)
    {
        throw new NotImplementedException();
    }
    public override string ToString() =>
        $"The lower gate is {(LowWaterGateOpen ? "Open" : "Closed")}. " +
        $"The upper gate is {(HighWaterGateOpen ? "Open" : "Closed")}. " +
        $"The water level is {CanalLockWaterLevel}.";
}
 
     次に、 CanalLock クラスの各メソッドの最初の実装を追加します。 次のコードにより、安全ルールが考慮されていないクラスの メソッドが実装されます。 安全テストは後で追加します。
    // Change the upper gate.
public void SetHighGate(bool open)
{
    HighWaterGateOpen = open;
}
// Change the lower gate.
public void SetLowGate(bool open)
{
    LowWaterGateOpen = open;
}
// Change water level.
public void SetWaterLevel(WaterLevel newLevel)
{
    CanalLockWaterLevel = newLevel;
}
 これまでに記述したテストは合格です。 基本が実装されました。 次に、最初のエラー条件のテストを記述します。 前のテストの 終了時点では、両方のゲートは閉じられ、水位は低に設定されています。 上の側のゲートを開こうとするテストを追加します。
  // Create a new canal lock:
var canalGate = new CanalLock();
// State should be doors closed, water level low:
Console.WriteLine(canalGate);
canalGate.SetLowGate(open: true);
Console.WriteLine($"Open the lower gate:  {canalGate}");
Console.WriteLine("Boat enters lock from lower gate");
canalGate.SetLowGate(open: false);
Console.WriteLine($"Close the lower gate:  {canalGate}");
canalGate.SetWaterLevel(WaterLevel.High);
Console.WriteLine($"Raise the water level: {canalGate}");
Console.WriteLine(canalGate);
canalGate.SetHighGate(open: true);
Console.WriteLine($"Open the higher gate:  {canalGate}");
Console.WriteLine("Boat exits lock at upper gate");
Console.WriteLine("Boat enters lock from upper gate");
canalGate.SetHighGate(open: false);
Console.WriteLine($"Close the higher gate: {canalGate}");
canalGate.SetWaterLevel(WaterLevel.Low);
Console.WriteLine($"Lower the water level: {canalGate}");
canalGate.SetLowGate(open: true);
Console.WriteLine($"Open the lower gate:  {canalGate}");
Console.WriteLine("Boat exits lock at upper gate");
canalGate.SetLowGate(open: false);
Console.WriteLine($"Close the lower gate:  {canalGate}");

  ゲートが開くため、このテストは失敗します。 最初の実装として、次のコードを使用して修正できます。
    // Change the upper gate.
public void SetHighGate(bool open)
{
    if (open && (CanalLockWaterLevel == WaterLevel.High))
        HighWaterGateOpen = true;
    else if (open && (CanalLockWaterLevel == WaterLevel.Low))
        throw new InvalidOperationException("Cannot open high gate when the water is low");
}
 テストは合格します。 しかし、さらにテストを追加していくと、 if 句がどんどん増え、異なるプロパティをテストするようになりま す。 やがて、メソッドが複雑すぎて、条件を追加できなくなります。
パターンを使用してコマンドを実装する
もっとよい方法は、" パターン " を使用して、オブジェクトがコマンドを実行するための有効な状態であるかどうかを判断することで す。 次の 3 つの変数の関数として、コマンドが許可されるかどうかを表すことができます: ゲートの状態、水位、新しい設定。
        [不可] [不可] 高
[不可] [不可] 低 [不可] 開く 高
解決済み [ファイル] 低 開く 解決済み 高 開く 解決済み 低 開く 開く 高 [ファイル] [ファイル] 低
[不可] [不可] 開く 解決済み 開く
閉 (エラー) 開く
閉 (エラー)
                                                               表の 4 番目と最後の行は無効であるため、テキストを消してあります。 ここで追加しようとしているコードを使用して、水位が低 いときは、高い水位のゲートが開かれないようにする必要があります。 それらの状態は、1 つの switch 式としてコーディングでき ます(false は"閉"を示すことに注意してください)。
   Console.WriteLine("=============================================");
Console.WriteLine("     Test invalid commands");
// Open "wrong" gate (2 tests)
try
{
    canalGate = new CanalLock();
    canalGate.SetHighGate(open: true);
}
catch (InvalidOperationException)
{
    Console.WriteLine("Invalid operation: Can't open the high gate. Water is low.");
}
Console.WriteLine($"Try to open upper gate: {canalGate}");
 
  このバージョンを試してみます。 テストは合格し、コードが検証されました。 完全な表には、入力と結果の可能な組み合わせが 示されています。 これは、自分や他の開発者が表をすばやく見て、可能なすべての入力が網羅されていることを確認できること を意味します。 さらに簡単にするには、コンパイラも役に立ちます。 前のコードを追加した後、コンパイラによって警告が生成さ れることがあります。 CS8524 は、switch 式ですべての可能な入力がカバーされていないことを示します。 その警告が表示され る原因は、入力の1つが enum 型であることです。コンパイラでは、"可能なすべての入力"は、基になる型からのすべての入 力 (通常は int ) と解釈されます。 この switch 式の場合、 enum で宣言されている値のみがチェックされています。 警告を 除去するには、式の最後のアームに、キャッチオール破棄パターンを追加します。 この状態は無効な入力を示すため、例外を スローします。
前記のswitchアームは、すべての入力に一致するため、switch 式の最後に置く必要があります。前の方の順序に移動し て実験します。 そのようにすると、パターン内に到達できないコードがあることを示すコンパイラ エラー CS8510 が発生します。 switch 式の自然な構造により、コンパイラはエラーや警告を生成して間違いを防ぐことができます。 コンパイラの "セーフティ ネッ ト" により、少ない繰り返しで正しいコードをより簡単に作成でき、switch アームとワイルドカードを自由に組み合わせることがで きます。 組み合わせによって意図せず到達できないアームが作成されると、コンパイラによってエラーが表示され、必要なアーム を削除すると警告が表示されます。
最初の変更は、コマンドによってゲートが閉じられるすべてのアームを結合することです。これは常に許可されます。 次のコードを switch 式の最初のアームとして追加します。
前のswitchアームを追加すると、4つのコンパイラエラーが発生します。コマンドが false であるアームごとに1つあります。そ れらのアームは、新しく追加したアームによって既にカバーされています。 それら 4 つの行は安全に削除できます。 この新しい switch アームを使用して、それらの条件を置き換えます。
次に、ゲートを開くコマンドの 4 つのアームを簡略化できます。 水位が高であるどちらの場合も、ゲートを開くことができます。 (1 つでは既に開いています)。水位が低である 1 つのケースでは例外がスローされ、もう 1 つのケースでは発生しません。 水門が 既に無効な状態である場合は、同じ例外がスローされても安全である必要があります。 それらのアームは、次のように簡略化 できます。
テストを再び実行すると、それらは合格します。 SetHighGate メソッドの最終バージョンは次のようになります。
   _  => throw new InvalidOperationException("Invalid internal state"),
    (false, _, _) => false,
     (true, _, WaterLevel.High) => true,
(true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the water
is low"),
_ => throw new InvalidOperationException("Invalid internal state"),
     HighWaterGateOpen = (open, HighWaterGateOpen, CanalLockWaterLevel) switch
{
    (false, false, WaterLevel.High) => false,
    (false, false, WaterLevel.Low) => false,
    (false, true, WaterLevel.High) => false,
    (false, true, WaterLevel.Low) => false, // should never happen
    (true, false, WaterLevel.High) => true,
    (true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the
water is low"),
    (true, true, WaterLevel.High) => true,
    (true, true, WaterLevel.Low) => false, // should never happen
};
 
  パターンを自分で実装する
これで手法を確認できたので、 SetLowGate メソッドと SetWaterLevel メソッドについては自分で入力してください。 まず、次の コードを追加して、それらのメソッドでの無効な操作をテストします。
      Console.WriteLine();
Console.WriteLine();
try
{
    canalGate = new CanalLock();
    canalGate.SetWaterLevel(WaterLevel.High);
    canalGate.SetLowGate(open: true);
}
catch (InvalidOperationException)
{
    Console.WriteLine("invalid operation: Can't open the lower gate. Water is high.");
}
Console.WriteLine($"Try to open lower gate: {canalGate}");
// change water level with gate open (2 tests)
Console.WriteLine();
Console.WriteLine();
try {
}
catch (InvalidOperationException)
{
    Console.WriteLine("invalid operation: Can't raise water when the lower gate is open.");
}
Console.WriteLine($"Try to raise water with lower gate open: {canalGate}");
Console.WriteLine();
Console.WriteLine();
try
{
    canalGate = new CanalLock();
    canalGate.SetWaterLevel(WaterLevel.High);
    canalGate.SetHighGate(open: true);
    canalGate.SetWaterLevel(WaterLevel.Low);
}
catch (InvalidOperationException)
{
    Console.WriteLine("invalid operation: Can't lower water when the high gate is open.");
}
Console.WriteLine($"Try to lower water with high gate open: {canalGate}");
canalGate = new CanalLock();
canalGate.SetLowGate(open: true);
canalGate.SetWaterLevel(WaterLevel.High);
 アプリケーションをもう一度実行します。 新しいテストは失敗し、運河の水門が無効な状態になることを確認できます。 残りの メソッドを自分で実装してみてください。 低い方のゲートを設定するメソッドは、高い方のゲートを設定するメソッドに似ているは ずです。 水位を変更するメソッドのチェックは異なりますが、同様の構造にする必要があります。 水位を設定するメソッドにも同
   // Change the upper gate.
public void SetHighGate(bool open)
{
    HighWaterGateOpen = (open, HighWaterGateOpen, CanalLockWaterLevel) switch
    {
        (false, _,    _)               => false,
        (true, _,     WaterLevel.High) => true,
        (true, false, WaterLevel.Low)  => throw new InvalidOperationException("Cannot open high gate when
the water is low"),
        _                              => throw new InvalidOperationException("Invalid internal state"),
}; }
 
 じプロセスを使用すると便利な場合があります。 次の 4 つのすべての入力から始めます: 両方のゲートの状態、水位の現在の 状態、要求された新しい水位。 switch 式の先頭は次のようになります。
全部で 16 個の switch アームを使用します。 その後、テストと簡略化を行います。 次のようなメソッドができましたか。
    CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
{
// elided };
     // Change the lower gate.
public void SetLowGate(bool open)
{
    LowWaterGateOpen = (open, LowWaterGateOpen, CanalLockWaterLevel) switch
    {
        (false, _, _) => false,
        (true, _, WaterLevel.Low) => true,
        (true, false, WaterLevel.High) => throw new InvalidOperationException("Cannot open high gate when
the water is low"),
        _ => throw new InvalidOperationException("Invalid internal state"),
}; }
// Change water level.
public void SetWaterLevel(WaterLevel newLevel)
{
    CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
    {
        (WaterLevel.Low, WaterLevel.Low, true, false) => WaterLevel.Low,
        (WaterLevel.High, WaterLevel.High, false, true) => WaterLevel.High,
        (WaterLevel.Low, _, false, false) => WaterLevel.Low,
        (WaterLevel.High, _, false, false) => WaterLevel.High,
        (WaterLevel.Low, WaterLevel.High, false, true) => throw new InvalidOperationException("Cannot lower
water when the high gate is open"),
        (WaterLevel.High, WaterLevel.Low, true, false) => throw new InvalidOperationException("Cannot raise
water when the low gate is open"),
        _ => throw new InvalidOperationException("Invalid internal state"),
}; }
 テストは合格し、運河の水門は安全に作動するはずです。
まとめ
このチュートリアルでは、パターン マッチングを使用して、オブジェクトの内部状態に変更を適用する前に、その状態を確認する 方法について学習しました。 プロパティの組み合わせを確認できます。 それらの遷移のいずれかの表を作成したら、コードをテ ストして、読みやすさと保守性のために簡素化できます。 これらの初期リファクタリングにより、内部状態を検証したり、他の API 変更を管理したりするリファクタリングがさらに提案される場合があります。 このチュートリアルでは、クラスとオブジェクトを、よりデー タ指向でパターンベースのアプローチと組み合わせて、それらのクラスを実装しました。

        このチュートリアルでは、C# で文字列補間を使用して、単一の結果の文字列に値を挿入する方法を説明します。 C# コード を記述し、コードをコンパイルおよび実行して結果を確認します。 チュートリアルには、値を文字列に挿入し、それらの値の書式 をさまざまな方法で設定する方法を示す、一連のレッスンが含まれています。
このチュートリアルでは、開発用に使用できるマシンがあることを想定しています。 Windows、Linux、または macOS 上でロー カルの開発環境を設定する手順については、.NET チュートリアル Hello World in 10 minutes (10 分で Hello World) に記 載されています。 また、使用しているブラウザーでこのチュートリアルの対話型バージョンを完了することもできます。
挿入文字列を作成する
interpolated という名前のディレクトリを作成します。 それを現在のディレクトリにして、コンソール ウィンドウから次のコマンドを実 行します。
このコマンドによって、現在のディレクトリに新しい .NET Core コンソール アプリケーションが作成されます。 お好みのエディターで Program.cs を開き、 Console.WriteLine("Hello World!"); の行を次のコードで置き換えます。
<name> は自分の名前に置き換えてください。
コンソール ウィンドウで「 dotnet run 」と入力し、このコードを試します。 プログラムを実行すると、あいさつ文に自分の名前を含 む単一の文字列が表示されます。 WriteLine メソッド呼び出しに含まれる文字列は、挿入文字列式 です。 これは、埋め込 みコードを含む文字列から (結果文字列 という) 単一の文字列を構築できる一種のテンプレートです。 挿入文字列は、文字 列に値を挿入したり、文字列を (結合) 連結したりする場合に特に便利です。
この簡単な例には、すべての挿入文字列に含める必要がある次の 2 つの要素が含まれています。
始まりの引用符文字の前の $ で始まる文字列リテラル。 $ シンボルと引用符文字の間にスペースを挿入することは できません (スペースが含まれている場合の動作を確認したい場合は、 $ 文字の後にスペースを挿入し、ファイルを保 存してから、コンソール ウィンドウで「 dotnet run 」と入力してプログラムを再実行します。 C# コンパイラには、"エラー CS1056:予期しない文字 '$' です" というエラー メッセージが表示されます。
1つ以上の補間式。補間式は、始めかっこと終わりかっこ({ と })で示されます。かっこ内に(null を含む)値を 返す C# 式を配置できます。
その他のいくつかのデータ型を持つ文字列補間の例をさらにいくつか試してみましょう。 さまざまなデータ型を含める
前のセクションでは、文字列補間を使用して、1 つの文字列内に別の文字列を挿入しましたが、 補間式の結果を任意のデー タ型にすることもできます。 挿入文字列にさまざまなデータ型の値を含めてみましょう。
  dotnet new console
       var name = "<name>";
Console.WriteLine($"Hello, {name}. It's a pleasure to meet you!");
     次の例では、最初に、 Name プロパティと ToString メソッドを持つクラス データ型 Vegetable を定義します。このメソッド
文字列補間を使用し、書式設定された文字列を作
成する
2021/03/08 • • Edit Online
 
          は、Object.ToString() メソッドのビヘイビアーをオーバーライドします。   アクセス修飾子により、そのメソッドは、すべての クライアント コードで インスタンスの文字列表現を取得するために使用できるようになります。 この例の
メソッドでは、 Vegetable コンストラクターで初期化される Name プロパティの値を返します。
次に、 new 演算子を使用し、コンストラクター Vegetable に名前を指定することで item という名前の Vegetable クラスの インスタンスを作成します。
最後に、item 変数を挿入文字列に含めます。ここには、DateTime値、Decimal値、Unit 列挙値も含まれます。エディ ターのすべての C# コードを以下のコードに置き換えてから、 dotnet run コマンドを使用して実行します。
 Vegetable
  Vegetable.ToString
  public Vegetable(string name) => Name = name;
     var item = new Vegetable("eggplant");
      using System;
public class Vegetable
{
   public Vegetable(string name) => Name = name;
   public string Name { get; }
   public override string ToString() => Name;
}
public class Program
{
   public enum Unit { item, kilogram, gram, dozen };
   public static void Main()
   {
      var item = new Vegetable("eggplant");
      var date = DateTime.Now;
      var price = 1.99m;
      var unit = Unit.item;
      Console.WriteLine($"On {date}, the price of {item} was {price} per {unit}.");
} }
 補間文字列の挿入式 item は、結果の文字列のテキスト"eggplant"に解決されることに注意してください。これは、式の 結果の型が文字列でない場合に、結果が次の方法で文字列に解決されるためです。
補間式が null の場合、空の文字列(""、またはString.Empty)が使用されます。
補間式が null でない場合、通常、結果の型の ToString メソッドが呼び出されます。 メソッ ドの実装を更新して、これをテストすることができます。 すべての型にこのメソッドの実装が含まれるため、 メ ソッドを実装する必要なない場合があります。これをテストするには、例の Vegetable.ToString メソッドの定義をコメ ントアウトします(この操作を行うには、コメントシンボル // を前に配置します)。出力では、"eggplant"という文字 列が完全修飾型名 (この例では "Vegetable") に置き換えられます。これは、Object.ToString() メソッドの既定の動作 です。列挙値の ToString メソッドの既定の動作は、値の文字列表現を返すことです。
この例の出力では、日付の精度が高すぎ ("eggplant" の価格は毎秒変更されることはありません)、価格の値は通貨の単位 を示していません。 次のセクションでは、式の結果における文字列表現の書式を制御することで、こうした問題を修正する方 法について説明します。
  Vegetable.ToString
 ToString
  補間式の書式設定を制御する
 public
 
      前のセクションでは、適切に書式設定されていない 2 つの文字列が結果文字列に挿入されました。 1 つは、日付のみが適切 な日時の値でした。 もう 1 つは、通貨単位を示さない価格でした。 両方の問題には簡単に対処することができます。 文字列 補間では、特定の型の書式設定を制御する書式指定文字列を指定することができます。前の例の Console.WriteLine 呼び出しを変更し、次の行に示すように、日付と価格の式の書式指定文字列を含めます。
コロン (":") と書式指定文字列を持つ補間式に従って、書式指定文字列を指定します。 "d" は、短い日付形式を表す標準 の日時書式設定文字列です。 "C2" は、小数点以下が 2 桁の通貨値として数値を表す標準の数値書式指定文字列で す。
.NET ライブラリの多くの型で、定義済みの書式指定文字列セットがサポートされています。 これらには、数値型と日時型がすべ て含まれます。 書式指定文字列をサポートする型の完全なリストについては、「.Net 型の書式設定」記事の「.NET クラス ライ ブラリの型および書式指定文字列」を参照してください。
テキスト エディターで書式指定文字列を変更してみて、変更するたびにプログラムを再実行し、変更が日時と数値の書式設 定にどのように影響するかを確認します。 {date:d} の"d"を"t"(短い時刻形式を表示する)、"y"(年と月を表示する)、 "yyyy"(4桁の数字として年を表示する)に変更します。 {price:C2} "C2"を"e"(指数表記の場合)と"F3"(小数点以下 が 3 桁の数値の場合) に変更します。
書式設定を制御するだけでなく、結果の文字列に含まれる書式指定された文字列のフィールドの幅と配置を制御することもで きます。 次のセクションでは、この方法を説明します。
補間式のフィールドの幅と配置を制御する
通常、補間式の結果が文字列に書式設定される場合、文字列は先頭スペースおよび末尾スペースなしで結果文字列に含 まれます。 通常、データのセットを操作する場合、フィールドの幅とテキストの配置を制御できることで、読みやすい出力を生成 できます。 そのためには、テキスト エディターのすべてのコードを次のコードに置き換えてから、「 dotnet run 」と入力してプログラ ムを実行します。
   Console.WriteLine($"On {date:d}, the price of {item} was {price:C2} per {unit}.");
        using System;
using System.Collections.Generic;
public class Example
{
   public static void Main()
   {
      var titles = new Dictionary<string, string>()
      {
          ["Doyle, Arthur Conan"] = "Hound of the Baskervilles, The",
          ["London, Jack"] = "Call of the Wild, The",
          ["Shakespeare, William"] = "Tempest, The"
};
      Console.WriteLine("Author and Title List");
      Console.WriteLine();
      Console.WriteLine($"|{"Author",-25}|{"Title",30}|");
      foreach (var title in titles)
} }
Console.WriteLine($"|{title.Key,-25}|{title.Value,30}|");
 作成者の名前は左揃えになり、書き込まれたタイトルは右揃えになります。 補間式の後にコンマ (",") を追加し、最小 のフィー ルド幅を指定して、配置を指定します。 指定された値が正数の場合、フィールドは右揃えになります。 負数の場合、フィール ドは左揃えになります。
  {"Author",-25} と {title.Key,-25} のコードから負号を削除してみて、次のコードのように、例を再実行します。

    この場合、作成者情報は右揃えになります。
単一の補間式にアラインメント指定子と書式指定文字列を組み合わせることができます。 この操作を行うには、最初に配置 を指定して、その後にコロンと書式指定文字列を続けます。 Main メソッド内のすべてのコードを次のコードに置き換えると、 フィールド幅が定義された 3 つの書式指定された文字列が表示されます。 次に、 dotnet run コマンドを入力してプログラムを 実行します。
出力は次のようになります。
文字列補間のチュートリアルはこれで終了です。
詳細については、文字列補間に関するトピックと「C# における文字列補間」チュートリアルを参照してください。
   Console.WriteLine($"[{DateTime.Now,-20:d}] Hour [{DateTime.Now,-10:HH}] [{1063.342,15:N2}] feet");
   [04/14/2018          ] Hour [16        ] [       1,063.34] feet
    Console.WriteLine($"|{"Author",25}|{"Title",30}|");
foreach (var title in titles)
   Console.WriteLine($"|{title.Key,25}|{title.Value,30}|");
 
          このチュートリアルは、文字列補間を使用して結果文字列に式の結果を書式設定したものを含める方法を示しています。 例 では、基本的な C# の概念と .NET の型の書式設定について理解していることを前提としています。 文字列補間や .NET の 型の書式設定の経験がない場合は、最初に対話型の文字列補間に関するチュートリアルを参照してください。 .NET の型の 書式設定の詳細については、「.NET での型の書式設定」のトピックを参照してください。
はじめに
文字列補間機能は、複合書式設定機能の上に構築されていて、結果文字列に書式設定された式の結果を含めるためのよ り読みやすく、便利な構文を提供します。
文字列リテラルを挿入文字列として識別するため、先頭に $ の記号を追加してください。挿入文字列の値を返す、有効な C# の式を埋め込むことができます。 次の例では、式が評価されるとすぐにその結果が文字列に変換され、結果文字列に含ま れています。
    NOTE
この記事の C# 例は、Try.NET インライン コード ランナーとプレイグラウンドで実行されます。 [ ] ボタンを選択すると、対話型ウィンドウで例 が実行されます。 コードを実行したら、コードを変更し、 [ ] をもう一度選択して変更後のコードを実行できます。 変更後のコードが対話 型ウィンドウで実行されるか、コンパイルできなかった場合、対話型ウィンドウにすべての C# コンパイラ エラー メッセージが表示されます。
     double a = 3;
double b = 4;
Console.WriteLine($"Area of the right triangle with legs of {a} and {b} is {0.5 * a * b}");
Console.WriteLine($"Length of the hypotenuse of the right triangle with legs of {a} and {b} is
{CalculateHypotenuse(a, b)}");
double CalculateHypotenuse(double leg1, double leg2) => Math.Sqrt(leg1 * leg1 + leg2 * leg2);
// Expected output:
// Area of the right triangle with legs of 3 and 4 is 6
// Length of the hypotenuse of the right triangle with legs of 3 and 4 is 5
 例に示すように、式を中かっこで囲むことで挿入文字列に含めることができます。
挿入文字列では、文字列の複合書式設定機能に含まれるすべての機能がサポートされます。 そのため、String.Format メ ソッドを使用するよりも読みやすい代替手法になります。
補間式の書式設定文字列を指定する方法
コロン (":") と書式設定文字列を持つ補間式に従って、式の結果の型でサポートされる書式設定文字列を指定します。
  {<interpolationExpression>}
   {<interpolationExpression>:<formatString>}
 次の例は、日時や数値による結果を生成する式の標準とカスタムの書式設定文字列を指定する方法を示しています。
C# における文字列補間 2020/05/20 • • Edit Online
 
        詳細については、「複合書式設定」トピックの「Format String コンポーネント」のセクションを参照してください。 このセクションで は、.NET の基本データ型でサポートされる標準とカスタムの書式設定文字列について説明するトピックへのリンクを提供してい ます。
書式設定された補間式のフィールドの幅と配置を制御する方法
コンマ (",") と定数式を持つ補間式に従って、書式設定された式の結果の最小フィールド幅と配置を指定します。
alignment の値が正の値である場合、書式設定された式の結果は右揃えになります。負の値である場合は、左揃えになりま す。
配置と書式設定文字列の両方を指定する必要がある場合は、alignment コンポーネントから開始します。
次の例は、配置を指定する方法を示し、テキスト フィールドを区切るためにパイプ文字 ("|") を使用しています。
  {<interpolationExpression>,<alignment>}
   {<interpolationExpression>,<alignment>:<formatString>}
     const int NameAlignment = -9;
const int ValueAlignment = 7;
double a = 3;
double b = 4;
Console.WriteLine($"Three classical Pythagorean means of {a} and {b}:");
Console.WriteLine($"|{"Arithmetic",NameAlignment}|{0.5 * (a + b),ValueAlignment:F3}|");
Console.WriteLine($"|{"Geometric",NameAlignment}|{Math.Sqrt(a * b),ValueAlignment:F3}|");
Console.WriteLine($"|{"Harmonic",NameAlignment}|{2 / (1 / a + 1 / b),ValueAlignment:F3}|");
// Expected output:
// Three classical Pythagorean means of 3 and 4:
// |Arithmetic|  3.500|
// |Geometric|  3.464|
// |Harmonic |  3.429|
 出力例が示すように、書式設定された式の結果の長さが指定したフィールドの幅を超える場合、alignment の値は無視され ます。
詳細については、「複合書式設定」トピックの「Alignment コンポーネント」のセクションを参照してください。 挿入文字列でエスケープ シーケンスを使用する方法
挿入文字列は、通常の文字列リテラルで使用できるすべてのエスケープ シーケンスをサポートします。 詳細については、「文字 列のエスケープ シーケンス」を参照してください。
エスケープシーケンスをリテラルで解釈するには、verbatim文字列リテラルを使用します。verbatim補間文字列は、$ 文 字で始まり、 @ 文字が続きます。 C# 8.0 以降では、 $ と @ のトークンを任意の順序で使用できます。 $@"..." と
  @$"..." はどちらも有効なverbatim補間文字列です。
   var date = new DateTime(1731, 11, 25);
Console.WriteLine($"On {date:dddd, MMMM dd, yyyy} Leonhard Euler introduced the letter e to denote
{Math.E:F5} in a letter to Christian Goldbach.");
// Expected output:
// On Sunday, November 25, 1731 Leonhard Euler introduced the letter e to denote 2.71828 in a letter to
Christian Goldbach.
 
       中かっこ "{" または "}" を結果文字列に含める場合は、2 つの中かっこ "{{" または "}}" を使用します。 詳細については、「複 合書式設定」トピックの「エスケープ中かっこ ({})」のセクションを参照してください。
次の例は、結果文字列に中かっこを含め、verbatim 挿入文字列を作成する方法を示しています。
    var xs = new int[] { 1, 2, 7, 9 };
var ys = new int[] { 7, 9, 12 };
Console.WriteLine($"Find the intersection of the {{{string.Join(", ",xs)}}} and {{{string.Join(", ",ys)}}}
sets.");
var userName = "Jane";
var stringWithEscapes = $"C:\\Users\\{userName}\\Documents";
var verbatimInterpolated = $@"C:\Users\{userName}\Documents";
Console.WriteLine(stringWithEscapes);
Console.WriteLine(verbatimInterpolated);
// Expected output:
// Find the intersection of the {1, 2, 7, 9} and {7, 9, 12} sets.
// C:\Users\Jane\Documents
// C:\Users\Jane\Documents
 補間式で三項条件演算子 ?: を使用する方法
コロン (":") が補間式の項目で特別な意味を持つときに、式で条件演算子を使用するには、次の例が示すようにその式をかっ
こで囲みます。
文字列補間を使用してカルチャ固有の結果文字列を作成する方法
既定では、挿入文字列は、すべての書式設定操作に対して CultureInfo.CurrentCulture プロパティで定義された現在のカ ルチャを使用します。 カルチャ固有の結果文字列を作成するには、System.FormattableString インスタンスへの挿入文字列 の暗黙的変換を使用し、その ToString(IFormatProvider) メソッドを呼び出します。 その方法を次の例に示します。
    var rand = new Random();
for (int i = 0; i < 7; i++)
{
    Console.WriteLine($"Coin flip: {(rand.NextDouble() < 0.5 ? "heads" : "tails")}");
}
 
            例に示すように、FormattableString インスタンスを 1 回使用して、さまざまなカルチャに対する複数の結果文字列を生成す ることができます。
インバリアント カルチャを使用して結果文字列を作成する方法 FormattableString.ToString(IFormatProvider) メソッドと共に静的な FormattableString.Invariant メソッドを使用し
て、InvariantCulture の結果文字列に挿入文字列を解決することができます。 その方法を次の例に示します。
まとめ
このチュートリアルでは、文字列補間の使用に関する一般的なシナリオについて説明しています。 文字列補間の詳細について は、文字列補間に関するトピックを参照してください。 .NET の型の書式設定の詳細については、「.NET での型の書式設定」 および「複合書式設定」のトピックを参照してください。
参照
String.Format System.FormattableString System.IFormattable 文字列
    string messageInInvariantCulture = FormattableString.Invariant($"Date and time in invariant culture:
{DateTime.Now}");
Console.WriteLine(messageInInvariantCulture);
// Expected output is like:
// Date and time in invariant culture: 05/17/2018 15:46:24
    var cultures = new System.Globalization.CultureInfo[]
{
    System.Globalization.CultureInfo.GetCultureInfo("en-US"),
    System.Globalization.CultureInfo.GetCultureInfo("en-GB"),
    System.Globalization.CultureInfo.GetCultureInfo("nl-NL"),
    System.Globalization.CultureInfo.InvariantCulture
};
var date = DateTime.Now;
var number = 31_415_926.536;
FormattableString message = $"{date,20}{number,20:N3}";
foreach (var culture in cultures)
{
    var cultureSpecificMessage = message.ToString(culture);
    Console.WriteLine($"{culture.Name,-10}{cultureSpecificMessage}");
}
// Expected output is like:
// en-US
// en-GB
// nl-NL
//
 5/17/18 3:44:55 PM
17/05/2018 15:44:55
  17-05-18 15:44:55
05/17/2018 15:44:55
31,415,926.536
31,415,926.536
31.415.926,536
31,415,926.536
 
      .NET Core 3.0 上の C# 8.0 以降では、インターフェイスのメンバーを宣言するときに実装を定義できます。 最も一般的なシナ リオは、数え切れないほどのクライアントから既にリリースされ、使用されているインターフェイスにメンバーを安全に追加することで す。
このチュートリアルでは、次の作業を行う方法について説明します。
実装を含むメソッドを追加して、インターフェイスを安全に拡張します。 パラメーター化された実装を作成して、柔軟性を高めます。 実装者がオーバーライドの形でより具体的な実装を提供できるようにします。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。C# 8.0 コンパイラも実行されるようにしま
す。 C# 8.0 コンパイラは Visual Studio 2019 バージョン 16.3 または .NET Core 3.0 SDK 以降で使用できます。 シナリオの概要
このチュートリアルは、カスタマー リレーションシップ ライブラリのバージョン 1 から始まります。 GitHub 上の サンプル リポジトリでス ターター アプリケーションを入手できます。 このライブラリを構築した会社の目的は、既存のアプリケーションを使用している顧客 がライブラリを採用することでした。 ライブラリのユーザーが実装できる最小限のインターフェイス定義が用意されました。 顧客向 けのインターフェイス定義は次のとおりです。
    public interface ICustomer
{
    IEnumerable<IOrder> PreviousOrders { get; }
    DateTime DateJoined { get; }
    DateTime? LastOrder { get; }
    string Name { get; }
    IDictionary<DateTime, string> Reminders { get; }
}
 注文を表す 2 つ目のインターフェイスを定義しました。
チームは、これらのインターフェイスからユーザー向けのライブラリを構築し、顧客にとってより良いエクスペリエンスを作り出すことが できました。 目標は、既存の顧客との関係を深め、新しい顧客との関係を改善することでした。
次回のリリースのためにライブラリをアップグレードする時期になりました。 求められている機能の 1 つは、注文数が多い顧客向 けにロイヤルティ割引を有効にすることです。 この新しいロイヤルティ割引は、顧客が注文するたびに適用されます。 この特定
    public interface IOrder
{
    DateTime Purchased { get; }
    decimal Cost { get; }
}
 チュートリアル: C# 8.0 で既定のインターフェイ
ス メソッドを使用してインターフェイスを更新
する
2020/11/02 • • Edit Online
 
 の割引は、各顧客のプロパティです。   の各実装で、ロイヤルティ割引に対して異なるルールを設定できます。
 この機能を追加する最も自然な方法は、ロイヤルティ割引を適用するメソッドを使用して ICustomer インターフェイスを拡張 することです。 この設計の提案から、経験豊富な開発者の間で次のような懸念が起こりました。「リリース済みのインターフェイス は変更できません。 これは破壊的変更です」 C# 8.0 では、インターフェイスをアップグレードするための "既定のインターフェイス 実装" が追加されました。 ライブラリ作成者はインターフェイスに新しいメンバーを追加し、それらのメンバーに既定の実装を指 定することができます。
既定のインターフェイス実装を使用すると、開発者がインターフェイスをアップグレードできるだけでなく、すべての実装者がその実 装をオーバーライドできるようになります。 ライブラリのユーザーは、非破壊的変更として既定の実装を受け入れることができま す。 ビジネス ルールが異なる場合は、オーバーライドできます。
既定のインターフェイス メソッドを使用してアップグレードする
チームは、最も可能性の高い既定の実装、つまり顧客に対するロイヤルティ割引について合意しました。
アップグレードでは、2 つのプロパティを設定する機能を提供する必要があります。割引の対象となるために必要な注文数と、 割引の割合です。これは、既定のインターフェイスメソッドに最適なシナリオです。 ICustomer インターフェイスにメソッドを追 加し、最も確実な実装を提供することができます。 すべての既存の実装とすべての新しい実装では、既定の実装を使用する ことも、独自の実装を提供することもできます。
まず、メソッドの本体を含め、インターフェイスに新しいメソッドを追加します。
     // Version 1:
public decimal ComputeLoyaltyDiscount()
{
    DateTime TwoYearsAgo = DateTime.Now.AddYears(-2);
    if ((DateJoined < TwoYearsAgo) && (PreviousOrders.Count() > 10))
    {
        return 0.10m;
    }
return 0; }
 ライブラリ作成者は、実装を確認する最初のテストを作成しました。
    SampleCustomer c = new SampleCustomer("customer one", new DateTime(2010, 5, 31))
{
Reminders = {
        { new DateTime(2010, 08, 12), "childs's birthday" },
        { new DateTime(1012, 11, 15), "anniversary" }
    }
};
SampleOrder o = new SampleOrder(new DateTime(2012, 6, 1), 5m);
c.AddOrder(o);
o = new SampleOrder(new DateTime(2103, 7, 4), 25m);
c.AddOrder(o);
// Check the discount:
ICustomer theCustomer = c;
Console.WriteLine($"Current discount: {theCustomer.ComputeLoyaltyDiscount()}");
 テストの次の部分に注目してください。
 ICustomer
 
      SampleCustomer から ICustomer へのキャストは必須です。 SampleCustomer クラスから の実装 を提供する必要はありません。これは ICustomer インターフェイスによって提供されます。ただし、 クラスはそ のインターフェイスからメンバーを継承しません。 そのルールは変わっていません。 インターフェイスで宣言および実装されているメ ソッドを呼び出すには、変数をインターフェイスの型(この例では ICustomer)似する必要があります。
パラメーター化を提供する
なかなかのスタートです。 ただし、既定の実装は制限が厳しすぎます。 このシステムの多くの利用者は、異なる購入数のしきい 値、異なる長さのメンバーシップ、または異なる割引率を選択する可能性があります。 これらのパラメーターを設定する方法を 用意することで、より多くの顧客とって優れたアップグレード エクスペリエンスを提供できます。 既定の実装を制御するこれら 3 つ のパラメーターを設定する静的メソッドを追加しましょう。
ComputeLoyaltyDiscount
  SampleCustomer
     // Version 2:
public static void SetLoyaltyThresholds(
    TimeSpan ago,
    int minimumOrders = 10,
    decimal percentageDiscount = 0.10m)
{
    length = ago;
    orderCount = minimumOrders;
    discountPercent = percentageDiscount;
}
private static TimeSpan length = new TimeSpan(365 * 2, 0,0,0); // two years
private static int orderCount = 10;
private static decimal discountPercent = 0.10m;
public decimal ComputeLoyaltyDiscount()
{
    DateTime start = DateTime.Now - length;
    if ((DateJoined < start) && (PreviousOrders.Count() > orderCount))
    {
        return discountPercent;
    }
return 0; }
 このわずかなコード フラグメントには、新しい言語機能が多数見られます。 インターフェイスには、フィールドやメソッドなどの静的 メンバーを含めることができるようになりました。 さまざまなアクセス修飾子も使用できます。 追加のフィールドはプライベートであ り、新しいメソッドはパブリックです。 どの修飾子もインターフェイス メンバーに使用できます。
ロイヤルティ割引の計算に一般的な数式を使用する (ただしパラメーターは異なる) アプリケーションでは、カスタム実装を用意 する必要がありません。静的メソッドを介して引数を設定できます。 たとえば、次のコードでは、メンバーシップが 1 か月を超える すべての顧客に報酬を与える "顧客感謝" を設定します。
既定の実装を拡張する
これまでに追加したコードでは、ユーザーが既定の実装のようなものを希望しているシナリオ、または関係のない一連のルールを 指定するシナリオに便利な実装を提供しました。 最後の機能として、コードを少しリファクターして、ユーザーが既定の実装を基 に構築したくなるようなシナリオに対応しましょう。
    ICustomer.SetLoyaltyThresholds(new TimeSpan(30, 0, 0, 0), 1, 0.25m);
Console.WriteLine($"Current discount: {theCustomer.ComputeLoyaltyDiscount()}");
    // Check the discount:
ICustomer theCustomer = c;
Console.WriteLine($"Current discount: {theCustomer.ComputeLoyaltyDiscount()}");
 
   新規顧客を引き付けたいスタートアップ企業があるとします。 新規顧客の最初の注文には 50% 割引が提供されます。 それ 以外の場合、既存の顧客は標準の割引を受けます。 このインターフェイスを実装するすべてのクラスが実装内でコードを再利 用できるように、ライブラリ作成者は既定の実装を protected static メソッドに移行する必要があります。 インターフェイス メ ンバーの既定の実装では、この共有メソッドも呼び出されます。
     public decimal ComputeLoyaltyDiscount() => DefaultLoyaltyDiscount(this);
protected static decimal DefaultLoyaltyDiscount(ICustomer c)
{
    DateTime start = DateTime.Now - length;
    if ((c.DateJoined < start) && (c.PreviousOrders.Count() > orderCount))
    {
        return discountPercent;
    }
return 0; }
 このインターフェイスを実装するクラスの実装では、オーバーライドによって静的ヘルパー メソッドを呼び出し、そのロジックを拡張 して "新規顧客" の割引を提供することができます。
GitHub 上の サンプル リポジトリで完成したコード全体を確認できます。 GitHub 上の サンプル リポジトリでスターター アプリケー ションを入手できます。
これらの新機能は、新しいメンバーに妥当な既定の実装がある場合に、インターフェイスを安全に更新できることを意味しま す。 複数のクラスから実装できる 1 つの機能的なアイデアを表現するように、慎重にインターフェイスを設計してください。 その 結果、同じ機能的なアイデアに対して新しい要件が見つかったときに、そのインターフェイス定義を簡単にアップグレードできるよ うになります。
    public decimal ComputeLoyaltyDiscount()
{
   if (PreviousOrders.Any() == false)
        return 0.50m;
    else
        return ICustomer.DefaultLoyaltyDiscount(this);
}
 
        .NET Core 3.0 上の C# 8.0 以降では、インターフェイスのメンバーを宣言するときに実装を定義できます。 この機能により、イ ンターフェイスで宣言された機能の既定の実装を定義できるという新機能が提供されます。 クラスでは、機能をオーバーライド する場合、既定の機能を使用する場合、および個別の機能のサポートを宣言しない場合を選択できます。
このチュートリアルでは、次の作業を行う方法について説明します。
個別の機能を記述する実装を備えたインターフェイスを作成します。 既定の実装を使用するクラスを作成します。 既定の実装の一部またはすべてをオーバーライドするクラスを作成します。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。C# 8.0 コンパイラも実行されるようにしま
す。 C# 8.0 コンパイラは Visual Studio 2019 バージョン 16.3 または .NET Core 3.0 SDK 以降から使用できます。 拡張メソッドの制限事項
インターフェイスの一部として表示される動作を実装する方法の 1 つとして、既定の動作を提供する拡張メソッドを定義するこ とがあります。 インターフェイスでは、そのインターフェイスを実装するクラスに対してより広い範囲の外部からのアクセスを提供す ると同時に、最小セットのメンバーを宣言します。 たとえば、Enumerable の拡張メソッドは、任意のシーケンスの実装を LINQ クエリのソースとして提供します。
拡張メソッドは、コンパイル時に変数の宣言型を使用して解決されます。 インターフェイスを実装するクラスを使用すると、すべ ての拡張メソッドに対してより適切な実装を提供できます。 コンパイラで実装を選択できるようにするには、変数宣言が実装す る型と一致している必要があります。 コンパイル時の型がインターフェイスと一致する場合、メソッドの呼び出しは拡張メソッドに 解決されます。 拡張メソッドに関するもう 1 つの問題は、拡張メソッドを含むクラスにアクセスできる場所であれば、これらのメ ソッドにアクセスできることです。 クラスでは、拡張メソッドで宣言された機能を提供する必要があるかどうかを宣言できません。
C# 8.0 以降では、既定の実装をインターフェイス メソッドとして宣言できます。 その後は、すべてのクラスで自動的に既定の実 装が使用されます。 より適切な実装を提供できるクラスでは、インターフェイス メソッドの定義をより適切なアルゴリズムでオー バーライドできます。 ある意味では、この手法は拡張メソッドを使用する方法と似ています。
この記事では、既定のインターフェイスの実装で新しいシナリオを実現する方法について説明します。
アプリケーションを設計する
ホーム オートメーション アプリケーションについて考えてみましょう。 家庭内で使用される可能性がある照明とインジケーターに は、おそらくさまざまな種類があります。 すべての照明が、オン/オフを切り替え、現在の状態を報告する API をサポートする必 要があります。 一部の照明とインジケーターでは、次のような他の機能がサポートされている場合があります。
照明をオンにして、タイマーの後にオフにする。 一定の期間、照明を点滅させる。
これらの拡張機能の一部は、最小セットをサポートするデバイスでエミュレートできます。 これは、既定の実装を提供することを 示します。 より多くの機能が組み込まれているデバイスの場合、デバイス ソフトウェアではネイティブ機能を使用します。 他の照
チュートリアル: 既定のインターフェイス メソッ
ドでインターフェイスを使用してクラスを作成す
るときの機能の混合
2021/03/08 • • Edit Online
 
 明については、インターフェイスを実装し、既定の実装を使用することを選択できます。
このシナリオでは、拡張メソッドよりも既定のインターフェイス メンバーの方が適したソリューションです。 クラス作成者は、実装す るインターフェイスを制御できます。 選択したインターフェイスはメソッドとして利用できます。 また、既定のインターフェイス メソッ ドは既定で仮想であるため、メソッドのディスパッチでは常にクラス内の実装が選択されます。
これらの違いを示すコードを作成してみましょう。
インターフェイスを作成する まず、すべての照明の動作を定義するインターフェイスを作成します。
基本的な天井の照明器具では、次のコードに示すようにこのインターフェイスを実装する場合があります。
    public interface ILight
{
    void SwitchOn();
    void SwitchOff();
    bool IsOn();
}
     public class OverheadLight : ILight
{
    private bool isOn;
    public bool IsOn() => isOn;
    public void SwitchOff() => isOn = false;
    public void SwitchOn() => isOn = true;
    public override string ToString() => $"The light is {(isOn ? "on" : "off")}";
}
 このチュートリアルでは、IoT デバイスを駆動していませんが、コンソールにメッセージを書き込んでそのアクティビティをエミュレートし ます。 家を自動化せずにコードを調べることができます。
次に、タイムアウト後に自動的にオフにできる照明のインターフェイスを定義します。
天井の照明に基本的な実装を追加することもできますが、おすすめのソリューションは、このインターフェイス定義を変更して virtual の既定の実装を提供することです。
    public interface ITimerLight : ILight
{
    Task TurnOnFor(int duration);
}
      public interface ITimerLight : ILight
{
    public async Task TurnOnFor(int duration)
    {
        Console.WriteLine("Using the default interface method for the ITimerLight.TurnOnFor.");
        SwitchOn();
        await Task.Delay(duration);
        SwitchOff();
        Console.WriteLine("Completed ITimerLight.TurnOnFor sequence.");
    }
}
  この変更を追加することで、 OverheadLight クラスで、インターフェイスのサポートを宣言してタイマー関数を実装できます。

   照明の種類によっては、より高度なプロトコルがサポートされている場合があります。 次のコードに示すように、 TurnOnFor の独 自の実装を提供できます。
    public class HalogenLight : ITimerLight
{
    private enum HalogenLightState
    {
        Off,
        On,
        TimerModeOn
}
    private HalogenLightState state;
    public void SwitchOn() => state = HalogenLightState.On;
    public void SwitchOff() => state = HalogenLightState.Off;
    public bool IsOn() => state != HalogenLightState.Off;
    public async Task TurnOnFor(int duration)
    {
        Console.WriteLine("Halogen light starting timer function.");
        state = HalogenLightState.TimerModeOn;
        await Task.Delay(duration);
        state = HalogenLightState.Off;
        Console.WriteLine("Halogen light finished custom timer function");
    }
    public override string ToString() => $"The light is {state}";
}
    仮想クラス メソッドのオーバーライドとは異なり、 HalogenLight クラスの TurnOnFor の宣言では、 override キーワードは使 用されません。
機能の混在と対応付け
より高度な機能を導入すると、既定のインターフェイス メソッドの利点が明らかになります。 インターフェイスを使用すると、機能 を混在させて対応付けることができます。 また、各クラスの作成者は、既定の実装とカスタム実装のいずれかを選択できるよう になります。 点滅する照明の既定の実装を持つインターフェイスを追加してみましょう。
    public interface IBlinkingLight : ILight
{
    public async Task Blink(int duration, int repeatCount)
    {
        Console.WriteLine("Using the default interface method for IBlinkingLight.Blink.");
        for (int count = 0; count < repeatCount; count++)
        {
            SwitchOn();
            await Task.Delay(duration);
            SwitchOff();
            await Task.Delay(duration);
}
        Console.WriteLine("Done with the default interface method for IBlinkingLight.Blink.");
    }
}
 既定の実装では、任意の照明を点滅させることができます。 天井の照明には、既定の実装を使用して、タイマーと点滅の両 方の機能を追加できます。
 public class OverheadLight : ITimerLight { }
 
    新しい照明の種類である では、タイマー関数と点滅関数の両方を直接サポートします。 この照明のスタイルでは、 ITimerLight と の両方のインターフェイスを実装し、 Blink メソッドをオーバーライドします。
LEDLight
  IBlinkingLight
    public class LEDLight : IBlinkingLight, ITimerLight, ILight
{
    private bool isOn;
    public void SwitchOn() => isOn = true;
    public void SwitchOff() => isOn = false;
    public bool IsOn() => isOn;
    public async Task Blink(int duration, int repeatCount)
    {
        Console.WriteLine("LED Light starting the Blink function.");
        await Task.Delay(duration * repeatCount);
        Console.WriteLine("LED Light has finished the Blink funtion.");
}
    public override string ToString() => $"The light is {(isOn ? "on" : "off")}";
}
  ExtraFancyLight は、点滅とタイマーの両方の関数を直接サポートしている可能性があります。
    public class ExtraFancyLight : IBlinkingLight, ITimerLight, ILight
{
    private bool isOn;
    public void SwitchOn() => isOn = true;
    public void SwitchOff() => isOn = false;
    public bool IsOn() => isOn;
    public async Task Blink(int duration, int repeatCount)
    {
        Console.WriteLine("Extra Fancy Light starting the Blink function.");
        await Task.Delay(duration * repeatCount);
        Console.WriteLine("Extra Fancy Light has finished the Blink function.");
    }
    public async Task TurnOnFor(int duration)
    {
        Console.WriteLine("Extra Fancy light starting timer function.");
        await Task.Delay(duration);
        Console.WriteLine("Extra Fancy light finished custom timer function");
}
    public override string ToString() => $"The light is {(isOn ? "on" : "off")}";
}
  以前に作成した HalogenLight は、点滅をサポートしていません。そのため、サポートされているインターフェイスの一覧に を追加しないでください。
パターン マッチングを使用して照明の種類を検出する
次に、テスト コードを書いてみましょう。 C# のパターン マッチング機能を利用して、サポートされているインターフェイスを調べるこ とで、照明の機能を決定することができます。 次のメソッドでは、各照明のサポートされている機能を実行します。
 IBlinkingLight
   public class OverheadLight : ILight, ITimerLight, IBlinkingLight
{
    private bool isOn;
    public bool IsOn() => isOn;
    public void SwitchOff() => isOn = false;
    public void SwitchOn() => isOn = true;
    public override string ToString() => $"The light is {(isOn ? "on" : "off")}";
}
 
  Main メソッドの次のコードでは、各照明の種類を順番に作成し、その照明をテストします。
    static async Task Main(string[] args)
{
    Console.WriteLine("Testing the overhead light");
    var overhead = new OverheadLight();
    await TestLightCapabilities(overhead);
    Console.WriteLine();
    Console.WriteLine("Testing the halogen light");
    var halogen = new HalogenLight();
    await TestLightCapabilities(halogen);
    Console.WriteLine();
    Console.WriteLine("Testing the LED light");
    var led = new LEDLight();
    await TestLightCapabilities(led);
    Console.WriteLine();
    Console.WriteLine("Testing the fancy light");
    var fancy = new ExtraFancyLight();
    await TestLightCapabilities(fancy);
    Console.WriteLine();
}
 コンパイラで最適な実装を決定する方法
このシナリオは、実装のない基底インターフェイスを示しています。 ILight インターフェイスにメソッドを追加すると、新たな複雑 さが生じます。 既定のインターフェイス メソッドを管理する言語規則により、複数の派生インターフェイスを実装する具象クラス への影響が最小限に抑えられます。 元のインターフェイスを新しいメソッドで拡張して、その使用方法がどのように変わるかを説 明します。 すべてのインジケーター照明では、その電源の状態を列挙値として報告できます。
    private static async Task TestLightCapabilities(ILight light)
{
    // Perform basic tests:
    light.SwitchOn();
    Console.WriteLine($"\tAfter switching on, the light is {(light.IsOn() ? "on" : "off")}");
    light.SwitchOff();
    Console.WriteLine($"\tAfter switching off, the light is {(light.IsOn() ? "on" : "off")}");
    if (light is ITimerLight timer)
    {
        Console.WriteLine("\tTesting timer function");
        await timer.TurnOnFor(1000);
        Console.WriteLine("\tTimer function completed");
} else {
        Console.WriteLine("\tTimer function not supported.");
    }
    if (light is IBlinkingLight blinker)
    {
        Console.WriteLine("\tTesting blinking function");
        await blinker.Blink(500, 5);
        Console.WriteLine("\tBlink function completed");
} else {
        Console.WriteLine("\tBlink function not supported.");
    }
}
 
  既定の実装では、電源は想定されていません。
ExtraFancyLight が ILight インターフェイスと ITimerLight および 両方の派生インターフェイスのサポー トを宣言していても、これらの変更は正常にコンパイルされます。 インターフェイスで宣言される "最も近い" 実装は 1 つのみです。 オーバーライドを宣言した任意のクラスは、1 つの "最も近い" 実装になります。 上記のクラスの例では、他の派生 インターフェイスのメンバーをオーバーライドしています。
複数の派生インターフェイスで同じメソッドをオーバーライドすることは避けてください。 このようにすると、クラスで両方の派生イン ターフェイスが実装されるたびに、あいまいなメソッド呼び出しが作成されます。 コンパイラでは、より適切な 1 つのメソッドを選択 できないため、エラーが発行されます。 たとえば、 IBlinkingLight と ITimerLight の両方で PowerStatus のオーバーライド が実装されている場合、 OverheadLight にはより具体的なオーバーライドを用意する必要があります。 そうしないと、コンパイ ラでは 2 つの派生インターフェイスで実装を選択できません。 通常、インターフェイスの定義を小さく保ち、1 つの機能に集中す ることで、この状況を回避できます。 このシナリオでは、照明の各機能は独自のインターフェイスです。複数のインターフェイスは クラスからのみ継承されます。
このサンプルでは、クラスに混在させることができる個別の機能を定義できる 1 つのシナリオを示します。 サポートされる機能の セットを宣言するには、クラスがサポートするインターフェイスを宣言します。 仮想の既定のインターフェイス メソッドを使用する と、クラスでは、任意の、またはすべてのインターフェイス メソッドに対して異なる実装を使用または定義できます。 この言語機 能によって、構築している実際のシステムをモデル化する新しい方法が提供されます。 既定のインターフェイス メソッドでは、こ れらの機能の仮想実装を使用して、さまざまな機能を混在させて対応付けることができる関連クラスをより明確に表現できるよ うになります。
    public interface ILight
{
    void SwitchOn();
    void SwitchOff();
    bool IsOn();
    public PowerStatus Power() => PowerStatus.NoPower;
}
     IBlinkingLight
 ILight
       public enum PowerStatus
{
    NoPower,
    ACPower,
    FullBattery,
    MidBattery,
    LowBattery
}
 
     範囲とインデックスには、シーケンス内の 1 つの要素または範囲にアクセスできる簡潔な構文が用意されています。 このチュートリアルでは、次の作業を行う方法について説明します。
シーケンス内の範囲に構文を使用します。 各シーケンスの開始と終了に関する設計上の決定について説明します。 Index 型と Range 型のシナリオについて説明します。
インデックスと範囲の言語サポート
この言語のサポートでは、次の 2 つの新しい型と 2 つの新しい演算子が使用されています。
System.Index はシーケンスとしてインデックスを表します。
indexfromend演算子の ^。シーケンスの末尾から相対的なインデックスを指定します。 System.Range はシーケンスのサブ範囲を表します。
範囲演算子の .. 。範囲の先頭と末尾をそのオペランドとして指定します。
インデックスのルールから始めましょう。配列 sequence を考えます。 0 インデックスは デックスは sequence[sequence.Length] と同じです。 sequence[^0] 式からは、 様に、例外がスローされます。任意の数値 n の場合、インデックス ^n は
と同じです。 ^0 イン の場合と同 と同じです。
  sequence[0]
   sequence[sequence.Length]
 sequence[sequence.Length - n]
    string[] words = new string[]
{
};
// index from start "The", //0
"quick", //1 "brown", //2 "fox", //3 "jumped", //4 "over", //5 "the", //6 "lazy", //7 "dog" //8
//9 (or words.Length)
index from end
^9
^8
^7
^6
^5
^4
^3
^2
^1
^0
 末尾の単語は ^1 インデックスで取得できます。初期化の下に次のコードを追加します。
  Console.WriteLine($"The last word is {words[^1]}");
  範囲は、範囲の先頭と末尾を指定します。範囲は排他的です。つまり、"末尾"は範囲に含まれません。範囲 [0..^0] は、 [0..sequence.Length] が範囲全体を表すのと同じように、範囲全体を表します。
次のコードでは、単語"quick"、"brown"、"fox"から成る部分範囲が作成されます。それには、words[1] から words[3] までが含まれます。要素 words[4] が範囲内にありません。同じメソッドに次のコードを追加します。それをコピーして、対話 型ウィンドウの下部に貼り付けます。
    インデックスと範囲
2021/03/06 • • Edit Online
 
    次のコードでは、"lazy"と"dog"の範囲が返されます。それには、words[^2] と words[^1] が含まれます。末尾インデック ス words[^0] は含まれません。次のコードも追加します。
次の例では、先頭と末尾の一方または両方が開いている範囲が作成されます。
     string[] lazyDog = words[^2..^0];
foreach (var word in lazyDog)
    Console.Write($"< {word} >");
Console.WriteLine();
     string[] allWords = words[..]; // contains "The" through "dog".
string[] firstPhrase = words[..4]; // contains "The" through "fox"
string[] lastPhrase = words[6..]; // contains "the, "lazy" and "dog"
foreach (var word in allWords)
    Console.Write($"< {word} >");
Console.WriteLine();
foreach (var word in firstPhrase)
    Console.Write($"< {word} >");
Console.WriteLine();
foreach (var word in lastPhrase)
    Console.Write($"< {word} >");
Console.WriteLine();
 範囲やインデックスを変数として宣言することもできます。この変数は、文字 [ と ] の内側で使用できます。
次のサンプルは、こうした選択肢の理由の多くを示しています。 x 、 y 、 z を変更してさまざまな組み合わせを試してくださ い。 実験するときには、有効な組み合わせになるように x が y 未満の値、 y が z 未満の値を使用します。 新しいメソッ ドに次のコードを追加します。 さまざまな組み合わせを試してください。
    Index the = ^3;
Console.WriteLine(words[the]);
Range phrase = 1..4;
string[] text = words[phrase];
foreach (var word in text)
    Console.Write($"< {word} >");
Console.WriteLine();
    string[] quickBrownFox = words[1..4];
foreach (var word in quickBrownFox)
    Console.Write($"< {word} >");
Console.WriteLine();
 
            インデックスと範囲の型のサポート
インデックスと範囲を使用すると、シーケンス内の 1 つの要素または要素の範囲にアクセスする構文を明確かつ簡潔に指定で きます。 インデックス式は、一般的に、シーケンスの要素の型を返します。 範囲式は、一般的に、ソース シーケンスと同じシー ケンス型を返します。
Index または Range パラメーターを持つインデクサーが用意されている型では、インデックスまたは範囲がそれぞれ明示的にサ ポートされます。 1 つの Range パラメーターをとるインデクサーからは、System.Span<T> などの別のシーケンス型が返される場 合があります。
    IMPORTANT
範囲演算子を使用したコードのパフォーマンスは、シーケンス オペランドの型によって異なります。
範囲演算子の時間計算量は、シーケンスの種類によって異なります。 たとえば、シーケンスが string または配列の場合、指定したセク ションの入力のコピーが結果として返されるため、時間計算量は O(N) になります (ここで N は範囲の長さです)。 一方、System.Span<T> または System.Memory<T> の場合、結果で同じバッキング ストアが参照されます。つまり、コピーは行われず、操作は O(1) になります。
これでは時間計算量以外に、パフォーマンスに影響する割り当てとコピーも追加で発生します。 パフォーマンスが重視されるコードでは、シー ケンス型として範囲演算子が割り当てられない Span<T> または Memory<T> を使用することを検討してください。
     アクセス可能なゲッターと戻り値の型 int を持つ Length または Count という名前のプロパティがある場合、型は可算で す。 インデックスまたは範囲を明示的にサポートしていない可算型は、それらを暗黙的にサポートしている可能性があります。 詳細については、機能の提案に関する注記の「暗黙的なインデックスのサポート」と「暗黙的な範囲のサポート」のセクションを 参照してください。 暗黙的な範囲のサポートを使用している範囲によって返されるのは、ソース シーケンスと同じシーケンス型で す。
たとえば、次の .NET 型ではインデックスと範囲の両方がサポートされています: String、Span<T>、および ReadOnlySpan<T>。 List<T> はインデックスをサポートしていますが、範囲はサポートしていません。
Array には、より微妙な動作があります。 1 次元配列では、インデックスと範囲の両方がサポートされます。 多次元配列では、 インデクサーまたは範囲はサポートされていません。 多次元配列のインデクサーには、1 つのパラメーターではなく、複数のパラ メーターがあります。 配列の配列とも呼ばれるジャグ配列では、範囲とインデクサーの両方がサポートされます。 次の例では、
   int[] numbers = Enumerable.Range(0, 100).ToArray();
int x = 12;
int y = 25;
int z = 36;
Console.WriteLine($"{numbers[^x]} is the same as {numbers[numbers.Length - x]}");
Console.WriteLine($"{numbers[x..y].Length} is the same as {y - x}");
Console.WriteLine("numbers[x..y] and numbers[y..z] are consecutive and disjoint:");
Span<int> x_y = numbers[x..y];
Span<int> y_z = numbers[y..z];
Console.WriteLine($"\tnumbers[x..y] is {x_y[0]} through {x_y[^1]}, numbers[y..z] is {y_z[0]} through
{y_z[^1]}");
Console.WriteLine("numbers[x..^x] removes x elements at each end:");
Span<int> x_x = numbers[x..^x];
Console.WriteLine($"\tnumbers[x..^x] starts with {x_x[0]} and ends with {x_x[^1]}");
Console.WriteLine("numbers[..x] means numbers[0..x] and numbers[x..] means numbers[x..^0]");
Span<int> start_x = numbers[..x];
Span<int> zero_x = numbers[0..x];
Console.WriteLine($"\t{start_x[0]}..{start_x[^1]} is the same as {zero_x[0]}..{zero_x[^1]}");
Span<int> z_end = numbers[z..];
Span<int> z_zero = numbers[z..^0];
Console.WriteLine($"\t{z_end[0]}..{z_end[^1]} is the same as {z_zero[0]}..{z_zero[^1]}");
 
 ジャグ配列の四角形サブセクションを反復処理する方法を示しています。 最初と最後の 3 つの行と、選択された各行の最初 と最後の 2 つの列を除いて、中央のセクションが反復処理されます。
    var jagged = new int[10][]
{
newint[10]{0, 1,2,3,4,5,6,7,8,9}, new int[10] { 10,11,12,13,14,15,16,17,18,19}, new int[10] { 20,21,22,23,24,25,26,27,28,29}, new int[10] { 30,31,32,33,34,35,36,37,38,39}, new int[10] { 40,41,42,43,44,45,46,47,48,49}, new int[10] { 50,51,52,53,54,55,56,57,58,59}, new int[10] { 60,61,62,63,64,65,66,67,68,69}, new int[10] { 70,71,72,73,74,75,76,77,78,79}, new int[10] { 80,81,82,83,84,85,86,87,88,89}, new int[10] { 90,91,92,93,94,95,96,97,98,99},
};
var selectedRows = jagged[3..^3];
foreach (var row in selectedRows)
{
    var selectedColumns = row[2..^2];
    foreach (var cell in selectedColumns)
    {
        Console.Write($"{cell}, ");
    }
    Console.WriteLine();
}
 いずれの場合も、Array の範囲演算子では、返される要素を格納する配列が割り当てられます。 インデックスと範囲のシナリオ
長いシーケンスの部分を分析するときは、多くの場合、範囲とインデックスを使用します。 新しい構文では、シーケンスのどの部 分が関係しているかをより正確に読み取ることができます。ローカル関数 MovingAverage は、引数としてRangeを受け取り ます。 このメソッドでは、最小値、最大値、および平均値を計算するときに、その範囲のみが列挙されます。 プロジェクトで次の コードを試してみてください。
 
    int[] sequence = Sequence(1000);
for(int start = 0; start < sequence.Length; start += 100)
{
    Range r = start..(start+10);
    var (min, max, average) = MovingAverage(sequence, r);
    Console.WriteLine($"From {r.Start} to {r.End}:    \tMin: {min},\tMax: {max},\tAverage: {average}");
}
for (int start = 0; start < sequence.Length; start += 100)
{
    Range r = ^(start + 10)..^start;
    var (min, max, average) = MovingAverage(sequence, r);
    Console.WriteLine($"From {r.Start} to {r.End}:  \tMin: {min},\tMax: {max},\tAverage: {average}");
}
(int min, int max, double average) MovingAverage(int[] subSequence, Range range) =>
    (
        subSequence[range].Min(),
        subSequence[range].Max(),
        subSequence[range].Average()
);
int[] Sequence(int count) =>
    Enumerable.Range(0, count).Select(x => (int)(Math.Sqrt(x) * 100)).ToArray();
  
      C# 8.0 には null 許容参照型が導入されています。これは、null 許容値型が値型を補完するのと同じように、参照型を補完 するものです。型に ? を追加することで、変数がnull許容参照型であることを宣言します。たとえば、string? は、null が許容される string を表します。これらの新しい型を使用して、一部の変数では常に値を持つ必要があり、他の変数では 値が欠落することも可能である という設計意図をさらに明確に示すことができます。
このチュートリアルでは、次の作業を行う方法について説明します。
null 許容参照型と null 非許容参照型を設計に組み込む。 コード全体で null 許容参照型をチェックできるようにする。 コンパイラでこれらの設計上の決定が適用されるコードを記述する。 自分の設計の中で null 許容参照機能を使用する。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。C# 8.0 コンパイラも実行されるようにしま
す。 C# 8.0 コンパイラは、Visual Studio 2019 または .NET Core 3.0 で使用できます。
このチュートリアルでは、.NET と、C# と Visual Studio または .NET Core CLI のいずれかに精通していることを前提としていま
す。
null 許容参照型と null 非許容参照型を設計に組み込む
このチュートリアルでは、アンケートの実行をモデル化するライブラリを構築します。 コードでは、null 許容参照型と null 非許容 参照型の両方を使用して、現実世界の概念を表します。 アンケートの質問は null することはできません。 回答者が質問に 答えたくない場合があります。この場合、応答は null になる可能性があります。
このサンプルで記述するコードはそのような意図を表現し、コンパイラにその意図が適用されます。 アプリケーションを作成し、null 許容参照型を有効にする
新しいコンソール アプリケーションを作成します。Visual Studio を使用するか、コマンド ラインで dotnet new console を使用 します。アプリケーションに NullableIntroduction という名前を付けます。アプリケーションを作成したら、プロジェクト全体が、 有効な null 許容注釈コンテキスト でコンパイルされるように指定する必要があります。 .csproj ファイルを開き、 Nullable 要素を PropertyGroup 要素に追加します。値を enableに設定します。C#8.0プロジェクトであっても、null許容参照 型 機能を選択する必要があります。 これは、機能をオンにすると、既存の参照変数宣言が null 非許容参照型 になるため です。 その決定は既存のコードで適切な null チェックが行われていない場合に問題を発見するのに役立ちますが、元の設計 意図が正確に反映されない可能性があります。
アプリケーション用の型を設計する
このアンケート アプリケーションでは、いくつかのクラスを作成する必要があります。
質問の一覧をモデル化するクラス。 アンケートに応じてもらうために連絡した人物の一覧をモデル化するクラス。
         <Nullable>enable</Nullable>
 チュートリアル: null 許容参照型と null 非許容参
照型を使用して設計意図をもっと明確に示す
2021/03/08 • • Edit Online
 
  アンケートに応じた人物から得た回答をモデル化するクラス。
これらの型では、null 許容参照型と null 非許容参照型の両方を利用して、必要なメンバーと省略可能なメンバーを表現し
ます。 null 許容参照型により、次の設計意図が明確に伝わります。
アンケートの一部である質問を null にすることはできません。空の質問は意味がありません。
回答者を null にすることはできません。 回答者が参加を辞退している場合でも、連絡した人物を追跡したいからです。 質問に対する回答を null にすることができます。 回答者は、一部の質問またはすべての質問の回答を拒否できます。
これまでC#でプログラミングしている場合は、null 値を許容する参照型に慣れているため、nullを許容しないインスタンスを 宣言する機会がなかったかもしれません。
質問のコレクションは null を許容しないものにする必要があります。 回答者のコレクションは null を許容しないものにする必要があります。
コードを記述していくにつれて、参照の既定値としての null 非許容参照型によって、NullReferenceException を引き起こす 可能性がある一般的なミスを回避できることを理解できるでしょう。このチュートリアルから学ぶことの1つは、null にすること ができる変数とできない変数を決定することです。 この言語には、このような決定を表現するための構文が提供されていません でした。 今、それが実現しています。
ビルドするアプリで、次の手順を行います。
1. アンケートを作成し、そこに質問を追加します。
2. アンケートの回答者の擬似乱数セットを作成します。
3. 回答されたアンケートのサイズが目標数に達するまで、回答者に連絡します。 4. アンケートの回答に関する重要な統計情報を書き込みます。
null 許容参照型と null 非許容参照型を含むアンケートを作成する
最初に記述するコードによって、アンケートが作成されます。 アンケートの質問とアンケートの実行をモデル化するクラスを記述し ます。 アンケートには、回答の形式によって区別される 3 種類の質問があります:はい/いいえで回答するもの、番号で回答する もの、およびテキストで回答するもの。 public SurveyQuestion クラスを作成します。
コンパイラでは、有効な null 許容注釈コンテキスト内のコードについては、すべての参照型変数の宣言が null 非許容 参照 型として解釈されます。 次のコードに示すように、質問のテキストと質問の種類のプロパティを追加することで、最初の警告を確 認できます。
     namespace NullableIntroduction
{
    public class SurveyQuestion
    {
    }
}
 
   QuestionText を初期化していないため、コンパイラによって、nullを許容しないプロパティが初期化されていないことを示す警 告が発行されます。 この設計では、質問のテキストを null 以外にする必要があるため、初期化するためのコンストラクターを追 加します。 QuestionType 値も同様にします。 完成したクラス定義は、次のコードのようになります。
     namespace NullableIntroduction
{
    public enum QuestionType
    {
        YesNo,
        Number,
        Text
}
    public class SurveyQuestion
    {
} }
public string QuestionText { get; }
public QuestionType TypeOfQuestion { get; }
public SurveyQuestion(QuestionType typeOfQuestion, string text) =>
    (TypeOfQuestion, QuestionText) = (typeOfQuestion, text);
 コンストラクターを追加すると、警告が解除されます。 コンストラクターの引数も、null 非許容参照型であるため、コンパイラによ る警告は発行されません。
次に、 という名前の public クラスを作成します。次のコードに示すように、このクラスには、アンケートに質問を追 加する オブジェクトとメソッドの一覧が含まれます。
  SurveyRun
 SurveyQuestion
    using System.Collections.Generic;
namespace NullableIntroduction
{
    public class SurveyRun
    {
        private List<SurveyQuestion> surveyQuestions = new List<SurveyQuestion>();
        public void AddQuestion(QuestionType type, string question) =>
            AddQuestion(new SurveyQuestion(type, question));
        public void AddQuestion(SurveyQuestion surveyQuestion) => surveyQuestions.Add(surveyQuestion);
    }
}
 前と同じように、この一覧オブジェクトを null 以外の値に初期化する必要があります。そうしないとコンパイラによって警告が発 行されます。   の 2 つ目のオーバーロードでは null のチェックは必要ないため、それが実行されることはありませ
   namespace NullableIntroduction
{
    public enum QuestionType
    {
        YesNo,
        Number,
        Text
}
    public class SurveyQuestion
    {
        public string QuestionText { get; }
        public QuestionType TypeOfQuestion { get; }
    }
}
  AddQuestion
 
 ん。その変数はnull非許容であることが宣言されています。その値は null になることはできません。 お使いのエディターでProgram.csに切り替え、Main の内容を次のコード行に置き換えます。
プロジェクト全体が、有効なnull許容注釈コンテキスト内にあるので、null非許容参照型が必要なメソッドに null を渡す と、警告が発生します。次の行を Main に追加して試してください。
回答者を作成し、アンケートに対する回答を取得する 次に、アンケートに対する回答を生成するコードを記述します。 このプロセスには、いくつかの小さいタスクが含まれます。
1. 回答者オブジェクトを生成するメソッドを作成します。 これらは、アンケートへの入力を求められる人物を表します。
2. 回答者にアンケートを依頼し、回答を収集するか、回答者が回答しなかったことを示すデータを収集することをシミュレート
するロジックを構築します。
3. 十分な数の回答者がアンケートに回答するまで、これを繰り返します。
アンケートの回答を表すクラスが必要なので、ここでそれを追加します。 null 許容のサポートを有効にします。 次のコードに示 すように、 Id プロパティとそれを初期化するコンストラクターを追加します。
    var surveyRun = new SurveyRun();
surveyRun.AddQuestion(QuestionType.YesNo, "Has your code ever thrown a NullReferenceException?");
surveyRun.AddQuestion(new SurveyQuestion(QuestionType.Number, "How many times (to the nearest 100) has that
happened?"));
surveyRun.AddQuestion(QuestionType.Text, "What is your favorite color?");
   surveyRun.AddQuestion(QuestionType.Text, default);
     namespace NullableIntroduction
{
    public class SurveyResponse
    {
        public int Id { get; }
        public SurveyResponse(int id) => Id = id;
    }
}
  次に、static メソッドを追加し、ランダムIDを生成することで新しい参加者を作成します。
このクラスの主な役割は、アンケートの質問に対する参加者の回答を生成することです。 この役割には、いくつかの手順があり ます。
1. アンケートへの参加を依頼します。 回答者が同意しない場合は、応答の欠落 (つまり null) が返されます。 2. 各質問を表示し、回答を記録します。 回答も欠落する (つまり null になる) 可能性があります。
SurveyResponse クラスに次のコードを追加します。
    private static readonly Random randomGenerator = new Random();
public static SurveyResponse GetRandomId() => new SurveyResponse(randomGenerator.Next());
  
     アンケートの回答用のストレージは Dictionary<int, string>? であり、null が可能であることを示しています。 新しい言語機 能を使用して、コンパイラーと後日コードを読む人の両方に対して、設計意図が宣言されています。先に null 値のチェックを 行わずに を逆参照した場合は、コンパイラの警告が表示されます。 AnswerSurvey メソッドで警告が表示 されないのは、上記で 変数が null 以外の値に設定されたことをコンパイラが判断できるためです。
欠落している回答に対して null を使用すると、null許容参照型を処理するための重要なポイントが強調表示されます。目 標は、プログラムからすべての null 値を削除することではありません。本当の目標は、記述しているコードで設計の意図が 確実に表されるようにすることです。欠落値は、コードでの表現に必要な概念です。 null 値は、これらの欠落値を表現する 明確な方法です。 すべての null を削除しようとしても、 null を使わずにそれらの欠落値を表すための他の何らかの方法を 定義することになるだけです。
次に、 SurveyRun クラス内に PerformSurvey メソッドを記述する必要があります。 SurveyRun クラスに次のコードを追加しま す。
  surveyResponses
 surveyResponses
     private Dictionary<int, string>? surveyResponses;
public bool AnswerSurvey(IEnumerable<SurveyQuestion> questions)
{
    if (ConsentToSurvey())
    {
        surveyResponses = new Dictionary<int, string>();
        int index = 0;
        foreach (var question in questions)
        {
            var answer = GenerateAnswer(question);
            if (answer != null)
            {
                surveyResponses.Add(index, answer);
            }
index++; }
}
    return surveyResponses != null;
}
private bool ConsentToSurvey() => randomGenerator.Next(0, 2) == 1;
private string? GenerateAnswer(SurveyQuestion question)
{
    switch (question.TypeOfQuestion)
    {
} }
case QuestionType.YesNo:
    int n = randomGenerator.Next(-1, 2);
    return (n == -1) ? default : (n == 0) ? "No" : "Yes";
case QuestionType.Number:
    n = randomGenerator.Next(-30, 101);
    return (n < 0) ? default : n.ToString();
case QuestionType.Text:
default:
    switch (randomGenerator.Next(0, 5))
    {
        case 0:
            return default;
        case 1:
            return "Red";
        case 2:
            return "Green";
        case 3:
            return "Blue";
    }
    return "Red. No, Green. Wait.. Blue... AAARGGGGGHHH!";

   ここでも、nullを許容する List<SurveyResponse>? の選択によって、応答でnullが可能であることが示されす。これは、アン ケートがまだ回答者に表示されていないことを示します。 十分な数の同意が得られるまで回答者が追加されることに注意してく ださい。
アンケートを実行する最後の手順は、 Main メソッドの最後にアンケートを実行する呼び出しを追加することです。
アンケートの回答を調べる
最後の手順は、アンケートの結果を表示することです。 記述したクラスの多くにコードを追加します。 このコードでは、null 許容 参照型とnull非許容参照型を区別する値を示します。 SurveyResponse クラスに次の2つの式形式メンバーを追加するこ とから始めます。
surveyResponses はnull許容参照型であるため、それを逆参照する前にチェックが必要です。 Answer メソッドからはnull 非許容の文字列が返されます。そのため、null 合体演算子を使用して、不足している回答のケースをカバーする必要がありま す。
次に、次の3つの式形式メンバーを SurveyRun クラスに追加します。
AllParticipants メンバーでは、respondents 変数はnullの場合があるが、戻り値をnullにすることはできないことを考慮 する必要があります。この式を ?? とその後ろの空のシーケンスを削除することで変更すると、コンパイラーによって、メソッドで
null が返され、その戻り値のシグネチャでnull非許容型が返される可能性があることが警告されます。 最後に、次のループを Main メソッドの末尾に追加します。
  surveyRun.PerformSurvey(50);
      public bool AnsweredSurvey => surveyResponses != null;
public string Answer(int index) => surveyResponses?.GetValueOrDefault(index) ?? "No answer";
        public IEnumerable<SurveyResponse> AllParticipants => (respondents ?? Enumerable.Empty<SurveyResponse>()); public ICollection<SurveyQuestion> Questions => surveyQuestions;
public SurveyQuestion GetQuestion(int index) => surveyQuestions[index];
      private List<SurveyResponse>? respondents;
public void PerformSurvey(int numberOfRespondents)
{
    int respondentsConsenting = 0;
    respondents = new List<SurveyResponse>();
    while (respondentsConsenting < numberOfRespondents)
    {
} }
var respondent = SurveyResponse.GetRandomId();
if (respondent.AnswerSurvey(surveyQuestions))
    respondentsConsenting++;
respondents.Add(respondent);
 
      基になるインターフェースを非許容参照型を返すように設計しているため、このコードでは null のチェックは必要ありません。
コードを取得する
csharp/NullableIntroduction フォルダーの samples リポジトリから、完成したチュートリアルのコードを取得できます。
null 許容参照型と null 非許容参照型の間で型宣言を変更することで試してください。 それによって生成される警告が変わる ことを確認して、 null を間違って逆参照することがないようにしてください。
次の手順
既存のアプリケーションを null 許容参照型を使用するように移行することについてさらに詳しく学習します。 Null 許容参照型を使用するようにアプリケーションをアップグレードする
Entity Framework を使用する場合に null 許容参照型を使用する方法について説明します。
Entity Framework Core の基礎: null 許容参照型の使用
     foreach (var participant in surveyRun.AllParticipants)
{
    Console.WriteLine($"Participant: {participant.Id}:");
    if (participant.AnsweredSurvey)
    {
        for (int i = 0; i < surveyRun.Questions.Count; i++)
        {
            var answer = participant.Answer(i);
            Console.WriteLine($"\t{surveyRun.GetQuestion(i).QuestionText} : {answer}");
        }
} else {
        Console.WriteLine("\tNo responses");
    }
}
 
      C# 8 には null 許容参照型が導入されています。これは、null 許容値型が値型を補完するのと同じように、参照型を補完 するものです。型に ? を追加することで、変数がnull許容参照型であることを宣言します。たとえば、string? は、null が許容される string を表します。これらの新しい型を使用して、一部の変数では常に値を持つ必要があり、他の変数で は値が欠落することも可能であるという設計意図をさらに明確に示すことができます。 参照型の既存の変数は、null 非許容 参照型として解釈されます。
このチュートリアルでは、次の作業を行う方法について説明します。
コードを操作するときに null 参照のチェックを有効にする。
null 値に関連するさまざまな警告を診断して修正する。
null 許容が有効なコンテキストと null 許容が無効なコンテキストの間のインターフェイスを管理する。 null 許容注釈のコンテキストを制御する。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。C# 8.0 コンパイラも実行されるようにしま
す。 C# 8 コンパイラは Visual Studio 2019 バージョン 16.3 または .NET Core 3.0 SDK 以降で使用できます。 このチュートリアルでは、.NET と、C# と Visual Studio または .NET Core CLI のいずれかに精通していることを前提としていま
す。
サンプル アプリケーションを調べる
これから移行するサンプル アプリケーションは、RSS フィード リーダー Web アプリです。 1 つの RSS フィードから読み取り、最新 の記事の要約を表示します。 いずれかの記事を選択すると、そのサイトに移動できます。 そのアプリケーションは比較的新しい ものですが、null 許容参照型が有効になる前に書かれました。 アプリケーションの設計上の決定では適切な原則が表されて いましたが、この重要な言語機能は利用されていません。
サンプル アプリケーションには、アプリの主要な機能を検証する単体テスト ライブラリが含まれています。 生成された警告に基づ いて実装のいずれかを変更する場合、そのプロジェクトによって容易に安全なアップグレードを行うことができます。 GitHub の dotnet/samples リポジトリから、スタート コードをダウンロードすることができます。
プロジェクト移行の目標は、新しい言語機能を利用して変数の null 値の許容についての意図を明確に表すこと、そしてと null許容注釈コンテキストおよびnull許容警告コンテキストを enabled に設定したときにコンパイラで警告が生成されないよ うな方法でそれを行うことです。
プロジェクトを C# 8 にアップグレードする
最初のステップとして、移行タスクの範囲を決定します。 まず最初に、プロジェクトを C# 8.0 (またはそれ以降) にアップグレード します。Webプロジェクトと単体テストプロジェクトの両方について、csprojファイルのPropertyGroupに LangVersion 要素 を追加します。
      <LangVersion>8.0</LangVersion>
 言語バージョンをアップグレードすると C# 8.0 が選択されますが、null 許容注釈コンテキストまたは null 許容警告コンテキスト
チュートリアル: null 許容参照型で既存のコード
を移行する
2020/03/18 • • Edit Online
 
 は有効になりません。 プロジェクトをリビルドして、警告なしにビルドされることを確認します。
次に、null 許容注釈コンテキストを有効にして、警告がいくつ生成されるかを確認します。 ソリューションの両方の csproj ファイ
ルで、 LangVersion 要素のすぐ下に次の要素を追加します。
テスト ビルドを行い、警告の一覧に注目します。 この小さいアプリケーションでは 5 つのコンパイラ警告が生成されるので、null 許容注釈コンテキストを有効にしたまま、プロジェクト全体の警告の修正を始めます。
そのような戦略は、小さいプロジェクトに対してのみ機能します。 大きいプロジェクトでは、コードベース全体の null 許容注釈コ ンテキストを有効にすると生成される警告の数が多く、体系的に警告を修正することは困難です。 大規模なエンタープライズ プロジェクトでは、一度に 1 つのプロジェクトを移行するのが普通です。 各プロジェクトでは、一度に 1 つのクラスまたはファイルを 移行します。
   <Nullable>enable</Nullable>
 元の設計意図の発見に役立つ警告
複数の警告が生成されているクラスが 2 つあります。 クションに警告の範囲を制限できるように、両方の csproj ファイルから NewsStoryViewModel.cs ファイルを開き、次のディレクティブを追加して テキストを有効にし、そのクラス定義の後で元に戻します。
クラスから始めます。 作業を行っているコードのセ 要素を削除します。
に対して null 許容注釈コン
 NewsStoryViewModel
 Nullable
 NewsStoryViewModel
    #nullable enable
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; }
    public string Uri { get; set; }
}
#nullable restore
 これら 2 つのディレクティブは、移行作業の対象を絞るのに役立ちます。 null 許容の警告は、今まさに作業を行っているコード の領域に対して生成されます。 プロジェクト全体の警告を有効にする準備ができるまで、それをオンのままにします。 後でプロ ジェクト全体の null 許容注釈を有効にしたときに、誤ってコンテキストを無効にしないように、 disable 値ではなく restore を使用する必要があります。 プロジェクト全体の null 許容注釈コンテキストを有効にした後は、そのプロジェクトからすべての
#nullable プラグマを削除できます。
NewsStoryViewModel クラスはデータ転送オブジェクト(DTO)であり、プロパティのうち2つは読み取り/書き込み文字列です。
これら2つのプロパティが、CS8618 "null非許容型のプロパティが初期化されていません"の原因になっています。 NewsStoryViewModel が構築されるときに、どちらの string プロパティも既定値が null になっているので、それははっきりわ
かります。 重要なのは、 NewsStoryViewModel オブジェクトの構築方法を明らかにすることです。 このクラスを調べても、 null 値が設計の一部なのかどうか、またはこれらのオブジェクトは作成されるたび null 以外の値に設定されるのかどうかはわかりませ ん。 ニュース記事は、 NewsService クラスの GetNews メソッドで作成されます。
        public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; }
    public string Uri { get; set; }
}
       
   上記のコード ブロックでは多くのことが行われています。 このアプリケーションでは、AutoMapper NuGet パッケージを使用して、 ISyndicationItem からニュース項目を作成しています。ニュース記事の項目が構築され、その1つのステートメントでプロパ
ティが設定されることはわかっています。 つまり、 NewsStoryViewModel の設計では、これらのプロパティが null 値になってはな らないことが示されています。 これらのプロパティは、null 非許容参照型にする必要があります。 それが、元の設計意図を最 も適切に表しています。実際、NewsStoryViewModel は、null値以外で正しくインスタンス化されて"います"。これにより、次 の初期化コードが有効な修正になります。
型の場合は null である default を Title および Uri に割り当てても、プログラムの実行時の動作は変わりま せん。 はやはり null 値で構築されますが、コンパイラの警告は報告されなくなります。 null 許容演算 子( 式の後の ! 文字)は、その前の式がnullではないことをコンパイラに指示します。この手法は、他の変更に よってコード ベースに大きな変化が強制されるときは便利なことがありますが、このアプリケーションでは、比較的簡単でもっとよい 解決策があります。すべてのプロパティがコンストラクター内で設定される場合は、 NewsStoryViewModel を変更不可の型にし ます。 NewsStoryViewModel を次のように変更します。
       public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; } = default!;
    public string Uri { get; set; } = default!;
}
   string
 NewsStoryViewModel
 default
      #nullable enable
    public class NewsStoryViewModel
    {
        public NewsStoryViewModel(DateTimeOffset published, string title, string uri) =>
            (Published, Title, Uri) = (published, title, uri);
        public DateTimeOffset Published { get; }
        public string Title { get; }
        public string Uri { get; }
    }
#nullable restore
 それを行った後は、プロパティを設定するのではなくコンストラクターを使用するように、AutoMapper を構成するコードを更新す る必要があります。 NewsService.cs を開き、ファイルの最後にある次のコードを探します。
     public class NewsStoryProfile : Profile
{
    public NewsStoryProfile()
    {
} }
// Create the AutoMapper mapping profile between the 2 objects.
// ISyndicationItem.Id maps to NewsStoryViewModel.Uri.
CreateMap<ISyndicationItem, NewsStoryViewModel>()
    .ForMember(dest => dest.Uri, opts => opts.MapFrom(src => src.Id));
   そのコードでは、 ISyndicationItem オブジェクトのプロパティが NewsStoryViewModel プロパティにマップされています。 AutoMapper では代わりにコンストラクターを使用してマッピングを提供する必要があります。 上記のコードを次のような AutoMapper 構成に置き換えます。
   ISyndicationItem item = await feedReader.ReadItem();
var newsStory = _mapper.Map<NewsStoryViewModel>(item);
news.Add(newsStory);
 
   このクラスは小さく、注意深く調べたので、このクラスの宣言の上にある #nullable enable ディレクティブを有効にする必要があ ることに注意してください。 コンストラクターを変更すると何かが壊れる可能性があるため、続行する前に、すべてのテストを実行 し、アプリケーションをテストすることをお勧めします。
最初の一連の変更では、変数を null に設定してはならないことが元の設計で示されていたことを検出する方法を示しまし た。 その手法は、Correct by Construction (構築からの正しさ) と呼ばれます。 構築するときに、オブジェクトとそのプロパ ティを null にできないことを宣言します。 コンパイラのフロー分析により、構築後にそれらのプロパティが null に設定されて いないことが保証されます。 このコンストラクターは外部のコードによって呼び出され、そのコードでは null 許容が認識されて いないことに注意してください。 新しい構文では、実行時のチェックは提供されません。 外部のコードによって、コンパイラのフ ロー分析が回避される可能性があります。
クラスの構造によって、意図に対する別の手掛かりが提供されている場合があります。 Pages フォルダーの Error.cshtml.cs ファ イルを開きます。 ErrorViewModel には、次のコードが含まれています。
     public class ErrorModel : PageModel
{
    public string RequestId { get; set; }
    public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);
    public void OnGet()
    {
        RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
    }
}
   クラス宣言の前に #nullable enable ディレクティブを追加し、後に #nullable restore ディレクティブを追加します。 RequestId が初期化されていないことを示す警告を1つ受け取ります。クラスを調べることで、場合によっては RequestId プ
ロパティを null にする必要があると判断します。 プロパティの存在は、欠落値があってもかまわないことを示し ます。 null が有効なので、string 型に ? を追加して、 プロパティは"null許容参照型"であることを示しま す。 最終的なクラスは次の例のようになります。
   ShowRequestId
  RequestId
    #nullable enable
    public class ErrorModel : PageModel
    {
        public string? RequestId { get; set; }
        public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);
        public void OnGet()
        {
            RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
        }
    }
#nullable restore
 プロパティの使用方法を調べると、関連するページで、マークアップでレンダリングする前にプロパティが null かどうか確認されてい
   #nullable enable
    public class NewsStoryProfile : Profile
    {
        public NewsStoryProfile()
        {
            // Create the AutoMapper mapping profile between the 2 objects.
            // ISyndicationItem.Id maps to NewsStoryViewModel.Uri.
            CreateMap<ISyndicationItem, NewsStoryViewModel>()
}
.ForCtorParam("uri", opt => opt.MapFrom(src => src.Id));
 
 ることがわかります。 それは null 許容参照型の安全な使用方法なので、このクラスについては終了します。 null の修正による変更
ある一連の警告を修正すると、関連するコードで新しい警告が発生することがよくあります。 index.cshtml.cs クラスを修正す ることによって、警告の動作を見てみましょう。 index.cshtml.cs ファイルを開いてコードを調べます。このファイルには、索引 ページに対する分離コードが含まれます。
      public class IndexModel : PageModel
{
    private readonly NewsService _newsService;
    public IndexModel(NewsService newsService)
    {
        _newsService = newsService;
    }
    public string ErrorText { get; private set; }
    public List<NewsStoryViewModel> NewsItems { get; private set; }
    public async Task OnGet()
    {
        string feedUrl = Request.Query["feedurl"];
        if (!string.IsNullOrEmpty(feedUrl))
        {
try {
                NewsItems = await _newsService.GetNews(feedUrl);
            }
            catch (UriFormatException)
            {
                ErrorText = "There was a problem parsing the URL.";
return; }
            catch (WebException ex) when (ex.Status == WebExceptionStatus.NameResolutionFailure)
            {
                ErrorText = "Unknown host name.";
return; }
            catch (WebException ex) when (ex.Status == WebExceptionStatus.ProtocolError)
            {
                ErrorText = "Syndication feed not found.";
return; }
            catch (AggregateException ae)
            {
                ae.Handle((x) =>
                {
syndication feed?";
} }
} }
    if (x is XmlException)
    {
        ErrorText = "There was a problem parsing the feed. Are you sure that URL is a
        return true;
    }
    return false;
});
    #nullable enable ディレクティブを追加すると、2 つの警告が表示されます。 ErrorText プロパティも NewsItems プロパティ

 も初期化されていません。 このクラスを調べた結果、どちらのプロパティも null 許容参照型にする必要があることがわかりまし た。どちらにもプライベートのセッターがあります。厳密に1つだけが、OnGet メソッドで割り当てられます。変更する前に、両 方のプロパティのコンシューマーを確認します。ページ自体では、エラーのマークアップが生成される前に、ErrorText でnullが 確認されています。 NewsItems コレクションは null に対して確認され、項目が含まれることが確認されます。簡単に修正 するには、両方のプロパティを null 許容参照型にします。 より適切な修正方法は、コレクションを null 非許容参照型にして、 ニュースを取得するときに既存のコレクションに項目を追加することです。 最初の修正として、 ErrorText の string 型に ? を追加します。
ErrorText プロパティに対するすべてのアクセスはnullチェックによって既に保護されているので、その変更は他のコードには反 映されません。 次に、 NewsItems リストを初期化し、プロパティのセッターを削除して、読み取り専用のプロパティにします。
それによって警告は修正されますが、エラーが発生するようになります。 NewsItems リストはCorrectbyConstructionに なっていますが、OnGet でリストを設定するコードを、新しいAPIと一致するように変更する必要があります。割り当ての代わり に、 AddRange を呼び出して既存のリストにニュース項目を追加します。
割り当ての代わりに AddRange を使用するということは、 GetNews メソッドで List ではなく IEnumerable を返すことができる ことを意味します。 それによって 1 つの割り当てが保存されます。 次のコード サンプルで示すように、メソッドのシグネチャを変更 し、 ToList の呼び出しを削除します。
      public string? ErrorText { get; private set; }
     public List<NewsStoryViewModel> NewsItems { get; } = new List<NewsStoryViewModel>();
     NewsItems.AddRange(await _newsService.GetNews(feedUrl));
     
      シグネチャを変更すると、テストの 1 つにも影響があります。 プロジェクトの ファイルを開きます。 テストに移動し、
を に変更します。型を変更すると Count プロパティを使用できなくなるので、 プロパティを Any() の呼び出しに置き換えます。
ファイルの先頭に using System.Linq ステートメントを追加する必要もあります。
フォルダーの 変数の型
の Count
SimpleFeedReader.Tests
Services
   NewsServiceTests.cs
Returns_News_Stories_Given_Valid_Uri
result
   IEnumerable<NewsItem>
Assert
    // Act
IEnumerable<NewsStoryViewModel> result =
    await _newsService.GetNews(feedUrl);
// Assert
Assert.True(result.Any());
  この一連の変更では、ジェネリック インスタンス化を含むコードを更新するときの特別な考慮事項に注目しています。 リストとリス ト内の null 非許容型の要素の両方です。 どちらか一方または両方が、null 許容型である可能性があります。 以下のすべて の宣言が許容されます。
: null 非許容ビュー モデルのを null 非許容リスト。 : null 許容ビュー モデルのを null 非許容リスト。
: null 非許容ビュー モデルのを null 許容リスト。
: null 許容ビュー モデルのを null 許容リスト。
 List<NewsStoryViewModel>
 List<NewsStoryViewModel?>
  List<NewsStoryViewModel>?
  List<NewsStoryViewModel?>?
  public async Task<IEnumerable<NewsStoryViewModel>> GetNews(string feedUrl)
{
    var news = new List<NewsStoryViewModel>();
    var feedUri = new Uri(feedUrl);
    using (var xmlReader = XmlReader.Create(feedUri.ToString(),
           new XmlReaderSettings { Async = true }))
{
try
        {
            var feedReader = new RssFeedReader(xmlReader);
            while (await feedReader.Read())
            {
} }
switch (feedReader.ElementType)
{
    // RSS Item
    case SyndicationElementType.Item:
        ISyndicationItem item = await feedReader.ReadItem();
        var newsStory = _mapper.Map<NewsStoryViewModel>(item);
        news.Add(newsStory);
        break;
    // Something else
    default:
break; }
        catch (AggregateException ae)
        {
            throw ae.Flatten();
        }
}
    return news.OrderByDescending(story => story.Published);
}

     外部コードとのインターフェイス
NewsService クラスを変更したので、そのクラスの #nullable enable 注釈を有効にします。 これにより、新しい警告が生成 されることはありません。 ただし、クラスを注意深く調べることは、コンパイラのフロー分析に含まれるいくつかの制限を明らかにす るのに役立ちます。 コンストラクターを調べます。
IMapper パラメーターは、null非許容参照として型指定されています。それはASP.NETCoreインフラストラクチャコードで呼 び出されるため、IMapper がnullにはならないということは、コンパイラには実際にはわかりません。ASP.NETCoreの既定の 依存関係挿入 (DI) コンテナーでは、コードが正しくなるよう、必要なサービスを解決できない場合は、例外がスローされます。 null 許容注釈コンテキストを有効にしてコードをコンパイルした場合でも、コンパイラではパブリック API のすべての呼び出しを検 証することはできません。 さらに、null 許容参照型がまだ使用されていないプロジェクトで、ライブラリが使用される可能性があり ます。 null 非許容型として宣言されている場合でも、パブリック API への入力を検証してください。
コードを取得する
最初のテスト コンパイルで明らかになった警告を修正したので、今度は両方のプロジェクトで null 許容注釈コンテキストを有効 にできます。 プロジェクトをリビルドします。コンパイラで警告は報告されません。 dotnet/samples GitHub リポジトリで、完成し たプロジェクトのコードを入手できます。
null許容参照型をサポートする新しい機能を使用すると、コードでの null 値の処理方法に関する潜在的なエラーを発見し て修正するのに役立ちます。 null 許容注釈コンテキストを有効にすると、null にできない変数と、null 値を含むことができる変 数に関する、設計の意図を表すことができます。 これらの機能を使用すると、設計意図を簡単に宣言できるようになります。 同様に、null 許容警告コンテキストでは、その意図に違反しているときに警告を発行するようコンパイラに指示されます。 それ らの警告を参考にすると、より回復性が高く、実行中に NullReferenceException がスローされる可能性が低くなるように、 コードを更新できます。 コードの局所的な領域に注目して移行を行うことができ、それ以外のコードベースは変更されないよう に、これらのコンテキストの範囲を制御できます。 実際には、この移行タスクを、クラスに対する定期的なメンテナンスの一部に することができます。 このチュートリアルでは、null 許容参照型を使用するようにアプリケーションを移行するプロセスを示しまし た。 このプロセスのさらに大きな実際の例については、Jon Skeet が NodaTime に null 許容参照型を組み込むために行った PR を調べてください。 また、Entity Framework Core の null 許容参照型の使用に関するページで、Entity Framework Core で null 許容参照型を使用する手法を確認することもできます。
      public NewsService(IMapper mapper)
{
    _mapper = mapper;
}
    
          C# 8.0 では、データのストリーミング元をモデル化する 非同期ストリーム が導入されました。 データ ストリームでは、多くの場 合、要素を非同期で取得または生成します。 非同期ストリームは .NET Standard 2.1 で導入された新しいインターフェイスに 依存します。 このインターフェイスは .NET Core 3.0 以降でサポートされています。 非同期でストリーミングするデータ ソースに とって自然なプログラミング モデルが与えられます。
このチュートリアルでは、次の作業を行う方法について説明します。
データ要素のシーケンスを非同期で生成するデータ ソースを作成します。
そのデータ ソースを非同期で使用します。 非同期ストリームのキャンセルとキャプチャされたコンテキストをサポートします。 新しいインターフェイスとデータ ソースが以前の同期データ シーケンスより優先される場合を認識します。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。C# 8.0 コンパイラも実行されるようにしま
す。 C# 8 コンパイラは Visual Studio 2019 バージョン 16.3 または .NET Core 3.0 SDK 以降で使用できます。
GitHub アクセス トークンを作成して、GitHub GraphQL エンドポイントにアクセスできるようにする必要があります。 GitHub ア
クセス トークンに対して次のアクセス許可を選択します。
repo:status public_repo
アクセス トークンを安全な場所に保存して、GitHub API エンドポイントへのアクセス権を得るために使用できるようにします。
このチュートリアルでは、.NET と、C# と Visual Studio または .NET Core CLI のいずれかに精通していることを前提としていま す。
初期アプリケーションを実行する このチュートリアルで使用される初期アプリケーションのコードは、csharp/tutorials/AsyncStreams フォルダー内の
dotnet/docs リポジトリから取得できます。
初期アプリケーションは、GitHub GraphQL インターフェイスを使用して、dotnet/docs リポジトリに書き込まれた最近の問題を 取得するコンソールアプリケーションです。まず、初期アプリの Main メソッドについて次のコードを参照します。
    WARNING
自分の個人用アクセス トークンをセキュリティで保護します。 個人用アクセス トークンを使用するソフトウェアでは、ユーザーのアクセス権を使 用して GitHub API 呼び出しが行われる可能性があります。
 チュートリアル: C#8.0 および .NET Core 3.0 を使
用して非同期ストリームを生成および使用する
2021/03/09 • • Edit Online
 
    GitHubKey 環境変数を自分の個人用アクセス トークンに設定するか、 GetEnvVariable への呼び出しの最後の引数を自分 の個人用アクセス トークンで置き換えることができます。 ソースを他人と共有する場合、自分のアクセス コードをソース コードに 置かないでください。 共有ソース リポジトリにアクセス コードをアップロードしないでください。
GitHubクライアントの作成後に、Main 内のコードによって進行状況レポートオブジェクトとキャンセルトークンが作成されま す。これらのオブジェクトが作成されると、Main によって runPagedQueryAsync が呼び出されて、作成された直近250件の 問題が取得されます。 そのタスクが完了すると、結果が表示されます。
初期アプリケーションを実行するときに、このアプリケーションの実行方法についていくつかの重要な観察を行うことができます。 GitHub から返される各ページについてレポートされる進行状況を確認します。 問題の新しい各ページが GitHub から返される 前に、注目すべき一時停止を観察できます。 最後に、問題は GitHub から 10 ページすべてが取得された後にのみ表示され ます。
実装を調べる
実装では、前のセクションで説明した動作を観察した理由が明らかになります。 runPagedQueryAsync のコードを調べます:
     static async Task Main(string[] args)
{
    //Follow these steps to create a GitHub Access Token
// https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a- token
    //Select the following permissions for your GitHub Access Token:
    // - repo:status
    // - public_repo
    // Replace the 3rd parameter to the following code with your GitHub access token.
    var key = GetEnvVariable("GitHubKey",
    "You must store your GitHub key in the 'GitHubKey' environment variable",
    "");
    var client = new GitHubClient(new Octokit.ProductHeaderValue("IssueQueryDemo"))
    {
        Credentials = new Octokit.Credentials(key)
    };
    var progressReporter = new progressStatus((num) =>
    {
        Console.WriteLine($"Received {num} issues in total");
    });
    CancellationTokenSource cancellationSource = new CancellationTokenSource();
try {
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("Work has been cancelled");
    }
}
var results = await runPagedQueryAsync(client, PagedIssueQuery, "docs",
    cancellationSource.Token, progressReporter);
foreach(var issue in results)
    Console.WriteLine(issue);
 
      上記のコードのページング アルゴリズムと非同期構造体に注目してみましょう。 (GitHub GraphQL API について詳しく は、GitHub GraphQL のドキュメントをご覧ください。) メソッドでは、問題が新しい順に列挙されます。 1 ページあたり 25 件の問題を要求し、応答の 構造体を調べて前のページに進みます。 次の GraphQL の標準的 なページングでは、複数ページの応答がサポートされます。 応答には、前のページを要求するために使用される
  hasPreviousPages
runPagedQueryAsync
 pageInfo
  値と 値を含む pageInfo オブジェクトが含まれています。問題は nodes 配列内にありま メソッドでは、すべてのページからのすべての結果を格納する配列にこれらのノードが追加されます。
startCursor
 す。
結果のページを取得し、復元した後、 によって進行状況がレポートされ、キャンセルがチェックされます。
runPagedQueryAsync
 runPagedQueryAsync
 キャンセルが要求されている場合は、 によって OperationCanceledException がスローされます。
このコードには、改善できる要素がいくつかあります。 最も重要なものとして、 runPagedQueryAsync では返されるすべての問題 に記憶域を割り当てる必要があります。 未解決の問題をすべて取得するには、取得したすべての問題を格納するためにはる かに多くのメモリが必要になるので、このサンプルは 250 件の問題で停止します。 進行状況レポートとキャンセルをサポートする ためのプロトコルが原因で、アルゴリズムを初読で理解することが難しくなります。 関連する型や API の数が増えます。 CancellationTokenSource とそれに関連付けられた CancellationToken を通じた通信をトレースして、キャンセルが要求され ている場所と、付与されている場所を理解する必要があります。
非同期ストリームではより優れた方法が提供される
非同期ストリームおよび関連付けられている言語サポートは、これらすべての問題に対処します。 シーケンスを生成するコード では、 yield return を使用して、 async 修飾子で宣言されたメソッド内で要素を返せるようになりました。 foreach ループ を使用してシーケンスを使用する場合と同様に、 await foreach ループを使用して非同期ストリームを使用することができま す。
runPagedQueryAsync
       private static async Task<JArray> runPagedQueryAsync(GitHubClient client, string queryText, string repoName, CancellationToken cancel, IProgress<int> progress)
{
    var issueAndPRQuery = new GraphQLRequest
    {
        Query = queryText
    };
    issueAndPRQuery.Variables["repo_name"] = repoName;
    JArray finalResults = new JArray();
    bool hasMorePages = true;
    int pagesReturned = 0;
    int issuesReturned = 0;
    // Stop with 10 pages, because these are large repos:
    while (hasMorePages && (pagesReturned++ < 10))
    {
        var postBody = issueAndPRQuery.ToJsonText();
        var response = await client.Connection.Post<string>(new Uri("https://api.github.com/graphql"),
            postBody, "application/json", "application/json");
        JObject results = JObject.Parse(response.HttpResponse.Body.ToString());
        int totalCount = (int)issues(results)["totalCount"];
        hasMorePages = (bool)pageInfo(results)["hasPreviousPage"];
        issueAndPRQuery.Variables["start_cursor"] = pageInfo(results)["startCursor"].ToString();
        issuesReturned += issues(results)["nodes"].Count();
        finalResults.Merge(issues(results)["nodes"]);
        progress?.Report(issuesReturned);
        cancel.ThrowIfCancellationRequested();
    }
    return finalResults;
    JObject issues(JObject result) => (JObject)result["data"]["repository"]["issues"];
    JObject pageInfo(JObject result) => (JObject)issues(result)["pageInfo"];
}
 
         これらの新しい言語機能は、.NET Standard 2.1 に追加され、.NET Core 3.0 で実装された 3 つの新しいインターフェイスに依 存します。
System.Collections.Generic.IAsyncEnumerable<T> System.Collections.Generic.IAsyncEnumerator<T> System.IAsyncDisposable
この 3 つのインターフェイスは、ほとんどの C# 開発者にとって見慣れたものです。 これらは、同期版と同じように動作します。
System.Collections.Generic.IEnumerable<T> System.Collections.Generic.IEnumerator<T> System.IDisposable
見慣れない可能性のある1つの型はSystem.Threading.Tasks.ValueTaskです。 ValueTask 構造体で は、System.Threading.Tasks.Task クラスと同様の API が提供されます。 パフォーマンス上の理由から、これらのインターフェイ スでは ValueTask が使用されます。
非同期ストリームに変換する
次に、 メソッドを変換して非同期ストリームを生成します。 まず、 IAsyncEnumerable<JToken> を返すよ うに のシグネチャを変更し、次のコードに示すように、パラメーター リストからキャンセル トークンと進行状 況オブジェクトを削除します。
次のコードに示すように、初期コードではページが取得されると各ページが処理されます。
この 3 行を次のコードに置き換えます。
このメソッドの前の方にある finalResults の宣言と、変更したループに続く return ステートメントを削除することもできます。 非同期ストリームを生成するための変更が完了しました。 完了したメソッドは次のコードのようになります。
    runPagedQueryAsync
 runPagedQueryAsync
    private static async IAsyncEnumerable<JToken> runPagedQueryAsync(GitHubClient client,
    string queryText, string repoName)
     finalResults.Merge(issues(results)["nodes"]);
progress?.Report(issuesReturned);
cancel.ThrowIfCancellationRequested();
     foreach (JObject issue in issues(results)["nodes"])
    yield return issue;
   
  次に、コレクションを使用するコードを変更して、非同期ストリームを使用するようにします。 Main 内で、問題のコレクションを 処理する次のコードを探します。
    var progressReporter = new progressStatus((num) =>
{
    Console.WriteLine($"Received {num} issues in total");
});
CancellationTokenSource cancellationSource = new CancellationTokenSource();
try {
}
catch (OperationCanceledException)
{
    Console.WriteLine("Work has been cancelled");
}
var results = await runPagedQueryAsync(client, PagedIssueQuery, "docs",
    cancellationSource.Token, progressReporter);
foreach(var issue in results)
    Console.WriteLine(issue);
  このコードを次の await foreach ループに置き換えます。
   private static async IAsyncEnumerable<JToken> runPagedQueryAsync(GitHubClient client,
    string queryText, string repoName)
{
    var issueAndPRQuery = new GraphQLRequest
    {
        Query = queryText
    };
    issueAndPRQuery.Variables["repo_name"] = repoName;
    bool hasMorePages = true;
    int pagesReturned = 0;
    int issuesReturned = 0;
    // Stop with 10 pages, because these are large repos:
    while (hasMorePages && (pagesReturned++ < 10))
    {
        var postBody = issueAndPRQuery.ToJsonText();
        var response = await client.Connection.Post<string>(new Uri("https://api.github.com/graphql"),
            postBody, "application/json", "application/json");
        JObject results = JObject.Parse(response.HttpResponse.Body.ToString());
        int totalCount = (int)issues(results)["totalCount"];
        hasMorePages = (bool)pageInfo(results)["hasPreviousPage"];
        issueAndPRQuery.Variables["start_cursor"] = pageInfo(results)["startCursor"].ToString();
        issuesReturned += issues(results)["nodes"].Count();
        foreach (JObject issue in issues(results)["nodes"])
            yield return issue;
}
    JObject issues(JObject result) => (JObject)result["data"]["repository"]["issues"];
    JObject pageInfo(JObject result) => (JObject)issues(result)["pageInfo"];
}
 
      新しいインターフェイス IAsyncEnumerator<T> は IAsyncDisposable から派生します。 つまり、前のループは、ループの完了 時、ストリームを非同期で破棄します。 ループは次のコードのようになります。
    int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
}
} finally
{
    if (enumerator != null)
}
await enumerator.DisposeAsync();
 既定では、ストリーム要素はキャプチャされたコンテキストで処理されます。 コンテキストのキャプチャを無効にする場合 は、TaskAsyncEnumerableExtensions.ConfigureAwait 拡張メソッドを使用します。 同期コンテキストについて、および現在 のコンテキストのキャプチャについての詳細は、「タスク ベースの非同期パターンの利用」を参照してください。
非同期ストリームでは、他の async メソッドと同じプロトコルを利用してキャンセルできます。キャンセルをサポートするよう、非 同期反復子メソッドのシグネチャを次のように変更します。
   int num = 0;
await foreach (var issue in runPagedQueryAsync(client, PagedIssueQuery, "docs"))
{
    Console.WriteLine(issue);
    Console.WriteLine($"Received {++num} issues in total");
}
 
       EnumeratorCancellationAttribute 属性によってコンパイラは IAsyncEnumerator<T> のコードを生成します。このコード は、 GetAsyncEnumerator に渡されたトークンを非同期反復子の本文にその引数として表示します。 runQueryAsync の中で は、トークンの状態を調べたり、要求されたら、後続の処理をキャンセルしたりできます。
キャンセル トークンを非同期ストリームに渡すには、別の拡張メソッド WithCancellation を使用します。 問題を列挙するルー プを次のように変更します。
      private static async Task EnumerateWithCancellation(GitHubClient client)
{
    int num = 0;
    var cancellation = new CancellationTokenSource();
    await foreach (var issue in runPagedQueryAsync(client, PagedIssueQuery, "docs")
        .WithCancellation(cancellation.Token))
    {
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
}
 完了したチュートリアルのコードは、csharp/tutorials/AsyncStreams フォルダー内の dotnet/docs リポジトリから取得できま す。
完成したアプリケーションを実行する
アプリケーションをもう一度実行します。 その動作を初期アプリケーションの動作と比較します。 結果の最初のページは、使用 可能になるとすぐに列挙されます。 新しい各ページが要求され、取得されるときに観測可能な一時停止があり、次のページの
   private static async IAsyncEnumerable<JToken> runPagedQueryAsync(GitHubClient client,
    string queryText, string repoName, [EnumeratorCancellation] CancellationToken cancellationToken =
default) {
    var issueAndPRQuery = new GraphQLRequest
    {
        Query = queryText
    };
    issueAndPRQuery.Variables["repo_name"] = repoName;
    bool hasMorePages = true;
    int pagesReturned = 0;
    int issuesReturned = 0;
    // Stop with 10 pages, because these are large repos:
    while (hasMorePages && (pagesReturned++ < 10))
    {
        var postBody = issueAndPRQuery.ToJsonText();
        var response = await client.Connection.Post<string>(new Uri("https://api.github.com/graphql"),
            postBody, "application/json", "application/json");
        JObject results = JObject.Parse(response.HttpResponse.Body.ToString());
        int totalCount = (int)issues(results)["totalCount"];
        hasMorePages = (bool)pageInfo(results)["hasPreviousPage"];
        issueAndPRQuery.Variables["start_cursor"] = pageInfo(results)["startCursor"].ToString();
        issuesReturned += issues(results)["nodes"].Count();
        foreach (JObject issue in issues(results)["nodes"])
            yield return issue;
}
    JObject issues(JObject result) => (JObject)result["data"]["repository"]["issues"];
    JObject pageInfo(JObject result) => (JObject)issues(result)["pageInfo"];
}
 
 結果がすぐに列挙されます。 try / catch ブロックではキャンセルを処理する必要はありません。呼び出し元がコレクションの 列挙を停止できます。 各ページがダウンロードされるときに非同期ストリームによって結果が生成されるので、進行状況が明確 にレポートされます。 返される各問題の状態は、 await foreach ループにシームレスに含まれます。 進行状況を追跡するた めにコールバック オブジェクトは必要ありません。
コードを調べることで、メモリの改善を確認できます。 すべての結果が列挙される前にそれらを格納するコレクションを割り当てる 必要がなくなります。 呼び出し元では、結果を使用する方法、および記憶域のコレクションが必要かどうかを判断できます。
初期アプリケーションと完成したアプリケーションの両方を実行し、実装間の違いを自分で確認できます。 完了後に、このチュー トリアルの開始時に作成した GitHub アクセス トークンを削除することができます。 攻撃者は、そのトークンへのアクセス権を獲 得すると、ユーザーの資格情報を使用して GitHub API にアクセスできます。
 
     C# 7 で、基本的なパターン マッチング機能が導入されました。 C# 8 と C# 9 では、これらの機能が新しい式とパターンで拡張 されています。 他のライブラリ内に存在する可能性がある型を拡張したかのように動作する機能を記述できます。 パターンの別 の用途は、アプリケーションで必要な、拡張される型の基本機能ではない機能を作成することです。
このチュートリアルで学習する内容は次のとおりです。
パターン マッチングを使用する必要がある状況を認識する。
パターン マッチング式を使用して、型とプロパティの値に基づく動作を実装する。 パターン マッチングと他の手法を組み合わせて、完全なアルゴリズムを作成する。
必須コンポーネント
お使いのマシンを、.NET 5 が実行されるように設定する必要があります。これには C# 9 コンパイラが含まれます。 C# 9 コンパイ
ラは Visual Studio 2019 バージョン 16.9 プレビュー 1 または .NET 5.0 SDK 以降で使用できます。 このチュートリアルでは、.NET と、C# と Visual Studio または .NET Core CLI のいずれかに精通していることを前提としていま
す。
パターン マッチングのシナリオ
多くの場合、最新の開発には、1 つのまとまりのあるアプリケーションの中で、複数のソースから受信するデータを統合し、それら のデータに基づいて情報と分析情報を提示することが含まれます。 開発者やチームは、受信データを表す型のすべてをコント ロールしたり、アクセスしたりすることはできません。
従来のオブジェクト指向設計では、複数のデータ ソースから受信する各データ型を表す型をアプリケーション内で作成する必要 があります。 その後、アプリケーションで、それらの新しい型を操作し、継承階層を構築し、仮想メソッドを作成し、抽象化を実 装します。 これらの手法は有効であり、ときには最善のツールです。 少ないコードを記述できる場合があります。 データと、その データを操作する操作を分離する手法を使用して、もっと読みやすいコードを記述できます。
このチュートリアルでは、1 つのシナリオでさまざまな外部ソースから受信データを受け取るアプリケーションを作成して探索しま す。 パターン マッチング を使用して、元のシステムには含まれていない効率的な方法で、データを使用して処理するしくみを 見ていきます。
通行料金とピーク時間帯料金を使用して交通量を管理する大都市圏について検討します。 車種に基づいて通行料金を計 算するアプリケーションを記述します。 機能強化として、車両の乗員数に基づく料金を組み込みます。 さらなる機能強化とし て、時間帯と曜日に基づく料金を追加します。
この簡単な説明から、このシステムをモデル化するオブジェクト階層をすぐに思い描くことができます。 ただし、データは、他の車 両登録管理システムなどの複数のソースから送信されます。 これらのシステムでは異なるクラスを使用してデータがモデル化され ているため、使用できる単一のオブジェクト モデルはありません。 このチュートリアルでは、次のコードに示すように、簡略化された クラスを使用して外部システムからの車両データをモデル化します。
チュートリアル: パターン マッチングを使用し
て、型ドリブンおよびデータ ドリブンのアルゴ
リズムを構築する
2021/03/06 • • Edit Online
 
   GitHub の dotnet/samples リポジトリから、スタート コードをダウンロードすることができます。 さまざまなシステムからの車両クラ スがあり、異なる名前空間に存在していることがわかります。 System.Object を除いて、利用できる共通基底クラスはありませ ん。
パターン マッチング設計
このチュートリアルで使用するシナリオでは、パターン マッチングを使用して解決するのに適した種類の問題に焦点を当てていま す。
操作する必要があるオブジェクトは、目標と一致するオブジェクト階層内にはありません。 別個のシステムの一部であるクラ スを操作する可能性があります。
追加する機能は、これらのクラスのコア抽象化の一部ではありません。 車両が支払う通行料金は、車両の種類によって "変化" しますが、通行料金は車両の中心的な関数ではありません。
データの "形状" とデータに対する "操作" が一緒に記述されていない場合は、C# のパターン マッチング機能によって、作業が 容易になります。
基本的な通行料金計算を実装する 最も基本的な通行料金計算は、車種にのみ依存します。
Car は$2.00。
Taxi は$3.50。
Bus は$5.00。 DeliveryTruck は$10.00。
新しい クラスを作成し、車種に対するパターン マッチングを実装して、通行料金の金額を取得します。 の最初の実装を次のコードに示します。
   TollCalculator
 TollCalculator
   namespace ConsumerVehicleRegistration
{
    public class Car
    {
        public int Passengers { get; set; }
    }
}
namespace CommercialRegistration
{
    public class DeliveryTruck
    {
        public int GrossWeightClass { get; set; }
    }
}
namespace LiveryRegistration
{
    public class Taxi
    {
        public int Fares { get; set; }
    }
    public class Bus
    {
        public int Capacity { get; set; }
        public int Riders { get; set; }
    }
}
 
    上記のコードでは、型パターン をテストする switch 式( ステートメントとは異なります) が使用されています。 上記の コードでは、switch 式 は変数 で始まり、 キーワードが続きます。 次に、すべての switch アーム が中 かっこ内に指定されます。 式は、 ステートメントを囲む構文に対して、その他の絞り込みを行います。 case キーワードは省略され、各アームの結果が式になります。 最後の 2 つのアームは、新しい言語機能を示しています。 { } case は、前のアームと一致しなかった null 以外のオブジェクトと一致します。 このアームは、このメソッドに渡された正しくない型 をキャッチします。 { } case は、車種ごとの case に従う必要があります。 順序が逆になった場合は、 { } case が優先され ます。最後に、null パターンで、このメソッドに null が渡されたときを検出します。他の型パターンがnull以外の正しい車 種のオブジェクトのみと一致するため、 null パターンを最後にすることができます。
このコードを Program.cs の次のコードを使用してテストできます。
switch
  vehicle
switch
  switch
switch
    using System;
using CommercialRegistration;
using ConsumerVehicleRegistration;
using LiveryRegistration;
namespace toll_calculator
{
    public class TollCalculator
    {
        public decimal CalculateToll(object vehicle) =>
            vehicle switch
{
            { }
nameof(vehicle)),
null
}; }
}
Car c
Taxi t
Bus b
DeliveryTruck t => 10.00m,
=> 2.00m,
=> 3.50m,
=> 5.00m,
=> throw new ArgumentException(message: "Not a known vehicle type", paramName:
=> throw new ArgumentNullException(nameof(vehicle))
 
    このコードはスタート プロジェクトに含まれていますが、コメント アウトされています。コメントを削除することで、自分で記述した コードをテストできます。
コードとデータが分離されるアルゴリズムの作成にパターンがどのように役立つかを示す最初の例を見てきました。 switch 式に よって型がテストされ、結果に基づいて別の値が生成されます。 これはほんの序の口に過ぎません。
乗員料金を追加する
料金徴収機関は、車両が乗車定員を乗せて走行することを推奨したいと思っています。 車両の乗員数が少ない場合は多く 請求し、乗車定員の場合は料金を下げることによって、定員いっぱいでの走行を推奨することを決定しています。
乗客がいない自動車とタクシーは、$0.50 余分に支払う。
2 名の乗客がいる自動車とタクシーは、$0.50 割引される。
3 名以上の乗客がいる自動車とタクシーは、$1.00 割引される。 乗車率が 50% 未満のバスは、$2.00 余分に支払う。 乗車率が 90% を超えるバスは、$1.00 割引される。
このルールは、同じ switch 式で プロパティ パターン を使用して実装できます。 プロパティ パターンは、プロパティ値を定数値と 比較する when 句です。プロパティパターンでは、型が決定した後、オブジェクトのプロパティが調べられます。 Car に対する
   using System;
using CommercialRegistration;
using ConsumerVehicleRegistration;
using LiveryRegistration;
namespace toll_calculator
{
    class Program
    {
        static void Main(string[] args)
        {
            var tollCalc = new TollCalculator();
            var car = new Car();
            var taxi = new Taxi();
            var bus = new Bus();
            var truck = new DeliveryTruck();
            Console.WriteLine($"The toll for a car is {tollCalc.CalculateToll(car)}");
            Console.WriteLine($"The toll for a taxi is {tollCalc.CalculateToll(taxi)}");
            Console.WriteLine($"The toll for a bus is {tollCalc.CalculateToll(bus)}");
            Console.WriteLine($"The toll for a truck is {tollCalc.CalculateToll(truck)}");
try {
                tollCalc.CalculateToll("this will fail");
            }
            catch (ArgumentException e)
            {
                Console.WriteLine("Caught an argument exception when using the wrong type");
            }
try {
                tollCalc.CalculateToll(null!);
            }
            catch (ArgumentNullException e)
            {
                Console.WriteLine("Caught an argument exception when using null");
            }
} }
}

 1 つの case が、4 つの異なる case に拡張されます。
    vehicle switch
{
    Car {Passengers: 0}
    Car {Passengers: 1}
    Car {Passengers: 2}
    Car c
// ... };
=> 2.00m + 0.50m,
=> 2.0m,
=> 2.0m - 0.50m,
=> 2.00m - 1.0m,
  最初の3つのcaseでは、型を Car としてテストした後、Passengers プロパティの値がチェックされます。両方が一致した場 合は、その式が評価され、結果が返されます。
タクシーに対する case も、同様の方法で拡張します。
    vehicle switch
{
// ...
    Taxi {Fares: 0}  => 3.50m + 1.00m,
    Taxi {Fares: 1}  => 3.50m,
    Taxi {Fares: 2}  => 3.50m - 0.50m,
    Taxi t           => 3.50m - 1.00m,
// ... };
 上記の例では、最後のcaseの when 句は省略されています。 次に、次の例に示すように、バスに対する case を拡張して、乗車率ルールを実装します。
    vehicle switch
{
// ...
    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,
    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,
    Bus b => 5.00m,
// ... };
 料金徴収機関は、配送トラックの乗客数には関心がありません。 代わりに、次のようにトラックの重量クラスに基づいて通行料 金の金額を調整します。
5,000 lbs を超えるトラックは、$5.00 余分に請求される。 3,000 lbs を下回る軽トラックは、$2.00 割引される。
これらのルールは、次のコードで実装されます。

  前のコードは、switchアームの when 句を示しています。 when 句を使用して、プロパティの等価以外の条件をテストできま す。 完了すると、次のコードによく似たメソッドが作成されます。
    vehicle switch
{
    Car {Passengers: 0}
    Car {Passengers: 1}
    Car {Passengers: 2}
    Car c
=> 2.00m + 0.50m,
=> 2.0m,
=> 2.0m - 0.50m,
=> 2.00m - 1.0m,
    Taxi {Fares: 0}  => 3.50m + 1.00m,
    Taxi {Fares: 1}  => 3.50m,
    Taxi {Fares: 2}  => 3.50m - 0.50m,
    Taxi t           => 3.50m - 1.00m,
    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,
    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,
    Bus b => 5.00m,
    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,
    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,
    DeliveryTruck t => 10.00m,
    { }     => throw new ArgumentException(message: "Not a known vehicle type", paramName: nameof(vehicle)),
    null    => throw new ArgumentNullException(nameof(vehicle))
};
  これらの switch アームの多くは、再帰パターン の例です。 たとえば、 Car { Passengers: 1} は、プロパティ パターンの内部の 定数パターンを示しています。
switchを入れ子にして使用することで、このコードの反復を少なくすることができます。 Car と Taxi は、どちらにも上記の例 で示した 4 つの異なるアームがあります。 両方に対して、プロパティ パターンに供給される型パターンを作成できます。 この手法 を次のコードに示します。
   vehicle switch
{
// ...
    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,
    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,
    DeliveryTruck t => 10.00m,
};
 
  上記の例では、再帰式の使用は、プロパティの値をテストする子アームを含む Car と Taxi のアームを繰り返さないことを意 味しています。この手法は、プロパティの個別の値ではなくその範囲をテストする Bus と DeliveryTruck のアームでは使用さ れません。
ピーク料金を追加する
最後の機能として、料金徴収機関は、時間に依存するピーク料金を追加することを望んでいます。 朝と夕方のラッシュ アワー の間は、通行料金を倍にします。 このルールは、片方向の通行のみに影響し、朝のラッシュ時は市内に入る (インバウンド) 通 行が、夕方のラッシュ時は市外に出てゆく (アウトバウンド) 通行が対象になります。 平日のその他の時間帯では、通行料金 は 50% 増額される。 深夜と早朝の通行料金は、25% 減額される。 週末は、時間に関係なく、通常料金になる。 次のコー ドを使用して、 if および else ステートメントの連続使用によりこれを表すことができます。
    public decimal CalculateToll(object vehicle) =>
    vehicle switch
    {
        Car c => c.Passengers switch
        {
            0 => 2.00m + 0.5m,
            1 => 2.0m,
            2 => 2.0m - 0.5m,
            _ => 2.00m - 1.0m
},
        Taxi t => t.Fares switch
        {
            0 => 3.50m + 1.00m,
            1 => 3.50m,
            2 => 3.50m - 0.50m,
            _ => 3.50m - 1.00m
},
        Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,
        Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,
        Bus b => 5.00m,
        DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,
        DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,
        DeliveryTruck t => 10.00m,
        { }  => throw new ArgumentException(message: "Not a known vehicle type", paramName:
nameof(vehicle)),
        null => throw new ArgumentNullException(nameof(vehicle))
    };
 
    上記のコードは正常に動作しますが、読みにくいものです。コードを理解するには、すべての入力ケースと入れ子になった if ステートメントを連結する必要があります。 代わりに、この機能のためにパターン マッチングを使用しますが、それは他の手法と 統合します。 方向、曜日、および時間帯のすべてを組み合わせた単一のパターン マッチ式を作成できますが、 結果は、複雑 な式になるでしょう。 読みにくく、理解しにくくなるでしょう。 それは、正確さを保証することを難しくします。 代わりに、メソッドを 組み合わせて、すべての状態を簡潔に記述する値のタプルを作成します。 その後、パターン マッチングを使用して、通行料金 の乗数を計算できます。 タプルには、3 つの個別の条件が含まれています。
その日が平日または週末のどちらであるか。 通行料金が収集される時間帯。 方向が市内に入るほうか市外に出るほうか。
次の表に、入力値の組み合わせとピーク時の乗数を示します。
  public decimal PeakTimePremiumIfElse(DateTime timeOfToll, bool inbound)
{
    if ((timeOfToll.DayOfWeek == DayOfWeek.Saturday) ||
        (timeOfToll.DayOfWeek == DayOfWeek.Sunday))
    {
        return 1.0m;
} else {
} }
int hour = timeOfToll.Hour;
if (hour < 6)
{
    return 0.75m;
}
else if (hour < 10)
{
    if (inbound)
    {
        return 2.0m;
    }
else {
        return 1.0m;
    }
}
else if (hour < 16)
{
    return 1.5m;
}
else if (hour < 20)
{
    if (inbound)
    {
        return 1.0m;
    }
else {
        return 2.0m;
    }
}
else // Overnight
{
    return 0.75m;
}

   TIME
DIRECTION
PREMIUM
        平日 朝のラッシュ時
平日 朝のラッシュ時
平日 日中
平日 日中
平日 夕方のラッシュ時
平日 夕方のラッシュ時
平日 夜間
平日 夜間
週末 朝のラッシュ時
週末 朝のラッシュ時
週末 日中
週末 日中
週末 夕方のラッシュ時
週末 夕方のラッシュ時
週末 夜間
週末 夜間
インバウンド アウトバウンド インバウンド アウトバウンド インバウンド アウトバウンド インバウンド アウトバウンド インバウンド アウトバウンド インバウンド アウトバウンド インバウンド アウトバウンド インバウンド アウトバウンド
x 2.00 x 1.00 x 1.50 x 1.50 x 1.00 x 2.00 x 0.75 x 0.75 x 1.00 x 1.00 x 1.00 x 1.00 x 1.00 x 1.00 x 1.00 x 1.00
                                                                                                                            3 つの変数の 16 組の異なる組み合わせがあります。 いくつかの条件を組み合わせることで、最終的な switch 式を簡略化し ます。
通行料金を収集するシステムでは、通行料金が徴収される時刻に対して DateTime 構造体を使用しています。 上記の表か ら、変数を作成するメンバー メソッドを作成します。 次の関数では、パターン マッチングの switch 式を使用して、DateTime が 週末または平日のどちらを表しているかを示しています。
    private static bool IsWeekDay(DateTime timeOfToll) =>
    timeOfToll.DayOfWeek switch
    {
        DayOfWeek.Monday    => true,
        DayOfWeek.Tuesday   => true,
        DayOfWeek.Wednesday => true,
        DayOfWeek.Thursday  => true,
        DayOfWeek.Friday    => true,
        DayOfWeek.Saturday  => false,
        DayOfWeek.Sunday    => false
};
 このメソッドは正しいものですが、繰り返しが含まれています。 次のコードに示すように簡略化できます。

  次に、時間をブロックに分類する同様の関数を追加します。
    private enum TimeBand
{
    MorningRush,
    Daytime,
    EveningRush,
    Overnight
}
private static TimeBand GetTimeBand(DateTime timeOfToll) =>
    timeOfToll.Hour switch
    {
        < 6 or > 19 => TimeBand.Overnight,
        < 10 => TimeBand.MorningRush,
        < 16 => TimeBand.Daytime,
        _ => TimeBand.EveningRush,
};
  プライベート enum を追加して、時間の各範囲を個別の値に変換します。 次に、 GetTimeBand メソッドにより、"リレーショナル パターン" と "結合 or パターン" が使用されます。どちらも C# 9.0 で追加されたものです。 リレーショナル パターンを使用すると、 < 、 > 、 <= 、または >= の使用により数値をテストできます。 or パターンを使用すると、式が 1 つ以上のパターンに一致
するかどうかをテストできます。 また、 and パターンを使用して、式が 2 つの異なるパターンに一致することを確認し、 not パ ターンを使用して、式がパターンに一致しないことをテストすることもできます。
これらのメソッドを作成したら、別の switch 式とタプルパターンを使用して、割増料金を計算できます。全部で16のアー ムがある switch 式を作成できます。
      public decimal PeakTimePremiumFull(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
    {
        (true, TimeBand.MorningRush, true) => 2.00m,
        (true, TimeBand.MorningRush, false) => 1.00m,
        (true, TimeBand.Daytime, true) => 1.50m,
        (true, TimeBand.Daytime, false) => 1.50m,
        (true, TimeBand.EveningRush, true) => 1.00m,
        (true, TimeBand.EveningRush, false) => 2.00m,
        (true, TimeBand.Overnight, true) => 0.75m,
        (true, TimeBand.Overnight, false) => 0.75m,
        (false, TimeBand.MorningRush, true) => 1.00m,
        (false, TimeBand.MorningRush, false) => 1.00m,
        (false, TimeBand.Daytime, true) => 1.00m,
        (false, TimeBand.Daytime, false) => 1.00m,
        (false, TimeBand.EveningRush, true) => 1.00m,
        (false, TimeBand.EveningRush, false) => 1.00m,
        (false, TimeBand.Overnight, true) => 1.00m,
        (false, TimeBand.Overnight, false) => 1.00m,
};
 上記のコードは機能しますが、簡略化できます。 週末の 8 つの組み合わせは、同じ通行料金になります。 8 つのすべてを、 次の行に置き換えることができます。
   private static bool IsWeekDay(DateTime timeOfToll) =>
    timeOfToll.DayOfWeek switch
    {
        DayOfWeek.Saturday => false,
        DayOfWeek.Sunday => false,
        _ => true
};
 
   平日の日中と夜間のインバウンドとアウトバウンドの通行では、同じ乗数が使用されます。 これら 4 つの switch アームは、次 の 2 行に置換できます。
これら 2 つの変更を行った後のコードは、次のようになります。
    (true, TimeBand.Overnight, _) => 0.75m,
(true, TimeBand.Daytime, _)   => 1.5m,
     public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
    {
        (true, TimeBand.MorningRush, true)  => 2.00m,
        (true, TimeBand.MorningRush, false) => 1.00m,
        (true, TimeBand.Daytime,     _)     => 1.50m,
        (true, TimeBand.EveningRush, true)  => 1.00m,
        (true, TimeBand.EveningRush, false) => 2.00m,
        (true, TimeBand.Overnight,   _)     => 0.75m,
        (false, _,                   _)     => 1.00m,
};
 最後に、通常料金を支払う 2 つのラッシュの時間帯は削除できます。 これらのアームを削除した後、最後の switch アーム内 の false を破棄 ( _ ) に置き換えることができます。 次のメソッドが完成します。
    public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
    {
        (true, TimeBand.Overnight, _) => 0.75m,
        (true, TimeBand.Daytime, _) => 1.5m,
        (true, TimeBand.MorningRush, true) => 2.0m,
        (true, TimeBand.EveningRush, false) => 2.0m,
        _ => 1.0m,
};
 この例では、パターン マッチングの利点の 1 つに注目しています。パターンの分岐は、順序正しく評価されます。 前のほうの分 岐で後ろにあるいずれかの case が処理されるようにパターンを並べ替えると、コンパイラによって到達できないコードに関する警 告が表示されます。 これらの言語ルールによって、コードが変化しないという自信を持って、前述した簡略化を簡単に実行でき ます。
パターン マッチングによって、ある種のコードが読みやすくなり、クラスにコードを追加できない場合はオブジェクト指向の手法の代 替として機能します。 クラウドによって、データと機能は分離されています。 データの "形状" とデータに対する "操作" は、必ず しも一緒に記述されるわけではありません。 このチュートリアルでは、既存のデータを、元の関数とは完全に異なる方法で使用 しています。 パターン マッチングでは、型を拡張できない場合でも、それらをオーバーライドする機能を記述できます。
次のステップ
GitHub リポジトリの dotnet/samples から、完成したコードをダウンロードできます。 自分のパターンを調査し、通常のコーディ ング アクティビティにこの手法を追加してください。 これらの手法を習得することで、別の方法で問題にアプローチし、新しい機能 を作成できます。
 (false, _, _) => 1.0m,
 
       このチュートリアルでは、.NET Core と C# 言語のさまざまな機能を説明します。 内容は以下のとおりです。
.NET Core CLI の基本事項
C# コンソール アプリケーションの構造 コンソール入出力
.NET でのファイル入出力 API の基本
.NET でのタスクベースの非同期プログラミングの基本
テキスト ファイルを読み取って、そのテキスト ファイルの内容をコンソールにエコーするアプリケーションをビルドします。 コンソールへ の出力は、内容を読み上げる速度に一致します。 "<" (未満) または ">" (大なり) キーを押して、速度を速めたり遅めたりでき ます。
このチュートリアルには、多くの機能が含まれています。 それらを 1 つずつビルドしてみましょう。 必須コンポーネント
お使いのマシンを、.NET Core が実行されるように設定します。 インストールの手順については、.NET Core のダウン ロード ページを参照してください。 このアプリケーションは、Windows、Linux、macOS 上、または Docker コンテナーで 実行できます。
お好みのコード エディターをインストールしてください。
アプリを作成する
最初に新しいアプリケーションを作成します。 コマンド プロンプトを開き、アプリケーション用の新しいディレクトリを作成します。 そ れを、現在のディレクトリとしてください。 コマンド プロンプトで dotnet new console のコマンドを入力します。 これで、基本的 な "Hello World" アプリケーションのスターター ファイルが作成されます。
変更を加える前に、このシンプルな Hello World アプリケーションを実行する手順を見ていきましょう。 アプリケーション作成後、 コマンド プロンプトで dotnet restore と入力します。 このコマンドにより、NuGet パッケージの復元処理が実行されます。 NuGet は .NET パッケージ マネージャーです。 このコマンドにより、プロジェクトの依存関係のうち欠落しているものがすべてダウ ンロードされます。 これは新しいプロジェクトなので、依存関係は何もなく、最初の実行で .NET Core フレームワークがダウン ロードされます。 この初期手順の後に必要なのは、新しい依存パッケージを追加するときに dotnet restore を実行するか、 いずれかの依存関係のバージョンを更新するだけです。
を実行する必要がなくなりました。復元を必要とするすべてのコマンド ( dotnet new 、 dotnet build 、
、 、 、 dotnet pack など) によって暗黙的に実行されるためです。 暗黙的な復
元を無効にするには、 オプションを使用します。
Azure DevOps Services の継続的インテグレーション ビルドなどの、明示的な復元が意味のある一部のシナリオや、復元が
行われるタイミングを明示的に制御する必要があるビルド システムでは、 dotnet restore は引き続き有用なコマンドです。 NuGetフィードの管理方法については、 dotnet restore のドキュメントをご覧ください。
パッケージを復元したら、 を実行します。 これにより、ビルド エンジンが実行され、アプリケーション実行可能ファ イルが作成されます。 最後に、 を実行してアプリケーションを実行します。
シンプルな Hello World アプリケーションのコードはすべて Program.cs に含まれています。 使い慣れたテキスト エディターでそ のファイルを開きます。 最初の変更を加えてみましょう。 ファイルの上部に、using ステートメントがあります。
      dotnet restore
    dotnet run
dotnet test
dotnet publish
 --no-restore
   dotnet build
 dotnet run
コンソール アプリ
2021/03/13 • • Edit Online
 
           このステートメントは、 System 名前空間からのいずれの型もスコープ内にあることをコンパイラに伝えています。 お使いになった ことのある他のオブジェクト指向の言語と同じく、C# では名前空間を使用して型を整理します。 この Hello World プログラムも 同様です。 プログラムは現在のディレクトリの名前に基づく名前を持つ名前空間で囲まれていることがわかります。 このチュート リアルでは、名前空間の名前を TeleprompterConsole に変更します。
ファイルの読み取りとエコー
最初に追加する機能は、テキスト ファイルを読み取り、そのテキストすべてをコンソールに表示する機能です。 まず、テキスト ファイルを追加しましょう。 このサンプルの GitHub リポジトリから、sampleQuotes.txt ファイルをプロジェクト ディレクトリにコピーし ます。 これがアプリケーションのスクリプトとして機能します。 このトピックのサンプル アプリをダウンロードする方法については、「サ ンプルおよびチュートリアル」をご覧ください。
次に、以下のメソッドを Program クラス(Main メソッドの真下)に追加します。
   namespace TeleprompterConsole
      static IEnumerable<string> ReadFrom(string file)
{
    string line;
    using (var reader = File.OpenText(file))
    {
} }
while ((line = reader.ReadLine()) != null)
{
    yield return line;
}
 このメソッドは、2 つの新しい名前空間の型を使用します。 これをコンパイルするには、ファイルの先頭に次の 2 行を追加する 必要があります。
IEnumerable<T> インターフェイスは System.Collections.Generic 名前空間で定義されます。 File クラスは System.IO 名 前空間で定義されます。
このメソッドは 反復子メソッド と呼ばれる特殊な型の C# メソッドです。 列挙子メソッドは、遅延評価されるシーケンスを返しま す。 つまり、シーケンスを使用するコードによって要求されると、そのシーケンス内の各項目が生成されことになります。 列挙子メ ソッドは、1 つまたは複数の yield return ステートメントを含むメソッドです。 ReadFrom メソッドによって返されるオブジェクト には、シーケンス内の各項目を生成するコードが含まれています。 この例では、ソース ファイルからテキストの次の行を読み取 り、その文字列を返す処理が含まれます。 呼び出し元のコードがシーケンスから次の項目を要求するたびに、コードはファイルか らテキストの次の行を読み取り、それを返します。 ファイルが完全に読み取られたら、シーケンスはこれ以上項目がないことを示 します。
新機能としてさらに、C#構文要素が2つあります。このメソッド内の using ステートメントは、リソースのクリーンアップを管理 するものです。 using ステートメント内で初期化された変数(この例では reader)は、IDisposableインターフェイスを実装 する必要があります。そのインターフェイスは、リソースの解放が必要なときに呼び出す必要がある1つのメソッド Dispose を 定義します。 実行が using ステートメントの右中かっこに達したときに、コンパイラがその呼び出しを生成します。 コンパイラに よって生成されたコードでは、using ステートメントによって定義されたブロック内のコードから例外がスローされた場合でも、確実 にリソースを解放させます。
    using System.Collections.Generic;
using System.IO;
      using System;
 
     変数は var キーワードを使用して定義されます。 var は暗黙的に型指定されたローカル変数を定義します。つ まり、変数の型は、変数に割り当てられているオブジェクトのコンパイル時の型によって決まるということです。 ここで は、OpenText(String) メソッドからの戻り値のことで、これは StreamReader オブジェクトです。
ここで、 Main メソッドにファイルを読み取るコードを入力してみましょう。
プログラム ( dotnet run を使用) を実行すると、コンソールに出力されるすべての行を確認できます。 遅延の追加と出力の書式設定
コードは今の状態だと、表示が早すぎて読み上げることができません。 出力に遅延を追加する必要があります。 非同期処理 を可能にするコア コードを作成していくことになります。 しかしここでの手順では、アンチパターンをいくつか使います。 このアンチ パターンは、コードを追加しながらコメントで指摘され、コードは後の手順で更新されます。
このセクションでは 2 つの手順があります。 最初に、行全体ではなく単一の語を返すように反復子メソッドを更新します。 その ために、次の変更を行います。 yield return line; ステートメントを、次のコードに置き換えます。
次に、ファイルの行を使用する方法を変更し、各語を書き込んだ後に遅延を追加する必要があります。 Main メソッドの Console.WriteLine(line) ステートメントを、次のブロックに置き換えます。
    var lines = ReadFrom("sampleQuotes.txt");
foreach (var line in lines)
{
    Console.WriteLine(line);
}
       var words = line.Split(' ');
foreach (var word in words)
{
    yield return word + " ";
}
yield return Environment.NewLine;
      Console.Write(line);
if (!string.IsNullOrWhiteSpace(line))
{
    var pause = Task.Delay(200);
    // Synchronously waiting on a task is an
    // anti-pattern. This will get fixed in later
    // steps.
    pause.Wait();
}
 TaskクラスはSystem.Threading.Tasks名前空間にあるので、using ステートメントをファイルの先頭に追加する必要があり ます。
このサンプルを実行し、出力を確認します。 これで、各語が出力されるたびに 200 ミリ秒の遅延が発生するようになりました。 しかし、表示される出力には問題があります。ソース テキスト ファイルには、改行なしで 80 文字を超える行が複数あるからで す。 スクロール中にそれを読み取るのは困難です。 これは簡単に修正できます。 各行の長さを追跡して、行の長さが特定の しきい値に達したら新しい行を生成するだけです。行の長さを保持する ReadFrom メソッドの words の宣言の後に、ローカル 変数を宣言します。
  using System.Threading.Tasks;
   reader
 
    そして、次のコードを yield return word + " "; ステートメントの後 (右中かっこの前) に追加します。
    lineLength += word.Length + 1;
if (lineLength > 70)
{
    yield return Environment.NewLine;
    lineLength = 0;
}
 サンプルを実行すると、事前に設定されていたペースで読み上げることができます。 非同期タスク
この最後の手順では、1 つのタスク内で非同期的に出力を記述するとともに、別のタスクを実行して、テキスト表示の速度を上 げ下げしたり、テキスト表示をまとめて停止したりする場合のユーザーからの入力を読み取ります。 これは少しの手順だけで済 み、これで必要な変更はすべて完了となります。 最初に、ここまでで作成したファイルを読み取り表示するコードを表す、非同 期の Task を返すメソッドを作成します。
このメソッドを Program クラス(Main メソッドの本体から取得したもの)に追加します。
     private static async Task ShowTeleprompter()
{
    var words = ReadFrom("sampleQuotes.txt");
    foreach (var word in words)
    {
} }
Console.Write(word);
if (!string.IsNullOrWhiteSpace(word))
{
    await Task.Delay(200);
}
 2 点、変更されます。 1 点目は、メソッドの本体で、Wait() を呼び出してタスクが終了するのを同期的に待つかわりに、この バージョンでは await キーワードを使用することです。 そのためには、 async 修飾子をメソッド シグネチャに追加する必要が あります。このメソッドは Task を返します。 Task オブジェクトを返すreturnステートメントがないことに注意してください。か わりに、その Task オブジェクトは await 演算子を使用した時にコンパイラが生成したコードによって作成されます。このメソッ ドは await に達するときに戻ることが想像できます。 Task が返されたということは、作業が完了していないことを表していま す。このメソッドは、待機中のタスクが完了したときに再開します。それが完了すると Task が返され、タスクが完了したことが わかります。コード呼び出しでは、その返された Task を監視して、いつ完了したのか判断します。
この新しいメソッドは Main メソッドで呼び出すことができます。
ここで、 Main では、コードは同期的に待機します。 可能なときは同期的に待機しないで、 await 演算子を使用します。 し かし、コンソール アプリケーションの Main メソッドでは、 await 演算子を使うことはできません。 それでは、すべてのタスクが完 了する前にアプリケーションが終了することになります。
  ShowTeleprompter().Wait();
   var lineLength = 0;
    NOTE
C# 7.1 以降を使用している場合は、 async Main メソッドでコンソール アプリケーションを作成できます。
 
  次に、2 つ目の非同期メソッドを記述して、コンソールから読み取り、"<" (未満)、">" (大なり)、および "X" または "x" キーを監 視する必要があります。 そのタスクに追加するメソッドは次のとおりです。
    private static async Task GetInput()
{
    var delay = 200;
    Action work = () =>
    {
        do {
            var key = Console.ReadKey(true);
            if (key.KeyChar == '>')
            {
delay -= 10; }
            else if (key.KeyChar == '<')
            {
delay += 10; }
            else if (key.KeyChar == 'X' || key.KeyChar == 'x')
            {
break; }
        } while (true);
    };
    await Task.Run(work);
}
 ここでは、ラムダ式を作成して、コンソールからキーを読み取り、ユーザーが "<" (未満) キーまたは ">" (大なり) キーを押したとき の遅延を表すローカル変数を変更する Action デリゲートを表します。 デリゲート メソッドは、ユーザーが "X" または "x" キーを 押したときに終了し、ユーザーはテキスト表示をいつでも停止できます。 このメソッドは ReadKey() を使用してブロックし、ユー ザーがキーを押すまで待機します。
この機能を完成させるには、これら両方のタスク(GetInput と ShowTeleprompter)を開始し、これら2つのタスク間で共有 データを管理する、 async Task を返す新しいメソッドを作成する必要があります。
これら 2 つのタスク間で共有データを処理するクラスを作成しましょう。 このクラスには、2 つのパブリック プロパティが含まれます。 遅延、そして、ファイルが完全に読み取られたことを示すフラグ Done です。
       namespace TeleprompterConsole
{
    internal class TelePrompterConfig
    {
} }
public int DelayInMilliseconds { get; private set; } = 200;
public void UpdateDelay(int increment) // negative to speed up
{
    var newDelay = Min(DelayInMilliseconds + increment, 1000);
    newDelay = Max(newDelay, 20);
    DelayInMilliseconds = newDelay;
}
public bool Done { get; private set; }
public void SetDone()
{
Done = true; }
  そのクラスを新しいファイルに配置し、上記のように、 TeleprompterConsole 名前空間にそのクラスを囲います。 さらに
using static ステートメントを追加して、囲むクラスや名前空間の名前なしで Min および Max メソッドを参照できるように
 
   する必要があります。   ステートメントは 1 つのクラスからメソッドをインポートします。 これは、この時点までで使 用した、名前空間からすべてのクラスをインポートした using ステートメントとは対照的です。
次に、 ShowTeleprompter メソッドと GetInput メソッドを更新して、新しい config オブジェクトを使用する必要があります。 最後の Task を返す async メソッドを書いて、両方のタスクを開始し、最初のタスクが終了するときに終了させます。
  using static System.Math;
        private static async Task RunTeleprompter()
{
    var config = new TelePrompterConfig();
    var displayTask = ShowTeleprompter(config);
    var speedTask = GetInput(config);
    await Task.WhenAny(displayTask, speedTask);
}
 ここでの 1 つの新しいメソッドは WhenAny(Task[]) の呼び出しです。 これによって、その引数リスト内の任意のタスクが完了し たらすぐに終了する Task が作成されます。
次に、遅延の config オブジェクトを使用するように、 ShowTeleprompter メソッドと GetInput メソッドの両方を更新する必 要があります。
       private static async Task ShowTeleprompter(TelePrompterConfig config)
{
    var words = ReadFrom("sampleQuotes.txt");
    foreach (var word in words)
    {
        Console.Write(word);
        if (!string.IsNullOrWhiteSpace(word))
        {
            await Task.Delay(config.DelayInMilliseconds);
        }
}
    config.SetDone();
}
private static async Task GetInput(TelePrompterConfig config)
{
    Action work = () =>
    {
        do {
            var key = Console.ReadKey(true);
            if (key.KeyChar == '>')
                config.UpdateDelay(-10);
            else if (key.KeyChar == '<')
                config.UpdateDelay(10);
            else if (key.KeyChar == 'X' || key.KeyChar == 'x')
                config.SetDone();
        } while (!config.Done);
};
    await Task.Run(work);
}
   この新しいバージョンの は、 クラスの新しいメソッドを呼び出します。 ここで、 Main を更新して の代わりに を呼び出す必要があります。
ShowTeleprompter
TeleprompterConfig
  ShowTeleprompter
RunTeleprompter
  RunTeleprompter().Wait();
  using static
 
    まとめ
このチュートリアルでは、コンソール アプリケーションでの作業に関連する、C# 言語と .NET Core ライブラリについての多くの機能 を説明しました。 ここでの知識を基にすれば、この言語やここで紹介したクラスについてさらに理解していけるでしょう。 ファイルと コンソール入出力の基本、タスク ベースの非同期プログラミングのブロック使用と非ブロック使用、C# 言語のツアーと C# プログラ ムの構成方法、および .NET Core CLI について説明しました。
ファイル入出力の詳細については、「ファイルおよびストリーム入出力」トピックを参照してください。 このチュートリアルで使用され る非同期プログラミング モデルの詳細については、「タスク ベースの非同期プログラミング」トピックと「非同期プログラミング」トピッ クを参照してください。

        このチュートリアルでは、.NET Core と C# 言語のさまざまな機能を説明します。 内容は以下のとおりです。
.NET Core CLI の基本事項。 C# 言語機能の概要
NuGet での依存関係の管理 HTTP 通信
JSON 情報の処理 属性を使用した構成の管理
GitHub 上の REST サービスに対して HTTP 要求を発行するアプリケーションをビルドします。 JSON 形式で情報を読み取り、 その JSON パケットを C# オブジェクトに変換します。 最後に、C# オブジェクトを操作する方法について説明します。
このチュートリアルには、多くの機能が含まれています。 それらを 1 つずつビルドしてみましょう。 この記事の最終的なサンプルも参照したい方は、ダウンロードできます。 ダウンロード方法については、「サンプルおよびチュート
リアル」を参照してください。 必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。 インストールの手順については、.NET Core のダウンロード ページを参照してください。 このアプリケーションは、Windows、Linux、macOS 上、または Docker コンテ ナーで実行できます。 お好みのコード エディターをインストールしてください。 次の説明では、オープン ソースのクロス プラット フォーム エディターである Visual Studio Code を使用しています。 しかし、他の使い慣れたツールを使用しても構いません。
アプリケーションを作成する
最初に新しいアプリケーションを作成します。 コマンド プロンプトを開き、アプリケーション用の新しいディレクトリを作成します。 そ れを、現在のディレクトリとしてください。 コンソール ウィンドウに次のコマンドを入力します。
これで、基本的な "Hello World" アプリケーションのスターター ファイルが作成されます。 プロジェクト名は "WebAPIClient" で す。 これは新しいプロジェクトであるため、依存関係はありません。 1 回目の実行では、.NET Core フレームワークがダウンロー ドされ、開発証明書がインストールされ、NuGet パッケージ マネージャーが実行されて、不足している依存関係が復元されま す。
変更を開始する前に、"WebAPIClient"ディレクトリに cd で移動し、コマンドプロンプトに「 」(注を参照)と入力 してアプリケーションを実行します。 環境に依存関係がない場合、 では自動的に が実行され ます。 アプリケーションのリビルドが必要な場合にも が実行されます。 初期設定の後は、プロジェクトにとって意 味がある場合にのみ dotnet restore または を実行する必要があります。
新しい依存関係を追加する
.NET Core の重要な設計目標の 1 つは、.NET インストール サイズを最小限に抑えることです。 その一部の機能のための追 加ライブラリがアプリケーションで必要な場合は、C# プロジェクト (*.csproj) ファイルにそれらの依存関係を追加します。 ここで示 す例の場合は、System.Runtime.Serialization.Json パッケージを追加して、アプリケーションがJSON応答を処理できるよう にする必要があります。
  dotnet new console --name WebAPIClient
  dotnet build
dotnet run
dotnet run
  dotnet restore
   dotnet build
 REST クライアント 2021/03/06 • • Edit Online
 
        このアプリケーションには、   パッケージが必要です。 次の .NET CLI コマンドを実行して、 それをご自身のプロジェクトに追加します。
Web 要求を作成する
Web サイトからデータの取得を開始する準備ができました。 このアプリケーションでは、GitHub API から情報を読み取ります。 .NET Foundation にあるプロジェクトに関する情報を読み取ります。 最初に、プロジェクトに関する情報を取得する GitHub API に対する要求を作成します。 使用するエンドポイントは https://api.github.com/orgs/dotnet/repos です。 HTTP GET 要求を使用して、これらのプロジェクトに関する情報をすべて取得します。 HTTP GET 要求はブラウザーでも使用されるので、ブ ラウザーに URL を貼り付けて、取得および処理する情報を確認できます。
HttpClient クラスを使用して Web 要求を作成します。 最新のすべての .NET API と同様に、HttpClient は実行時間の長い API の非同期メソッドだけをサポートします。 最初に非同期メソッドを作成します。 アプリケーションの機能をビルドする際に実 装を記述します。 最初に、プロジェクト ディレクトリ内の program.cs ファイルを開き、 Program クラスに次のメソッドを追加しま す。
Main メソッドの先頭に using ディレクティブを追加して、C#コンパイラにTask型を認識させる必要があります。
この時点でプロジェクトをビルドすると、このメソッドに対して警告が生成されます。これは、 await 演算子がメソッドに含まれて おらず、メソッドが同期的に実行されるためです。 現時点ではこの警告を無視してください。 await 演算子は、メソッドを記述 する際に追加します。
次に、 ProcessRepositories メソッドを呼び出すように Main メソッドを更新します。 ProcessRepositories メソッドはタスク を返します。そのタスクが完了する前にプログラムを終了しないでください。 そのため、 Main のシグネチャを変更する必要があり ます。 async 修飾子を追加し、戻り値の型を Task に変更します。次に、メソッドの本体で、呼び出しを
ProcessRepositories に追加します。そのメソッド呼び出しに await キーワードを追加します。
これで、何も実行せず、非同期的に実行されるプログラムの準備ができました。 これを改善しましょう。
まず、Web からデータを取得できるオブジェクトが必要です。この条件に合うものとして、HttpClient を使用できます。 このオブ ジェクトは要求と応答を処理します。Program.csファイル内の Program クラスで該当する型の単一のインスタンスをインスタ ンス化します。
  dotnet add package System.Text.Json
       private static async Task ProcessRepositories()
{
}
   using System.Threading.Tasks;
        static async Task Main(string[] args)
{
    await ProcessRepositories();
}
   System.Runtime.Serialization.Json
 
       ProcessRepositories メソッドに戻って、最初のバージョンのプログラムを記述します。
    private static async Task ProcessRepositories()
{
    client.DefaultRequestHeaders.Accept.Clear();
    client.DefaultRequestHeaders.Accept.Add(
        new MediaTypeWithQualityHeaderValue("application/vnd.github.v3+json"));
    client.DefaultRequestHeaders.Add("User-Agent", ".NET Foundation Repository Reporter");
    var stringTask = client.GetStringAsync("https://api.github.com/orgs/dotnet/repos");
    var msg = await stringTask;
    Console.Write(msg);
}
 また、ファイルの先頭に2つの新しい using ディレクティブを追加して、プログラムをコンパイルする必要があります。
この最初のバージョンでは、.NET Foundation にあるすべてのリポジトリのリストを読み取る Web 要求を作成します (.NET FoundationのGitHubIDは dotnet です)。最初の数行では、この要求のHttpClientを設定します。最初は、GitHubの JSON 応答を受け入れるように構成されます。 この形式は単なる JSON です。 次の行では、このオブジェクトからのすべての要 求にユーザー エージェント ヘッダーを追加します。 これらの 2 つのヘッダーは、GitHub サーバー コードによってチェックされ、 GitHub から情報を取得するために必要です。
HttpClient を構成したら、Web 要求を作成して応答を取得します。 この最初のバージョンで は、HttpClient.GetStringAsync(String) 簡易メソッドを使います。 この簡易メソッドは、Web 要求を作成するタスクを開始 し、要求が返されると応答ストリームを読み取って、ストリームからコンテンツを抽出します。 応答の本文は String として返され ます。 この文字列は、タスクが完了すると使用できます。
このメソッドの最後の 2 行は、そのタスクを待機し、コンソールに応答を出力します。 アプリケーションをビルドして実行してくださ い。 ProcessRepositories に await 演算子が含まれているため、ビルドの警告が表示されなくなりました。JSON形式の 長いテキストが表示されます。
JSON の結果を処理する
この時点では、Web サーバーからの応答を取得し、その応答に含まれているテキストを表示するコードの記述が完了していま
す。 次に、JSON 応答を C# オブジェクトに変換します。
System.Text.Json.JsonSerializer クラスは、オブジェクトを JSON にシリアル化し、JSON をオブジェクトに逆シリアル化します。 最初にクラスを定義して、GitHubAPIから返される repo JSONオブジェクトを表します。
    using System.Net.Http;
using System.Net.Http.Headers;
      namespace WebAPIClient
{
    class Program
    {
        private static readonly HttpClient client = new HttpClient();
        static async Task Main(string[] args)
        {
//... }
} }
 
       "repo.cs" という新しいファイルに上記のコードを記述します。 このバージョンのクラスは、JSON データを処理する最もシンプルな パスを表します。 クラス名とメンバー名は、C# の規約に従うのではなく、JSON パケットで使用される名前に一致します。 後で いくつかの構成属性を指定して、これを修正します。 このクラスは、JSON のシリアル化と逆シリアル化に関する、もう一つの重 要な特性を示しています:JSON パケット内のすべてのフィールドがこのクラスの一部というわけではありません。 JSON シリアライ ザーは、使用されているクラス型に含まれていない情報を無視します。 この機能により、JSON パケット内のフィールドのサブセッ トのみを操作する型を容易に作成できます。
型の作成が完了したら、逆シリアル化を実行します。 次に、シリアライザーを使用して、JSONをC#オブジェクトに変換します。 ProcessRepositories メソッド内の
GetStringAsync(String) の呼び出しを、次の行に置き換えます。
新しい名前空間を使用しているため、ファイルの先頭にそれを追加する必要もあります。
GetStringAsync(String) ではなく、GetStreamAsync(String) が使用されていることをご確認ください。 シリアライザーは、文字 列の代わりにストリームをソースとして使用します。 前のコード スニペットの 2 行目で使用されている C# 言語のいくつかの機能 について説明します。 JsonSerializer.DeserializeAsync<TValue>(Stream, JsonSerializerOptions, CancellationToken) への最初の引数は await 式です(他の2つのパラメーターは省略可能で、このコードスニペットでは省略されています)。 await 式は、コード内のほとんどの場所に表示される可能性があります (これまでは代入ステートメントの一部としてしか表示さ れていませんでした)。 Deserialize メソッドは"ジェネリック"です。つまり、JSONテキストから作成するオブジェクトの種類に対 して型引数を指定する必要があります。 この例では、汎用オブジェクト System.Collections.Generic.List<T> の 1 つである
に逆シリアル化しています。 List<> クラスには、オブジェクトのコレクションが格納されます。型引数は、 に格納されているオブジェクトの型を宣言します。 JSON テキストは、リポジトリ オブジェクトのコレクションを表している
ため、型引数は Repository です。
このセクションでの作業はほぼ完了です。 JSON を C# オブジェクトに変換したので、次は各リポジトリの名前を表示します。 次
の行があるとします。
この行を次の行に置き換えます。
     var streamTask = client.GetStreamAsync("https://api.github.com/orgs/dotnet/repos");
var repositories = await JsonSerializer.DeserializeAsync<List<Repository>>(await streamTask);
     using System.Collections.Generic;
using System.Text.Json;
    List<Repository>
 List<>
     var msg = await stringTask;   //**Deleted this
Console.Write(msg);
     foreach (var repo in repositories)
    Console.WriteLine(repo.name);
 アプリケーションをコンパイルして実行します。 .NET Foundation に含まれるリポジトリの名前が出力されます。
   using System;
namespace WebAPIClient
{
    public class Repository
    {
        public string name { get; set; }
    }
}
 
  シリアル化を制御する
機能を追加する前に、 [JsonPropertyName] 属性を使用して name プロパティに対処しましょう。 repo.cs の name フィール ドの宣言を次のように変更してください。
[JsonPropertyName] 属性を使用するには、using ディレクティブにSystem.Text.Json.Serialization名前空間を追加する 必要があります。
この変更により、program.cs で各リポジトリの名前を記述するコードを変更する必要があります。
dotnet run を実行して、マッピングが正しいことを確認します。 前と同じ出力が表示されるはずです。
新機能を追加する前に、もう 1 つの変更を行います。 メソッドは非同期作業を行って、リポジトリのコ レクションを返すことができます。そのメソッドから を返して、情報を記述するコードを Main メソッドに移動 します。
結果が Repository オブジェクトのリストであるタスクを返すように ProcessRepositories のシグネチャを変更します。
続いて、JSON 応答の処理後にリポジトリを返します。
このメソッドを async とマークしたので、コンパイラは戻り値として Task<T> オブジェクトを生成します。 次に、 Main メソッドを 変更して、それらの結果をキャプチャし、各リポジトリ名をコンソールに書き込むようにします。 Main メソッドは次のようになりま す。
     [JsonPropertyName("name")]
public string Name { get; set; }
    using System.Text.Json.Serialization;
   Console.WriteLine(repo.Name);
   ProcessRepositories
 List<Repository>
    private static async Task<List<Repository>> ProcessRepositories()
     var streamTask = client.GetStreamAsync("https://api.github.com/orgs/dotnet/repos");
var repositories = await JsonSerializer.DeserializeAsync<List<Repository>>(await streamTask);
return repositories;
      public static async Task Main(string[] args)
{
    var repositories = await ProcessRepositories();
    foreach (var repo in repositories)
        Console.WriteLine(repo.Name);
}
 詳細情報を確認する
最後に、GitHub API から送信される JSON パケット内のいくつかのプロパティを処理します。 すべてのプロパティを追加する必
要はありませんが、いくつかのプロパティを追加することで C# 言語のさらなる機能を示すことができます。 最初に、いくつかの単純型を Repository クラスの定義に追加します。そのクラスに次のプロパティを追加します。
 
    これらのプロパティには、(JSON パケットに格納されている) 文字列型からターゲット型への組み込みの変換があります。 Uri 型 はおそらく初めて使用する型でしょう。これはURI(ここではURL)を表します。 Uri 型と int 型では、ターゲット型に変換し ないデータが JSON パケットに含まれている場合、シリアル化アクションで例外がスローされます。
プロパティの追加が完了したら、それらの要素を表示するように Main メソッドを更新してください。
    foreach (var repo in repositories)
{
    Console.WriteLine(repo.Name);
    Console.WriteLine(repo.Description);
    Console.WriteLine(repo.GitHubHomeUrl);
    Console.WriteLine(repo.Homepage);
    Console.WriteLine(repo.Watchers);
    Console.WriteLine();
}
 最後の手順として、最後のプッシュ操作に関する情報を追加します。 この情報は、JSON 応答では次のように書式設定され ます。
この形式は協定世界時 (UTC) であるため、Kind プロパティが Utc である DateTime 値が得られます。 ご自分のタイム ゾーン で表される日付が必要な場合は、カスタムの変換メソッドを記述する必要があります。 最初に、日付と時刻の UTC 表現を Repository クラスに保持する public プロパティと、ローカル時刻に変換された日付を返す プロパ
ティを定義します。
定義したばかりの新しいコンストラクトについて詳しく見てみましょう。 LastPush プロパティは、"式形式のメンバー"を使用して get アクセサーに対して定義されます。 set アクセサーがない。C#では set アクセサーを省略することで"読み取り専用"
プロパティを定義します (C# では "書き込み専用" プロパティを作成できますが、その値は制限されています)。 最後に、コンソールで出力ステートメントをもう 1 つ追加すれば、このアプリケーションを再度ビルドして実行する準備は完了で
す。
以上で、作成してきたバージョンは最終的なサンプルと同じになるはずです。 まとめ
  2016-02-08T21:27:00Z
    LastPush
 readonly
    [JsonPropertyName("pushed_at")]
public DateTime LastPushUtc { get; set; }
public DateTime LastPush => LastPushUtc.ToLocalTime();
    Console.WriteLine(repo.LastPush);
    [JsonPropertyName("description")]
public string Description { get; set; }
[JsonPropertyName("html_url")]
public Uri GitHubHomeUrl { get; set; }
[JsonPropertyName("homepage")]
public Uri Homepage { get; set; }
[JsonPropertyName("watchers")]
public int Watchers { get; set; }
 
    このチュートリアルでは、Web 要求を作成する方法、結果を解析する方法、およびそれらの結果のプロパティを表示する方法を 紹介しました。 また、依存関係として新しいパッケージをプロジェクトに追加しました。 さらに、オブジェクト指向の手法をサポー トする C# 言語の一部の機能について確認しました。
を実行する必要がなくなりました。復元を必要とするすべてのコマンド ( dotnet new 、 dotnet build 、
、 、 、 dotnet pack など) によって暗黙的に実行されるためです。 暗黙的な復
元を無効にするには、 オプションを使用します。
Azure DevOps Services の継続的インテグレーション ビルドなどの、明示的な復元が意味のある一部のシナリオや、復元が
行われるタイミングを明示的に制御する必要があるビルド システムでは、 dotnet restore は引き続き有用なコマンドです。 NuGetフィードの管理方法については、 dotnet restore のドキュメントをご覧ください。
   dotnet restore
    dotnet run
dotnet test
dotnet publish
 --no-restore
  
              このチュートリアルでは、C# での継承について説明します。 継承は、オブジェクト指向プログラミング言語の一機能であり、特定 の機能 (データおよび動作) を提供する基底クラスを定義し、その機能を継承またはオーバーライドする派生クラスを定義するこ とができます。
必須コンポーネント
このチュートリアルでは、.NET Core SDK がインストールされていることを前提としています。 ダウンロードするには、.NET Core ダ ウンロード ページにアクセスしてください。 コード エディターも必要です。 このチュートリアルでは Visual Studio Code を使用して いますが、任意のコード エディターを使用して構いません。
例の実行
このチュートリアル内の例を作成して実行するには、コマンド ラインの dotnet ユーティリティを使用します。 それぞれの例につい て、次の手順に従います。
1. 例を格納するディレクトリを作成します。
2. コマンド プロンプトで dotnet new コンソール コマンドを入力し、新しい .NET Core プロジェクトを作成します。
3. 例にあるコードをコピーして、コード エディターに貼り付けます。
4. コマンド ラインから dotnet restore コマンドを入力し、プロジェクトの依存関係を読み込みまたは復元します。
を実行する必要がなくなりました。復元を必要とするすべてのコマンド ( dotnet new 、
、 、 dotnet test 、 、 dotnet pack など) によって暗黙的に実行される
ためです。 暗黙的な復元を無効にするには、 オプションを使用します。
Azure DevOps Services の継続的インテグレーション ビルドなどの、明示的な復元が意味のある一部のシナリオや、 復元が行われるタイミングを明示的に制御する必要があるビルド システムでは、 dotnet restore は引き続き有用なコ マンドです。
NuGetフィードの管理方法については、 dotnet restore のドキュメントをご覧ください。
5. dotnet run コマンドを入力して、例をコンパイルし実行します。
背景: 継承とは何か
継承とは、オブジェクト指向プログラミングの基本的な属性の 1 つです。 親クラスの動作を再利用 (継承)、拡張、または変更 する子クラスを定義することができます。 メンバーの継承元となるクラスを、基底クラスと呼びます。 基底クラスのメンバーを継承 するクラスを、派生クラスと呼びます。
C# と .NET は単一継承のみをサポートしています。 つまり、1 つのクラスは、1 つのクラスからしか継承できないことになります。 ただし継承は推移的であり、一連の型の継承階層を定義することができます。 たとえば、 D 型は C 型から継承でき、この
C 型は B 型から継承され、この B 型は基底クラスである A 型から継承されます。 継承が推移的であるため、 A 型のメ ンバーは D 型で使用できます。
基底クラスのすべてのメンバーが、派生クラスによって継承されるわけではありません。 以下のメンバーは継承されません。 静的コンスラクター。クラスの静的データを初期化するもの。
インスタンス コンストラクター。クラスの新しいインスタンスを作成するために呼び出すもの。 各クラスはそれ自身のコンスト
  dotnet restore
     dotnet build
dotnet run
dotnet publish
 --no-restore
  C# と .NET での継承 2020/11/02 • • Edit Online
 
     ラクターを定義する必要があります。
ファイナライザー。ランタイムのガベージ コレクターによって呼び出され、クラスのインスタンスを破棄するもの。 他のすべての基底クラスのメンバーは派生クラスに継承されますが、それらが表示されるどうかはアクセシビリティに依存します。
メンバーのアクセシビリティは、次のとおり、派生したクラスの可視性に影響します。
プライベート メンバーは、基底クラスで入れ子になっている派生クラスでのみ表示されます。 それ以外の場合、派生クラ スでは表示されません。 次の例では、 A.B は A から派生した入れ子になったクラスで、 C は A から派生していま す。 プライベートの A.value フィールドは A.B で表示されます。 しかし、 C.GetValue メソッドからコメントを削除して例 をコンパイルしようとすると、コンパイラ エラー CS0122 "'A.value' is inaccessible due to its protection level." ('A.value' はアクセスできない保護レベルになっています") が生成されます。
      using System;
public class A
{
   private int value = 10;
   public class B : A
   {
       public int GetValue()
       {
           return this.value;
       }
} }
public class C : A
{
//    public int GetValue()
//    {
//        return this.value;
//    }
}
public class Example
{
    public static void Main(string[] args)
    {
        var b = new A.B();
        Console.WriteLine(b.GetValue());
    }
}
// The example displays the following output:
//       10
 プロテクト メンバーは派生クラスでのみ表示されます。 内部メンバーは、基底クラスと同じアセンブリ内にある派生クラスでのみ表示されます。 基底クラスとは別のアセンブリに
ある派生クラスでは、表示されません。
パブリック メンバーは派生クラスで表示され、派生クラスのパブリック インターフェイスの一部です。 パブリックの継承された メンバーは、派生クラスで定義された場合と同様に呼び出すことができます。 次の例では、クラス A が Method1 とい う名前のメソッドを定義し、クラス B がクラス A から継承します。 そこでこの例は、 Method1 を B 上のインスタンス メソッドであるかのように呼び出します。
  
   派生クラスはまた、代替実装を行うことにより、継承されたメンバーをオーバーライドすることができます。 メンバーをオーバーライ ドするためには、基底クラスのメンバーは virtual のキーワードでマークされている必要があります。 既定では基底クラスのメン バーは virtual としてマークされていないので、オーバーライドすることはできません。次の例のように、非仮想メンバーをオー バーライドしようとすると、コンパイラ エラー CS0506 "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override." ("継承されたメンバー member が virtual、abstract、または override でマークされていないため、member でオーバーライドすることができません") が生成されます。
     public class A
{
    public void Method1()
    {
        // Do something.
    }
}
public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
 場合によっては、派生クラスは基底クラスの実装をオーバーライドする必要があります。 abstract キーワードでマークされた基底 クラスのメンバーは、派生クラスによってオーバーライドされる必要があります。 次の例をコンパイルしようとすると、コンパイラ エ ラーCS0534(「<クラス>は継承抽象メンバー<メンバー>を実装しません。」)が生成されます。これは、クラス B が
A.Method1 の実装を提供していないためです。
     public class A
{
    public void Method1()
    {
        // Method implementation.
    }
}
public class B : A {}
public class Example
{
    public static void Main()
    {
B b = new B();
        b.Method1();
    }
}
    public abstract class A
{
    public abstract void Method1();
}
public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
 
 継承は、クラスとインターフェイスにのみ適用されます。 その他の種類のカテゴリ (構造体、デリゲート、および列挙型) は、継承 をサポートしていません。 これらのルールのため、次の例のようなコードをコンパイルしようとすると、コンパイラ エラー CS0527 "イ ンターフェイス リストの型 'ValueType' はインターフェイスではありません。" が生成されます。 このエラー メッセージは、構造体が 実装するインターフェイスを定義することはできても、継承はサポートされないことを示します。
暗黙的な継承
.NET 型システムの型はすべて、単一継承によって継承する型のほかに、Object またはその派生型から暗黙的に継承します。
Object の共通の機能はあらゆる型で使用できます。
暗黙的な継承とはどのようなものか、新しいクラス SimpleClass を定義してみましょう。単純な空のクラス定義です。
次に、リフレクション(型のメタデータを検査して、その型の情報を取得できるもの)を使用して、SimpleClass 型に属するメン バーの一覧を取得します。 SimpleClass クラスにはメンバーをまだ定義していないにもかかわらず、この例の出力は、9つのメ ンバーが存在することを示しています。 これらのメンバーのうちの 1 つは、パラメーターなし (既定) のコンストラクターで、C# コン パイラによって SimpleClass 型に自動的に提供されるものです。あとの8つはObjectのメンバーで、この型から、.NET型シ ステムのすべてのクラスとインターフェイスが最終的に暗黙的に継承します。
    using System;
public struct ValueStructure : ValueType // Generates CS0527.
{
}
      public class SimpleClass {}
    
     Objectクラスからの暗黙的な継承により、 SimpleClass クラスで以下のメソッドが使用可能になります。
パブリック メソッド。 SimpleClass オブジェクトを文字列表記に変換し、完全修飾型名を返します。 ここ
で、 メソッドは文字列 "SimpleClass" を返します。
2 つのオブジェクトが等しいかどうか調べる 3 つのメソッド: パブリック インスタンス メソッド、パブリック静 的 Equals(Object, Object) メソッド、およびパブリック静的 メソッド。 既定によ り、これらのメソッドは参照の等価性を調べます。つまり、等価であるためには、2 つのオブジェクトの変数が同じオブジェ クトを参照している必要があります。
パブリック GetHashCode メソッド。型インスタンスのハッシュされたコレクションでの使用を許可する値を計算します。 パブリック GetType メソッド。 SimpleClass 型を表す Type オブジェクトを返します。
  ToString
ToString
  Equals(Object)
  ReferenceEquals(Object, Object)
     using System;
using System.Reflection;
public class Example
{
    public static void Main()
    {
        Type t = typeof(SimpleClass);
        BindingFlags flags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public |
                             BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;
        MemberInfo[] members = t.GetMembers(flags);
        Console.WriteLine($"Type {t.Name} has {members.Length} members: ");
        foreach (var member in members)
        {
            string access = "";
            string stat = "";
            var method = member as MethodBase;
            if (method != null)
            {
                if (method.IsPublic)
                    access = " Public";
                else if (method.IsPrivate)
                    access = " Private";
                else if (method.IsFamily)
                    access = " Protected";
                else if (method.IsAssembly)
                    access = " Internal";
                else if (method.IsFamilyOrAssembly)
                    access = " Protected Internal ";
                if (method.IsStatic)
                    stat = " Static";
}
            var output = $"{member.Name} ({member.MemberType}): {access}{stat}, Declared by
{member.DeclaringType}";
            Console.WriteLine(output);
        }
} }
// The example displays the following output:
// Type SimpleClass has 9 members:
// ToString (Method):  Public, Declared by System.Object
// Equals (Method):  Public, Declared by System.Object
// Equals (Method):  Public Static, Declared by System.Object
// ReferenceEquals (Method):  Public Static, Declared by System.Object
// GetHashCode (Method):  Public, Declared by System.Object
// GetType (Method):  Public, Declared by System.Object
// Finalize (Method):  Internal, Declared by System.Object
// MemberwiseClone (Method):  Internal, Declared by System.Object
// .ctor (Constructor):  Public, Declared by SimpleClass

        保護された Finalize メソッド。オブジェクトのメモリがガベージ コレクターによって回収される前にアンマネージ リソースを解 放するように設計されています。
保護された MemberwiseClone メソッド。現在のオブジェクトの浅い複製を作成します。
暗黙的な継承によって、 SimpleClass オブジェクトから任意の継承されたメンバーを、 クラスで定義されたメン バーであるかのように呼び出すことができます。 たとえば、次の例では メソッドを呼び出しますが、これ は SimpleClass がObjectから継承しています。
  SimpleClass
 SimpleClass.ToString
     using System;
public class SimpleClass
{}
public class Example
{
    public static void Main()
    {
        SimpleClass sc = new SimpleClass();
        Console.WriteLine(sc.ToString());
    }
}
// The example displays the following output:
//        SimpleClass
 次の表は、C# で作成できる型のカテゴリと、暗黙的に継承する元となる型の一覧です。 各々の基本型によって、暗黙的な派 生型への継承を通して、異なるメンバーのセットが利用可能となります。
    class struct enum delegate
継承と "is a" 関係
Object
ValueType, Object
Enum, ValueType, Object MulticastDelegate, Delegate, Object
              継承は通常、基底クラスと 1 つまたは複数の派生クラスとの "is a" 関係を表現するのに使用します。ここで、派生クラスは基 底クラスの特殊化されたバージョン、つまり基底クラスの1つの型です。たとえば、Publication クラスはあらゆる種類の出版 物を表しますが、 Book クラスおよび Magazine クラスは特定の種類の出版物を表します。
なお、"isa"関係は、型とその型の特定のインスタンス化の間の関係も表します。次の例では、Automobile は一意の読み取 り専用プロパティを 3 つ持つクラスです。自動車の製造メーカーである Make 、車種である Model 、そして製造年である
Year の3つです。この Automobile クラスはまた、プロパティ値に割り当てられている引数があるコンストラクターを持 ち、Object.ToStringメソッドをオーバーライドして、 Automobile クラスではなく Automobile インスタンスを一意に識別する文
      NOTE
1 つのクラスまたは構造体は、1 つまたは複数のインターフェイスを実装できます。 インターフェイスの実装は、単一継承の回避策として、また は構造体とともに継承を使用する方法として提示されることが多いですが、継承というよりは、インターフェイスとその実装型の間の別の関係 ("can do" 関係) を表すものとして意図されています。 インターフェイスは、その実装型で使用可能とする機能 (等価性を調べる機能、オブ ジェクトを比較または並べ替える機能、カルチャに依存した解析および書式設定のサポート機能など) のサブセットを定義します。
     
 字列を生成します。
    using System;
public class Automobile
{
    public Automobile(string make, string model, int year)
    {
        if (make == null)
           throw new ArgumentNullException("The make cannot be null.");
        else if (String.IsNullOrWhiteSpace(make))
           throw new ArgumentException("make cannot be an empty string or have space characters only.");
Make = make;
        if (model == null)
           throw new ArgumentNullException("The model cannot be null.");
        else if (String.IsNullOrWhiteSpace(model))
           throw new ArgumentException("model cannot be an empty string or have space characters only.");
        Model = model;
        if (year < 1857 || year > DateTime.Now.Year + 2)
           throw new ArgumentException("The year is out of range.");
Year = year; }
    public string Make { get; }
    public string Model { get; }
    public int Year { get; }
    public override string ToString() => $"{Year} {Make} {Model}";
}
 この場合、特定の自動車メーカーと車種を表すために継承に依存すべきではありません。 たとえば、Packard Motor Car 社に よって製造された自動車を表すのに、 Packard という型を定義する必要はありません。 代わりに、次の例のように、
Automobile オブジェクトを作成して、そのクラスコンストラクターに適切な値を渡すことによって同社の自動車を表すことができ ます。
      using System;
public class Example
{
    public static void Main()
    {
        var packard = new Automobile("Packard", "Custom Eight", 1948);
        Console.WriteLine(packard);
    }
}
// The example displays the following output:
//        1948 Packard Custom Eight
 継承に基づいた is-a 関係の適用が最も適しているのは、基底クラスと、基底クラスにメンバーを追加する派生クラス、または基 底クラスにない追加機能が必要な派生クラスです。
基底クラスと派生クラスの設計
基底クラスとその派生クラスを設計するプロセスについて説明します。 このセクションでは、基底クラス す。書籍、雑誌、新聞、ジャーナル、記事などの任意の種類の出版物を表します。さらに クラスも定義します。 この例を拡張して、簡単に Magazine 、 Journal 、 Newspaper 、および スを定義することができます。
を定義しま から派生する Book などの他の派生クラ
 Publication
Publication
     Article

      基底 Publication クラス
Publication クラスを設計するにあたり、次のように、設計についていくつか決定する必要があります。
どのメンバーを基底クラス Publication に含めるか、 Publication メンバーがメソッドの実装を提供するかどうか、 Publication をその派生クラスのテンプレートとなる抽象基底クラスとするかどうか。
ここで、 Publication クラスはメソッドの実装を提供します。 「抽象基底クラスとその派生クラスの設計」セクションには、 抽象基底クラスを使用して、派生クラスがオーバーライドする必要があるメソッドを定義する例が含まれています。 派生 クラスは、その派生型に適した任意の実装を提供することができます。
コードを再利用する機能 (つまり、複数の派生クラスが基底クラスのメソッドの宣言と実装を共有し、それらをオーバーラ イドする必要がないこと) は、非抽象基底クラスの利点です。 そこで、コードが 型の複数または非常に 特殊化されたものによって共有される可能性が高い場合は、メンバーを に追加します。 基底クラスの実 装を効率的に提供できていないと、基底クラスでの単一の実装で済むところを、派生クラスでほぼ同一のメンバーの実 装を行わなければいけないことになります。 複数の箇所で重複するコードを保守する必要が生じ、バグを引き起こす元 となりえます。
コードの再利用を最大化し、同時に論理的で直感的な継承階層を作成するために、 Publication クラスには必ず、 すべてもしくはほとんどの出版物に共通したデータと機能のみを含めるようにします。 そして派生クラスは、それ自身が表 す特定の種類の出版物に固有のメンバーを実装します。
クラス階層をどの程度まで拡張すべきか。 1 つの基底クラスと 1 つまたは複数の派生クラスではなく、3 つ以上のクラス 階層を作るかどうか。たとえば、 は Periodical の基底クラスになり得ますが、このPeriodicalは
Magazine 、 Journal 、および の基底クラスです。
この例では、 クラスと1つの派生クラス Book という小さな階層を使用します。この例を簡単に拡張し
て、 や など、 Publication から派生する多くの追加のクラスを作成できます。
基底クラスのインスタンス化に意味があるのか。 意味がなければ、そのクラスには abstract キーワードを適用します。 そ れ以外の場合、 Publication クラスはそのクラス コンストラクターを呼び出すことによってインスタンス化することができま す。 キーワードでマークされたクラスを、そのクラス コンストラクターへの直接呼び出しによってインスタンス化し ようとすると、C# コンパイラはエラー CS0144 "Cannot create an instance of the abstract class or interface." ("抽 象クラスまたはインターフェイスのインスタンスを作成できません") を生成します。 リフレクションを使用してクラスをインスタ ンス化しようとすると、そのリフレクション メソッドは MemberAccessException をスローします。
既定では、基底クラスはそのクラス コンストラクターを呼び出すことによってインスタンス化することができます。 クラス コン ストラクターを明示的に定義する必要はありません。 基底クラスのソース コード内に存在しない場合、C# コンパイラは 自動的に既定の (パラメーターなしの) コンストラクターを提供します。
この例では、 クラスをabstractとしてマークして、インスタンス化できないようにします。 abstract メソッド なしの クラスは、このクラスが、いくつかの具象クラス ( Book 、 Journal など) で共有される抽象概念を表 すことを示します。
派生クラスで、特定のメンバーの基底クラス実装を継承する必要があるかどうか、基底クラス実装をオーバーライドする オプションがあるかどうか、または実装を提供する必要があるかどうか。 abstract キーワードを使用して、派生クラスで実 装を提供するように強制します。 virtual キーワードを使用して、派生クラスによる基底クラス メソッドのオーバーライドを 許可します。 既定では、基底クラスで定義されているメソッドはオーバーライドできません。
Publication クラスには abstract メソッドはありませんが、クラス自体が abstract になります。
派生クラスが継承階層内の最後のクラスを表していて、それ自体が追加の派生クラスの基底クラスとして使用できない かどうか。 既定では、どのクラスも基底クラスとして使用できます。 sealed キーワードを適用すると、クラスが追加クラス の基底クラスとして使用できないことを示すことができます。 sealed クラスからの派生を試みると、コンパイラ エラー CS0509 "cannot derive from sealed type <typeName>" ("シール型 typeName から派生することができません") が生成されます。
        Publication
Publication
 Publication
    Newspaper
 Publication
   Magazine
Article
  abstract
   abstract
Publication
    この例では、派生クラスを   としてマークします。
 sealed
 
     次の例では、   のソース コードを、 プロパティに返される   列挙 型とともに示します。 Object から継承したメンバーに加え、   クラスは次の一意のメンバーおよびメンバー オーバー ライドを定義します。
Publication
Publication.PublicationType
PublicationType
    Publication
     using System;
public enum PublicationType { Misc, Book, Magazine, Article };
public abstract class Publication
{
   private bool published = false;
   private DateTime datePublished;
   private int totalPages;
   public Publication(string title, string publisher, PublicationType type)
   {
      if (String.IsNullOrWhiteSpace(publisher))
         throw new ArgumentException("The publisher is required.");
      Publisher = publisher;
      if (String.IsNullOrWhiteSpace(title))
         throw new ArgumentException("The title is required.");
      Title = title;
Type = type; }
   public string Publisher { get; }
   public string Title { get; }
   public PublicationType Type { get; }
   public string CopyrightName { get; private set; }
   public int CopyrightDate { get; private set; }
   public int Pages
   {
     get { return totalPages; }
     set
     {
         if (value <= 0)
            throw new ArgumentOutOfRangeException("The number of pages cannot be zero or negative.");
         totalPages = value;
     }
}
   public string GetPublicationDate()
   {
      if (!published)
         return "NYP";
      else
         return datePublished.ToString("d");
}
   public void Publish(DateTime datePublished)
   {
      published = true;
      this.datePublished = datePublished;
   }
   public void Copyright(string copyrightName, int copyrightDate)
   {
      if (String.IsNullOrWhiteSpace(copyrightName))
         throw new ArgumentException("The name of the copyright holder is required.");
      CopyrightName = copyrightName;

    コンストラクター
Publication クラスは abstract なので、次の例のようなコードから直接インスタンス化することはできません。
ただし、Book クラスのソースコードが示すように、インスタンスコンストラクターは派生クラスのコンストラクターから直接 呼び出すことができます。
出版物に関する 2 つのプロパティ
Title は読み取り専用のStringプロパティで、Publication コンストラクターを呼び出すことでその値が提供されま
す。
Pages は読み取り/書き込みのInt32プロパティで、出版物の総ページ数を示します。その値は totalPages というプ ライベート フィールドに格納されています。 正の数である必要があり、そうでなければ ArgumentOutOfRangeException がスローされます。
出版社に関するメンバー
2 つの読み取り専用プロパティ Publisher と Type 。 これらの値はもともと Publication クラスのコンストラクターへの 呼び出しによって提供されるものです。
出版に関するメンバー
Publish および という2つのメソッドは、発行日を設定して返すものです。 Publish メソッド
      var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                  PublicationType.Book);
        GetPublicationDate
 は、呼び出されるとプライベートの datePublished フィールドに割り当てます。
文字列"NYP"を返し、true の場合に 著作権に関するメンバー
フラグを true に設定し、渡された日付を引数としてプライベート メソッドは、 published フラグが false の場合に
フィールドの値を返します。
published
   GetPublicationDate
 datePublished
  メソッドは、著作権者の名前および著作権年を引数として受け取り、 CopyrightName および プロパティに割り当てます。
ToString メソッドのオーバーライド
ある型が Object.ToString メソッドをオーバーライドしない場合、その型の完全修飾名を返しますが、これはインスタンス の区別にはほとんど役に立ちません。 Publication クラスはObject.ToStringをオーバーライドして、Title プロパ ティの値を返します。
次の図は、基底の Publication クラスとその暗黙的に継承されたObjectクラスの関係を表しています。
Copyright
 CopyrightDate
            int currentYear = DateTime.Now.Year;
      if (copyrightDate < currentYear - 10 || copyrightDate > currentYear + 2)
         throw new ArgumentOutOfRangeException($"The copyright year must be between {currentYear - 10} and
{currentYear + 1}");
      CopyrightDate = copyrightDate;
   }
   public override string ToString() => Title;
}
 
  Book クラス
Book クラスは、特定の種類の出版物としての本を表します。 次の例は、 Book クラスのソース コードを示しています。

   using System;
public sealed class Book : Publication
{
   public Book(string title, string author, string publisher) :
          this(title, String.Empty, author, publisher)
{}
   public Book(string title, string isbn, string author, string publisher) : base(title, publisher,
PublicationType.Book)
   {
      // isbn argument must be a 10- or 13-character numeric string without "-" characters.
      // We could also determine whether the ISBN is valid by comparing its checksum digit
      // with a computed checksum.
      //
      if (! String.IsNullOrEmpty(isbn)) {
        // Determine if ISBN length is correct.
        if (! (isbn.Length == 10 | isbn.Length == 13))
            throw new ArgumentException("The ISBN must be a 10- or 13-character numeric string.");
        ulong nISBN = 0;
        if (! UInt64.TryParse(isbn, out nISBN))
            throw new ArgumentException("The ISBN can consist of numeric characters only.");
}
ISBN = isbn;
      Author = author;
   }
   public string ISBN { get; }
   public string Author { get; }
   public Decimal Price { get; private set; }
   // A three-digit ISO currency symbol.
   public string Currency { get; private set; }
   // Returns the old price, and sets a new price.
   public Decimal SetPrice(Decimal price, string currency)
   {
       if (price < 0)
          throw new ArgumentOutOfRangeException("The price cannot be negative.");
       Decimal oldValue = Price;
       Price = price;
       if (currency.Length != 3)
          throw new ArgumentException("The ISO currency symbol is a 3-character string.");
       Currency = currency;
       return oldValue;
   }
   public override bool Equals(object obj)
   {
      Book book = obj as Book;
      if (book == null)
         return false;
      else
         return ISBN == book.ISBN;
}
   public override int GetHashCode() => ISBN.GetHashCode();
   public override string ToString() => $"{(String.IsNullOrEmpty(Author) ? "" : Author + ", ")}{Title}";
}
   
          から継承したメンバーに加え、 Book クラスは次の一意のメンバーおよびメンバー オーバーライドを定義します。 2 つのコンストラクター
2つの Book コンストラクターは、共通パラメーターを3つ共有しています。タイトルおよび出版社の2つは、 Publication コンストラクターのパラメーターに対応します。3つ目は著者で、パブリックの変更不可の Author プロパ ティに格納されています。1つのコンストラクターにはisbnパラメーターが1つ含まれていて、ISBN 自動プロパティに格
納されています。
最初のコンストラクターはこのキーワードを使用して、他のコンストラクターを呼び出します。 コンストラクター チェーンは、 コンストラクターを定義する上で一般的なパターンです。 パラメーターが最も多いコンストラクターを呼び出すときに、パラ メーターのより少ないコンストラクターが既定値を提供するものです。
2 番目のコンストラクターは base キーワードを使用して、基底クラスのコンストラクターにタイトルと出版社名を渡しま す。 ソース コードで基底クラスのコンストラクターを明示的に呼び出さない場合、C# コンパイラは、基底クラスの既定ま たはパラメーターなしのコンストラクターへの呼び出しを自動的に提供します。
読み取り専用の ISBN プロパティ。Book オブジェクトのISBN(一意の10~13桁の数字)を返します。ISBNは Book コンストラクターの1つに引数として提供されます。ISBNは、コンパイラで自動生成されるプライベートバッキン
グ フィールドに格納されます。
読み取り専用の Author プロパティ。著者名は両方の Book コンストラクターに引数として提供され、プロパティに格 納されます。
価格に関する、2 つの読み取り専用の Price と Currency のプロパティ。 これらの値は、 SetPrice メソッド呼び出し で引数として提供されます。 Currency プロパティは3桁のISO通貨記号(たとえば米ドルの場合はUSD)です。 ISO 通貨記号は ISOCurrencySymbol プロパティから取得できます。 これらのプロパティは両方とも外部では読み取り 専用ですが、 Book クラスのコードによって設定できます。
SetPrice メソッド。 Price プロパティおよび Currency プロパティの値を設定します。 これらの値は、それぞれ同じプ ロパティによって返されます。
ToString メソッド(Publication から継承)へのオーバーライドと、Object.Equals(Object)メソッドおよび GetHashCode メソッド (Object から継承) へのオーバーライド。
オーバーライドされない限り、Object.Equals(Object) メソッドは参照の等価性を調べます。 つまり、2 つのオブジェクト 変数は同じオブジェクトを参照している場合に等価であると見なされます。 一方、 Book クラスでは、2 つの Book オブ ジェクトは同じ ISBN を持つ場合に等価であるはずです。
Object.Equals(Object) メソッドをオーバーライドする場合、GetHashCode メソッドもオーバーライドする必要がありま す。このメソッドは、ランタイムで項目をハッシュされたコレクションに格納し効率的に取得するために使用する値を返す ものです。 ハッシュ コードは、等価性のテストと一致する値を返します。 Object.Equals(Object) をオーバーライドして、 2つの Book オブジェクトのISBNプロパティが等しい場合に true を返すようにしたので、ISBN プロパティによって返 される文字列の GetHashCode メソッドを呼び出すことにより計算されるハッシュ コードを返します。
次の図は、 Book クラスとその基底クラスである Publication の関係を表しています。
            Publication
 
 これで、次の例に示すように、 Book オブジェクトをインスタンス化して、その一意のメンバーと継承されたメンバーの両方を呼び 出し、 Publication 型または Book 型のパラメーターを必要とするメソッドに引数として渡すことができるようになりました。
 
     抽象基底クラスとその派生クラスの設計
前述の例では、多くのメソッドの実装を提供する基底クラスを定義し、派生クラスがコードを共有できるようにしました。 しかし 多くの場合、基底クラスが実装を提供する必要はありません。 むしろ基底クラスは、抽象メソッド を宣言する抽象クラス であ り、各派生クラスで実装する必要があるメンバーを定義するテンプレートとして機能します。 通常、抽象基底クラスでは、派生 型の実装はそれぞれその型に固有のものです。 クラスでは出版物に共通の機能の実装が提供されましたが、 Publication オ ブジェクトをインスタンス化しても意味はないので、クラスは abstract キーワードでマークしました。
たとえば、2 次元の閉じた幾何学図形には、2 つのプロパティが含まれます。図形の内部の大きさである面積と、図形の辺に 沿った長さである周です。 一方で、これらのプロパティの計算方法は、それぞれの図形によって違います。 たとえば、円周の計 算式は、三角形の周の計算式とは異なります。 Shape クラスは、 abstract メソッドがある abstract クラスです。 これは、 派生クラスで同じ機能が共有されるものの、それらの派生クラスではその機能が異なる方法で実装されることを示します。
次の例では、 Area と Perimeter という 2 つのプロパティを定義する、 Shape という名前の抽象基底クラスを定義します。 ク ラスを abstract キーワードでマークするだけでなく、インスタンス メンバーもそれぞれ abstract キーワードでマークされます。 ここで
Shape はObject.ToStringメソッドもオーバーライドして、完全修飾名ではなく、その型の名前を返します。そして GetArea と GetPerimeter の2つの静的メンバーを定義し、呼び出し元で任意の派生クラスのインスタンスの面積と周を簡単に取得で きるようにします。 これらのメソッドのいずれかに派生クラスのインスタンスを渡すとき、ランタイムは派生クラスのメソッド オーバーラ イドを呼び出します。
         using System;
using static System.Console;
public class Example
{
   public static void Main()
   {
      var book = new Book("The Tempest",  "0971655819", "Shakespeare, William",
                          "Public Domain Press");
      ShowPublicationInfo(book);
      book.Publish(new DateTime(2016, 8, 18));
      ShowPublicationInfo(book);
      var book2 = new Book("The Tempest", "Classic Works Press", "Shakespeare, William");
      Write($"{book.Title} and {book2.Title} are the same publication: " +
            $"{((Publication) book).Equals(book2)}");
}
   public static void ShowPublicationInfo(Publication pub)
   {
       string pubDate = pub.GetPublicationDate();
       WriteLine($"{pub.Title}, " +
                 $"{(pubDate == "NYP" ? "Not Yet Published" : "published on " + pubDate):d} by
{pub.Publisher}");
} }
// The example displays the following output:
//        The Tempest, Not Yet Published by Public Domain Press
//        The Tempest, published on 8/18/2016 by Public Domain Press
//        The Tempest and The Tempest are the same publication: False
 
    ここで特定の図形を表す Shape から、いくつかのクラスを派生させることができます。 次の例では、 Triangle 、 Rectangle 、 および Circle の3つのクラスを定義します。これらのクラスはそれぞれ、その図形に一意の数式を使用して面積と周を計算 します。 一部の派生クラスも、 Rectangle.Diagonal や Circle.Diameter など、その図形に固有のプロパティを定義します。
      using System;
public abstract class Shape
{
   public abstract double Area { get; }
   public abstract double Perimeter { get; }
   public override string ToString() => GetType().Name;
   public static double GetArea(Shape shape) => shape.Area;
   public static double GetPerimeter(Shape shape) => shape.Perimeter;
}
 
    次の例では、 Shape から派生したオブジェクトを使用しています。 ここでは Shape から派生したオブジェクトの配列をインスタ ンス化して、 Shape クラスの静的メソッドを呼び出します。これにより、返された Shape のプロパティ値がラップされます。 ランタ イムは、派生型のオーバーライドされたプロパティから値を取得します。この例ではまた、配列内の Shape オブジェクトをそれぞ れの派生型にキャストし、キャストが成功すると、その特定の Shape サブクラスのプロパティを取得します。
  using System;
public class Square : Shape
{
   public Square(double length)
   {
      Side = length;
   }
   public double Side { get; }
   public override double Area => Math.Pow(Side, 2);
   public override double Perimeter => Side * 4;
   public double Diagonal => Math.Round(Math.Sqrt(2) * Side, 2);
}
public class Rectangle : Shape
{
   public Rectangle(double length, double width)
   {
      Length = length;
      Width = width;
   }
   public double Length { get; }
   public double Width { get; }
   public override double Area => Length * Width;
   public override double Perimeter => 2 * Length + 2 * Width;
   public bool IsSquare() => Length == Width;
   public double Diagonal => Math.Round(Math.Sqrt(Math.Pow(Length, 2) + Math.Pow(Width, 2)), 2);
}
public class Circle : Shape
{
   public Circle(double radius)
   {
      Radius = radius;
   }
   public override double Area => Math.Round(Math.PI * Math.Pow(Radius, 2), 2);
   public override double Perimeter => Math.Round(Math.PI * 2 * Radius, 2);
   // Define a circumference, since it's the more familiar term.
   public double Circumference => Perimeter;
   public double Radius { get; }
   public double Diameter => Radius * 2;
}

   関連項目
継承 (C# プログラミング ガイド)
   using System;
public class Example
{
   public static void Main()
   {
      Shape[] shapes = { new Rectangle(10, 12), new Square(5),
                        new Circle(3) };
      foreach (var shape in shapes) {
         Console.WriteLine($"{shape}: area, {Shape.GetArea(shape)}; " +
                           $"perimeter, {Shape.GetPerimeter(shape)}");
         var rect = shape as Rectangle;
      if (rect != null) {
         Console.WriteLine($"
         continue;
      }
      var sq = shape as Square;
      if (sq != null) {
         Console.WriteLine($"
continue; }
} }
Is Square: {rect.IsSquare()}, Diagonal: {rect.Diagonal}");
Diagonal: {sq.Diagonal}");
}
// The example displays the following output:
// // // // //
Rectangle: area, 120; perimeter, 44
   Is Square: False, Diagonal: 15.62
Square: area, 25; perimeter, 20
   Diagonal: 7.07
Circle: area, 28.27; perimeter, 18.85
 
         はじめに
このチュートリアルでは、.NET Core と C# 言語の機能を説明します。 以下の方法について説明します。
LINQ を使用してシーケンスを生成する。
LINQ クエリで簡単に使用できるメソッドを記述する。 先行評価と遅延評価を区別する。
これらの方法を、マジシャンの基本的スキルの 1 つであるファロ― シャッフルを再現するアプリケーションを作成しながら学習して いきます。 ファロ― シャッフルとは、簡単に言うと、カード デッキを正確に 2 等分し、双方のデッキから 1 枚ずつ交互に並ぶよう にシャッフルして、元のデッキを並べ替えることです。
マジシャンがこの手法を使用するのは、シャッフルした後もそれぞれのカードの位置がわかり、カードの順序が繰り返しのパターン になるからです。
ここでは、データ シーケンスの操作として気軽に見ていきましょう。 これから作成するアプリケーションでは、カード デッキを構築 し、シャッフルのシーケンスを実行し、その都度シーケンスを書き込みます。 また、更新された順序を元の順序と比較します。
このチュートリアルには、複数の手順があります。 各手順の後に、アプリケーションを実行して進行状況を確認できます。 GitHub の dotnet/samples リポジトリでは、完全版のサンプルを確認することもできます。 ダウンロード方法については、「サン プルおよびチュートリアル」を参照してください。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。 インストールの手順については、.NET Core のダウンロード ページを参照してください。 このアプリケーションは、Windows、Ubuntu Linux、または OS X 上、あるい は Docker コンテナーで実行できます。 お好みのコード エディターをインストールしてください。 次の説明では、オープン ソースの クロス プラットフォーム エディターである Visual Studio Code を使用しています。 しかし、他の使い慣れたツールを使用しても構 いません。
アプリケーションを作成する
最初に新しいアプリケーションを作成します。 コマンド プロンプトを開き、アプリケーション用の新しいディレクトリを作成します。 そ れを、現在のディレクトリとしてください。 コマンド プロンプトで dotnet new console のコマンドを入力します。 これで、基本的 な "Hello World" アプリケーションのスターター ファイルが作成されます。
C# を始めて使用する方向けに、このチュートリアルで C# プログラムの構造について説明しています。 そのチュートリアルを先に 読んでから、ここに戻って LINQ の詳細について学ぶのも良いでしょう。
データ セットを作成する
開始する前に、 dotnet new console によって生成された Program.cs ファイルの上部に次の行があることを確認してくださ い。
       // Program.cs
using System;
using System.Collections.Generic;
using System.Linq;
 統合言語クエリ (LINQ) を使用する 2020/11/02 • • Edit Online
 
     これら3つの行(using ステートメント)がファイルの上部にない場合、プログラムはコンパイルされません。
必要になる参照のすべてが用意できたので、カード デッキを構成するものは何かを考えます。 一般的に、1 組のトランプ カード には4種類の絵札(スート)があり、スートごとに13個の値があります。通常は、Card クラスをすぐに作成し、Card オブジェ クトのコレクションを手動で設定することを検討するかもしれません。 LINQ では、カード デッキの作成を通常の方法よりも簡潔 に処理することができます。 Card クラスを作成する代わりに、それぞれがスートとランクを表す2つのシーケンスを作成できま す。 文字列の IEnumerable<T> としてランクとスートを生成する、非常に単純な "反復子メソッド" のペアを作成します。
    // Program.cs
// The Main() method
static IEnumerable<string> Suits()
{
    yield return "clubs";
    yield return "diamonds";
    yield return "hearts";
    yield return "spades";
}
static IEnumerable<string> Ranks()
{
    yield return "two";
    yield return "three";
    yield return "four";
    yield return "five";
    yield return "six";
    yield return "seven";
    yield return "eight";
    yield return "nine";
    yield return "ten";
    yield return "jack";
    yield return "queen";
    yield return "king";
    yield return "ace";
}
   Program.cs ファイル内の Main メソッドの下にこれらを配置します。 これら 2 つのメソッドは両方とも、 yield return 構文を 使用して実行中にシーケンスを生成します。 コンパイラは IEnumerable<T> を実装するオブジェクトをビルドし、要求に応じて 文字列のシーケンスを生成します。
次に、これらの反復子メソッドを使用して、カードデッキを作成します。 Main メソッドの中にLINQクエリを配置します。次の ようになります。
    // Program.cs
static void Main(string[] args)
{
    var startingDeck = from s in Suits()
                       from r in Ranks()
                       select new { Suit = s, Rank = r };
    // Display each card that we've generated and placed in startingDeck in the console
    foreach (var card in startingDeck)
    {
        Console.WriteLine(card);
    }
}
 複数の from 句は1つのSelectManyを生成し、これが、最初のシーケンス内の各要素と2番目のシーケンス内の各要素 とを組み合わせた 1 つのシーケンスを作成します。 ここでは順序が重要です。 最初のソース シーケンス (Suits) 内の最初の要 素が、2 番目のシーケンス (Ranks) のすべての要素と組み合わされます。 これで、最初のスートのカード 13 枚すべてが生成さ れます。 このプロセスを、最初のシーケンス (Suits) 内の各要素について繰り返します。 その結果、はじめにスート順に並んで、

 次に値の順に並んだカード デッキができます。
LINQ を記述するときに、上記に示したクエリ構文を使用することを選択した場合でも、メソッド構文を使用することを選択した 場合でも、片方の形式の構文から他方の構文の形式に常に移動できることを覚えておくことが重要です。 クエリ構文で記述さ れた上記のクエリは、次のようにメソッド構文で記述できます。
クエリ構文で記述された LINQ ステートメントは、コンパイラによって、同等のメソッド呼び出し構文に変換されます。 そのため、 選択した構文に関係なく、クエリの 2 つのバージョンでは同じ結果が生成されます。 ご自分の状況にとって最善の構文を選択 してください。たとえば、チームで作業している場合に、メソッド構文に慣れていないメンバーがいる場合は、クエリ構文の使用を 勧めるようにしてください。
この時点で、作成したサンプルを実行してみてください。 デッキにある 52 枚のカードがすべて表示されます。 デバッガ―でこのサ ンプルを実行すると、 Suits() メソッドと Ranks() メソッドがどのように実行されるか理解するのに役立ちます。 各シーケンス 内の各文字列が必要な場合にのみ生成されることがよくわかります。
順序を操作する
次に、カード デッキをどのようにシャッフルするかに注目します。 適切なシャッフルの最初の手順は、カード デッキを 2 つの山に分 けることです。LINQAPIの一部であるTakeメソッドとSkipメソッドの機能を利用できます。それらを foreach ループの下に 配置します。
  var startingDeck = Suits().SelectMany(suit => Ranks().Select(rank => new { Suit = suit, Rank = rank }));
         // Program.cs
public static void Main(string[] args)
{
    var startingDeck = from s in Suits()
                       from r in Ranks()
                       select new { Suit = s, Rank = r };
    foreach (var c in startingDeck)
    {
        Console.WriteLine(c);
    }
    // 52 cards in a deck, so 52 / 2 = 26
    var top = startingDeck.Take(26);
    var bottom = startingDeck.Skip(26);
}
 ただし、標準ライブラリの中には利用できるシャッフル メソッドがないので、自分で作成する必要があります。 作成するシャッフル

       メソッドには、LINQ ベースのプログラムで使用できるさまざまなテクニックが例示されているので、このプロセスの各部分を手順を 追って説明します。
LINQ クエリから返される IEnumerable<T> を操作する方法に対していくつかの機能を追加するには、拡張メソッドと呼ばれる 特別な種類のメソッドをいくつか記述する必要があります。 手短に言うと、拡張メソッドとは、既に存在する型に機能を追加す る際に、元の型を変更せずに新しい機能を追加するという特別な目的を持つ静的メソッドです。
Extensions.cs という名前の新しいstaticクラスファイルをプログラムに追加した後、最初の拡張メソッドをビルドすることで、 自分の拡張メソッドに新しいホームを与えます。
     // Extensions.cs
using System;
using System.Collections.Generic;
using System.Linq;
namespace LinqFaroShuffle
{
    public static class Extensions
    {
        public static IEnumerable<T> InterleaveSequenceWith<T>(this IEnumerable<T> first, IEnumerable<T>
second)
        {
            // Your implementation will go here soon enough
} }
}
 少しの間、メソッド シグネチャ、特にパラメーターを調べてみてください。
メソッドの最初の引数に this 修飾子が追加されているのがわかります。つまり、最初の引数の型のメンバーメソッドと同じよ うに、メソッドを呼び出すということです。 また、このメソッドの宣言は標準的な表現形式に従い、入力と出力の型が
IEnumerable<T> となります。これによってLINQメソッドが連結され、より複雑なクエリを実行できるようになります。
当然ながら、デッキを二等分したため、これらを結合させる必要があります。 コードでは、これは、Take と Skip を同時に実行 し、要素を interleaving して取得したシーケンスの両方を列挙し、1つのシーケンス(今シャッフルが行なわれたカードデッ キ) を作成することを意味します。 2 つのシーケンスで動作する LINQ メソッドを作成するには、IEnumerable<T> がどのように 動作するかを理解する必要があります。
IEnumerable<T> インターフェイスには GetEnumerator のメソッドが 1 つあります。 GetEnumerator によって返されるオブ ジェクトには、次の要素に移動するメソッドと、シーケンス内の現在の要素を取得するプロパティがあります。 これら 2 つのメン バーを使用して、コレクションを列挙し、要素を返します。 このインターリーブ メソッドは反復子メソッドになるので、コレクションを 作成してそのコレクションを返す代わりに、上記の yield return 構文を使用します。
そのメソッドの実装を以下に示します。
  public static IEnumerable<T> InterleaveSequenceWith<T> (this IEnumerable<T> first, IEnumerable<T> second)
    
  このメソッドが作成できたので、Main メソッドに戻り、デッキを1回シャッフルします。
    // Program.cs
public static void Main(string[] args)
{
    var startingDeck = from s in Suits()
                       from r in Ranks()
                       select new { Suit = s, Rank = r };
    foreach (var c in startingDeck)
    {
        Console.WriteLine(c);
    }
    var top = startingDeck.Take(26);
    var bottom = startingDeck.Skip(26);
    var shuffle = top.InterleaveSequenceWith(bottom);
    foreach (var c in shuffle)
    {
        Console.WriteLine(c);
    }
}
 比較
デッキを元の順序に戻すまでに何回シャッフルが必要でしょうか。 これを見つけるには、2 つのシーケンスが等しいかどうかを判断 するメソッドを記述する必要があります。 そのメソッドを記述したら、デッキをループでシャッフルするコードを配置し、どの時点で 元の順序に戻るかを確認する必要があります。
2 つのシーケンスが等しいかどうかを判断するメソッドの記述は簡単です。 デッキのシャッフル用に記述したメソッドと似た構造で す。 今回に限り、各要素を yield return するのではなく、各シーケンスの一致する要素を比較します。 シーケンス全体が 列挙されている場合、各要素が一致すれば、シーケンスは同じです。
    public static IEnumerable<T> InterleaveSequenceWith<T>
    (this IEnumerable<T> first, IEnumerable<T> second)
{
    var firstIter = first.GetEnumerator();
    var secondIter = second.GetEnumerator();
    while (firstIter.MoveNext() && secondIter.MoveNext())
    {
        yield return firstIter.Current;
        yield return secondIter.Current;
    }
}
 
  これは 2 つ目の LINQ の表現形式であるターミナル メソッドを示しています。 これらは、シーケンスを入力として受け取り (この 場合 2 つのシーケンス)、単一のスカラー値を返します。 ターミナル メソッドを使用した場合、それらは常に LINQ クエリ用のメ ソッド チェーンの最後のメソッドになります。そのため、名前が "ターミナル" (終点) になっています。
これは、デッキが元の順序に戻るタイミングの判定に使用すると、どのように動作するかを確認できます。 ループ内にシャッフルの コードを配置し、 SequenceEquals() メソッドを適用して、シーケンスが元の順序に戻った時点で停止します。 シーケンスでは なく単一の値を返すため、常にクエリ内の最後のメソッドになることがわかります。
     // Program.cs
static void Main(string[] args)
{
    // Query for building the deck
    // Shuffling using InterleaveSequenceWith<T>();
    var times = 0;
    // We can re-use the shuffle variable from earlier, or you can make a new one
    shuffle = startingDeck;
    do
    {
        shuffle = shuffle.Take(26).InterleaveSequenceWith(shuffle.Skip(26));
        foreach (var card in shuffle)
        {
            Console.WriteLine(card);
        }
        Console.WriteLine();
        times++;
    } while (!startingDeck.SequenceEquals(shuffle));
    Console.WriteLine(times);
}
 ここでコードを実行して、シャッフルごとにデッキがどのように整列するかを書き留めておいてください。 8 回のシャッフル (do-while loop の繰り返し) 後に、デッキは、開始時の LINQ クエリから作成された初回の構成に戻ります。
最適化
ここまでで構築したサンプルは、アウト シャッフル (一番上と一番下のカードが毎回同じになること) を実行するものです。 ここで 1 つ変更を加えましょう。"イン シャッフル " を代わりに使用します。ここでは、52 枚のカードすべての位置が変わります。 イン シャッフルでは、下半分の一番上のカードが、デッキの最上部に来るように、デッキをインターウィーブします。 つまり、上半分の 一番下のカードがデッキの最下部のカードになります。 これは、1 行のコードを変更する単純な変更です。 Take と Skip の位 置を入れ替えることで、現在のシャッフル クエリを更新します。 これにより、デッキの上半分と下半分の順序が変更されます。
   public static bool SequenceEquals<T>
    (this IEnumerable<T> first, IEnumerable<T> second)
{
    var firstIter = first.GetEnumerator();
    var secondIter = second.GetEnumerator();
    while (firstIter.MoveNext() && secondIter.MoveNext())
    {
        if (!firstIter.Current.Equals(secondIter.Current))
        {
            return false;
        }
}
    return true;
}
 
   プログラムを再実行すると、デッキが元の順序に戻るのに反復が 52 回行われることがわかります。 プログラムを実行し続ける と、著しくパフォーマンスが低下することがわかります。
これには多くの理由があります。 このパフォーマンスの低下の主な原因の 1 つを説明できます。それは、"遅延評価" の非効率 的な使用です。
手短に言えば、遅延評価とは、ステートメントの値が必要になるまで、その評価が実行されないことです。 遅延して評価されて いるステートメントは LINQ クエリです。 シーケンスは、要素が要求された場合にのみ生成されます。 通常、これは LINQ の利 点です。 しかし、このプログラムのような使い方をする場合、実行時間が急激に増加する要因となります。
元のデッキを LINQ クエリを使用して生成したことを思い出してください。 毎回のシャッフルは、直前のデッキに LINQ クエリを 3 回実行することによって生成されます。 これらはすべて遅延実行されます。 つまり、シーケンスが要求されるたびに再度実行さ れるということです。 52 回反復されるまでに、元のデッキを何度も何度も再生成しているのです。 ログを記述してこの動作を示 しましょう。 その次に修正します。
ファイルに、次のメソッドを入力するかコピーします。 この拡張メソッドによって、プロジェクト ディレクトリ内に と呼ばれる新しいファイルが作成され、このログ ファイルに現在どのようなクエリが実行されているかが記録されます。
この拡張メソッドはどんなクエリにも追加でき、そのクエリが実行されたことをマークできます。
 Extensions.cs
 debug.log
    public static IEnumerable<T> LogQuery<T>
    (this IEnumerable<T> sequence, string tag)
{
    // File.AppendText creates a new file if the file doesn't exist.
    using (var writer = File.AppendText("debug.log"))
    {
        writer.WriteLine($"Executing Query {tag}");
    }
    return sequence;
}
 File の下に、存在しないことを意味する赤い波線が表示されます。コンパイラがどのような File かを把握できないため、こ れはコンパイルされません。 この問題を解決するには、 Extensions.cs の最初の行の下に次のコード行を追加してください。
これでイシューが解決し、赤のエラーは表示されなくなるはずです。 次に、各クエリの定義をログ メッセージでインストルメントします。
   using System.IO;
  shuffle = shuffle.Skip(26).InterleaveSequenceWith(shuffle.Take(26));
 
      クエリにアクセスするたびにログをとるわけではないことに注意してください。 元のクエリを作成する場合にのみログをとります。 プロ グラムの実行にはまだ時間がかかりますが、これで理由がわかるようになりました。 ログを有効にしたままイン シャッフルを実行す ると時間がかかりすぎると感じる場合は、アウト シャッフルに戻してください。 それでも遅延評価の影響はわかります。 1 回の実 行で、すべての値とスートの生成を含めてクエリを 2592 回実行します。
ここでコードのパフォーマンスを向上させて、実行回数を減らすことができます。 実行できる単純な修正は、カード デッキを構築 する元の LINQ クエリの結果を "キャッシュ" することです。 現時点では、do-while loop が繰り返されるたびに、何度もクエリが 実行され、カード デッキが再構築され、シャッフルが毎回実行されています。 カード デッキをキャッシュするには、LINQ メソッドの ToArray と ToList を活用できます。それらをクエリに追加すると、実行するように指示したのと同じアクションが実行されますが、 今回は、呼び出すように選択したメソッドに応じて、結果が配列または一覧内に格納されます。 LINQ メソッド ToArray を両 方のクエリに追加し、もう一度プログラムを実行します。
  // Program.cs
public static void Main(string[] args)
{
    var startingDeck = (from s in Suits().LogQuery("Suit Generation")
                        from r in Ranks().LogQuery("Rank Generation")
                        select new { Suit = s, Rank = r }).LogQuery("Starting Deck");
    foreach (var c in startingDeck)
    {
        Console.WriteLine(c);
    }
    Console.WriteLine();
    var times = 0;
    var shuffle = startingDeck;
do {
*/
        // In shuffle
        shuffle = shuffle.Skip(26).LogQuery("Bottom Half")
                .InterleaveSequenceWith(shuffle.Take(26).LogQuery("Top Half"))
                .LogQuery("Shuffle");
        foreach (var c in shuffle)
        {
            Console.WriteLine(c);
        }
times++;
        Console.WriteLine(times);
    } while (!startingDeck.SequenceEquals(shuffle));
    Console.WriteLine(times);
}
// Out shuffle
/*
shuffle = shuffle.Take(26)
    .LogQuery("Top Half")
    .InterleaveSequenceWith(shuffle.Skip(26)
    .LogQuery("Bottom Half"))
    .LogQuery("Shuffle");

     これで、アウト シャッフルのクエリが 30 回に減少します。 イン シャッフルで再実行しても、同様の改善がみられます。今回は 162 回のクエリが実行されます。
この例は、遅延評価がパフォーマンス問題を引き起こす可能性があるユース ケースを強調することを意図していることに注意し てください。 遅延評価がどこでコードのパフォーマンスに影響を与える可能性があるかを確認することは重要ですが、すべてのク エリを先行評価で実行する必要があるわけではないことを理解することも同じように重要です。 ToArray の無使用によってパ フォーマンス ヒットが発生するのは、カード デッキの新しい並びが、毎回、直前の並びから作成されるためです。 遅延評価を使 用すると、 startingDeck を作成したコードを実行するときでさえも、新しいデッキ構成が毎回最初のデッキから作成されること になります。 これでは、余分な作業が多く発生してしまいます。
実際には、先行評価を使用すると効率的に動作するアルゴリズムもあれば、遅延評価を使用したほうがよいアルゴリズムもあり ます。 日常の使用では、データ ソースがデータベース エンジンのように個別のプロセスである場合は、遅延評価のほうが通常は 適しています。 データベースでは、遅延評価を使用すると、より複雑なクエリがデータベース プロセスに対して 1 往復だけ実行 された後、残りのコードに戻ることができます。 LINQ には遅延評価と先行評価のどちらを利用するかを選択できる柔軟性があ るため、プロセスを測定して、最善のパフォーマンスをもたらすほうの種類の評価を選択してください。
   public static void Main(string[] args)
{
    var startingDeck = (from s in Suits().LogQuery("Suit Generation")
                        from r in Ranks().LogQuery("Value Generation")
                        select new { Suit = s, Rank = r })
                        .LogQuery("Starting Deck")
                        .ToArray();
    foreach (var c in startingDeck)
    {
        Console.WriteLine(c);
    }
    Console.WriteLine();
    var times = 0;
    var shuffle = startingDeck;
do {
*/
        shuffle = shuffle.Skip(26)
            .LogQuery("Bottom Half")
            .InterleaveSequenceWith(shuffle.Take(26).LogQuery("Top Half"))
            .LogQuery("Shuffle")
            .ToArray();
        foreach (var c in shuffle)
        {
            Console.WriteLine(c);
        }
times++;
        Console.WriteLine(times);
    } while (!startingDeck.SequenceEquals(shuffle));
    Console.WriteLine(times);
}
/*
shuffle = shuffle.Take(26)
    .LogQuery("Top Half")
    .InterleaveSequenceWith(shuffle.Skip(26).LogQuery("Bottom Half"))
    .LogQuery("Shuffle")
    .ToArray();

       まとめ このプロジェクトでは、以下を扱いました。
LINQ クエリを使用してデータを集計して、意味のあるシーケンスにする
拡張メソッドを記述して、LINQ クエリに独自のカスタム機能を追加する
LINQ クエリによって速度の低下のようなパフォーマンスの問題が発生する可能性があるコード内の領域を見つける LINQ クエリに関する遅延評価と選考評価と、クエリのパフォーマンスにおけるそれらの意味
LINQ の他に、マジシャンがカードのトリックで使用するテクニックについて少し学びました。 マジシャンは、すべてのカードをデッキ のどこに移動させるかを制御できるため、ファロー シャッフルを使用しています。 これがわかったからといって、種明かしをしてマジッ クを台無しにしないでください。
LINQ の詳細については、以下を参照してください。
統合言語クエリ (LINQ)
LINQ の概要
LINQ クエリの基本操作 (C#)
LINQ によるデータ変換 (C#)
LINQ でのクエリ構文とメソッド構文 (C#) LINQ をサポートする C# の機能

        属性は、情報をコードに宣言的に関連付けるための手段を提供します。 また、さまざまなターゲットに適用できる再利用可能 な要素も提供します。
たとえば [Obsolete] 属性について考えてみましょう。この属性はクラス、構造体、メソッド、コンストラクトなどに適用できま す。 これは、その要素が古いことを "宣言" します。 この属性を検索して、対応する何らかのアクションを実行するのは、C# コン パイラの役目です。
このチュートリアルでは、コードに属性を追加する方法、独自の属性を作成して使用する方法、.NET Core に組み込まれてい るいくつかの属性を使用する方法について説明します。
必須コンポーネント
お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。 インストールの手順については、.NET Core のダウンロード ページを参照してください。 このアプリケーションは、Windows、Ubuntu Linux、macOS または Docker コンテナーで実行できます。 お好みのコード エディターをインストールしてください。 次の説明では、オープン ソースのクロス プラッ トフォーム エディターである Visual Studio Code を使用しています。 しかし、他の使い慣れたツールを使用しても構いません。
アプリケーションを作成する
すべてのツールをインストールしたら、新しい .NET Core アプリケーションを作成します。 コマンド ライン ジェネレーターを使用する には、お使いのシェルで次のコマンドを実行します。
dotnet new console
このコマンドにより、必要最小限の .NET Core プロジェクト ファイルが作成されます。 dotnet restore を実行して、このプロ
ジェクトのコンパイルに必要な依存関係を復元する必要があります。
を実行する必要がなくなりました。復元を必要とするすべてのコマンド ( dotnet new 、 dotnet build 、
、 、 、 dotnet pack など) によって暗黙的に実行されるためです。 暗黙的な復
元を無効にするには、 オプションを使用します。
Azure DevOps Services の継続的インテグレーション ビルドなどの、明示的な復元が意味のある一部のシナリオや、復元が
行われるタイミングを明示的に制御する必要があるビルド システムでは、 dotnet restore は引き続き有用なコマンドです。 NuGetフィードの管理方法については、 dotnet restore のドキュメントをご覧ください。
プログラムを実行するには dotnet run を使用します。 コンソールに "Hello, World" という出力が表示されます。
コードに属性を追加する方法
C#では、属性は Attribute 基底クラスを継承するクラスです。 クラスから継承したクラスは、コードの他の部分 で一種の "タグ" として使用できます。 たとえば という名前の属性があります。 これは、そのコードが古い ので現在は使用できないことを警告するために使用されます。 この属性を、角かっこを使用して、たとえばクラスに適用すること ができます。
      dotnet restore
    dotnet run
dotnet test
dotnet publish
 --no-restore
     Attribute
 ObsoleteAttribute
    [Obsolete]
public class MyClass
{
}
 C# で属性を使用する 2020/11/02 • • Edit Online
 
     この属性の名前は と記述するだけで使用できます。 これは C# が準拠 している規則によります。 完全な名前   も使用できます。
クラスを現在使用されていないとマークするときは、その "理由" と、代わりに "何を" 使用べきかについての情報を提供すること をお勧めします。 これは、Obsolete 属性に文字列パラメーターを渡すことで行います。
この文字列は、 var attr = new ObsoleteAttribute("some string") と記述した場合と同様に、 ObsoleteAttribute コン ストラクターに引数として渡されます。
属性コンストラクターに渡すパラメーターは、単純な型/リテラル ( bool, int, double, string, Type, enums, etc ) とそれらの 配列のみに限られます。 式または変数は使用できません。 位置指定パラメーターや名前付きパラメーターは自由に使用でき ます。
独自の属性を作成する方法
属性の作成は、 Attribute 基底クラスからの継承と同じくらいに簡単です。
これで、 [MySpecial] (または [MySpecialAttribute] ) をコード ベースの他の場所で属性として使用できます。
.NETの基本クラスライブラリに含まれる ObsoleteAttribute のような属性は、コンパイラ内で特定の動作をトリガーします。し かし、作成した属性はメタデータとしてのみ機能するため、属性クラス内のコードは実行されません。 そのメタデータを、コードの 他の場所で操作する必要があります (詳細については、このチュートリアルの公判で説明します)。
ここに注意すべき "罠" があります。 前述のように、属性を使用するときは、特定の型のみを引数として渡すことができます。 し かし、属性の型を作成するときに、C# コンパイラによってパラメーターの作成が阻止されることはありません。 下の例では、正常 にコンパイルされるコンストラクターを使用して属性を作成しています。
しかし、このコンストラクターは属性構文では使用できません。
ObsoleteAttribute
ですが、コードでは
  [ObsoleteAttribute]
     [Obsolete("ThisClass is obsolete. Use ThisClass2 instead.")]
public class ThisClass
{
}
         public class MySpecialAttribute : Attribute
{
}
       [MySpecial]
public class SomeOtherClass
{
}
      public class GotchaAttribute : Attribute
{
    public GotchaAttribute(Foo myClass, string str) {
} }
     [Gotcha(new Foo(), "test")] // does not compile
public class AttributeFail
{
}
 上のコードでは、次のようなエラーが発生します。
[Obsolete]
 
   属性の用途を制限する方法
属性はさまざまな "ターゲット" に対して使用できます。 上の例ではクラスに使用しましたが、次のターゲットに対しても使用でき ます。
アセンブリ
クラス コンストラクター 代理人
列挙型
Event
フィールド GenericParameter インターフェイス メソッド
モジュール パラメーター プロパティ ReturnValue 構造体
C# の既定では、属性クラスを作成した場合、その属性は可能なすべての属性ターゲットに使用できます。 属性を特定のター ゲットにのみ使用できるように制限するには、属性クラスに対して AttributeUsageAttribute を使用します。 つまり、属性に属 性を設定します。
クラスまたは構造体以外のターゲットに上の属性を設定しようとすると、次のようなコンパイラ エラーが発生します。
     [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class MyAttributeForClassAndStructOnly : Attribute
{
}
   Attribute 'MyAttributeForClassAndStructOnly' is not valid on this declaration type. It is only valid on
'class, struct' declarations
     public class Foo
{
// if the below attribute was uncommented, it would cause a compiler error // [MyAttributeForClassAndStructOnly]
public Foo()
{}
}
 コード要素にアタッチされた属性を使用する方法 属性はメタデータとして機能します。 外からの力が働かないかぎり、実際には何の処理も実行しません。
属性を見つけて操作するには、通常、Reflection が必要になります。 このチュートリアルでは Reflection について詳しく説明し ませんが、基本的な考えとしては、Reflection を使用すると C# で他のコードを調べるコードを記述できます。
たとえば、Reflection を使用して次のクラスに関する情報を取得できます (コードの先頭に using System.Reflection; を追 加する)。
  Attribute constructor parameter 'myClass' has type 'Foo', which is not a valid attribute parameter type
 
   出力は次のようになります。
TypeInfo オブジェクト (または MemberInfo 、 FieldInfo など) を取得したら、 メソッドを使用できま す。 このメソッドは オブジェクトのコレクションを返します。 また、 を使用して Attribute 型を 指定することもできます。
MyClass クラス(前の例で [Obsolete] 属性を適用したクラス)の MemberInfo インスタンスに対して GetCustomAttributes を使用する例を以下に示します。
コンソールには次のように出力されます。 に他の属性を追加してみて ください。
オブジェクトは限定的にインスタンス化されることに注意してください。 つまり、 GetCustomAttribute または を使用するまでインスタンス化されません。 また、インスタンス化は使用のたびに行われます。 行内で を2回呼び出すと、ObsoleteAttribute の異なる2つのインスタンスが返されます。
基本クラス ライブラリ (BCL) のよく使用される属性
属性は、さまざまなツールやフレームワークで使用されます。NUnitは、[Test] や [TestFixture] などの属性をNUnitテス トランナーで使用します。ASP.NETMVCは、[Authorize] などの属性を使用して、MVCアクションに対する横断的な処理 を実行するためのアクション フィルター フレームワークを提供します。 PostSharp は、属性構文を使用して C# でアスペクト指向 プログラミングを行えるようにします。
.NET Core の基本クラス ライブラリに組み込まれている、よく使用される属性のいくつかを以下に示します。
[Obsolete] . これは上の例で使用した属性で、 System 名前空間に格納されています。 この属性は、コード ベース の変更に関する宣言的なドキュメントを提供するのに便利です。 メッセージは文字列の形式で指定でき、別のブール 型パラメーターを使用すると、コンパイラの警告をコンパイラのエラーにエスカレートすることができます。
[Conditional].この属性は System.Diagnostics 名前空間に格納されています。この属性はメソッド(または属性 クラス)に適用できます。コンストラクターに文字列を渡す必要があります。その文字列が #define ディレクティブと一 致しない場合、そのメソッドの呼び出し (メソッド自体ではありません) が C# コンパイラによって除外されます。 通常、こ の属性はデバッグ (診断) 目的で使用されます。
[CallerMemberName] .この属性はパラメーターに使用でき、 System.Runtime.CompilerServices 名前空間に格納さ れています。 この属性は、別のメソッドを呼び出しているメソッドの名前を挿入するために使用します。 これは通常、さ まざまな UI フレームワークで INotifyPropertyChanged を実装する際に "マジック文字列" を排除するための方法とし て使用されます。 例
  The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0,
Culture=neutral, PublicKeyToken=null
     GetCustomAttributes
 Attribute
 GetCustomAttribute
        var attrs = typeInfo.GetCustomAttributes();
foreach(var attr in attrs)
    Console.WriteLine("Attribute on MyClass: " + attr.GetType().Name);
  Attribute on MyClass: ObsoleteAttribute
 MyClass
  Attribute
 GetCustomAttributes
   GetCustomAttributes
             TypeInfo typeInfo = typeof(MyClass).GetTypeInfo();
Console.WriteLine("The assembly qualified name of MyClass is " + typeInfo.AssemblyQualifiedName);
 
   上のコードでは、リテラルの "Name" 文字列を使用する必要はありません。これは入力ミス関連のバグを防ぎ、リファクタリング や名前変更をスムーズにするのに役立ちます。
まとめ
属性によって C# に宣言機能が追加されますが、それらはメタデータ形式のコードであり、単独では機能しません。
   public class MyUIClass : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged;
    public void RaisePropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
} }
private string _name;
public string Name
{
    get { return _name;}
    set
    {
        if (value != _name)
        {
} }
_name = value;
RaisePropertyChanged();
// notice that "Name" is not needed here explicitly
 
        C# 9.0 によって、C# 言語に次の機能と機能強化が追加されています。
レコード
init 専用セッター 最上位レベルのステートメント パターン マッチングの拡張機能 ネイティブ サイズの整数 関数ポインター
localsinit フラグの出力を抑制する ターゲット型の新しい式 静的な匿名関数 ターゲットにより型指定された条件式 共変の戻り値の型
foreach ループの拡張機能 GetEnumerator サポート ラムダ ディスカード パラメーター
ローカル関数の属性
モジュールの初期化子
部分メソッドの新機能
C# 9.0 は .NET 5 でサポートされています。 詳細については、「C# 言語のバージョン管理」を参照してください。 最新の .NET SDK は .NET のダウンロード ページでダウンロードできます。
レコードの種類
C# 9.0 には "レコード型" が導入されています。これは、等価性の値のセマンティクスを提供するための合成されたメソッドを提 供する参照型です。 既定では、レコードは変更できません。
レコード型を使用すると、変更できない参照型を .NET で簡単に作成できます。 従来、.NET 型は、参照型 (クラス型と匿名 型を含む) と値型 (構造体とタプルを含む) に大別されています。 変更できない値型が推奨されますが、変更可能な値型でエ ラーが頻繁に発生するわけではありません。 値型の変数には値が保持され、値型がメソッドに渡されるときは、元のデータのコ ピーが変更されます。
変更できない参照型にも多くの利点があります。 これらの利点は、共有データを使用する同時実行プログラムで、より顕著に なります。 残念ながら、C# で変更できない参照型を作成するには、余分なコードをかなり記述する必要がありました。 レコー ドにより、等価性の値のセマンティクスを使用する、変更できない参照型の型宣言が提供されます。 等価コードとハッシュ コー ドの合成メソッドでは、プロパティがすべて等しい場合、2 つのレコードは等しいと見なされます。 次の定義を考慮してください。
      public record Person
{
    public string LastName { get; }
    public string FirstName { get; }
    public Person(string first, string last) => (FirstName, LastName) = (first, last);
}
    レコード定義によって、 FirstName と LastName の 2 つの読み取り専用プロパティを含む Person 型が作成されます。
C# 9.0 の新機能 2021/03/06 • • Edit Online
 
    型は参照型です。 IL を見た場合は、それはクラスです。 どのプロパティも作成後に変更できないので、それは変更で きません。 レコード型を定義すると、コンパイラによって他のいくつかのメソッドが自動的に合成されます。
値ベースの等価比較のためのメソッド GetHashCode() のオーバーライド コピー メンバーとクローン メンバー
PrintMembers およびToString()
レコードによって、継承がサポートされます。 次のようにして、 Person の新しい派生レコードを宣言できます。
また、レコードをシールして、さらに派生させることもできます。
コンパイラにより、上記のメソッドの異なるバージョンが合成されます。 メソッドのシグネチャは、レコード型がシールされているかど うか、および直接基底クラスがオブジェクトであるかどうかによって異なります。 レコードには次の機能が必要です。
等価性は値に基づいており、型が一致するかどうかのチェックが含まれます。 たとえば、2 つのレコードが同じ名前を共有し ている場合でも、 Student を Person と同じにすることはできません。
レコードには、自動的に生成される一貫した文字列表現があります。
レコードによって、コピーの構築がサポートされます。 正しいコピーの構築には、継承階層と、開発者によって追加されたプロ パティが含まれる必要があります。
レコードは、変更してコピーできます。 これらのコピー操作と変更操作では、非破壊的な変異がサポートされます。
使い慣れた Equals オーバーロード、 operator == 、 operator != に加えて、コンパイラによって新しい EqualityContract プロパティが合成されます。プロパティからは、レコードの型に一致する Type オブジェクトが返されます。基本データ型が
object の場合、プロパティは になります。基本データ型が別のレコード型である場合、プロパティは override に なります。レコード型が の場合、プロパティは sealed になります。合成された GetHashCode によって、基本データ 型とレコード型で宣言されているすべてのプロパティとフィールドの が使用されます。 これらの合成メソッドにより、 継承階層全体で値ベースの等価性が適用されます。つまり、 は、同じ名前の Person と等しいとは見なされませ ん。 2 つのレコードの型が一致し、さらにレコード型の間で共有されているすべてのプロパティが等しい必要があります。
レコードには、合成されたコンストラクターと、コピーを作成するための "clone" メソッドもあります。 合成コンストラクターには、レ コード型の引数が 1 つあります。 これにより、レコードのすべてのプロパティの値が同じ新しいレコードが生成されます。 レコード がシールされている場合、このコンストラクターは private です。それ以外の場合は、protected です。 合成された "clone" メ ソッドによって、レコード階層のコピーの構築がサポートされます。 "clone" という用語が引用符で囲まれているのは、実際の名 前はコンパイラによって生成されるためです。レコード型で Clone という名前のメソッドを作成することはできません。合成され た"clone"メソッドによって、仮想ディスパッチを使用してコピーされるレコードの型が返されます。コンパイラにより、record のア クセス修飾子に応じて、異なる修飾子が "clone" メソッドに追加されます。
レコード型が の場合は、"clone"メソッドも abstract になります。基本データ型が object でない場合は、メ ソッドも になります。
      public record Teacher : Person
{
    public string Subject { get; }
    public Teacher(string first, string last, string sub)
        : base(first, last) => Subject = sub;
}
     public sealed record Student : Person
{
    public int Level { get; }
    public Student(string first, string last, int level) : base(first, last) => Level = level;
}
          virtual
       abstract
sealed
 GetHashCode
 Student
  override
 Person
 
       基本データ型が   であるときの、   ではないレコード型の場合:
レコードが   の場合、追加の修飾子は"clone"メソッドに追加されません(つまり、virtual ではありませ ん)。
レコードが
object
abstract
    sealed
   sealed
  基本データ型が レコードが レコードが
ではない場合、"clone"メソッドは virtual になります。 ではないときの、 abstract ではないレコード型の場合:
object
  sealed
の場合は、"clone" メソッドも になります。 ではない場合、"clone" メソッドは になります。
sealed
   sealed
override
これらすべてのルールの結果として、レコード型のすべての階層で等価性が一貫して実装されます。 次の例で示すように、プロ パティが等しく、型が同じである場合、2 つのレコードは互いに等しくなります。
コンパイラにより、印刷出力をサポートする2つのメソッドToString()のオーバーライドと PrintMembers が合成されます。 PrintMembers は、引数としてSystem.Text.StringBuilderを受け取ります。レコード型のすべてのプロパティに対し、プロパ
ティ名と値のコンマ区切りリストが追加されます。 によって、他のレコードからのすべての派生レコードに対する基 本実装が呼び出されます。 ToString() のオーバーライドでは、 によって生成され、 { と } で囲まれた文字列 が返されます。たとえば、Student に対するToString()メソッドでは、次のコードのような string が返されます。
これまでに示した例では、従来の構文を使用してプロパティが宣言されています。 "*位置指定レコード*" と呼ばれる簡潔な形 式があります。 次に示すのは、前に位置指定レコードとして定義されている 3 つのレコード型です。
    var person = new Person("Bill", "Wagner");
var student = new Student("Bill", "Wagner", 11);
Console.WriteLine(student == person); // false
    PrintMembers
 PrintMembers
    "Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
     public record Person(string FirstName, string LastName);
public record Teacher(string FirstName, string LastName,
    string Subject)
    : Person(FirstName, LastName);
public sealed record Student(string FirstName,
    string LastName, int Level)
    : Person(FirstName, LastName);
 これらの宣言によって、以前のバージョンと同じ機能が作成されます (次のセクションで説明する追加の機能がいくつかありま す)。 これらのレコードには新しいメソッドが追加されていないため、これらの宣言は角かっこではなくセミコロンで終わっています。 本体を追加し、追加のメソッドを含めることもできます。

       コンパイラによって、位置指定レコードに対して Deconstruct メソッドが生成されます。 Deconstruct メソッドには、レコード型 のすべてのパブリック プロパティの名前と一致するパラメーターがあります。 メソッドを使用して、レコードをコンポー ネント プロパティに分解できます。
最後に、レコードは with 式をサポートしています。 * with 式 _ _ は、レコードのコピーを、_with で指定したプロパティを変 更して作成するように、コンパイラに指示します。
前の行では、 LastName プロパティが person のコピーで、 FirstName が "Paul" である、新しい Person レコードが作成さ れます。 with 式には、任意の数のプロパティを設定できます。 with 式を使用して、正確なコピーを作成することもできま す。 変更するプロパティの空のセットを指定します。
"clone" メソッド以外のすべての合成メンバーは、開発者が自分で記述できます。 レコード型に、いずれかの合成メソッドのシグ ネチャと一致するメソッドがある場合、コンパイラでそのメソッドは合成されません。前の Dog レコードの例には、手作業でコー ディングされた ToString() メソッドが例として含まれます。
レコードの種類の詳細については、このレコードの探索チュートリアルを参照してください。 init 専用セッター
"*init 専用セッター" によって、オブジェクトのメンバーを初期化するための一貫した構文が提供されます。 プロパティ初期化 子を使用すると、どの値によってどのプロパティが設定されているかが明確にされます。 欠点は、それらのプロパティが設定可能 である必要があることです。C#9.0以降では、プロパティとインデクサーに対して set アクセサーの代わりに init アクセサー を作成できます。 呼び出し元により、プロパティ初期化子構文を使用して作成式でこれらの値を設定することができますが、構 築が完了するとそれらのプロパティは読み取り専用になります。 init 専用セッターによって、状態を変更するためのウィンドウが提 供されます。 構築フェーズが終了すると、そのウィンドウは閉じます。 プロパティ初期化子と with 式の完了を含め、すべての初 期化の後で、構築フェーズは実質的に終了します。
 Deconstruct
    var person = new Person("Bill", "Wagner");
var (first, last) = person;
Console.WriteLine(first);
Console.WriteLine(last);
   Person brother = person with { FirstName = "Paul" };
        Person clone = person with { };
    public record Pet(string Name)
{
    public void ShredTheFurniture() =>
        Console.WriteLine("Shredding furniture");
}
public record Dog(string Name) : Pet(Name)
{
    public void WagTail() =>
        Console.WriteLine("It's tail wagging time");
    public override string ToString()
    {
} }
StringBuilder s = new();
base.PrintMembers(s);
return $"{s.ToString()} is a dog";
 
 init 専用セッターは、記述する任意の型で宣言できます。たとえば、次の構造体では、気象監視構造体が定義されていま す。
    public struct WeatherObservation
{
    public DateTime RecordedAt { get; init; }
    public decimal TemperatureInCelsius { get; init; }
    public decimal PressureInMillibars { get; init; }
    public override string ToString() =>
        $"At {RecordedAt:h:mm tt} on {RecordedAt:M/d/yyyy}: " +
        $"Temp = {TemperatureInCelsius}, with {PressureInMillibars} pressure";
}
 呼び出し元は、プロパティ初期化子構文を使用して値を設定できますが、それでも不変性は維持されます。
ただし、初期化後に監視を変更することは、初期化の外側で init 専用プロパティに代入することによるエラーになります。
init 専用セッターは、派生クラスから基底クラスのプロパティを設定する場合に便利です。 また、基底クラスのヘルパーを使用し て派生プロパティを設定することもできます。 位置指定レコードによって、init 専用セッターを使用してプロパティが宣言されま す。これらのセッターは、with式で使用されます。定義する任意の class または struct に対して、init専用セッターを宣 言できます。
最上位レベルのステートメント
"*最上位レベル ステートメント*" により、多くのアプリケーションから不要な手続きが削除されます。 正規の "Hello World!" プ ログラムについて考えます。
    var now = new WeatherObservation
{
    RecordedAt = DateTime.Now,
    TemperatureInCelsius = 20,
    PressureInMillibars = 998.0m
};
     // Error! CS8852.
now.TemperatureInCelsius = 18;
      using System;
namespace HelloWorld
{
    class Program
    {
} }
static void Main(string[] args)
{
    Console.WriteLine("Hello World!");
}
 何かを行うコード行は1つだけです。最上位レベルステートメントを使用すると、そのすべての定型句を、using ステートメン トと処理を行う 1 行に置き換えることができます。

  1 行だけのプログラムが必要な場合は、 using ディレクティブを削除し、完全修飾型名を使用することができます。
最上位レベル ステートメントを使用できるのは、アプリケーション内の 1 つのファイルだけです。 コンパイラにより、複数のソース ファイルで最上位レベル ステートメントが検出されると、エラーになります。 また、最上位レベル ステートメントを、宣言されたプロ グラムエントリポイントメソッド(通常は Main メソッド)と組み合わせても、エラーになります。ある程度まで、その1つのファイ ルに、通常は Program クラスの Main メソッドに含まれるステートメントが含まれているものと考えることができます。
この機能の最も一般的な用途の 1 つは、教材の作成です。 C# の開発初心者は、正規の "Hello World!" を 1 行または 2 行のコードで作成できます。 余分な手続きは必要ありません。 一方、経験豊富な開発者は、この機能の多くの用途を見つけ ることができます。 最上位レベル ステートメントを使用すると、Jupyter Notebook で提供されるものと同様の実験用にスクリプ トに似たエクスペリエンスを有効にできます。 最上位レベル ステートメントは、小規模なコンソール プログラムとユーティリティに最 適です。 Azure Functions は、最上位レベル ステートメントに最適なユース ケースです。
最も重要なのは、最上位レベル ステートメントでアプリケーションのスコープや複雑さが制限されないことです。 それらのステート メントでは、任意の .NET クラスにアクセスしたり、使用したりできます。 また、コマンド ライン引数や戻り値の使用も制限されま せん。 最上位レベル ステートメントでは、args という名前の文字列の配列にアクセスできます。 最上位レベル ステートメントで 整数値が返される場合、その値は、合成された Main メソッドからの整数のリターンコードになります。最上位レベルステート メントには、非同期式を含めることができます。その場合、合成されたエントリポイントからは Task または Task<int> が返さ れます。
パターン マッチングの拡張機能
C# 9 には、新しいパターン マッチングの機能強化が含まれています。
"*型パターン*" は、変数が型である場合に一致します
"*かっこで囲まれたパターン*" では、パターンの組み合わせの優先順位が適用または強調されます "*接続的 and パターン*"では、両方のパターンが一致することが要求されます
"*離接的 or パターン*"では、どちらかのパターンが一致することが要求されます
"*否定的 not パターン*"では、パターンが一致しないことが要求されます
"*関係パターン*" では、入力が定数より小さい、より大きい、以下、または以上であることが要求されます。
これらのパターンにより、パターンの構文が豊富になります。 次のような例を考えてみてください。
または、省略可能なかっこを使用して、 and が or より優先順位が高いことを明確にします。
最も一般的な使用方法の 1 つは、null チェックの新しい構文です。
  System.Console.WriteLine("Hello World!");
       public static bool IsLetter(this char c) =>
    c is >= 'a' and <= 'z' or >= 'A' and <= 'Z';
     public static bool IsLetterOrSeparator(this char c) =>
    c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z') or '.' or ',';
    using System;
Console.WriteLine("Hello World!");
 
          これらのパターンのいずれも、パターンが許可される任意のコンテキスト ( is パターン式、 switch 式、入れ子になったパター ン、 switch ステートメントの case ラベルのパターン) で使用できます。
パフォーマンスと相互運用
3 つの新機能により、高パフォーマンスを必要とするネイティブ相互運用および低レベル ライブラリのサポートが向上します (ネイ
ティブ サイズの整数、関数ポインター、 localsinit フラグの省略)。
ネイティブサイズの整数 nint と nuint は整数型です。これらは、基になる型System.IntPtrおよびSystem.UIntPtrに よって表されます。 コンパイラによって、これらの型に対する追加の変換と操作がネイティブ int として公開されます。 ネイティブ サイズの整数では、 MaxValue または MinValue のプロパティが定義されます。 これらの値は、ターゲット コンピューターでの整 数のネイティブ サイズに依存するため、コンパイル時の定数として表すことはできません。 これらの値は実行時に読み取り専用 になります。 nint に対する定数値は、[ int.MinValue .. int.MaxValue ]. nuint に対する定数値は、[ uint.MinValue ..
uint.MaxValue ]. コンパイラによって、System.Int32 型と System.UInt32 型を使用するすべての単項演算子と二項演算子 に対して、定数の折りたたみが実行されます。 結果が 32 ビットに収まらない場合、演算は実行時に実行され、定数とは見な されません。 ネイティブ サイズの整数を使用すると、整数演算が広く使用されており、最速のパフォーマンスを実現する必要が あるシナリオで、パフォーマンスを向上させることができます。
関数ポインターでは、ILオペコード ldftn および calli にアクセスするための簡単な構文が提供されます。関数ポインター
           は、新しい delegate_ 構文を使用して宣言できます。 が使用されるデリゲートとは異なり、
出しは同じです。関数ポインターの呼び出しでは、 が必要であることを宣言するには、 delegate* 構文の後に は、 delegate* 宣言の属性を使用して指定できます。
型はポインター型です。 Invoke() メソッドで 型の呼び出しでは calli が使用されます。構文的には、呼び
の呼び出し規約が使用されます。 unmanaged の呼び出し規約 キーワードを追加します。 その他の呼び出し規約
delegate*
  callvirt
delegate*
  managed
  unmanaged
  最後に、System.Runtime.CompilerServices.SkipLocalsInitAttributeを追加することで、 localsinit フラグを生成しない ようコンパイラに指示することができます。 このフラグは、すべてのローカル変数をゼロで初期化するように CLR に指示します。 1.0から、localsinit フラグがC#に対する既定の動作でした。しかし、一部のシナリオでは、ゼロによる初期化を追加する と、パフォーマンスに大きく影響する可能性があります。 特に、 stackalloc を使用する場合です。 そのような場合 は、SkipLocalsInitAttribute を追加できます。 1 つのメソッドまたはプロパティに、または class 、 struct 、 interface に、 さらにはモジュールに対してさえも、それを追加できます。この属性は abstract メソッドに影響しません。実装用に生成され たコードに影響します。
これらの機能により、一部のシナリオでパフォーマンスを向上させることができます。 導入前と導入後の両方で慎重にベンチマー クを行った後でのみ、使用する必要があります。 ネイティブ サイズの整数に関するコードは、複数のターゲット プラットフォーム で、異なる整数サイズを使用して、テストする必要があります。 その他の機能には、アンセーフ コードが必要です。
適合性と完成度の機能
他の多くの機能は、コードをより効率的に記述するのに役立ちます。 C# 9.0 では、作成されるオブジェクトの型が既にわかって
いる場合、 new 式で型を省略できます。 最も一般的な使用方法は、フィールドの宣言です。
ターゲット型の new は、メソッドへの引数として渡す新しいオブジェクトを作成する必要がある場合にも使用できます。次のよう なシグネチャを持つ ForecastFor() メソッドについて考えます。
       private List<WeatherObservation> _observations = new();
     if (e is not null)
{
// ... }
 
          これを、次のように呼び出すことができます。
  var forecast = station.ForecastFor(DateTime.Now.AddDays(2), new());
 この機能のもう 1 つの便利な用途は、init 専用プロパティと組み合わせて、新しいオブジェクトを初期化する場合です。
return new(); ステートメントを使用することで、既定のコンストラクターによって作成されたインスタンスを返すことができます。
同様の機能により、条件式の対象となる型の解決が向上します。 この変更により、2 つの式の間で暗黙的な変換を行う必要 はありませんが、どちらもターゲット型への暗黙的な変換を行うことができます。 多くの場合、この変更に気付くことはありません。 気付くとすれば、以前はキャストを必要としたり、コンパイルされなかったりした一部の条件式が、機能するようになることです。
C#9.0以降では、static 修飾子をラムダ式または匿名メソッドに追加できます。静的なラムダ式は、static ローカル関 数に似ています。静的ラムダまたは匿名メソッドでは、ローカル変数またはインスタンスの状態をキャプチャできません。 static 修飾子により、誤って他の変数がキャプチャされることがなくなります。
共変の戻り値の型を使用すると、override メソッドの戻り値の型を柔軟に指定できます。 override メソッドは、オーバーライド された基本メソッドの戻り値の型から派生した型を返すことができます。 これは、レコードや、仮想クローンまたはファクトリ メソッ ドをサポートするその他の型に役立ちます。
また、 foreach ループによって、それ以外の方法で foreach パターンを満たす拡張メソッド GetEnumerator が認識され、使 用されます。この変更は、非同期パターンやパターンベースの分解など、他のパターンベースのコンストラクションと foreach の 間に整合性があることを意味します。実際、この変更は、あらゆる型に foreach サポートを追加できることを意味します。そ れの使用は、設計においてオブジェクトの列挙に意味があるときのみに限定してください。
次に、ラムダ式に対するパラメーターとして破棄を使用できます。 このようにすると、引数の名前付けを避けることができ、コンパ イラではその使用を避けることができます。任意の引数に対して _ を使用します。詳細については、ラムダ式に関する記事 の「ラムダ式の入力パラメーター」セクションを参照してください。
ようやく、ローカル関数に属性を適用できるようになりました。 たとえば、null 許容属性の注釈をローカル関数に適用できます。 コード ジェネレーターのサポート
2 つの最終機能では、C# コード ジェネレーターがサポートされています。 C# コード ジェネレーターは、roslyn アナライザーまた はコード修正と同じように記述できるコンポーネントです。 違いは、コード ジェネレーターでは、コードが分析され、コンパイル プロ セスの一環として新しいソース コード ファイルが記述されることです。 一般的なコード ジェネレーターでは、属性またはその他の 規則がコードで検索されます。
コード ジェネレーターにより、Roslyn 分析 API を使用して属性または他のコード要素が読み取られます。 その情報を基にし て、コンパイルに新しいコードが追加されます。 ソース ジェネレーターではコードが追加されるだけで、コンパイル中の既存のコー ドの変更は許可されていません。
コード ジェネレーターに対して追加された 2 つの機能は、"部分メソッド構文" の拡張機能と、"*モジュール初期化子*" です。 1つ目は、部分メソッドに対する変更です。C#9.0より前の部分メソッドは private ですが、アクセス修飾子を指定すること はできず、戻り値は void で、 out パラメーターを持つことはできません。 これらの制限は、メソッドの実装を提供しないと、コ ンパイラによって部分メソッドのすべての呼び出しが削除されることを意味しました。 C# 9.0 ではこれらの制限はなくなりました が、部分メソッドの宣言には実装が必要です。 コード ジェネレーターで、その実装を提供できます。 破壊的変更が発生しない よう、コンパイラでは、アクセス修飾子を持たないすべての部分メソッドは、古い規則に従うものと見なされます。 部分メソッドに
  WeatherStation station = new() { Location = "Seattle, WA" };
            private アクセス修飾子が含まれている場合、その部分メソッドは新しい規則によって制御されます。
 public WeatherForecast ForecastFor(DateTime forecastDate, WeatherForecastOptions options)
 
  コード ジェネレーターの 2 つ目の新機能は、"モジュール初期化子" です。 モジュール初期化子 は、ModuleInitializerAttribute 属性が関連付けられているメソッドです。 これらのメソッドは、全体モジュール内の他のフィー ルド アクセスまたはメソッド呼び出しの前にランタイムによって呼び出されます。 モジュール初期化子メソッドは次のようなもので す。
静的でなければなりません パラメーターなしである必要があります
void を返す必要があります
ジェネリック メソッドであってはなりません
ジェネリック クラスに含まれていてはなりません それを含むモジュールからアクセスできる必要があります
最後の項目は事実上、メソッドとそれを含んでいるクラスが internal または public である必要があることを意味します。 メソッ ドをローカル関数にすることはできません。

                        C# 8.0 では、C# 言語に次の機能と機能強化が追加されています。
読み取り専用メンバー 既定のインターフェイス メソッド パターン マッチングの拡張機能:
switch 式 プロパティのパターン タプル パターン 位置指定パターン
using 宣言
静的ローカル関数
破棄可能な ref 構造体
Null 許容参照型 非同期ストリーム 非同期の破棄可能 インデックスと範囲
null 合体割り当て 構築されたアンマネージド型 入れ子になった式の stackalloc verbatim 補間文字列の拡張
C# 8.0 は .NET Core 3.x と .NET Standard 2.1 でサポートされています。 詳細については、「C# 言語のバージョン管理」 を参照してください。
この記事の以降では、これらの機能について簡単に説明します。 詳細な記事がある場合は、それらのチュートリアルと概要への リンクが提供されています。 dotnet try グローバル ツールを使って、これらの機能をご自身の環境で調べることができます。
1. dotnet try グローバル ツールをインストールします。
2. dotnet/try-samples リポジトリを複製します。
3. 現在のディレクトリを、 try-samples リポジトリの csharp8 サブディレクトリに設定します。 4. dotnet try を実行します。
読み取り専用メンバー
構造体のメンバーに readonly 修飾子を適用できます。これは、メンバーが状態を変更しないことを示します。 readonly 修飾子を struct 宣言に適用するよりも詳細になります。次の変更可能な構造体を検討します。
      C# 8.0 の新機能 2020/11/02 • • Edit Online
    public struct Point
{
    public double X { get; set; }
    public double Y { get; set; }
    public double Distance => Math.Sqrt(X * X + Y * Y);
    public override string ToString() =>
        $"({X}, {Y}) is {Distance} from the origin";
}
 
         メソッドでは、ほとんどの構造体と同様に状態を変更しません。 それを示すには、   の宣言に修飾子 を追加します。
ToString が readonly とマークされていない Distance プロパティにアクセスするため、上記の変更により、コンパイラの警告 が生成されます。
コンパイラからは、防御用のコピーを作成する必要があるときに警告されます。 Distance プロパティでは状態を変更しないた め、次のように宣言に readonly 修飾子を追加することで、この警告を修正できます。
readonly 修飾子は読み取り専用プロパティに必要であることに注意してください。 コンパイラでは、 get アクセサーが状態を 変更しないことを想定していないため、 readonly を明示的に宣言する必要があります。 自動実装プロパティは例外です。こ のコンパイラは、自動実装されたすべてのゲッターを readonly として処理します。したがって、ここでは、 X および Y プロパ ティに readonly 修飾子を追加する必要はありません。
コンパイラによって、 readonly メンバーによって状態が変更されないというルールが適用されます。 次のメソッドは、 readonly 修飾子を削除しない限りコンパイルされません。
この機能により、設計の意図を指定し、コンパイラによってそれが適用され、その意図に基づいて最適化が行われるようにするこ とができます。
詳細については、構造体型に関する記事の「 readonly インスタンス メンバー」セクションを参照してください。 既定のインターフェイス メソッド
ここでインターフェイスにメンバーを追加し、それらのメンバーの実装を提供できます。 この言語機能を使用することで、API 作成 者は、インターフェイスの既存の実装とのソースやバイナリの互換性を損なうことなく、新しいバージョンのそのインターフェイスにメ ソッドを追加できます。 既存の実装では既定の実装が 継承 されます。 さらに、この機能により、同様の機能をサポートする Android や Swift を対象とする API を、C# と連携させることができます。 既定のインターフェイス メソッドでは、"traits" 言語 機能のようなシナリオも可能になります。
既定のインターフェイス メソッドにより、多くのシナリオと言語要素が影響を受けます。 最初のチュートリアルでは、既定の実装で のインターフェイスの更新について取り上げています。 その他のチュートリアルとリファレンスの更新は、一般公開に間に合うように 提供されます。
より多くの場所でより多くのパターン
パターン マッチング では、関連はあっても種類が異なるデータをまたがってシェイプに依存する機能を提供するツールが用意さ れています。C#7.0では、is 式と switch ステートメントを使用することで、型パターンと定数パターンの構文が導入されま した。 これらの機能では、データと機能が分かれて存在するプログラミング パラダイムのサポートに向けた最初の試験的なステッ
ToString()
ToString()
    readonly
     public readonly override string ToString() =>
    $"({X}, {Y}) is {Distance} from the origin";
        warning CS8656: Call to non-readonly member 'Point.Distance.get' from a 'readonly' member results in an
implicit copy of 'this'
     public readonly double Distance => Math.Sqrt(X * X + Y * Y);
           public readonly void Translate(int xOffset, int yOffset)
{
X += xOffset;
    Y += yOffset;
}
   
  プが示されました。 業界はマイクロサービスと他のクラウド ベース アーキテクチャに向けて移動しており、他の言語ツールが必要 になっています。
C# 8.0 では、このボキャブラリが展開されて、コードのより多くの場所で、より多くのパターン式を使用できます。 データと機能が 分かれているときは、これらの機能を検討してください。 アルゴリズムがオブジェクトのランタイム型以外の事実に依存している場 合は、パターン マッチングを検討してください。 これらの手法では、設計を表現する別の方法が提供されます。
新しい場所での新しいパターンだけでなく、C# 8.0 では 再帰パターン が追加されています。 パターン式の結果は式です。 再 帰パターンは、単に、別のパターン式の出力に適用されるパターン式です。
switch 式
多くの場合、 switch ステートメントでは、その各 case ブロックで値が生成されます。 switch 式 を使用すると、より簡潔な 式の構文を使用できます。反復的な case や break キーワード、および中かっこの数が少なくなります。たとえば、虹の色を 示す次のような列挙型について考えます。
     public enum Rainbow
{
    Red,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet
}
  アプリケーションで R 、 G 、および B コンポーネントから構成される RGBColor 型が定義されている場合は、switch 式を含む 次のメソッドを使用して、Rainbow の値をそのRGB値に変換できます。
     public static RGBColor FromRainbow(Rainbow colorBand) =>
    colorBand switch
    {
        Rainbow.Red    => new RGBColor(0xFF, 0x00, 0x00),
        Rainbow.Orange => new RGBColor(0xFF, 0x7F, 0x00),
        Rainbow.Yellow => new RGBColor(0xFF, 0xFF, 0x00),
        Rainbow.Green  => new RGBColor(0x00, 0xFF, 0x00),
        Rainbow.Blue   => new RGBColor(0x00, 0x00, 0xFF),
        Rainbow.Indigo => new RGBColor(0x4B, 0x00, 0x82),
        Rainbow.Violet => new RGBColor(0x94, 0x00, 0xD3),
        _              => throw new ArgumentException(message: "invalid enum value", paramName:
nameof(colorBand)),
    };
 この構文ではいくつかの点が改良されています。
変数は switch キーワードの前にあります。順序を変えることで、switchステートメントからのswitch式の視覚的な区別 が容易になります。
case 要素と : 要素は、 => に置き換えられます。 より簡潔でわかりやすくなります。
default ケースは、 _ 破棄に置き換えられます。 本体は式であり、ステートメントではありません。
従来の switch ステートメントを使用した同等のコードと比較してください。
   
  プロパティ パターン
プロパティ パターン を使用すると、調査対象のオブジェクトのプロパティと照合することができます。 購入者の住所に基づいて 消費税を計算する必要があるeコマースサイトについて考えます。そのような計算は、Address クラスの主な役割ではありま せん。時間とともに、おそらくは住所の形式の変更より頻繁に、変更されます。消費税の金額は、住所の State プロパティに 依存します。 次のメソッドでは、プロパティ パターンを使用して、住所と価格から消費税を計算しています。
     public static decimal ComputeSalesTax(Address location, decimal salePrice) =>
    location switch
    {
        { State: "WA" } => salePrice * 0.06M,
        { State: "MN" } => salePrice * 0.075M,
        { State: "MI" } => salePrice * 0.05M,
        // other cases removed for brevity...
        _ => 0M
};
 パターン マッチングにより、このアルゴリズムを表現するための簡潔な構文が作成されます。 タプル パターン
いくつかのアルゴリズムは複数の入力に依存しています。 タプル パターン を使うと、 タプルとして表現された複数の値に基づい て切り替えを行うことができます。 " rock、paper、scissors (じゃんけん) " ゲーム用の switch 式を示すコードを以下に示しま す。
    public static string RockPaperScissors(string first, string second)
    => (first, second) switch
    {
        ("rock", "paper") => "rock is covered by paper. Paper wins.",
        ("rock", "scissors") => "rock breaks scissors. Rock wins.",
        ("paper", "rock") => "paper covers rock. Paper wins.",
        ("paper", "scissors") => "paper is cut by scissors. Scissors wins.",
        ("scissors", "rock") => "scissors is broken by rock. Rock wins.",
        ("scissors", "paper") => "scissors cuts paper. Scissors wins.",
        (_, _) => "tie"
    };
 メッセージは勝者を示しています。 破棄のケースは、引き分けとなる 3 つの組み合わせ、またはその他のテキスト入力を表しま す。
   public static RGBColor FromRainbowClassic(Rainbow colorBand)
{
    switch (colorBand)
    {
        case Rainbow.Red:
            return new RGBColor(0xFF, 0x00, 0x00);
        case Rainbow.Orange:
            return new RGBColor(0xFF, 0x7F, 0x00);
        case Rainbow.Yellow:
            return new RGBColor(0xFF, 0xFF, 0x00);
        case Rainbow.Green:
            return new RGBColor(0x00, 0xFF, 0x00);
        case Rainbow.Blue:
            return new RGBColor(0x00, 0x00, 0xFF);
        case Rainbow.Indigo:
            return new RGBColor(0x4B, 0x00, 0x82);
        case Rainbow.Violet:
            return new RGBColor(0x94, 0x00, 0xD3);
        default:
            throw new ArgumentException(message: "invalid enum value", paramName: nameof(colorBand));
}; }
 
  位置指定パターン
一部の型には、そのプロパティを個別の変数に分解する Deconstruct メソッドが含まれています。 Deconstruct メソッドにア クセスできる場合、 位置指定パターン を使ってオブジェクトのプロパティを検査し、パターン用にそれらのプロパティを使うことがで きます。 X と Y の個別の変数を作成する Deconstruct メソッドを含む Point クラスの例を次に示します。
       public class Point
{
    public int X { get; }
    public int Y { get; }
    public Point(int x, int y) => (X, Y) = (x, y);
    public void Deconstruct(out int x, out int y) =>
        (x, y) = (X, Y);
}
 さらに、クアドラントのさまざまな位置を表す次の列挙を検討してください。
    public enum Quadrant
{
    Unknown,
    Origin,
    One,
    Two,
    Three,
    Four,
    OnBorder
}
 次のメソッドでは、 位置指定パターン を使用して、 x と y の値を抽出しています。 その後、 when 句を使用して、点の Quadrant を決定します。
     static Quadrant GetQuadrant(Point point) => point switch
{
    (0, 0) => Quadrant.Origin,
    var (x, y) when x > 0 && y > 0 => Quadrant.One,
    var (x, y) when x < 0 && y > 0 => Quadrant.Two,
    var (x, y) when x < 0 && y < 0 => Quadrant.Three,
    var (x, y) when x > 0 && y < 0 => Quadrant.Four,
    var (_, _) => Quadrant.OnBorder,
    _ => Quadrant.Unknown
};
 前のswitchでの破棄パターンは、x または y のどちらか一方が0のときに一致しますが、両方とも0のときには一致しませ ん。 switch 式は、値を生成するか、または例外をスローする必要があります。 どのケースとも一致しない場合、switch 式は例 外をスローします。 可能性のあるすべてのケースが switch 式で網羅されていない場合、コンパイラで警告が生成されます。
このパターン マッチングの高度なチュートリアルで、パターン マッチング手法を確認できます。 using 宣言
using 宣言 は、 using キーワードが前に付いている変数宣言です。 宣言されている変数を外側のスコープの最後に破棄 する必要があることを、コンパイラに伝えます。 たとえば、テキスト ファイルを書き込む次のようなコードについて考えます。

    上の例では、メソッドの右中かっこに達した時点で、ファイルは破棄されます。 そこは、 file が宣言されているスコープの末端 です。 上記のコードは、従来の using ステートメントを使用する次のコードと同等です。
    static int WriteLinesToFile(IEnumerable<string> lines)
{
    using (var file = new System.IO.StreamWriter("WriteLines2.txt"))
    {
        int skippedLines = 0;
        foreach (string line in lines)
        {
            if (!line.Contains("Second"))
            {
                file.WriteLine(line);
            }
else {
                skippedLines++;
            }
}
        return skippedLines;
    } // file is disposed here
}
 上の例では、 using ステートメントに関連付けられている右中かっこに達すると、ファイルは破棄されます。 どちらの場合も、コンパイラでは Dispose() の呼び出しが生成されます。 using ステートメント内の式を破棄できない場合、
コンパイラによってエラーが生成されます。 静的ローカル関数
static 修飾子をローカル関数に追加することにより、ローカル関数で外側のスコープの変数がキャプチャ(参照)されないよう にすることができます。それを行うと、CS8421 "静的ローカル関数は<variable>への参照を含むことができない"が生成され ます。
次のコードについて考えてみましょう。ローカル関数 は、外側のスコープ(M メソッド)で宣言されている変数 y にアクセスしています。そのため、 では 修飾子を宣言することはできません。
    LocalFunction
  LocalFunction
static
   static int WriteLinesToFile(IEnumerable<string> lines)
{
    using var file = new System.IO.StreamWriter("WriteLines2.txt");
    int skippedLines = 0;
    foreach (string line in lines)
    {
        if (!line.Contains("Second"))
        {
            file.WriteLine(line);
        }
else {
            skippedLines++;
        }
    }
    // Notice how skippedLines is in scope here.
    return skippedLines;
    // file is disposed here
}
 
       次のコードには、静的ローカル関数が含まれています。 外側のスコープ内のどの変数にもアクセスしていないため、静的にするこ とができます。
    int M() {
    int y = 5;
    int x = 7;
    return Add(x, y);
    static int Add(int left, int right) => left + right;
}
 破棄可能な ref 構造体
ref 修飾子付きで宣言されている struct ではインターフェイスを実装できないので、IDisposableを実装できません。した がって、 を破棄できるようにするには、アクセス可能な void Dispose() メソッドを持っている必要があります。 こ
   ref struct
 の機能は、
null 許容参照型
宣言にも当てはまります。
readonly ref struct
null 許容注釈コンテキスト内では、参照型のすべての変数は、 null 非許容参照型 と見なされます。 変数が null 許容で あることを示したい場合は、型名に ? を追加し、null許容参照型として変数を宣言する必要があります。
null 非許容参照型の場合は、コンパイラでフロー分析を使用して、ローカル変数が宣言時に null 以外の値に初期化されるこ とが確認されます。 フィールドは、構築時に初期化される必要があります。 変数が使用可能ないずれかのコンストラクターの呼 び出しまたは初期化子によって設定されていない場合、コンパイラで警告が生成されます。 さらに、null 非許容参照型に、 null になる可能性がある値を割り当てることはできません。
null 許容参照型の場合は、null に割り当てられたり初期化されたりしないことは確認されません。 ただし、null 許容参照型 の変数が null 非許容参照型にアクセスしたり割り当てられたりするときは、その前に、コンパイラでフロー分析を使用して、null 値のチェックが行われます。
詳しくは、「null 許容参照型」の概要をご覧ください。 この null 許容参照型チュートリアルの新しいアプリケーションを使って、 自分で試してみてください。 既存のコードベースを null 許容参照型を使用するように移行する手順について詳しくは、null 許 容参照型を使用するようにアプリケーションを移行する方法についてのチュートリアルに関する記事をご覧ください。
非同期ストリーム
C# 8.0 以降では、ストリームを非同期的に作成して使用することができます。 非同期ストリームを返すメソッドには、次の 3 つ の特徴があります。
1. async 修飾子を使用して宣言されています。
2. IAsyncEnumerable<T> を返します。
3. メソッドに、連続する要素を非同期ストリームで返すための yield return ステートメントが含まれています。
非同期ストリームを使用するには、ストリームの要素を列挙するときに、 foreach キーワードの前に await キーワードを追加 する必要があります。 await キーワードを追加するには、非同期ストリームを列挙するメソッドが、 async 修飾子を使用して
     int M() {
    int y;
    LocalFunction();
    return y;
    void LocalFunction() => y = 0;
}
 
             宣言されていて、async メソッドに対して許可される型を返すようになっている必要があります。通常は、Taskまたは Task<TResult> を返すことを意味します。 ValueTask または ValueTask<TResult> にすることもできます。 同じメソッドで非 同期ストリームの使用と生成の両方を行うことができます。これは、そのメソッドが IAsyncEnumerable<T> を返すことを意味し ます。 次のコードでは、0 から 19 の値のシーケンスが生成され、各値の間に 100 ミリ秒の待機が設けられています。
    public static async System.Collections.Generic.IAsyncEnumerable<int> GenerateSequence()
{
    for (int i = 0; i < 20; i++)
    {
        await Task.Delay(100);
        yield return i;
    }
}
  シーケンスの列挙は、 await foreach ステートメントを使用して行います。
非同期ストリームの作成と使用に関するチュートリアルを使用して、自分で非同期ストリームを試すことができます。 既定では、 ストリーム要素はキャプチャされたコンテキストで処理されます。 コンテキストのキャプチャを無効にする場合 は、TaskAsyncEnumerableExtensions.ConfigureAwait 拡張メソッドを使用します。 同期コンテキストについて、および現在 のコンテキストのキャプチャについての詳細は、「タスク ベースの非同期パターンの利用」を参照してください。
非同期の破棄可能
C# 8.0 以降、この言語では System.IAsyncDisposable インターフェイスを実装する非同期の破棄可能な型がサポートされま す。 await using ステートメントを使用し、非同期破棄可能オブジェクトを操作します。 詳細については、「DisposeAsync メソッドの実装」の記事を参照してください。
インデックスと範囲
インデックスと範囲には、シーケンス内の 1 つの要素または範囲にアクセスできる簡潔な構文が用意されています。 この言語のサポートでは、次の 2 つの新しい型と 2 つの新しい演算子を使用しています。
    await foreach (var number in GenerateSequence())
{
    Console.WriteLine(number);
}
  System.Index はシーケンスとしてインデックスを表します。
indexfromend演算子の ^。シーケンスの末尾から相対的なインデックスを指定します。 System.Range はシーケンスのサブ範囲を表します。
範囲演算子の .. 。範囲の先頭と末尾をそのオペランドとして指定します。
インデックスのルールから始めましょう。配列 sequence を考えます。 0 インデックスは デックスは sequence[sequence.Length] と同じです。 と同様に、 ローすることに注意してください。任意の数値 n の場合、インデックス ^n は
と同じです。 ^0 イン は例外をス
と同じです。
     sequence[sequence.Length]
範囲は、範囲の 先頭 と 末尾 を指定します。 範囲の先頭は包含ですが、範囲の末尾は排他です。つまり、" 先頭 " は範囲 に含まれますが、"末尾"は範囲に含まれません。範囲 [0..^0] は、[0..sequence.Length] が範囲全体を表すのと同じ ように、範囲全体を表します。
いくつか例を見てみましょう。 先頭および末尾からのインデックスの注釈が付けられた、次のような配列について考えます。
sequence[0]
sequence[^0]
 sequence.Length - n
  
      最後の単語は、 ^1 というインデックスで取得することができます。
次のコードでは、単語"quick"、"brown"、"fox"から成る部分範囲が作成されます。それには、words[1] から words[3] までが含まれます。要素 words[4] が範囲内にありません。
次のコードでは、"lazy"と"dog"の部分範囲が作成されます。それには、words[^2] と words[^1] が含まれます。末尾イ ンデックス words[^0] は含まれません。
次の例では、先頭と末尾の一方または両方が開いている範囲が作成されます。
変数として範囲を宣言することもできます。
その場合、範囲は文字 [ と ] の内側で使用できます。
配列でインデックスと範囲がサポートされるだけではありません。 string、Span<T>、または ReadOnlySpan<T> と共にイン デックスと範囲を使用することもできます。 詳細については、「インデックスと範囲の型のサポート」を参照してください。
チュートリアルでのインデックスと範囲について詳しくは、「Indices and ranges (インデックスと範囲)」で調べることができます。 null 合体割り当て
C#8.0では、null合体割り当て演算子 ??= が導入されています。左側のオペランドが null に評価された場合にのみ、 ??= 演算子を使用して右側のオペランドの値を左側のオペランドに割り当てることができます。
    Console.WriteLine($"The last word is {words[^1]}");
// writes "dog"
      var quickBrownFox = words[1..4];
      var lazyDog = words[^2..^0];
     var allWords = words[..]; // contains "The" through "dog".
var firstPhrase = words[..4]; // contains "The" through "fox"
var lastPhrase = words[6..]; // contains "the", "lazy" and "dog"
   Range phrase = 1..4;
   var text = words[phrase];
    var words = new string[]
{
};
// index from start "The", //0
"quick", //1 "brown", //2 "fox", //3 "jumped", //4 "over", //5 "the", //6 "lazy", //7 "dog" //8
//9 (or words.Length)
index from end
^9
^8
^7
^6
^5
^4
^3
^2
^1
^0
 
         詳細については、「?? and ??= 演算子」の記事を参照してください。 構築されたアンマネージド型
C# 7.3 以前では、構築された型 (少なくとも 1 つの型引数を含む型) はアンマネージド型にできません。 C# 8.0 以降、アンマ ネージド型のフィールドのみが含まれている場合、構築された値型はアンマネージドになります。
たとえば、次の Coords<T> ジェネリック型の定義があるとします。
この Coords<int> 型は、C#8.0以降ではアンマネージド型です。あらゆるアンマネージド型の場合と同様に、この型の変数 へのポインターを作成したり、この型のインスタンスのスタックにメモリ ブロックを割り当てたりすることができます。
詳細については、「アンマネージド型」を参照してください。 入れ子になった式の stackalloc
C# 8.0 以降、stackalloc 式の結果が System.Span<T> または System.ReadOnlySpan<T> 型になる場合、他の式で stackalloc 式を使用できます。
verbatim 補間文字列の拡張
verbatim 補間文字列において、 $ および @ のトークンの順序は任意です。 $@"..." と @$"..." は両方とも有効な verbatim補間文字列です。以前のバージョンのC#では、$ トークンは @ トークンの前に記述する必要があります。
     public struct Coords<T>
{
public T X;
public T Y; }
      Span<Coords<int>> coordinates = stackalloc[]
{
    new Coords<int> { X = 0, Y = 0 },
    new Coords<int> { X = 0, Y = 3 },
    new Coords<int> { X = 4, Y = 0 }
};
      Span<int> numbers = stackalloc[] { 1, 2, 3, 4, 5, 6 };
var ind = numbers.IndexOfAny(stackalloc[] { 2, 4, 6, 8 });
Console.WriteLine(ind);  // output: 1
      List<int> numbers = null;
int? i = null;
numbers ??= new List<int>();
numbers.Add(i ??= 17);
numbers.Add(i ??= 20);
Console.WriteLine(string.Join(" ", numbers));  // output: 17 17
Console.WriteLine(i);  // output: 17
 
                  C# 7.0 - C# 7.3 では、多くの機能が追加され、C# での開発エクスぺリエンスが段階的に改善されました。 この記事では、新し い言語機能とコンパイラ オプションの概要について説明します。 .NET Framework ベースのアプリケーションでサポートされてい る最新バージョンである C# 7.3 の動作について説明します。
C# 7.1 で言語バージョンの選択の構成要素が追加され、これにより、プロジェクト ファイルでコンパイラ言語バージョンが指定で きるようになりました。
C# 7.0 - 7.3 で C# 言語に追加された機能とテーマは次のとおりです。
タプルと破棄
複数のパブリック フィールドを含む、軽量で名前のない型を作成できます。 コンパイラおよび IDE ツールでは、このよう な型のセマンティクスが認識されます。 破棄は、割り当てられた値を考慮しない場合に割り当てで使用された、一時的な書き込み専用の値です。 タプル およびユーザー定義の型を分解する場合や、メソッドを out パラメーターを使用して呼び出す場合に特に便利で す。
パターン一致
これらの型のメンバーの任意の型と値に基づいて、分岐ロジックを作成できます。
async Main メソッド
アプリケーションのエントリポイントに async 修飾子を設定できます。
ローカル関数
関数を他の関数の中に入れ子にして、関数のスコープと可視性を制限することができます。
式形式のメンバーの追加
式を使用して作成できるメンバーが増加しました。
throw 式
throw がステートメントだったためにこれまで許可されなかったコードコンストラクトで例外をスローできるようになりま
した。
default リテラル式 ターゲットの種類を推論できるとき、既定の値式で既定のリテラル式を使用できます。
数値リテラルの構文の改善
新しいトークンにより、数値定数の読みやすさが向上します。
out 変数
out の値は、それが使用されるメソッドの引数としてインラインで宣言できます。
末尾以外の名前付き引数
名前付き引数の後ろに位置引数を続けることができます。
アクセス修飾子
アクセス修飾子によって、同じアセンブリ内の派生クラスのアクセスが有効になります。
オーバーロード解決の改善
オーバーロードの解決のあいまいさを解決するための新しい規則。
安全で効率的なコードを記述するための手法
参照セマンティクスを使用したさまざまな値の型の使用を有効にする、構文の機能強化の組み合わせ。 最後に、コンパイラに新しいオプションが追加されました。
  private protected
 private protected
  -refout と -refonly :参照アセンブリの生成を制御します。
C#7.0-C#7.3の新機能 2021/03/06 • • Edit Online
 
     : オープン ソース ソフトウェア (OSS) のアセンブリの署名を可能にします。 : ソース ディレクトリのマッピングを提供します。
この記事の残りでは、各機能の概要について説明します。 各機能について、背後にある論拠と構文について説明します。 dotnet try グローバル ツールを使って、これらの機能をご自身の環境で調べることができます。
1. dotnet try グローバル ツールをインストールします。
2. dotnet/try-samples リポジトリを複製します。
3. 現在のディレクトリを、try-samples リポジトリの csharp7 サブディレクトリに設定します。 4. dotnet try を実行します。
タプルと破棄
C# には、設計の意図を説明するために使用される、クラスと構造体の豊富な構文が用意されています。 ところが、場合によっ ては、その豊富な構文を使用するために、余分な作業が必要になることがあります。この場合、メリットはごくわずかです。 複数 のデータ要素を含む単純な構造を必要とするメソッドを記述することはよくあります。 このようなシナリオをサポートするために、 C# には "タプル" が追加されました。 タプルとは、データ メンバーを表す複数のフィールドを含む軽量なデータ構造です。 フィー ルドは検証されず、独自のメソッドを定義することはできません。 C# のタプル型は、 == と != をサポートしています。 詳しく は、
各メンバーに値を割り当て、任意でタプルの各メンバーにセマンティック名を付けることでタプルを作成できます。
namedLetters タプルには、 Alpha と Beta と呼ばれるフィールドが含まれています。 これらの名前は、コンパイル時にのみ存 在し、実行時にリフレクションを使用してタプルを検査するときなどには保持されません。
タプルの割り当てでは、代入の右辺でフィールドの名前を指定することもできます。
状況によっては、メソッドから返されたタプルのメンバーをばらすことが必要になる場合もあります。 そのためには、タプル内のそれ ぞれの値に対して別個の変数を宣言します。 このばらす行為は、タプルの 分解 と呼ばれます。
.NETでも任意の型に同様の分解を指定することができます。クラスのメンバーとして Deconstruct メソッドを記述します。そ の Deconstruct メソッドは、抽出する各プロパティ用に一連の out 引数を提供します。 次の Point クラスを考えてみましょ う。このクラスは、 X 座標と Y 座標を抽出するデコンストラクター メソッドを指定しています。
-publicsign
   -pathmap
       NOTE
タプルは C# 7.0 より前で使用できましたが、効率的でなく、言語サポートがありませんでした。 これは、タプル要素が Item1 や Item2 などとしてのみ参照できることを意味しました。 C# 7.0 では、タプルの言語サポートが導入されたことで、新しい、より効率的なタプル型を使 用するフィールドのセマンティック名が有効になります。
     (string Alpha, string Beta) namedLetters = ("a", "b");
Console.WriteLine($"{namedLetters.Alpha}, {namedLetters.Beta}");
      var alphabetStart = (Alpha: "a", Beta: "b");
Console.WriteLine($"{alphabetStart.Alpha}, {alphabetStart.Beta}");
     (int max, int min) = Range(numbers);
Console.WriteLine(max);
Console.WriteLine(min);
   
   Point をタプルに割り当てて、個々のフィールドを抽出できます。
タプルを何度初期化しても、代入の右項に使用される変数は、タプル要素に使用するものと同じ名前になります。タプル要素 の名前は、タプルの初期化に使用される変数から推測できます。
この機能の詳細については、タプルの型に関する記事を参照してください。
out パラメーターを使用してタプルを分解したりメソッドを呼び出したりする場合に、使用する予定がなく、考慮にも入れない 値の変数の定義を強制されることが多くあります。 C# ではこのシナリオを処理するために 破棄 のサポートを追加しています。 破棄は名前が _ (アンダースコア(_)文字)の書き込み専用の変数で、破棄するすべての値をこの1つの変数に割り当てるこ とができます。 破棄は未割り当ての変数に似ています。代入ステートメントとは異なり、破棄はコードで使用できません。
次のシナリオでは破棄はサポートされません。
タプルまたはユーザー定義の型を分解する場合。
out パラメーターを使用してメソッドを呼び出す場合。
is および switch ステートメントによるパターン マッチング操作。 割り当ての値を破棄として明示的に識別する必要がある場合の、スタンドアロン識別子。
次の例では、ある都市の2つの異なる年度のデータを含む6つのタプルを戻す QueryCityDataForYears メソッドを定義してい ます。 この例のメソッド呼び出しでは、メソッドによって戻された 2 つの人口の値のみが考慮されているため、タプルの残りの値は タプルの分解時に破棄として扱われます。
    var p = new Point(3.14, 2.71);
(double X, double Y) = p;
     int count = 5;
string label = "Colors used in the map";
var pair = (count, label); // element names are "count" and "label"
     public class Point
{
    public Point(double x, double y)
        => (X, Y) = (x, y);
    public double X { get; }
    public double Y { get; }
    public void Deconstruct(out double x, out double y) =>
        (x, y) = (X, Y);
}
 
     詳細については、破棄に関するページを参照してください。 パターン マッチング
"パターン マッチング" は、コード内の制御フローを新しい方法で表現できるようにする一連の機能です。 変数の型、値、または プロパティの値をテストできます。 これらの手法により、より読みやすいコード フローが作成されます。
パターン マッチングでは、 is 式と switch 式がサポートされています。 どちらの式でも、オブジェクトとそのプロパティを検査し て、そのオブジェクトが必要なパターンを満たしているかどうかを判定できます。 パターンに追加の規則を指定するには、 when キーワードを使用します。
is パターン式を使用すると、使い慣れた is 演算子を拡張し、その型を超えてオブジェクトを照会したり、1つの命令で結 果を割り当てたりできます。次のコードでは、変数が int であるかどうかが確認されます。intの場合、現在の合計に追加さ れます。
先の小さな例では、 is 式の拡張が示されています。 値の型や参照型に対してテストしたり、正しい型の新しい変数に成功 した結果を割り当てたりできます。
switch一致式には、既にC#言語に含まれている switch ステートメントに基づいた、使い慣れた構文があります。更新さ れた switch 式には新しいコンストラクトがいくつか含まれます。
     if (input is int count)
    sum += count;
    using System;
using System.Collections.Generic;
public class Example
{
    public static void Main()
    {
        var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);
        Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}");
    }
    private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int
year2)
    {
        int population1 = 0, population2 = 0;
        double area = 0;
        if (name == "New York City")
        {
            area = 468.48;
            if (year1 == 1960)
            {
                population1 = 7781984;
            }
            if (year2 == 2010)
            {
                population2 = 8175133;
            }
            return (name, area, year1, population1, year2, population2);
        }
        return ("", 0, 0, 0, 0, 0);
    }
}
// The example displays the following output:
//      Population change, 1960 to 2010: 393,149

     式を制御する型は、整数型、Enum 型、   、あるいはそれらの型のいずれかに対応するnull許容型に制 限されなくなります。 任意の型を使用できます。
各 case ラベルで switch 式の型をテストできます。 is 式と同様に、その型に新しい変数を割り当てることができます。
when 句を追加し、その変数で条件をさらにテストできます。
case ラベルの順序が重要になります。一致する最初の分岐が実行されます。他の分岐はスキップされます。
次のコードでこれらの新しい機能を確認できます。
switch
     public static int SumPositiveNumbers(IEnumerable<object> sequence)
{
    int sum = 0;
    foreach (var i in sequence)
    {
switch (i) {
            case 0:
                break;
            case IEnumerable<int> childSequence:
            {
                foreach(var item in childSequence)
                    sum += (item > 0) ? item : 0;
break; }
            case int n when n > 0:
                sum += n;
                break;
            case null:
                throw new NullReferenceException("Null found in sequence");
            default:
                throw new InvalidOperationException("Unrecognized type");
} }
return sum; }
  はおなじみの定数パターンです。
は型パターンです。
は when 条件が追加された型パターンです。
は null パターンです。 はおなじみの既定ケースです。
C#7.1 以降では、 is 型パターンと switch 型パターンのパターン式は、ジェネリック型パラメーターの型を持つことができます。 これは struct 型か class 型のいずれかである可能性がある型を確認し、ボックス化を回避するときに最も役立ちます。
パターン マッチングの詳細については、C# のパターン マッチングを参照してください。 async main
asyncmainメソッドにより、Main メソッドで await を使用できます。以前は次のように記述する必要がありました。
case 0:
 case IEnumerable<int> childSequence:
 case int n when n > 0:
 case null:
 default:
string
        static int Main()
{
    return DoAsyncWork().GetAwaiter().GetResult();
}
 それが次のように記述できるようになりました。

   プログラムによって終了コードが返されない場合、Taskを返す Main メソッドを宣言できます。
プログラミング ガイドの async main の記事に詳細があります。 ローカル関数
クラスの多くの設計には、1 つの場所からのみ呼び出されるメソッドが含まれます。 このような追加のプライベート メソッドを使用 することで、各メソッドのサイズを小さくし、その焦点を絞ることができます。 ローカル関数 を使用すると、別のメソッドのコンテキス ト内でメソッドを宣言することができます。 ローカル関数のおかげで、クラスを読み取る際に、ローカル メソッドはそれ自体が宣言 されているコンテキストからしか呼び出されないことが、簡単にわかります。
ローカル関数には、パブリック反復子メソッドとパブリック非同期メソッドという 2 つの一般的なユース ケースがあります。 どちらの 種類のメソッドも、プログラマーが期待するよりも遅くエラーを報告するコードを生成します。 反復子メソッドの場合、例外が検 出されるのは、返されたシーケンスを列挙するコードを呼び出した場合のみです。 非同期メソッドの場合、例外が検出されるの は、返された Task が待機状態になったときのみです。次の例では、ローカル関数を使用し、反復子の実装からパラメーター 検証を分ける動作を確認できます。
    static async Task Main()
{
    await SomeAsyncMethod();
}
     public static IEnumerable<char> AlphabetSubset3(char start, char end)
{
    if (start < 'a' || start > 'z')
        throw new ArgumentOutOfRangeException(paramName: nameof(start), message: "start must be a letter");
    if (end < 'a' || end > 'z')
        throw new ArgumentOutOfRangeException(paramName: nameof(end), message: "end must be a letter");
    if (end <= start)
        throw new ArgumentException($"{nameof(end)} must be greater than {nameof(start)}");
    return alphabetSubsetImplementation();
    IEnumerable<char> alphabetSubsetImplementation()
    {
} }
for (var c = start; c < end; c++)
    yield return c;
 同じ手法を async メソッドで使用すると、引数の検証で発生する例外が非同期操作の開始前にスローされることを保証でき ます。
   static async Task<int> Main()
{
    // This could also be replaced with the body
    // DoAsyncWork, including its await expressions:
    return await DoAsyncWork();
}
 
   次の構文がサポートされるようになりました。
属性 SomeThingAboutFieldAttribute は、 SomeProperty のコンパイラによって生成されるバッキング フィールドに適用されま す。 詳しくは、C# プログラミング ガイドの「属性」を参照してください。
式形式のメンバーの追加
C# 6 では、メンバー関数の式形式のメンバーと読み取り専用プロパティが導入されました。 C# 7.0 では、式として実装できる 許可されたメンバーが拡張されます。C#7.0では、"コンストラクター"、"ファイナライザー"、get アクセサー、および set アクセ サーを "プロパティ" と "インデクサー" に実装できます。 それぞれの例を次のコードに示します。
    [field: SomeThingAboutFieldAttribute]
public int SomeProperty { get; set; }
       NOTE
ローカル関数によってサポートされる設計の中には、"ラムダ式" を使用して実現できるものもあります。 詳細については、ローカル関数とラムダ 式に関するページをご覧ください。
     // Expression-bodied constructor
public ExpressionMembersExample(string label) => this.Label = label;
// Expression-bodied finalizer
~ExpressionMembersExample() => Console.Error.WriteLine("Finalized!");
private string label;
// Expression-bodied get / set accessors.
public string Label
{
get => label;
    set => this.label = value ?? "Default label";
}
    public Task<string> PerformLongRunningWork(string address, int index, string name)
{
    if (string.IsNullOrWhiteSpace(address))
        throw new ArgumentException(message: "An address is required", paramName: nameof(address));
    if (index < 0)
        throw new ArgumentOutOfRangeException(paramName: nameof(index), message: "The index must be non-
negative");
    if (string.IsNullOrWhiteSpace(name))
        throw new ArgumentException(message: "You must supply a name", paramName: nameof(name));
    return longRunningWorkImplementation();
    async Task<string> longRunningWorkImplementation()
    {
} }
var interimResult = await FirstWork(address);
var secondResult = await SecondStep(index, name);
return $"The results are {interimResult} and {secondResult}. Enjoy.";
 
       式形式のメンバー用のこれらの新しい場所は、C# 言語の重要なマイルストーンです。これらの機能は、オープン ソースの Roslyn プロジェクトに関わるコミュニティ メンバーによって実装されました。
メソッドを式のようなメンバーに変更することは、バイナリ互換性がある変更です。 throw 式
C#では、throw は常にステートメントでした。 throw は式ではなくステートメントであるため、使用できないC#コンストラクト がありました。 これには、条件式、null 結合式、および一部のラムダ式が含まれます。 式形式のメンバーが追加されたことによ り、さらに多くの場所で throw 式が役に立つようになりました。C#7.0では、このようなコンストラクトを記述できるよう に、throw 式が導入されています。
この導入により、式ベースのコードをたくさん記述することが簡単になります。 エラー チェックのためにステートメントを追加する必 要はありません。
既定のリテラル式
既定のリテラル式は既定の値式の拡張版です。 これらの式によって変数が初期化され、既定値になります。 以前は次のよう に記述していました。
それが今では、初期化の右項で種類を省略できるようになりました。
詳しくは、「default 演算子」記事の「default リテラル」セクションをご覧ください。 数値リテラルの構文の改善
数値定数を読み間違えると、コードを初めて読むときにコードを理解するのが難しくなる場合があります。 ビット マスクやその他 の記号を用いた値では誤解を招きやすくなります。 C# 7.0 では、使用目的に応じて最も読みやすい形式で数値を記述しで きるように、バイナリ リテラル と 桁区切り文字 という 2 つの新機能が導入されました。
ビット マスクを作成しているときや、数値をバイナリで表現するとコードが最も読みやすくなる場合は、数字をバイナリで記述しま す。
定数の先頭にある 0b は、数値が2進数として記述されていることを示します。2進数は長くなる可能性があるため、前の 例の2進定数に示されているように、_ を桁区切り文字として導入すると、ビットパターンが見やすくなることがよくあります。 桁区切り記号は定数のどこにでも置くことができます。 10 進数の場合は、3 桁の区切り記号として使用するのが一般的で す。16進と2進の数値リテラルの先頭に _ を使用できます。
  Func<string, bool> whereClause = default(Func<string, bool>);
   Func<string, bool> whereClause = default;
     public const int Sixteen =   0b0001_0000;
public const int ThirtyTwo = 0b0010_0000;
public const int SixtyFour = 0b0100_0000;
public const int OneHundredTwentyEight = 0b1000_0000;
    NOTE
この例ではファイナライザーは必要ありませんが、その構文を紹介するために示しています。 アンマネージ リソースを解放する必要がない限 り、クラスにファイナライザーを実装しないでください。 また、アンマネージ リソースを直接管理する代わりに、SafeHandle クラスの使用を検討 する必要もあります。
 
    桁区切り記号は、 decimal 型、 float 型、 double 型でも使用できます。
    public const double AvogadroConstant = 6.022_140_857_747_474e23;
public const decimal GoldenRatio = 1.618_033_988_749_894_848_204_586_834_365_638_117_720_309_179M;
 これらをまとめると、数値定数をさらに見やすい状態で宣言できます。 out 変数
out パラメーターをサポートする既存の構文は、C#7で改良されました。現在は、別の宣言ステートメントを記述するのでは なく、メソッド呼び出しの引数リストで out 変数を宣言できるようになりました。
前の例に示されているように、わかりやすくするために out 変数の型を指定することができます。ただし、この言語では、次の ように暗黙的に型指定されたローカル変数を使用できます。
コードが読みやすくなる。
out 変数は、前のコード行ではなく、使用する場所で宣言します。
初期値を割り当てる必要がない。
out 変数は、メソッド呼び出し内の使用場所で宣言することにより、割り当てる前に誤って使用することがなくなり
ます。
out 変数の宣言を許可するためにC#7.0に追加された構文が、フィールド初期化子、プロパティ初期化子、コンストラクター 初期化子、およびクエリ句を含めるように拡張されました。 これにより、次の例に示すようなコードを使用できるようになります。
     if (int.TryParse(input, out int result))
    Console.WriteLine(result);
else
    Console.WriteLine("Could not parse input");
     if (int.TryParse(input, out var answer))
    Console.WriteLine(answer);
else
    Console.WriteLine("Could not parse input");
     public class B
{
   public B(int i, out int j)
   {
j = i; }
}
public class D : B
{
   public D(int i) : base(i, out var j)
   {
      Console.WriteLine($"The value of 'j' is {j}");
   }
}
 末尾以外の名前付き引数
 public const long BillionsAndBillions = 100_000_000_000;
 
       メソッド呼び出しで、位置引数の前に名前付き引数を使用できるようになりました。ただし、そのような名前付き引数が正しい 位置にある場合です。 詳細については、「名前付き引数と省略可能な引数」を参照してください。
private protected アクセス修飾子
新しい複合アクセス修飾子: は、同じアセンブリで宣言されているクラスまたは派生クラスを含むことでメン バーにアクセスできることを示しています。 は同じアセンブリの派生クラスまたはクラスによるアクセスを許 可していますが、 private protected は同じアセンブリで宣言された派生型へのアクセスを制限しています。
詳細については、言語リファレンスのアクセス修飾子に関するページを参照してください。 オーバーロード候補の改善
すべてのリリースにおいて、あいまいなメソッド呼び出しに対する "明らかな" 選択肢が存在する状況に対応するようにオーバー ロードの解決ルールが更新されました。 このリリースでは、コンパイラが明らかな選択肢を選択できるようにする 3 つの新しいルー ルが追加されています。
1. インスタンス メンバーと静的メンバーの両方がメソッド グループに含まれている場合は、インスタンス レシーバーまたはコンテキ ストを指定せずにメソッドが呼び出されると、コンパイラがインスタンス メンバーを破棄します。 インスタンス レシーバーを使用 してメソッドが呼び出された場合、コンパイラは静的メンバーを破棄します。 レシーバーがない場合、コンパイラは静的メン バーだけを静的コンテキストに含めます。それ以外の場合は、静的メンバーとインスタンス メンバーの両方を含めます。 レ シーバーがあいまいなインスタンスまたは型である場合、コンパイラは両方のメンバーを含めます。暗黙的な this インスタ ンスレシーバーを使用できない静的コンテキストには、this が定義されないメンバー(静的メンバーなど)の本体および
this を使用できない場所(フィールド初期化子やコンストラクター初期化子など)が含まれます。
2. 型引数が制約を満たしていない複数のジェネリック メソッドがメソッド グループに含まれている場合、そのグループのメンバー は候補セットから削除されます。
3. メソッド グループの変換では、戻り値の型がデリゲートの戻り値の型と一致しない候補メソッドが候補セットから削除されま す。
適切なメソッドがわかっている場合には、あいまいなメソッドのオーバーロードに対するコンパイラ エラーが少なくなることを認識で きるため、この変更点にのみ注意してください。
セーフ コードをより効率的にする
アンセーフ コードと同様のパフォーマンスを確保した C# コードを安全に記述できるようにする必要があります。 セーフ コードは、 バッファー オーバーラン、ストレイ ポインター、その他のメモリ アクセス エラーなどのエラーを回避します。 ここで説明する新機能 は、検証可能なセーフ コードの機能を拡張します。 安全なコンストラクトを使用してより多くのコードを記述するようにしてくださ い。 以下に示す機能によって、コードの記述が容易になります。
次の新機能は、セーフ コードのパフォーマンス向上のテーマをサポートします。
ピン留めを使用せずに fixed フィールドにアクセスできます。 ref ローカル変数を再割り当てできます。
stackalloc 配列で初期化子を使用できます。
パターンをサポートする型と共に fixed ステートメントを使用できます。 追加のジェネリック制約を使用できます。
パラメーターの in 修飾子。引数が参照によって渡されるが、呼び出されたメソッドでは変更されないことを指定します。引 数に in 修飾子を加えることは、ソース互換性がある変更です。
メソッド戻りの ref readonly 修飾子。メソッドが参照によってその値を戻しますが、そのオブジェクトに対する書き込みを許 可しないことを指定します。 戻り値が値に割り当てられている場合、 修飾子を追加することは、ソース互換 性がある変更です。既存の ref returnステートメントに 修飾子を追加することは、互換性がない変更で す。 呼び出し元は、 readonly 修飾子を含むように ref ローカル変数の宣言を更新する必要があります。
 private protected
 protected internal
    ref readonly
 readonly
  readonly struct 宣言。変更不可の構造体で、そのメンバー メソッドの in パラメーターとして渡す必要があることを示し

     ます。 既存の構造体の宣言に   修飾子を追加することは、バイナリ互換性がある変更です。 宣言。構造体型がマネージド メモリに直接アクセスし、常にスタック割り当てが必要であることを示します。 既 存の の宣言に ref 修飾子を追加することは、互換性がない変更です。 ref struct をクラスのメンバーにする
ことはできません。また、ヒープ上に割り当てられている可能性がある他の場所で使用することもできません。 これらすべての変更点の詳細については、安全で効率的なコードを記述する方法に関するページを参照してください。
ref ローカル変数と戻り値
この機能により、他の場所に定義されている変数への参照を使用したり返したりするアルゴリズムが実現します。 1 つの例とし て、大規模なマトリックスを使用していて、特定の特性を持つ 1 つの場所を探します。 次のメソッドでは、マトリックスのそのスト レージに 参照 が返されます。
 ref struct
  struct
    public static ref int Find(int[,] matrix, Func<int, bool> predicate)
{
    for (int i = 0; i < matrix.GetLength(0); i++)
        for (int j = 0; j < matrix.GetLength(1); j++)
            if (predicate(matrix[i, j]))
                return ref matrix[i, j];
    throw new InvalidOperationException("Not found");
}
 戻り値を ref として宣言し、次のコードのように、マトリックスでその値を変更できます。
C#言語には、 ref ローカル変数と戻り値の誤用を防ぐ規則がいくつかあります。
メソッドシグネチャと、メソッド内のすべての return ステートメントに ref キーワードを追加する必要があります。 それにより、メソッド全体でメソッドは参照渡しで返すことになります。
ref return は値の変数か ref 変数に割り当てることができます。 呼び出し元により、戻り値がコピーされるかどうかが制御されます。 戻り値を割り当てるとき、 ref 修飾子を省略す ると、呼び出し元はストレージの参照ではなく、値のコピーを求めることになります。
標準的なメソッドの戻り値を ref ローカル変数に割り当てることはできません。
したがって、 ref int i = sequence.Count(); のようなステートメントは使用できません。
有効期間がメソッドの実行期間を超えない変数に ref を返すことはできません。 つまり、ローカル変数または類似のスコープの変数への参照を返すことはできません。
ref ローカル変数と戻り値は、非同期メソッドと共に使用することはできません。 コンパイラは、非同期メソッドが戻るときに、参照先の変数が、最終的な値に設定されているかどうかを認識できま
せん。
ref ローカル変数および ref 戻り値の追加により、値のコピーを回避したり、逆参照操作を複数回実行したりすることで、より効 率的なアルゴリズムを実現できます。
戻り値に ref を追加することは、ソース互換性がある変更です。既存のコードはコンパイルされますが、参照戻り値は割り当 て時にコピーされます。呼び出し元は、戻り値を参照として格納するために、戻り値の記憶域を ref ローカル変数に更新す る必要があります。
初期化後に別のインスタンスを参照するために、 ref ローカル変数を再割り当てできるようになりました。 次のコードがコンパイ ルされます。
    ref var item = ref MatrixSearch.Find(matrix, (val) => val == 42);
Console.WriteLine(item);
item = 24;
Console.WriteLine(matrix[4, 2]);
     readonly
 
         詳しくは、 ref 戻り値と ref ローカル変数に関する記事と foreach に関する記事を参照してください。 詳しくは、ref キーワードに関する記事をご覧ください。
条件付きの ref 式
最後に、条件式で値の結果ではなく参照結果を生成することができます。 たとえば、次のように記述して、2 つの配列のいず
れかに含まれる最初の要素の参照を取得できます
変数 r は、 arr または otherArr の最初の値の参照です。 詳細については、言語リファレンスの条件演算子 (?:) に関するページを参照してください。
in パラメーター修飾子
in キーワードは、refとoutの既存のキーワードを補完し、引数を参照で渡します。 in キーワードでは、引数を参照で渡
すことが指定されますが、呼び出されたメソッドでは値は変更されません。 次のコードに示すように、値または読み取り専用参照によって渡されるオーバーロードを宣言できます。
値によるオーバーロード (前述の例の 1 番目) の方が、読み取り専用参照による方法よりも優れています。 readonly 参照引 数を使用してバージョンを呼び出すには、メソッドの呼び出し時に in 修飾子を含める必要があります。
詳しくは、 in パラメーター修飾子に関する記事を参照してください。 fixed ステートメントをサポートする型の増加
fixed ステートメントは、限られた一連の型をサポートしていました。 C# 7.3 以降では、 ref T または ref readonly T を 返す GetPinnableReference() メソッドを格納する型として fixed を使用できます。 この機能の追加により、 fixed を System.Span<T> および関連する型と共に使用できます。
詳しくは、言語リファレンスの fixed ステートメントに関する記事を参照してください。 ピン留めが不要な fixed フィールドのインデックス付け
たとえば、次の構造体があるとします。
以前のバージョンのC#では、myFixedField の一部であるいずれかの整数にアクセスするために変数のピン留めが必要でし た。今では、次のコードは、変数 p を別の fixed ステートメントの内部にピン留めせずに、コンパイルされます。
  ref var r = ref (arr != null ? ref arr[0] : ref otherArr[0]);
      static void M(S arg);
static void M(in S arg);
       unsafe struct S
{
    public fixed int myFixedField[10];
}
     ref VeryLargeStruct refLocal = ref veryLargeStruct; // initialization
refLocal = ref anotherVeryLargeStruct; // reassigned, refLocal refers to different storage.
 
            変数 p は myFixedField の1個の要素にアクセスします。個別の int* 変数を宣言する必要はありません。 unsafe コ ンテキストは引き続き必要です。 以前のバージョンの C# では、2 番目の固定ポインターを宣言する必要があります。
    class C {
    static S s = new S();
    unsafe public void M()
    {
} }
fixed (int* ptr = s.myFixedField)
{
    int p = ptr[5];
}
 詳細については、 fixed ステートメントに関する記事を参照してください。 stackalloc 配列による初期化子のサポート
配列を初期化する際に、配列内の要素の値を指定することが可能でした。
現在では、 stackalloc で宣言された配列に同じ構文を適用できます。
詳細については、「 stackalloc 演算子」の記事を参照してください。 ジェネリック制約の拡張
型パラメーターの基底クラスの制約として、System.Enum 型または System.Delegate 型を指定できるようになりました。 また、新しい unmanaged 制約を使用して、型パラメーターがnull非許容でアンマネージ型である必要があることを指定するこ
ともできます。
詳しくは、 where ジェネリック制約および型パラメーターの制約に関する記事を参照してください。
これらの制約を既存の型に追加することは、互換性のない変更です。 クローズ ジェネリック型は、これらの新しい制約を満たさ なくなります。
一般化された async の戻り値の型
非同期メソッドから Task オブジェクトを返すと、特定のパスでパフォーマンスのボトルネックが発生する可能性があります。
Task は参照型です。したがって、これを使うことは、オブジェクトを割り当てることを意味します。 async 修飾子で宣言された メソッドがキャッシュされた結果を返すか、同期的に完了する場合、追加の割り当ては、コードのパフォーマンスが重要なセクショ
     var arr = new int[3] {1, 2, 3};
var arr2 = new int[] {1, 2, 3};
      int* pArr = stackalloc int[3] {1, 2, 3};
int* pArr2 = stackalloc int[] {1, 2, 3};
Span<int> arr = stackalloc [] {1, 2, 3};
      class C {
    static S s = new S();
    unsafe public void M()
    {
        int p = s.myFixedField[5];
    }
}
 
       ンにおいて大きな時間コストにつながります。 厳密なループ処理でこのような割り当てが発生した場合、コストがかかる場合が あります。
新しい言語機能では、非同期メソッドの戻り値の型が Task 、 Task<T> 、 void に限定されません。 返される型は引き続き 非同期パターンを満たす必要があります。つまり、 メソッドはアクセス可能である必要があります。 1 つの具体的な 例として、この新しい言語機能を使用するために .NET に 型が追加されました。
  GetAwaiter
 ValueTask
    public async ValueTask<int> Func()
{
    await Task.Delay(100);
return 5; }
     NOTE
ValueTask<TResult> 型を使用するには、NuGet パッケージ System.Threading.Tasks.Extensions > を追加する必要がありま す。
  この機能強化は、ライブラリの作成時、パフォーマンスクリティカルなコードに Task を割り当てることを回避する目的で非常に 便利です。
新しいコンパイラ オプション
新しいコンパイラ オプションでは、C# プログラムの新しいビルドと DevOps のシナリオがサポートされます。
参照アセンブリ生成
"参照専用アセンブリ" を生成する新しい 2 つのコンパイラ オプション -refout と -refonly があります。 リンク先の記事には、オプ ションと参照アセンブリに関する詳細があります。
公開署名またはオープン ソース署名
-publicsign コンパイラオプションは、公開キーを使用してアセンブリに署名するようにコンパイラに指示します。アセンブリは署 名済みとしてマークされますが、署名は公開キーから取得されます。 このオプションでは、公開キーを使用するオープン ソース プ ロジェクトから署名済みのアセンブリをビルドできます。
詳しくは、-publicsign コンパイラ オプションの記事を参照してください。 pathmap
コンパイラ オプションは、ビルド環境からのソース パスをマップ済みのソース パスに置き換えるようにコンパイラに指示し ます。 オプションは、コンパイラが記述した PDB ファイルまたは CallerFilePathAttribute のソース パスを制御しま す。
詳しくは、-pathmap コンパイラ オプションの記事を参照してください。
  -pathmap
 -pathmap

          Roslyn チームは、C# および Visual Basic コンパイラでの破壊的変更の一覧を保持しています。 これらの変更に関する情報 については、GitHub リポジトリの次のリンクを参照してください。
.NET 5.0 と C# 9.0 に導入される VS2019 バージョン 16.8 の破壊的変更
VS2019 更新プログラム 1 以降の破壊的変更と VS2019 の比較
VS2017 (C# 7) 以降の破壊的変更
Roslyn 2.* (VS2017) からの Roslyn 3.0 (VS2019) の破壊的変更
Roslyn 1.* (VS2015) およびネイティブ C# コンパイラ (VS2013 以前) からの Roslyn 2.0 (VS2017) の破壊的変更。 ネイティブ C# コンパイラ (VS2013 以前) からの Roslyn 1.0 (VS2015) の破壊的変更。
C# 6 での Unicode バージョンの変更
C# コンパイラでの破壊的変更の詳細情報 2020/11/02 • • Edit Online
 
                  この記事では、C# 言語の各メジャー リリースの履歴について説明します。 C# チームは、引き続き新機能を刷新および追加し ていきます。 今後のリリースに向けて検討される機能を含め、言語機能ステータスについての詳細は GitHub の dotnet/roslyn リポジトリで見つけられます。
    IMPORTANT
C# 言語の一部の機能は、C# の仕様で定義されている "標準ライブラリ" の型とメソッドに依存しています。 .NET プラットフォームでは、さま ざまなパッケージでそれらの型とメソッドが提供されています。 一例として、例外処理があります。 すべての throw ステートメントまたは式 は、スローされたオブジェクトが Exception から派生していることを確認するために、チェックされます。 同様に、すべての catch は、キャッチ された型が Exception から派生していることを確認するために、チェックされます。 バージョンごとに新しい要件が追加されている場合があり ます。 古い環境で言語の最新機能を使用するには、特定のライブラリをインストールする必要がある場合があります。 これらの依存関係に ついては、特定のバージョンごとに用意されたページに記載されています。 この依存関係の経緯と詳細については、言語とライブラリ間の関 係に関する記事をご覧ください。
 C# のビルド ツールでは、言語の最新のメジャー リリースが言語の既定のバージョンと見なされます。 メジャー リリースの間には、 このセクションの他の記事で詳しく説明するポイント リリースが存在することがあります。 ポイント リリースで最新の機能を使用す るには、コンパイラ言語バージョンを構成し、バージョンを選択する必要があります。 C# 7.0 以降、3 つのポイント リリースがあり ました。
C# 7.3:
C# 7.3 は Visual Studio 2017 バージョン 15.7 および .NET Core 2.1 SDK 以降で利用可能です。
C# 7.2:
C# 7.2 は Visual Studio 2017 バージョン 15.5 および .NET Core 2.0 SDK 以降で利用可能です。
C# 7.1:
C# 7.1 は Visual Studio 2017 バージョン 15.3 および .NET Core 2.0 SDK 以降で利用可能です。
C# バージョン 1.0
振り返ってみると、Visual Studio .NET 2002 でリリースされた C# バージョン 1.0 は Java に似ていました。 ECMA で掲げられ た設計目標の一環として、C# は "シンプルかつモダンな汎用オブジェクト指向言語" を目指していました。 当時、Java に似て いることは、初期の設計目標を達成したことを意味していました。
しかし、今 C# 1.0 を振り返ってみると、少し混乱するかもしれません。 現在では当たり前となっている組み込みの非同期機能 や、ジェネリック関連の優れた機能の一部は備わっていませんでした。 実際、ジェネリック全体がなかったのです。 そして LINQ も、 まだ使用できませんでした。 このような追加機能が登場するまでにはまだ数年かかります。
C# バージョン 1.0 は、現在のバージョンと比べると、機能がはぎ取られたように見えます。 気がつくと冗長なコードを記述してい る場合があるでしょう。 しかしそれでも、千里の道も一歩からです。 C# バージョン 1.0 は、Windows プラットフォームにおける Java の実行可能な代替手段でした。
C# 1.0 の主な機能:
クラス
構造体 インターフェイス イベント プロパティ
C#の歴史 2021/03/06 • • Edit Online
 
              デリゲート 演算子および式 ステートメント 属性
C# バージョン 1.2
Visual Studio .NET 2003 に付属の C# バージョン 1.2。 言語に対する細かな機能強化がいくつか含まれています。 最も重 要な点は、このバージョン以降、IEnumeratorによってIDisposableが実装された場合、foreach ループ内で生成された コードでは、その IEnumerator 上で Dispose が呼び出されているということです。
C# バージョン 2.0
ここから面白くなり始めます。 Visual Studio 2005 と共に 2005 年にリリースされた C# 2.0 の主な機能をいくつか見てみましょ
う。
ジェネリック
部分型
匿名メソッド
null 許容値型 反復子 共変性と反変性
その他の C# 2.0 機能では既存の機能に新たな能力を追加しました。
ゲッター/セッター別のアクセシビリティ メソッド グループの変換 (デリゲート) 静的クラス
デリゲート推論
C# は汎用的なオブジェクト指向 (OO) 言語として始まったかもしれませんが、C# バージョン 2.0 ではそれが急速に変化しまし た。 マイクロソフトが本腰を入れると、いくつかの開発者の重大な問題点を追究しました。 そしてその問題点を著しく追究しま した。
ジェネリックでは、型とメソッドがタイプ セーフを維持しながら任意の型に対して操作を行えます。 たとえば、List<T> があると、 List<string> または List<int> を使用し、これらの文字列または整数に対してタイプセーフ操作を実行しながら、これらを 反復処理することができます。 ジェネリックを使用する方が、 ArrayList から派生する ListInt 型を作成したり、すべての操
作で Object からキャストしたりするよりも優れています。
C#バージョン2.0で、反復子が導入されました。手短に言うと、反復子を使用すると、List 内のすべての項目(またはその 他の列挙可能な型)を foreach ループで確認することができます。反復子を言語のファーストクラスの部分として持つことで、 言語の読みやすさと、ユーザーのコードについて推論する能力が劇的に高まりました。
それでもまだ、C# は Java にほんの少し後れを取り続けていました。 Java は、ジェネリックと反復子が含まれたバージョンを既に リリースしていました。 しかし間もなく、2 つの言語は別々の進化を続けていくことになります。
C# バージョン 3.0
C# バージョン 3.0 は、Visual Studio 2008 と共に 2007 年後半に登場しましたが、すべての言語機能が搭載されたのは、実 際には .NET Framework バージョン 3.5 からでした。 このバージョンは、C# の成長において大きな変化を遂げました。 この バージョンで、C# は真に強力なプログラミング言語としての地位を確立しました。 このバージョンでの主な機能をいくつか見てみ ましょう。
       自動実装プロパティ

           匿名型
クエリ式
ラムダ式
式ツリー
拡張メソッド 暗黙的に型指定されるローカル変数 部分メソッド オブジェクト初期化子とコレクション初期化子
今になって考えると、これらの機能の多くは必然で切り離せないものに思えます。 これらすべてが戦略的に組み合わさっていま す。 一般的には、C# のこのバージョンでの目玉機能はクエリ式 (統合言語クエリ (LINQ) とも呼ばれる) だったと考えられていま す。
もう少し異なる見解では、式ツリー、ラムダ式、匿名型が、LINQ が構築される基になっていると分析しています。 しかし、いず れにしても、C# 3.0 は革新的な概念を提示しました。 C# 3.0 から、C# をオブジェクト指向と関数型言語のハイブリッドに変換 するための下準備が始まりました。
いろいろありますが、特に、今では記述できるようになった SQL スタイル、コレクションに対して操作を実行する宣言型クエリなど があります。 for ループを記述して整数のリストの平均を計算する代わりに、今では単純に list.Average() でこれを行うこ とができます。 クエリ式と拡張メソッドの組み合わせにより、整数のリストが非常にスマートになったように見えるようになりました。
ユーザーが概念を真に理解して統合するには時間がかかりましたが、徐々にそうなりました。 そして数年後の現在、コードは もっと簡潔、シンプルかつ機能的になりました。
C# バージョン 4.0
Visual Studio 2010 でリリースされた C# バージョン 4.0 は、バージョン 3.0 の革新的なステータスに応えるための困難な時期 だったと言えるでしょう。 バージョン 3.0 で C# は Java の影から脱却して、主要な言語となったのです。 この言語は急速に洗 練されました。
次のバージョンでは、いくつかの興味深い新機能が導入されました。
動的バインディング 名前付き/省略可能な引数 ジェネリックの共変と反変 埋め込まれた相互運用機能型
埋め込まれた相互運用機能型は、展開の問題を緩和しました。 ジェネリックの共変性と反変性は、ジェネリックを使用する権 限を強化しますが、少々アカデミックで、最も高く評価されているのは、おそらくフレームワークとライブラリの作成者からでしょう。 名前付きパラメーターと省略可能なパラメーターは、多くのメソッドのオーバーロードを排除して、利便性を高めることができま す。 しかし、これらの機能はいずれもパラダイムを変えるほどのものではありませんでした。
主要な機能は、dynamic キーワードの導入でした。C#バージョン4.0で導入された dynamic キーワードにより、コンパイル 時の型指定でコンパイラをオーバーライドできるようになりました。 dynamic キーワードを使用することで、JavaScript のような 動的に型指定された言語と同様のコンストラクトを作成することができます。 dynamic x = "a string" を作成してから、それ に 6 を追加して、実行時までそのままにして次に発生する必要のあることを整理することができます。
動的バインドには潜在的なエラーの可能性がありますが、同時に、この言語が持つ大きな力にもなっています。 C# バージョン 5.0
Visual Studio 2012 でリリースされた C# バージョン 5.0 は、この言語の専心的なバージョンでした。 このバージョンに対するほ ぼすべての努力が、非同期プログラミングの async および await モデルというもう一つの革新的な言語の概念に注がれまし た。 主要な機能の一覧を次に示します。
    
                  非同期メンバー 呼び出し元情報属性
関連項目
コード プロジェクト:C# 5.0 の呼び出し元情報属性
呼び出し元情報属性を使用すると、さまざまな定型リフレクション コードを使用しなくても、実行しているコンテキストに関する情
報を簡単に取得できます。 診断とログ記録のタスクでは、さまざまな用途があります。
しかしこのリリースの真の主役は、async と await です。2012年にこれらの機能が登場したとき、C#はファーストクラスの一 部として非同期を言語に採用したことで再び流れを変えました。 これまでに、長時間実行される操作とコールバックの Web の 実装に対処したことがあれば、おそらくこの言語機能を気に入っているでしょう。
C# バージョン 6.0
C# バージョン 3.0 と 5.0 では、主要な新機能がオブジェクト指向言語に追加されました。 Visual Studio 2015 と共にリリース されたバージョン 6.0 では、主要な目玉機能を投入する代わりに、C# プログラミングをより生産的にする多くの小さな機能をリ リースしました。 その一部を次に示します。
静的インポート 例外フィルター 自動プロパティ初期化子 式形式のメンバー
Null 伝達子 文字列補間 nameof 演算子
その他に次の新機能があります。
インデックス初期化子 Catch/Finally ブロックでの Await ゲッターのみのプロパティの既定値
これらの機能は、単独でも興味深い機能ですが、 全体として見てみると、興味深いパターンが見えます。 このバージョンで、 コードをより簡潔で読みやすくするため、C# から定型表現が排除されました。 そのため、クリーンで単純なコードが好きな人に、 この言語バージョンは大当たりしました。
マイクロソフトはこのバージョンとともにもう 1 つ別のことを行いましたが、それ自体が従来の言語機能ではありませんでした。 サービスとしてのコンパイラ Roslyn をリリースしたのです。 C# コンパイラは現在、C# で記述され、プログラミングのための取り組 みの一環として、コンパイラを使用することができます。
C# バージョン 7.0
C# バージョン 7.0 は、Visual Studio 2017 でリリースされました。 このバージョンには、C# 6.0 から続くいくつかの革新的で優れ
た機能がありますが、サービスとしてのコンパイラはありません。 新機能の一部を次に示します。
out 変数
タプルと分解
パターン マッチング ローカル関数 拡張された式形式のメンバー ref ローカル変数と戻り値
その他の機能:

              破棄
バイナリ リテラルと桁区切り文字 throw 式
これらすべての機能が素晴らしい新機能を開発者に提供し、これまでよりもさらにクリーンなコードを記述する機会を提供しま す。 ハイライトは、 out キーワードで使用するために変数の宣言を凝縮することと、タプルを通じて複数の戻り値を許可するこ とです。
しかし C# はさらに広範に使用されています。 .NET Core は現在、任意のオペレーティング システムを対象としており、クラウドと 移植性をしっかりと見据えています。 この言語の設計者たちは、新機能を考え出すことに加え、こうした新たな能力についても 多くの思考と時間を費やしています。
C# バージョン 7.1
C# は、C#7.1 で "ポイント リリース" のリリースを開始しました。 このバージョンでは、言語バージョン選択構成要素、3 つの新し
い言語機能、新しいコンパイラ動作が追加されます。 このリリースの新しい言語機能は次のとおりです。
async Main メソッド
アプリケーションのエントリポイントに async 修飾子を設定できます。
default リテラル式 ターゲットの種類を推論できるとき、既定の値式で既定のリテラル式を使用できます。
推論されたタプル要素の名前
タプル要素の名前は、多くの場合、タプル初期化から推論できます。
ジェネリック型パラメーターのパターン マッチ
型がジェネリック型パラメーターである変数にパターン マッチ式を使用できます。 最後に、コンパイラには、参照アセンブリ生成を制御する 2 つのオプション、 -refout と -refonly があります。
C# バージョン 7.2
C# 7.2 では、いくつかの小規模な言語機能が追加されました。
安全で効率的なコードを記述するための手法
参照セマンティクスを使用したさまざまな値の型の使用を有効にする、構文の機能強化の組み合わせ。
末尾以外の名前付き引数
名前付き引数の後ろに位置引数を続けることができます。
数値リテラルでの先頭のアンダースコア (_) 数値リテラルの印刷桁の前に先頭のアンダースコア(_) を含めることができるようになりました。
アクセス修飾子
アクセス修飾子によって、同じアセンブリ内の派生クラスのアクセスが有効になります。 条件式 ( ?: ) の結果を参照にすることができるようになりました。
C# バージョン 7.3
C# 7.3 リリースには 2 つの主要なテーマがあります。 1 つ目のテーマは、アンセーフ コードと同様のパフォーマンスをセーフ コード で確保するための機能の提供です。 2 つ目のテーマは、既存の機能のインクリメンタルな改善の提供です。 また、新しいコンパ イラ オプションがこのリリースで追加されました。
    private protected
 private protected
条件付きの ref 式
次の新機能は、セーフ コードのパフォーマンス向上のテーマをサポートします。

                        ピン留めを使用せずに fixed フィールドにアクセスできます。 ref ローカル変数を再割り当てできます。
stackalloc 配列で初期化子を使用できます。
パターンをサポートする型と共に fixed ステートメントを使用できます。 追加のジェネリック制約を使用できます。
既存の機能が次のように強化されました。
タプル型を使用して == と != をテストできます。 式の変数をより多くの場所で使用できます。 自動実装プロパティのバッキング フィールドに属性をアタッチできます。 引数が in によって異なる場合のメソッド解決が改善されました。 オーバーロードの解決のあいまいなケースが削減されました。
新しいコンパイラ オプションは次のとおりです。
: オープン ソース ソフトウェア (OSS) のアセンブリの署名を可能にします。
: ソース ディレクトリのマッピングを提供します。 C# バージョン 8.0
C# 8.0 は、特に C# .NET Core をターゲットとする最初のメジャー リリースです。 新しい CLR 機能に依存する機能と、.NET Core にのみ追加されたライブラリの型に依存する機能があります。 C# 8.0 では、C# 言語に次の機能と機能強化が追加され ています。
読み取り専用メンバー 既定のインターフェイス メソッド パターン マッチングの拡張機能:
switch 式 プロパティのパターン タプル パターン 位置指定パターン
using 宣言
静的ローカル関数
破棄可能な ref 構造体
Null 許容参照型 非同期ストリーム インデックスと範囲
null 合体割り当て 構築されたアンマネージド型 入れ子になった式の stackalloc verbatim 補間文字列の拡張
既定のインターフェイス メンバーには、CLR の拡張機能が必要です。 これらの機能は、CLR for .NET Core 3.0 で追加されま した。 範囲とインデックス、および非同期ストリームには、.NET Core 3.0 ライブラリの新しい型が必要です。 null 許容参照型 は、コンパイラに実装されていますが、引数と戻り値の null 状態に関するセマンティック情報を提供する注釈がライブラリに付け られている場合に非常に役立ちます。 このような注釈は .NET Core ライブラリに追加されています。
記事 は、NDepend ブログで元々公開されていたものです (提供: Erik Dietrich および Patrick Smacchia)。
  -publicsign
 -pathmap

        C# 言語の定義は、標準ライブラリが特定の型とその型にアクセス可能な特定のメンバーを持つことを必要とします。 コンパイラ は、多くの異なる言語機能にこれらの必要な型とメンバーを使用するコードを生成します。 これらの型やメンバーがまだ展開さ れていない環境のためのコードを記述する場合、必要に応じてその言語の新しいバージョンに必要な型が含まれている NuGet パッケージが利用できます。
この標準ライブラリ機能に対する依存関係は、C# 言語の最初のバージョンからその一部となっています。 そのバージョンでは、 次の例が含まれています。
Exception: すべてのコンパイラーによって生成された例外に使用されます。 String:C# string 型はStringのシノニムです。
Int32: int のシノニムです。
その最初のバージョンは単純でした。コンパイラと標準ライブラリは共に出荷され、それぞれ 1 つのバージョンしかありませんでし た。
C# の以降のバージョンでは、随時、依存関係に新しい型またはメンバーが追加されています。 例とし て、INotifyCompletion、CallerFilePathAttribute、CallerMemberNameAttribute があります。 C# 7.0 では、 タプル言語 機能を実装するためにValueTupleへの依存関係が追加されます。
言語設計チームは、準拠している標準ライブラリで必要な型およびメンバーのアクセス領域を最小限に抑えることに取り組んで います。 その目標は、新しいライブラリ機能が言語にシームレスに組み込まれているクリーン設計と両立させることです。 将来、 標準ライブラリ内の新しい型とメンバーを必要とする C# の新バージョンが登場するでしょう。 自分の作業でこれらの依存関係を 管理する方法を理解することが重要です。
依存関係の管理
C# コンパイラ ツールは現在、サポートされているプラットフォームの .NET ライブラリのリリース サイクルと切り離されています。 実 際、.NET ライブラリごとに異なるリリース サイクルがあります。Windows の .NET Framework は、Windows Update としてリ リースされ、.NET Core は個別のスケジュールで出荷されます。また、Xamarin バージョンのライブラリの更新は、各ターゲット プ ラットフォーム用の Xamarin ツールとともに出荷されます。
ほとんどの場合、これらの変更に気付くことはありません。 ただし、そのプラットフォーム上の .NET ライブラリ内にまだない機能を 必要とする言語の新しいバージョンを使用している場合は、それらの新しい型を提供する NuGet パッケージを参照することにな ります。 お使いのアプリがサポートしているプラットフォームが新しいフレームワークのインストールで更新されるときに、この余分な 参照を削除できます。
この分離は、対応するフレームワークがない可能性があるマシンを対象とする場合でも、新しい言語機能を使用できることを意 味します。
 言語機能とライブラリ型間のリレーションシップ
2020/11/02 • • Edit Online
 
   互換性は、新しい機能を C# 言語に追加するときの非常に重要な目標です。 ほとんどの場合、既存のコードは、新しいコン パイラのバージョンで問題なく再コンパイルできます。
新しい言語機能をライブラリに導入するときに、配慮が必要な場合があります。 最新バージョンで見つかった機能を使用して 新しいライブラリを作成したが、コンパイラの以前のバージョンを使用してビルドされたアプリがそれを使用できることを保証しなけ ればならない場合があります。 または、既存のライブラリをアップグレードしたが、多くのユーザーがバージョンをまだアップグレードし ていない場合があります。 新しい機能の導入を検討するときは、互換性の 2 つのバリエーション (ソース互換とバイナリ互換) を 考慮する必要があります。
バイナリ互換の変更
更新されたライブラリを、アプリケーションとそれを使用するライブラリのリビルドなしで使用できる場合、ライブラリの変更はバイナ リ互換です。 依存するアセンブリのリビルドも、ソース コードの変更も必要ありません。 バイナリ互換の変更は、ソース互換の変 更でもあります。
ソース互換の変更
更新されたライブラリを使用するアプリケーションとライブラリではソース コードの変更を必要としませんが、ソースを正常に動作さ せるには、新しいバージョンで再コンパイルする必要がある場合、ライブラリの変更はソース互換です。
互換性のない変更
変更がソース互換とバイナリ互換のどちらでもない場合は、依存するライブラリとアプリケーションのソース コードの変更と再コン パイルが必要です。
ライブラリを評価する
これらの互換性の概念は、ライブラリの内部実装ではなく、public 宣言と protected 宣言に影響します。 新しい機能の内部 的な導入は、常にバイナリ互換です。
バイナリ互換の変更では、古い構文の public 宣言と同じコンパイル済みコードを生成する新しい構文があります。 たとえば、 メソッドを式形式のメンバーに変更することは、バイナリ互換の変更です。
元のコード:
新しいコード:
ソース互換の変更では、public メンバーのコンパイル コードを変更する構文が導入されますが、それは既存の呼び出しサイト と互換性がある方法で行われます。たとえば、メソッドのシグネチャを値によるパラメーターから in 参照によるパラメーターに変
    public double CalculateSquare(double value)
{
    return value * value;
}
   public double CalculateSquare(double value) => value * value;
 C# 開発者向けのバージョンと更新に関する考慮
事項
2020/11/02 • • Edit Online
 
 更することはソース互換ですが、バイナリ互換ではありません。 元のコード:
新しいコード:
新機能に関する記事に、public 宣言に影響する機能の導入がソース互換であるかバイナリ互換であるかについての注が含ま れています。
  public double CalculateSquare(double value) => value * value;
   public double CalculateSquare(in double value) => value * value;
 
   型、変数、および値
C# は、厳密に型指定された言語です。 すべての変数および定数は、値に評価されるすべての式がそうであるように、型を持ち ます。 各メソッドの宣言は、各入力パラメーターと戻り値に対して、名前、パラメーターの数、型と種類 (値、参照、または出 力) を指定します。 .NET クラス ライブラリでは、一連の組み込みの数値型や、ファイル システム、ネットワーク接続、オブジェクト のコレクションと配列、日付など、さまざまな論理構造を表すより複雑な型が定義されています。 一般的な C# プログラムは、ク ラス ライブラリの型と、そのプログラムの問題領域に固有の概念をモデル化するユーザー定義の型を使用します。
型には、次のような項目の情報が保存されます。
その型の変数が必要とする記憶領域。 表すことができる最大値と最小値。
含まれるメンバー (メソッド、フィールド、イベントなど)。 継承元となった基本型。 実装されるインターフェイス。 実行時に変数に割り当てられるメモリの場所。 許可される演算の種類。
コンパイラは型情報を使用して、コード内で実行されるすべての演算が "タイプ セーフ" となるようにします。 たとえば、int 型の 変数を宣言すると、その変数は加算演算と減算演算で使用できます。 同じ演算を bool 型の変数に対して実行しようとする と、コンパイラで次の例のようなエラーが発生します。
    int a = 5;
int b = a + 2; //OK
bool test = true;
// Error. Operator '+' cannot be applied to operands of type 'int' and 'bool'.
int c = a + test;
     NOTE
C や C++ と異なり、C# では、bool を int に変換することはできません。
 コンパイラは、型情報を実行可能ファイル内にメタデータとして埋め込みます。 共通言語ランタイム (CLR: Common Language Runtime) は、実行時にこのメタデータを使用して、メモリの割り当て時および再要求時に、タイプ セーフであるかど うかを再度確認します。
変数宣言での型の指定
プログラム内で変数や定数を宣言するときは、その型を指定するか、var キーワードを使用して、コンパイラが型を推論できるよ うにする必要があります。 次の例では、組み込みの数値型と複雑なユーザー定義の型の両方を使用する変数宣言を示しま す。
型 (C# プログラミング ガイド) 2021/03/09 • • Edit Online
 
        メソッドのパラメーターおよび戻り値の型は、メソッドの宣言で指定します。 入力引数として int を使用する必要があり、戻り値 として文字列を返すメソッドのシグネチャを次に示します。
    public string GetName(int ID)
{
    if (ID < names.Length)
        return names[ID];
    else
        return String.Empty;
}
private string[] names = { "Spencer", "Sally", "Doug" };
 変数を宣言した後は、新しい型を使用して再宣言することはできず、宣言された型と互換性のない値を代入することもできま せん。たとえば、intを宣言してから、それに true のブール値を代入することはできません。ただし、たとえば新しい変数に代 入するときや、メソッドの引数として渡すときに、値を他の型に変換することは可能です。 データの損失を伴わない "型変換" は、コンパイラによって自動的に実行されます。 データの損失を伴う可能性のある変換には、ソース コードに cast を記述する 必要があります。
詳細については、「キャストと型変換」を参照してください。 組み込み型
C# には、整数、浮動小数点値、ブール式、テキスト文字、10 進数値などのデータを表現するための標準的な組み込みの型 が用意されています。また、組み込みの string 型や object 型もあります。これらの型は、どのC#プログラムでも使用で きます。 組み込み型の完全な一覧については、組み込みの型に関するページを参照してください。
カスタム型
独自のカスタム型を作成するには、struct、class、interface、enum、および record の各構造体を使用します。 .NET クラス ライブラリ自体が、マイクロソフトによって提供された、ユーザーが独自のアプリケーションで使用できるカスタムの型のコレクションで す。 既定では、クラス ライブラリで最も頻繁に使用される型は任意の C# プログラムで使用可能になっています。 それ以外は、 それらが定義されているアセンブリへのプロジェクト参照を明示的に追加した場合にのみ使用可能になります。 コンパイラがアセ ンブリを参照できるようになると、そのアセンブリ内で宣言されている型の変数 (および定数) をソース コード内で宣言できるように なります。 詳細については、「.NET クラス ライブラリの概要」を参照してください。
共通型システム
.NET で型システムを使用する場合は、次の 2 つの基本事項を理解しておく必要があります。
継承の原則がサポートされています。 他の型から型を派生させることができます。派生元の型は "基本型" と呼ばれます。 派生した型は、基本型のメソッド、プロパティ、およびその他のメンバーを (若干の制限付きで) 継承します。 基本型もなん らかの他の型から派生できます。この場合、派生した型はその継承階層内の両方の基本型のメンバーを継承します。 System.Int32 (C# のキーワードは int) などの組み込み数値型を含むすべての型は、最終的に System.Object (C# の
     // Declaration only:
float temperature;
string name;
MyClass myClass;
// Declaration with initializers (four examples):
char firstLetter = 'C';
var limit = 3;
int[] source = { 0, 1, 2, 3, 4, 5 };
var query = from item in source
            where item <= limit
select item;
 
       キーワードは object) という単一の基本型から派生します。 この一元化された型階層は、共通型システム (CTS) と呼ばれ ます。 C# での継承の詳細については、「継承」を参照してください。
CTS の各型は、"値型" または "参照型" として定義されます。 この型には、.NET クラス ライブラリのすべてのカスタムの型だ けでなく、ユーザーが独自に定義した型も含まれます。 struct キーワードを使用して定義した型は値型であり、すべての組 み込み数値型は structs です。classまたはrecordのキーワードを使用して定義した型は、参照型です。参照型と値 型では、コンパイル時の規則や実行時の動作が異なります。
次の図は、CTS における値型と参照型の関係を示しています。
値型
値型は、System.ValueType の派生型である System.Object から派生します。 System.ValueType から派生した型は、 CLR では特殊な動作をします。 値型の変数は、その値を直接含みます。つまり、変数がどのようなコンテキストで宣言されたと しても、必ずメモリがインラインで割り当てられます。 値型の変数には、独立したヒープ割り当てやガベージ コレクションのオー バーヘッドはありません。
値型には、構造体と列挙体の 2 つのカテゴリがあります。 組み込みの数値型は構造体であり、次のようにしてアクセスできるフィールドとメソッドを持ちます。
ただし、宣言とそこへの値の代入は、あたかも単純な非集約型であるかのように行うことができます。
値型は "シールド" です。つまり、System.Int32 などのどの値型からも型を派生させることはできません。 構造体は System.ValueType からしか継承できないため、ユーザー定義のクラスまたは構造体を継承する構造体を定義することはでき ません。 ただし、構造体は 1 つ以上のインターフェイスを実装できます。 構造体型は、実装する任意のインターフェイス型に
      NOTE
この図を見るとわかるように、最もよく使用される型はすべて System 名前空間に属しています。 しかし、型が属している名前空間は、その 型が値型と参照型のどちらであるかには関係ありません。
     // constant field on type byte.
byte b = byte.MaxValue;
     byte num = 0xA;
int i = 5;
char c = 'Z';
 
          キャストできます。このキャストを行うと、"ボックス化" 操作によって、構造体がマネージド ヒープ上の参照型オブジェクト内にラッ プされます。 ボックス化操作が発生するのは、入力パラメーターとして System.Object または任意のインターフェイス型を受け 取るメソッドに値型を渡した場合です。 詳細については、「ボックス化とボックス化解除」を参照してください。
独自のカスタム値型を作成するには、struct キーワードを使用します。 通常、構造体は、次の例に示すように、少数の関連 する変数のコンテナーとして使用します。
    public struct Coords
{
    public int x, y;
    public Coords(int p1, int p2)
    {
x = p1;
y = p2; }
}
 構造体の詳細については、構造体型に関する記事をご覧ください。 値型の詳細については、値型に関するページを参照して ください。
別の種類の値型として、列挙体があります。 列挙体は、一連の名前付き整数定数を定義します。 たとえば、.NET クラス ライ ブラリの System.IO.FileMode 列挙体には、ファイルを開く方法を指定する一連の名前付き整数定数が格納されています。 こ れは、次の例のように定義されます。
    public enum FileMode
{
    CreateNew = 1,
    Create = 2,
    Open = 3,
    OpenOrCreate = 4,
    Truncate = 5,
    Append = 6,
}
  定数 System.IO.FileMode.Create は、2という値を持ちます。しかし、人間がソースコードを読む場合は名前があるとわかり やすいため、このような場合は、リテラルの数値の定数を使用するよりも、列挙体を使用する方がよいと言えます。 詳細につい ては、「System.IO.FileMode」を参照してください。
すべての列挙体は、System.Enum の派生型である System.ValueType から派生します。 構造体に適用されるすべての規 則が、列挙体にも適用されます。 詳細については、「列挙型」を参照してください。
参照型
class、record、delegate、配列、または interface として定義された型は、"参照型" です。 参照型の変数を宣言した場 合、実行時には、new 演算子によってオブジェクトが明示的に作成されるまで、この変数には null が格納されます。または、 次の例に示すように new を使用して、別の場所で作成されたオブジェクトを割り当てることもできます。
インターフェイスは、それを実装するクラスオブジェクトで一緒に初期化する必要があります。 MyClass が IMyInterface を実 装している場合は、次の例のようにして IMyInterface のインスタンスを作成できます。
    MyClass mc = new MyClass();
MyClass mc2 = mc;
      IMyInterface iface = new MyClass();
 オブジェクトが作成されると、マネージド ヒープ上でメモリが割り当てられ、変数にはそのオブジェクトの場所への参照のみが格納

           されます。 マネージド ヒープを使用する型では、メモリの割り当て時と、CLR の自動メモリ管理機能 ("ガベージ コレクション") に よる再要求時の両方についてオーバーヘッドが発生します。 しかし、ガベージ コレクションも高度に最適化されるため、ほとんど のシナリオでは、パフォーマンス上の問題が発生することはありません。 ガベージ コレクションの詳細については、「自動メモリ管 理」を参照してください。
配列は、その要素が値型の場合でも、すべて参照型です。 配列は、System.Array クラスから暗黙的に派生しますが、C# に 用意されている次の例のような簡単な構文で宣言および使用します。
参照型では、継承が全面的にサポートされています。 クラスの作成時には、シールドとして定義されているものを除く、他のす べてのインターフェイスまたはクラスから継承できます。また、作成したクラスから他のクラスを継承し、仮想メソッドをオーバーライ ドすることもできます。 独自のクラスを作成する方法の詳細については、「クラスおよび構造体」を参照してください。 継承と仮 想メソッドの詳細については、「継承」を参照してください。
リテラル値の型
C# では、リテラル値の型がコンパイラによって決定されます。 数値リテラルの型指定の方法を指定するには、その数値の末尾に 文字を付加します。たとえば、値4.56をfloat型として扱うには、数値の後に"f"または"F"を付加して、4.56f のように指 定します。 文字を付加しない場合、リテラルの型はコンパイラによって推論されます。 文字サフィックスで指定できる型の詳細に ついては、「整数数値型」と「浮動小数点数値型」を参照してください。
リテラルは型指定され、すべての型は最終的に System.Object から派生するため、次のようなコードを記述してコンパイルでき ます。
    // Declare and initialize an array of integers.
int[] nums = { 1, 2, 3, 4, 5 };
// Access an instance property of System.Array.
int len = nums.Length;
     string s = "The answer is " + 5.ToString();
// Outputs: "The answer is 5"
Console.WriteLine(s);
Type type = 12345.GetType();
// Outputs: "System.Int32"
Console.WriteLine(type);
 ジェネリック型
クライアント コードが型のインスタンスを作成したときに提供される実際の型 (具象型) のプレースホルダーとして使用される 1 つ 以上の 型パラメーター で、型を宣言することもできます。 このような型は、ジェネリック型 と呼ばれます。 たとえば、.NET の型 System.Collections.Generic.List<T> には、慣例により T という名前が与えられる 1 つの型パラメーターがあります。この型の インスタンスを作成するときには、たとえば文字列の場合なら、リストに含まれるオブジェクトの型を次のように指定します。
型パラメーターを使用することで、同じクラスを再利用して任意の型の要素を格納できます。このとき、各要素をオブジェクトに 変換する必要はありません。 ジェネリック コレクション クラスが "厳密に型指定されたコレクション" と呼ばれるのは、コレクションの 要素の固有の型をコンパイラが認識しているためで、たとえば、前の例の stringList オブジェクトに整数を追加しようとする と、コンパイル時にエラーが発生します。 詳細については、「ジェネリック」を参照してください。
    List<string> stringList = new List<string>();
stringList.Add("String example");
// compile time error adding a type other than a string:
stringList.Add(4);
  
           暗黙の型、匿名型、および Null 許容値型
前にも説明したとおり、ローカル変数 (クラスのメンバーではない) の型を暗黙的に指定するには、var キーワードを使用します。 変数の型はコンパイル時に決定されますが、その型はコンパイラによって指定されます。 詳細については、「暗黙的に型指定さ れるローカル変数」を参照してください。
メソッドの境界を越えて格納したり受け渡したりする予定のない単純な一連の関連値に名前付きの型を作成するのは便利で はないこともあります。 このような場合は、"匿名型" を作成できます。 詳細については、「匿名型」を参照してください。
通常の値型には、null値を割り当てることができません。しかし、型の後ろに ? を付けることによって、Null許容値型を作成 できます。たとえば、int? は、null値も設定できる int 型です。Null許容値型は一般的な構造体型 System.Nullable<T> のインスタンスです。 Null 許容値型は、数値が null になる可能性のあるデータベースとの間でデータを 受け渡しする場合に、特に便利です。 詳細については、「Null 許容値型」を参照してください。
コンパイル時の型と実行時の型
変数は、コンパイル時と実行時で型が異なる場合があります。 "コンパイル時の型" は、ソースコード内の変数の宣言または推 論された型です。 "実行時の型" は、その変数によって参照されるインスタンスの型です。 次の例に示すように、多くの場合、こ れら 2 つの型は同じです。
そうでない場合、次の 2 つの例に示すように、コンパイル時の型が異なります。
前の例はどちらも、実行時の型が string です。 コンパイル時の型は最初が object 、2 番目が IEnumerable<char> で す。
変数の 2 つの型が異なる場合は、コンパイル時の型と実行時の型が適用されるタイミングを理解することが重要です。 コンパイ ル時の型によって、コンパイラによって実行されるすべてのアクションが決まります。 これらのコンパイラ アクションには、メソッド呼び 出しの解決、オーバーロードの解決、使用できる暗黙的および明示的なキャストが含まれます。 実行時の型によって、実行時 に解決されるすべてのアクションが決まります。 この実行時のアクションには、仮想メソッド呼び出しのディスパッチ、 is と
switch の式と、その他の型のテストAPIの評価が含まれます。コードが型とどのように対話するかを理解するには、どのアク ションがどの型に適用されるかを認識してください。
関連項目 詳細については、次の記事を参照してください。
キャストと型変換 ボックス化とボックス化解除 dynamic 型の使用
値型
参照型 クラスと構造体 匿名型 ジェネリック
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
  string message = "This is a string of characters";
     object anotherMessage = "This is another string of characters";
IEnumerable<char> someCharacters = "abcdefghijklmnopqrstuvwxyz";
     
    す。 関連項目
C# リファレンス
C# プログラミング ガイド XML データ型の変換 整数型

     C# 8.0 で導入された null 許容参照型 および null 非許容参照型 を使用すると、参照型変数のプロパティについて重要 なことを表明できます。
参照が null になることはない。 変数が null にならない場合、コンパイラでは最初に変数が null ではないことをチェックし ないで変数を逆参照しても安全であることを保証する規則が適用されます。
変数は、null 以外の値に初期化される必要があります。
変数に値 null を割り当てることはできません。
参照は null になることがある。 変数が null になる可能性がある場合、コンパイラでは別の規則が適用されて、null 参 照を正しくチェックしていることが確認されます。
値が null ではないことをコンパイラが保証できる場合にのみ、変数を逆参照できます。
これらの変数は、既定値 null で初期化される場合があり、他のコードで値 null を割り当てられる可能性があ ります。
以前のバージョンの C# では変数の宣言から設計の意図を判断できなかったので、この新機能には参照変数の処理について 大きなメリットがあります。 コンパイラでは、参照型の null 参照例外に対する安全性は提供されませんでした。
参照は null にできる。 参照型変数を null に初期化したり、後で null を割り当てたりしても、コンパイラから警告が 発せられることはありません。 これらの変数が null チェックなしで逆参照されていると、コンパイラで警告が発生します。 参照は null ではないと見なされる。 参照型が逆参照されても、コンパイラでは警告は発行されません。 変数が null に なる可能性のある式に設定されている場合、コンパイラで警告が発生します。
これらの警告は、コンパイル時に生成されます。 コンパイラでは、null 許容コンテキストには、null チェックやその他のランタイム コンストラクトは追加されません。 実行時には、null 許容参照と null 非許容参照は等価になります。
null許容参照型の追加により、いっそう明確に意図を宣言できます。 null 値は、変数で値が参照されていないことを表す ための正しい方法です。コードからすべての null 値を削除するために、この機能を使用しないでください。そうではなく、コン パイラと、コードを読む他の開発者に対し、自分の意図を宣言する必要があります。 意図を宣言することにより、その意図と矛 盾するコードを記述すると、コンパイラによって通知されます。
null許容参照型は、null許容値型と同じ構文を使用して記述し、変数の型の後に ? を追加します。たとえば、次の変 数宣言は、null許容型の文字列変数 name を表します。
型の名前に ? が追加されていないすべての変数は、null非許容参照型です。この機能を有効にすると、既存のコードの すべての参照型変数がそれに含まれます。
コンパイラでは、静的分析を使用して、null 許容参照が非 null として認識されているかどうかが判定されます。 コンパイラは、 nullの可能性があるときにnull許容参照を逆参照していると警告します。この動作は、変数名の後にnull免除演算子 ! を使用することでオーバーライドできます。たとえば、変数 name はnullではないことがわかっているのに、コンパイラで警告が 出る場合は、次のようにコードを記述することで、コンパイラの分析をオーバーライドできます。
  string? name;
   name!.Length;
 型の null 値の許容
null 許容参照型 2021/03/06 • • Edit Online
 
 すべての参照型には、4 種類の "null 値の許容" のいずれかを指定でき、それぞれで警告が生成される場合が示されていま す。
"null 非許容" : この型の変数には、null を割り当てることはできません。 この型の変数については、逆参照する前に null チェックを行う必要はありません。
"null許容":この型の変数には、nullを割り当てることができます。先に null をチェックしないでこの型の変数を逆参照 すると、警告が生成されます。
"無関係" : 無関係は、C# 8.0 より前の状態です。 この型の変数を逆参照したり割り当てたりしても、警告は発生しませ ん。
"不明" : 不明は一般に、型が "null 許容" または "null 非許容" でなければならないことが制約によってコンパイラに指示 されない、型パラメーターの場合です。
変数宣言での型の null 値の許容は、変数が宣言されている "null 許容コンテキスト" によって制御されます。 null 許容コンテキスト
null 許容コンテキストでは、コンパイラによる参照型変数の解釈方法を細かく制御できます。 指定されたソース行の null 許 容注釈コンテキスト は、有効または無効です。 C# 8.0 より前のコンパイラでは、無効な null 許容コンテキストですべてのコー ドがコンパイルされると考えることができます。すべての参照型は null にすることができます。 null 許容警告コンテキスト も有 効または無効にすることができます。 null 許容警告コンテキストでは、フロー分析を使用するコンパイラによって生成される警告 が指定されます。
プロジェクトのnull許容注釈コンテキストとnull許容警告コンテキストは、.csprojファイルの Nullable 要素を使用して設定 することができます。 この要素では、コンパイラによって型の null 値の許容が解釈される方法と、生成される警告を構成しま す。 有効な設定は次のとおりです。
enable :null 許容注釈コンテキストは 有効 です。 null 許容警告コンテキストは 有効 です。 参照型の変数(string など)は、null非許容です。null値の許容のすべての警告は有効です。
warnings :null 許容注釈コンテキストは 無効 です。 null 許容警告コンテキストは 有効 です。 参照型の変数は、無関係です。 null 値の許容のすべての警告は有効です。
annotations :null 許容注釈コンテキストは 有効 です。 null 許容警告コンテキストは 無効 です。 参照型の変数 (文字列など) は、null 非許容です。 null 値の許容のすべての警告は無効です。
disable :null 許容注釈コンテキストは 無効 です。 null 許容警告コンテキストは 無効 です。 参照型の変数は無関係であり、以前のバージョンの C# と同じです。 null 値の許容のすべての警告は無効です。
例:
ディレクティブを使用して、プロジェクト内の任意の場所にこれらと同じコンテキストを設定することもできます。
:null 許容注釈コンテキストと null 許容警告コンテキストを、有効 に設定します。
:null 許容注釈コンテキストと null 許容警告コンテキストを、無効 に設定します。
:null 許容注釈コンテキストと null 許容警告コンテキストを、プロジェクトの設定に戻します。
:null 許容警告コンテキストを 無効 に設定します。 :null 許容警告コンテキストを 有効 に設定します。
:null 許容警告コンテキストをプロジェクトの設定に戻します。 :Null 許容の注釈コンテキストを 無効 に設定します。
:Null 許容の注釈コンテキストを 有効 に設定します。 :注釈の警告コンテキストをプロジェクト設定に復元します。
        <Nullable>enable</Nullable>
  #nullable enable
 #nullable disable
  #nullable restore
 #nullable disable warnings
 #nullable enable warnings
 #nullable restore warnings
 #nullable disable annotations
 #nullable enable annotations
  #nullable restore annotations

    既定の null 許容注釈および警告コンテキストは、新しいプロジェクトも含めて 無効 です。 これは、既存のコードを変更せずに コンパイルできて新しい警告は生成されないことを意味します。
これらのオプションでは、null 許容参照型を使用するように既存のコードベースを更新するための 2 つの方法が提供されます。
null 許容注釈コンテキスト
null 許容注釈コンテキストが無効になっていると、コンパイラでは次の規則が使用されます。
無効コンテキスト内で null 許容参照を宣言することはできません。 すべての参照変数には、null 値を割り当てることができます。 参照型の変数が逆参照されても、警告は生成されません。 無効コンテキスト内では、null 免除演算子を使用できません。
動作は、以前のバージョンの C# と同じです。
null 許容注釈コンテキストが有効になっていると、コンパイラでは次の規則が使用されます。
参照型のすべての変数は、null 非許容参照 です。
すべての null 非許容参照は、安全に逆参照できます。
すべてのnull許容参照型(変数宣言で型の後に ? を付けて示されているもの)は、nullにすることができます。静的分 析によって、逆参照されるときに値が null 以外であることがわかっているかどうかが決定されます。 そうでない場合、コンパイ ラで警告が出ます。
null 免除演算子を使用して、null 許容参照が null ではないことを宣言できます。
null許容注釈コンテキストが有効になっていると、参照型に追加された ? 文字により、null許容参照型が宣言されます。 null 免除演算子 ! を式に追加して、式が null ではないことを宣言できます。
null 許容警告コンテキスト
null 許容警告コンテキストは、null 許容注釈コンテキストとは異なります。 新しい注釈が無効になっている場合でも、警告を 有効にすることができます。 コンパイラでは、静的フロー解析を使用して、参照の null 状態 が決定されます。 null 許容警告 コンテキスト が 無効 ではない場合、null 状態は null ではない または null かもしれない です。 コンパイラが null かもし れない と判断したときに、参照を逆参照した場合は、コンパイラで警告が出ます。 コンパイラが次の 2 つの条件のいずれかで あると判断できない場合、参照の状態は null かもしれない になります。
1. 変数に null 以外の値が確実に割り当てられている。
2. 変数または式は、それを逆参照する前に null かどうかをチェックされている。
null 許容警告コンテキストで null かもしれない 変数または式を逆参照すると、コンパイラで警告が生成されます。 さらに、 null 許容注釈が有効にされたコンテキストで null かもしれない 変数または式に null 非許容参照型変数を割り当てると、コ
   IMPORTANT
グローバルな Null 許容コンテキストは、生成されたコード ファイルに適用されません。 いずれの方法でも、Null 許容コンテキストは、生成済 みとしてマークされているすべてのソース ファイルに対して "無効になります"。 これは、生成されたファイル内のどの API にも注釈が付けられな いことを意味します。 ファイルが生成済みとしてマークされる方法は 4 つあります。
1. .editorconfigで、そのファイルに適用されるセクションで を指定します。
2. ファイルの先頭にあるコメントに または を配置します。 これは、コメント内の任意の行に
配置できますが、コメント ブロックはファイル内の最初の要素である必要があります。 3. ファイル名を TemporaryGeneratedFile_ で開始します
4. ファイル名の末尾を .designer.cs、 .generated.cs、 .g.cs、または .g.i.cs にします。
ジェネレーターは、 #nullable プリプロセッサ ディレクティブを使用してオプトインできます。
 generated_code = true
  <auto-generated>
<auto-generated/>
  
  ンパイラで警告が生成されます。 属性で API を記述する
引数または戻り値を null にできるとき、またはできないときについての詳細情報をコンパイラに提供する属性を、API に追加し ます。 これらの属性の詳細については、null 許容属性について説明されている言語リファレンスの記事を参照してください。 こ れらの属性は、現在および今後のリリースで .NET ライブラリに追加されます。 最もよく使用される API が最初に更新されます。
既知の落とし穴
参照型を含む配列および構造体は、null 許容参照型機能の既知の落とし穴です。
構造体
null非許容の参照型を含む構造体により、警告なしで default を割り当てることができます。次の例を確認してください。
     using System;
#nullable enable
public struct Student
{
    public string FirstName;
    public string? MiddleName;
    public string LastName;
}
public static class Program
{
    public static void PrintStudent(Student student)
    {
        Console.WriteLine($"First name: {student.FirstName.ToUpper()}");
        Console.WriteLine($"Middle name: {student.MiddleName.ToUpper()}");
        Console.WriteLine($"Last name: {student.LastName.ToUpper()}");
}
    public static void Main() => PrintStudent(default);
}
    前の例では PrintStudent(default) に警告はありませんが、null非許容の参照型 FirstName と LastName はnullで す。
もう 1 つの一般的なケースは、ジェネリック構造体を扱う場合です。 次の例を確認してください。
    #nullable enable
public struct Foo<T>
{
    public T Bar { get; set; }
}
public static class Program
{
    public static void Main()
    {
        string s = default(Foo<string>).Bar;
    }
}
 前の例では、プロパティ Bar は実行時に null になり、null非許容の文字列には警告なしで割り当てられます。 配列

     配列も null 許容参照型の既知の落とし穴です。 警告が生成されない次の例を考えてみます。
    using System;
#nullable enable
public static class Program
{
    public static void Main()
    {
} }
string[] values = new string[10];
string s = values[0];
Console.WriteLine(s.ToUpper());
 前の例では、null 非許容の文字列が保持され、その要素がすべて null に初期化されることが配列の宣言からわかります。 そ の後、変数 s にnull値が割り当てられます(配列の最初の要素)。最後に、変数 s が逆参照され、ランタイム例外が発 生します。
関連項目
null 許容参照型仕様の下書き
null 許容参照の概要チュートリアル 既存のコードベースを null 許容参照に移行する -nullable (C# コンパイラ オプション)

    null許容参照型を追加するということは、すべての変数で null 値が許可または要求されるかどうかを宣言できることを意味 します。 さらに、いくつかの属性 ( AllowNull 、 DisallowNull 、 MaybeNull 、 NotNull 、 NotNullWhen 、 MaybeNullWhen 、
NotNullIfNotNull ) を適用して、引数と戻り値の null 状態を完全に記述することもできます。 それにより、コードを記述する ときに優れたエクスペリエンスが提供されます。null非許容変数が null に設定される可能性がある場合は、警告が表示さ れます。 null 許容変数が逆参照される前に null チェックが行われていない場合、警告が表示されます。 ライブラリの更新に は時間がかかることがありますが、メリットにはそれだけの価値があります。 "どのようなときに" null 値が許可または禁止される かについて、コンパイラに提供する情報が多いほど、より適切な警告が API のユーザーに示されます。 よくある例から始めましょ う。 ライブラリに、リソース文字列を取得するための次の API があるとします。
前述の例では、.NETのよくある Try* パターンに従っています。このAPIには、2つの参照引数(key および message パラ メーター) があります。 この API には、これらの引数の null 性に関連する次の規則があります。
呼び出し元では、 key の引数として null を渡すことはできません。 呼び出し元では、 message の引数として、値が null の変数を渡すことができます。
メソッドから true が返された場合、 message の値は null ではありません。 戻り値が false, である場 合、 (およびその null 状態) の値は null です。
key の規則は、変数型によって完全に表すことができます。key はnull非許容参照型である必要があります。 message パラメーターはより複雑です。引数として null が許可されますが、成功した場合、out 引数がnullでないことが保証され ます。 これらのシナリオでは、予測を記述するために、より豊富なボキャブラリが必要です。
null許容参照用にライブラリを更新すると、一部の変数や型名に ? を指定する以上のことが必要になります。前の例では、 API を調べて、各入力引数について想定されることを検討する必要があることが示されています。 戻り値の保証と、メソッドから 戻るときの out または ref 引数について検討します。次に、それらの規則をコンパイラに通知します。呼び出し元がそれら の規則を守らないと、コンパイラによって警告が示されます。
この作業には時間がかかります。 他の要件とバランスを取りながら、ライブラリまたはアプリケーションを null 許容対応にするため の戦略から始めましょう。 実行中の開発で null 許容参照型を有効にするときにバランスを取る方法について説明します。 ジェネリック型定義の課題について学習します。 属性を適用して、個々の API の事前条件と事後条件を記述する方法につい て学習します。
null 許容参照型に関する戦略を選択する
最初に選択することは、null 許容参照型を既定でオンまたはオフにするかどうかです。 次の 2 つの方法があります。
プロジェクト全体について null 許容参照型を有効にし、準備ができていないものをコードで無効にします。 null 許容参照型の注釈が付けられたコードについてのみ、null 許容参照型を有効にします。
最初の方法は、null 許容参照型対応に更新するときに、他の機能をライブラリに追加する場合に最も適しています。 すべて の新規開発は null 許容対応です。 既存のコードを更新するときに、それらのクラスで null 許容参照型を有効にします。
この最初の戦略に従う場合は、次の手順のようにします。
1. csproj ファイルに   要素を追加することにより、プロジェクト全体で null 許容参照型を有
         bool TryGetMessage(string key, out string message)
      TryGetMessage
 message
 null 許容参照型を使用するようにライブラリを更
新し、null 許容規則を呼び出し元に伝える 2021/03/06 • • Edit Online
  <Nullable>enable</Nullable>
 
  効にします。
2. プロジェクト内のすべてのソース ファイルに #nullable disable プラグマを追加します。
3. 各ファイルの作業を行うときに、プラグマを削除し、警告が発生したら対処します。
この最初の戦略の場合、すべてのファイルにプラグマを追加するための事前作業が多くなります。 利点は、プロジェクトに追加さ れるすべての新しいコード ファイルで null 許容が有効になることです。 新しい作業はすべて null 許容対応になります。既存の コードのみを更新する必要があります。
2 番目の戦略は、ライブラリが安定している場合に適しており、開発の主な目的は null 許容参照型を導入することになりま す。 API に注釈を付けるときに、null 許容参照型を有効にします。 終了した時点で、プロジェクト全体について null 許容参 照型が有効になります。
この 2 番目の戦略に従う場合は、次の手順のようにします。
1. null 許容対応にするファイルに #nullable enable プラグマを追加します。
2. すべての警告に対処します。
3. ライブラリ全体を null 許容対応にするまで、これら最初の 2 つの手順を続けます。
4.csprojファイルに <Nullable>enable</Nullable> 要素を追加することにより、プロジェクト全体でnull許容型を有効にし
ます。
5. #nullable enable プラグマは不要になったため、削除します。
この 2 番目の戦略は、事前の作業が少なくなります。 トレードオフは、新しいファイルを作成するときの最初のタスクが、プラグマ を追加し、それを null 許容対応にすることであるということです。 チームの開発者がそれを忘れた場合、その新しいコードは、す べてのコードを null 許容対応にするという作業が発生します。
どちらの戦略を選択するかは、プロジェクトで行われているアクティブな開発の量によって異なります。 プロジェクトが成熟して安 定しているほど、2 番目の戦略がふさわしくなります。 開発中の機能が多いほど、最初の戦略が優れています。
        IMPORTANT
グローバルな Null 許容コンテキストは、生成されたコード ファイルに適用されません。 いずれの方法でも、Null 許容コンテキストは、生成済 みとしてマークされているすべてのソース ファイルに対して "無効になります"。 これは、生成されたファイル内のどの API にも注釈が付けられな いことを意味します。 ファイルが生成済みとしてマークされる方法は 4 つあります。
1. .editorconfigで、そのファイルに適用されるセクションで を指定します。
2. ファイルの先頭にあるコメントに または を配置します。 これは、コメント内の任意の行に
配置できますが、コメント ブロックはファイル内の最初の要素である必要があります。 3. ファイル名を TemporaryGeneratedFile_ で開始します
4. ファイル名の末尾を .designer.cs、 .generated.cs、 .g.cs、または .g.i.cs にします。
ジェネレーターは、 #nullable プリプロセッサ ディレクティブを使用してオプトインできます。
 generated_code = true
  <auto-generated>
<auto-generated/>
  null 許容の警告によって破壊的変更が発生するか
null 許容参照型を有効にする前は、変数は "null 許容が認識されていない" ものと見なされます。 null 許容参照型を有効 にすると、そのような変数はすべて "null 非許容" になります。 そのような変数が null 以外の値に初期化されていない場合、 コンパイラで警告が発生します。
警告が発生する可能性があるもう 1 つの原因は戻り値で、値が初期化されていない場合です。
コンパイラの警告に対処するための最初の手順は、パラメーターと戻り値の型で ? 注釈を使用して、引数または戻り値が null になる可能性があるときを示すことです。 参照変数が null であってはならないときは、元の宣言が正しくなります。 この作 業を行うときの目標は、警告を修正することだけではありません。 より重要な目標は、null 値の可能性があるという意図をコン パイラに理解させることです。 警告を確認すると、ライブラリに関する次の重要な決定がわかります。 設計の意図をより明確に 伝えるために、APIのシグネチャの変更を検討しますか。前に調べた TryGetMessage メソッドのより優れたAPIシグネチャは次
 
   のようになります。
  string? TryGetMessage(string key);
 戻り値は成功または失敗を示し、値が見つかった場合は値を保持します。 多くの場合、API のシグネチャを変更すると、null 値の伝達方法が向上する可能性があります。
ただし、パブリック ライブラリや、ユーザー ベースの大きいライブラリでは、API のシグネチャを変更しない方がよい場合があります。 そのような場合や、他の一般的なパターンでは、属性を適用することで、引数または戻り値が null になる可能性がある場合 をより明確に定義できます。 API のサーフェイスの変更を検討するかどうかにかかわらず、型の注釈だけでは、引数または戻り 値での null 値を記述するのに十分ではないことがわかるでしょう。そのような場合は、属性を適用することでAPIをより明確 に記述できます。
属性で型の注釈を拡張する
変数の null 状態に関する追加情報を表すために、いくつかの属性が追加されました。 C# 8 で null 許容参照型型が導入さ れる前に記述したすべてのコードでは、"null が認識されません" でした。 つまり、参照型変数は null である可能性があります が、nullチェックは必須ではありません。コードが"null許容認識"になると、それらの規則は変わります。参照型を null 値 にすることはできません。また、null許容参照型は、逆参照される前に null に対してチェックする必要があります。
APIの規則は、TryGetValue APIシナリオで見たとおり、より複雑になる可能性があります。多くのAPIには、変数を null にできる場合やできない場合のより複雑な規則があります。 このような場合は、属性を使用してそれらの規則を表します。 API のセマンティクスを記述する属性については、null 許容の分析に影響を与える属性に関する記事を参照してください。
ジェネリック定義と null 値の許容
ジェネリック型とジェネリック メソッドの null 状態を正しく伝えるには、特別な注意が必要です。 特別な注意が必要になる原因 は、null許容値型とnull許容参照型が根本的に異なるという事実です。 int? が Nullable<int> のシノニムであるのに 対し、 string? はコンパイラによって追加された属性を持つ string です。 結果として、 T が class または struct のど ちらであるかがわからないと、コンパイラで T? の正しいコードを生成できません。
これは、クローズ ジェネリック型の型引数として null 許容型 (値型または参照型) を使用できないという意味ではありません。 List<string?> と List<int?> はどちらも、 List<T> の有効なインスタンス化です。
それが意味しているのは、制約なしにジェネリッククラスまたはメソッドの宣言で T? を使用することはできない、ということです。 たとえば、Enumerable.FirstOrDefault<TSource>(IEnumerable<TSource>)は T? を返すように変更されません。この 制限を克服するには、 struct または class のいずれかの制約を追加します。 それらの制約のいずれかを指定すると、コン パイラで T と T? の両方のコードを生成する方法が認識されます。
ジェネリック型引数に使用される型を、null非許容型に制限することができます。そのためには、その型引数に notnull 制約 を追加します。 その制約が適用されているときは、型引数を null 許容型にすることはできません。
遅延初期化されるプロパティ、データ転送オブジェクト、および null 値の許容 遅延初期化される (構築後に設定されるという意味です) プロパティの null 値の許容を示す場合、クラスで本来の設計意図
が引き続き正しく表現されるよう、特別な配慮が必要になる場合があります。
データ転送オブジェクト (DTO) など、遅延初期化されるプロパティを含む型は、多くの場合、データベース ORM (Object Relational Mapper) のような外部ライブラリ、逆シリアライザー、または別のソースから自動的にプロパティを設定するその他のコ ンポーネントによってインスタンス化されます。
null 許容参照型を有効にする前に、ある学生を表す次の DTO クラスについて考えてください。
          
     設計の意図 (この例では Required 属性によって示されます) として、このシステムでは、 FirstName および LastName プロパ ティは 必須 であり、したがって null ではないことが示されています。
VehicleRegistration プロパティは必須ではないため、nullにできます。
null 許容参照型を有効にするときは、本来の意図と一致するように、null 許容にできる DTO のプロパティを指定します。
     class Student
{
    [Required]
    public string FirstName { get; set; }
    [Required]
    public string LastName { get; set; }
    public string? VehicleRegistration { get; set; }
}
  このDTOの場合、nullにできる唯一のプロパティは VehicleRegistration です。
ただし、 FirstName と LastName の両方に対しては、null 非許容のプロパティが初期化されていないことを示す警告
がコンパイラによって生成されます。
元の意図が維持されるような方法でコンパイラの警告を解決するために使用できるオプションが 3 つあります。 これらのオプショ ンはいずれも有効です。コーディング スタイルと設計要件に最も適したものを選択する必要があります。
コンストラクター内で初期化する 初期化されていないという警告を解決するための最善の方法は、プロパティをコンストラクター内で初期化することです。
   CS8618
    class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
    [Required]
    public string FirstName { get; set; }
    [Required]
    public string LastName { get; set; }
    public string? VehicleRegistration { get; set; }
}
 この方法は、クラスのインスタンスを作成するために使用するライブラリで、コンストラクターにパラメーターを渡すことがサポートされ ている場合にのみ機能します。
   class Student
{
    [Required]
    public string FirstName { get; set; }
    [Required]
    public string LastName { get; set; }
    public string VehicleRegistration { get; set; }
}
 
     ライブラリでコンストラクターに全部のプロパティではなく "一部" だけを渡すことがサポートされている場合があります。 たとえば、 EF Core では、通常の列プロパティについてのコンストラクター バインドはサポートされていますが、ナビゲーション プロパティについ てはサポートされていません。
クラスのインスタンスを作成するライブラリのドキュメントを調べて、コンストラクター バインドがサポートされている範囲を理解してく ださい。
null 許容バッキング フィールドを持つプロパティ
コンストラクター バインドが機能しない場合、この問題に対処する方法の 1 つは、null 許容バッキング フィールドを持つ null 非
許容プロパティを使用することです。
    private string? _firstName;
[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
}
?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
  このシナリオでは、初期化される前の プロパティにアクセスすると、API コントラクトが正しく使用されていないため、 コードで がスローされます。
バッキング フィールドを使用するときは、一部のライブラリに特別な考慮事項があることに注意してください。 たとえば、EF Core はバッキング フィールドを正しく使用するように構成することが必要な場合があります。
プロパティを null に初期化する
null 許容バッキング フィールドの使用に代わるさらに簡潔な方法として、またはクラスのインスタンスを作成するライブラリがその
方法と互換性を持たない場合は、null免除演算子(!)を使用して、プロパティを null に直接初期化できます。
適切に初期化される前にプロパティにアクセスするプログラミングのバグの結果の場合を除き、実行時に実際の null 値が観察 されることはありません。
関連項目
既存のコードベースを null 許容参照に移行する EF Core での null 許容参照型の使用
FirstName
 InvalidOperationException
    [Required]
public string FirstName { get; set; } = null!;
[Required]
public string LastName { get; set; } = null!;
public string? VehicleRegistration { get; set; }
 
            C# プログラミングでは、名前空間が 2 つの方法でよく使用されます。 最初の方法では、次のように .NET で名前空間を使用 して、その多くのクラスを整理します。
Systemは名前空間で、Consoleはその名前空間内のクラスです。以下の例のように、using キーワードを使用できるた め、完全な名前は必要ありません。
詳細については、「using ディレクティブ」をご覧ください。
2 つ目の方法では、独自の名前空間を宣言します。これは、より大きなプログラミング プロジェクトでクラス名とメソッド名のス
コープを制御するのに役立ちます。 名前空間を宣言するには、以下の例のように、namespace キーワードを使用します。
  System.Console.WriteLine("Hello World!");
   using System;
   Console.WriteLine("Hello World!");
     namespace SampleNamespace
{
    class SampleClass
    {
        public void SampleMethod()
        {
} }
}
System.Console.WriteLine(
  "SampleMethod inside SampleNamespace");
 名前空間の名前を、有効な C# の識別子名にする必要があります。
名前空間の概要 名前空間には次の特徴があります。
大きなコード プロジェクトを整理します。
. 演算子を使用して、区切られます。
using ディレクティブを使用すると、クラスごとに名前空間の名前を指定する必要がなくなります。
global 名前空間は"ルート"名前空間です。global::System は常に.NET名前空間のSystemを参照します。
C# 言語仕様
詳細については、C# 言語仕様に関する記事の「名前空間」に関するセクションを参照してください。
関連項目
  C# プログラミング ガイド
名前空間 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
      名前空間の使用
My 名前空間を使用する方法 識別子名
using ディレクティブ
::演算子

   C# は、厳密に型指定された言語です。 すべての変数および定数は、値に評価されるすべての式がそうであるように、型を持ち ます。 すべてのメソッド シグネチャで、各入力パラメーターの型と戻り値の型が指定されます。 .NET クラス ライブラリでは、一連 の組み込みの数値型が定義され、さらにファイル システム、ネットワーク接続、オブジェクトのコレクション、オブジェクトの配列、日 付など、さまざまな論理構造を表すより複雑な型も定義されています。 一般的な C# プログラムでは、クラス ライブラリで定義 されている型と、そのプログラムの問題領域に固有の概念をモデル化するユーザー定義の型が使用されます。
型には、次のような情報が保存されます。 その型の変数が必要とする記憶領域。 表すことができる最大値と最小値。
含まれるメンバー (メソッド、フィールド、イベントなど)。 継承元となった基本型。 実装されるインターフェイス。 実行時に変数に割り当てられるメモリの場所。 許可される演算の種類。
コンパイラは型情報を使用して、コード内で実行されるすべての演算が "タイプ セーフ" であることを確認します。 たとえば、int 型の変数を宣言すると、その変数は加算演算と減算演算で使用できます。 同じ演算を bool 型の変数に対して実行しようと すると、コンパイラで次の例のようなエラーが発生します。
    int a = 5;
int b = a + 2; //OK
bool test = true;
// Error. Operator '+' cannot be applied to operands of type 'int' and 'bool'.
int c = a + test;
     NOTE
C や C++ と異なり、C# では、bool を int に変換することはできません。
 コンパイラは、型情報を実行可能ファイル内にメタデータとして埋め込みます。 共通言語ランタイム (CLR: Common Language Runtime) は、実行時にこのメタデータを使用して、メモリの割り当て時および再要求時に、タイプ セーフであるかど うかを再度確認します。
変数宣言での型の指定
プログラム内で変数や定数を宣言するときは、その型を指定するか、var キーワードを使用して、コンパイラが型を推論できるよ うにする必要があります。 次の例では、組み込みの数値型と複雑なユーザー定義の型の両方を使用する変数宣言を示しま す。
型、変数、および値
2021/03/16 • • Edit Online
 
      メソッドのパラメーターおよび戻り値の型は、メソッド シグネチャで指定します。 入力引数として int を使用する必要があり、戻り 値として文字列を返すメソッドのシグネチャを次に示します。
    public string GetName(int ID)
{
    if (ID < names.Length)
        return names[ID];
    else
        return String.Empty;
}
private string[] names = { "Spencer", "Sally", "Doug" };
 変数を宣言すると、新しい型を使用してその変数を再度宣言することはできず、宣言された型と互換性のない値をその変数に 代入することはできません。たとえば、intを宣言してから、それに true のブール値を代入することはできません。ただし、たと えば新しい変数に代入するときや、メソッドの引数として渡すときに、値を他の型に変換することは可能です。 データの損失を 伴わない "型変換" は、コンパイラによって自動的に実行されます。 データの損失を伴う可能性のある変換には、ソース コード に cast を記述する必要があります。
詳細については、「キャストと型変換」を参照してください。 組み込み型
C# には、整数、浮動小数点値、ブール式、テキスト文字、10 進数値などのデータを表現するための標準的な組み込みの数 値型が用意されています。 また、組み込みの string 型と object 型もあります。 これらの型は、すべての C# プログラムで使 用できます。 組み込み型の完全な一覧については、組み込みの型に関するページを参照してください。
カスタム型
独自のカスタム型を作成するには、struct、class、record、interface、および enum の各構造体を使用します。 .NET クラス ライブラリ自体が、マイクロソフトによって提供された、ユーザーが独自のアプリケーションで使用できるカスタムの型のコレクションで す。 既定では、クラス ライブラリで最も頻繁に使用される型は任意の C# プログラムで使用可能になっています。 その他の型 は、その型が定義されているアセンブリへのプロジェクト参照を明示的に追加した場合にのみ使用可能になります。 コンパイラが アセンブリを参照できるようになると、そのアセンブリ内で宣言されている型の変数 (および定数) をソース コード内で宣言できる ようになります。
ジェネリック型
クライアント コードが型のインスタンスを作成したときに提供される実際の型 (具象型) のプレースホルダーとして使用される 1 つ 以上の 型パラメーター で、型を宣言することもできます。 このような型は、ジェネリック型 と呼ばれます。 たとえば、List<T> に は、慣例により T という名前が与えられる 1 つの型パラメーターがあります。この型のインスタンスを作成するときには、たとえば 文字列の場合なら、リストに含まれるオブジェクトの型を次のように指定します。
   // Declaration only:
float temperature;
string name;
MyClass myClass;
// Declaration with initializers (four examples):
char firstLetter = 'C';
var limit = 3;
int[] source = { 0, 1, 2, 3, 4, 5 };
var query = from item in source
            where item <= limit
select item;
 
          型パラメーターを使用することで、同じクラスを再利用して任意の型の要素を格納できます。このとき、各要素をオブジェクトに 変換する必要はありません。 ジェネリック コレクション クラスが "厳密に型指定されたコレクション" と呼ばれるのは、コレクションの 要素の固有の型をコンパイラが認識しているためで、たとえば、前の例の strings オブジェクトに整数を追加しようとすると、コ ンパイル時にエラーが発生します。 詳細については、「ジェネリック」を参照してください。
暗黙の型、匿名型、および Null 許容型
前に説明したように、var キーワードを使用すると、ローカル変数 (クラスのメンバーではない) の型を暗黙的に指定できます。 変数の型はコンパイル時に決定されますが、その型はコンパイラによって指定されます。 詳細については、「暗黙的に型指定さ れたローカル変数」を参照してください。
場合によっては、メソッドの境界を越えて格納したり受け渡したりする予定のない単純な一連の関連値に名前付きの型を作 成するのは便利ではないこともあります。 このような場合は、匿名型 を作成できます。 詳細については、「匿名型」を参照して ください。
1 つのメソッドから複数の値を返したいというのはよくあることです。 そのような場合は、1 つのメソッド呼び出しで複数の値を返 す タプル型 を作成できます。 詳細については、タプル型に関するページを参照してください。
共通型システム
.NET で型システムを使用する場合は、次の 2 つの基本事項を理解しておく必要があります。
継承の原則がサポートされています。 他の型から型を派生させることができます。派生元の型は "基本型" と呼ばれま す。 派生した型は、基本型のメソッド、プロパティ、およびその他のメンバーを (若干の制限付きで) 継承します。 基本 型もなんらかの他の型から派生できます。この場合、派生した型はその継承階層内の両方の基本型のメンバーを継承 します。 Int32 (C# のキーワード: int ) などの組み込み数値型を含むすべての型は、最終的に Object (C# のキー ワード: object ) という単一の基本型から派生します。 この一元化された型階層は、共通型システム (CTS) と呼ばれ ます。 C# での継承の詳細については、「継承」を参照してください。
CTS の各型は、"値型" または "参照型" として定義されます。 これは、.NET クラス ライブラリのすべてのカスタムの型 や、ユーザーが独自に定義した型にも当てはまります。 struct または enum キーワードを使用して定義する型は値 型です。 値型の詳細については、値型に関するページを参照してください。 class キーワードを使用して定義した型 は、参照型です。 参照型の詳細については、「Classes」を参照してください。 参照型と値型では、コンパイル時の規 則や実行時の動作が異なります。
関連項目
構造体型 列挙型 クラス
    List<string> strings = new List<string>();
 
     参照型
class として定義された型は、参照型 です。 実行時には、参照型の変数を宣言すると、new 演算子を使用してクラスのイン スタンスを明示的に作成するまで、変数には値 null が格納されています。または、次の例に示すように、別の場所で作成され た可能性がある、互換性のある型のオブジェクトを代入することもできます。
オブジェクトが作成されると、その特定のオブジェクトに対してマネージド ヒープ上で十分なメモリが割り当てられ、変数にはそのオ ブジェクトの場所への参照のみが格納されます。 マネージド ヒープを使用する型では、メモリの割り当て時と、CLR の自動メモリ 管理機能 ("ガベージ コレクション") による再要求時の両方についてオーバーヘッドが発生します。 しかし、ガベージ コレクション も高度に最適化されるため、ほとんどのシナリオでは、パフォーマンス上の問題が発生することはありません。 ガベージ コレクショ ンの詳細については、「自動メモリ管理とガベージ コレクション」を参照してください。
クラスの宣言
クラスは、次の例に示すように、class キーワードと、その後に続ける一意の識別子を使用して宣言します。
class キーワードは、アクセスレベルの後に配置します。この例では、publicが使用されているため、誰でもこのクラスのインス タンスを作成できます。 class キーワードの後にクラスの名前を記述します。クラスの名前を、有効なC#の識別子名にする 必要があります。 定義の残りの部分がクラス本体で、そこで動作とデータを定義します。 クラスのフィールド、プロパティ、メソッ ド、およびイベントは クラス メンバー と総称されます。
オブジェクトの作成
クラスとオブジェクトは、同義的に使用されることがありますが、これらは異なるものです。 クラスはオブジェクトの型を定義します が、オブジェクト自体ではありません。 オブジェクトは、クラスに基づく具体的なエンティティであり、クラスのインスタンスと呼ばれる こともあります。
オブジェクトを作成するには、次のように、new キーワードの後にオブジェクトの基になるクラスの名前を指定します。
クラスのインスタンスを作成すると、そのオブジェクトへの参照が返されます。 前の例の object1 は、 Customer に基づくオブ ジェクトへの参照です。 この参照は、新しいオブジェクトを参照しますが、オブジェクト データ自体を含みません。 実際、オブジェ クト参照は、オブジェクトを作成しなくても作成できます。
    //Declaring an object of type MyClass.
MyClass mc = new MyClass();
//Declaring another object of the same type, assigning it the value of the first object.
MyClass mc2 = mc;
     //[access modifier] - [class] - [identifier]
public class Customer
{
   // Fields, properties, methods and events go here...
}
   Customer object1 = new Customer();
   クラス (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
         上のような、オブジェクトを参照しないオブジェクト参照を作成するのはお勧めしません。実行時にこのような参照を通じてオブ ジェクトへのアクセスを試みると失敗するからです。 ただし、新しいオブジェクトを作成するか、既存のオブジェクトを割り当てると、 このような参照でオブジェクトを参照できるようになります。次に例を示します。
上のコードでは、同じオブジェクトを参照する2つのオブジェクト参照が作成されます。そのため、object3 を通じて行われたオ ブジェクトの変更は、後で object4 を使用するときに反映されます。これは、クラスに基づくオブジェクトが参照によって参照さ れるからです。このためクラスは参照型と呼ばれています。
クラスの継承
クラスは、オブジェクト指向プログラミングの基本的な特性である "継承" を完全にサポートします。 クラスを作成するとき は、sealed として定義されているものを除く、他のすべてのクラスから継承できます。また、作成したクラスから他のクラスを継承 し、クラスの仮想メソッドをオーバーライドすることもできます。 さらに、1 つまたは複数のインターフェイスを実装できます。
継承は、派生 を使用して行われます。派生とは、データの動作の継承元である 基底クラス を使用してクラスを宣言することを 意味します。 基底クラスは、派生クラス名の後に、コロンと基底クラス名を追加して指定します。次に例を示します。
クラスで基底クラスを宣言している場合、基底クラスのすべてのメンバー (コンストラクター以外) が継承されます。 詳細について は、「継承」を参照してください。
C++ と異なり、C# のクラスは 1 つの基底クラスから直接継承することしかできません。 ただし、基底クラス自体が別のクラスを 継承している場合があるため、1 つのクラスに複数の基底クラスが間接的に継承されることもあります。 さらに、クラスは 1 つまた は複数のインターフェイスを直接実装できます。 詳細については、「インターフェイス」を参照してください。
クラスは抽象としても宣言できます。 抽象クラスには、シグネチャ定義が存在し、実装は存在しない抽象メソッドが含まれてい ます。 抽象クラスはインスタンス化できません。 抽象クラスを使用するには、抽象メソッドを実装する派生クラスを介する必要が あります。 これとは対照的に、シール クラスは、他のクラスに派生させることはできません。 詳細については、「抽象クラスとシー ル クラス、およびクラス メンバー」を参照してください。
クラス定義は、別々のソース ファイルに分割できます。 詳細については、「部分クラスと部分メソッド」を参照してください。 例
次の例では、自動実装プロパティ、メソッド、およびコンストラクターという特殊なメソッドをそれぞれ 1 つずつ含むパブリック クラス を定義しています。 詳しくは、プロパティ、メソッド、およびコンス トラクターに関するトピックを参照してください。 このクラスのイン スタンスは、 new キーワードによってインスタンス化されます。
    Customer object3 = new Customer();
Customer object4 = object3;
       public class Manager : Employee
{
    // Employee fields, properties, methods and events are inherited
    // New Manager fields, properties, methods and events go here...
}
  Customer object2;
 
          C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミング ガイド オブジェクト指向プログラミング ポリモーフィズム
識別子名
メンバー メソッド
  using System;
public class Person
{
    // Constructor that takes no arguments:
    public Person()
    {
        Name = "unknown";
    }
    // Constructor that takes one argument:
    public Person(string name)
    {
Name = name; }
    // Auto-implemented readonly property:
    public string Name { get; }
    // Method that overrides the base class (System.Object) implementation.
    public override string ToString()
    {
        return Name;
    }
}
class TestPerson
{
    static void Main()
    {
        // Call the constructor that has no parameters.
        var person1 = new Person();
        Console.WriteLine(person1.Name);
        // Call the constructor that has one parameter.
        var person2 = new Person("Sarah Jones");
        Console.WriteLine(person2.Name);
        // Get the string representation of the person2 instance.
        Console.WriteLine(person2);
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
// Output:
// unknown
// Sarah Jones
// Sarah Jones

    コンストラクター ファイナライザー オブジェクト

   タプルでは、軽量な処理でメソッドの呼び出しから複数の値を取得することができます。 ただし、タプルを取得した場合は、その 個々の要素を処理する必要があります。 このような処理を要素ごとに行うことは手間がかかります。次に例を示します。
QueryCityData メソッドは3つのタプルを返し、その各要素は別の操作の変数に割り当てられます。
     using System;
public class Example
{
    public static void Main()
    {
        var result = QueryCityData("New York City");
        var city = result.Item1;
        var pop = result.Item2;
        var size = result.Item3;
         // Do something with the data.
    }
    private static (string, int, double) QueryCityData(string name)
    {
        if (name == "New York City")
            return (name, 8175133, 468.48);
        return ("", 0, 0);
    }
}
 1 つのオブジェクトから複数のフィールドとプロパティの値を取得する処理も同様に煩雑です。メンバーごとにフィールドまたはプロ パティの値を変数に割り当てる必要があります。
C# 7.0 以降、単一の 分解 操作で、タプルから複数の要素を取得したり、オブジェクトから複数のフィールド、プロパティ、および 計算値を取得したりできるようになりました。 タプルを分解するときに、その要素を個々の変数に割り当てます。 オブジェクトを 分解するときに、選択した値を個々の変数に割り当てます。
タプルの分解
C# には、タプルの分解を組み込みでサポートしているという特長があり、単一操作でタプル内のすべての項目を展開することが できます。 タプルを分解する一般的な構文は、タプルを定義する構文と似ています。代入ステートメントの左側で変数をかっこ で囲み、その各要素に割り当てられます。 たとえば、次のステートメントは、4 タプルの要素を 4 つの別の変数に割り当てます。
タプルの分解には 3 つの方法があります。
かっこ内の各フィールドの型を明示的に宣言することができます。 次の例では、この方法を使用して、 QueryCityData メソッドから返される 3 タプルを分解します。
  var (name, address, city, zip) = contact.GetAddressInfo();
  タプルとその他の型の分解
2021/03/06 • • Edit Online
 
  C#で各変数の型を推定するには、var キーワードを使用できます。 var キーワードはかっこの外に配置します。次 の例では、QueryCityData メソッドから返される3タプルを分解するときに型の推定を使用します。
また、かっこ内の変数宣言のいずれかまたはすべてについて、個々に var キーワードを使用することもできます。
ただし、この処理は煩雑なため推奨されません。 最後に、既に宣言されている変数にタプルを分解することができます。
     public static void Main()
{
    var (city, population, area) = QueryCityData("New York City");
    // Do something with the data.
}
     public static void Main()
{
    (string city, var population, var area) = QueryCityData("New York City");
    // Do something with the data.
}
     public static void Main()
{
    string city = "Raleigh";
    int population = 458880;
    double area = 144.8;
    (city, population, area) = QueryCityData("New York City");
    // Do something with the data.
}
 タプル内のフィールドすべての型が同じでも、かっこ外では指定できない型があることに注意してください。 この場合、コンパイル エラーCS8136"分解 変数 (...) フォームは特定の種類の'変数'を許可しません"が生成されます。
また、タプルの各要素も変数に割り当てる必要があります。 いずれかの要素を省略すると、コンパイラでエラー CS8132 " 'x' 要 素のタプルを 'y' 変数に分解することはできません" が生成されます。
分解の左側にある既存の変数に宣言と割り当てを混在させることはできません。 メンバーに新しく宣言された変数と既存の変 数が含まれる場合、コンパイラでエラー CS8184 "分解の左側で宣言と式を混用できません" が生成されます。
破棄によるタプル要素の分解
タプルを分解する場合、一部の要素の値のみが必要なことがよくあります。 C# 7.0 以降、C# の 破棄 のサポートを利用できる ようになりました。破棄は、無視対象と選択した値が指定された書き込み専用の変数です。 破棄を指定するには、割り当て 内でアンダースコア文字 ("_") を使用します。 必要に応じて任意の数の値を破棄できます。そのため、すべての値を 1 つの破 棄 _ で表すことができます。
    public static void Main()
{
    (string city, int population, double area) = QueryCityData("New York City");
    // Do something with the data.
}
 
 破棄を含むタプルの使用例を次に示します。   メソッドは、市区町村名、その地域、年、市区町村の その年の人口、2 つ目の年、市区町村のその 2 つ目の年の人口という 6 つのタプルを返します。 この例は、2 つの年の間に変 化した人口数を示しています。 タプルから使用できるデータのうち、市区町村の地域は使用しません。また、指定時に市区町 村名と 2 つの日付はわかっています。 そのため、タプルに格納されている 2 つの人口値のみが必要であり、残りの値は破棄対 象として処理できます。
    using System;
using System.Collections.Generic;
public class Example
{
    public static void Main()
    {
        var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);
        Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}");
    }
    private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int
year2)
    {
        int population1 = 0, population2 = 0;
        double area = 0;
        if (name == "New York City")
        {
            area = 468.48;
            if (year1 == 1960)
            {
                population1 = 7781984;
            }
            if (year2 == 2010)
            {
                population2 = 8175133;
            }
            return (name, area, year1, population1, year2, population2);
        }
        return ("", 0, 0, 0, 0, 0);
    }
}
// The example displays the following output:
//      Population change, 1960 to 2010: 393,149
 ユーザー定義型の分解
C# には、非タプル型を分解するためのサポートが組み込まれていません。 ただし、クラス、構造体、またはインターフェイスの作 成者であれば、1つまたは複数の Deconstruct メソッドを実装することで、型のインスタンスを分解することができます。このメ ソッドからはvoidが返され、分解される各値はメソッドシグネチャのoutパラメーターで示されます。たとえば、Person クラス の次の Deconstruct メソッドは、名、ミドルネーム、姓を返します。
この場合、 p という Person クラスのインスタンスは、次のような割り当てで分解できます。
次の例では、 Deconstruct メソッドをオーバーロードし、 Person オブジェクトの多様な組み合わせのプロパティを返します。 各 オーバーロードから以下が返されます。
     public void Deconstruct(out string fname, out string mname, out string lname)
    var (fName, mName, lName) = p;
    QueryCityDataForYears
 
 名と姓。 名、ミドルネーム、姓。 名、姓、市区町村名、州名。
    using System;
public class Person
{
    public string FirstName { get; set; }
    public string MiddleName { get; set; }
    public string LastName { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public Person(string fname, string mname, string lname,
                  string cityName, string stateName)
    {
        FirstName = fname;
        MiddleName = mname;
        LastName = lname;
        City = cityName;
        State = stateName;
}
    // Return the first and last name.
    public void Deconstruct(out string fname, out string lname)
    {
        fname = FirstName;
        lname = LastName;
    }
    public void Deconstruct(out string fname, out string mname, out string lname)
    {
        fname = FirstName;
        mname = MiddleName;
        lname = LastName;
}
    public void Deconstruct(out string fname, out string lname,
                            out string city, out string state)
    {
        fname = FirstName;
        lname = LastName;
        city = City;
        state = State;
} }
public class Example
{
    public static void Main()
    {
} }
var p = new Person("John", "Quincy", "Adams", "Boston", "MA");
// Deconstruct the person object.
var (fName, lName, city, state) = p;
Console.WriteLine($"Hello {fName} {lName} of {city}, {state}!");
// The example displays the following output:
//    Hello John Adams of Boston, MA!
  パラメーター数が同じ Deconstruct メソッドが複数あると、あいまいになります。異なる数のパラメーター、つまり"アリティ"を持 つ Deconstruct メソッドを定義するように注意する必要があります。オーバーロードの解決時に、パラメーター数が同じ
 
    メソッドを区別できません。 破棄によるユーザー定義型の分解
タプルの場合と同様に、破棄を使用して、 Deconstruct メソッドから返される項目のうち、選択した項目を無視できます。 各 破棄は "_" という変数で定義されます。また、1 つの破棄操作に複数の破棄を含めることができます。
Person オブジェクトを4つの文字列(名、姓、市区町村、州)に分解し、姓と州を破棄する例を次に示します。
拡張メソッドによるユーザー定義型の分解
クラス、構造体、またはインターフェイスを作成していない場合でも、目的の値を返す Deconstruct 拡張メソッドを1つまたは 複数実装することで、このようなオブジェクトを分解することができます。
System.Reflection.PropertyInfoクラスの Deconstruct 拡張メソッドを2つ定義する例を次に示します。1つ目の拡張メ ソッドは、型、静的かインスタンスか、読み取り専用かどうか、インデックスが作成されているかどうかなど、プロパティの特徴を示 す値のセットを返します。 2 つ目の拡張メソッドは、プロパティのアクセシビリティを示します。 get アクセサーと set アクセサーのア クセシビリティは異なる可能性があるため、ブール値は、プロパティの get アクセサーと set アクセサーが異なるかどうか、また異な る場合はアクセシビリティが同じかどうかを示します。 アクセサーが 1 つのみの場合、または get アクセサーと set アクセサーのアク セシビリティが同じ場合、access 変数は、全体としてそのアクセシビリティのプロパティを示します。それ以外の場合、getアク セサーとsetアクセサーのアクセシビリティは getAccess 変数と setAccess 変数で示されます。
      // Deconstruct the person object.
var (fName, _, city, _) = p;
Console.WriteLine($"Hello {fName} of {city}!");
// The example displays the following output:
//      Hello John of Boston!
       Deconstruct
     using System;
using System.Collections.Generic;
using System.Reflection;
public static class ReflectionExtensions
{
    public static void Deconstruct(this PropertyInfo p, out bool isStatic,
                                   out bool isReadOnly, out bool isIndexed,
                                   out Type propertyType)
    {
        var getter = p.GetMethod;
        // Is the property read-only?
        isReadOnly = ! p.CanWrite;
        // Is the property instance or static?
        isStatic = getter.IsStatic;
        // Is the property indexed?
        isIndexed = p.GetIndexParameters().Length > 0;
        // Get the property type.
        propertyType = p.PropertyType;
    }
    public static void Deconstruct(this PropertyInfo p, out bool hasGetAndSet,
                                   out bool sameAccess, out string access,
                                   out string getAccess, out string setAccess)
    {
        hasGetAndSet = sameAccess = false;
        string getAccessTemp = null;
        string setAccessTemp = null;

          MethodInfo getter = null;
        if (p.CanRead)
            getter = p.GetMethod;
        MethodInfo setter = null;
        if (p.CanWrite)
            setter = p.SetMethod;
        if (setter != null && getter != null)
            hasGetAndSet = true;
        if (getter != null)
        {
            if (getter.IsPublic)
                getAccessTemp = "public";
            else if (getter.IsPrivate)
                getAccessTemp = "private";
            else if (getter.IsAssembly)
                getAccessTemp = "internal";
            else if (getter.IsFamily)
                getAccessTemp = "protected";
            else if (getter.IsFamilyOrAssembly)
                getAccessTemp = "protected internal";
}
        if (setter != null)
        {
            if (setter.IsPublic)
                setAccessTemp = "public";
            else if (setter.IsPrivate)
                setAccessTemp = "private";
            else if (setter.IsAssembly)
                setAccessTemp = "internal";
            else if (setter.IsFamily)
                setAccessTemp = "protected";
            else if (setter.IsFamilyOrAssembly)
                setAccessTemp = "protected internal";
}
        // Are the accessibility of the getter and setter the same?
        if (setAccessTemp == getAccessTemp)
        {
            sameAccess = true;
            access = getAccessTemp;
            getAccess = setAccess = String.Empty;
} else {
} }
}
access = null;
getAccess = getAccessTemp;
setAccess = setAccessTemp;
public class Example
{
    public static void Main()
    {
        Type dateType = typeof(DateTime);
        PropertyInfo prop = dateType.GetProperty("Now");
        var (isStatic, isRO, isIndexed, propType) = prop;
        Console.WriteLine($"\nThe {dateType.FullName}.{prop.Name} property:");
Console.WriteLine($"
Console.WriteLine($"
Console.WriteLine($"
Console.WriteLine($"
PropertyType: {propType.Name}");
Type listType = typeof(List<>);
Static:
Read-only:
Indexed:
{isStatic}");
{isRO}");
{isIndexed}");
  
 Type listType = typeof(List<>);
 関連項目
破棄 タプル型
           prop = listType.GetProperty("Item",
                                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |
BindingFlags.Static);
        var (hasGetAndSet, sameAccess, accessibility, getAccessibility, setAccessibility) = prop;
        Console.Write($"\nAccessibility of the {listType.FullName}.{prop.Name} property: ");
        if (!hasGetAndSet | sameAccess)
        {
            Console.WriteLine(accessibility);
        }
//
//
//
//
//
//
//
The System.DateTime.Now property:
   PropertyType: DateTime
   Static:       True
   Read-only:    True
   Indexed:      False
Accessibility of the System.Collections.Generic.List`1.Item property: public
else {
} }
Console.WriteLine($"\n
Console.WriteLine($"
  The get accessor: {getAccessibility}");
The set accessor: {setAccessibility}");
}
// The example displays the following output:
 
         インターフェイスには、非抽象クラスまたは構造体で実装する必要がある、関連する機能のグループに対する定義が含まれま す。インターフェイスを使用すると、実装が必要な static メソッドを定義することができます。C#8.0以降では、インターフェ イスによってメンバーの既定の実装を定義できます。 インターフェイスでは、フィールド、自動実装プロパティ、プロパティに似たイ ベントなどのインスタンス データを宣言できません。
インターフェイスを使用すると、たとえば、クラス内の複数のソースからの動作を含めることができます。 C# ではクラスの複数の継 承がサポートされないため、この機能は重要です。 また、構造体の継承をシミュレートする場合はインターフェイスを使用する必 要があります。これは、実際に別の構造体またはクラスから継承することができないためです。
インターフェイスを定義するには、次の例に示すように、interface キーワードを使用します。
インターフェイスの名前を、有効なC#の識別子名にする必要があります。慣例により、インターフェイス名は大文字の I で 始めます。
IEquatable<T> インターフェイスを実装するすべてのクラスまたは構造体は、インターフェイスで指定されたシグネチャに一致す る Equals メソッドの定義を含む必要があります。 したがって、 IEquatable<T> を実装するクラスが Equals メソッドを含むと想 定したうえで、これを使用してクラスの 1 つのインスタンスが同じクラスの別のインスタンスと等しいかどうかを判定できます。
IEquatable<T> の定義は Equals の実装を提供しません。クラスまたは構造体には複数のインターフェイスを実装できます。 ただし、クラスは 1 つのクラスからのみ継承できます。
抽象クラスの詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。
インターフェイスには、instance メソッド、プロパティ、イベント、インデクサー、またはこれらの 4 種類のメンバーの任意の組み合 わせを含めることができます。 インターフェイスには、静的コンストラクター、フィールド、定数、または演算子を含めることができま す。 例へのリンクについては、「関連項目」を参照してください。 インターフェイスには、インスタンス フィールド、インスタンス コンス トラクター、またはファイナライザーを含めることができません。 インターフェイス メンバーは、既定ではパブリックであり、 public 、
protected 、 private 、 protected internal 、 private protected などのアクセシビリティ修飾子を明示的に 指定できます。 メンバーには既定の実装が必要です。
インターフェイスのメンバーを実装するには、実装するクラスの対応するメンバーがパブリックかつ非静的であり、インターフェイスの メンバーと同じ名前およびシグネチャを持つ必要があります。
クラスまたは構造体でインターフェイスを実装する場合、インターフェイスによって宣言され、既定の実装が提供されないすべて のメンバーについて、クラスまたは構造体で実装を提供する必要があります。 ただし、基本クラスでインターフェイスが実装される 場合、その基本クラスから派生するすべてのクラスはその実装を継承します。
IEquatable<T>インターフェイスを実装する例を次に示します。実装するクラスの Car は、Equalsメソッドの実装を提供する 必要があります。
     interface IEquatable<T>
{
    bool Equals(T obj);
}
           internal 、
 private
インターフェイス (C# プログラミング ガイド) 2021/03/15 • • Edit Online
 
         クラスのプロパティとインデクサーでは、インターフェイスに定義されているプロパティまたはインデクサーの追加のアクセサーを定義 できます。 たとえば、インターフェイスで get アクセサーを持つプロパティを宣言するとします。 このインターフェイスを実装するクラ スでは、get アクセサーとsetアクセサーの両方を持つ同じプロパティを宣言できます。ただし、プロパティまたはインデクサーで 明示的な実装を使用する場合は、これらのアクセサーが一致する必要があります。 明示的な実装の詳細については、「明示 的なインターフェイス実装」および「インターフェイスのプロパティ」を参照してください。
インターフェイスは、1 つ以上のインターフェイスから継承できます。 派生インターフェイスは、その基本インターフェイスからメン バーを継承します。 派生インターフェイスを実装するクラスでは、派生インターフェイスの基底インターフェイスのすべてのメンバー を含め、派生インターフェイスのすべてのメンバーを実装する必要があります。 そのクラスは、暗黙的に派生インターフェイスまた はその基底インターフェイスのいずれかに変換されます。 クラスは、継承する基底クラス、または他のインターフェイスが継承する インターフェイスを介して、インターフェイスを複数回含めることができます。 ただし、クラスでインターフェイスの実装を提供できる のは 1 回のみであり、それもクラスでクラスの定義の一部としてインターフェイスを宣言する場合 (
class ClassName : InterfaceName ) に限られます。 インターフェイスを実装する基本クラスを継承することによってインターフェ イスを継承する場合、基本クラスは、そのインターフェイスのメンバーの実装を提供します。 ただし、派生クラスでは、継承された 実装を使用する代わりに、任意の仮想インターフェイスのメンバーを再実装できます。 インターフェイスでメソッドの既定の実装 を宣言すると、そのインターフェイスを実装したクラスにはその実装が継承されます。 インターフェイスで定義された実装は仮想で あり、実装クラスを使ってその実装をオーバーライドできます。
また、基本クラスでは、仮想メンバーを使用して、インターフェイスのメンバーを実装することもできます。 その場合、派生クラスで は、仮想メンバーをオーバーライドすることでインターフェイスの動作を変更できます。 仮想メンバーの詳細については、「ポリモー フィズム」を参照してください。
インターフェイスの概要 インターフェイスは、次の特性を持ちます。
通常、インターフェイスは抽象メンバーのみを含む抽象基底クラスに似ています。 インターフェイスを実装するすべてのクラス または構造体では、そのすべてのメンバーを実装する必要があります。 必要に応じて、そのメンバーの一部またはすべての 既定の実装をインターフェイスで定義できます。 詳細については、既定のインターフェイス メソッドに関する記事をご覧くださ い。
インターフェイスを直接インスタンス化することはできません。 そのメンバーは、インターフェイスを実装する任意のクラスまたは 構造体によって実装されます。
クラスまたは構造体は、複数のインターフェイスを実装できます。 クラスは、基本クラスを継承する一方で、1 つまたは複数 のインターフェイスを実装できます。
関連セクション
インターフェイスのプロパティ インターフェイスのインデクサー インターフェイス イベントを実装する方法 クラスと構造体
    public class Car : IEquatable<Car>
{
    public string Make {get; set;}
    public string Model { get; set; }
    public string Year { get; set; }
    // Implementation of IEquatable<T> interface
    public bool Equals(Car car)
    {
} }
return (this.Make, this.Model, this.Year) ==
    (car.Make, car.Model, car.Year);
 
        継承
インターフェイス
メソッド
ポリモーフィズム
抽象クラスとシール クラス、およびクラス メンバー プロパティ
イベント
インデクサー
関連項目
C# プログラミング ガイド 継承
識別子名

    メソッドは、一連のステートメントが含まれているコード ブロックです。 必要なメソッド引数を指定してプログラムからメソッドを呼び 出すと、メソッド内のステートメントが実行されます。 C# では、実行されるすべての命令がメソッドのコンテキストで実行されま す。 Main メソッドは、すべてのC#アプリケーションのエントリポイントです。プログラムが開始されると、このメソッドが共通言語 ランタイム (CLR) によって呼び出されます。
メソッド シグネチャ
メソッドは次の項目を指定することで class または struct で宣言されます。
や など、任意のアクセス レベル。 既定値は、 private です。 や など、任意の修飾子。
メソッドに何も与えられていない場合、戻り値または void 。 メソッド名。
メソッド パラメーター。 メソッド パラメーターはかっこで囲み、各パラメーターをコンマで区切ります。 かっこ内を空にすると、メ ソッドでパラメーターが不要なことを意味します。
これらのまとまりがメソッド シグネチャとなります。
次の例では、5つのメソッドを含む Motorcycle という名前のクラスを定義します。
    NOTE
このトピックでは、名前付きメソッドについて説明します。 匿名関数については、「匿名関数」を参照してください。
     public
private
  abstract
sealed
    IMPORTANT
メソッドのオーバーロードを可能にするために、メソッドの戻り値の型はメソッドのシグネチャには含まれません。 ただし、デリゲートとそれが指す メソッドの互換性を決定する場合には、メソッドのシグネチャの一部となります。
      using System;
abstract class Motorcycle
{
   // Anyone can call this.
   public void StartEngine() {/* Method statements here */ }
   // Only derived classes can call this.
   protected void AddGas(int gallons) { /* Method statements here */ }
   // Derived classes can override the base class implementation.
   public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }
   // Derived classes can override the base class implementation.
   public virtual int Drive(TimeSpan time, int speed) { /* Method statements here */ return 0; }
   // Derived classes must implement this.
   public abstract double GetTopSpeed();
}
 (C#) のメソッド 2021/03/06 • • Edit Online
 
  クラスにオーバーロードされたクラス Drive が含まれていることに注意してください。2つのメソッドの名前が同じで あり、パラメーターの種類で識別する必要があります。
メソッドの呼び出し
メソッドは インスタンス または 静的 になります。 インスタンス メソッドを呼び出すには、オブジェクトをインスタンス化し、そのオブ ジェクトでメソッドを呼び出す必要があります。インスタンス メソッドはこのインスタンスとそのデータを操作します。 メソッドが属する 型の名前を参照して静的メソッドを呼び出します。静的メソッドではインスタンス データは操作できません。 オブジェクト インスタ ンス経由で静的メソッドを呼び出そうとすると、コンパイラ エラーが発生します。
メソッドを呼び出すことは、フィールドにアクセスするのと似ています。 オブジェクトの名前 (インスタンス メソッドを呼び出す場合) または型の名前(static メソッドを呼び出す場合)の後ろに、期間、メソッドの名前、かっこを追加します。引数はかっこの中 に記述し、コンマで区切ります。
メソッド定義には、必要なパラメーターの名前と型を指定します。 呼び出し元からメソッドを呼び出すとき、各パラメーターに引 数と呼ばれる具体的な値を指定します。 引数にはパラメーター型との互換性が必要ですが、呼び出し元のコードで引数名を 使用する場合、引数名がメソッドで定義されるパラメーター名と同じである必要はありません。 次の例では、 Square メソッドに 型が int でiという名前のパラメーターが1つ含まれています。最初のメソッド呼び出しでは、型が int でnumという名前 の変数が Square メソッドに渡されます。2つ目のメソッド呼び出しでは数値定数が、3つ目のメソッド呼び出しでは式が渡さ れます。
       public class Example
{
   public static void Main()
   {
      // Call with an int variable.
      int num = 4;
      int productA = Square(num);
      // Call with an integer literal.
      int productB = Square(12);
      // Call with an expression that evaluates to int.
      int productC = Square(productA * 3);
   }
   static int Square(int i)
   {
      // Store input argument in a local variable.
      int input = i;
      return input * input;
} }
 メソッド呼び出しの最も一般的な形式では、位置引数が使用されます。これはメソッド パラメーターと同じ順序で引数を指定 するものです。 そのため、 Motorcycle クラスのメソッドは次の例のように呼び出されます。 たとえば、 Drive メソッドの呼び出 しには 2 つの引数が含まれます。この 2 つの引数は、メソッドの構文の 2 つのパラメーターに対応しています。 1 つ目は
miles パラメーターの値になります。2つ目は speed パラメーターの値になります。
  Motorcycle
 
  メソッドを呼び出すとき、位置引数の代わりに 名前付き引数 を使用することもできます。 名前付き引数を使用するとき、パラ メーター名に続けてコロン (":") と引数を指定します。 必要なすべての引数が存在する限り、メソッドの引数の順序は問われま せん。次の例では、名前付き引数を使用して TestMotorcycle.Drive メソッドを呼び出しています。この例では、メソッドのパ ラメーター リストとは反対の順序で名前付き引数が渡されています。
     using System;
class TestMotorcycle : Motorcycle
{
   public override int Drive(int miles, int speed)
   {
      return (int) Math.Round( ((double)miles) / speed, 0);
   }
   public override double GetTopSpeed()
   {
      return 108.4;
   }
   static void Main()
   {
      TestMotorcycle moto = new TestMotorcycle();
      moto.StartEngine();
      moto.AddGas(15);
      var travelTime = moto.Drive(speed: 60, miles: 170);
      Console.WriteLine("Travel time: approx. {0} hours", travelTime);
} }
// The example displays the following output:
//      Travel time: approx. 3 hours
 位置引数と名前付き引数の両方を利用してメソッドを呼び出すことができます。 ただし、位置引数は、名前付き引数が正し い位置にある場合にのみ、名前付き引数に従うことができます。次の例では、前の例にあった TestMotorcycle.Drive メソッ ドを呼び出していますが、位置引数が 1 つ、名前付き引数が 1 つ使用されています。
   var travelTime = moto.Drive(170, speed: 55);
 継承されたメソッドとオーバーライドされたメソッド
   class TestMotorcycle : Motorcycle
{
   public override double GetTopSpeed()
   {
      return 108.4;
   }
   static void Main()
   {
      TestMotorcycle moto = new TestMotorcycle();
      moto.StartEngine();
      moto.AddGas(15);
      moto.Drive(5, 20);
      double speed = moto.GetTopSpeed();
      Console.WriteLine("My top speed is {0}", speed);
} }
 
      型に明示的に定義されるメンバーに加え、型は、その基底クラスに定義されているメンバーを継承します。 マネージド型という 系統のすべての型は Object クラスから直接的または間接的に継承するため、すべての型 が、Equals(Object)、GetType()、ToString()など、そのメンバーを継承します。次の例では、Person クラスを定義し、2つの
Person オブジェクトをインスタンス化し、Person.Equals メソッドを呼び出して2つのオブジェクトが等しいかどうかを判断しま す。ただし、Equals メソッドは クラスに定義されていません。Objectから継承されたものです。
    Person
     using System;
public class Person
{
   public String FirstName;
}
public class Example
{
   public static void Main()
   {
      var p1 = new Person();
      p1.FirstName = "John";
      var p2 = new Person();
      p2.FirstName = "John";
      Console.WriteLine("p1 = p2: {0}", p1.Equals(p2));
} }
// The example displays the following output:
//      p1 = p2: False
  型は継承されたメンバーをオーバーライドできます。 override キーワードを使用し、オーバーライドされたメソッドを実装します。 メソッド シグネチャは、オーバーライドされたメソッドのものと同じにする必要があります。 次の例は前の例と似ています が、Equals(Object) メソッドをオーバーライドしている点が異なります。 (この 2 つのメソッドは一貫性のある結果を提供するた め、GetHashCode() メソッドもオーバーライドされます。)

  パラメーターを渡す
C# の型は、値型 と 参照型 のどちらかに区別されます。 組み込みの値型の一覧については、型に関するページを参照してく ださい。 既定では、値型と参照型の両方が値によりメソッドに渡されます。
パラメーターを値で渡す
値型が値でメソッドに渡されるとき、オブジェクト自体の代わりにオブジェクトのコピーがメソッドに渡されます。 そのため、呼び出さ れたメソッドでオブジェクトに加えた変更は、コントロールが呼び出し元に戻ったとき、元のオブジェクトで反映されません。
次の例では、値型を値でメソッドに渡します。呼び出されたメソッドが値型の値を変更しようとします。型 int (値型)の変数 を定義し、その値を20に初期化し、ModifyValue という名前のメソッドに値を渡します。このメソッドは変数の値を30に変 更します。 しかしながら、メソッドが戻ると、変数の値は元のままです。
    using System;
public class Person
{
   public String FirstName;
   public override bool Equals(object obj)
   {
      var p2 = obj as Person;
      if (p2 == null)
         return false;
      else
         return FirstName.Equals(p2.FirstName);
}
   public override int GetHashCode()
   {
      return FirstName.GetHashCode();
   }
}
public class Example
{
   public static void Main()
   {
      var p1 = new Person();
      p1.FirstName = "John";
      var p2 = new Person();
      p2.FirstName = "John";
      Console.WriteLine("p1 = p2: {0}", p1.Equals(p2));
} }
// The example displays the following output:
//      p1 = p2: True
 
  参照型のオブジェクトが値でメソッドに渡されると、オブジェクトへの参照が値で渡されます。 つまり、メソッドは、オブジェクト自体 ではなく、オブジェクトの場所を示す引数を受け取ります。 この参照を使用してオブジェクトのメンバーを変更した場合、コント ロールが呼び出し元のメソッドに戻ると、オブジェクトで変更が反映されています。 ただし、メソッドに渡されるオブジェクトを置換 しても、コントロールが呼び出し元に戻ったとき、元のオブジェクトで反映されません。
次の例では、SampleRefType という名前のクラス(参照型)を定義します。 SampleRefType オブジェクトをインスタンス化し、そ の value フィールドに 44 を割り当て、 ModifyObject メソッドにオブジェクトを渡します。 この例は、基本的に前の例と同様 に、引数を値でメソッドに渡しています。ただし、参照型を使用しているため、結果は異なります。 ModifyObject の
obj.value フィールドを変更したことで、 Main メソッドの引数 rt の value フィールドも 33 に変更されます。例の出力で 確認できます。
         using System;
public class SampleRefType
{
    public int value;
}
public class Example
{
    public static void Main()
    {
        var rt = new SampleRefType();
        rt.value = 44;
        ModifyObject(rt);
        Console.WriteLine(rt.value);
}
    static void ModifyObject(SampleRefType obj)
    {
        obj.value = 33;
    }
}
 パラメーターの参照渡し
メソッドの引数の値を変更し、コントロールが呼び出し元に戻ったときにその変更を反映させるには、参照でパラメーターを渡しま す。 パラメーターを参照で渡すには、 ref または out キーワードを使用します。 値を参照で渡すことで、コピーを回避するこ
   using System;
public class Example
{
   public static void Main()
   {
      int value = 20;
      Console.WriteLine("In Main, value = {0}", value);
      ModifyValue(value);
      Console.WriteLine("Back in Main, value = {0}", value);
}
   static void ModifyValue(int i)
   {
      i = 30;
      Console.WriteLine("In ModifyValue, parameter value = {0}", i);
      return;
} }
// The example displays the following output:
//      In Main, value = 20
//      In ModifyValue, parameter value = 30
//      Back in Main, value = 20
 
 ともできますが、 in キーワードを使用して変更を防ぐこともできます。
次の例は前の例とよく似ていますが、値が参照で ModifyValue メソッドに渡される点が異なります。パラメーターの値が
ModifyValue メソッドで変更されると、コントロールが呼び出し元に戻ったとき、地の変更が反映されます。
      using System;
public class Example
{
   public static void Main()
   {
      int value = 20;
      Console.WriteLine("In Main, value = {0}", value);
      ModifyValue(ref value);
      Console.WriteLine("Back in Main, value = {0}", value);
}
   static void ModifyValue(ref int i)
   {
      i = 30;
      Console.WriteLine("In ModifyValue, parameter value = {0}", i);
      return;
} }
// The example displays the following output:
//      In Main, value = 20
//      In ModifyValue, parameter value = 30
//      Back in Main, value = 30
 参照型パラメーターを利用する典型的なパターンが変数の値の入れ替えです。 参照でメソッドに 2 つの変数を渡すと、メソッド がその中身を入れ替えます。 次の例では、整数値が入れ替えられます。
    using System;
public class Example
{
   static void Main()
   {
      int i = 2, j = 3;
      System.Console.WriteLine("i = {0}  j = {1}" , i, j);
      Swap(ref i, ref j);
      System.Console.WriteLine("i = {0}  j = {1}" , i, j);
   }
   static void Swap(ref int x, ref int y)
   {
      int temp = x;
      x = y;
      y = temp;
} }
// The example displays the following output:
// i=2 j=3
// i=3 j=2
 参照型パラメーターを渡すことで、個々の要素またはフィールドの値ではなく、参照自体の値を変更できます。 パラメーター配列
メソッドに厳密な数の引数を指定する要件が限定的になることがあります。 params キーワードを利用し、パラメーターがパラ メーター配列であることを示すことで、可変数の引数でメソッドを呼び出すことができます。 params キーワードでタグが付けられ
  
 たパラメーターは配列型にする必要があり、メソッドのパラメーター リストの最後のパラメーターにする必要があります。 呼び出し元は、次の 4 つの方法のいずれかでメソッドを呼び出すことができます。
必要な数の要素を含む、適切な型の配列を渡す。 適切な型の引数をコンマで区切った一覧をメソッドに渡す。
null を渡す。 パラメーター配列に引数を指定しない。
次の例は、パラメーター配列からすべての母音を返す GetVowels という名前のメソッドを定義します。 Main メソッドには、メ ソッド呼び出しの4つの方法すべてが入っています。呼び出し元は、params 修飾子が含まれるパラメーターに引数を指定す る必要はありません。 その場合、パラメーターは空の配列になります。
      using System;
using System.Linq;
class Example
{
    static void Main()
    {
        string fromArray = GetVowels(new[] { "apple", "banana", "pear" });
        Console.WriteLine($"Vowels from array: '{fromArray}'");
        string fromMultipleArguments = GetVowels("apple", "banana", "pear");
        Console.WriteLine($"Vowels from multiple arguments: '{fromMultipleArguments}'");
        string fromNull = GetVowels(null);
        Console.WriteLine($"Vowels from null: '{fromNull}'");
        string fromNoValue = GetVowels();
        Console.WriteLine($"Vowels from no value: '{fromNoValue}'");
    }
    static string GetVowels(params string[] input)
    {
} }
if (input == null || input.Length == 0)
{
    return string.Empty;
}
var vowels = new char[] { 'A', 'E', 'I', 'O', 'U' };
return string.Concat(
    input.SelectMany(
        word => word.Where(letter => vowels.Contains(char.ToUpper(letter)))));
// The example displays the following output:
//     Vowels from array: 'aeaaaea'
//     Vowels from multiple arguments: 'aeaaaea'
//     Vowels from null: ''
//     Vowels from no value: ''
 省略可能なパラメーターと引数
メソッド定義では、そのパラメーターが必須であるか、任意であるかを指定できます。 既定では、パラメーターは必須です。 省略 可能なパラメーターを指定するには、メソッド定義にパラメーターの既定値を追加します。 メソッドが呼び出されるとき、省略可 能なパラメーターに引数が指定されていなければ、既定値が代わりに使用されます。
パラメーターの既定値は、次の種類の式のいずれかで割り当てる必要があります。

 リテラル文字列や数値など、定数。
ValType が値型となる、 new ValType() 形式の式。 値型の暗黙のパラメーターなしのコンストラクターが呼び出されること
に注意してください。それは型の実際のメンバーではありません。 ValType が値型となる、 default(ValType) 形式の式。
メソッドに必須のパラメーターと省略可能なパラメーターの両方が含まれる場合、省略可能なパラメーターはパラメーター リストの 終わりに定義されます (すべての必須パラメーターの後に)。
次の例では、ExampleMethod メソッドを定義しています。必須のパラメーターが1つ、省略可能なパラメーターが2つありま す。
         using System;
public class Options
{
   public void ExampleMethod(int required, int optionalInt = default(int),
                             string description = "Optional Description")
   {
      Console.WriteLine("{0}: {1} + {2} = {3}", description, required,
} }
optionalInt, required + optionalInt);
 省略可能なパラメーターを複数持つメソッドが位置引数で呼び出された場合、呼び出し元は、引数が指定される最初のパラ メーターから最後のパラメーターまで、すべての省略可能なパラメーターに引数を指定する必要があります。 たとえば、
   ExampleMethod メソッドの場合、呼び出し元が ターの引数も指定する必要があります。
す。
パラメーターの引数を指定した場合、 optionalInt パラメー は有効なメソッド呼び出しで
description
 opt.ExampleMethod(2, 2, "Addition of 2 and 2");
 は、"引数がありません" というコンパイラ エラーを発生させます。 メソッドが名前付き引数または位置引数と名前付き引数の組み合わせで呼び出される場合、呼び出し元は、メソッド呼び出
opt.ExampleMethod(2, , "Addition of 2 and 0");
しの最後の位置引数の後に続く引数を省略できます。
次の例では、ExampleMethod メソッドが3回呼び出されます。最初の2つのメソッド呼び出しでは、位置引数が使用されま す。 最初の呼び出しではいずれの省略可能なパラメーターも省略され、2 つ目の呼び出しでは最後の引数が省略されます。 3つ目のメソッドは必須パラメーターの位置引数を指定しますが、名前付き引数を利用して description パラメーターに値を 指定します。 optionalInt パラメーターは省略します。
       public class Example
{
   public static void Main()
   {
      var opt = new Options();
      opt.ExampleMethod(10);
      opt.ExampleMethod(10, 2);
      opt.ExampleMethod(12, description: "Addition with zero:");
} }
// The example displays the following output:
//      Optional Description: 10 + 0 = 10
//      Optional Description: 10 + 2 = 12
//      Addition with zero:: 12 + 0 = 12
 省略可能なパラメーターの使用は、オーバーロードの解決 に影響を与えます。次のように、特定のオーバーロードをメソッド呼び 出しで呼び出すかどうかを C# コンパイラが決定する方法に影響を与えます。
メソッド、インデクサー、コンストラクターのパラメーターのそれぞれが任意であるか、名前か位置により、呼び出しステートメント の 1 つの引数に対応するとき、その引数がパラメーターの型に変換できる場合、メソッド、インデクサー、コンストラクターが実 行の候補になります。

 複数の候補が見つかった場合、明示的に指定される引数には、優先変換に関するオーバーロード解決の規則が適用され ます。 任意のパラメーターの省略された引数は無視されます。
2 つの候補が等しく良好であると判断された場合、呼び出しで引数が省略された任意のパラメーターのない候補が優先さ れます。 これはパラメーターの少ない候補に関するオーバーロード解決の一般優先設定の結果です。
戻り値
メソッドは、呼び出し元に値を返すことができます。 戻り値の型 (メソッド名の前に記述されている型) が void でない場合、メ ソッドは、 return キーワードを使用して値を返すことができます。 return キーワードに続いて変数、定数、または戻り値の 型に一致する値が記述されたステートメントは、その値をメソッドの呼び出し元に返します。 戻り値の型が void 以外のメソッド で値を返すには、 return キーワードを使用する必要があります。また、 return キーワードは、メソッドの実行を中止しま す。
戻り値の型が void の場合、値を持たない return ステートメントは、メソッドの実行を中止するときに役立ちます。 return キーワードを使用しない場合、メソッドは、コード ブロックの最後に到達したときに実行を中止します。
たとえば、次の2つのメソッドは、 return キーワードを使用して整数を返します。
           class SimpleMath
{
    public int AddTwoNumbers(int number1, int number2)
    {
        return number1 + number2;
    }
    public int SquareANumber(int number)
    {
        return number * number;
    }
}
 メソッドから返された値を使用する場合、呼び出し元のメソッド内で同じ型の値を使用している場所では、メソッド呼び出し自 体を値として使用できます。 戻り値は、変数に代入することもできます。 たとえば、次の 2 つのコードでは、同様の結果が得ら れます。
    int result = obj.AddTwoNumbers(1, 2);
result = obj.SquareANumber(result);
// The result is 9.
Console.WriteLine(result);
     result = obj.SquareANumber(obj.AddTwoNumbers(1, 2));
// The result is 9.
Console.WriteLine(result);
  この場合、ローカル変数 result を使用して値を格納する手順はオプションです。 このローカル変数によってコードの読みやす さが向上することがあります。また、引数の元の値をメソッドのスコープ全体で保持する場合に必要になることがあります。
メソッドで複数の値を返すと便利な場合があります。 C# 7.0 以降では、タプル型 と タプル リテラル を使用してこれを簡単に実 行できます。 タプル型は、タプルの要素のデータ型を決定します。 タプル リテラルは、返されたタプルの実際の値を提供します。 次の例では、 は、 メソッドにより返されるタプル型を定義します。 式
  (string, string, string, int)
GetPersonalInfo
  (per.FirstName, per.MiddleName, per.LastName, per.Age)
トの名、ミドルネーム、姓、年齢を返します。
はタプル リテラルです。このメソッドは、 PersonInfo オブジェク

  呼び出し元はそれから、次のようなコードで返されたタプルを利用します。
名前は、タプル型の定義のタプル要素に割り当てることもできます。次の例は、名前付き要素を使用する GetPersonalInfo メソッドの別バージョンです。
この例の GetPersonInfo メソッドの呼び出しは次のように変更できます。
メソッドに引数として配列が渡されるとき、そのメソッドが個々の要素の値を変更する場合、メソッドが配列を返す必要はありま せん。ただし、見やすいから、値の流れが機能的になるからといった理由で配列を返してもかまいません。 配列を返す必要がな いのは、C# ではすべての参照型が値で渡され、配列参照の値がその配列のポインターになるためです。 次の例では、
DoubleValues メソッドで行われた values 配列の内容の変更を、配列の参照があるあらゆるコードで観察できます。
    var person = GetPersonalInfo("111111111")
Console.WriteLine($"{person.Item1} {person.Item3}: age = {person.Item4}");
      public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
      var person = GetPersonalInfo("111111111");
Console.WriteLine($"{person.FName} {person.LName}: age = {person.Age}");
       using System;
public class Example
{
   static void Main(string[] args)
   {
      int[] values = { 2, 4, 6, 8 };
      DoubleValues(values);
      foreach (var value in values)
         Console.Write("{0}  ", value);
}
   public static void DoubleValues(int[] arr)
   {
      for (int ctr = 0; ctr <= arr.GetUpperBound(0); ctr++)
         arr[ctr] = arr[ctr] * 2;
} }
// The example displays the following output:
//       4  8  12  16
 拡張メソッド 通常、既存の型にメソッドを追加する方法が 2 つあります。
その型のソース コードを変更する。 もちろん、型のソース コードを所有していない場合、これはできません。 また、メソッドを
   public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
 
     サポートするプライベース データ フィールドも追加した場合、これは互換性に影響する変更になります。 派生クラスで新しいメソッドを定義する。 構造体や列挙型など、その他の型の継承を利用し、メソッドをこの方法で追加す ることはできません。 シール クラスにメソッドを "追加する" こともできません。
拡張メソッドでは、型自体を変更せずに、あるいは継承された型に新しいメソッドを実装せずに、既存の型にメソッドを "追加" できます。 また、拡張メソッドは、それが拡張する型と同じアセンブリに置く必要がありません。 型の定義済みメンバーのように 拡張メソッドを呼び出します。
詳細については、「拡張メソッド」を参照してください。 非同期メソッド
非同期機能を使用することによって、明示的なコールバックを使用せずに、または複数のメソッドやラムダ式にわたって手動で コードを分割することなく、非同期メソッドを呼び出すことができます。
メソッドにasync修飾子を付けると、そのメソッドでawait演算子を使用できます。コントロールが非同期メソッドの await 式 に到達すると、待機中のタスクが完了していない場合、コントロールが呼び出し元に戻ります。 await キーワードが与えられた メソッドの進行は、待機中のタスクが完了するまで中断されます。 タスクが完了すると、メソッドで実行を再開できます。
非同期メソッドの戻り値の型としては、Task<TResult>、Task、 void を指定できます。 戻り値の型 void は主として、戻り 値の型 void が必要なイベントハンドラーの定義に使用されます。 void を返す非同期メソッドは待機できません。voidを 返すメソッドの呼び出し元は、このメソッドがスローする例外をキャッチできません。 C# 7.0 以降、非同期メソッドはタスクと同様 の戻り値の型を持つことができます。
次の例では、DelayAsync は、整数を返すreturnステートメントのある非同期メソッドです。非同期メソッドであるため、その メソッド宣言で戻り値の型 を指定する必要があります。 戻り値の型が Task<int> であるため、次のステートメント
に示すように、 DoSomethingAsync 内の await 式を評価すると整数が生成されます。
    NOTE
非同期メソッドは、まだ完了していない待機中の最初のオブジェクトに達するか、または非同期メソッドの最後に達すると、呼び出し元に戻 ります。
    Task<int>
  int result = await delayTask

         非同期メソッドで in、ref、out パラメーターを宣言することはできませんが、これらのパラメーターを持つメソッドを呼び出すことは できます。
非同期メソッドの詳細については、「async および await を使用した非同期プログラミング」と非同期の戻り値の型に関する ページを参照してください。
式形式のメンバー
メソッドの定義としては、式の結果を即座に返すか、またはメソッドの本文として 1 つのステートメントを含むものが一般的です。
=> を使用してこのようなメソッドを定義するための構文ショートカットがあります。
メソッドが void を返すか、非同期メソッドである場合は、メソッドの本文を(ラムダの場合と同様に)ステートメント式にする必 要があります。 プロパティとインデクサーは読み取り専用にする必要があるため、 get アクセサー キーワードは使用しないでくださ い。
Iterators
反復子は、リストや配列など、コレクションに対するカスタム イテレーションを実行します。 反復子は、 yield return ステートメン トを使用して、各要素を 1 回に1 つ返します。 yield return ステートメントに到達すると、現在の場所が記録されます。呼 び出し元は、シーケンス内の次の要素を要求できます。
反復子の戻り値の型には、IEnumerable、IEnumerable<T>、IEnumerator、または IEnumerator<T> を指定できます。 詳細については、「 反復子」を参照してください。
    public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
     using System;
using System.Threading.Tasks;
class Program
{
    static Task Main() => DoSomethingAsync();
    static async Task DoSomethingAsync()
    {
        Task<int> delayTask = DelayAsync();
        int result = await delayTask;
        // The previous two statements may be combined into
        // the following statement.
        //int result = await DelayAsync();
        Console.WriteLine($"Result: {result}");
    }
    static async Task<int> DelayAsync()
    {
        await Task.Delay(100);
return 5; }
}
// Example output:
//   Result: 5
 
      関連項目
アクセス修飾子
静的クラスと静的クラス メンバー
継承
抽象クラスとシール クラス、およびクラス メンバー params
out
ref
in
パラメーターの引き渡し

   C# のプロパティは、非常に優れた機能です。 開発者は C# で定義されている構文を使用して、設計の意図を正確に表す コードを記述できます。
プロパティは、アクセスされたときにはフィールドのように振る舞います。 ただし、フィールドとは異なり、プロパティの実装ではアクセ サーを使用します。プロパティがアクセスされたときや値を割り当てられたときに実行されるステートメントをアクセサーで定義しま す。
プロパティの構文
プロパティの構文は、フィールドを自然に拡張したものです。 フィールドで格納場所を定義します。
プロパティの定義には、プロパティの値を取得する get アクセサーとプロパティに値を割り当てる set アクセサーの宣言が含ま れます。
上記の構文は "自動プロパティ" の構文です。 コンパイラによって、プロパティをバックアップするフィールドの格納場所が生成され ます。 また、 get アクセサーと set アクセサーの本体もコンパイラによって実装されます。
場合によっては、その型の既定以外の値にプロパティを初期化する必要があります。 C# では、プロパティの右中かっこの後で値 を設定することにより可能です。 FirstName プロパティの初期値は null より空の文字列の方がよい場合があります。その 場合は次に示すように指定します。
この記事で後述するように、特定の初期化は読み取り専用プロパティに最も役に立ちます。 格納場所は、下に示すように、開発者が定義することもできます。
    public class Person
{
    public string FirstName;
    // remaining implementation removed from listing
}
     public class Person
{
    public string FirstName { get; set; }
    // remaining implementation removed from listing
}
      public class Person
{
    public string FirstName { get; set; } = string.Empty;
    // remaining implementation removed from listing
}
 プロパティ
2021/03/06 • • Edit Online
 
  プロパティの実装が 1 つの式の場合は、式形式のメンバー を get アクセス操作子または set アクセス操作子に使用できます。
    public class Person
{
    public string FirstName
    {
        get => firstName;
        set => firstName = value;
    }
    private string firstName;
    // remaining implementation removed from listing
}
 この記事では、該当する箇所ではこの簡単な構文を使います。
上に示したプロパティの定義は、読み取り/書き込みプロパティです。setアクセサーの value に注目してください。 set アクセ サーには常に、value という名前のパラメーターが1つあります。 get アクセサーは、プロパティの型に変換可能な値を返す 必要があります (この例では string )。
これが構文の基本です。 さまざまな設計手法をサポートするバリエーションが多数あります。 これらを詳しく確認しながら、各種 シナリオに応じた構文の選択肢を見てみましょう。
シナリオ ここまでに示した例は、検証が行われない読み取り/書き込みプロパティという、プロパティ定義の中でも単純なものでした。 目
的のコードを get アクセサーと set アクセサーで記述することで、さまざまなシナリオに対応できます。 検証
set アクセサーにコードを記述すると、プロパティが表す値を常に有効な値にすることができます。 たとえば、 Person クラスに 設定されているルールの 1 つに、名前は無指定または空白文字にできないというものがあるとします。 これは次のように記述で きます。
      public class Person
{
    public string FirstName
    {
        get => firstName;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("First name must not be blank");
            firstName = value;
        }
    }
    private string firstName;
    // remaining implementation removed from listing
}
    public class Person
{
    public string FirstName
    {
        get { return firstName; }
        set { firstName = value; }
    }
    private string firstName;
    // remaining implementation removed from listing
}
 
 上記の例は、プロパティセッターの検証の一部として throw 式を使用して簡略化できます。
    public class Person
{
    public string FirstName
    {
        get => firstName;
        set => firstName = (!string.IsNullOrWhiteSpace(value)) ? value : throw new ArgumentException("First
name must not be blank");
    }
    private string firstName;
    // remaining implementation removed from listing
}
 上記の例では、名前を無指定または空白文字にしてはいけないというルールが強制的に適用されます。 もし開発者が下のよ うに指定すると、
この割り当てに対して ArgumentException がスローされます。プロパティのsetアクセサーの戻り値はvoidでなければならな いため、例外をスローすることで set アクセサーにエラーを報告します。
この構文を拡張して、シナリオに必要なあらゆる要素に対応できます。 たとえば、各種プロパティ間の関係をチェックしたり、外 部条件に対して検証したりできます。 C# で有効なステートメントは、すべてプロパティ アクセサーでも有効です。
読み取り専用
ここまでのプロパティ定義はすべて、パブリック アクセサーを持つ読み取り/書き込みプロパティでした。 これ以外にも、プロパティに 有効なアクセシビリティがあります。 たとえば、読み取り専用プロパティを作成したり、set アクセサーと get アクセサーに異なるア クセシビリティを設定したりすることができます。 具体例として、 Person クラスで、クラス内の他のメソッドからのみ FirstName プ ロパティの値を変更できるようにしたい場合は、setアクセサーのアクセシビリティを public ではなく private に設定します。
これで、 FirstName プロパティにはどのコードからもアクセスできる一方で、値の割り当ては Person クラス内の他のコードからし かできなくなります。
制限を設定するアクセス修飾子を set アクセサーと get アクセサーのどちらか 1 つに追加することもできます。 個々のアクセサー には、プロパティ定義のアクセス修飾子よりも制限が強いアクセス修飾子を設定する必要があります。 上記は、 プ
  hero.FirstName = "";
          public class Person
{
    public string FirstName { get; private set; }
    // remaining implementation removed from listing
}
    FirstName
    ロパティが public ですがsetアクセサーが private であるため、有効です。 なアクセサーを持つ パティを宣言することはできません。 プロパティの宣言では、 protected 、 、 言することもできます。
、
なプロ を宣
public
private
    internal
protected internal
private
 get アクセサーに制限の高い修飾子を設定することも有効です。 たとえば、 public なプロパティで、 get アクセサーを private に制限できます。ただし、このようなシナリオは実際にはほとんどありません。
また、コンストラクターやプロパティの初期化子でのみ設定できるように、プロパティに対する変更を制限することもできます。 Person クラスを次のように変更することができます。
  
   この機能は、読み取り専用プロパティとして公開されるコレクションを初期化する場合に最もよく使われます。
計算されたプロパティ
プロパティが返す値は、メンバー フィールドの値でなくてもかまいません。 計算された値を返すプロパティを作成できます。 姓と名
を連結する計算をしてフルネームを返すように Person オブジェクトを拡張してみましょう。
    public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
      public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string FullName { get { return $"{FirstName} {LastName}"; } }
}
 上の例では、"文字列補間" 機能を使用して、フルネームを表す書式設定された文字列を作成しています。 式形式のメンバーを使用することもできます。式形式のメンバーを使用すると、計算された FullName プロパティを簡潔な方
法で作成できます。
     public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string FullName => $"{FirstName} {LastName}";
}
 式形式のメンバー では、式が 1 つだけ含まれたメソッドを定義する ラムダ式 構文を使用します。 ここでは、その式が Person オブジェクトのフルネームを返しています。
キャッシュ済みの評価されたプロパティ
計算されたプロパティの概念をストレージと組み合わせて、キャッシュ済みの評価されたプロパティ を作成できます。 たとえば、 FullName プロパティを更新して、プロパティが最初にアクセスされたときに文字列が書式設定されるようにすることができます。
    public class Person
{
    public Person(string firstName) => this.FirstName = firstName;
    public string FirstName { get; }
    // remaining implementation removed from listing
}
 
    ただし、上記のコードにはバグが含まれています。コードによって FirstName プロパティと LastName プロパティのいずれかの値 が更新されると、以前に評価された fullName フィールドは無効になります。 フィールドが再計算されるように、
FirstName プロパティと プロパティの set アクセサーを変更します。
   LastName
fullName
     public class Person
{
    private string firstName;
    public string FirstName
    {
        get => firstName;
        set
        {
            firstName = value;
            fullName = null;
        }
}
    private string lastName;
    public string LastName
    {
        get => lastName;
        set
        {
            lastName = value;
            fullName = null;
        }
}
    private string fullName;
    public string FullName
    {
get {
            return fullName;
        }
} }
if (fullName == null)
    fullName = $"{FirstName} {LastName}";
  上の最終版では、必要になった場合にのみ FullName プロパティが評価されます。以前に計算されたものが有効であれば、 それが使用されます。 状態が変化したことで、以前に計算されたバージョンが無効になると、再計算が行われます。 このクラス を使用するにあたって、開発者は実装の詳細を知っている必要はありません。 内部で変化があっても Person オブジェクトの使 用には影響しません。 これが、プロパティを使用してオブジェクトのデータ メンバーを公開するする重要な利点です。
   public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    private string fullName;
    public string FullName
    {
get {
            return fullName;
        }
} }
if (fullName == null)
    fullName = $"{FirstName} {LastName}";
 
       自動実装プロパティに属性をアタッチする
C# 7.3 以降、自動実装プロパティのコンパイラの生成したバッキング フィールドにフィールド属性をアタッチできるようになりまし た。たとえば、一意の整数 Id プロパティを追加する Person クラスのリビジョンについて考えてみましょう。自動実装プロパ ティを使用して Id プロパティを記述しますが、この設計では Id プロパティの永続化を呼び出しません。 NonSerializedAttribute は、プロパティではなく、フィールドにのみアタッチすることができます。 次の例のように、属性に対して
field: 指定子を使用して Id プロパティのバッキングフィールドにNonSerializedAttributeをアタッチできます。
      public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    [field:NonSerialized]
    public int Id { get; set; }
    public string FullName => $"{FirstName} {LastName}";
}
 この手法は、自動実装プロパティのバッキング フィールドにアタッチする任意の属性に利用できます。
INotifyPropertyChanged を実装する
プロパティ アクセサーでコードを記述する必要があるシナリオとして、値が変更されたことをデータ バインディング クライアントに通 知するための INotifyPropertyChanged インターフェイスのサポートというものもあります。 プロパティの値が変更されると、オブ ジェクトはその変更を示す INotifyPropertyChanged.PropertyChanged イベントを発生させます。 データ バインディング ライ ブラリは、その変更に基づいて表示要素を更新します。下のコードは、このPersonクラスの FirstName プロパティに
INotifyPropertyChanged を実装する方法を示しています。
      public class Person : INotifyPropertyChanged
{
    public string FirstName
    {
        get => firstName;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("First name must not be blank");
            if (value != firstName)
            {
                PropertyChanged?.Invoke(this,
                    new PropertyChangedEventArgs(nameof(FirstName)));
}
            firstName = value;
        }
    }
    private string firstName;
    public event PropertyChangedEventHandler PropertyChanged;
    // remaining implementation removed from listing
}
 ?. は"null条件演算子"と呼ばれる演算子です。演算子の右側を評価する前に、null参照がないかをチェックします。 チェックの結果、 PropertyChanged イベントに対するサブスクライバーがない場合は、イベントを発生させるコードは実行されま せん。 その場合、評価は行われず がスローされます。 詳細については、「 events 」を参照してくだ さい。 上記の例では、新たに という演算子を使用して、記号としてのプロパティ名を文字列に変換しています。
nameof を使用すると、プロパティ名にタイプミスが含まれるというエラーを減らすことができます。
INotifyPropertyChanged の実装も、アクセサーでコードを記述することで目的のシナリオをサポートできるケースの一例です。
   NullReferenceException
 nameof
 
 要約
プロパティは、クラスまたはオブジェクトに含まれた一種のスマート フィールドです。 オブジェクトの外部からは、オブジェクト内にあ るフィールドのように見えます。 一方、プロパティは、C# の機能をどれでも自由に使用して実装できます。 検証、各種アクセシ ビリティ、遅延評価など、目的のシナリオで必要となる要素はすべて提供できます。

      "インデクサー" はプロパティに似ています。 さまざまな面で、インデクサーはプロパティと同じ言語機能を基にして構築されていま す。 インデクサーにより、"インデックス付き" プロパティを使用できるようになります。これは、1 つ以上の引数を使用して参照さ れるプロパティです。 これらの引数は、値のいくつかのコレクションにインデックスを提供します。
インデクサーの構文
インデクサーにアクセスするには、変数名と角かっこを使用します。 インデクサーの引数は、角かっこで囲みます。
インデクサーを宣言するには、 this キーワードをプロパティ名として使用し、引数を各かっこの中で宣言します。 この宣言は、 前の段落で説明した使用方法と一致します。
この最初の例から、プロパティの構文とインデクサーの構文の関係がわかります。 この類似点は、インデクサーの構文規則のほと んどで見られます。 インデクサーは、有効なアクセス修飾子 (public、protected internal、protected、internal、private、 private protected) を持つことができます。 sealed、virtual、または abstract を指定することもできます。 プロパティと同様に、 インデクサーの get アクセサーと set アクセサーには異なるアクセス修飾子を指定できます。 また、読み取り専用インデクサー (set アクセサーを省略) または書き込み専用インデクサー (get アクセサーを省略) を指定することもできます。
プロパティの操作方法から習得したほとんどすべてのことをインデクサーにも適用できます。 その唯一の例外は、"自動実装プロ パティ" です。 コンパイラは、必ずしもインデクサーに適切なストレージを生成できるとは限りません。
項目のセット内の項目を参照するための引数が存在することも、インデクサーとプロパティの違いです。 インデクサーごとの引数リ ストが一意である場合は、1 つの型に複数のインデクサーを定義できます。 それでは、クラス定義で 1 つ以上のインデクサーを 使用するさまざまなシナリオを見ていきましょう。
シナリオ
型の API がコレクションをモデル化していて、そのコレクションへの引数が定義されている場合に、型に "インデクサー" を定義しま す。 インデクサーは、.NET Core Framework に含まれているコレクション型に直接マップされることもあれば、されないこともあり ます。 型は、コレクションのモデル化だけでなく、他の役割がある場合もあります。 インデクサーを使用すると、型の抽象化に適 した API を提供することができ、抽象化された値の格納や計算の方法の内部の詳細を公開しなくて済みます。
"インデクサー" を使用する一般的なシナリオをいくつか見ていきましょう。 インデクサーのサンプル フォルダーにアクセスできます。 ダウンロード方法については、「サンプルおよびチュートリアル」を参照してください。
配列とベクター
インデクサーを作成する最も一般的なシナリオの 1 つは、型が配列またはベクターをモデル化する場合です。 データの番号付き リストをモデル化するためのインデクサーを作成できます。
    var item = someObject["key"];
someObject["AnotherKey"] = item;
     public int this[string key]
{
    get { return storage.Find(key); }
    set { storage.SetAt(key, value); }
}
 独自のインデクサーを作成する利点は、ニーズに合わせてそのコレクションのストレージを定義できることです。 一度でメモリに読
インデクサー
2020/11/02 • • Edit Online
 
 み込むには大きすぎる履歴データを型でモデル化するシナリオを考えてみましょう。 使用状況に基づいて、コレクションのセクショ ンを読み込んだりアンロードしたりする必要があります。 次の例では、この動作をモデル化します。 存在するデータ ポイント数が 報告されます。 必要に応じて、データのセクションを保持するページを作成します。 より新しい要求によって必要とされるページ のための領域を確保するために、メモリからページを削除します。
    public class DataSamples
{
    private class Page
    {
        private readonly List<Measurements> pageData = new List<Measurements>();
        private readonly int startingIndex;
        private readonly int length;
        private bool dirty;
        private DateTime lastAccess;
        public Page(int startingIndex, int length)
        {
            this.startingIndex = startingIndex;
            this.length = length;
            lastAccess = DateTime.Now;
            // This stays as random stuff:
            var generator = new Random();
            for(int i=0; i < length; i++)
            {
                var m = new Measurements
                {
                    HiTemp = generator.Next(50, 95),
                    LoTemp = generator.Next(12, 49),
                    AirPressure = 28.0 + generator.NextDouble() * 4
};
                pageData.Add(m);
            }
        }
        public bool HasItem(int index) =>
            ((index >= startingIndex) &&
            (index < startingIndex + length));
        public Measurements this[int index]
        {
get {
                return pageData[index - startingIndex];
            }
set {
} }
lastAccess = DateTime.Now;
pageData[index - startingIndex] = value;
dirty = true;
lastAccess = DateTime.Now;
    public bool Dirty => dirty;
    public DateTime LastAccess => lastAccess;
}
private readonly int totalSize;
private readonly List<Page> pagesInMemory = new List<Page>();
public DataSamples(int totalSize)
{
    this.totalSize = totalSize;
}
public Measurements this[int index]
{

     この設計手法に従って、メモリ内コレクションにデータのセット全体を読み込まないことが妥当であるような種類のコレクションをモ デル化できます。 Page クラスが、パブリックインターフェイスの一部ではない、入れ子になったプライベートクラスであることに注 意してください。 これらの詳細は、このクラスのユーザーには表示されません。
ディクショナリ
もう 1 つの一般的なシナリオは、ディクショナリまたはマップをモデル化する必要がある場合です。 このシナリオでは、キー (通常は テキスト キー) に基づいて型が値を格納します。 この例では、これらのオプションを管理するラムダ式にコマンド ライン引数をマッ プするディクショナリを作成します。次の例では、2つのクラスを示します。ArgsActions クラスは、コマンドラインオプションを
デリゲートにマップします。 ArgsProcessor クラスは、そのオプションが検出されたときに、 ArgsActions を使用して各 を実行します。
      get {
            return page[index];
        }
set {
            page[index] = value;
        }
}
    private Page updateCachedPagesForAccess(int index)
    {
        foreach (var p in pagesInMemory)
        {
            if (p.HasItem(index))
            {
return p; }
        }
        var startingIndex = (index / 1000) * 1000;
        var newPage = new Page(startingIndex, 1000);
        addPageToCache(newPage);
        return newPage;
}
    private void addPageToCache(Page p)
    {
        if (pagesInMemory.Count > 4)
        {
            // remove oldest non-dirty page:
            var oldest = pagesInMemory
                .Where(page => !page.Dirty)
                .OrderBy(page => page.LastAccess)
                .FirstOrDefault();
            // Note that this may keep more than 5 pages in memory
            // if too much is dirty
            if (oldest != null)
                pagesInMemory.Remove(oldest);
}
        pagesInMemory.Add(p);
    }
}
if (index < 0)
    throw new IndexOutOfRangeException("Cannot index less than 0");
if (index >= totalSize)
    throw new IndexOutOfRangeException("Cannot index past the end of storage");
var page = updateCachedPagesForAccess(index);
if (index < 0)
    throw new IndexOutOfRangeException("Cannot index less than 0");
if (index >= totalSize)
    throw new IndexOutOfRangeException("Cannot index past the end of storage");
var page = updateCachedPagesForAccess(index);
 Action
  Action
 
     この例では、 ArgsAction コレクションが、基になるコレクションと密接に対応しています。 get は、特定のオプションが構成さ れているかどうかを判定します。構成されている場合は、そのオプションに関連付けられている Action が返されます。構成さ れていない場合は、何も実行しない Action が返されます。 パブリック アクセサーには、 set アクセサーは含まれていません。 代わりに、オプションの設定にパブリック メソッドを使用する設計になっています。
多次元マップ
複数の引数を使用するインデクサーを作成できます。 さらに、これらの引数は、同じ型でなくてもかまいません。 2 つの例を見て みましょう。
最初の例は、マンデルブロ集合の値を生成するクラスを示しています。 集合の数学的な背景情報の詳細については、こちらの 記事を参照してください。 インデクサーは、2 つの倍精度浮動小数点数を使用して、X および Y 平面上の点を定義します。 get アクセサーは、点が集合内に存在しないと判断されるまで、イテレーションの回数を計算します。 イテレーションの最大数に 達した場合、点は集合内に存在し、クラスの maxIterations 値が返されます。 マンデルブロ集合でよく知られている、コン ピューターで生成される画像では、点が集合外に存在すると判断するために必要なイテレーションの数に対して色を定義しま す。
    public class ArgsProcessor
{
    private readonly ArgsActions actions;
    public ArgsProcessor(ArgsActions actions)
    {
        this.actions = actions;
    }
    public void Process(string[] args)
    {
        foreach(var arg in args)
        {
            actions[arg]?.Invoke();
        }
}
}
public class ArgsActions
{
    readonly private Dictionary<string, Action> argsActions = new Dictionary<string, Action>();
    public Action this[string s]
    {
get {
} }
Action action;
Action defaultAction = () => {} ;
return argsActions.TryGetValue(s, out action) ? action : defaultAction;
    public void SetOption(string s, Action a)
    {
        argsActions[s] = a;
    }
}

  マンデルブロ集合では、実数値の各 (x,y) 座標の値を定義します。 これによって、無限の数の値を格納できるディクショナリが定 義されます。 そのため、集合の背後にストレージはありません。 代わりに、このクラスはコードが get アクセサーを呼び出すとき に各点の値を計算します。 使用される、基になるストレージはありません。
最後の使用例を調べてみましょう。この例では、インデクサーが異なる型の複数の引数を受け取ります。 気温の履歴データを 管理するプログラムがあるとします。 このインデクサーは、市区町村と日付を使用して、その場所の最高気温と最低気温を設 定または取得します。
   public class Mandelbrot
{
    readonly private int maxIterations;
    public Mandelbrot(int maxIterations)
    {
        this.maxIterations = maxIterations;
    }
    public int this [double x, double y]
    {
get {
} }
var iterations = 0;
var x0 = x;
var y0 = y;
while ((x*x + y * y < 4) &&
    (iterations < maxIterations))
{
    var newX = x * x - y * y + x0;
    y = 2 * x * y + y0;
    x = newX;
    iterations++;
}
    return iterations;
}
 
     この例では、気象データを2つの異なる引数にマップするインデクサーを作成します。その引数は、city(string で表されます) とdate(DateTime で表されます)です。内部ストレージでは、2つの Dictionary クラスを使用して、2次元ディクショナリを 表します。 パブリック API は、基になるストレージを表さなくなります。 代わりに、インデクサーの言語機能を使用すると、基にな るストレージで別の主要コレクション型を使用する必要があっても、抽象化を表すパブリック インターフェイスを作成できます。
このコードには、一部の開発者にはなじみのない部分が2つあります。これら2つの using ディレクティブです。
構築ジェネリック型の "エイリアス" を作成しています。 これらのステートメントにより、後のコードでは、
と のジェネリック コン
      using DateMeasurements = System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>;
using CityDataMeasurements = System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>>;
   Dictionary<DateTime, Measurements>
ストラクションではなく、よりわかりやすい
トラクトでは、 = 記号の右辺で完全修飾型名を使用する必要はありません。
Dictionary<string, Dictionary<DateTime, Measurements> >
  DateMeasurements
と という名前を使用できます。 このコンス
CityDateMeasurements
 2つ目の手法では、コレクションへのインデックス作成に使用された任意の DateTime オブジェクトから時間部分を取り除きま す。.NETには、日付のみの型は含まれません。開発者は   型を使用しますが、Date プロパティを使用して、その
  using DateMeasurements =
System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>;
using CityDataMeasurements =
System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<System.DateTime,
IndexersSamples.Common.Measurements>>;
public class HistoricalWeatherData
{
    readonly CityDataMeasurements storage = new CityDataMeasurements();
    public Measurements this[string city, DateTime date]
    {
get {
} }
}
} set {
var cityData = default(DateMeasurements);
if (!storage.TryGetValue(city, out cityData))
    throw new ArgumentOutOfRangeException(nameof(city), "City not found");
// strip out any time portion:
var index = date.Date;
var measure = default(Measurements);
if (cityData.TryGetValue(index, out measure))
    return measure;
throw new ArgumentOutOfRangeException(nameof(date), "Date not found");
var cityData = default(DateMeasurements);
if (!storage.TryGetValue(city, out cityData))
{
    cityData = new DateMeasurements();
    storage.Add(city, cityData);
}
// Strip out any time portion:
var index = date.Date;
cityData[index] = value;
 DateTime
 
  日のすべての   オブジェクトが等しくなるようにしてください。
まとめ
クラスにプロパティのような要素があり、そのプロパティが単一の値ではなく値のコレクションを表していて、各項目が引数のセット によって識別される場合は、インデクサーを作成する必要があります。 これらの引数では、参照する必要があるコレクションの項 目を一意に特定できます。 インデクサーにより、プロパティの概念は拡張されます。メンバーはクラスの外部からデータ項目のよう に扱われますが、内部ではメソッドに似ています。 インデクサーを使用すると、引数は、項目のセットを表すプロパティ内で単一 の項目を見つけることができます。
 DateTime
 
     C# 7.0 以降では、C# で破棄がサポートされます。これらは、アプリケーション コードで意図的に使用しないプレースホルダー変 数です。 破棄は、未割り当ての変数と同等です。つまり、値がありません。 破棄によって、あなたのコードを読み取るコンパイラ およびその他のユーザーに対して、次のような意図が伝わります。あなたは式の結果を無視するつもりでした。 あなたは、式の 結果、タプル式の1つ以上のメンバー、メソッドの out パラメーター、またはパターンマッチング式のターゲットを無視したい可能 性があります。
破棄変数は 1 つしかないため、その変数にストレージが割り当てられていない可能性もあります。 破棄すると、メモリ割り当て を減らすことができます。 破棄することで、コードの意図が明確になります。 そのため、読みやすさと保守容易性が向上します。
変数を破棄と指定するには、変数名にアンダースコア ( _ ) を指定します。 たとえば、次のメソッド呼び出しでタプルが返され、1 つ目と2つ目の値は破棄です。 area は、GetCityInformation によって返される3つ目のコンポーネントに設定された、以 前に宣言された変数です。
C# 9.0 以降では、破棄を使用して、ラムダ式の未使用の入力パラメーターを指定できます。 詳細については、ラムダ式に関す る記事の「ラムダ式の入力パラメーター」セクションを参照してください。
_ が有効な破棄の場合、その値を取得しようとすると、または代入演算で使用しようとすると、"名前'_'は、現在のコンテキ ストに存在していません"というコンパイラエラーCS0301が生成されます。このエラーの原因は、_ に値が割り当てられておら ず、記憶域の場所も割り当てることができないことです。 実際の変数であれば、前の例のように、複数の値を破棄できません。
タプルとオブジェクトの分解
分解は、複数のタプルがあり、アプリケーション コードで一部のタプル要素を使用し、その他の要素を無視する場合に便利で す。たとえば、次の QueryCityDataForYears メソッドは、市区町村名、その地域、年、市区町村のその年の人口、2つ目の 年、市区町村のその 2 つ目の年の人口というタプルを返します。 この例は、2 つの年の間に変化した人口数を示しています。 タプルから使用できるデータのうち、市区町村の地域は使用しません。また、指定時に市区町村名と 2 つの日付はわかってい ます。 そのため、タプルに格納されている 2 つの人口値のみが必要であり、残りの値は破棄対象として処理できます。
   (_, _, area) = city.GetCityInformation(cityName);
  破棄 - C# ガイド 2021/03/16 • • Edit Online
 
   破棄を使用したタプルの分解の詳細については、「タプルとその他の型の分解」を参照してください。
また、クラス、構造体、またはインターフェイスの Deconstruct メソッドを使用すると、オブジェクトから特定セットのデータを取得 し、分解することもできます。分解された値の一部のみが必要な場合は、破棄を使用できます。 Person オブジェクトを4つ の文字列 (名、姓、市区町村、州) に分解し、姓と州を破棄する例を次に示します。
     var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);
Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}");
static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2)
{
    int population1 = 0, population2 = 0;
    double area = 0;
    if (name == "New York City")
    {
        area = 468.48;
        if (year1 == 1960)
        {
            population1 = 7781984;
        }
        if (year2 == 2010)
        {
            population2 = 8175133;
        }
        return (name, area, year1, population1, year2, population2);
    }
    return ("", 0, 0, 0, 0, 0);
}
// The example displays the following output:
//      Population change, 1960 to 2010: 393,149
 
      破棄を使用したユーザー定義型の分解の詳細については、「タプルとその他の型の分解」を参照してください。
switch を使用したパターン マッチング "破棄パターン"は、switch式を使用したパターンマッチングで使用できます。 null も含め、あらゆる式は常に破棄パターンと
   using System;
namespace Discards
{
    public class Person
    {
        public string FirstName { get; set; }
        public string MiddleName { get; set; }
        public string LastName { get; set; }
        public string City { get; set; }
        public string State { get; set; }
        public Person(string fname, string mname, string lname,
                      string cityName, string stateName)
        {
            FirstName = fname;
            MiddleName = mname;
            LastName = lname;
            City = cityName;
            State = stateName;
}
        // Return the first and last name.
        public void Deconstruct(out string fname, out string lname)
        {
            fname = FirstName;
            lname = LastName;
        }
        public void Deconstruct(out string fname, out string mname, out string lname)
        {
            fname = FirstName;
            mname = MiddleName;
            lname = LastName;
}
        public void Deconstruct(out string fname, out string lname,
                                out string city, out string state)
        {
            fname = FirstName;
            lname = LastName;
            city = City;
            state = State;
} }
    class Example
    {
        public static void Main()
        {
} }
}
var p = new Person("John", "Quincy", "Adams", "Boston", "MA");
// Deconstruct the person object.
var (fName, _, city, _) = p;
Console.WriteLine($"Hello {fName} of {city}!");
// The example displays the following output:
//      Hello John of Boston!

   一致します。
 switch 式を使用して、オブジェクトがIFormatProvider実装を提供しているかどうかを判断し、オブジェクトが null かどう かをテストする ProvidesFormatInfo メソッドの定義例を次に示します。また、破棄パターンを使用して、その他の任意の型の null 以外のオブジェクトを処理します。
     object[] objects = { CultureInfo.CurrentCulture,
                   CultureInfo.CurrentCulture.DateTimeFormat,
                   CultureInfo.CurrentCulture.NumberFormat,
                   new ArgumentException(), null };
foreach (var obj in objects)
    ProvidesFormatInfo(obj);
static void ProvidesFormatInfo(object obj) =>
    Console.WriteLine(obj switch
    {
        IFormatProvider fmt => $"{fmt.GetType()} object",
        null => "A null object reference: Its use could result in a NullReferenceException",
        _ => "Some object type without format information"
    });
// The example displays the following output:
//    System.Globalization.CultureInfo object
//    System.Globalization.DateTimeFormatInfo object
//    System.Globalization.NumberFormatInfo object
//    Some object type without format information
//    A null object reference: Its use could result in a NullReferenceException
  out パラメーターを使用したメソッドの呼び出し
Deconstruct メソッドを呼び出してユーザー定義型(クラス、構造体、またはインターフェイスのインスタンス)を分解する場合、 個々の out 引数の値を破棄できます。 また、 out パラメーターを指定して任意のメソッドを呼び出すときに、 out 引数の値 を破棄することもできます
次の例では、DateTime.TryParse(String, out DateTime) メソッドを呼び出して、現在のカルチャで日付の文字列表現が有 効かどうかを判断します。 この例では、日付文字列の検証のみが目的で、解析して日付を抽出する処理は行わないため、メ ソッドの out 引数は破棄されます。
     string[] dateStrings = {"05/01/2018 14:57:32.8", "2018-05-01 14:57:32.8",
                      "2018-05-01T14:57:32.8375298-04:00", "5/01/2018",
                      "5/01/2018 14:57:32.80 -07:00",
                      "1 May 2018 2:57:32.8 PM", "16-05-2018 1:00:32 PM",
                      "Fri, 15 May 2018 20:10:57 GMT" };
foreach (string dateString in dateStrings)
{
    if (DateTime.TryParse(dateString, out _))
        Console.WriteLine($"'{dateString}': valid");
    else
        Console.WriteLine($"'{dateString}': invalid");
}
// The example displays output like the following:
//       '05/01/2018 14:57:32.8': valid
//       '2018-05-01 14:57:32.8': valid
//       '2018-05-01T14:57:32.8375298-04:00': valid
//       '5/01/2018': valid
//       '5/01/2018 14:57:32.80 -07:00': valid
//       '1 May 2018 2:57:32.8 PM': valid
//       '16-05-2018 1:00:32 PM': invalid
//       'Fri, 15 May 2018 20:10:57 GMT': invalid
 スタンドアロンの破棄

   スタンドアロンの破棄を使用して、無視対象として任意の変数を指定できます。 一般的な用途の 1 つは、割り当てを使用し て、引数が null でないことを確認することです。 次のコードでは、破棄を使用して割り当てを強制しています。 代入の右側に はnull合体演算子が使用され、引数が null の場合にSystem.ArgumentNullExceptionがスローされます。このコード に割り当ての結果は不要なため、破棄されます。 式によって null チェックが強制的に実行されます。 破棄を使用して、割り当 ての結果は必要ではないか、使用されない、という意図を明確にします。
次の例では、スタンドアロンの破棄を使用して、非同期操作で返される Task オブジェクトを無視します。 タスクの割り当ての結 果、この処理が完了するときにスローされる例外が抑制される効果があります。 これにより、次のようなあなたの意図が明確に なります。あなたは、 Task を破棄し、その非同期操作から生成されるエラーを無視したいと考えています。
    public static void Method(string arg)
{
    _ = arg ?? throw new ArgumentNullException(paramName: nameof(arg), message: "arg can't be null");
    // Do work with arg.
}
     private static async Task ExecuteAsyncMethods()
{
    Console.WriteLine("About to launch a task...");
    _ = Task.Run(() =>
    {
        var iterations = 0;
        for (int ctr = 0; ctr < int.MaxValue; ctr++)
            iterations++;
        Console.WriteLine("Completed looping operation...");
        throw new InvalidOperationException();
    });
    await Task.Delay(5000);
    Console.WriteLine("Exiting after 5 second delay");
}
// The example displays output like the following:
//       About to launch a task...
//       Completed looping operation...
//       Exiting after 5 second delay
 タスクを破棄に割り当てないと、次のコードにより、コンパイラの警告が生成されます。
    private static async Task ExecuteAsyncMethods()
{
    Console.WriteLine("About to launch a task...");
    // CS4014: Because this call is not awaited, execution of the current method continues before the call
is completed.
    // Consider applying the 'await' operator to the result of the call.
    Task.Run(() =>
    {
        var iterations = 0;
        for (int ctr = 0; ctr < int.MaxValue; ctr++)
            iterations++;
        Console.WriteLine("Completed looping operation...");
        throw new InvalidOperationException();
    });
    await Task.Delay(5000);
    Console.WriteLine("Exiting after 5 second delay");
     NOTE
デバッガーを使用して上の 2 つのサンプルのいずれかを実行すると、例外がスローされたときにデバッガーによってプログラムが停止します。 デ バッガーがアタッチされていない場合、どちらの場合も例外は警告なしで無視されます。
 
    _ は有効な識別子でもあります。サポートされるコンテキスト以外で _ を使用すると、破棄対象ではなく、有効な変数とし て扱われます。 _ という識別子が既にスコープ内にある場合、スタンドアロンの破棄として _ を使用すると、次のような結果 になります。
意図した破棄の値を割り当てることで、スコープ内の _ 変数の値が誤って変更される。次に例を示します。
    private static void ShowValue(int _)
{
   byte[] arr = { 0, 0, 1, 2 };
   _ = BitConverter.ToInt32(arr, 0);
   Console.WriteLine(_);
}
 // The example displays the following output:
 //       33619968
 タイプ セーフに違反するコンパイラ エラーが発生する。 次に例を示します。
    private static bool RoundTrips(int _)
{
   string value = _.ToString();
   int newValue = 0;
   _ = Int32.TryParse(value, out newValue);
   return _ == newValue;
}
// The example displays the following compiler error:
//      error CS0029: Cannot implicitly convert type 'bool' to 'int'
 コンパイラ エラー CS0136 "ローカルまたはパラメーター '_' は、その名前が外側のローカルのスコープでローカルやパラメーター の定義に使用されているため、このスコープでは宣言できません" が発生する。 次に例を示します。
     public void DoSomething(int _)
{
 var _ = GetValue(); // Error: cannot declare local _ when one is already in scope
}
// The example displays the following compiler error:
// error CS0136:
//       A local or parameter named '_' cannot be declared in this scope
//       because that name is used in an enclosing local scope
//       to define a local or parameter
 関連項目
タプルとその他の型の分解 is キーワード
switch キーワード
 
       ジェネリックにより、.NET に型パラメーターという概念が導入されます。これを使用すると、クラスやメソッドがクライアント コードに よって宣言され、インスタンス化されるまで、1 つ以上の型の指定を遅延させるクラスやメソッドを設計することができます。 たとえ ば、ジェネリック型パラメーター T を使用すると、次に示すように、ランタイムキャストやボックス化操作を使うコストやリスクを発 生させることなく他のクライアント コードで使用できる、単一のクラスを記述できます。
    // Declare the generic class.
public class GenericList<T>
{
    public void Add(T input) { }
}
class TestGenericList
{
    private class ExampleClass { }
    static void Main()
    {
} }
// Declare a list of type int.
GenericList<int> list1 = new GenericList<int>();
list1.Add(1);
// Declare a list of type string.
GenericList<string> list2 = new GenericList<string>();
list2.Add("");
// Declare a list of type ExampleClass.
GenericList<ExampleClass> list3 = new GenericList<ExampleClass>();
list3.Add(new ExampleClass());
 ジェネリックのクラスとメソッドにより、非ジェネリックの場合には不可能な方法で、再利用性、タイプ セーフ、効率性が同時に実 現されます。 ジェネリックは、コレクションとそれを操作するメソッドとともに使用されるのが通常です。 System.Collections.Generic 名前空間には、ジェネリック ベースのコレクション クラスがいくつか含まれています。 ArrayList な どの非ジェネリック コレクションは推奨されません。これらは互換性のために保持されています。 詳細については、「.NET のジェネ リック」を参照してください。
もちろん、カスタムのジェネリック型やジェネリック メソッドを作成して、タイプ セーフで効率的な独自の汎用ソリューションや設計パ ターンを実現することもできます。 次のコード例では、デモンストレーション用の簡単なジェネリックのリンク リスト クラスを示しま す。 (通常は、独自のクラスを作成するのではなく、.NET で用意されている List<T> クラスを使用してください。)この例では、 通常、具体的な型を使用して、リストに格納する項目の型を示す場面で、型パラメーター T を使用しています。このパラメー ターは、次のように使用されています。
AddHead メソッドのメソッドパラメーターの型として使用。
入れ子になった Node クラスの Data プロパティの戻り値の型として使用。 入れ子になったクラスのプライベートメンバー data の型として使用。
入れ子になった Node クラスで T を使用できることに注意してください。 GenericList<T> が GenericList<int> のような具 象型でインスタンス化されると、 T の部分はそれぞれ int に置き換えられます。
   ジェネリック (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     次のコード例では、クライアントコードでジェネリックの GenericList<T> クラスを使用して、整数のリストを作成する方法を示し ています。 このコードの型引数を変更するだけで、文字列やその他の任意のカスタム型のリストを作成するように簡単に修正で きます。
  // type parameter T in angle brackets
public class GenericList<T>
{
    // The nested class is also generic on T.
    private class Node
    {
        // T used in non-generic constructor.
        public Node(T t)
        {
next = null;
data = t; }
        private Node next;
        public Node Next
        {
            get { return next; }
            set { next = value; }
        }
        // T as private member data type.
        private T data;
        // T as return type of property.
        public T Data
        {
            get { return data; }
            set { data = value; }
        }
    }
    private Node head;
    // constructor
    public GenericList()
    {
head = null; }
    // T as method parameter type:
    public void AddHead(T t)
    {
        Node n = new Node(t);
        n.Next = head;
        head = n;
}
    public IEnumerator<T> GetEnumerator()
    {
} }
Node current = head;
while (current != null)
{
    yield return current.Data;
    current = current.Next;
}

                   ジェネリックの概要
ジェネリック型は、コードの再利用、タイプ セーフ、およびパフォーマンスを最大化するために使用します。 ジェネリックの最も一般的な用途は、コレクション クラスの作成です。
.NET クラス ライブラリには、複数のジェネリック コレクション クラスが System.Collections.Generic 名前空間に含まれていま す。 System.Collections 名前空間の ArrayList などのクラスの代わりとして、できる限りこれらを使用してください。 独自のジェネリック インターフェイス、クラス、メソッド、イベント、およびデリゲートを作成できます。
ジェネリック クラスは、特定のデータ型のメソッドへのアクセスを有効にするように制限できます。
ジェネリック データ型で使用される型に関する情報は、実行時にリフレクションを使用して取得できます。 関連項目
ジェネリック型パラメーター 型パラメーターの制約 ジェネリック クラス ジェネリック インターフェイス ジェネリック メソッド 汎用デリゲート
C++ テンプレートと C# ジェネリックの違い ジェネリックとリフレクション ランタイムのジェネリック
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。
関連項目
System.Collections.Generic
C# プログラミング ガイド 型
<typeparam> <typeparamref>
   class TestGenericList
{
    static void Main()
    {
        // int is the type argument
        GenericList<int> list = new GenericList<int>();
        for (int x = 0; x < 10; x++)
        {
            list.AddHead(x);
        }
        foreach (int i in list)
        {
            System.Console.Write(i + " ");
        }
        System.Console.WriteLine("\nDone");
    }
}
 
  .NET のジェネリック

      プログラムを記述するうえで、ほとんどのプログラムに必要になるのがコレクションの反復処理です。 反復処理が必要な場合は、 コレクション内のすべての項目を調べるコードを記述します。
また、クラスの要素に対して反復子 (コンテナーを横断するオブジェクト。特にリスト) を生成するメソッドである、反復子メソッドも 作成することになります。 反復子メソッドは以下のような目的に使用できます。
コレクション内の各項目に対するアクションの実行。
カスタム コレクションの列挙。
LINQ やその他のライブラリの拡張。
反復子メソッドによってデータ フローを効率化するデータ パイプラインの作成。
C# 言語には、上記の両方のシナリオに対応するための機能が用意されています。 この記事では、それらの機能の概要につい て説明します。
このチュートリアルには、複数の手順があります。 各手順の後に、アプリケーションを実行して進行状況を確認できます。 このト ピックの完全なサンプルを表示またはダウンロードすることもできます。 ダウンロード方法については、「サンプルおよびチュートリア ル」を参照してください。
foreach を使用した反復処理
コレクションの列挙処理は単純です。foreach キーワードによってコレクション内の要素ごとに埋め込みステートメントを1回実
行し、コレクションを列挙します。
これで完成です。 foreach ステートメントさえあれば、コレクションに含まれるすべての内容を反復処理できます。ただし、 foreach ステートメントは魔法ではありません。コレクションの反復処理に必要なコードを生成するためには、.NETコアライブ
ラリに定義されている2つのジェネリックインターフェイス、IEnumerable<T> と IEnumerator<T> が不可欠です。このメカニズム については、後ほど詳しく説明します。
これら2つのインターフェイスに対応する非ジェネリックインターフェイスとして、IEnumerable と IEnumerator があります。最 新のコード向けにはジェネリック バージョンが適しています。
反復子メソッドを使用した列挙型のソース
C# 言語のもう 1 つの優れた機能を利用することで、列挙型用のソースを作成するメソッドを構築できます。 このようなメソッド を、"反復子メソッド" と呼びます。 反復子メソッドでは、要求があった場合にオブジェクトがどのようなシーケンスで生成されるか を定義します。 反復子メソッドを定義するには、 yield return コンテキスト キーワードを使用します。
次のメソッドを記述することで、0 ~ 9 の整数からなるシーケンスを生成できます。
     foreach (var item in collection)
{
   Console.WriteLine(item.ToString());
}
        Iterators
2020/11/02 • • Edit Online
 
   上記のコードでは、複数の yield return ステートメントを反復子メソッド内で個別に使用できるという点を強調するために、 さまざまな yield return ステートメントを示しています。 反復子メソッドのコードを簡略化するために、他の言語構成要素を 使用することができます (実際、頻繁に使用します)。 次のメソッド定義では、まったく同じ数値のシーケンスが生成されます。
どちらか一方に決める必要はありません。 メソッドのニーズに合わせて必要な数だけ yield return ステートメントを使用でき ます。
     public IEnumerable<int> GetSingleDigitNumbers()
{
    int index = 0;
    while (index < 10)
}
yield return index++;
      public IEnumerable<int> GetSingleDigitNumbers()
{
    int index = 0;
    while (index < 10)
        yield return index++;
    yield return 50;
    index = 100;
    while (index < 110)
}
yield return index++;
 これが基本的な構文です。 反復子メソッドを記述することになるであろう実際の例について考えてみましょう。 自分が IoT プロ ジェクトに参加しているとして、デバイス センサーから膨大な量のデータ ストリームが生成されている状況を想像してください。 データをおおまかに把握するためには、N 番目ごとにデータ要素をサンプリングするメソッドを記述することになります。 このような 処理は、次の小さな反復子メソッドで実現できます。
    public static IEnumerable<T> Sample(this IEnumerable<T> sourceSequence, int interval)
{
    int index = 0;
    foreach (T item in sourceSequence)
    {
} }
if (index++ % interval == 0)
    yield return item;
   反復子メソッドには重要な制限事項が 1 つあり、 return ステートメントと yield return ステートメントの両方を同じメソッド 内で使用することはできません。 そのため、次のコードはコンパイルされません。
   public IEnumerable<int> GetSingleDigitNumbers()
{
    yield return 0;
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
    yield return 5;
    yield return 6;
    yield return 7;
    yield return 8;
    yield return 9;
}
 
   通常は、この制限が問題になることはありません。 メソッド全体で を使用するか、元のメソッドを複数に分割し て一部のメソッドでは return 、一部のメソッドでは を使用するか、いずれかの方法を選択できます。
前のメソッドを少し修正すると、メソッド全体で yield return のみを使用するように変更できます。
      public IEnumerable<int> GetSingleDigitNumbers()
{
    int index = 0;
    while (index < 10)
        yield return index++;
    yield return 50;
    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };
    foreach (var item in items)
}
yield return item;
  反復子メソッドを2つの異なるメソッドに分割することが正解となる場合もあります。つまり、return を使用するメソッドと yield return を使用するメソッドの 2 つです。 ブール型の引数を基に、空のコレクションまたは最初の 5 つの奇数を返す必
要があるような場合を考えてみてください。 この処理は、次の 2 つのメソッドとして記述できます。
     public IEnumerable<int> GetSingleDigitOddNumbers(bool getCollection)
{
    if (getCollection == false)
        return new int[0];
    else
        return IteratorMethod();
}
private IEnumerable<int> IteratorMethod()
{
    int index = 0;
    while (index < 10)
    {
        if (index % 2 == 1)
            yield return index;
index++; }
}
  上記のメソッドを見てみましょう。1つ目のメソッドでは、標準の return ステートメントを使用して空のコレクションまたは2つ 目のメソッドで作成された反復子のいずれかを返します。 2 つ目のメソッドでは、 yield return ステートメントを使用して要求 されたシーケンスを作成します。
  foreach の詳細
yield return
 yield return
   public IEnumerable<int> GetSingleDigitNumbers()
{
    int index = 0;
    while (index < 10)
        yield return index++;
    yield return 50;
    // generates a compile time error:
    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };
    return items;
}
 
      ステートメントは、   および   インターフェイスを使用してコレクションの全要素を反 復処理する標準的な表現形式に展開されます。 また、開発者の不適切なリソース管理によって生じるエラーを最小化する効 果もあります。
最初の例に登場する foreach ループは、コンパイラによって次のコンストラクトに似たコードに変換されます。
上記のコンストラクトは、バージョン 5 以降の C# コンパイラによって生成されるコードを表しています。 バージョン 5 より前のバー ジョンでは、 item 変数のスコープが異なります。
foreach
IEnumerable<T>
IEnumerator<T>
        IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    Console.WriteLine(item.ToString());
}
     // C# versions 1 through 4:
IEnumerator<int> enumerator = collection.GetEnumerator();
int item = default(int);
while (enumerator.MoveNext())
{
    item = enumerator.Current;
    Console.WriteLine(item.ToString());
}
 この点が変更された理由は、以前の動作に、ラムダ式に関連する微妙なバグや診断の難しいバグを発生させる可能性があっ たためです。 ラムダ式について詳しくは、「ラムダ式」をご覧ください。
コンパイラによって実際に生成されるコードはもう少し複雑であり、 GetEnumerator() から返されるオブジェクトで IDisposable インターフェイスを実装する場合の処理も含まれています。 全展開によって生成されるコードは、次のようになります。
      {
    var enumerator = collection.GetEnumerator();
    try
    {
        while (enumerator.MoveNext())
        {
            var item = enumerator.Current;
            Console.WriteLine(item.ToString());
        }
} finally {
        // dispose of enumerator.
    }
}
   列挙子が破棄される場合、その方法は enumerator の型の特性によって異なります。 一般的なケースでは、 finally 句は 次のように展開されます。
ただし、 enumerator の型がシール型で、 enumerator から IDisposable への暗黙的な型変換がない場合、 finally 句 は空のブロックに展開されます。
    finally {
   (enumerator as IDisposable)?.Dispose();
}
     
      enumerator から IDisposable への暗黙的な型変換があり、 enumerator が null 非許容の値型である場合、 finally 句は次のように展開されます。
さいわいなことに、これらの詳細をすべて覚えておく必要はありません。このような微妙な差異は、いずれも foreach ステートメ ントによって処理されます。 コンパイラでは、これらすべてのコンストラクトに対して正しいコードが生成されます。
    finally {
   ((IDisposable)enumerator).Dispose();
}
     finally {
}
 
     デリゲートは、.NET における "遅延バインディング" のメカニズムです。 遅延バインディングとは、皆さんが作成するアルゴリズムに ついて、その一部を実装するメソッドを呼び出し元からも少なくとも 1 つ与えることを意味します。
たとえば天文学アプリケーションで、一連の星を並べ替えることを考えてみましょう。 星の並べ替え基準には、地球からの距離 や星の等級、知覚的な明るさを選ぶことができます。
いずれの場合も、Sort() メソッドが行うことは基本的に同じです。つまり何らかの比較に基づいて一連の項目を整列します。 し かし、2 つの星を比較するコードは、並べ替えの基準によって異なります。
ソフトウェアには、この種の手法が半世紀にわたって使用されてきました。 C# 言語のデリゲートの概念は、きわめて優れた言語 機能と、その概念を中心にしたタイプ セーフ機能を実現します。
本シリーズの中で後述しているように、このようなアルゴリズム向けに記述された C# コードはタイプ セーフであり、引数や戻り値 の型については、言語規則とコンパイラの機能を使用して型の一致が保証されます。
同様のシナリオで、呼び出し規則をより細かく制御する必要がある場合のために、関数ポインターが C# 9 に追加されました。 デリゲートに関連付けられたコードは、デリゲート型に追加された仮想メソッドを使用して呼び出されます。 関数ポインターを使 用して、さまざまな規則を指定できます。
デリゲートの言語上の設計目標
最終的にデリゲートとなる機能を実現するにあたって、言語の設計者たちはさまざまな目標を設定しました。
設計チームが目指したのは、あらゆる遅延バインディング アルゴリズムに適用できる共通の言語概念です。 デリゲートによって、 開発者が 1 つの概念を身に付け、ソフトウェアに関するさまざまな課題にその知識を応用できるような言語の実現を目標に掲 げたのです。
次に設計チームが目指したのは、シングルキャストとマルチキャストの両方のメソッド呼び出しをサポートすることでした。 (マルチ キャスト デリゲートは、複数のメソッド呼び出しを連結するデリゲートです。 このシリーズの後の記事で例を見ます。)
設計チームは、C# のあらゆるコード要素に関して開発者たちが当然と考えるレベルのタイプ セーフティをデリゲートにおいても実 現したいと考えていたのです。
また、設計チームは、デリゲートを初めとする遅延バインディング アルゴリズムの利便性が大いに発揮される具体的なパターン は、イベント パターンであると認識していました。 .NET のイベントの基本的なパターンをデリゲートのコードで確実に実現したいと 考えていたのです。
そうした目標に向けたすべての作業の成果として C# と .NET にサポートされたのが、デリゲートとイベントです。 以降このセクショ ンの記事では、言語の機能やライブラリのサポート、デリゲートを扱う際に用いられる一般的な用語について取り上げています。
delegate キーワードとそれによって生成されるコード、 System.Delegate クラスの機能とその使い方、タイプセーフなデリゲー トの作成方法、デリゲート経由で呼び出すことのできるメソッドの作成方法のほか、 ラムダ式を使ったデリゲートやイベントの扱い 方、 LINQ の構成要素としてデリゲートがどこで使われているか、 .NET のイベント パターンの基礎としてデリゲートがどのように 使われ、両者がどのように違うのかについても説明します。
では、始めましょう。
次へ
  デリゲートの概要
2021/03/06 • • Edit Online
 
     [戻る]
この記事では、デリゲートをサポートする.NETのクラスと、それが delegate キーワードにどのように対応付けられるかについて
取り上げます。 デリゲート型を定義する
最初に、'delegate'キーワードから始めましょう。これは、主に、デリゲートを操作する際に使用するためです。 delegate キー ワードを使用したときにコンパイラで生成されるコードは、Delegate クラスおよび MulticastDelegate クラスのメンバーを呼び出 すメソッド呼び出しにマップされます。
デリゲート型を定義するには、メソッドシグネチャの定義と同様の構文を使用します。定義に delegate キーワードを追加す るだけです。
続けて、例として List.Sort() メソッドを使用してみましょう。 最初の手順では、比較デリゲートの型を作成します。
コンパイラは、使用されたシグネチャ(ここでは、整数を返し、2つの引数を持つメソッド)と一致する System.Delegate から派 生するクラスを生成します。そのデリゲートの型は Comparison です。 Comparison デリゲート型はジェネリック型です。ジェネ リックの詳細については、こちらを参照してください。
構文は変数を宣言しているように見えるかもしれませんが、実際には "型" を宣言していることに注意してください。 デリゲート 型は、クラス内で定義したり、名前空間内で直接定義したりできるだけでなく、さらにグローバル名前空間でも定義できます。
コンパイラは、この新しい型用の追加ハンドラーと削除ハンドラーも生成するため、このクラスのクライアントは、インスタンスの呼 び出しリストでメソッドを追加したり削除したりできます。 コンパイラでは、追加または削除されるメソッドのシグネチャが、メソッド の宣言時に使用されたシグネチャと一致することが強制されます。
デリゲートのインスタンスを宣言する
デリゲートを定義した後に、その型のインスタンスを作成できます。 C# のすべての変数と同様に、デリゲート インスタンスを名前 空間で直接宣言することも、グローバル名前空間で宣言することもできません。
       // From the .NET Core library
// Define the delegate type:
public delegate int Comparison<in T>(T left, T right);
        NOTE
グローバル名前空間で直接デリゲート型 (またはその他の型) を宣言することは、お勧めしません。
     // inside a class definition:
// Declare an instance of that type:
public Comparison<T> comparator;
   変数の型は、前に定義したデリゲート型の Comparison<T> です。 変数の名前は、 comparator です。
 System.Delegateと delegate キーワード 2020/11/02 • • Edit Online
 
   上記のコード スニペットでは、クラス内でメンバー変数を宣言しました。 ローカル変数であるデリゲート変数、またはメソッドの引 数も宣言できます。
デリゲートを呼び出す
デリゲートの呼び出しリストに含まれているメソッドを呼び出すには、そのデリゲートを呼び出します。 Sort() メソッドの内部で、 コードは比較メソッドを呼び出して、オブジェクトを配置する順番を決定します。
上の行のコードは、デリゲートにアタッチされているメソッドを "呼び出し" ます。 変数をメソッド名として扱い、通常のメソッド呼び 出しの構文を使用して呼び出します。
このコード行は、安全でない想定を行っています。つまり、ターゲットがデリゲートに追加済みであるという保証がありません。 ター ゲットがアタッチされていない場合、上の行によって NullReferenceException がスローされます。この問題に対処するための 用法は、単純な null チェックよりも複雑で、このシリーズの後の方で説明します。
呼び出しターゲットの割り当て、追加、および削除を行う デリゲート型の定義方法と、デリゲート インスタンスの宣言および呼び出しの方法は以上です。
List.Sort() メソッドを使用する開発者は、シグネチャがデリゲート型の定義と一致するメソッドを定義し、sortメソッドによっ て使用されるデリゲートに割り当てる必要があります。 この割り当てによって、そのデリゲート オブジェクトの呼び出しリストにメソッ ドが追加されます。
文字列のリストを、長さを基準にして並べ替えるとします。 比較関数は、次のようになります。
メソッドは、プライベート メソッドとして宣言されます。 それでかまいません。 このメソッドをパブリック インターフェイスに含めることは できないかもしれません。 それでも、デリゲートにアタッチすれば、比較メソッドとして使用できます。 呼び出しコードでは、このメ ソッドがデリゲート オブジェクトのターゲット リストにアタッチされるため、そのデリゲートを通じてこのメソッドにアクセスできます。
この関係を作成するには、このメソッドを List.Sort() メソッドに渡します。
メソッド名が、かっこなしで使用されることに注意してください。 メソッドを引数として使用すると、コンパイラは、メソッドの参照を、 デリゲート呼び出しターゲットとして使用できる参照に変換し、そのメソッドを呼び出しターゲットとしてアタッチします。
Comparison<string> 型の変数を宣言し、割り当てを行うことで、明示的にそうすることもできました。
デリゲート ターゲットとして使用されているメソッドが小さなメソッドである場合は、ラムダ式構文を使用して割り当てを実行する ことが一般的です。
   int result = comparator(left, right);
       private static int CompareLength(string left, string right) =>
    left.Length.CompareTo(right.Length);
    phrases.Sort(CompareLength);
      Comparison<string> comparer = CompareLength;
phrases.Sort(comparer);
     Comparison<string> comparer = (left, right) => left.Length.CompareTo(right.Length);
phrases.Sort(comparer);
 デリゲート ターゲットにラムダ式を使用する方法については、後のセクションで詳しく説明しています。

    Sort() の例では、通常、デリゲートに 1 つのターゲット メソッドをアタッチします。 ただし、デリゲート オブジェクトは、複数のター ゲット メソッドがデリゲート オブジェクトにアタッチされている呼び出しリストをサポートしています。
Delegate クラスと MulticastDelegate クラス 前述の言語サポートは、デリゲートの操作で一般的に必要となる機能と支援を提供します。 これらの機能は、.NET Core
Framework の 2 つのクラスである Delegate と MulticastDelegate に基づいています。
System.Delegate クラスとその単一の直接的なサブクラス System.MulticastDelegate では、デリゲートの作成、デリゲート ターゲットとしてのメソッドの登録、デリゲート ターゲットとして登録されているすべてのメソッドの呼び出しに対するフレームワークの サポートが提供されます。
興味深いことに、 System.Delegate クラスと System.MulticastDelegate クラス自体は、デリゲート型ではありません。 これら のクラスは、すべてのデリゲート型の基礎となります。 この言語設計プロセスにより、 Delegate または MulticastDelegate か ら派生するクラスを宣言することはできません。 C# 言語の規則によって禁止されています。
代わりに、C#言語キーワードを使用してデリゲート型を宣言すると、C#コンパイラは、 MulticastDelegate から派生したクラス のインスタンスを作成します。
この設計は、C# と .NET の最初のリリースが起源になっています。 設計チームの 1 つの目標は、デリゲートを使用するときに言 語によってタイプ セーフが強制的に適用されるようにすることでした。 つまり、デリゲートが確実に適切な型と数の引数で呼び出 されるようにすることでした。 また、戻り値の型がコンパイル時に正しく指定されるようにする必要もありました。 デリゲートは 1.0 .NET リリースに含まれており、ジェネリックより前のことでした。
このタイプ セーフを強制的に適用する最良の方法は、使用されるメソッド シグネチャを表す具体的なデリゲート クラスをコンパイ ラで作成することでした。
派生クラスを直接作成することはできませんが、これらのクラスで定義されているメソッドを使用することはできます。 それでは、デ リゲートを操作するときに使用する最も一般的なメソッドを見ていきましょう。
まず、覚えておくべき最も重要な事実は、操作するすべてのデリゲートが MulticastDelegate から派生しているということで す。 マルチキャスト デリゲートとは、デリゲートを通じて呼び出す場合に複数のメソッド ターゲットを呼び出すことができることを意 味します。 元の設計では、アタッチして呼び出すことができるターゲット メソッドが 1 つのみのデリゲートと、複数のターゲット メソッ ドをアタッチして呼び出すことができるデリゲートを区別することが考慮されていました。 この区別は、実際には当初考えていたよ りも役に立たないことがわかりました。 この異なる 2 つのクラスは既に作成され、初期の公開リリースからフレームワークに含まれ ていました。
デリゲートと共に最もよく使用するメソッドは、 Invoke() と BeginInvoke() / EndInvoke() です。 Invoke() は、特定のデリ ゲート インスタンスにアタッチされているすべてのメソッドを呼び出します。 前に説明したように、通常はデリゲート変数に対するメ ソッド呼び出し構文を使用して、デリゲートを呼び出します。 このシリーズの後半で説明するように、これらのメソッドを直接操作 するパターンは複数あります。
デリゲートをサポートしている言語構文とクラスの説明は以上です。次に、厳密に型指定されたデリゲートの使用、作成、呼び 出しの方法を確認しましょう。
次へ
            
       [戻る]
前の記事では、 delegate キーワードを使って実際にデリゲート型を作成する方法を見てきました。
抽象型の Delegate クラスは、疎な結合と呼び出しのための基盤となるものです。 一方、具体的な Delegate 型は、デリゲー ト オブジェクトの呼び出しリストに追加されるメソッドのタイプ セーフを促し、また強制的に適用することによって、その利便性を 大きく高めています。 delegate キーワードを使用し、具体的なデリゲート型を定義すると、それらのメソッドがコンパイラによっ て生成されます。
しかし実際にやってみると、異なるメソッド シグネチャが必要になるたびに新しいデリゲート型を作成することになり、 次第にわず らわしくなってくるものです。 新しい機能を追加するたびに、新しいデリゲート型が必要になるからです。
さいわい、その必要はありません。 .NET Core フレームワークには、デリゲート型が必要になったときにいつでも再利用できる型が いくつか用意されています。 それがジェネリック定義です。新しいメソッドの宣言が必要になったときは、カスタマイズしたものを宣 言することができます。
その筆頭となる型が Action 型で、いくつかのバリエーションも存在します。
ジェネリック型引数の in 修飾子については、共変性についての記事で取り上げます。
Action デリゲートには、最大16の引数を含むバリエーションが存在します(例: Action<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>)。 これらの定義では、デリゲート引数のそれぞれに異 なるジェネリック引数が使われているという点が重要です。それによってきわめて高い柔軟性が実現されているからです。 メソッド の一連の引数は、必ずしも同じ型である必要はありませんが、同じ型である場合もあります。
戻り値を持たないデリゲート型には、いずれかの Action 型を使用します。 フレームワークには、戻り値を持つデリゲート型に使用できる汎用デリゲート型もいくつか用意されています。
ジェネリック型引数resultの out 修飾子については、共変性についての記事で取り上げます。
Func デリゲートには、最大16の入力引数を含むバリエーションが存在します(例: Func<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,TResult>)。 慣例上、 Func に宣言されているすべての 型パラメーターの最後に出現する型が常に実行結果の型になります。
値を返すデリゲート型には、いずれかの Func 型を使用します。 また、単一の値に対する判定結果を返すデリゲートに特化された Predicate<T> という型も存在します。
      public delegate void Action();
public delegate void Action<in T>(T arg);
public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);
// Other variations removed for brevity.
       public delegate TResult Func<out TResult>();
public delegate TResult Func<in T1, out TResult>(T1 arg);
public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
// Other variations removed for brevity
  厳密に型指定されたデリゲート
2020/03/18 • • Edit Online
  public delegate bool Predicate<in T>(T obj);
 
 どのような   型でも、構造的に同等な Func 型が存在することにお気付きでしょうか。その例を次に示します。
    Func<string, bool> TestForString;
Predicate<string> AnotherTestForString;
 これら 2 つの型は等価と思うかもしれません。 しかし、そうではありません。 これら 2 つの変数を相互に置き換えて使用すること はできません。 一方の型の変数をもう一方の型に代入することはできないのです。 C# の型システムで使用されるのは、定義さ れている型の名前であって、構造ではありません。
これらのデリゲート型の定義はすべて .NET Core ライブラリに存在します。つまり、デリゲートを必要とする新しい機能を作成す るたびに新たにデリゲート型を定義する必要はないということです。 ほとんどの状況で、皆さんが必要になるデリゲート型はすべ て、これらのジェネリック定義でまかなうことができるはずです。 必要な型パラメーターを指定すれば、それらの型のいずれかをイン スタンス化することができます。 汎用化できるアルゴリズムの場合、これらのデリゲートをジェネリック型として使用することが可能で す。
そうすることで無駄な時間をなくし、デリゲートを使用するうえで新たに作成する必要のある型の数を抑えることができます。 次の記事では、実際にデリゲートを扱うための一般的なパターンをいくつか見ていきます。
次へ
 Predicate
 
   [戻る] デリゲートは、コンポーネント間の結合度を最小限にしたソフトウェア設計を可能にするメカニズムです。
この種の設計の代表的な例が LINQ です。 LINQ のクエリ式パターンは、そのすべての機能がデリゲートによって支えられていま す。 簡単な例を考えてみましょう。
このコードは、一連の数値から値が10未満である数値のみを抽出するものです。 Where メソッドは、デリゲートを使って、どの 要素を抽出するかを判断しています。 LINQ クエリを作成するとき、その具体的な目的に合ったデリゲートの機能は、皆さんが 実装することになります。
Where メソッドのプロトタイプは次のとおりです。
この例は、LINQ のすべてのメソッドに当てはまります。 具体的なクエリを扱うコードには、すべてデリゲートが使われているので す。 きわめて強力な API デザイン パターンなので、しっかり覚えて自分のものにしてください。
この単純な例から、コンポーネント間の結合関係がデリゲートにはほとんど必要ないことがわかります。 特定の基本クラスから派 生したクラスを作成する必要がないのです。 特定のインターフェイスを実装する必要もありません。 唯一の要件は、目的のタス クに必要なメソッドの機能を 1 つ、手の届くところに実装するだけです。
デリゲートを使った独自のコンポーネントを作成する
この例を踏まえて、デリゲートを利用した設計を使ってコンポーネントを作成してみましょう。
たとえば大規模なシステムのログ メッセージに使われるコンポーネントとは、どのようなものでしょうか。 そのライブラリ コンポーネン トは、各種プラットフォーム上のさまざまな環境で使われることが考えられます。 ログを扱うコンポーネントには、共通する機能が 多数存在します。 まず、システム内のコンポーネントからメッセージを受け取らなければなりません。 それらのメッセージには、さま ざまな優先度が割り当てられ、中心となるコンポーネントがそれらの優先度を管理できるようになっていることでしょう。 最終的に アーカイブされるメッセージの形式には、タイムスタンプが記録されている必要があります。 さらに高度な用途としては、ログの発 生元のコンポーネントごとにメッセージをフィルタリングすることも考えられます。
この機能には、不確定要素が 1 つあります。メッセージがどこに出力されるかです。 メッセージがエラー コンソールに出力される か、 ファイルに出力されるかは、環境によってさまざまです。 データベース ストレージや OS のイベント ログのほか、ドキュメント ス トレージに出力される可能性もあります。
また複数の場所に出力して、それぞれ異なる用途に使われるようなケースもあります。 たとえばコンソールとファイルにメッセージ を出力したい場合もあるでしょう。
デリゲートを使った設計なら運用の幅が大きく広がり、将来追加される可能性のあるストレージ メカニズムへの対応が容易にな ります。
この設計の下では、主要なログ コンポーネントが必ずしも仮想クラスである必要はなく、シール クラスであってもかまいません。 一連のデリゲートを組み込めば、さまざまなストレージ メディアにメッセージを書き込むことができます。 マルチキャスト デリゲートが ネイティブでサポートされているため、メッセージを複数の場所 (ファイルとコンソールなど) に出力する必要のある状況にも簡単に
  var smallNumbers = numbers.Where(n => n < 10);
     public static IEnumerable<TSource> Where<TSource> (this IEnumerable<TSource> source, Func<TSource, bool>
predicate);
 デリゲートの一般的なパターン
2020/11/02 • • Edit Online
 
 対応することができます。
初めての実装 最初は簡単な機能を実装してみましょう。新しいメッセージを受け取ったら、アタッチされたデリゲートを使ってそれらを出力する
ものです。 まず、コンソールにメッセージを出力するデリゲートを 1 つ作成します。
    public static class Logger
{
    public static Action<string> WriteMessage;
    public static void LogMessage(string msg)
    {
        WriteMessage(msg);
    }
}
 上の静的クラスは、ごく簡単なコードですが、きちんと機能します。 メッセージをコンソールに出力するメソッドの機能を 1 つ実装 する必要があります。
最後にそのメソッドを、Logger に宣言されている WriteMessage デリゲートにアタッチして接続する必要があります。
実践
紹介したサンプルはごく簡単なものですが、デリゲートを伴う設計についての重要な指針がいくつか示されています。
ユーザーは、Core Framework に定義されているデリゲート型を使うことで、さらに簡単にデリゲートを扱うことができます。 皆さ んが新しい型を定義する必要はなく、皆さんのライブラリを利用する開発者も、特別な目的を持ったデリゲート型を新たに覚え る必要がありません。
使用されているインターフェイスはごくわずかでありながら、最大限の柔軟性が得られるようになっています。つまり新しい出力ロ ガーを作成するために皆さんがすべきことは、メソッドを 1 つ作成することです。 そのメソッドは静的メソッドでも、インスタンス メ ソッドでもかまいません。 またアクセス指定も任意です。
出力の書式設定
最初のコード例にもう少し肉付けしてみましょう。その後、別のログ メカニズムの作成に進みます。 まず、より構造化されたメッセージを作成するために、いくつかの引数を LogMessage() メソッドに追加します。
    public static class LoggingMethods
{
    public static void LogToConsole(string message)
    {
        Console.Error.WriteLine(message);
    }
}
   Logger.WriteMessage += LoggingMethods.LogToConsole;
  
      public static class Logger
{
    public static Action<string> WriteMessage;
    public static void LogMessage(Severity s, string component, string msg)
    {
        var outputMsg = $"{DateTime.Now}\t{s}\t{component}\t{msg}";
        WriteMessage(outputMsg);
    }
}
  次に、その Severity 引数を利用して、ログ出力に送るメッセージをフィルター選択します。
    public static class Logger
{
    public static Action<string> WriteMessage;
    public static Severity LogLevel {get;set;} = Severity.Warning;
    public static void LogMessage(Severity s, string component, string msg)
    {
        if (s < LogLevel)
            return;
        var outputMsg = $"{DateTime.Now}\t{s}\t{component}\t{msg}";
        WriteMessage(outputMsg);
    }
}
 実践
ログのインフラストラクチャに新しい機能を追加しました。 このロガー コンポーネントは、出力メカニズムとの結び付きがきわめて弱 いので、このように新しい機能を追加しても、ロガーのデリゲートを実装する側のコードには一切影響が生じません。
他の部分には変更を加えずに一部分だけをアップデートできるという点に関しては、このプログラム コードを記述していく過程 で、結び付きの弱さによって運用の幅が広がる例が他にもたくさん見つかることでしょう。 実際、大規模なアプリケーションになる と、ロガー出力クラスを別のアセンブリに置き、リビルドすら必要ないケースもあります。
2 つ目の出力エンジンの作成
1 つ目のログ コンポーネントがうまく作成できました。 次は、メッセージをファイルに記録する出力エンジンを追加してみましょう。 この出力エンジンは、先ほどよりも少し複雑になります。 このクラスにはファイル操作がカプセル化され、毎回出力後に必ずファイ ルが閉じられます。 これによって、メッセージが生成されるたびにすべてのデータが確実にディスクにフラッシュされます。
このファイル ベースのロガーを次に示します。
   public enum Severity
{
    Verbose,
    Trace,
    Information,
    Warning,
    Error,
    Critical
}
 
  このクラスを作成した後、インスタンス化すれば、その LogMessage メソッドを Logger コンポーネントにアタッチすることができま す。
この 2 つは、どちらか一方しか使えないというわけではありません。 両方のログ メソッドをアタッチすれば、コンソールとファイルに メッセージを生成することができます。
後で同じアプリケーションで、片方のデリゲートを削除しても、システムに問題が生じることはありません。
実践
ログ サブシステム用に 2 つ目の出力ハンドラーを追加しました。 こちらは、ファイル システムを正しくサポートするために、もう少し インフラストラクチャを整える必要があります。 デリゲートはインスタンス メソッドです。 プライベート メソッドでもあります。 それより 広いアクセス指定は必要ありません。なぜならデリゲートの接続は、デリゲート インフラストラクチャが行ってくれるためです。
また、デリゲート ベースの設計では、新たにコードを書かなくても複数の出力メソッドを利用することができます。 複数の出力メ ソッドをサポートするために、別途インフラストラクチャを作成する必要はありません。 何もしなくても、呼び出しリストの中では、 それらが別々のメソッドになるのです。
  var file = new FileLogger("log.txt");
     var fileOutput = new FileLogger("log.txt");
Logger.WriteMessage += LoggingMethods.LogToConsole; // LoggingMethods is the static class we utilized
earlier
   Logger.WriteMessage -= LoggingMethods.LogToConsole;
    public class FileLogger
{
    private readonly string logPath;
    public FileLogger(string path)
    {
        logPath = path;
        Logger.WriteMessage += LogMessage;
    }
    public void DetachLog() => Logger.WriteMessage -= LogMessage;
    // make sure this can't throw.
    private void LogMessage(string msg)
    {
try {
        }
        catch (Exception)
        {
} }
}
using (var log = File.AppendText(logPath))
{
    log.WriteLine(msg);
    log.Flush();
}
// Hmm. We caught an exception while
// logging. We can't really log the
// problem (since it's the log that's failing).
// So, while normally, catching an exception
// and doing nothing isn't wise, it's really the
// only reasonable option here.
 
 ファイル ロガーの出力メソッドのコードに注目してください。 決して例外がスローされないようにコーディングされています。 厳密に は常に必要というわけではありませんが、通常はこのようにすることをお勧めします。 いずれかのデリゲート メソッドから例外がス ローされた場合に、呼び出しリストに残っている他のデリゲートが呼び出されなくなってしまいます。
最後の注意点として、ファイル ロガーは、ログ メッセージごとにファイルを開閉することによって、そのリソースを自己管理する必要 があります。 または、ファイルを開いたままにすることも可能です。つまり IDisposable を実装し、完了した時点でファイルを閉じ るようにするのです。 どちらの方法にも長所と短所があります。 また、どちらの方法も、クラス間の結合度がわずかに増します。
しかし、どちらのシナリオをサポートするにしても、Logger クラスのコードには一切手を加える必要がありません。 Null デリゲートの処理
最後に、出力メカニズムが選択されなかったケースに備えて、LogMessage メソッドに変更を加えたいと思います。 現在の実 装コードでは、 WriteMessage デリゲートに呼び出しリストがアタッチされなかった場合、 NullReferenceException がスローされ ます。 メソッドがアタッチされていなくても、何事もなかったように処理が継続されるような設計の方が望ましい場合もあります。 これは、Delegate.Invoke() メソッドにnull条件演算子を組み合わせて使えば簡単に実現できます。
null条件演算子(?.)は、左辺オペランド(このケースでは WriteMessage)がnullのとき、そこで評価が打ち切られます。つ まり、メッセージを記録する処理は試行されません。
System.Delegate や System.MulticastDelegate のドキュメントを探しても、 Invoke() メソッドは記載されていません。 宣 言されているデリゲート型には、コンパイラによってタイプセーフな Invoke メソッドが生成されます。つまり、この例では、
Invoke が string 引数を1つ持ち、戻り値の型がvoidであるということです。 実践のまとめ
ログ コンポーネントの基本的概念を見てきました。この概念は、その他の出力機構や各種機能に応用することができます。 デ リゲートを使った設計では、そうしたコンポーネント間の結びつきを疎に保つことができるのです。 これにはさまざまな利点がありま す。 まず、ごくわずかな手間で、新しい出力メカニズムを作成してシステムにアタッチすることができます。 新たに追加するメカニ ズムで必要となるのは、1 つのメソッドだけです。ログ メッセージを出力するメソッドです。 これは、新しい機能を追加するときに 問題がきわめて起きにくい設計といえます。 どのような出力機構を追加するにせよ、求められるコントラクトはメソッドを 1 つ実 装する、ということです。 それは静的メソッドでもインスタンス メソッドでもかまいません。 アクセスできる範囲も、public や private を含め、正当なアクセス指定であれば何でもかまいません。
Logger クラスには、これまでの動作を大きく変えることなく何度でも、その機能を強化したり変更を加えたりすることができます。 あらゆるクラスに言えることですが、パブリック API の変更には、互換性に影響する変更のリスクが伴います。 しかし、ロガーと出 力エンジンとの結合はデリゲートを介してのみ行われるので、他の型 (インターフェイス、基本クラスなど) が関係してくることはあり ません。 その結合度は最小限で済むのです。
次へ
       public static void LogMessage(string msg)
{
    WriteMessage?.Invoke(msg);
}
        
   [戻る]
デリゲートのようなイベントは遅延バインディング メカニズムになっています。 実際、イベントはデリゲートの言語サポートに基づい
て構築されます。
イベントは、何かが起こったことをオブジェクトが (システム内のあらゆる関連コンポーネントに) ブロードキャストする方法です。 他 のコンポーネントはイベントを受信登録できます。イベントが発生すると通知されます。
プログラミングにイベントを利用した経験があることでしょう。 グラフィカル システムの多くには、ユーザー操作を報告するイベント モデルがあります。 そのようなイベントは、マウスが動いた、ボタンが押されたなどの動作を報告します。 それは最も一般的なイ ベントの 1 つですが、イベントが利用されるシナリオはこれだけではありません。
クラスに対して発生させるイベントを定義できます。 イベントを使用するときに考慮するべき重要なことは、特定のイベントに登 録されていないオブジェクトの可能性です。 リスナーが構成されていないときはイベントを発生させないようにコードを記述する必 要があります。
イベントを受信登録すると、2 つのオブジェクト (イベント ソースとイベント シンク) の間に結合も生成されます。 イベント シンクに イベントに対する関心がなくなったとき、イベント ソースの受信登録を解除する必要があります。
イベント サポートのデザイン目標 イベントの言語デザインには次のような目標があります。
イベント ソースとイベント シンクの間で最小限の結合を有効にすること。 これら 2 つのコンポーネントは、別々の組織に 記述されることがあります。まったく異なる日程で更新されることもあります。
イベントの受信登録と、同じイベントの登録解除を非常にシンプルにすること。
イベント ソースで複数のイベント サブスクライバーに対応すること。 イベント サブスクライバーをアタッチしないことにも対応 する必要があります。
イベントの目標はデリゲートの目標とよく似ています。 そのような理由から、イベント言語サポートはデリゲート言語サポートに基 づいて構築されます。
イベントの言語サポート イベントの定義、受信登録、登録解除の構文は、デリゲートの構文の拡張になります。 イベントを定義するには、 event キーワードを使用します。
イベントの種類(この例の EventHandler<FileListArgs>)はデリゲート型にする必要があります。イベントを宣言するときはさ まざまな決まりごとを守る必要があります。 通常、イベント デリゲート型には戻り値 void があります。 イベント宣言は動詞また は動詞句にする必要があります。 何かが起こったことをイベントで報告するときは、過去時制を使用します。 何かが起こりそう なことを報告するには、現在時制の動詞 (たとえば、 Closing ) を使用します。 多くの場合、現在時制の使用は、お使いのク ラスで何らかのカスタマイズ動作をサポートしていることを示します。 最も一般的なシナリオの 1 つがキャンセルのサポートです。 たとえば、Closing イベントには、close操作を続行するかどうかを示す引数が含まれることがあります。イベント引数のプロパ ティを更新することで呼び出し元が動作を変更するシナリオもあります。 アルゴリズムに実行させる次のアクションを提案するイベ ントを発生させることもできます。 イベント ハンドラーは、イベント引数のプロパティを変更することで、別のアクションを命令するこ
  public event EventHandler<FileListArgs> Progress;
    イベントの概要
2020/11/02 • • Edit Online
 
  ともあります。
イベントが発生させるとき、デリゲート呼び出し構文を利用してイベント ハンドラーを呼び出します。
デリゲートに関するセクションで説明したように、 ?. 演算子を利用すると、イベントのサブスクライバーが存在しないとき、そのイベ ントの発生を試行しないように容易に確保できます。
+= 演算子を利用し、イベントを受信登録します。
上に示すように、一般的にハンドラー メソッドはプレフィックス 'On' の後にイベント名を続けたものになります。 -= 演算子を利用して受信登録を解除します。
イベント ハンドラーを表す式にローカル変数が宣言することが重要です。 これで受信登録解除によりハンドラーが削除されま す。 代わりにラムダ式の本文を使用した場合、アタッチされたことがないハンドラーの削除が試行され、何も起こりません。
次回の記事では、一般的なイベント パターンと今回のサンプルのさまざまなバリエーションについて学習します。
次へ
  Progress?.Invoke(this, new FileListArgs(file));
     EventHandler<FileListArgs> onProgress = (sender, eventArgs) =>
    Console.WriteLine(eventArgs.FoundFile);
fileLister.Progress += onProgress;
   fileLister.Progress -= onProgress;
 
    前へ
一般的に、.NET イベントはいくつかの既知のパターンに従います。 これらのパターンを標準化すれば、開発者はこうした標準的 なパターンの知識を活用し、あらゆる .NET イベント プログラムに適用することができます。
これらの標準的なパターンを理解することにより、標準的なイベント ソースを作成し、標準的なイベントをコードでサブスクライブ し処理するために必要な知識を習得してください。
イベント デリゲートのシグネチャ
.NET イベント デリゲートの標準的なシグネチャは、次のとおりです。
戻り値の型は void です。 イベントは、デリゲートを基本とするマルチキャスト デリゲートです。 このため、任意のイベント ソースに 対して複数のサブスクライバーをサポートします。 メソッドが返す単一の戻り値が複数のイベント サブスクライバーに拡張されるこ とはありません。 イベント発生後にイベントソースはどの戻り値を受け取るのでしょうか。 この記事の後半で、イベント サブスクラ イバーをサポートするイベント プロトコルの作成方法を説明します。イベント サブスクライバーはイベント ソースに情報をレポート します。
引数リストには、2つの引数、すなわち送信元とイベント引数が含まれます。 のコンパイル時型は System.Object で す。常に正しいより確実な派生型が存在する可能性はありますが、 慣例に従って、 を使用します。
2番目の引数は、通常は System.EventArgs から派生した型です。(次のセクションで、この規則が適用されなくなっているこ とを説明します。)イベント型に引数を追加する必要がない場合でも、両方の引数を使用します。 特殊な値である
EventArgs.Empty は、イベントにその他の情報が含まれていないことを示すために使用します。 これから、パターンに従うディレクトリ、またはそのサブディレクトリのいずれかでファイルを一覧表示するクラスをビルドしていきます。
このコンポーネントでは、パターンに一致することが確認されたファイルごとにイベントを発生させます。
イベント モデルを使用すると、設計上の利点が得られます。 要求されたファイルを検出すると、異なるアクションを実行する複数 のイベント リスナーを作成できます。 別のリスナーと組み合わせることで、より堅牢なアルゴリズムを作成できます。
次に示すのは、要求されたファイルを検索するイベント引数を最初に宣言する部分です。
  void OnEventRaised(object sender, EventArgs args);
   sender
 object
      public class FileFoundArgs : EventArgs
{
    public string FoundFile { get; }
    public FileFoundArgs(string fileName)
    {
        FoundFile = fileName;
    }
}
 この型はデータのみの小さな型のように見えますが、規則に従って、参照 ( class ) 型にする必要があります。 つまり、引数オブ ジェクトは参照によって渡され、データが更新されると、すべてのサブスクライバーから参照されます。 最初のバージョンは、変更 不可のオブジェクトです。 イベント引数の型のプロパティを変更不可に設定しておいた方がよいでしょう。 このようにすれば、別 のサブスクライバーが値を確認する前に、いずれかのサブスクライバーが値を変更することがありません。 (下記に説明するとお り、これには例外があります。)
標準的な .NET イベント パターン 2020/03/18 • • Edit Online
 
  次に、FileSearcher クラスでイベント宣言を作成する必要があります。 型を活用すれば、もう 1 つ別の型 を定義する必要はありません。 ジェネリックの特殊化を使用するだけで済みます。
パターンに一致するファイルを検索し、一致が検出されると、適切なイベントを発生する FileSearcher クラスを記述します。
    public class FileSearcher
{
    public event EventHandler<FileFoundArgs> FileFound;
    public void Search(string directory, string searchPattern)
    {
} }
foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
{
    FileFound?.Invoke(this, new FileFoundArgs(file));
}
 フィールドのように使用するイベントの定義と発生 クラスにイベントを追加する最も簡単な方法は、上記の例のように、そのイベントをパブリック フィールドとして宣言することです。
これはパブリック フィールドを宣言しているように見えるため、不適切なオブジェクト指向プラクティスと考えられるかもしれません。 プロパティ、またはメソッドでデータ アクセスを保護したくなるところです。 これは一見すると不適切なプラクティスのように見えるか もしれませんが、安全な方法でしかイベント オブジェクトにアクセスできないように、コンパイラによって生成されたコードでは、ラッ パーを作成します。 フィールドのように使用するイベントで使用できる唯一の操作は、ハンドラーの追加です。
それと、ハンドラーの削除です。
このハンドラーにはローカル変数があります。 ラムダの本体を使用する場合、削除は正しく動作しません。 ラムダ本体はデリゲー トの別のインスタンスであるため、自動的に何か実行することはありません。
クラスの外側にあるコードはイベントを発生させることも、その他の操作を実行することもできません。
イベント サブスクライバーからの戻り値 この単純なバージョンは正常に動作しています。 別の機能を追加してみましょう。キャンセル機能です。
検出されたイベントを発生させるとき、このファイルが要求された最後のファイルである場合、リスナーはその後の処理を停止する 必要があります。
イベント ハンドラーは値は返さないため、別の方法で値を伝達する必要があります。 標準的なイベント パターンでは、イベント サブスクライバーがキャンセルを伝達するために使用するフィールドを含めるために、EventArgs オブジェクトを使用します。
  public event EventHandler<FileFoundArgs> FileFound;
     EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>
{
    Console.WriteLine(eventArgs.FoundFile);
    filesFound++;
};
fileLister.FileFound += onFileFound;
   fileLister.FileFound -= onFileFound;
  EventHandler<T>
 
 使用できるパターンには 2 種類あり、それらは Cancel コントラクトのセマンティクスに基づいています。 どちらの場合も、検出さ れたファイル イベントの EventArguments にブール型フィールドを追加します。
1つのパターンでは、任意のサブスクライバーが単独で操作をキャンセルできます。このパターンでは、新しいフィールドは false に初期化されます。どのサブスクライバーでもこのフィールドを true に変更できます。すべてのサブスクライバーがイベントの発 生を確認すると、FileSearcher コンポーネントがブール値を検証し、アクションを実行します。
2 つ目のパターンでは、すべてのサブスクライバーが操作のキャンセルを認める場合に限り、操作がキャンセルされます。 このパ ターンでは、新しいフィールドは操作のキャンセルを示すように初期化され、任意のサブスクライバーが操作を続行するように変 更できます。 すべてのサブスクライバーがイベントの発生を確認すると、FileSearcher コンポーネントがブール値を検証し、アク ションを実行します。 このパターンには、手順がもう 1 つあり、コンポーネントは、いずれかのサブスクライバーがイベントを確認し たか把握する必要があります。 サブスクライバーが存在しない場合、フィールドが示すキャンセルは誤りとなります。
次に、このサンプルの最初のバージョンを実装します。 FileFoundArgs 型に CancelRequested という名前のブール型フィール ドを追加する必要があります。
      public class FileFoundArgs : EventArgs
{
    public string FoundFile { get; }
    public bool CancelRequested { get; set;}
    public FileFoundArgs(string fileName)
    {
        FoundFile = fileName;
    }
}
 誤ってキャンセルすることがないように、この新しいフィールドは false (ブール型フィールドの既定値)に自動的に初期化されま す。 コンポーネントのもう 1 つの変更点は、イベントが発生したあと、フラグをチェックして、いずれかのサブスクライバーがキャンセ ルを要求しているか確認することです。
    public void List(string directory, string searchPattern)
{
    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
    {
        var args = new FileFoundArgs(file);
        FileFound?.Invoke(this, args);
        if (args.CancelRequested)
break; }
}
 このパターンの利点の 1 つは、この変更が重大な変更ではないことです。 いずれのサブスクライバーも前にキャンセルを要求して いなければ、引き続き同じ状態が維持されます。 サブスクライバーが新しいキャンセル プロトコルをサポートしない限り、どのサブ スクライバーのコードも更新する必要がありません。 非常にゆるやかな結合となっています。
次に、最初の実行可能ファイルが検索されると、キャンセルを要求するように、サブスクライバーを更新します。
別のイベント宣言の追加
ここで、1 つの機能を追加し、イベント用の他の慣用句について説明します。 すべてのサブディレクトリを走査してファイルを検
    EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>
{
    Console.WriteLine(eventArgs.FoundFile);
    eventArgs.CancelRequested = true;
};
 
  索する   メソッドのオーバーロードを追加します。
多くのサブディレクトリを持つディレクトリでは、これは時間のかかる操作となる場合があります。 次に、新しいディレクトリの検索が 開始するたびに発生するイベントを追加します。 このイベントによって、サブスクライバーは進行状況を追跡し、進行状況の更 新をユーザーに伝えます。 これまでに作成したすべてのサンプルは、パブリックです。 このイベントを内部イベントにします。 つま り、引数に使用される型を内部型にすることもできるということです。
最初に、新しいディレクトリと進行状況をレポートする新しい EventArgs 派生クラスを作成します。
    internal class SearchDirectoryArgs : EventArgs
{
    internal string CurrentSearchDirectory { get; }
    internal int TotalDirs { get; }
    internal int CompletedDirs { get; }
    internal SearchDirectoryArgs(string dir, int totalDirs, int completedDirs)
    {
} }
CurrentSearchDirectory = dir;
TotalDirs = totalDirs;
CompletedDirs = completedDirs;
 ここでも、イベント引数に変更不可の参照型を使用することをお勧めします。
次に、イベントを定義します。 今回は、別の構文を使用します。 フィールドの構文を使用する以外に、明示的にプロパティを 作成し、ハンドラーを追加、削除することができます。 このサンプルでは、ハンドラーにコードを追加する必要はありませんが、次 に示したのはそれを作成する方法です。
ここで作成するコードは、多くの点で、コンパイラがフィールドのイベントを定義するために作成した先ほどのコードとよく似ていま す。 イベントを作成するときに、プロパティで使用する構文と非常によく似た構文を使用します。 このハンドラーには、 add およ び remove という別の名前があることに注意してください。 これらはイベントをサブスクライブするか、またはイベントのサブスクリプ ションを解除するために呼び出されます。 また、イベント変数を格納するために、プライベートなバッキング フィールドを宣言する 必要があることにも注意してください。 このフィールドは null に初期化されます。
次に、サブディレクトリを走査して両方のイベントを発生させる Search メソッドのオーバーロードを追加します。これを実現す る最も簡単な方法は、既定の引数を使用して、すべてのディレクトリの検索を指定することです。
    internal event EventHandler<SearchDirectoryArgs> DirectoryChanged
{
    add { directoryChanged += value; }
    remove { directoryChanged -= value; }
}
private EventHandler<SearchDirectoryArgs> directoryChanged;
    Search
 
  この時点で、アプリケーションを実行し、すべてのサブディレクトリを検索するオーバーロードを呼び出すことができます。 新しい ChangeDirectory イベントでは、サブスクライバーが存在しませんが、 ?.Invoke() 慣用句を使用すれば、正常に動作させる
ことができます。
ここで、コンソール ウィンドウに進行状況を表示する行を記述するハンドラーを追加します。
このトピックでは、.NET エコシステム全体で使用されるパターンを確認しました。 これらのパターンと規則を学習することにより、 慣用句を使用した C# および .NET をすばやく記述できるようになります。
次の項目では、.NET の最新のリリースで変更されたパターンを確認してください。 次へ
      fileLister.DirectoryChanged += (sender, eventArgs) =>
{
    Console.Write($"Entering '{eventArgs.CurrentSearchDirectory}'.");
    Console.WriteLine($" {eventArgs.CompletedDirs} of {eventArgs.TotalDirs} completed...");
};
    public void Search(string directory, string searchPattern, bool searchSubDirs = false)
{
    if (searchSubDirs)
    {
        var allDirectories = Directory.GetDirectories(directory, "*.*", SearchOption.AllDirectories);
        var completedDirs = 0;
        var totalDirs = allDirectories.Length + 1;
        foreach (var dir in allDirectories)
        {
            directoryChanged?.Invoke(this,
                new SearchDirectoryArgs(dir, totalDirs, completedDirs++));
            // Search 'dir' and its subdirectories for files that match the search pattern:
            SearchDirectory(dir, searchPattern);
        }
        // Include the Current Directory:
        directoryChanged?.Invoke(this,
            new SearchDirectoryArgs(directory, totalDirs, completedDirs++));
        SearchDirectory(directory, searchPattern);
} else {
        SearchDirectory(directory, searchPattern);
    }
}
private void SearchDirectory(string directory, string searchPattern)
{
    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
    {
        var args = new FileFoundArgs(file);
        FileFound?.Invoke(this, args);
        if (args.CancelRequested)
break; }
}
 
    前へ
前回の記事では、最も一般的なイベント パターンについて説明しました。 .NET Core には、もっと柔軟なパターンがあります。 このバージョンでは、 EventHandler<TEventArgs> 定義に、 TEventArgs は System.EventArgs から派生したクラスでなけれ ばならないという制約がなくなりました。
これにより、柔軟性が向上し、旧バージョンとの互換性が与えられます。 柔軟性から始めましょう。 クラス System.EventArgs で というメソッドが導入されました。これはオブジェクトの簡易コピーを作成するメソッドです。 そのメソッドで は、 から派生したあらゆるクラスのための機能を実装する目的で、リフレクションを利用する必要があります。 その機 能では、特定の派生クラスでの作成が簡単になります。 つまり、System.EventArgs からの派生は設計を制限する制約です が、他に利点はありません。 実際、 EventArgs から派生しないように FileFoundArgs と SearchDirectoryArgs の定義を変 更できます。 このプログラムはまったく同じように機能します。
さらに1つ変更するのであれば、SearchDirectoryArgs を構造体に変更することもできます。
    MemberwiseClone()
 EventArgs
        internal struct SearchDirectoryArgs
{
    internal string CurrentSearchDirectory { get; }
    internal int TotalDirs { get; }
    internal int CompletedDirs { get; }
    internal SearchDirectoryArgs(string dir, int totalDirs, int completedDirs) : this()
    {
} }
CurrentSearchDirectory = dir;
TotalDirs = totalDirs;
CompletedDirs = completedDirs;
 追加の変更は、すべてのフィールドを初期化するコンストラクターに入る前にパラメータ―なしのコンストラクターを呼び出すことで す。 その追加がなければ、C# のルールは、割り当てられる前にプロパティがアクセスされていると報告するでしょう。
FileFoundArgs はクラス(参照型)から構造体(値型)に変更しないでください。キャンセルを処理するプロトコルで、イベント 引数が参照で渡されることが要求されるためです。 同じ変更をした場合、ファイル検索クラスは、イベント サブスクライバーが 行った変更を観察できなくなる可能性があります。 サブスクライバーごとに構造体の新しいコピーが使用され、そのコピーは、ファ イル検索オブジェクトで確認されるものとは別のコピーになるでしょう。
次に、この変更を下位互換可能にする方法について考えましょう。 制約を削除しても、既存のコードには影響を与えません。 既存のイベントの引数の型は引き続き System.EventArgs から派生します。 System.EventArgs から引き続き派生する理 由の 1 つが下位互換性です。 既存のイベント サブスクライバーは、従来のパターンに従ったイベントのサブスクライバーになりま す。
同様の論理に従うと、今、イベントの引数の型を作成すると、それには既存のコードベースのサブスクライバーが与えられないで しょう。 System.EventArgs から派生しない新しいイベントの型は、そのようなコードベースを壊しません。
非同期サブスクライバーのあるイベント
学習する最後のパターンは、非同期コードを呼び出すイベント サブスクライバーを正しく記述する方法です。 この難題の説明 は、async と await に関する記事にあります。 非同期メソッドには戻り値の型 void を指定できますが、指定しないことが推奨 されます。 イベント サブスクライバーのコードが非同期メソッドを呼び出すとき、 async void メソッドを作成する以外の選択肢
     更新された .NET Core イベント パターン 2020/03/18 • • Edit Online
 
 はありません。 イベント ハンドラー シグネチャでそれが要求されます。
 このような相反する指示と何とか折り合いを付け、 無難な async void メソッドを作成する必要があります。 実装が必要なパ ターンの基本は次のようになります。
    worker.StartWorking += async (sender, eventArgs) =>
{
try {
        await DoWorkAsync();
    }
    catch (Exception e)
    {
} };
//Some form of logging.
Console.WriteLine($"Async task failure: {e.ToString()}");
// Consider gracefully, and quickly exiting.
 最初に、ハンドラーが非同期ハンドラーとしてマークされていることに注目してください。 イベント ハンドラーのデリゲート型に割り 当てられているため、戻り値の型 void が与えられます。 つまり、ハンドラーに示されるパターンに従う必要があります。非同期ハ ンドラーのコンテキストから例外をスローすることを許可しません。 タスクを返さないため、エラーが発生してもタスクはそれを報告 できません。メソッドは非同期であるため、例外をスローできません。(呼び出しメソッドは async であるため、実行を続行して います。)実際の実行時動作は、環境が異なれば各様に定義されます。 スレッドまたはスレッドを所有するプロセスを終了させ たり、またはプロセスを中間状態のままにする場合があります。 これらの潜在的な結果はすべて、非常に望ましくありません。
そのため、独自の try ブロックに非同期タスクの await ステートメントをラップする必要があります。 それでタスクにエラーが発生し た場合、エラーをログに記録できます。 アプリケーションがエラーから復旧できない場合、プログラムを至急、正常に終了できま す。
以上が .NET イベント パターンの主要な更新でした。 使用するライブラリには以前のバージョンのサンプルがたくさんあります。 し かしながら、最新のパターンも理解してください。
このシリーズの次の記事では、設計における delegates と events の使い分けについて説明します。概念は似ており、最良 のプログラムを作るための知識をその記事で得ることができます。
次へ
  
   前へ
.NETCoreプラットフォームを初めて利用する開発者は、 delegates に基づく設計と events に基づく設計のどちらにするか 迷うことがあります。 デリゲートまたはイベントの選択は難しいことがよくあります。この 2 つの言語機能は非常に似ているためで す。 さらに言えば、イベントはデリゲートの言語サポートを利用して構築されています。
いずれも遅延バインディングのシナリオを提供します。実行時にのみ認識されるメソッドを呼び出すことでコンポーネントが通信す るシナリオが可能になります。 いずれもシングルとマルチのサブスクライバー メソッドに対応しています。 これはシングルキャストま たはマルチキャスト サポートと呼ばれることがあります。 いずれも、ハンドラーの追加と削除に同じような構文を利用しています。 最後になりますが、イベントを発生させ、デリゲートを呼び出すとき、まったく同じメソッド呼び出し構文が使用されます。 いずれ も、 ?. 演算子で使用する同じ Invoke() メソッド構文をサポートしています。
このような類似点があるため、どちらを使用するか決定することは簡単ではありません。
イベントの待機は任意です
使用する言語機能を決定するときに考慮するべき最も重要なことは、サブスクライバーをアタッチする必要があるのかどうかで す。 サブスクライバーが提供するコードをコードで呼び出す必要がある場合、コールバックを実装する必要があるとき、デリゲート に基づくデザインを使用してください。 サブスクライバーを呼び出さなくてもすべての作業をコードで完了できる場合、イベントに 基づくデザインを使用してください。
このセクションで作成されたサンプルを考察してください。 List.Sort() を利用して作成したコードには、要素を適切に並べ替 える目的で、比較関数を与える必要があります。 LINQ クエリには、返す要素を決定する目的で、デリゲートを指定する必要 があります。 いずれもデリゲートで作成したデザインを使用しています。
イベントを考察してください。 これはタスクの進行状況を報告します。 リスナーの有無に関係なく、このタスクは続行 します。 は別の例です。 イベント サブスクライバーがアタッチされていませんが、要求されたすべてのファイルを検 索します。 サブスクライバーがイベントを待ち受けていなくても、UX コントロールは正しく動作します。 いずれもイベントに基づく デザインを使用しています。
戻り値でデリゲートが必要になる
別の考慮事項として、デリゲート メソッドのために必要なメソッド プロトタイプがあります。 ご覧のとおり、イベントに使用されるデ リゲートにはすべて戻り値の型 void が与えられます。 また、イベント引数オブジェクトのプロパティを変更することでイベント ソー スに情報を戻すイベント ハンドラーを作成する表現形式があります。 そのような表現形式は実際に機能しますが、メソッドから 値を返すことと同じように自然ではありません。
この 2 つのヒューリスティックは両方とも存在する可能性があります。デリゲート メソッドが値を返す場合は、何らかの形でアルゴリ ズムに影響を与える可能性があります。
イベントにプライベート呼び出しがある
イベントが含まれているもの以外のクラスは、イベント リスナーの追加と削除のみを実行できます。イベントを呼び出すことができ るのは、イベントを含むクラスだけです。 イベントは、一般にパブリック クラスのメンバーです。 これに対して、デリゲートが格納され るのであれば、これはパラメーターとして渡され、プライベート クラスのメンバーとして格納されることが多いです。
イベント リスナーの有効期間が頻繁に長くなる
イベント リスナーの有効期間が長くなることは、少々弱い根拠です。 しかしながら、イベント ソースが長期間にわたりイベントを
     Progress
 FileSearcher
デリゲートとイベントの識別
2020/11/02 • • Edit Online
 
 発生させるとき、イベント基準の設計の方が自然であることがあります。 UX コントロールのイベント基準の設計の例は、多くのシ ステムで確認できます。 イベントを受信登録すると、イベント ソースはプログラムの有効期間にわたりイベントを発生させることが あります。 (不要になったらイベントの受信登録を解除できます。)
さまざまなデリゲート基準デザインと比較してみてください。デリゲート基準デザインの場合、デリゲートはメソッドの引数として使 用され、そのメソッドが戻った後、デリゲートは使用されません。
慎重に評価する
以上の考慮事項は絶対厳守の決まりではありません。 代わりに、特定の用途に最適な選択肢はどれかを決定する際の指南 になります。 どちらも似ているため、両方を試作し、どちらが自然に動作するか検討するという方法もあります。 いずれも遅延 バインディング シナリオを効率的に処理します。 自分の設計を最もよく伝える方を利用してください。

       統合言語クエリ (LINQ) は、C# 言語への直接的なクエリ機能の統合に基づくテクノロジのセットの名前です。 これまでは、デー タに対するクエリは、コンパイル時の型チェックや IntelliSense のサポートがない単純な文字列として表現されてきました。 さら に、SQL データベース、XML ドキュメント、さまざまな Web サービスなど、各種データ ソースの異なるクエリ言語を学習する必 要があります。 LINQ では、クエリは、クラス、メソッド、イベントと同様に、ファースト クラスの言語コンストラクトです。
クエリを記述する開発者にとって、最も目立つ LINQ の "統合言語" 部分は、クエリ式です。 クエリ式は、宣言型の "クエリ構 文" で記述されます。 クエリ構文を使用することで、フィルター処理、並べ替え、グループ化などのデータ ソースに対する操作 を、最小限のコードで実行できます。 同一の基本的なクエリ式のパターンを使用して、SQL データベース、ADO .NET データ セット、XML ドキュメントとストリーム、および .NET コレクション内のデータを照会して変換できます。
次の例は、完全なクエリ操作を示しています。完全な操作には、データソースの作成、クエリ式の定義、および foreach ス テートメントでのクエリの実行が含まれています。
     class LINQQueryExpressions
{
    static void Main()
    {
} }
// Specify the data source.
int[] scores = new int[] { 97, 92, 81, 60 };
// Define the query expression.
IEnumerable<int> scoreQuery =
    from score in scores
    where score > 80
    select score;
// Execute the query.
foreach (int i in scoreQuery)
{
    Console.Write(i + " ");
}
// Output: 97 92 81
 クエリ式の概要
クエリ式を使用して、任意の LINQ 対応データ ソースのデータを照会して変換することができます。 たとえば、1 つのクエ
リで SQL データベースからデータを取得し、出力として XML ストリームを生成できます。 クエリ式は、多くの使い慣れた C# 言語の構成体を使用するため、簡単に習得できます。
クエリ式内の変数はすべて厳密に型指定されますが、多くの場合、型はコンパイラが推測できるため、明示的に指定す る必要はありません。 詳細については、「LINQ クエリ操作での型の関係」を参照してください。
クエリは、たとえば foreach ステートメントでクエリ変数を反復処理するまで実行されません。詳細については、「LINQ クエリの概要」を参照してください。
コンパイル時に、クエリ式は、C# 仕様に規定された規則に従って、標準クエリ演算子メソッドの呼び出しに変換されま す。 クエリ構文を使用して表現できるすべてのクエリは、メソッド構文でも表現することができます。 ただし、ほとんどの場 合、クエリ構文のほうが読みやすく、簡潔です。 詳細については、「# 言語仕様」と「標準クエリ演算子の概要」を参照
 統合言語クエリ (LINQ) 2020/11/02 • • Edit Online
 
             してください。
原則として、LINQ クエリを記述するときは、可能であれば常にクエリ構文を使用し、必要な場合にメソッド構文を使用 することをお勧めします。 この 2 つの異なる形式の間には、セマンティックの違いもパフォーマンスの違いもありません。 多 くの場合、クエリ式のほうが、メソッド構文で記述された同等の式よりも読みやすくなります。
Count や Max など一部のクエリ操作には、同等のクエリ式の句がないため、メソッドの呼び出しとして表す必要がありま す。 メソッド構文は、さまざまな方法でクエリ構文と組み合わせることができます。 詳細については、「LINQ でのクエリ構 文とメソッド構文」を参照してください。
クエリ式は、クエリの適用対象の種類によって、式ツリーまたはデリゲートにコンパイルすることができます。 IEnumerable<T> クエリはデリゲートにコンパイルされます。 IQueryable および IQueryable<T> クエリは式ツリーにコ ンパイルされます。 詳細については、「式ツリー」を参照してください。
次の手順
LINQ の詳細については、最初に「クエリ式の基本」で基本的な概念を理解してから、関心のある LINQ テクノロジのドキュメン トを参照してください。
XML ドキュメント:LINQ to XML
ADO.NET Entity Framework:LINQ to Entities
.NET のコレクション、ファイル、文字列など:LINQ to Objects
LINQ 全般をより深く理解するには、「C# での LINQ」を参照してください。
C# での LINQ の使用を開始するには、「LINQ の使用」チュートリアルを参照してください。

      この記事では、C# でのクエリ式に関連する基本概念について説明します。 クエリとは何か。またどのような働きをするのか
クエリとは、指定したデータ ソース (単一または複数) からどのようなデータを取得し、それらのデータをどのような形式と編成で返 すかを説明した、命令のセットです。 クエリは、それが生成する結果とは区別されます。
一般に、ソース データは、同じ種類の要素のシーケンスとして論理的に編成されます。 たとえば、SQL データベース テーブルに は、行のシーケンスが含まれています。 XML ファイルには、XML 要素のシーケンスがあります (ただし、これらはツリー構造で階 層化されています)。 メモリ内コレクションには、オブジェクトのシーケンスが含まれています。
アプリケーションの観点から言うと、元のソース データの特定の型や構造体はは重要ではありません。 アプリケーションは常に、 ソース データを IEnumerable<T> または IQueryable<T> コレクションとして認識します。 たとえば、LINQ to XML では、ソー スデータは IEnumerable<XElement>として表示されます。
クエリは、このソース シーケンスに対して、次の 3 つのうち、いずれかの操作を行います。
個々 の要素を変更することなく、要素のサブセットを取得して新しいシーケンスを生成する。 クエリはその後、次の例の ように、返されたシーケンスをさまざまな方法で並べ替えたり、グループ化する場合があります(例では scores を
int[] と想定)。
上記の例のように要素のシーケンスを取得するが、それらを新しい型のオブジェクトに変換する。 たとえば、クエリでは、 データ ソース内の特定の顧客レコードから姓だけを取得することがあります。 また、完全なレコードを取得し、それを使 用して別のメモリ内オブジェクト型や XML データを構築した後、最終的な結果シーケンスを生成することもあります。 次の例では、 int から string へのプロジェクションを行っています。 highScoresQuery の新しい型があることに注目 してください。
ソース データに関するシングルトン値を取得します。次に例を示します。 特定の条件に一致する要素の数。 最大値または最小値を持つ要素。
条件に一致する最初の要素や、指定された要素セット内の特定の値の合計。 たとえば、次のクエリは、整数 配列 scores から、80より大きいスコアの数を返します。
      IEnumerable<int> highScoresQuery =
    from score in scores
    where score > 80
    orderby score descending
    select score;
       IEnumerable<string> highScoresQuery2 =
    from score in scores
    where score > 80
    orderby score descending
    select $"The score is {score}";
  クエリ式の基本
2020/03/18 • • Edit Online
 
   上記の例では、 Count メソッドに対する呼び出しの前に、クエリ式を囲むかっこが使用されています。 これは、 具体的な結果を格納する新しい変数を使用しても表現できます。 この手法では、クエリを格納する変数が、 結果を格納するクエリとは別に保持されるので、コードがより読みやすくなります。
上記の例では、 Count に対する呼び出しの前でクエリが実行されています。これは、 highScoresQuery によって返された要素 の数を確認するために、 Count が結果を反復処理する必要があるためです。
クエリ式とは何か
クエリ式とは、クエリ構文で表されたクエリのことです。 クエリ式は、ファーストクラスの言語コンストラクトです。 他の式とよく似てい て、C# 式が有効である任意のコンテキストで使用できます。 クエリ式の構文は、SQL や XQuery などのような宣言型の構文 で記述された、一連の句で構成されます。 各句には 1 つ以上の C# 式が含まれていて、それらの式は、それ自体がクエリ式で ある場合もあれば、クエリ式を含んでいる場合もあります。
クエリ式はfrom句で始まり、selectまたはgroup句で終わる必要があります。最初の from 句と最後の select または group 句の間には、次の省略可能句を1つ以上含めることができます:where、orderby、join、let、および追加のfrom
句。また、intoキーワードを使用して、join 句や group 句の結果を、同じクエリ式内の追加のクエリ句のソースとして使用 することもできます。
クエリ変数
LINQ では、クエリの結果ではなく、クエリを格納する変数を、クエリ変数と呼びます。 より具体的に言うと、クエリ変数は常に列 挙可能な型であり、 foreach ステートメントか、または IEnumerator.MoveNext メソッドに対する直接呼び出しで反復処理さ れた場合に、要素のシーケンスを生成します。
次のコード例は、データ ソース、フィルター句、および並べ替え句がそれぞれ 1 つずつあり、ソース要素の変換がない、簡単なク エリ式を示したものです。 select 句でクエリが終わっています。
    IEnumerable<int> highScoresQuery3 =
    from score in scores
    where score > 80
    select score;
int scoreCount = highScoresQuery3.Count();
         int highScoreCount =
    (from score in scores
     where score > 80
     select score)
     .Count();
 
    上記の例では、 scoreQuery が クエリ変数です。クエリ変数は単にクエリと呼ばれることもあります。 クエリ変数には、 foreach ループで生成された実際の結果データは格納されません。 また、 ステートメントが実行されたとき、クエリ結果はクエリ 変数 を通じては返されません。結果は反復変数 を通じて返されます。 scoreQuery 変数は2 番目の ループで反復処理できます。 この変数とデータ ソースのどちらかが変更されないかぎり、同じ結果が生成され ます。
クエリ変数には、クエリ構文、メソッド構文、またはそれら 2 つの組合せで表現されたクエリが格納される場合があります。 次の 例では、 queryMajorCities と queryMajorCities2 の両方がクエリ変数です。
   scoreQuery
      //Query syntax
IEnumerable<City> queryMajorCities =
    from city in cities
    where city.Population > 100000
    select city;
// Method-based syntax
IEnumerable<City> queryMajorCities2 = cities.Where(c => c.Population > 100000);
 これに対し、次の 2 つの例は、クエリで初期化されてはいるものの、クエリ変数ではない変数を示しています。 これらは結果を 格納するので、クエリ変数ではありません。
foreach
 testScore
 foreach
   static void Main()
{
    // Data source.
    int[] scores = { 90, 71, 82, 93, 75, 82 };
    // Query Expression.
    IEnumerable<int> scoreQuery = //query variable
        from score in scores //required
        where score > 80 // optional
        orderby score descending // optional
        select score; //must end with select or group
    // Execute the query to produce the results
    foreach (int testScore in scoreQuery)
    {
        Console.WriteLine(testScore);
    }
}
// Outputs: 93 90 82 82
 
      クエリのさまざまな表現方法については、「LINQ でのクエリ構文とメソッド構文」をご覧ください。
クエリ変数の明示的型指定と暗黙的型指定 このドキュメントでは通常、明示的な型のクエリ変数で説明を行います。これは、クエリ変数と select 句の関係を示すためで
す。 ただし、 var キーワードを使用すれば、コンパイル時にクエリ変数 (またはその他のローカル変数) の型を推論するようにコン パイラに指示することもできます。 たとえば、このトピックで先に示したクエリの例は、暗黙的な型指定を使用しても表現できま す。
詳しくは、「暗黙的に型指定されるローカル変数」および「LINQ クエリ操作での型の関係」をご覧ください。 クエリ式の開始
クエリ式は、from 句で始める必要があります。この句では、データソースと範囲変数を指定します。範囲変数は、ソース シーケンスが走査されるときの、ソース シーケンス内の連続する各要素を表します。 範囲変数は、データ ソース内の要素の型 に基づいて厳密に型指定されます。 次の例では、 countries が Country オブジェクトの配列であるため、範囲変数も
Country として型指定されています。範囲変数は厳密に型指定されるので、ドット演算子を使用して、その型の利用可能 なメンバーにアクセスすることができます。
    // Use of var is optional here and in all queries.
// queryCities is an IEnumerable<City> just as
// when it is explicitly typed.
var queryCities =
    from city in cities
    where city.Population > 100000
    select city;
        IEnumerable<Country> countryAreaQuery =
    from country in countries
    where country.Area > 500000 //sq km
    select country;
    int highestScore =
    (from score in scores
     select score)
    .Max();
// or split the expression
IEnumerable<int> scoreQuery =
    from score in scores
    select score;
int highScore = scoreQuery.Max();
// the following returns the same result
int highScore = scores.Max();
List<City> largeCitiesList =
    (from country in countries
     from city in country.Cities
     where city.Population > 10000
     select city)
.ToList();
// or split the expression
IEnumerable<City> largeCitiesQuery =
    from country in countries
    from city in country.Cities
    where city.Population > 10000
    select city;
List<City> largeCitiesList2 = largeCitiesQuery.ToList();
 
    範囲変数は、クエリがセミコロンまたは continuation 句で終了するまでスコープ内に維持されます。
クエリ式には、複数の from 句を含めることができます。ソースシーケンス内の各要素がそれ自体コレクションであるか、または コレクションを格納している場合には、追加の from 句を使用します。 たとえば、 Country オブジェクトのコレクションがあり、各 オブジェクトに、 Cities という名前の City オブジェクトのコレクションが格納されているとします。 その場合、各 Country 内 の City オブジェクトを照会するには、次のように2つの from 句を使用します。
詳しくは、「from 句」をご覧ください。 クエリ式の終了
クエリ式は、 group 句または select 句のいずれかで終わる必要があります。
group 句
group 句は、指定したキーによって編成されたグループのシーケンスを生成するために使用します。キーには、任意のデータ型
を指定できます。たとえば、次のクエリでは、1つ以上の Country オブジェクトを含み、キーが char 値であるグループのシーケ ンスが作成されます。
       IEnumerable<City> cityQuery =
    from country in countries
    from city in country.Cities
    where city.Population > 10000
    select city;
       var queryCountryGroups =
    from country in countries
    group country by country.Name[0];
 グループ化について詳しくは、「group 句」をご覧ください。
select 句
select 句は、その他すべての型のシーケンスを生成するために使用します。シンプルな
まれるオブジェクトと同じ型のオブジェクトのシーケンスを生成します。 この例では、データ ソースに れています。 orderby 句は要素を新しい順序に並べ替え、 select 句は並べ替えられた を生成します。
句は、データソース内に含 オブジェクトが含ま
オブジェクトのシーケンス
  select
 Country
   Country
    IEnumerable<Country> sortedQuery =
    from country in countries
    orderby country.Area
    select country;
  select 句は、ソースデータを新しい型のシーケンスに変換するために使用できます。この変換は、プロジェクションとも呼ばれ ます。 次の例では、 select 句は元の要素内にあるフィールドのサブセットのみを含んだ、匿名型のシーケンスをプロジェクトし ます。 新しいオブジェクトはオブジェクト初期化子を使用して初期化されています。
select 句を使用してソースデータを変換する方法について詳しくは、「select句」をご覧ください。
"into" を使用した継続
select 句または group 句で into キーワードを使用すると、クエリを格納する一時的な識別子を作成できます。これは、
grouping 操作や select 操作の後、クエリに対する追加のクエリ操作を実行する必要がある場合に便利です。 次の例では、
     // Here var is required because the query
// produces an anonymous type.
var queryNameAndPop =
    from country in countries
    select new { Name = country.Name, Pop = country.Population };
   
   1 千万という範囲の人口で   をグループ化しています。 これらのグループが作成された後、追加の句で一部のグルー プを除外し、その後、グループを昇順で並べ替えようとしています。 これらの追加操作を実行するには、 countryGroup によっ て継続を表す必要があります。
     // percentileQuery is an IEnumerable<IGrouping<int, Country>>
var percentileQuery =
    from country in countries
    let percentile = (int) country.Population / 10_000_000
    group country by percentile into countryGroup
    where countryGroup.Key >= 20
    orderby countryGroup.Key
    select countryGroup;
// grouping is an IGrouping<int, Country>
foreach (var grouping in percentileQuery)
{
    Console.WriteLine(grouping.Key);
    foreach (var country in grouping)
}
Console.WriteLine(country.Name + ":" + country.Population);
 詳しくは、「into」をご覧ください。 フィルター処理、並べ替え、および結合
開始の from 句と、終了の select または group 句の間には、その他のすべての省略可能句 ( where 、 join 、 orderby 、 from 、 let ) を必要に応じて使用できます。 省略可能句は、クエリ本文で任意の回数 (0 回~複数回) 使用できます。
where 句
where 句は、1つ以上の述語式に基づいて、ソースデータから要素を除外するために使用します。次の例では、where 句
に 1 つの述語と 2 つの条件があります。
詳しくは、「where 句」をご覧ください。
orderby 句
orderby 句は、結果を昇順または降順で並べ替えるために使用します。第2の並べ替え順序を指定することもできます。
次の例では、Area プロパティを使用して、country オブジェクトに対する第1の並べ替えを実行しています。その後、 Population プロパティを使用して第2の並べ替えを実行しています。
ascending キーワードは省略可能です。順序が指定されていない場合は、これが既定の並べ替え順序になります。詳しく は、「orderby 句」をご覧ください。
join 句
join 句は、各要素内の指定したキー間での等値比較に基づいて、1つのデータソースの要素を別のデータソースの要素と
関連付けたり、組み合わせたりするために使用します。 LINQ では、join 操作は要素の型が異なるオブジェクトのシーケンスに 対して実行されます。 2 つのシーケンスを結合した後には、 select または group ステートメント使用して、出力シーケンスに 格納する要素を指定する必要があります。 また、匿名型を使用して、関連付けられた各要素セットのプロパティを、出力シー ケンス用の新しい型に結合することもできます。 次の例では、 Category プロパティが categories 文字列配列内のいずれか
      IEnumerable<City> queryCityPop =
    from city in cities
    where city.Population < 200000 && city.Population > 100000
    select city;
        IEnumerable<Country> querySortedCountries =
    from country in countries
    orderby country.Area, country.Population descending
    select country;
      countries
 
        のカテゴリと一致する prod オブジェクトを関連付けています。   が   内の文字列に一致しない製品は 除外されます。 select ステートメントは、 cat と prod の両方からプロパティを取った新しい型をプロジェクトしています。
intoキーワードを使用して join 操作の結果を一時変数に格納することにより、グループ結合を実行することもできます。詳 しくは、「join 句」をご覧ください。
let 句
let 句は、式の結果(メソッド呼び出しなど)を新しい範囲変数に格納するために使用します。次の例では、Split よって
返された文字列配列の最初の要素を、範囲変数 firstName に格納しています。
     var categoryQuery =
    from cat in categories
    join prod in products on cat equals prod.Category
    select new { Category = cat, Name = prod.Name };
      string[] names = { "Svetlana Omelchenko", "Claire O'Donnell", "Sven Mortensen", "Cesar Garcia" };
IEnumerable<string> queryFirstNames =
    from name in names
    let firstName = name.Split(' ')[0]
    select firstName;
foreach (string s in queryFirstNames)
    Console.Write(s + " ");
//Output: Svetlana Claire Sven Cesar
 詳しくは、「let 句」をご覧ください。 クエリ式内のサブクエリ
クエリ句には、それ自体にクエリ式が含まれることがあります。これは、サブクエリとも呼ばれます。各サブクエリは、独自の from で始まります。この句は、最初の from 句と必ずしも同じデータソースを指している必要はありません。たとえば、次のクエリ は、select ステートメントで grouping 操作の結果を取得するために使用されるクエリ式を示しています。
Category
categories
      var queryGroupMax =
    from student in students
    group student by student.GradeLevel into studentGroup
    select new
    {
        Level = studentGroup.Key,
        HighestScore =
};
(from student2 in studentGroup
 select student2.Scores.Average())
 .Max()
 詳細については、「グループ化操作でのサブクエリの実行」を参照してください。 関連項目
C# プログラミング ガイド 統合言語クエリ (LINQ) クエリ キーワード (LINQ) 標準クエリ演算子の概要

           このセクションでは、LINQ について詳しく説明したトピックへのリンクを紹介しています。 このセクションの内容
LINQ クエリの概要
すべての言語とデータ ソースに共通する基本的な LINQ クエリ操作の 3 つの部分について説明します。
LINQ とジェネリック型
LINQ で使われる場合のジェネリック型の概要を説明します。
LINQ によるデータ変換 クエリで取得したデータを変換するさまざまな方法について説明します。
LINQ クエリ操作での型の関係
LINQ クエリ操作の 3 つの部分において型がどのように保持および変換されるかについて説明します。
LINQ でのクエリ構文とメソッド構文
LINQ クエリを表す 2 つの方法であるメソッド構文とクエリ構文を比較します。
LINQ をサポートする C# の機能
LINQ をサポートする C# の言語構造について説明します。
関連項目
LINQ クエリ式
LINQ でのクエリの概要を説明し、他のリソースへのリンクを提供します。
標準クエリ演算子の概要
LINQ で使われる標準的な方法を紹介します。
C#での LINQ 2020/03/18 • • Edit Online
 
    この記事では、C# で LINQ クエリを作成できる 3 つの方法を示しています。
1. クエリ構文を使用する。
2. メソッド構文を使用する。
3. クエリ構文とメソッド構文を組み合わせて使用する。
以下の例では、上記の各アプローチを使用したシンプルな LINQ クエリを示します。 一般に、可能であれば常に (1) を使用 し、(2) と (3) は必要に応じて使用するというのがルールになっています。
例 - クエリ構文
ほとんどのクエリ記述については、クエリの構文を使用してクエリ式を作成することをお勧めします。 次の例は、3 つのクエリ式を 示しています。1つ目のクエリ式は、where 句を使用した条件を適用することで、結果をフィルター処理または制限する方法 を示しています。 このクエリは、値が 7 より大きいか、または 3 より小さいソース シーケンス内のすべての要素を返します。 2 つ 目の式は、返された結果を並べ替える方法を示しています。 3 つ目の式は、キーに基づいて結果をグループ化する方法を示し ています。 このクエリは、単語の頭文字に基づいて 2 つのグループを返します。
    NOTE
これらのクエリでは、シンプルなメモリ内コレクションに対して操作を実行します。ただし、基本的な構文は、LINQ to Entities および LINQ to XML で使用されるのと同じものです。
     // Query #1.
List<int> numbers = new List<int>() { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
// The query variable can also be implicitly typed by using var
IEnumerable<int> filteringQuery =
    from num in numbers
    where num < 3 || num > 7
    select num;
// Query #2.
IEnumerable<int> orderingQuery =
    from num in numbers
    where num < 3 || num > 7
    orderby num ascending
    select num;
// Query #3.
string[] groupingQuery = { "carrots", "cabbage", "broccoli", "beans", "barley" };
IEnumerable<IGrouping<char, string>> queryFoodGroups =
    from item in groupingQuery
    group item by item[0];
 クエリの型がIEnumerable<T>であることに注意してください。これらのクエリはすべて、次の例で示すように、var を使用して も記述できます。
var query = from num in numbers...
上記の各例では、 foreach ステートメントまたはその他のステートメントでクエリ変数を反復処理するまで、クエリは実際には実
  C# での LINQ クエリの作成 2020/11/02 • • Edit Online
 
    行されません。 詳しくは、「LINQ クエリの概要」をご覧ください。 例 - メソッド構文
一部のクエリ操作は、メソッド呼び出しとして表す必要があります。 このようなメソッドで最も一般的なもの は、Sum、Max、Min、Average のような単一の数値を返すメソッドです。 これらのメソッドは、単一の値のみを表し、追加のク エリ操作のソースとしては使用できないため、常に、どのクエリよりも後に呼び出す必要があります。 次の例は、クエリ式でのメ ソッド呼び出しを示したものです。
メソッドに Action または Func パラメーターがある場合、それらはラムダ式の形式で提供されます。次に例を示します。
上記のクエリでは Query #4 だけが直ちに実行されます。 これは、それがジェネリック IEnumerable<T> コレクションではなく、 単一値を返すためです。メソッド自体は、値を計算するために foreach を使用する必要があります。
上記の各クエリは、var による暗黙的型指定を使用しても記述できます。次に例を示します。
例 - クエリとメソッド構文の併用
この例では、クエリ句の結果に対してメソッド構文を使用する方法を示します。 方法は、クエリ式をかっこで囲み、ドット演算子 を適用して、メソッドを呼び出すだけです。 次の例では、Query #7 は、値が 3 ~ 7 である数値のカウントを返します。 ただし 一般的には、メソッド呼び出しの結果の格納には、2 番目の変数を使うほうが賢明です。 この方法のほうが、クエリをクエリ結 果と混同する恐れがありません。
    List<int> numbers1 = new List<int>() { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
List<int> numbers2 = new List<int>() { 15, 14, 11, 13, 19, 18, 16, 17, 12, 10 };
// Query #4.
double average = numbers1.Average();
// Query #5.
IEnumerable<int> concatenationQuery = numbers1.Concat(numbers2);
     // Query #6.
IEnumerable<int> largeNumbersQuery = numbers2.Where(c => c > 15);
      // var is used for convenience in these queries
var average = numbers1.Average();
var concatenationQuery = numbers1.Concat(numbers2);
var largeNumbersQuery = numbers2.Where(c => c > 15);
     // Query #7.
// Using a query expression with method syntax
int numCount1 =
    (from num in numbers1
     where num < 3 || num > 7
     select num).Count();
// Better: Create a new variable to store
// the method call result
IEnumerable<int> numbersQuery =
    from num in numbers1
    where num < 3 || num > 7
    select num;
int numCount2 = numbersQuery.Count();
 Query #7 はコレクションではなく単一の値を返すので、クエリはすぐに実行されます。

    上記のクエリは、 var による暗黙的型指定を使用しても記述できます。次に例を示します。
  var numCount = (from num in numbers...
 次のように、メソッド構文で記述することもできます。
次のように、明示的な型指定を使用して記述することもできます。
参照
チュートリアル: C# でのクエリの作成 統合言語クエリ (LINQ)
where 句
  var numCount = numbers.Where(n => n < 3 || n > 7).Count();
   int numCount = numbers.Where(n => n < 3 || n > 7).Count();
 
     この例では、 Student オブジェクトのリストに対してシンプルなクエリを実行する方法を示します。 各 Student オブジェクトに は、生徒に関する基本情報と、4 回の試験での生徒の点数を表すリストが含まれています。
このアプリケーションは、同じ students データソースを使用する、このセクション内のその他多くの例のフレームワークとして機能 します。
例
次のクエリは、最初の試験で 90 点以上を取った学生を返します。
    オブジェクトのコレクションの照会
2020/03/18 • • Edit Online
  public class Student
{
    #region data
    public enum GradeLevel { FirstYear = 1, SecondYear, ThirdYear, FourthYear };
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int Id { get; set; }
    public GradeLevel Year;
    public List<int> ExamScores;
    protected static List<Student> students = new List<Student>
    {
        new Student {FirstName = "Terry", LastName = "Adams", Id = 120,
            Year = GradeLevel.SecondYear,
            ExamScores = new List<int> { 99, 82, 81, 79}},
        new Student {FirstName = "Fadi", LastName = "Fakhouri", Id = 116,
            Year = GradeLevel.ThirdYear,
            ExamScores = new List<int> { 99, 86, 90, 94}},
        new Student {FirstName = "Hanying", LastName = "Feng", Id = 117,
            Year = GradeLevel.FirstYear,
            ExamScores = new List<int> { 93, 92, 80, 87}},
        new Student {FirstName = "Cesar", LastName = "Garcia", Id = 114,
            Year = GradeLevel.FourthYear,
            ExamScores = new List<int> { 97, 89, 85, 82}},
        new Student {FirstName = "Debra", LastName = "Garcia", Id = 115,
            Year = GradeLevel.ThirdYear,
            ExamScores = new List<int> { 35, 72, 91, 70}},
        new Student {FirstName = "Hugo", LastName = "Garcia", Id = 118,
            Year = GradeLevel.SecondYear,
            ExamScores = new List<int> { 92, 90, 83, 78}},
        new Student {FirstName = "Sven", LastName = "Mortensen", Id = 113,
            Year = GradeLevel.FirstYear,
            ExamScores = new List<int> { 88, 94, 65, 91}},
        new Student {FirstName = "Claire", LastName = "O'Donnell", Id = 112,
            Year = GradeLevel.FourthYear,
            ExamScores = new List<int> { 75, 84, 91, 39}},
        new Student {FirstName = "Svetlana", LastName = "Omelchenko", Id = 111,
            Year = GradeLevel.SecondYear,
            ExamScores = new List<int> { 97, 92, 81, 60}},
        new Student {FirstName = "Lance", LastName = "Tucker", Id = 119,
            Year = GradeLevel.ThirdYear,
            ExamScores = new List<int> { 68, 79, 88, 92}},
        new Student {FirstName = "Michael", LastName = "Tucker", Id = 122,
            Year = GradeLevel.FirstYear,
            ExamScores = new List<int> { 94, 92, 91, 91}},
        new Student {FirstName = "Eugene", LastName = "Zabokritski", Id = 121,
Year = GradeLevel.FourthYear,

    このクエリは、実験用として意図的にシンプルに記述されています。 たとえば、 where 句でより多く条件を試したり、 orderby 句を使用して結果を並べ替えたりすることもできます。
参照
統合言語クエリ (LINQ) 文字列補間
} }
        Year = GradeLevel.FourthYear,
        ExamScores = new List<int> { 96, 85, 91, 60}}
};
#endregion
// Helper method, used in GroupByRange.
protected static int GetPercentile(Student s)
{
    double avg = s.ExamScores.Average();
    return avg > 0 ? (int)avg / 10 : 0;
}
public static void QueryHighScores(int exam, int score)
{
   var highScores = from student in students
                 where student.ExamScores[exam] > score
                 select new {Name = student.FirstName, Score = student.ExamScores[exam]};
foreach (var item in highScores)
{
    Console.WriteLine($"{item.Name,-15}{item.Score}");
}
public class Program
{
    public static void Main()
    {
} }
Student.QueryHighScores(1, 90);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit");
Console.ReadKey();
 
    この例では、メソッドから、クエリを戻り値として返す方法と out パラメーターとして返す方法を示します。
クエリ オブジェクトはコンポーザブルです。つまり、メソッドからクエリを返すことができます。 クエリを表すオブジェクトには、結果のコ レクションではなく、必要に応じて結果を生成する手順が格納されます。 メソッドからクエリ オブジェクトを返すメリットは、そのオ ブジェクトをさらに構成したり変更したりできることです。そのため、クエリを返すメソッドの戻り値または out パラメーターも同じ 型である必要があります。 メソッドがクエリを具象型 List<T> または Array に実体化する場合は、そのメソッドは、クエリ自体で はなくクエリ結果を返すと見なされます。 メソッドから返されたクエリ変数は、引き続き構成または変更できます。
例
次の例は、最初のメソッドはクエリを戻り値として返し、2番目のメソッドはクエリを out パラメーターとして返しています。どちら の場合も返されるのはクエリであり、クエリ結果ではないことに注意してください。
   メソッドからクエリを返す方法 (C# プログラミ
ング ガイド) 2020/11/02 • • Edit Online
  class MQ {
    // QueryMethhod1 returns a query as its value.
    IEnumerable<string> QueryMethod1(ref int[] ints)
    {
        var intsToStrings = from i in ints
                            where i > 4
                            select i.ToString();
        return intsToStrings;
}
    // QueryMethod2 returns a query as the value of parameter returnQ.
    void QueryMethod2(ref int[] ints, out IEnumerable<string> returnQ)
    {
        var intsToStrings = from i in ints
                            where i < 4
                            select i.ToString();
        returnQ = intsToStrings;
}
    static void Main()
    {
        MQ app = new MQ();
        int[] nums = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        // QueryMethod1 returns a query as the value of the method.
        var myQuery1 = app.QueryMethod1(ref nums);
        // Query myQuery1 is executed in the following foreach loop.
        Console.WriteLine("Results of executing myQuery1:");
        // Rest the mouse pointer over myQuery1 to see its type.
        foreach (string s in myQuery1)
        {
            Console.WriteLine(s);
}
        // You also can execute the query returned from QueryMethod1
        // directly, without using myQuery1.
        Console.WriteLine("\nResults of executing myQuery1 directly:");
        // Rest the mouse pointer over the call to QueryMethod1 to see its

  参照
統合言語クエリ (LINQ)
   } }
// return type.
foreach (string s in app.QueryMethod1(ref nums))
{
    Console.WriteLine(s);
}
IEnumerable<string> myQuery2;
// QueryMethod2 returns a query as the value of its out parameter.
app.QueryMethod2(ref nums, out myQuery2);
// Execute the returned query.
Console.WriteLine("\nResults of executing myQuery2:");
foreach (string s in myQuery2)
{
    Console.WriteLine(s);
}
// You can modify a query by using query composition. A saved query
// is nested inside a new query definition that revises the results
// of the first query.
myQuery1 = from item in myQuery1
           orderby item descending
           select item;
// Execute the modified query.
Console.WriteLine("\nResults of executing modified myQuery1:");
foreach (string s in myQuery1)
{
    Console.WriteLine(s);
}
// Keep console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
 
       クエリは、基本的に、データの取得方法と編成方法を指示するための一連の命令です。 結果の各項目は順次要求されるた め、クエリは遅延実行されます。 foreach を使用して結果を反復すると、項目はアクセスのたびに返されます。クエリを評価 し、 foreach のループを実行せずに結果を格納するには、クエリ変数で次のメソッドのいずれかを呼び出します。
ToList ToArray ToDictionar y ToLookup
クエリ結果を格納するときは、次の例に示すように、返されたコレクション オブジェクトを新しい変数に割り当てることをお勧めしま す。
例
      class StoreQueryResults
{
    static List<int> numbers = new List<int>() { 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };
    static void Main()
    {
} }
IEnumerable<int> queryFactorsOfFour =
    from num in numbers
    where num % 4 == 0
    select num;
// Store the results in a new variable
// without executing a foreach loop.
List<int> factorsofFourList = queryFactorsOfFour.ToList();
// Iterate the list just to prove it holds data.
Console.WriteLine(factorsofFourList[2]);
factorsofFourList[2] = 0;
Console.WriteLine(factorsofFourList[2]);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key");
Console.ReadKey();
 参照
統合言語クエリ (LINQ)
クエリ結果をメモリに格納する
2020/03/18 • • Edit Online
 
    グループ化は、LINQ の最も強力な機能の 1 つです。 次の例では、さまざまな方法でデータをグループ化する方法を示します。 1 つのプロパティで。
文字列プロパティの最初の文字で。
計算された数値の範囲で。
ブール述語またはその他の式で。
複合キーで。
さらに、最後の 2 つのクエリは、学生の名と姓だけを含む新しい匿名型に結果を射影します。 詳しくは、「group 句」をご覧く ださい。
例
このトピックのすべての例では、次のヘルパー クラスとデータ ソースを使います。
   クエリ結果のグループ化
2020/03/18 • • Edit Online
  public class StudentClass
{
    #region data
    protected enum GradeLevel { FirstYear = 1, SecondYear, ThirdYear, FourthYear };
    protected class Student
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int ID { get; set; }
        public GradeLevel Year;
        public List<int> ExamScores;
    }
    protected static List<Student> students = new List<Student>
    {
        new Student {FirstName = "Terry", LastName = "Adams", ID = 120,
            Year = GradeLevel.SecondYear,
            ExamScores = new List<int>{ 99, 82, 81, 79}},
        new Student {FirstName = "Fadi", LastName = "Fakhouri", ID = 116,
            Year = GradeLevel.ThirdYear,
            ExamScores = new List<int>{ 99, 86, 90, 94}},
        new Student {FirstName = "Hanying", LastName = "Feng", ID = 117,
            Year = GradeLevel.FirstYear,
            ExamScores = new List<int>{ 93, 92, 80, 87}},
        new Student {FirstName = "Cesar", LastName = "Garcia", ID = 114,
            Year = GradeLevel.FourthYear,
            ExamScores = new List<int>{ 97, 89, 85, 82}},
        new Student {FirstName = "Debra", LastName = "Garcia", ID = 115,
            Year = GradeLevel.ThirdYear,
            ExamScores = new List<int>{ 35, 72, 91, 70}},
        new Student {FirstName = "Hugo", LastName = "Garcia", ID = 118,
            Year = GradeLevel.SecondYear,
            ExamScores = new List<int>{ 92, 90, 83, 78}},
        new Student {FirstName = "Sven", LastName = "Mortensen", ID = 113,
            Year = GradeLevel.FirstYear,
            ExamScores = new List<int>{ 88, 94, 65, 91}},
        new Student {FirstName = "Claire", LastName = "O'Donnell", ID = 112,
            Year = GradeLevel.FourthYear,
ExamScores = new List<int>{ 75, 84, 91, 39}},

    例
次の例では、要素の 1 つのプロパティをグループ化キーとして使って、ソース要素をグループ化する方法を示します。 この場合、 キーは学生の姓である string です。また、キーの部分文字列を使うこともできます。グループ化操作では、型の既定の等 値比較子を使います。
次のメソッドを クラスに貼り付けます。 Main メソッドの呼び出しステートメントを に変更します。
  StudentClass
 sc.GroupBySingleProperty()
} }
        ExamScores = new List<int>{ 75, 84, 91, 39}},
    new Student {FirstName = "Svetlana", LastName = "Omelchenko", ID = 111,
        Year = GradeLevel.SecondYear,
        ExamScores = new List<int>{ 97, 92, 81, 60}},
    new Student {FirstName = "Lance", LastName = "Tucker", ID = 119,
        Year = GradeLevel.ThirdYear,
        ExamScores = new List<int>{ 68, 79, 88, 92}},
    new Student {FirstName = "Michael", LastName = "Tucker", ID = 122,
        Year = GradeLevel.FirstYear,
        ExamScores = new List<int>{ 94, 92, 91, 91}},
    new Student {FirstName = "Eugene", LastName = "Zabokritski", ID = 121,
        Year = GradeLevel.FourthYear,
        ExamScores = new List<int>{ 96, 85, 91, 60}}
};
#endregion
//Helper method, used in GroupByRange.
protected static int GetPercentile(Student s)
{
    double avg = s.ExamScores.Average();
    return avg > 0 ? (int)avg / 10 : 0;
}
public void QueryHighScores(int exam, int score)
{
 var highScores = from student in students
                 where student.ExamScores[exam] > score
                 select new {Name = student.FirstName, Score = student.ExamScores[exam]};
foreach (var item in highScores)
{
    Console.WriteLine($"{item.Name,-15}{item.Score}");
}
public class Program
{
    public static void Main()
    {
} }
StudentClass sc = new StudentClass();
sc.QueryHighScores(1, 90);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit");
Console.ReadKey();

    例
次の例では、オブジェクトのプロパティ以外の何かをグループ化キーとして使って、ソース要素をグループ化する方法を示します。 この例では、キーは学生の姓の最初の文字です。
次のメソッドを StudentClass クラスに貼り付けます。 Main メソッドの呼び出しステートメントを sc.GroupBySubstring() に 変更します。
    public void GroupBySingleProperty()
{
    Console.WriteLine("Group by a single property in an object:");
    // Variable queryLastNames is an IEnumerable<IGrouping<string,
    // DataClass.Student>>.
    var queryLastNames =
        from student in students
        group student by student.LastName into newGroup
        orderby newGroup.Key
        select newGroup;
    foreach (var nameGroup in queryLastNames)
    {
} }
Console.WriteLine($"Key: {nameGroup.Key}");
foreach (var student in nameGroup)
{
    Console.WriteLine($"\t{student.LastName}, {student.FirstName}");
}
/* Output:
    Group by a single property in an object:
    Key: Adams
            Adams, Terry
    Key: Fakhouri
            Fakhouri, Fadi
    Key: Feng
            Feng, Hanying
    Key: Garcia
            Garcia, Cesar
            Garcia, Debra
            Garcia, Hugo
    Key: Mortensen
            Mortensen, Sven
    Key: O'Donnell
            O'Donnell, Claire
    Key: Omelchenko
            Omelchenko, Svetlana
    Key: Tucker
            Tucker, Lance
            Tucker, Michael
    Key: Zabokritski
*/
Zabokritski, Eugene

    例
次の例では、数値範囲をグループ化キーとして使って、ソース要素をグループ化する方法を示します。 クエリは、名と姓および学 生が属しているパーセンタイル範囲のみを含む匿名型に、結果を投影します。 匿名型を使っているのは、結果を表示するため に完全な Student オブジェクトを使う必要がないためです。 GetPercentile は、学生の平均スコアに基づいてパーセンタイル を計算するヘルパー関数です。 メソッドは、0 から 10 の間の整数を返します。
次のメソッドを StudentClass クラスに貼り付けます。 Main メソッドの呼び出しステートメントを sc.GroupByRange() に変更 します。
      //Helper method, used in GroupByRange.
protected static int GetPercentile(Student s)
{
    double avg = s.ExamScores.Average();
    return avg > 0 ? (int)avg / 10 : 0;
}
     public void GroupBySubstring()
{
    Console.WriteLine("\r\nGroup by something other than a property of the object:");
    var queryFirstLetters =
        from student in students
        group student by student.LastName[0];
    foreach (var studentGroup in queryFirstLetters)
    {
} }
Console.WriteLine($"Key: {studentGroup.Key}");
// Nested foreach is required to access group items.
foreach (var student in studentGroup)
{
    Console.WriteLine($"\t{student.LastName}, {student.FirstName}");
}
/* Output:
    Group by something other than a property of the object:
    Key: A
            Adams, Terry
    Key: F
            Fakhouri, Fadi
            Feng, Hanying
    Key: G
            Garcia, Cesar
            Garcia, Debra
            Garcia, Hugo
    Key: M
            Mortensen, Sven
    Key: O
            O'Donnell, Claire
            Omelchenko, Svetlana
    Key: T
            Tucker, Lance
            Tucker, Michael
    Key: Z
*/
Zabokritski, Eugene

    例
次の例では、ブール比較式を使って、ソース要素をグループ化する方法を示します。 この例のブール式は、学生の平均試験ス コアが 75 より大きいかどうかをテストします。 前の例と同じように、完全なソース要素が必要ないため、結果を匿名型に投影し ます。匿名型のプロパティは Key メンバーのプロパティになり、クエリ実行時に名前でアクセスできることに注意してください。
次のメソッドを StudentClass クラスに貼り付けます。 Main メソッドの呼び出しステートメントを sc.GroupByBoolean() に変 更します。
    public void GroupByRange()
{
    Console.WriteLine("\r\nGroup by numeric range and project into a new anonymous type:");
    var queryNumericRange =
        from student in students
        let percentile = GetPercentile(student)
        group new { student.FirstName, student.LastName } by percentile into percentGroup
        orderby percentGroup.Key
        select percentGroup;
    // Nested foreach required to iterate over groups and group items.
    foreach (var studentGroup in queryNumericRange)
    {
} }
Console.WriteLine($"Key: {studentGroup.Key * 10}");
foreach (var item in studentGroup)
{
    Console.WriteLine($"\t{item.LastName}, {item.FirstName}");
}
/* Output:
    Group by numeric range and project into a new anonymous type:
    Key: 60
            Garcia, Debra
    Key: 70
            O'Donnell, Claire
    Key: 80
            Adams, Terry
            Feng, Hanying
            Garcia, Cesar
            Garcia, Hugo
            Mortensen, Sven
            Omelchenko, Svetlana
            Tucker, Lance
            Zabokritski, Eugene
    Key: 90
            Fakhouri, Fadi
*/
Tucker, Michael

  例
次の例では、匿名型を使って、複数の値を含むキーをカプセル化する方法を示します。 この例では、最初のキーの値は学生の 姓の最初の文字です。 2 番目のキーの値は、最初の試験での学生のスコアが 85 より高いかどうかを示すブール値です。 キー の任意のプロパティでグループを並べ替えることができます。
次のメソッドを StudentClass クラスに貼り付けます。 Main メソッドの呼び出しステートメントを sc.GroupByCompositeKey() に変更します。
     public void GroupByBoolean()
{
    Console.WriteLine("\r\nGroup by a Boolean into two groups with string keys");
    Console.WriteLine("\"True\" and \"False\" and project into a new anonymous type:");
    var queryGroupByAverages = from student in students
                               group new { student.FirstName, student.LastName }
                                    by student.ExamScores.Average() > 75 into studentGroup
                               select studentGroup;
    foreach (var studentGroup in queryGroupByAverages)
    {
} }
Console.WriteLine($"Key: {studentGroup.Key}");
foreach (var student in studentGroup)
    Console.WriteLine($"\t{student.FirstName} {student.LastName}");
/* Output:
    Group by a Boolean into two groups with string keys
    "True" and "False" and project into a new anonymous type:
    Key: True
            Terry Adams
            Fadi Fakhouri
            Hanying Feng
            Cesar Garcia
            Hugo Garcia
            Sven Mortensen
            Svetlana Omelchenko
            Lance Tucker
            Michael Tucker
            Eugene Zabokritski
    Key: False
            Debra Garcia
*/
Claire O'Donnell
 
           参照
GroupBy IGrouping<TKey,TElement> 統合言語クエリ (LINQ)
group 句
匿名型 グループ化操作でのサブクエリの実行 入れ子になったグループの作成 データのグループ化
  public void GroupByCompositeKey()
{
    var queryHighScoreGroups =
        from student in students
        group student by new { FirstLetter = student.LastName[0],
            Score = student.ExamScores[0] > 85 } into studentGroup
        orderby studentGroup.Key.FirstLetter
        select studentGroup;
    Console.WriteLine("\r\nGroup and order by a compound key:");
    foreach (var scoreGroup in queryHighScoreGroups)
    {
} }
string s = scoreGroup.Key.Score == true ? "more than" : "less than";
Console.WriteLine($"Name starts with {scoreGroup.Key.FirstLetter} who scored {s} 85");
foreach (var item in scoreGroup)
{
    Console.WriteLine($"\t{item.FirstName} {item.LastName}");
}
/* Output:
    Group and order by a compound key:
    Name starts with A who scored more than 85
            Terry Adams
    Name starts with F who scored more than 85
            Fadi Fakhouri
            Hanying Feng
    Name starts with G who scored more than 85
Cesar Garcia
            Hugo Garcia
    Name starts with G who scored less than 85
            Debra Garcia
    Name starts with M who scored more than 85
            Sven Mortensen
    Name starts with O who scored less than 85
            Claire O'Donnell
    Name starts with O who scored more than 85
            Svetlana Omelchenko
    Name starts with T who scored less than 85
            Lance Tucker
    Name starts with T who scored more than 85
            Michael Tucker
    Name starts with Z who scored more than 85
*/
Eugene Zabokritski

    LINQ クエリ式で入れ子になったグループを作成する方法を次の例に示します。 学年レベルに基づいて作成した各グループを、 さらに個人の名前に基づくグループに分割します。
例
    NOTE
この例には、「オブジェクトのコレクションの照会」のサンプル コードで定義されているオブジェクトへの参照が含まれています。
 入れ子になったグループの作成
2020/03/18 • • Edit Online
 
      入れ子になったグループの内部要素に対して反復処理を実行するために、入れ子になった foreach ループが3つ必要であ ることに注意してください。
参照
統合言語クエリ (LINQ)
  public void QueryNestedGroups()
{
    var queryNestedGroups =
        from student in students
        group student by student.Year into newGroup1
        from newGroup2 in
            (from student in newGroup1
             group student by student.LastName)
        group newGroup2 by newGroup1.Key;
    // Three nested foreach loops are required to iterate
    // over all elements of a grouped group. Hover the mouse
    // cursor over the iteration variables to see their actual type.
    foreach (var outerGroup in queryNestedGroups)
    {
        Console.WriteLine($"DataClass.Student Level = {outerGroup.Key}");
        foreach (var innerGroup in outerGroup)
        {
} }
} /*
Console.WriteLine($"\tNames that begin with: {innerGroup.Key}");
foreach (var innerGroupElement in innerGroup)
{
    Console.WriteLine($"\t\t{innerGroupElement.LastName} {innerGroupElement.FirstName}");
}
 Output:
DataClass.Student Level = SecondYear
        Names that begin with: Adams
                Adams Terry
        Names that begin with: Garcia
                Garcia Hugo
        Names that begin with: Omelchenko
                Omelchenko Svetlana
DataClass.Student Level = ThirdYear
        Names that begin with: Fakhouri
                Fakhouri Fadi
        Names that begin with: Garcia
                Garcia Debra
        Names that begin with: Tucker
                Tucker Lance
DataClass.Student Level = FirstYear
        Names that begin with: Feng
                Feng Hanying
        Names that begin with: Mortensen
                Mortensen Sven
        Names that begin with: Tucker
                Tucker Michael
DataClass.Student Level = FourthYear
*/
Names that begin with: Garcia
        Garcia Cesar
Names that begin with: O'Donnell
        O'Donnell Claire
Names that begin with: Zabokritski
        Zabokritski Eugene

     この記事では、ソース データを複数のグループに整理し、各グループに対して個別にサブクエリを実行するクエリを作成する方法 を2つ紹介します。各例の基本的な手法として、ソース要素のグループ化には、newGroup という名前の"継続"を使用し、
newGroup に対する新しいサブクエリを生成します。このサブクエリは、外部クエリによって作成された新しい各グループに対して 実行されます。 この例では、最終出力がグループではなく、匿名型のフラットなシーケンスであることに注意してください。
グループ化する方法の詳細については、「group 句」を参照してください。 継続の詳細については、「into」を参照してください。 次の例では、インメモリ データ構造をデータ ソースとして使用しています
が、どの種類の LINQ データ ソースにも同じ原則が当てはまります。 例
      NOTE
この例には、「オブジェクトのコレクションの照会」のサンプル コードで定義されているオブジェクトへの参照が含まれています。
     public void QueryMax()
{
    var queryGroupMax =
        from student in students
        group student by student.Year into studentGroup
        select new
        {
            Level = studentGroup.Key,
            HighestScore =
            (from student2 in studentGroup
             select student2.ExamScores.Average()).Max()
        };
    int count = queryGroupMax.Count();
    Console.WriteLine($"Number of groups = {count}");
    foreach (var item in queryGroupMax)
    {
        Console.WriteLine($"  {item.Level} Highest Score={item.HighestScore}");
    }
}
 上記のスニペットのクエリは、メソッド構文を使用して記述することもできます。 次のコード スニペットは、メソッド構文を使用して 記述した意味的に同等のクエリです。
グループ化操作でのサブクエリの実行
2020/05/20 • • Edit Online
 
   参照
統合言語クエリ (LINQ)
   public void QueryMaxUsingMethodSyntax()
{
    var queryGroupMax = students
        .GroupBy(student => student.Year)
        .Select(studentGroup => new
        {
            Level = studentGroup.Key,
            HighestScore = studentGroup.Select(student2 => student2.ExamScores.Average()).Max()
        });
    int count = queryGroupMax.Count();
    Console.WriteLine($"Number of groups = {count}");
    foreach (var item in queryGroupMax)
    {
        Console.WriteLine($"  {item.Level} Highest Score={item.HighestScore}");
    }
}
 
    要素をグループ化し、連続するキーのサブシーケンスを表すチャンクにする方法を次の例に示します。 たとえば、次の一連の キーと値のペアがあるとします。
A水
A think
A that
B Linq
C is
A really
B cool
B!
次のグループがこの順序で作成されます。
1. We,think,that 2. Linq
3. is
4. really
5. cool,!
ソリューションは、結果をストリーミングで返すスレッド セーフな拡張メソッドとして実装されます。 つまり、ソース シーケンス内を移 動するときにグループが作成されます。 group 演算子や orderby 演算子とは異なり、すべてのシーケンスの読み取りが終わ る前に、呼び出し元にグループを返し始めることができます。
ソース コードのコメントで説明されているように、ソース シーケンスが反復処理されるときに各グループまたはチャンクのコピーを作 成することで、スレッド セーフが実現されます。 ソース シーケンスに連続するアイテムの大きなシーケンスがある場合、共通言語 ランタイムにより OutOfMemoryException がスローされる可能性があります。
例
拡張メソッドと、それを使用するクライアント コードの両方を次の例に示します。
                                   連続するキーで結果をグループ化する
2020/03/18 • • Edit Online
     using System;
using System.Collections.Generic;
using System.Linq;
namespace ChunkIt
{

 {
    // Static class to contain the extension methods.
    public static class MyExtensions
    {
        public static IEnumerable<IGrouping<TKey, TSource>> ChunkBy<TSource, TKey>(this IEnumerable<TSource>
source, Func<TSource, TKey> keySelector)
        {
            return source.ChunkBy(keySelector, EqualityComparer<TKey>.Default);
}
        public static IEnumerable<IGrouping<TKey, TSource>> ChunkBy<TSource, TKey>(this IEnumerable<TSource>
source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
        {
            // Flag to signal end of source sequence.
            const bool noMoreSourceElements = true;
            // Auto-generated iterator for the source array.
            var enumerator = source.GetEnumerator();
            // Move to the first element in the source sequence.
            if (!enumerator.MoveNext()) yield break;
            // Iterate through source sequence and create a copy of each Chunk.
            // On each pass, the iterator advances to the first element of the next "Chunk"
            // in the source sequence. This loop corresponds to the outer foreach loop that
            // executes the query.
            Chunk<TKey, TSource> current = null;
            while (true)
            {
                // Get the key for the current Chunk. The source iterator will churn through
                // the source sequence until it finds an element with a key that doesn't match.
                var key = keySelector(enumerator.Current);
                // Make a new Chunk (group) object that initially has one GroupItem, which is a copy of the
current source element.
                current = new Chunk<TKey, TSource>(key, enumerator, value => comparer.Equals(key,
keySelector(value)));
 ChunkBy method.
elements will be
more info.
iterator
} }
// Return the Chunk. A Chunk is an IGrouping<TKey,TSource>, which is the return value of the
// At this point the Chunk only has the first element in its source sequence. The remaining
// returned only when the client code foreach's over this chunk. See Chunk.GetEnumerator for
yield return current;
// Check to see whether (a) the chunk has made a copy of all its source elements or
// (b) the iterator has reached the end of the source sequence. If the caller uses an inner
// foreach loop to iterate the chunk items, and that loop ran to completion,
// then the Chunk.GetEnumerator method will already have made
// copies of all chunk items before we get here. If the Chunk.GetEnumerator loop did not
// enumerate all elements in the chunk, we need to do it here to avoid corrupting the
// for clients that may be calling us on a separate thread.
if (current.CopyAllChunkElements() == noMoreSourceElements)
{
    yield break;
}
        // A Chunk is a contiguous group of one or more source elements that have the same key. A Chunk
        // has a key and a list of ChunkItem objects, which are copies of the elements in the source
sequence.
        class Chunk<TKey, TSource> : IGrouping<TKey, TSource>
        {
            // INVARIANT: DoneCopyingChunk == true ||
            //   (predicate != null && predicate(enumerator.Current) && current.Value == enumerator.Current)
  // A Chunk has a linked list of ChunkItems, which represent the elements in the current chunk.

             // A Chunk has a linked list of ChunkItems, which represent the elements in the current chunk.
Each ChunkItem
            // has a reference to the next ChunkItem in the list.
            class ChunkItem
            {
                public ChunkItem(TSource value)
                {
                    Value = value;
                }
                public readonly TSource Value;
                public ChunkItem Next = null;
            }
            // The value that is used to determine matching elements
            private readonly TKey key;
            // Stores a reference to the enumerator for the source sequence
            private IEnumerator<TSource> enumerator;
            // A reference to the predicate that is used to compare keys.
            private Func<TSource, bool> predicate;
            // Stores the contents of the first source element that
            // belongs with this chunk.
            private readonly ChunkItem head;
            // End of the list. It is repositioned each time a new
            // ChunkItem is added.
            private ChunkItem tail;
            // Flag to indicate the source iterator has reached the end of the source sequence.
            internal bool isLastSourceElement = false;
            // Private object for thread syncronization
            private object m_Lock;
            // REQUIRES: enumerator != null && predicate != null
            public Chunk(TKey key, IEnumerator<TSource> enumerator, Func<TSource, bool> predicate)
            {
                this.key = key;
                this.enumerator = enumerator;
                this.predicate = predicate;
                // A Chunk always contains at least one element.
                head = new ChunkItem(enumerator.Current);
                // The end and beginning are the same until the list contains > 1 elements.
                tail = head;
                m_Lock = new object();
            }
            // Indicates that all chunk elements have been copied to the list of ChunkItems,
            // and the source enumerator is either at the end, or else on an element with a new key.
            // the tail of the linked list is set to null in the CopyNextChunkElement method if the
            // key of the next element does not match the current chunk's key, or there are no more elements
in the source.
            private bool DoneCopyingChunk => tail == null;
            // Adds one ChunkItem to the current group
            // REQUIRES: !DoneCopyingChunk && lock(this)
            private void CopyNextChunkElement()
            {
                // Try to advance the iterator on the source sequence.
                // If MoveNext returns false we are at the end, and isLastSourceElement is set to true
                isLastSourceElement = !enumerator.MoveNext();
                // If we are (a) at the end of the source, or (b) at the end of the current chunk
                // then null out the enumerator and predicate for reuse with the next chunk.
   
      if (isLastSourceElement || !predicate(enumerator.Current))
    {
        enumerator = null;
        predicate = null;
    }
else {
        tail.Next = new ChunkItem(enumerator.Current);
    }
    // tail will be null if we are at the end of the chunk elements
    // This check is made in DoneCopyingChunk.
    tail = tail.Next;
}
// Called after the end of the last chunk was reached. It first checks whether
// there are more elements in the source sequence. If there are, it
// Returns true if enumerator for this chunk was exhausted.
internal bool CopyAllChunkElements()
{
    while (true)
    {
        lock (m_Lock)
        {
            if (DoneCopyingChunk)
            {
                // If isLastSourceElement is false,
                // it signals to the outer iterator
                // to continue iterating.
                return isLastSourceElement;
} else {
                CopyNextChunkElement();
            }
} }
}
public TKey Key => key;
// Invoked by the inner foreach loop. This method stays just one step ahead
// of the client requests. It adds the next element of the chunk only after
// the clients requests the last element in the list so far.
public IEnumerator<TSource> GetEnumerator()
{
    //Specify the initial element to enumerate.
    ChunkItem current = head;
    // There should always be at least one ChunkItem in a Chunk.
    while (current != null)
    {
        // Yield the current item in the list.
        yield return current.Value;
        // Copy the next item from the source sequence,
        // if we are at the end of our local list.
        lock (m_Lock)
        {
            if (current == tail)
            {
                CopyNextChunkElement();
            }
}
        // Move to the next ChunkItem in the list.
        current = current.Next;
    }
}
  
      プロジェクトで拡張メソッドを使用するには、 MyExtensions 静的クラスを新規または既存のソース コード ファイルにコピーし、必 要に応じて、配置されている名前空間の using ディレクティブを追加します。
参照
統合言語クエリ (LINQ)
             System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() =>
GetEnumerator();
} }
    // A simple named type is used for easier viewing in the debugger. Anonymous types
    // work just as well with the ChunkBy operator.
    public class KeyValPair
    {
        public string Key { get; set; }
        public string Value { get; set; }
    }
    class Program
    {
        // The source sequence.
        public static IEnumerable<KeyValPair> list;
        // Query variable declared as class member to be available
        // on different threads.
        static IEnumerable<IGrouping<string, KeyValPair>> query;
        static void Main(string[] args)
        {
            // Initialize the source sequence with an array initializer.
            list = new[]
            {
                new KeyValPair{ Key = "A", Value = "We" },
                new KeyValPair{ Key = "A", Value = "think" },
                new KeyValPair{ Key = "A", Value = "that" },
                new KeyValPair{ Key = "B", Value = "Linq" },
                new KeyValPair{ Key = "C", Value = "is" },
                new KeyValPair{ Key = "A", Value = "really" },
                new KeyValPair{ Key = "B", Value = "cool" },
                new KeyValPair{ Key = "B", Value = "!" }
};
            // Create the query by using our user-defined query operator.
            query = list.ChunkBy(p => p.Key);
            // ChunkBy returns IGrouping objects, therefore a nested
            // foreach loop is required to access the elements in each "chunk".
            foreach (var item in query)
            {
                Console.WriteLine($"Group key = {item.Key}");
                foreach (var inner in item)
                {
                    Console.WriteLine($"\t{inner.Value}");
                }
}
            Console.WriteLine("Press any key to exit");
            Console.ReadKey();
        }
} }

     where 句のソース要素に適用しなければならない述語の数が実行時までわからない場合があります。複数の述語フィルター を動的に指定する方法として、次の例のように、Contains メソッドを使用する方法があります。 この例は 2 段階構築になって います。 最初に、プログラムで提供される値にフィルターを適用してプログラムを実行します。 次に、実行時に提供された入力 を利用してプログラムをもう一度実行します。
Contains メソッドを使用してフィルター処理するには
1. 新しいコンソール アプリケーションを開き、それに PredicateFilters という名前を付けます。
2. 「オブジェクトのコレクションを照会する」から クラスをコピーし、クラス Program の下の名前空間 PredicateFilters に貼り付けます。 は、 オブジェクトの一覧を提供します。
3. StudentClass で Main メソッドをコメントアウトします。
4. クラス Program を次のコードで置き換えます。
   StudentClass
   StudentClass
      class DynamicPredicates : StudentClass
{
    static void Main(string[] args)
    {
        string[] ids = { "111", "114", "112" };
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
    static void QueryByID(string[] ids)
    {
} }
var queryNames =
    from student in students
    let i = student.ID.ToString()
    where ids.Contains(i)
    select new { student.LastName, student.ID };
foreach (var name in queryNames)
{
    Console.WriteLine($"{name.LastName}: {name.ID}");
}
  5. 次の行をクラス DynamicPredicates の Main メソッドに追加します。 ids の宣言の下です。
6. プロジェクトを実行します。
7. 次の出力がコンソール ウィンドウに表示されます。
Garcia: 114 O'Donnell: 112
Student
  QueryById(ids);
 実行時における述語フィルターの動的指定
2020/05/20 • • Edit Online
 
 Omelchenko: 111
8. 次の手順はプロジェクトをもう一度実行することですが、今度は配列 ids の代わりに実行時に提供された入力を使
用します。 Main メソッドで QueryByID(ids) を QueryByID(args) に変更します。
9. コマンド ライン引数 122 117 120 115 でプロジェクトを実行します。 プロジェクトが実行されると、これらの値が Main
メソッドのパラメーター、 args の要素になります。
10. 次の出力がコンソール ウィンドウに表示されます。
Adams: 120 Feng: 117 Garcia: 115 Tucker:122
switch ステートメントを使用してフィルター処理するには
1. ステートメントを使用し、あらかじめ決定されている代替クエリから選択できます。 次の例では、
は、実行時に指定された学年に基づき、別の where 句を使用します。 2. 次のメソッドをコピーし、クラス DynamicPredicates に貼り付けます。
    switch
 studentQuery
 
       3. Main メソッドで、 QueryByID の呼び出しを次の呼び出しに置換します。この呼び出しは、 args 配列の最初の要素 をその引数として送信します ( QueryByYear(args[0]) )。
4. 1 から 4 の整数をコマンド ライン引数としてプロジェクトを実行します。 参照
統合言語クエリ (LINQ) where 句
   // To run this sample, first specify an integer value of 1 to 4 for the command
// line. This number will be converted to a GradeLevel value that specifies which
// set of students to query.
// Call the method: QueryByYear(args[0]);
static void QueryByYear(string level)
{
    GradeLevel year = (GradeLevel)Convert.ToInt32(level);
    IEnumerable<Student> studentQuery = null;
    switch (year)
    {
        case GradeLevel.FirstYear:
            studentQuery = from student in students
                           where student.Year == GradeLevel.FirstYear
                           select student;
            break;
        case GradeLevel.SecondYear:
            studentQuery = from student in students
                           where student.Year == GradeLevel.SecondYear
                           select student;
            break;
        case GradeLevel.ThirdYear:
            studentQuery = from student in students
                           where student.Year == GradeLevel.ThirdYear
                           select student;
            break;
        case GradeLevel.FourthYear:
            studentQuery = from student in students
                           where student.Year == GradeLevel.FourthYear
break;
default:
    break;
select student;
    }
    Console.WriteLine($"The following students are at level {year}");
    foreach (Student name in studentQuery)
    {
        Console.WriteLine($"{name.LastName}: {name.ID}");
    }
}

   リレーショナル データベースでは、"内部結合" により、2 番目のコレクション内の一致するすべての要素に対して、最初のコレク ションの各要素が一度表示される結果セットが生成されます。 最初のコレクション内の要素に一致する要素が存在しない場 合、その要素は結果セットには表示されません。Joinメソッドは、C#の join 句によって呼び出され、内部結合を実装しま す。
この記事では、次の 4 種類の内部結合を実行する方法を示します。 簡単なキーに基づいて、2 つのデータ ソースの要素を関連付ける単純な内部結合。
"複合" キーに基づいて、2 つのデータ ソースの要素を関連付ける内部結合。 複合キーは複数の値で構成され、複数 のプロパティに基づいて要素を関連付けることができます。
一連の結合操作が相互に追加された "複数の結合"。 グループ結合を使用して実装された内部結合。
例 - 簡単なキーの結合
次の例は、2つのユーザー定義型オブジェクト、Person と Pet が含まれた2つのコレクションを作成します。クエリでは、C# の join 句を使用して、 Person オブジェクトを Owner がこの Person である Pet オブジェクトを照合します。 C# の
select 句では、結果のオブジェクトの表示内容を定義します。この例では、結果のオブジェクトは、飼い主の姓とペットの名 前で構成される匿名型です。
    内部結合の実行
2020/05/20 • • Edit Online
 
        LastName が"Huff"の Person オブジェクトは、Pet.Owner がその Person に等しい Pet オブジェクトがないため、結果 セットに表示されません。
例 - 複合キーの結合
1 つのプロパティだけに基づいて要素を関連付ける代わりに、複合キーを使用して、複数のプロパティに基づいて要素を比較で きます。 これを行うには、各コレクションに対してキー セレクター関数を指定し、比較するプロパティで構成された匿名型を返し ます。 プロパティにラベルを付ける場合は、各キーの匿名型に同じラベルを付ける必要があります。 また、プロパティは、同じ順 序で表示する必要があります。
  次の例は、 Employee オブジェクトのリストと Student オブジェクトのリストを使用して、学生でもある社員を調べます。 これらの
  class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
class Pet {
    public string Name { get; set; }
    public Person Owner { get; set; }
}
/// <summary>
/// Simple inner join.
/// </summary>
public static void InnerJoinExample()
{
    Person magnus = new Person { FirstName = "Magnus", LastName = "Hedlund" };
    Person terry = new Person { FirstName = "Terry", LastName = "Adams" };
    Person charlotte = new Person { FirstName = "Charlotte", LastName = "Weiss" };
    Person arlene = new Person { FirstName = "Arlene", LastName = "Huff" };
    Person rui = new Person { FirstName = "Rui", LastName = "Raposo" };
    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet bluemoon = new Pet { Name = "Blue Moon", Owner = rui };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };
    // Create two lists.
    List<Person> people = new List<Person> { magnus, terry, charlotte, arlene, rui };
    List<Pet> pets = new List<Pet> { barley, boots, whiskers, bluemoon, daisy };
    // Create a collection of person-pet pairs. Each element in the collection
    // is an anonymous type containing both the person's name and their pet's name.
    var query = from person in people
                join pet in pets on person equals pet.Owner
                select new { OwnerName = person.FirstName, PetName = pet.Name };
    foreach (var ownerAndPet in query)
    {
        Console.WriteLine($"\"{ownerAndPet.PetName}\" is owned by {ownerAndPet.OwnerName}");
    }
}
// This code produces the following output:
//
// "Daisy" is owned by Magnus
// "Barley" is owned by Terry
// "Boots" is owned by Terry
// "Whiskers" is owned by Charlotte
// "Blue Moon" is owned by Rui

   型の両方に、String 型の   プロパティと   プロパティがあります。 それぞれのリストの要素から結合キーを作 成する関数が、各要素の   プロパティと   プロパティで構成された匿名型を返します。 結合操作により、 これらの複合キーが等しいかどうか比較され、それぞれのリストの氏名が一致するオブジェクトのペアが返されます。
FirstName
LastName
    FirstName
LastName
      class Employee
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int EmployeeID { get; set; }
}
class Student
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int StudentID { get; set; }
}
/// <summary>
/// Performs a join operation using a composite key.
/// </summary>
public static void CompositeKeyJoinExample()
{
    // Create a list of employees.
    List<Employee> employees = new List<Employee> {
        new Employee { FirstName = "Terry", LastName = "Adams", EmployeeID = 522459 },
         new Employee { FirstName = "Charlotte", LastName = "Weiss", EmployeeID = 204467 },
         new Employee { FirstName = "Magnus", LastName = "Hedland", EmployeeID = 866200 },
         new Employee { FirstName = "Vernette", LastName = "Price", EmployeeID = 437139 } };
    // Create a list of students.
    List<Student> students = new List<Student> {
        new Student { FirstName = "Vernette", LastName = "Price", StudentID = 9562 },
        new Student { FirstName = "Terry", LastName = "Earls", StudentID = 9870 },
        new Student { FirstName = "Terry", LastName = "Adams", StudentID = 9913 } };
    // Join the two data sources based on a composite key consisting of first and last name,
    // to determine which employees are also students.
    IEnumerable<string> query = from employee in employees
                                join student in students
                                on new { employee.FirstName, employee.LastName }
                                equals new { student.FirstName, student.LastName }
                                select employee.FirstName + " " + employee.LastName;
    Console.WriteLine("The following people are both employees and students:");
    foreach (string name in query)
        Console.WriteLine(name);
}
// This code produces the following output:
//
// The following people are both employees and students:
// Terry Adams
// Vernette Price
 例 - 複数の結合
任意の数の結合操作を相互に追加して、複数の結合を実行できます。C#の各 join 句は、指定されたデータソースを前
の結合の結果に関連付けます。
次の例は、 Person オブジェクトのリスト、 Cat オブジェクトのリスト、 Dog オブジェクトのリストの 3 つのコレクションを作成しま す。
   C#の最初の join 句では、   と一致する   オブジェクトに基づいて飼い主と猫を一致させます。この操作
Cat.Owner
Person
  
 で、   オブジェクトと   が含まれた匿名型のシーケンスが返されます。
 C#の2番目の join 句では、Person 型の Owner プロパティと動物の名前の最初の文字で構成される複合キーに基づい て、最初の結合で返された匿名型を、指定された犬のリストの Dog オブジェクトに関連付けます。この操作で、一致するそれ ぞれのペアの Cat.Name プロパティと Dog.Name プロパティが含まれた匿名型のシーケンスが返されます。これは内部結合であ るため、2 番目のデータ ソースに一致するものが存在する、最初のデータ ソースのオブジェクトのみが返されます。
      Person
  Cat.Name
  class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
class Pet {
    public string Name { get; set; }
    public Person Owner { get; set; }
}
class Cat : Pet {}
class Dog : Pet {}
public static void MultipleJoinExample()
{
    Person magnus = new Person { FirstName = "Magnus", LastName = "Hedlund" };
    Person terry = new Person { FirstName = "Terry", LastName = "Adams" };
    Person charlotte = new Person { FirstName = "Charlotte", LastName = "Weiss" };
    Person arlene = new Person { FirstName = "Arlene", LastName = "Huff" };
    Person rui = new Person { FirstName = "Rui", LastName = "Raposo" };
    Person phyllis = new Person { FirstName = "Phyllis", LastName = "Harris" };
    Cat barley = new Cat { Name = "Barley", Owner = terry };
    Cat boots = new Cat { Name = "Boots", Owner = terry };
    Cat whiskers = new Cat { Name = "Whiskers", Owner = charlotte };
    Cat bluemoon = new Cat { Name = "Blue Moon", Owner = rui };
    Cat daisy = new Cat { Name = "Daisy", Owner = magnus };
    Dog fourwheeldrive = new Dog { Name = "Four Wheel Drive", Owner = phyllis };
    Dog duke = new Dog { Name = "Duke", Owner = magnus };
    Dog denim = new Dog { Name = "Denim", Owner = terry };
    Dog wiley = new Dog { Name = "Wiley", Owner = charlotte };
    Dog snoopy = new Dog { Name = "Snoopy", Owner = rui };
    Dog snickers = new Dog { Name = "Snickers", Owner = arlene };
    // Create three lists.
    List<Person> people =
        new List<Person> { magnus, terry, charlotte, arlene, rui, phyllis };
    List<Cat> cats =
        new List<Cat> { barley, boots, whiskers, bluemoon, daisy };
    List<Dog> dogs =
        new List<Dog> { fourwheeldrive, duke, denim, wiley, snoopy, snickers };
    // The first join matches Person and Cat.Owner from the list of people and
    // cats, based on a common Person. The second join matches dogs whose names start
    // with the same letter as the cats that have the same owner.
    var query = from person in people
                join cat in cats on person equals cat.Owner
                join dog in dogs on
                new { Owner = person, Letter = cat.Name.Substring(0, 1) }
                equals new { dog.Owner, Letter = dog.Name.Substring(0, 1) }
                select new { CatName = cat.Name, DogName = dog.Name };
    foreach (var obj in query)
    {

{
 例 - グループ化結合を使用した内部結合 グループ結合を使用して内部結合を実装する方法を次の例に示します。
query1 で、 Person オブジェクトのリストは、 Pet.Owner プロパティと一致する に基づいて、 Pet オブジェクトのリス トにグループ結合されます。グループ結合によって、それぞれのグループが オブジェクトおよび一致する Pet オブジェク トのシーケンスで構成された、中間グループのコレクションが作成されます。
2番目の from 句をクエリに追加すると、シーケンスのシーケンスが1つの長いシーケンスに結合(または平坦化)されます。 最後のシーケンスの要素の型は、 select 句で指定されます。 この例では、この型は、一致する各ペアの Person.FirstName プロパティと Pet.Name プロパティで構成された匿名型です。
の結果は、 into 句のない join 句を使用して内部結合を実行することで得られた結果セットと同じです。 変数は、これと同等のクエリを示しています。
    Person
 Person
    query1
  query2
              Console.WriteLine(
            $"The cat \"{obj.CatName}\" shares a house, and the first letter of their name, with \"
{obj.DogName}\".");
    }
}
// This code produces the following output:
//
// The cat "Daisy" shares a house, and the first letter of their name, with "Duke".
// The cat "Whiskers" shares a house, and the first letter of their name, with "Wiley".
  class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
class Pet {
    public string Name { get; set; }
    public Person Owner { get; set; }
}
/// <summary>
/// Performs an inner join by using GroupJoin().
/// </summary>
public static void InnerGroupJoinExample()
{
    Person magnus = new Person { FirstName = "Magnus", LastName = "Hedlund" };
    Person terry = new Person { FirstName = "Terry", LastName = "Adams" };
    Person charlotte = new Person { FirstName = "Charlotte", LastName = "Weiss" };
    Person arlene = new Person { FirstName = "Arlene", LastName = "Huff" };
    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet bluemoon = new Pet { Name = "Blue Moon", Owner = terry };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };
    // Create two lists.
    List<Person> people = new List<Person> { magnus, terry, charlotte, arlene };
    List<Pet> pets = new List<Pet> { barley, boots, whiskers, bluemoon, daisy };
    var query1 = from person in people
                 join pet in pets on person equals pet.Owner into gj
                 from subpet in gj
                 select new { OwnerName = person.FirstName, PetName = subpet.Name };
Console.WriteLine("Inner join using GroupJoin():");

   Console.WriteLine("Inner join using GroupJoin():");
 参照
Join
GroupJoin グループ化結合の実行 左外部結合の実行 匿名型
   }
foreach (var v in query1)
{
    Console.WriteLine($"{v.OwnerName} - {v.PetName}");
}
var query2 = from person in people
             join pet in pets on person equals pet.Owner
             select new { OwnerName = person.FirstName, PetName = pet.Name };
Console.WriteLine("\nThe equivalent operation using Join():");
foreach (var v in query2)
    Console.WriteLine($"{v.OwnerName} - {v.PetName}");
// This code produces the following output:
//
// Inner join using GroupJoin():
// Magnus - Daisy
// Terry - Barley
// Terry - Boots
// Terry - Blue Moon
// Charlotte - Whiskers
//
// The equivalent operation using Join():
// Magnus - Daisy
// Terry - Barley
// Terry - Boots
// Terry - Blue Moon
// Charlotte - Whiskers
 
      グループ結合は、階層データ構造を作成する場合に便利です。 これは、最初のコレクションの各要素と、2 番目のコレクション の相関関係を持つ要素のセットを組み合わせたものです。
たとえば、 Student という名前のクラスまたはリレーショナル データベース テーブルに、 Id と Name という 2 つのフィールドが含 まれているとします。 Course という名前の2番目のクラスまたはリレーショナルデータベーステーブルには、 と
という 2 つのフィールドが含まれているとします。 この 2 つのデータ ソースのグループ結合は、 と の一致に基づいて、 Course オブジェクトのコレクションを持つ各 Student をグループ化します (コレクショ
ンは空の場合もあります)。
   StudentId
  Student.Id
 CourseTitle
   Course.StudentId
    NOTE
最初のコレクションの各要素は、2 番目のコレクションに相関関係を持つ要素があるかどうかにかかわらず、グループ結合の結果セットに表示 されます。 相関関係を持つ要素が見つからない場合、その要素の相関関係を持つ要素のシーケンスは空です。 そのため、結果セレクター は最初のコレクションのすべての要素にアクセスできます。 これは、非グループ結合の結果セレクターとは異なります。非グループ結合の結果 セレクターは、2 番目のコレクションに一致するものがない最初のコレクションの要素にアクセスすることはできません。
     WARNING
Enumerable.GroupJoin には、従来のリレーショナル データベースの用語に直接相当するものはありません。 ただし、このメソッドでは内部 結合と左外部結合のスーパーセットが実装されます。 これらの操作はどちらも、グループ化結合の観点から記述できます。 詳細について は、「結合操作」と「Entity Framework Core」の「GroupJoin」を参照してください。
 この記事の最初の例では、グループ結合を実行する方法を示します。 2 つ目の例では、グループ結合を使用して XML 要素 を作成する方法を示します。
例 - グループ結合
次の例では、 Pet.Owner プロパティと一致する Person に基づいて、 Person 型と Pet 型のオブジェクトのグループ結合を実 行します。 一致ごとに要素のペアを生成する非グループ結合と異なり、グループ結合は最初のコレクションの要素ごとに 1 つの オブジェクト(この例では Person オブジェクト)のみを作成します。2番目のコレクションの対応する要素(この例では Pet オ ブジェクト)が1つのコレクションにグループ化されます。最後に、結果セレクター機能により、Person.FirstName と、Pet オブ ジェクトのコレクションで構成される一致ごとに匿名型が作成されます。
     グループ結合の実行
2020/11/02 • • Edit Online
 
    例 - XML を作成するグループ結合
グループ結合は、LINQ to XML を使用した XML の作成に適しています。 次の例は前の例に似ていますが、匿名型を作成 するのではなく、結果セレクター機能により、結合されたオブジェクトを表す XML 要素を作成する点が異なります。
  class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
class Pet {
    public string Name { get; set; }
    public Person Owner { get; set; }
}
/// <summary>
/// This example performs a grouped join.
/// </summary>
public static void GroupJoinExample()
{
    Person magnus = new Person { FirstName = "Magnus", LastName = "Hedlund" };
    Person terry = new Person { FirstName = "Terry", LastName = "Adams" };
    Person charlotte = new Person { FirstName = "Charlotte", LastName = "Weiss" };
    Person arlene = new Person { FirstName = "Arlene", LastName = "Huff" };
    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet bluemoon = new Pet { Name = "Blue Moon", Owner = terry };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };
    // Create two lists.
    List<Person> people = new List<Person> { magnus, terry, charlotte, arlene };
    List<Pet> pets = new List<Pet> { barley, boots, whiskers, bluemoon, daisy };
    // Create a list where each element is an anonymous type
    // that contains the person's first name and a collection of
    // pets that are owned by them.
    var query = from person in people
                join pet in pets on person equals pet.Owner into gj
                select new { OwnerName = person.FirstName, Pets = gj };
    foreach (var v in query)
    {
} }
// Output the owner's name.
Console.WriteLine($"{v.OwnerName}:");
// Output each of the owner's pet's names.
foreach (Pet pet in v.Pets)
    Console.WriteLine($"  {pet.Name}");
// This code produces the following output:
//
// Magnus:
//   Daisy
// Terry:
// Barley
// Boots
//   Blue Moon
// Charlotte:
//   Whiskers
// Arlene:

    関連項目
Join
  class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
class Pet {
    public string Name { get; set; }
    public Person Owner { get; set; }
}
/// <summary>
/// This example creates XML output from a grouped join.
/// </summary>
public static void GroupJoinXMLExample()
{
    Person magnus = new Person { FirstName = "Magnus", LastName = "Hedlund" };
    Person terry = new Person { FirstName = "Terry", LastName = "Adams" };
    Person charlotte = new Person { FirstName = "Charlotte", LastName = "Weiss" };
    Person arlene = new Person { FirstName = "Arlene", LastName = "Huff" };
    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet bluemoon = new Pet { Name = "Blue Moon", Owner = terry };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };
    // Create two lists.
    List<Person> people = new List<Person> { magnus, terry, charlotte, arlene };
    List<Pet> pets = new List<Pet> { barley, boots, whiskers, bluemoon, daisy };
    // Create XML to display the hierarchical organization of people and their pets.
    XElement ownersAndPets = new XElement("PetOwners",
        from person in people
        join pet in pets on person equals pet.Owner into gj
        select new XElement("Person",
            new XAttribute("FirstName", person.FirstName),
            new XAttribute("LastName", person.LastName),
            from subpet in gj
            select new XElement("Pet", subpet.Name)));
    Console.WriteLine(ownersAndPets);
}
// This code produces the following output:
//
// <PetOwners>
//
//
//
//
//
//
//
//
//
//
//
//
// </PetOwners>
<Person FirstName="Magnus" LastName="Hedlund">
  <Pet>Daisy</Pet>
</Person>
<Person FirstName="Terry" LastName="Adams">
<Pet>Barley</Pet>
<Pet>Boots</Pet>
<Pet>Blue Moon</Pet>
</Person>
<Person FirstName="Charlotte" LastName="Weiss">
  <Pet>Whiskers</Pet>
</Person>
<Person FirstName="Arlene" LastName="Huff" />

    GroupJoin
内部結合の実行 左外部結合の実行 匿名型

        左外部結合は、最初のコレクションの各要素を、2 つ目のコレクション内にある要素との相関関係の有無にかかわらず返す結 合です。 LINQ を使用すると、グループ結合の結果に対して DefaultIfEmpty メソッドを呼び出すことで、左外部結合を実行 できます。
例
次の例は、グループ結合の結果に対して DefaultIfEmpty メソッドを使用し、左外部結合を実行する方法を示しています。
2 つのコレクションの左外部結合を作成するための最初のステップは、グループ結合を使用して内部結合を実行することです。 (このプロセスの詳細については、「内部結合の実行」参照してください。)この例では、 Pet.Owner に一致する Person オブ ジェクトに基づいて、 Person オブジェクトの一覧が Pet オブジェクトの一覧に内部結合されています。
2 つ目のステップは、最初 (左側) のコレクションの各要素を結果セットに含めることです。このとき、その要素と一致するものが右 のコレクションにあるかどうかは考慮しません。 これを行うには、グループ結合内の一致する要素の各シーケンスに対し て、DefaultIfEmptyを呼び出します。この例では、Pet オブジェクトに一致する各シーケンスに対して、DefaultIfEmptyが 呼び出されています。 このメソッドは、 Person オブジェクトに対して一致する Pet オブジェクトのシーケンスが空である場合 に、単一の既定値を含んだコレクションを返します。これにより、各 Person オブジェクトが結果コレクション内に表されることが 保証されます。
         NOTE
参照型の既定値は null です。そのためこのコード例では、各 Pet コレクションの各要素にアクセスする前に Null 参照がチェックされま す。
 左外部結合の実行
2020/03/18 • • Edit Online
 
       関連項目
Join
GroupJoin 内部結合の実行 グループ化結合の実行 匿名型
  class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
class Pet {
    public string Name { get; set; }
    public Person Owner { get; set; }
}
public static void LeftOuterJoinExample()
{
    Person magnus = new Person { FirstName = "Magnus", LastName = "Hedlund" };
    Person terry = new Person { FirstName = "Terry", LastName = "Adams" };
    Person charlotte = new Person { FirstName = "Charlotte", LastName = "Weiss" };
    Person arlene = new Person { FirstName = "Arlene", LastName = "Huff" };
    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet bluemoon = new Pet { Name = "Blue Moon", Owner = terry };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };
    // Create two lists.
    List<Person> people = new List<Person> { magnus, terry, charlotte, arlene };
    List<Pet> pets = new List<Pet> { barley, boots, whiskers, bluemoon, daisy };
    var query = from person in people
                join pet in pets on person equals pet.Owner into gj
                from subpet in gj.DefaultIfEmpty()
                select new { person.FirstName, PetName = subpet?.Name ?? String.Empty };
    foreach (var v in query)
    {
        Console.WriteLine($"{v.FirstName+":",-15}{v.PetName}");
    }
}
// This code produces the following output:
//
// Magnus:
// Terry:
// Terry:
// Terry:
// Charlotte:
// Arlene:
Daisy
Barley
Boots
Blue Moon
Whiskers

   この例では、結合操作の結果の順序を指定する方法を示しています。 順序付けは結合後に実行されることに注意してくださ い。結合の前に1つ以上のソースシーケンスを指定した orderby 句を使用することもできますが、一般にこの方法は推奨さ れません。 LINQ プロバイダーによっては、結合後にその順序付けを維持しない場合があります。
例
このクエリは、グループ結合を作成した後、スコープ内に残っているカテゴリ要素に基づいてグループを並べ替えます。 匿名型初 期化子の内部では、結果のシーケンス内の一致するすべての要素がサブクエリによって順序付けられます。
    join 句の結果の順序指定 2020/03/18 • • Edit Online
       class HowToOrderJoins
     {
         #region Data
         class Product
         {
             public string Name { get; set; }
             public int CategoryID { get; set; }
         }
         class Category
         {
             public string Name { get; set; }
             public int ID { get; set; }
         }
         // Specify the first data source.
         List<Category> categories = new List<Category>()
 {
     new Category(){Name="Beverages", ID=001},
     new Category(){ Name="Condiments", ID=002},
     new Category(){ Name="Vegetables", ID=003},
     new Category() {  Name="Grains", ID=004},
     new Category() {  Name="Fruit", ID=005}
};
         // Specify the second data source.
         List<Product> products = new List<Product>()
{
   new Product{Name="Cola",  CategoryID=001},
   new Product{Name="Tea",  CategoryID=001},
   new Product{Name="Mustard", CategoryID=002},
   new Product{Name="Pickles", CategoryID=002},
   new Product{Name="Carrots", CategoryID=003},
   new Product{Name="Bok Choy", CategoryID=003},
   new Product{Name="Peaches", CategoryID=005},
   new Product{Name="Melons", CategoryID=005},
};
#endregion
static void Main()
{
    HowToOrderJoins app = new HowToOrderJoins();
    app.OrderJoin1();
    // Keep console window open in debug mode.
    Console.WriteLine("Press any key to exit.");
    Console.ReadKey();
}
void OrderJoin1()

      参照
統合言語クエリ (LINQ) orderby 句
join 句
 void OrderJoin1()
{
    var groupJoinQuery2 =
        from category in categories
        join prod in products on category.ID equals prod.CategoryID into prodGroup
        orderby category.Name
        select new
        {
            Category = category.Name,
            Products = from prod2 in prodGroup
                       orderby prod2.Name
                       select prod2
};
    foreach (var productGroup in groupJoinQuery2)
    {
} }
    /* Output:
        Beverages
Cola 1
          Tea        1
        Condiments
Mustard 2
          Pickles    2
        Fruit
Melons 5
          Peaches    5
        Grains
        Vegetables
          Bok Choy   3
          Carrots    3
*/ }
Console.WriteLine(productGroup.Category);
foreach (var prodItem in productGroup.Products)
{
    Console.WriteLine($"  {prodItem.Name,-10} {prodItem.CategoryID}");
}

      この例では、複数のキーを使用して一致項目を定義する結合操作の実行方法を示します。 この操作は複合キーを使用して 行います。 比較対象とする値を使用し、匿名型または名前付きの型として複合キーを作成します。 メソッドの境界を越えてク エリ変数が渡される場合は、キーの Equals と GetHashCode をオーバーライドする名前付きの型を使用してください。 各キー のプロパティ名とその出現順序は一致している必要があります。
例
次の例では、複合キーを使用して 3 つのテーブルのデータを結合する方法を示します。
複合キーの型の推定は、キーに含まれるプロパティの名前とその出現順序によって異なります。 ソース シーケンス内のプロパティ の名前が異なる場合は、キー内で新しい名前を割り当てる必要があります。 たとえば、 Orders テーブルと OrderDetails テーブルの列にそれぞれ異なる名前が使用されている場合、匿名型で同じ名前を割り当てることにより、復号キーを作成でき ます。
複合キーは、 group 句でも使用できます。 参照
統合言語クエリ (LINQ) join 句
group 句
    var query = from o in db.Orders
    from p in db.Products
    join d in db.OrderDetails
        on new {o.OrderID, p.ProductID} equals new {d.OrderID, d.ProductID} into details
        from d in details
        select new {o.OrderID, p.ProductID, d.UnitPrice};
       join...on new {Name = o.CustomerName, ID = o.CustID} equals
    new {Name = d.CustName, ID = d.CustID }
 複合キーを使用した結合
2020/03/18 • • Edit Online
 
   この例では、 join 句では実現できない結合操作を実行する方法を示しています。 クエリ式の join 句は、最も一般的な 種類の結合操作である等結合用に限定され、また、それを目的に最適化されています。 等結合の実行時には、 join 句を 使用することで、ほとんどの場合に最適なパフォーマンスが得られます。
ただし、 join 句は、次の場合には使用できません。
結合が非等値の式に基づいている場合 (非等結合)。 結合が等値または非等値の複数の式に基づいている場合。
結合操作の前に、右辺 (内部) のシーケンスに一時的な範囲変数を導入する必要がある場合。
等結合ではない結合を実行するには、複数の from 句を使用して、各データソースを個別に導入することができます。その 後、 where 句の述語式を各ソースの範囲変数に適用します。 式は、メソッド呼び出しの形式にすることもできます。
例
次の例の最初のメソッドは、単純なクロス結合を示しています。 クロス結合は、非常に大きな結果セットを生成することがある ので、注意して使用する必要があります。 ただし、追加のクエリの実行対象となるソース シーケンスを作成するためのいくつかの シナリオでは便利な場合があります。
2番目のメソッドは、左辺のカテゴリの一覧にカテゴリIDが含まれているすべての製品のシーケンスを生成します。 let 句と Contains メソッドを使用して一時配列を作成していることに注意してください。クエリの前に配列を作成し、最初の from
句を削除することもできます。
    NOTE
このようなカスタム結合操作を、複数の from 句を使用した内部コレクションへのアクセスと混同しないでください。 詳しくは、「join 句」をご 覧ください。
  カスタム結合操作の実行
2020/03/18 • • Edit Online
     class CustomJoins
{
#region Data
    class Product
    {
        public string Name { get; set; }
        public int CategoryID { get; set; }
    }
    class Category
    {
        public string Name { get; set; }
        public int ID { get; set; }
    }
    // Specify the first data source.
    List<Category> categories = new List<Category>()
    {
        new Category(){Name="Beverages", ID=001},
        new Category(){ Name="Condiments", ID=002},
        new Category(){ Name="Vegetables", ID=003},

  } }
};
// Specify the second data source.
List<Product> products = new List<Product>()
{
    new Product{Name="Tea",  CategoryID=001},
    new Product{Name="Mustard", CategoryID=002},
    new Product{Name="Pickles", CategoryID=002},
    new Product{Name="Carrots", CategoryID=003},
    new Product{Name="Bok Choy", CategoryID=003},
    new Product{Name="Peaches", CategoryID=005},
    new Product{Name="Melons", CategoryID=005},
    new Product{Name="Ice Cream", CategoryID=007},
    new Product{Name="Mackerel", CategoryID=012},
};
#endregion
static void Main()
{
    CustomJoins app = new CustomJoins();
    app.CrossJoin();
    app.NonEquijoin();
    Console.WriteLine("Press any key to exit.");
    Console.ReadKey();
}
void CrossJoin()
{
    var crossJoinQuery =
        from c in categories
        from p in products
        select new { c.ID, p.Name };
    Console.WriteLine("Cross Join Query:");
    foreach (var v in crossJoinQuery)
    {
        Console.WriteLine($"{v.ID,-5}{v.Name}");
    }
}
void NonEquijoin()
{
    /* Output:
Cross Join Query:
1    Tea
1    Mustard
1    Pickles
1    Carrots
1    Bok Choy
1    Peaches
1    Melons
1    Ice Cream
1 Mackerel
2 Tea
var nonEquijoinQuery =
    from p in products
    let catIds = from c in categories
                 select c.ID
    where catIds.Contains(p.CategoryID) == true
    select new { Product = p.Name, CategoryID = p.CategoryID };
Console.WriteLine("Non-equijoin query:");
foreach (var v in nonEquijoinQuery)
{
    Console.WriteLine($"{v.CategoryID,-5}{v.Product}");
}
  
2 Tea
    例
次の例では、クエリは一致するキーに基づいて 2 つのシーケンスを結合する必要があります。内部 (右辺) シーケンスでは、join 句自体より前にキーを取得することはできません。 この結合が join 句を使用して実行された場合は、要素ごとに Split メ ソッドを呼び出す必要があります。複数の from 句を使用すると、クエリは、メソッドを繰り返し呼び出すことのオーバーヘッドを 回避することができます。 ただし、 join は最適化されるため、この特定の場合には、複数の from 句を使用するよりも処理 が速くなることがあります。 結果は、主に、メソッド呼び出しにかかる負荷に応じて異なります。
    2    Mustard
2    Pickles
2    Carrots
2    Bok Choy
2    Peaches
2    Melons
2 Ice Cream
2 Mackerel
3 Tea
3 Mustard
3    Pickles
3    Carrots
3    Bok Choy
3    Peaches
3    Melons
3    Ice Cream
3    Mackerel
Non-equijoin query:
1 Tea
2 Mustard
2 Pickles
3 Carrots
3    Bok Choy
Press any key to exit.
*/
 class MergeTwoCSVFiles
{
    static void Main()
    {
        // See section Compiling the Code for information about the data files.
        string[] names = System.IO.File.ReadAllLines(@"../../../names.csv");
        string[] scores = System.IO.File.ReadAllLines(@"../../../scores.csv");
        // Merge the data sources using a named type.
        // You could use var instead of an explicit type for the query.
        IEnumerable<Student> queryNamesScores =
            // Split each line in the data files into an array of strings.
            from name in names
            let x = name.Split(',')
            from score in scores
            let s = score.Split(',')
            // Look for matching IDs from the two data files.
            where x[2] == s[0]
            // If the IDs match, build a Student object.
            select new Student()
            {
                FirstName = x[0],
                LastName = x[1],
                ID = Convert.ToInt32(x[2]),
                ExamScores = (from scoreAsText in s.Skip(1)
                              select Convert.ToInt32(scoreAsText)).
                              ToList()
            };
        // Optional. Store the newly created student objects in memory
// for faster access in future queries

   参照
統合言語クエリ (LINQ) join 句
join 句の結果の順序指定
        // for faster access in future queries
        List<Student> students = queryNamesScores.ToList();
        foreach (var student in students)
        {
            Console.WriteLine($"The average score of {student.FirstName} {student.LastName} is
{student.ExamScores.Average()}.");
}
        //Keep console window open in debug mode
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
   } }
class Student
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int ID { get; set; }
    public List<int> ExamScores { get; set; }
}
/* Output:
    The average score of Omelchenko Svetlana is 82.5.
    The average score of O'Donnell Claire is 72.25.
    The average score of Mortensen Sven is 84.5.
    The average score of Garcia Cesar is 88.25.
    The average score of Garcia Debra is 67.
    The average score of Fakhouri Fadi is 92.25.
    The average score of Feng Hanying is 88.
    The average score of Garcia Hugo is 85.75.
    The average score of Tucker Lance is 81.75.
    The average score of Adams Terry is 85.25.
    The average score of Zabokritski Eugene is 83.
    The average score of Tucker Michael is 92.
*/
 
        この例では、ソース コレクション内の可能な null 値を処理する方法を示します。 IEnumerable<T> のようなオブジェクト コレク ションには、値が null の要素を含めることができます。 ソース コレクションが null であるか null の値を持つ要素を含み、クエリで null 値を処理しない場合、クエリを実行すると NullReferenceException がスローされます。
例
次の例に示すように、null 参照の例外を回避する防御的なコーディングをすることができます。
前の例では、where 句によって、カテゴリシーケンス内のすべてのnull要素が除外されます。この手法は、join句でのnull チェックに依存しません。 この例の null 条件式が機能する理由は、 Products.CategoryID が int? 型 ( Nullable<int> の 短縮形) であるためです。
例
join 句で、比較キーの一方だけが null 許容値型である場合、クエリ式でもう一方のキーを null 許容値型にキャストできま
す。 次の例では、 EmployeeID は int? 型の値を含む列であるとします。
    var query1 =
    from c in categories
    where c != null
    join p in products on c.ID equals
        p?.CategoryID
    select new { Category = c.Name, Name = p.Name };
        void TestMethod(Northwind db)
{
    var query =
        from o in db.Orders
        join e in db.Employees
}
    on o.EmployeeID equals (int?)e.EmployeeID
select new { o.OrderID, e.FirstName };
 関連項目
Nullable<T>
統合言語クエリ (LINQ) null 許容値型
クエリ式の null 値の処理 2020/04/02 • • Edit Online
 
    クエリ式のコンテキストで任意のメソッドを呼び出すことができます。 ただし、データ ソースのコンテンツが変更されたり例外がス ローされたりするなどの副作用が生じる可能性のあるクエリ式では、メソッドを呼び出さないようにすることをお勧めします。 この 例では、クエリ式でメソッドを呼び出すときに、例外処理に関する .NET の全般的なガイドラインに違反することなく例外の発生 を避ける方法を示します。 ガイドラインでは、特定のコンテキストで特定の例外がスローされる理由がわかっているときにその例 外をキャッチすることは認められています。 詳細については、「例外の推奨事項」を参照してください。
最後の例では、クエリの実行中に例外をスローする必要がある場合の処理方法を示します。
例
次の例では、例外処理コードをクエリ式の外側に移動する方法を説明します。 この方法は、メソッドがクエリのローカル変数に 依存しない場合にのみ可能です。
    class ExceptionsOutsideQuery
{
    static void Main()
    {
        // DO THIS with a datasource that might
        // throw an exception. It is easier to deal with
        // outside of the query expression.
        IEnumerable<int> dataSource;
        try
        {
            dataSource = GetData();
        }
        catch (InvalidOperationException)
        {
            // Handle (or don't handle) the exception
            // in the way that is appropriate for your application.
            Console.WriteLine("Invalid operation");
            goto Exit;
}
        // If we get here, it is safe to proceed.
        var query = from i in dataSource
select i * i;
        foreach (var i in query)
            Console.WriteLine(i.ToString());
        //Keep the console window open in debug mode
        Exit:
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    // A data source that is very likely to throw an exception!
    static IEnumerable<int> GetData()
    {
        throw new InvalidOperationException();
    }
}
 例
クエリ式の例外の処理
2020/03/18 • • Edit Online
 
   場合によっては、クエリ内からスローされる例外に対する最適な応答は、クエリの実行をすぐに停止することです。 次の例では、 クエリ本体の内部からスローされる例外を処理する方法を示します。 SomeMethodThatMightThrow で、クエリの実行を停止す ることが必要な例外が発生する可能性があるとします。
try ブロックは foreach ループを囲み、クエリ自体を囲むのではありません。 その理由は、 foreach ループがクエリの実際の 実行ポイントであるためです。 詳細については、「LINQ クエリの概要」を参照してください。
       class QueryThatThrows
{
    static void Main()
    {
        // Data source.
        string[] files = { "fileA.txt", "fileB.txt", "fileC.txt" };
        // Demonstration query that throws.
        var exceptionDemoQuery =
            from file in files
            let n = SomeMethodThatMightThrow(file)
            select n;
        // Runtime exceptions are thrown when query is executed.
        // Therefore they must be handled in the foreach loop.
        try
        {
            foreach (var item in exceptionDemoQuery)
            {
                Console.WriteLine($"Processing {item}");
            }
}
        // Catch whatever exception you expect to raise
        // and/or do any necessary cleanup in a finally block
        catch (InvalidOperationException e)
        {
            Console.WriteLine(e.Message);
        }
        //Keep the console window open in debug mode
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    // Not very useful as a general purpose method.
    static string SomeMethodThatMightThrow(string s)
    {
        if (s[4] == 'C')
            throw new InvalidOperationException();
        return @"C:\newFolder\" + s;
    }
}
/* Output:
    Processing C:\newFolder\fileA.txt
    Processing C:\newFolder\fileB.txt
    Operation is not valid due to the current state of the object.
*/
 参照
統合言語クエリ (LINQ)

      I/O バインドのニーズ (ネットワークからのデータの要求、データベースへのアクセス、ファイル システムの読み書きなど) がある場 合、非同期プログラミングを利用できます。 CPU バインドのコードにも、コストのかかる計算の実行など、非同期コードに適した シナリオがあります。
C# は言語レベルで非同期プログラミング モデルを備えており、コールバックに苦労したり、非同期処理をサポートするライブラリ に従ったりしなくても、非同期コードを簡単に記述できます。 C# は、タスク ベースの非同期パターン (TAP) と呼ばれるものに従 います。
非同期モデルの概要
非同期プログラミングの中心になるのは Task オブジェクトと Task<T> オブジェクトであり、非同期操作をモデル化します。こ
れらは、 async および await キーワードによってサポートされています。 ほとんどの場合、モデルは非常に単純です。 I/O バインドのコードでは、 async メソッドの内部で、 Task または Task<T> を返す操作を待機します。
CPU バインドのコードでは、Task.Run メソッドによってバックグラウンド スレッドで開始された操作を待機します。
await キーワードはマジックが行われる場所であり、 await を実行したメソッドの呼び出し元に制御が委譲されます。これに よって最終的に、UIは応答できるようになり、サービスは柔軟性を持つようになります。 async と await 以外にも非同期 コードを実現する方法はありますが、この記事では言語レベルのコンストラクトについて説明します。
I/O バインドの例: Web サービスからデータをダウンロードする
ボタンがクリックされたら Web サービスからデータをダウンロードする必要がありますが UI スレッドはブロックしたくない、といった場
合があります。 これは、次のようにして実現できます。
      private readonly HttpClient _httpClient = new HttpClient();
downloadButton.Clicked += async (o, e) =>
{
    // This line will yield control to the UI as the request
    // from the web service is happening.
    //
    // The UI thread is now free to perform other work.
    var stringData = await _httpClient.GetStringAsync(URL);
    DoSomethingWithData(stringData);
};
 コードでは、Task オブジェクトとの対話に煩わされることなく意図すること(データを非同期的にダウンロードする)が表されてい ます。
CPU バインドの例: ゲームの計算を実行する ボタンをクリックすると画面上の多くの敵にダメージを与えることができるモバイル ゲームを作っています。 ダメージ計算の実行は
負荷が大きく、UI スレッドで実行すると計算の実行中はゲームが停止しているように見えます。
これを処理する最善の方法は、バックグラウンド スレッドを開始して、その中で Task.Run を使って処理を実行し、 await を 使用して結果を大気することです。 このようにすると、処理が行われている間も UI が停止することはありません。
 非同期プログラミング
2021/03/06 • • Edit Online
 
      このコードでは、ボタンのクリック イベントの意図が明らかに表されています。バックグラウンド スレッドを手動で管理する必要はな く、ブロッキングが発生しない方法で行われます。
内部での処理
非同期操作には多数の動作要素が関係します。 Task と Task<T> の内部処理について詳しくは、「非同期の詳細」をご 覧ください。
C#側では、コンパイラによってコードがステートマシンに変換されます。ステートマシンでは、await に達したときの実行の委譲 や、バックグラウンド ジョブが終了したときの実行の再開などが追跡されます。
理論的には、これは非同期処理の約束モデルの実装です。 理解すべき重要事項
非同期コードは I/O バインドと CPU バインドの両方のコードで使うことができますが、使い方はシナリオにより異なります。 非同期コードで使われる Task<T> と Task は、バックグラウンドで行われる処理のモデル化に使われる構成要素です。 キーワード async はメソッドを非同期メソッドに変換し、メソッドの本体で await キーワードを使用できるようにします。 適用された await キーワードは、呼び出しメソッドを中断し、待機中のタスクが完了するまで呼び出し元に制御を戻しま す。
await は、非同期メソッドの中でのみ使用できます。 CPU バインドと I/O バインドの処理
このガイドの最初の2つの例では、CPUバインドとI/Oバインドの処理に対して async および await を使う方法を示しまし た。 行う必要のあるジョブが I/O バインドか CPU バインドかを識別できることが重要です。これは、コードのパフォーマンスに大き く影響し、特定の構成の誤った使用につながるおそれがあります。
コードを記述する前に次の 2 点について考える必要があります。
1. コードは何か (データベースのデータなど) を "待機" していますか。
答えが "はい" の場合、その処理は I/O バインド です。 2. コードでは、負荷の大きい計算が実行されますか。
答えが "はい" の場合、その処理は CPU バインド です。
処理が I/O バインド の場合は、 async と await を使いますが、 Task.Run は "使いません"。 タスク並列ライブラリは "使わ
ないでください"。 その理由について詳しくは、「非同期の詳細」をご覧ください。
処理が CPU バインド であり、応答性が重要な場合は、 async と await を使い、 Task.Run を "使って" 別のスレッドで処 理を実行します。 処理がコンカレンシーと並列処理に適している場合は、タスク並列ライブラリを使うことも考慮します。
       private DamageResult CalculateDamageDone()
{
    // Code omitted:
    //
    // Does an expensive calculation and returns
    // the result of that calculation.
}
calculateButton.Clicked += async (o, e) =>
{
    // This line will yield control to the UI while CalculateDamageDone()
    // performs its work. The UI thread is free to perform other work.
    var damageResult = await Task.Run(() => CalculateDamageDone());
    DisplayDamage(damageResult);
};
 
  さらに、常にコードの実行を測定する必要があります。 たとえば、マルチスレッドでのコンテキスト切り替えのオーバーヘッドと比較 して、CPU バインドの処理の負荷がそれほど大きくないことがわかる場合があります。 すべての選択肢にはトレードオフがあり、 状況に合った適切なトレードオフを選ぶ必要があります。
その他の例
以下では、C# で非同期コードを記述するさまざまな方法がわかる例を示します。 実際に遭遇する可能性があるいくつかの異 なるシナリオを使います。
ネットワークからデータを抽出する
このスニペットでは、https://dotnetfoundation.org にあるホームページから HTML がダウンロードされ、HTML に文字列 ".NET" が出現する回数が数えられます。 ASP.NET を使用して Web API コントローラー メソッドが定義され、そのメソッドによっ てこのタスクが実行されて、値が返されます。
    NOTE
運用コードで HTML の解析の実行を計画している場合は、正規表現を使用しないでください。 代わりに解析ライブラリを使用します。
     private readonly HttpClient _httpClient = new HttpClient();
[HttpGet, Route("DotNetCount")]
public async Task<int> GetDotNetCount()
{
    // Suspends GetDotNetCount() to allow the caller (the web server)
    // to accept another request, rather than blocking on this one.
    var html = await _httpClient.GetStringAsync("https://dotnetfoundation.org");
    return Regex.Matches(html, @"\.NET").Count;
}
 次に示すのはユニバーサル Windows アプリ用に記述された同じシナリオであり、ボタンがクリックされたら同じタスクを実行しま す。
    private readonly HttpClient _httpClient = new HttpClient();
private async void OnSeeTheDotNetsButtonClick(object sender, RoutedEventArgs e)
{
    // Capture the task handle here so we can await the background task later.
    var getDotNetFoundationHtmlTask = _httpClient.GetStringAsync("https://dotnetfoundation.org");
    // Any other work on the UI thread can be done here, such as enabling a Progress Bar.
    // This is important to do here, before the "await" call, so that the user
    // sees the progress bar before execution of this method is yielded.
    NetworkProgressBar.IsEnabled = true;
    NetworkProgressBar.Visibility = Visibility.Visible;
    // The await operator suspends OnSeeTheDotNetsButtonClick(), returning control to its caller.
    // This is what allows the app to be responsive and not block the UI thread.
    var html = await getDotNetFoundationHtmlTask;
    int count = Regex.Matches(html, @"\.NET").Count;
    DotNetCountLabel.Text = $"Number of .NETs on dotnetfoundation.org: {count}";
    NetworkProgressBar.IsEnabled = false;
    NetworkProgressBar.Visibility = Visibility.Collapsed;
}
 複数タスクの完了を待機する

   複数のデータを同時に取得することが必要になる場合があります。 Task APIには2つのメソッドTask.WhenAllと Task.WhenAny が含まれており、これらを使用して、複数のバックグラウンド ジョブで非ブロッキング待機を実行する非同期コー ドを記述できます。
次の例では、一連の userId に対する User データを取得する方法を示します。
     public async Task<User> GetUserAsync(int userId)
{
    // Code omitted:
    //
    // Given a user Id {userId}, retrieves a User object corresponding
    // to the entry in the database with {userId} as its Id.
}
public static async Task<IEnumerable<User>> GetUsersAsync(IEnumerable<int> userIds)
{
    var getUserTasks = new List<Task<User>>();
    foreach (int userId in userIds)
    {
        getUserTasks.Add(GetUserAsync(userId));
    }
    return await Task.WhenAll(getUserTasks);
}
 LINQ を使ってさらに簡潔に記述する別の方法を次に示します。
    public async Task<User> GetUserAsync(int userId)
{
    // Code omitted:
    //
    // Given a user Id {userId}, retrieves a User object corresponding
    // to the entry in the database with {userId} as its Id.
}
public static async Task<User[]> GetUsersAsync(IEnumerable<int> userIds)
{
    var getUserTasks = userIds.Select(id => GetUserAsync(id));
    return await Task.WhenAll(getUserTasks);
}
 コードは少ないですが、LINQ と非同期コードを併用するときは注意してください。 LINQ は遅延実行を使うので、生成された シーケンスを .ToList() または .ToArray() の呼び出しで強制的に反復処理させない限り、 foreach ループ内で行われた 非同期呼び出しはすぐに実行されません。
重要な情報とアドバイス 非同期プログラミングには、留意することで予期しない動作を防ぐことができる細かい事柄がいくつかあります。
async メソッドの本体に await キーワードが含まれないと、何も行われません。
これは、忘れてはならない重要なことです。 await が async メソッドの本体で使用されていない場合、C#コンパイラ では警告が生成されますが、コードは通常のメソッドと同様にコンパイルされて実行されます。 非同期メソッドに対して C# コンパイラによって生成されるステート マシンでは何も行われないため、これは非常に非効率的です。
記述するすべての非同期メソッド名のサフィックスとして、"Async" を追加する必要があります
これは、同期メソッドと非同期メソッドの区別をより簡単にするために、.NET で使われる規則です。 コードによって明示的に呼 び出されない一部のメソッド (イベント ハンドラーや Web コントローラー メソッドなど) には、必ずしも当てはまりません。 そのよう なメソッドはコードでは明示的に呼び出されないため、明示的な命名はそれほど重要ではありません。
   
     はイベント ハンドラーに対してのみ使う必要があります。
 イベントには戻り値の型がないため、 async void は非同期イベント ハンドラーの動作を可能にする唯一の方法です (したがっ て、 Task と Task<T> を使うことはできません)。 async void のその他の使用はすべて TAP モデルに従わないので、使うのが 難しい場合があります。以下はその例です。
async void メソッドでスローされた例外を、そのメソッドの外部でキャッチすることはできません。
async void メソッドをテストするのは困難です。
async void メソッドでは、呼び出し元がそれを非同期と予期していないと、悪い副作用が発生する可能性がありま す。
LINQ 式での非同期ラムダの使用は慎重に行う必要があります
LINQ 内のラムダ式では、遅延実行が使用されます。つまり、予期していないときにコードが実行される可能性があります。 こ れにブロッキング タスクを組み込んだ場合、正しく作成されていないと、簡単にデッドロックが発生します。 さらに、このように非同 期コードを入れ子にすると、コードの実行についての推論も難しくなります。 非同期と LINQ は強力ですが、併用するときは可 能な限り慎重かつ明確にする必要があります。
タスクを待機するコードは非ブロッキング方式で作成します
Task が完了するのを待機するための手段として現在のスレッドをブロックすると、デッドロックおよびコンテキストスレッドのブロッ クが発生するおそれがあり、複雑なエラー処理が必要になることがあります。 次の表では、非ブロッキング方式でタスクの待機に 対処する方法について説明します。
            await
await Task.WhenAny
await Task.WhenAll
await Task.Delay
Task.Wait または Task.WaitAny Task.WaitAll
Thread.Sleep
Task.Result
バックグラウンド タスクの結果の取得 任意のタスクの完了の待機 すべてのタスクの完了の待機
一定期間の待機
                          可能な場合は ValueTask の使用を検討する
非同期メソッドから Task オブジェクトを返すと、特定のパスでパフォーマンスのボトルネックが発生する可能性があります。
Task は参照型です。したがって、これを使うことは、オブジェクトを割り当てることを意味します。 async 修飾子で宣言された メソッドがキャッシュされた結果を返すか、同期的に完了する場合、追加の割り当ては、コードのパフォーマンスが重要なセクショ
ンにおいて大きな時間コストにつながります。 厳密なループ処理でこのような割り当てが発生した場合、コストがかかる場合が あります。 詳しくは、「一般化された async の戻り値の型」をご覧ください。
ConfigureAwait(false) の使用を検討する
"どのような場合に Task.ConfigureAwait(Boolean) メソッドを使用する必要があるか" ということが問題になることがよくありま す。このメソッドを使用すると、Task インスタンスでそのawaiterを構成できます。これは重要な考慮事項であり、それを正し く設定しないと、パフォーマンスに影響し、デッドロックが発生する可能性があります。 ConfigureAwait の詳細については、 「ConfigureAwait の FAQ」を参照してください。
ステートフル性の低いコードを記述します
グローバル オブジェクトの状態または特定のメソッドの実行に依存しないでください。 代わりに、メソッドの戻り値のみに依存する ようにします。 なぜでしょうか。
  コードを理解しやすくなります。
 async void
 
     コードをテストしやすくなります。 非同期コードと同期コードの混在がはるかに簡単になります。 一般には、競合状態を完全に回避できます。 戻り値に依存すると、非同期コードの調整が簡単になります。 (ボーナス) 依存関係の挿入で問題なく動作します。
推奨される目標は、完全またはほぼ完全な参照の透過性をコードで実現することです。 そうすることで、予測、テスト、保守が 非常に容易なコードベースになります。
その他のリソース
「非同期の詳細」では、タスクの動作方法について詳しく説明します。 Async および Await を使用した非同期プログラミング (C#)
Lucian Wischik の「Six Essential Tips for Async」(非同期に関する 6 つの重要なヒント) は、非同期プログラミングのため のすばらしいリソースです。

    パターンでは、値に特定の "図形" を含まれているかどうかをテストし、一致する図形が含まれている場合にその値から情報を "抽出" することができます。 パターン マッチングでは、現在既に使用しているアルゴリズムに対してより簡潔な構文を提供しま す。パターンマッチングアルゴリズムは、既存の構文を使用して今までも作成しています。値をテストする if ステートメントま たは switch ステートメントを記述します。その後、これらのステートメントで一致する値が見つかると、その値から情報を抽出 して使用します。新しい構文要素は、既に使い慣れているステートメントの拡張機能 is と switch です。これらの新しい 拡張機能は、値のテストとその情報の抽出を組み合わせたものです。
この記事では、新しい構文を紹介し、それをどのように使用すると読みやすく簡潔なコードを作成できるかを説明します。 パ ターン マッチングでは、データとデータを操作するメソッドが密接に結び付けられているオブジェクト指向設計とは異なり、データと コードが分離される表現形式が可能になります。
これらの新しい表現形式を説明するために、パターン マッチングのステートメントを使用して幾何学的図形を表す構造体を見 ていきましょう。 おそらく、クラス階層の作成や、オブジェクトのランタイム型に基づいてオブジェクトの動作をカスタマイズするため の仮想メソッドとオーバーライドされたメソッドの作成には慣れているでしょう。
これらの手法は、クラス階層で構造化されていないデータに対しては使うことができません。 データとメソッドが分離されている場 合は、他のツールが必要になります。 新しい "パターン マッチング" コンストラクトを使用すると、より明確な構文でデータを検査 し、そのデータの任意の条件に基づいて制御フローを操作できます。変数の値をテストする if ステートメントと switch ス テートメントを既に記述しました。また、変数の型をテストする is ステートメントも記述しました。"パターンマッチング"により、 これらのステートメントに新しい機能が追加されます。
この記事では、さまざまな幾何学的図形の面積を計算するメソッドを作成します。 ただし、その際に、オブジェクト指向の手法 を使用したり、各種図形に対応するクラス階層を構築したりしません。 代わりに、"パターン マッチング" を使用します。 このサン プルを進めていく際に、このコードと、このコードをオブジェクト階層として構造化した場合を比較してください。 照会して操作す る必要のあるデータがクラス階層ではない場合は、パターン マッチングを使うことで洗練された設計が可能になります。
抽象的な図形の定義から開始して各種具体的な図形クラスを追加する代わりに、幾何学的図形それぞれの簡単なデータの みの定義から始めます。
   パターン マッチ
2020/11/02 • • Edit Online
 
    これらの構造から、特定の図形の面積を計算するメソッドを記述してみましょう。
is 型パターンの式
C#7.0より前では、一連の if ステートメントと is ステートメント内のそれぞれの型をテストする必要がありました。
  public class Square
{
    public double Side { get; }
    public Square(double side)
    {
Side = side; }
}
public class Circle
{
    public double Radius { get; }
    public Circle(double radius)
    {
        Radius = radius;
    }
}
public struct Rectangle
{
    public double Length { get; }
    public double Height { get; }
    public Rectangle(double length, double height)
    {
        Length = length;
        Height = height;
    }
}
public class Triangle
{
    public double Base { get; }
    public double Height { get; }
    public Triangle(double @base, double height)
    {
Base = @base;
        Height = height;
    }
}

  上記のコードは、従来の "型パターン" の式です。変数をテストしてその型を判別し、その型に基づいてさまざまなアクションを実 行します。
このコードは、テストが成功した場合に is 式の拡張機能を使用して変数を代入することで、より簡潔になります。
    public static double ComputeAreaModernIs(object shape)
{
    if (shape is Square s)
        return s.Side * s.Side;
    else if (shape is Circle c)
        return c.Radius * c.Radius * Math.PI;
    else if (shape is Rectangle r)
        return r.Height * r.Length;
    // elided
    throw new ArgumentException(
        message: "shape is not a recognized shape",
        paramName: nameof(shape));
}
 この更新したバージョンでは、変数のテストと適切な型の新しい変数への代入の両方を is 式が実行します。また、このバー ジョンには struct である Rectangle 型が含まれていることに注意してください。 新しい is 式は、値型と参照型で動作し ます。
パターン マッチング式の言語規則は、一致式の結果の誤った使用を回避することにも役立ちます。 上記の例では、変数 s 、 c 、 r はスコープ内のみに存在し、それぞれのパターン マッチング式の結果が true のときに確実に代入されます。 別の場
所でいずれかの変数を使用しようとすると、コンパイラ エラーが生成されます。
この2つの規則を詳しく調べてみましょう。まずはスコープです。 c 変数は、最初の if ステートメントの else 分岐のスコー プ内のみにあります。 s 変数は、メソッド ComputeAreaModernIs のスコープ内にあります。 これは、 if ステートメントの各分 岐によって変数に個別のスコープが確立されるためです。 ただし、 if ステートメント自体はスコープを確立しません。 つまり、
if ステートメントで宣言された変数は、if ステートメント(この場合はメソッド)と同じスコープにあります。この動作はパター ン マッチングに固有のものではありませんが、変数スコープ、 if ステートメント、 else ステートメントに定義されている動作で す。
c 変数と s 変数には、"trueのときに確実に代入する"メカニズムにより、それぞれの if ステートメントがtrueのときに代 入されます。
      public static double ComputeArea(object shape)
{
    if (shape is Square)
    {
        var s = (Square)shape;
        return s.Side * s.Side;
    }
    else if (shape is Circle)
    {
        var c = (Circle)shape;
        return c.Radius * c.Radius * Math.PI;
    }
    // elided
    throw new ArgumentException(
}
message: "shape is not a recognized shape",
paramName: nameof(shape));
 
  これらの規則は、そのパターンを満たさなかったときにパターン マッチング式の結果に誤ってアクセスする可能性が低くなることを意 味します。
パターン マッチング switch ステートメントの使用
時間が経過するにつれて、他の図形の種類をサポートすることが必要になる場合があります。 テストする条件の数が増えるに つれ、 is パターン マッチング式の使用が煩雑になることもわかります。 確認する各型に対して if ステートメントが必要にな るほか、 is 式は、入力が単一の型と一致するかどうかをテストすることに限定されます。 この場合は、 switch パターン マッチ ング式が適していることがわかります。
従来の switch ステートメントはパターン式であり、定数パターンをサポートしていました。 変数は、 case ステートメントで使 用されている任意の定数と比較することができました。
       public static string GenerateMessage(params string[] parts)
{
    switch (parts.Length)
    {
} }
case 0:
    return "No elements to the input";
case 1:
    return $"One element: {parts[0]}";
case 2:
    return $"Two elements: {parts[0]}, {parts[1]}";
default:
    return $"Many elements. Too many to write";
   switch ステートメントでサポートされるパターンは定数パターンのみでした。さらに、このパターンは、数値型と string 型に限 定されていました。このような制限事項がなくなったため、型パターンを使用して switch ステートメントを記述できるようになり ました。
     public static double ComputeAreaModernSwitch(object shape)
{
    switch (shape)
    {
} }
case Square s:
    return s.Side * s.Side;
case Circle c:
    return c.Radius * c.Radius * Math.PI;
case Rectangle r:
    return r.Height * r.Length;
default:
    throw new ArgumentException(
        message: "shape is not a recognized shape",
        paramName: nameof(shape));
   パターンマッチングの switch ステートメントでは、従来のC形式の switch ステートメントを使用してきた開発者にとって使い
   TIP
このトピックのサンプルでは、推奨されるコンストラクトを使用しています。この場合、パターン マッチングの is 式により、 if ステートメント の true 分岐で一致変数に確実に代入されます。 このロジックは、 if (!(shape is Square s)) を記述することで反転できます。 s 変数は、 false 分岐でのみ、確実に代入されます。 これは有効な C# ですが、ロジックの追跡がわかりにくくなるため、お勧めしませ
ん。
  
 慣れた構文を使用します。それぞれの case が評価され、入力変数に一致する条件の下にあるコードが実行されます。コー ドの実行では、あるcase式から次のcase式に"フォールスルーする"ことはできません。つまり、case ステートメントの構文で は、それぞれの case が break 、 return 、または goto で終わる必要があります。
ステートメントを制御する重要な新しい規則があります。 switch 式の変数の型に関する制限はなくなりました。こ の例の のように、どの型でも使用できます。 case 式は定数値に限定されなくなりました。 この制限がなくなるというこ とは、 セクションの順序を変更すると、プログラムの動作が変わる可能性があることを意味します。
定数値に限定されていたときは、 switch 式の値と一致する case ラベルは 1 つだけでした。 各 switch セクションは次のセ クションにフォール スルーできないという規則との組み合わせにより、 switch セクションは、動作に影響しない任意の順序で並 べ替えることができました。現在は、より汎用的になった 式により、各セクションの順序が重要になります。 switch 式は、テキストの順序で評価されます。 実行は、 式に一致する最初の ラベルに移ります。
default ケースが実行されるのは、他のcaseラベルが一致しない場合のみです。 ケースは、テキストの順序に関 係なく最後に評価されます。 default ケースがなく、他の case ステートメントのいずれも一致しない場合、実行は switch ステートメントの次のステートメントで続行されます。 case ラベルのコードは実行されません。
case 式の when 句
case ラベルで when 句を使用すると、面積が0の図形用に特殊なケースを作成できます。辺の長さが0の正方形または
半径が0の円は、面積が0になります。その条件は、case ラベルで when 句を使用して指定します。
     NOTE
別のラベルに移動する goto ステートメントは、定数パターン (従来の switch ステートメント) のみに有効です。
   switch
 object
 switch
     switch
  switch
switch
          public static double ComputeArea_Version3(object shape)
{
    switch (shape)
    {
} }
case Square s when s.Side == 0:
case Circle c when c.Radius == 0:
return 0;
case Square s:
    return s.Side * s.Side;
case Circle c:
    return c.Radius * c.Radius * Math.PI;
default:
    throw new ArgumentException(
        message: "shape is not a recognized shape",
        paramName: nameof(shape));
 この変更には、新しい構文に関するいくつかの重要なポイントが示されています。最初に、複数の case ラベルを1つの セクションに適用できます。これらのラベルのいずれかが true のとき、ステートメントブロックが実行されます。この例
では、 式が面積が 0 の円または正方形である場合、このメソッドが定数 0 を返します。
この例では、最初の switch ブロックの2つの case ラベルに異なる2つの変数を使用しています。この ブロック内 のステートメントで変数 c (円)または s (正方形)が使用されていないことに注意してください。この ブロックでは、 これらの変数のいずれも確実に代入されません。 これらのケースのいずれかが一致する場合は、変数の 1 つが明確に代入され ています。 ただし、コンパイル時に "どれに" 代入されたかを通知することは不可能です。それは、実行時にいずれかのケースも 一致する可能性があるためです。 そのため、同じブロックに複数の case ラベルを使用する場合のほとんどは、 case ステート メントに新しい変数を導入しません。つまり、 when 句の変数のみを使用します。
switch
default
 switch
   面積が 0 のこれらの図形を追加した後は、さらに図形の種類 (四角形と三角形) を追加してみましょう。
switch
 switch

  この一連の変更により、低次元の場合用に case ラベル、新しい図形ごとにラベルとブロックが追加されます。 最後に、 null ケースを追加して、引数が null にならないようにすることができます。
    public static double ComputeArea_Version5(object shape)
{
    switch (shape)
    {
} }
case Square s when s.Side == 0:
case Circle c when c.Radius == 0:
case Triangle t when t.Base == 0 || t.Height == 0:
case Rectangle r when r.Length == 0 || r.Height == 0:
return 0;
case Square s:
    return s.Side * s.Side;
case Circle c:
    return c.Radius * c.Radius * Math.PI;
case Triangle t:
    return t.Base * t.Height / 2;
case Rectangle r:
    return r.Length * r.Height;
case null:
    throw new ArgumentNullException(paramName: nameof(shape), message: "Shape must not be null");
default:
    throw new ArgumentException(
        message: "shape is not a recognized shape",
        paramName: nameof(shape));
 null パターンには興味深い特殊な動作があります。これは、パターン内の定数 null は、型がありませんが、任意の参照型 またはnull許容値型に変換できるためです。 null を任意の型に変換するよりも、変数のコンパイル時の型に関係なく、
null 値が任意の型パターンと一致しないことを言語で定義します。この動作により、新しい switch ベースの型パターンが
is ステートメントと一貫性を持ちます。 is ステートメントは、チェックされている値が null のとき、常に false を返します。 より簡単なのは、型をチェックしたら、追加の null チェックが必要ないことです。 上記のサンプルの case ブロックのいずれにも null チェックがないことからわかるように、型パターンのマッチングにより null 以外の値が保証されるため、これらは必要ありませ
    public static double ComputeArea_Version4(object shape)
{
    switch (shape)
    {
} }
case Square s when s.Side == 0:
case Circle c when c.Radius == 0:
case Triangle t when t.Base == 0 || t.Height == 0:
case Rectangle r when r.Length == 0 || r.Height == 0:
return 0;
case Square s:
    return s.Side * s.Side;
case Circle c:
    return c.Radius * c.Radius * Math.PI;
case Triangle t:
    return t.Base * t.Height / 2;
case Rectangle r:
    return r.Length * r.Height;
default:
    throw new ArgumentException(
        message: "shape is not a recognized shape",
        paramName: nameof(shape));
 
  ん。
  case 式内の var 宣言
match式の1つとしての var の導入により、パターンマッチングに新しい規則が導入されます。
最初の規則は、var 宣言が通常の型の推定規則に従うことです。この型はswitch式の静的な型として推論されます。その 規則から、型は常に一致します。
2番目の規則は、var 宣言には、他の型パターン式には含まれるnullチェックがないというものです。つまり、変数はnullで ある可能性があり、その場合は null チェックが必要です。
これら 2 つの規則は、多くの場合、 case 式での var 宣言は 式と同じ条件に一致することを意味します。 非 defaultケースは default ケースより優先されるため、 ケースは実行されません。
3番目の規則では、var ケースが役に立つことがある使用が導入されます。入力が文字列であり、既知のコマンド値を検索 する、パターン マッチングを行っている場合を想像してください。 次のようなコードを記述する場合があります。
 default
  default
    NOTE
ケースが記述されていても実行されない場合、コンパイラは警告を生成しません。 これは、すべての可能なケースが列記されて いる ステートメントの動作と一致しています。
 default
 switch
     static object CreateShape(string shapeDescription)
{
    switch (shapeDescription)
    {
} }
case "circle":
    return new Circle(2);
case "square":
    return new Square(4);
case "large-circle":
    return new Circle(12);
case var o when (o?.Trim().Length ?? 0) == 0:
    // white space
    return null;
default:
    return "invalid shape description";
 var のケースは、 null 、空の文字列、または空白文字のみを含む文字列と一致します。 上記のコードでは、 ?. 演算子を 使用して、誤ってNullReferenceExceptionをスローしないようになっていることに注意してください。 default のケースは、こ のコマンド パーサーで認識されない他のすべての文字列値を処理します。
これは、default 式とは別に var ケース式を検討する必要がある1つの例です。 まとめ
"パターン マッチング コンストラクト" を使用すると、継承階層で関連付けられていないさまざまな変数および型の間の制御フロー を簡単に管理できます。 また、ロジックを制御して、変数でテストする任意の条件を使用することもできます。 これにより、構築 する分散アプリケーションが増えるにつれてより頻繁に必要になるパターンと表現形式が実現します。分散アプリケーションでは、 データと、そのデータを操作するメソッドが分離されています。 このサンプルで使用されている図形の構造体にメソッドは含まれて いません。含まれているのは、読み込み専用のプロパティのみです。 パターン マッチングは、あらゆるデータ型で使用できます。 オ ブジェクトを調査する式を記述し、それらの条件に基づいて制御フローを決定します。
  
  このサンプルのコードを、抽象的な Shape と特定の派生図形のクラス階層を作成し、それぞれに面積を計算するための仮想 メソッドが独自に実装されている場合の設計と比較してください。 一般に、パターン マッチング式は、データを扱う際にデータ ス トレージの問題と動作の問題を分離したい場合に非常に便利なツールであることがわかります。
関連項目
チュートリアル: パターン マッチングを使用して、型ドリブンおよびデータ ドリブンのアルゴリズムを構築する

            C# の新しい機能により、よりよいパフォーマンスの検証可能なセーフ コードを記述できます。 これらの手法を慎重に適用した場 合、アンセーフ コードが必要なシナリオが少なくなります。 これらの機能により、メソッドの引数およびメソッドの戻り値として、これ までより簡単に値の型への参照を使用できるようになります。 これらの手法を安全に使用すると、値の型のコピーが最小限に 抑えられます。 値の型を使用することで、割り当てとガベージ コレクション パスの数が最小限になります。
この記事にあるサンプル コードの多くでは、C# 7.2 で追加された機能が使用されています。 そのような機能を使用するには、 C# 7.2 以降を使用するようにプロジェクトを構成する必要があります。 言語バージョンを設定する方法の詳細については、言 語バージョンの構成に関する記事を参照してください。
この記事では、効率的なリソース管理の手法に焦点を当てます。 値の型を利用する利点の 1 つは、多くの場合にヒープ割り 当てが回避されることです。 欠点は、値でコピーされるということです。 このトレードオフにより、大量のデータを操作するアルゴリ ズムの最適化が難しくなります。 C# 7.2 の新しい言語機能では、値の型への参照を使用して安全で効率的なコードを作成 できるメカニズムが提供されます。 これらの機能を賢く使って、割り当てとコピー操作の両方を最小限に抑えます。 この記事で は、これらの新しい機能について説明します。
この記事では、以下のリソース管理手法に焦点を当てます。
readonly struct を宣言して、型が 不変 であることを表します。 それにより、コンパイラでは in パラメーターを使用する ときに防御用のコピーを保存できます。
型を変更できない場合は、メンバーが状態を変更しないことを示すために、 struct メンバーの readonly を宣言します。 戻り値がIntPtr.Sizeより大きい struct であり、ストレージの有効期間が値を返すメソッドより長い場合に、
を使用して戻します。
のサイズがIntPtr.Sizeより大きいときは、パフォーマンスのため、in として渡す必要があります。
修飾子で宣言されている場合、またはメソッドが構造体の readonly メンバーのみを呼び出す場合を除き、 in パラメーターとして struct は渡さないでください。このガイダンスに違反すると、パフォーマンスが低下し、動作が不明
瞭になる場合があります。
バイトのシーケンスとしてメモリを操作するには、 ref struct または Span<T> や ReadOnlySpan<T> などの
readonly ref struct を使用します。
これらの手法では、参照 と 値 に関する 2 つの相反する目標のバランスを取ることが強要されます。 参照型の変数では、メモ リ内の場所への参照が保持されます。 値の型の変数には、値が直接格納されます。 これらの違いにより、メモリ リソースを管 理するために重要となる主な違いが強調されます。 値の型 は、通常、メソッドに渡されるとき、またはメソッドから戻されるとき に、コピーされます。 この動作には、値の型のメンバーを呼び出すときの、 this の値のコピーが含まれます。 コピーのコストは、 型のサイズに関係します。 参照型 は、マネージド ヒープ上に割り当てられます。 新しいオブジェクトごとに新しく割り当てる必 要があり、後でそれを回収する必要があります。 どちらの操作にも時間がかかります。 参照型が引数としてメソッドに渡されると き、またはメソッドから戻されるときは、参照がコピーされます。
この記事では、次に示す 3 次元の点の構造体を概念の例として使用し、これらの推奨事項を説明します。
     ref readonly
 readonly struct
  readonly
       public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
 別の例では、この概念の異なる実装が使用されます。
安全で効率的な C# コードを記述する 2021/03/16 • • Edit Online
 
 変更不可の値の型用に読み取り専用の構造体を宣言する
readonly 修飾子を使用して struct を宣言すると、変更不可の型を作成することが意図であることがコンパイラに伝わりま す。 コンパイラでは、以下の規則に従ってその設計の決定が適用されます。
すべてのフィールドのメンバーは readonly でなければならない 自動的に実装されるプロパティも含めて、すべてのプロパティは読み取り専用でなければならない。
これら 2 つの規則は、 readonly struct のメンバーによってその構造体の状態が変更されないことを保証するのに十分です。 struct は変更不可です。 次の例で示すように、 Point3D 構造体を変更不可の構造体として定義できます。
          readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
}
    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
 変更不可の値の型を作成することが設計の意図である場合は常に、この推奨事項に従ってください。 パフォーマンスの向上は すべて付加的なメリットです。 readonly struct の機能は、設計の意図を明確に表現することです。
構造体を変更不可にできない場合、読み取り専用メンバーを宣言する
C#8.0以降で構造体の型が変更可能な場合、変更を起こさないメンバーを readonly に宣言する必要があります。3Dポ イント構造体を必要としますが、変更可能性をサポートする必要がある別のアプリケーションについて考えます。 次のバージョン の3Dポイント構造では、構造体を変更しないメンバーに対してだけ readonly 修飾子が追加されます。設計で一部のメン バーによる構造体への変更をサポートしながら、一部のメンバーに readonly を適用する利点も必要な場合は、この例に従っ てください。
   
   上の例では、 readonly 修飾子を適用できる多数の場所を多く示しています (メソッド、プロパティ、およびプロパティ アクセ サー)。 自動実装プロパティを使用する場合、コンパイラは読み取り/書き込みプロパティに対し、 get アクセサーに readonly 修飾子を追加します。 コンパイラは、 get アクセサーのみを持つプロパティに対し、 readonly 修飾子を、自動実装プロパティ の宣言に追加します。
状態が変更不可なメンバーに readonly 修飾子を追加すると、2つの関連する利点があります。まず、コンパイラによって意 図が適用されます。 そのメンバーによる構造体の状態の変更はできません。 2 つ目には、 メンバーにアクセスすると きに、コンパイラは in パラメーターの防御的なコピーを作成しません。コンパイラは、 メンバーによって struct が 変更されないことを保証するため、この最適化を安全に行うことができます。
可能であれば大きい構造体には ref readonly return ステートメントを使用す
る
返される値が返すメソッドに対してローカルでない場合は、参照渡しで値を返すことができます。 参照渡しで返すということは、 構造体ではなく参照のみがコピーされることを意味します。次の例の Origin プロパティでは、返される値がローカル変数であ るため、 ref 返しを使用することはできません。
一方、次のプロパティ定義では、返される値が静的メンバーであるため、参照渡しで返すことができます。
     readonly
readonly
     public Point3D Origin => new Point3D(0,0,0);
    public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
}
    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }
    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }
    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }
    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);
    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
 
   呼び出し元によって元の値が変更されては困るので、 ref readonly で値を返す必要があります。
    public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);
    public static ref readonly Point3D Origin => ref origin;
    // other members removed for space
}
  ref readonly を返すと、もっと大きい構造体をコピーしなくて済み、内部データ メンバーの変更不可性を維持することができ ます。
呼び出しサイトでは、 Origin プロパティを ref readonly または値のどちらとして使用するかを、呼び出し元が選択します。
先のコードの最初の割り当てでは、Origin 定数のコピーが作成され、そのコピーが割り当てられます。2つ目は参照を割り当 てます。 readonly 修飾子は変数の宣言の一部にする必要があります。それが参照するものは変更できません。変更を試 みると、コンパイル時エラーが発生します。
originReference の宣言では、 readonly 修飾子が必要です。
コンパイラでは、呼び出し元で参照を変更できないように強制されます。 値を直接割り当てようとすると、コンパイル時エラーが 生成されます。 その他の場合では、読み取り専用の参照が安全に利用できるまで、防御用のコピーがコンパイラによって割り 当てられます。 スタティック分析ルールによって、構造体を変更できるかどうかが判断されます。 構造体が readonly struct のときや、メンバーが構造体の readonly メンバーのときは、防御用のコピーがコンパイラによって作成されることはありません。 構造体を in 引数として渡す目的では、防御用のコピーは不要です。
System.IntPtr.Size より大きい readonly struct パラメーターに in 修飾子 を適用する
in キーワードは、既存の ref キーワードと out キーワードを補完し、引数を参照で渡します。 in キーワードでは、引数 を参照で渡すことが指定されますが、呼び出されたメソッドでは値は変更されません。
この追加によって、設計の意図を表すためのボキャブラリが完全に与えられます。 メソッド シグネチャで次の修飾子のいずれも 指定しないのであれば、呼び出されたメソッドに渡されるとき、値の型がコピーされます。 これらのどの修飾子を使用しても、変 数を参照で渡すことが指定され、コピーが回避されます。 修飾子はそれぞれ、異なる意図を表します。
out :このメソッドでは、このパラメーターとして使用される引数の値が設定されます。
ref :このメソッドでは、このパラメーターとして使用される引数の値が設定されることがあります。 in :このメソッドでは、このパラメーターとして使用される引数の値は変更されません。
      var originValue = Point3D.Origin;
ref readonly var originReference = ref Point3D.Origin;
            public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);
    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;
    // other members removed for space
}
 
   in 修飾子を追加し、参照で引数を渡し、参照で引数を渡して不必要なコピーを回避する設計の意図を宣言します。その 引数として使用されるオブジェクトを変更することは、意図されていません。
この方法では、多くの場合、IntPtr.Size より大きい読み取り専用の値の型でのパフォーマンスが向上します。 単純型 ( sbyte 、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、enum 型)の 場合、可能性のあるパフォーマンスの向上は最小限です。 実際には、IntPtr.Size より小さい型に対して参照渡しを使用する と、パフォーマンスが低下する可能性があります。
次のコードは、3D 空間の 2 点間の距離を計算するメソッドの例です。
       private static double CalculateDistance(in Point3D point1, in Point3D point2)
{
    double xDifference = point1.X - point2.X;
    double yDifference = point1.Y - point2.Y;
    double zDifference = point1.Z - point2.Z;
    return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference);
}
 引数は 2 つの構造で、それぞれに 3 つの倍精度浮動小数点型が含まれます。 倍精度浮動小数点型は 8 バイトです。その ため、各引数は24バイトになります。 in 修飾子を指定することで、コンピューターのアーキテクチャに基づき、4バイトまたは 8 バイトの参照をそれらの引数に渡します。 サイズの差はわずかですが、アプリケーションにおいて、多くの異なる値を使用する 短いループでこのメソッドを呼び出すと膨れあがります。
in 修飾子は、その他の面でも out と ref を補完します。 in 、 out 、または ref の存在のみが異なるメソッドのオー バーロードは作成できません。 これらの新しいルールは、 out パラメーターと ref パラメーターに常に定義されていた同じ動作 を拡張します。 out や ref 修飾子のように、 in 修飾子が適用されるため、値の型はボックス化されません。
in 修飾子は、メソッド、デリケート、ラムダ、ローカル関数、インデクサー、演算子など、パラメーターを受け取るあらゆるメン バーに適用されることがあります。
in パラメーターのもう 1 つの機能として、 in パラメーターへの引数にリテラル値または定数を使用できます。 また、 ref パラ メーターや out パラメーターとは異なり、呼び出しサイトで in 修飾子を適用する必要はありません。次のコードは、
CalculateDistance メソッドを呼び出す2つの例です。最初のメソッドでは、参照で渡される2つのローカル変数が使用され ます。 2 つ目のメソッドには、メソッド呼び出しの一部として作成される一時的な変数が含まれます。
コンパイラでは、 in 引数の読み取り専用の性質を強制する方法がいくつかあります。 まず、呼び出されたメソッドは in パラ メーターに直接割り当てできません。 値が struct 型の場合、 in パラメーターのどのフィールドにも直接割り当てできません。 また、 ref または out 修飾子を使用するメソッドに、 in パラメーターを渡すことはできません。 これらの規則は、 in パラ メーターのすべてのフィールドに適用されます(ただし、フィールドが 型でパラメーターも struct 型の場合)。実際、こ れらの規則は、メンバー アクセスのすべてのレベルで型が であれば、複数層のメンバー アクセスに適用されます。 コン パイラは struct 型を in 引数として渡し、その メンバーが他のメソッドへの引数として使用される場合は読み取り 専用変数になるよう強制します。
in パラメーターを使用することで、コピーを作成することの潜在的なパフォーマンスコストを回避できます。メソッド呼び出しの セマンティクスは変更されません。そのため、呼び出しサイトで in 修飾子を指定する必要はありません。呼び出しサイトで
in 修飾子を省略すると、次の理由で、引数のコピーを作成することが許可されていることがコンパイラに通知されます。
暗黙的な変換は存在するが、引数の型からパラメーターの型への ID 変換が存在しない。 引数は式だが、既知のストレージ変数がない。
     var distance = CalculateDistance(pt1, pt2);
var fromOrigin = CalculateDistance(pt1, new Point3D());
    structs
struct
   struct
in の有無によって異なるオーバーロードが存在する。この場合は、値渡しオーバーロードの方がより適しています。

 これらの規則は、既存のコードを読み取り専用の参照引数を使用するように更新するときに役立ちます。 呼び出されるメソッド 内で、値渡しパラメーターを使用する任意のインスタンス メソッドを呼び出すことができます。 それらのインスタンスで、 in パラ メーターのコピーが作成されます。 コンパイラは in パラメーターに一時的な変数を作成できるため、 in パラメーターに既定値 を指定することもできます。 次のコードでは、2 つ目の点の既定値として原点 (点 0,0) を指定します。
    private static double CalculateDistance2(in Point3D point1, in Point3D point2 = default)
{
    double xDifference = point1.X - point2.X;
    double yDifference = point1.Y - point2.Y;
    double zDifference = point1.Z - point2.Z;
    return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference);
}
 コンパイラに読み取り専用引数の参照渡しを強制するには、次のコードに示すように、呼び出しサイトで引数に in 修飾子を 指定します。
この動作により、パフォーマンスの向上が可能な大規模なコードベースで、徐々に in パラメーターを採用しやすくなります。最 初に、メソッド シグネチャに in 修飾子を追加します。 その後、呼び出しサイトで in 修飾子を追加し、 readonly struct 型を作成して、コンパイラに他の場所で in パラメーターの防御用コピーを作成しないようにすることができます。
in パラメーターの指定は、参照型または数値と併用することもできます。ただし、いずれの場合も、利点があるとしてもわずか です。
in 引数として変更可能な構造体を使用しない
上で説明した手法では、参照を返し、参照で値を渡すことにより、コピーを避ける方法が説明されています。 これらの手法は、 引数の型が readonly struct 型として宣言されているときに最善の結果が得られます。 そうでない場合は、多くの状況にお いて、引数の読み取り専用性を強制するために、コンパイラで 防御用コピー を作成する必要があります。 原点からの 3D の 点の距離を計算する以下の例について考えます。
    distance = CalculateDistance(in pt1, in pt2);
distance = CalculateDistance(in pt1, new Point3D());
distance = CalculateDistance(pt1, in Point3D.Origin);
       private static double CalculateDistance(in Point3D point1, in Point3D point2)
{
    double xDifference = point1.X - point2.X;
    double yDifference = point1.Y - point2.Y;
    double zDifference = point1.Z - point2.Z;
    return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference);
}
  Point3D 構造体は、読み取り専用の構造体では"ありません"。このメソッドの本体には、6つの異なるプロパティアクセス呼 び出しがあります。 最初の調査では、これらのアクセスは安全であると思ったかもしれません。 いずれにしても、 get アクセサー ではオブジェクトの状態を変更すべきではありません。 しかし、それを強制する言語規則はありません。 それは、一般的な規則 のみです。 すべての型で、内部状態を変更する get アクセサーを実装できます。 何らかの言語的保証がないと、 readonly 修飾子でマークされていないメンバーを呼び出す前に、コンパイラで引数の一時コピーを作成する必要があります。 スタック上に 一時的なストレージが作成され、引数の値が一時的なストレージにコピーされて、 this 引数としての各メンバー アクセスに対 して値がスタックにコピーされます。 多くの場合、これらのコピーによってパフォーマンスが悪影響を受けるので、引数の型が readonly struct ではなく、 readonly とマークされていないメンバーがメソッドで呼び出される場合は、値渡しの方が、読み 取り専用参照渡しより速くなります。構造体の状態を変更しないすべてのメソッドを readonly としてマークした場合、コンパ イラでは、構造体の状態が変更されないと判断しても安全であり、防御用のコピーは必要ありません。
    
       代わりに、距離の計算で変更不可の構造体   が使用されている場合は、一時オブジェクトは必要ありませ ん。
    private static double CalculateDistance3(in ReadonlyPoint3D point1, in ReadonlyPoint3D point2 = default)
{
    double xDifference = point1.X - point2.X;
    double yDifference = point1.Y - point2.Y;
    double zDifference = point1.Z - point2.Z;
    return Math.Sqrt(xDifference * xDifference + yDifference * yDifference + zDifference * zDifference);
}
  コンパイラでは、 readonly struct のメンバーの呼び出しに対してもっと効率的なコードが生成されます。 this 参照は、レ シーバーのコピーではなく、常に、メンバー メソッドに参照で渡される in パラメーターです。 この最適化によって、 in 引数とし て readonly struct を使用するときのコピーが減ります。
null許容値の型を in 引数として渡すことはできません。Nullable<T>型は、読み取り専用の構造体として宣言されてい ません。つまり、コンパイラは、パラメータ―宣言上で in 修飾子を使用してメソッドに渡されるnull許容値型の任意の引数 に対して、防御用のコピーを生成する必要があります。
GitHub のサンプル リポジトリの BenchmarkDotNet を使用して、パフォーマンスの違いを示すサンプル プログラムを確認できま す。 変更可能な構造体の値渡しと参照渡し、および変更不可の構造体の値渡しと参照渡しが比較されています。 変更不 可の構造体で参照渡しを使用したときが、最も高速です。
単一のスタック フレームでブロックまたはメモリを操作するために ref struct 型
を使用する
関連するもう 1 つの言語機能は、単一のスタック フレームに拘束される必要のある値型を宣言する機能です。 この制限によ り、コンパイラでいくつかの最適化を行うことができます。 この機能の第一の動機は Span<T> と関連構造でした。 Span<T> 型を利用する新規および更新された .NET API を使用することにより、これらの機能強化によるパフォーマンスの向上を実現で きます。
stackalloc で作成したメモリを使用するとき、あるいは相互運用APIからメモリを使用するとき、同様の要件が求められる場 合があります。 そのようなニーズには独自の ref struct 型を定義できます。
readonly ref struct 型
構造体を readonly ref として宣言すると、 ref struct と readonly struct の制限の利点と制限が組み合わされます。 読み取り専用スパンによって使用されるメモリは単一のスタック フレームに制限され、読み取り専用スパンによって使用されるメモ リは変更できません。
まとめ 値の型を使用すると、割り当て操作の数が最小限になります。
値の型の記憶域は、ローカル変数とメソッド引数に割り当てられたスタックです。 他のオブジェクトのメンバーである値の型に対する記憶域は、別の割り当てとしてではなく、そのオブジェクトの一部として割り 当てられます。
値の型の戻り値に対する記憶域は、割り当てられたスタックです。
それを同じ状況での参照型と比較します。
参照型の記憶域は、ローカル変数とメソッド引数に割り当てられたヒープです。 参照は、スタック上に格納されます。
他のオブジェクトのメンバーである参照型に対する記憶域は、ヒープ上に別に割り当てられます。 参照は親オブジェクトに格 納されます。
         ReadonlyPoint3D
 
   参照型の戻り値に対する記憶域は、割り当てられたヒープです。 その記憶域に対する参照は、スタック上に格納されます。 割り当てを最小限に抑えることにはトレードオフが伴います。 struct のサイズが参照のサイズより大きいと、コピーするメモリの
量が増えます。 通常、参照は 32 ビットまたは 64 ビットであり、ターゲット コンピューターの CPU に応じます。
一般に、これらのトレードオフによるパフォーマンスへの影響は最小限です。 ただし、大きい構造体または大きいコレクションで は、パフォーマンスへの影響が大きくなります。 影響は、短いループおよびプログラムに対するホット パスで、大きくなる可能性が あります。
C# 言語の以上の拡張機能は、必要なパフォーマンスの達成においてメモリの割り当てを最小限にすることが大きな要因であ る、パフォーマンス クリティカルなアルゴリズムのために設計されています。 自分が記述するコードではこれらの機能を頻繁に使用 することがないかもしれません。 ただし、これらの拡張機能は .NET 全体で採用されています。 これらの機能を利用する API が 増えれば、自分で作るアプリケーションのパフォーマンスが向上するでしょう。
関連項目
ref キーワード
ref 戻り値と ref ローカル変数
 
            LINQを使ったことがあれば、APIセットに Func 型が含まれる豊富なライブラリを利用したのではないでしょうか(LINQの知識 があまりない場合は、この記事の前に、LINQ のチュートリアルとラムダ式に関する記事を読むことをお勧めします)。式ツリーに は、関数である引数とのさまざまな相互作用があります。
LINQ クエリを作成するときに関数の引数を作成するには、通常、ラムダ式を使用します。 一般的な LINQ クエリでは、このよ うな関数の引数は、コンパイラで作成されるデリゲートに変換されます。
さまざまな相互作用を使用するには、式ツリーを使用する必要があります。 式ツリーは、確認、変更、または実行が可能な構 造としてコードを表します。 このようなツールを使用すると、実行時にコードを操作できるようになります。 実行中のアルゴリズム を確認するコードや、新しい機能を挿入するコードを作成できます。 より高度なシナリオの場合、実行中のアルゴリズムを変更 し、別の環境で実行できるように C# 式を別の形式に変換することもできます。
式ツリーを使用するコードは既に作成してきました。 Entity Framework の LINQ API では、LINQ クエリ式パターンの引数とし て式ツリーを使用できます。 そのため、Entity Framework では、C# で作成したクエリをデータベース エンジンで実行される SQL に変換することができます。 もう 1 つの例として Moq があります。Moq は、.NET でよく使われるモック作成フレームワーク です。
以降、このチュートリアルでは、式ツリーの概要、式ツリーをサポートするフレームワーク クラス、式ツリーの使用方法について説 明します。 式ツリーの読み方、式ツリーの作成方法、変更を加えた式ツリーの作成方法、式ツリーで表されるコードの実行方 法を学びます。 チュートリアルを読み終わると、これらの構造を使用し、高度な適合アルゴリズムを作成できるようになります。
1. 式ツリーの説明 式ツリーの構造と概念を理解します。
2. 式ツリーをサポートするフレームワークの型 式ツリーを定義し、操作する構造とクラスについて説明します。
3. 式の実行 ラムダ式で表される式ツリーをデリゲートに変換し、結果のデリゲートを実行する方法について説明します。
4. 式の解釈 式ツリーを走査して確認し、式ツリーが表すコードの内容を理解する方法について説明します。
5. 式の構築 式ツリーのノードを構築し、式ツリーを構築する方法について説明します。
6. 式の変換 式ツリーに変更を加えたコピーを構築する方法、または式ツリーを別の形式に変換する方法について説明します。
7. まとめ 式ツリーに関する情報のまとめです。
式ツリー
2020/11/02 • • Edit Online
 
     前回 -- 概要
式ツリーはコードを定義するデータ構造です。 式ツリーは、コードの分析とコンパイル済み出力の生成にコンパイラが使用する構 造と同じ構造に基づいています。 このチュートリアルを読むと、式ツリーと、Analyzers と CodeFixes の構築に Roslyn API で使 用される型が似ている点が多くあることがわかります (Analyzers と CodeFixes は、コードに対して静的分析を実行し、開発者 に修正案を示す機能がある NuGet パッケージです)。概念が似ており、最終的に、わかりやすい方法でソース コードを調査で きるデータ構造になります。 ただし、式ツリーは Roslyn API とまったく異なるクラスと API のセットに基づいています。
単純な例を見てみましょう。 次のコードがあります。
この式ツリーを分析すると、ツリーにはいくつかのノードが含まれています。 最も外側のノードは、代入 ( var sum = 1 + 2; ) あり の変数宣言ステートメントです。この最も外側のノードには、いくつかの子ノードが含まれています。変数の宣言、代入演算 子、そして等号の右側を表す式です。 この式は、さらに加算演算と加算の左右のオペランドを表す式に分割されます。
等号の右側を構成する式を詳しく見てみましょう。 式は 1 + 2 です。 これは二項式です。 具体的には、二項加算式です。 二項加算式には、加算式の左ノードと右ノードを表す 2 つの子があります。 ここで、いずれのノードも定数式です。左オペラン ドは値 1 、右オペランドは値 2 です。
見た目では、ステートメント全体が 1 つのツリーです。ルート ノードから始めて、ツリーの各ノードをたどり、ステートメントを構成 するコードを確認することができます。
代入 ( var sum = 1 + 2; ) ありの変数宣言ステートメント 暗黙的な変数の型宣言 ( var sum )
暗黙的な var キーワード ( var )
変数名の宣言 ( sum ) 代入演算子 ( = ) 二項加算式 ( 1 + 2 )
左オペランド ( 1 ) 加算演算子 ( + ) 右オペランド ( 2 )
これは複雑に見えるかもしれませんが、とても強力です。 同じプロセスに従って、はるかに複雑な式を分解することができます。 次の式について考えます。
上の式も、代入ありの変数宣言です。 この例では、代入の右側はとても複雑なツリーです。 ここではこの式を分解しません が、どのようなノードがあるかを考えてみてください。 現在のオブジェクトをレシーバーとして使用するメソッド呼び出しがあります。 1つは明示的な this レシーバーを持つものと、もう1つは持たないものです。他のレシーバーオブジェクトを使用するメソッド 呼び出しがあり、さまざまな型の定数の引数があります。最後に、二項加算演算子があります。 SecretSauceFunction() ま たは MoreSecretSauce() の戻り値の型にもよりますが、二項加算演算子がオーバーライドされた加算演算子のメソッド呼び
  var sum = 1 + 2;
        var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
   式ツリーの説明
2020/03/18 • • Edit Online
 
   出しになり、静的メソッド呼び出しがクラスに定義されている二項加算演算子に解決されることがあります。
このような複雑さはありますが、上の式では、最初のサンプルと同じくらい簡単にたどることができるツリー構造が作成されます。 子ノードをたどっていくと、式内のリーフ ノードを見つけることができます。 親ノードには子への参照があり、各ノードにはノードの 種類を説明するプロパティがあります。
式ツリーの構造には高い一貫性があります。 基本がわかると、非常に複雑なコードが式ツリーとして表された場合でも理解でき るようになります。 データ構造が洗練されているので、C# コンパイラが非常に複雑な C# プログラムをどのように分析し、複雑な ソース コードから正しい出力を生成できるかがわかります。
式ツリーの構造に慣れると、その身につけた知識を他の高度なシナリオにもすぐに応用できるようになります。 式ツリーには優れ た機能があります。
他の環境で実行されるアルゴリズムを変換するだけでなく、式ツリーを使用してコードの実行前に調査するアルゴリズムを簡単に 作成できます。 引数が式のメソッドを作成し、その式を調査してからコードを実行できます。 式ツリーは、コード全体を表したも のです。任意のサブ式の値を確認できます。 メソッドとプロパティ名を確認できます。 定数式の値を確認できます。 また、式ツ リーを実行可能なデリゲートに変換し、コードを実行することもできます。
式ツリーの API を使用すると、ほぼすべての有効なコード コンストラクトを表すツリーを作成できます。 ただし、可能な限り単純 にするために、式ツリーでは一部のC#の表現方法を作成できません。たとえば、(async および await キーワードを使用す る)非同期式です。非同期アルゴリズムが必要な場合は、コンパイラのサポートに頼らず、Task オブジェクトを直接操作する 必要があります。 もう 1 つの例は、ループの作成時です。 通常、ループの作成には for 、 foreach 、 while 、または do ループを使用します。このシリーズの後半で説明しますが、式ツリーのAPIは、ループの繰り返しを制御する break 式と
continue 式を使用した1つのループ式をサポートしています。
実行できないことの 1 つが式ツリーの変更です。 式ツリーは不変のデータ構造です。 式ツリーを変更するには、元の式ツリーのコ
ピーに変更を加えた新しいツリーを作成する必要があります。
次回 -- 式ツリーをサポートするフレームワークの型
  
     前へ -- 式ツリーの説明
式ツリーを使用する .NET Core framework には、多くのクラスがあります。 クラスの全リストは System.Linq.Expressions で
確認できます。 ここでは、リストのすべてを説明するのではなく、フレームワークのクラスがどう設計されているかを把握します。
言語設計の観点から言えば、式は、評価して値を返すコードの本体です。式はごく単純な場合があります。定数式 1 は定 数値 1 を返します。 式が複雑になる場合もあります。式 (-B + Math.Sqrt(B*B - 4 * A * C)) / (2 * A) は二次方程式 の 1 つの解を返します (式に解がある場合)。
すべては System.Linq.Expression から始まる
式ツリーの使用が複雑になる理由の 1 つは、プログラムの多くの場所でさまざまな種類の式が有効になることです。 代入式を 考えてみます。 代入式の右側には、定数値、変数、メソッドの呼び出し式、その他を含めることができます。 言語に柔軟性が あるため、式ツリーをたどっていくと、ツリーのノードのあらゆる場所でさまざまな式の型が使用されていることに気づくはずです。 そ のため、基本の式の型を使用して作業できるのであれば、それが最も簡単な操作方法になります。 しかし、場合によっては、 それ以上の知識が必要です。このために、基本の式クラスに NodeType プロパティが含まれています。このプロパティは、あり得 る式の型の列挙型である ExpressionType を返します。ノードの型がわかれば、その型にキャストし、式ノードの型を識別する 特定のアクションを実行できます。 特定の型のノードを検索し、その種類の式が持つ特定のプロパティを使用できます。
たとえば、次のコードでは変数アクセス式の変数名を出力します。 ここでは、ノードの型を確認し、次に変数アクセス式にキャス トして、特定の式の型のプロパティを確認するという手順で進めています。
       Expression<Func<int, int>> addFive = (num) => num + 5;
if (addFive.NodeType == ExpressionType.Lambda)
{
    var lambdaExp = (LambdaExpression)addFive;
    var parameter = lambdaExp.Parameters.First();
    Console.WriteLine(parameter.Name);
    Console.WriteLine(parameter.Type);
}
 式ツリーの作成
System.Linq.Expression クラスには、式を作成する静的メソッドも数多く含まれています。これらのメソッドは、その子に指定 された引数を使用して式ノードを作成します。 このようにしてリーフ ノードから式を作成します。 たとえば、次のコードは Add 式 を作成します。
この簡単な例からわかるように、さまざまな型が式ツリーの作成と操作に関わっています。 C# 言語が備える豊富な語彙が提供 する機能を発揮するには、こうした複雑さが必要になります。
     // Addition is an add expression for "1 + 2"
var one = Expression.Constant(1, typeof(int));
var two = Expression.Constant(2, typeof(int));
var addition = Expression.Add(one, two);
 式ツリーをサポートするフレームワークの型
2020/11/02 • • Edit Online
 
  API の操作
ほぼすべての C# 言語の構文要素に対してマップされる式ノード型がそれぞれ存在します。 各型には、その型の言語要素に 特有のメソッドがあります。 一度に覚えておくべきことがたくさんあります。 ここではすべてを記憶しようとするのではなく、式ツリー を操作するときにふだん使うテクニックを紹介します。
1. ExpressionType 列挙型のメンバーを調べて、検証するノードを特定します。 式ツリーをたどって理解するときに、この方法 が実に役立ちます。
2. Expression クラスの静的メンバーを調べて、式を作成します。 これらのメソッドでは、その子ノードから任意の式の型を作 成できます。
3. ExpressionVisitor クラスを調べて、変更された式ツリーを作成します。
これら 3 つの部分をそれぞれ調べれば、さらに多くのことがわかります。 これら 3 つのステップのいずれかを実行すれば、必要なこ
とが必ず見つかります。
次へ -- 式ツリーの実行
   
    前へ -- 式ツリーをサポートするフレームワークの型
式ツリーはコードを表すデータ構造です。 式ツリーはコンパイル済みの実行可能なコードではありません。 式ツリーで表される
.NET コードを実行する場合は、実行可能な IL 命令に変換する必要があります。 ラムダ式から関数への変換
すべての LambdaExpression、または LambdaExpression の派生型は、実行可能な IL に変換できます。 その他の式の型 は直接コードに変換できません。 実際には、この制限はほとんど影響がありません。 ラムダ式は、実行可能な中間言語 (IL) に変換して実行する唯一の式の型です。 (直接 を実行することにどのような意味があるでしょうか。 何 かに役立つでしょうか。) である式ツリー、または の派生型はすべて IL に変換できま す。 式の型 は .NET Core ライブラリで唯一の具体的な例です。 この型は任意のデリゲート型にマッ プされる式を表すのに使用されます。 この型はデリゲート型にマップされるため、.NET で式を検証し、ラムダ式のシグネチャと一 致する適切なデリゲートの IL を生成することができます。
通常、これによって式とそれに対応するデリゲートの間で単純なマッピングが作成されます。 たとえば、 Expression<Func<int>> によって表される式ツリーは、 Func<int> 型のデリゲートに変換されます。 任意の戻り値の型と引数リストをもつラムダ式の場 合、そのラムダ式によって表される実行可能コードのターゲット型となるデリゲート型が存在します。
型には、式ツリーを実行可能コードに変換するために使用する Compile と CompileToMethod メンバー が含まれます。 メソッドはデリゲートを作成します。 メソッドは、式ツリーのコンパイル済み出力を 表す IL によって オブジェクトを更新します。 なお、 は完全なデスクトップ フレームワークで のみ利用可能で、.NET Core では利用できません。
必要に応じて、生成されたデリゲートオブジェクトのシンボルデバッグ情報を受け取る DebugInfoGenerator を用意することも できます。 これにより、式ツリーをデリゲート オブジェクトに変換し、生成されたデリゲートの完全なデバッグ情報を入手できます。
次のコードを使用して、式をデリゲートに変換します。
デリゲート型は式の型が基になっています。 厳密に型指定された方法でデリゲート オブジェクトを使用する場合は、戻り値の型 および引数リストを把握する必要があります。 LambdaExpression.Compile() メソッドは Delegate 型を返します。コンパイル 時ツールを使用して、引数リストまたは戻り値の型を確認するには、適切なデリゲート型にキャストする必要があります。
実行と有効期間
を呼び出したときに作成されたデリゲートを呼び出して、コードを実行します。 上の例の がデリゲートを返す部分に、これが表示されています。 func() を呼び出して、デリゲートを呼び出すことによ
り、コードを実行します。
そのデリゲートは式ツリーのコードを表します。 そのデリゲートのハンドルを保持して、後で呼び出すことができます。 デリゲートが 表すコードを実行するたびに、式ツリーをコンパイルする必要はありません。 (式ツリーは不変であるため、あとで同じ式ツリーをコ ンパイルしても、同じコードを実行するデリゲートが作成されます。)
 ConstantExpression
  LambdaExpression
 Expression<TDelegate>
     LambdaExpression
       Expression<Func<int>> add = () => 1 + 2;
var func = add.Compile(); // Create Delegate
var answer = func(); // Invoke Delegate
Console.WriteLine(answer);
   LambdaExpression.Compile()
Compile
 MethodBuilder
CompileToMethod
 CompileToMethod
   add.Compile()
より高度なキャッシュ機構を作成して、不要なコンパイルの呼び出しを回避することで、パフォーマンスを向上させようとしないよう
LambdaExpression
式ツリーの実行
2020/03/18 • • Edit Online
 
 に気を付けてください。 また、2 つの任意の式ツリーを比較して、同じアルゴリズムを表しているかどうかを確認することも、実行 に時間がかかります。 LambdaExpression.Compile() への余分な呼び出しを回避して、コンピューティング時間を削減しても、 2 つの異なる式ツリーから同じ実行可能コードが得られることを確認するコードを実行するのにもっと多くの時間がかかってしまい ます。
注意事項
ラムダ式をデリゲートにコンパイルして、そのデリゲートを呼び出すのは、式ツリーで実行する最も単純な操作の 1 つです。 ただ し、この簡単な操作にも気をつけるべき点があります。
ラムダ式は、式で参照される任意のローカル変数に対するクロージャを作成します。 デリゲートの一部となる任意の変数は、 Compile を呼び出す場所で使用でき、得られたデリゲートを実行するときに使用できるように保証する必要があります。
通常は、このことがtrueであることをコンパイラが確認します。しかし、式が IDisposable を実装する変数にアクセスする場 合、式ツリーでオブジェクトが保持されている一方で、コードがオブジェクトを破棄する可能性があります。
たとえば、次のコードは int が IDisposable を実装しないため、正常に機能します。
デリゲートはローカル変数 constant への参照を取得します。 CreateBoundFunc によって返される関数をあとで実行すると き、その変数はいつでもアクセスできます。
しかし、次の IDisposable を実装するクラス(かなり不自然です)はどうでしょうか。
        private static Func<int, int> CreateBoundFunc()
{
    var constant = 5; // constant is captured by the expression tree
    Expression<Func<int, int>> expression = (b) => constant + b;
    var rVal = expression.Compile();
    return rVal;
}
        public class Resource : IDisposable
{
    private bool isDisposed = false;
    public int Argument
    {
get {
            else throw new ObjectDisposedException("Resource");
        }
}
    public void Dispose()
    {
        isDisposed = true;
    }
}
if (!isDisposed)
    return 5;
  下記に示す式で使用する場合、 Resource.Argument プロパティによって参照されるコードを実行すると、 ObjectDisposedException が得られます。
 
    このメソッドから返されたデリゲートは、 constant オブジェクトを捕捉しますが、このオブジェクトはすでに破棄されています。 (オ ブジェクトは using ステートメントで宣言されたため、破棄されています。)
このため、このメソッドから返されたデリゲートを実行すると、実行時に ObjectDisposedException がスローされます。 コンパイル時の構成要素を表す実行時エラーが発生するのは変だと思うかもしれませんが、式ツリーを扱う場合はそういうもので
す。
この問題はさまざまなバリエーションがあるため、これを回避する一般的なガイダンスを提供することは困難です。 式を定義する ときにローカル変数へのアクセスに注意するとともに、パブリック API によって返される可能性がある式ツリーを作成する場合、(
this によって表される)現在のオブジェクトでのアクセス状態に注意してください。
式のコードが他のアセンブリのメソッドまたはプロパティを参照する場合があります。 そのアセンブリには、式の定義時、式のコンパ イル時、得られたデリゲートの呼び出し時にアクセスが必要になります。 アセンブリが存在しない場合、
ReferencedAssemblyNotFoundException が発生します。 まとめ
ラムダ式を表す式ツリーをコンパイルすると、実行可能なデリゲートを作成できます。 この方法は、式ツリーが表すコードを実行 するメカニズムの 1 つです。
式ツリーは、作成した任意の構成要素を実行するコードを表わしています。 コードをコンパイルして実行する環境が、式を作 成する環境と一致している限り、すべてが期待どおりに動作します。 環境が一致していない場合、エラーが確実に予想されま す。このエラーは、式ツリーを使用するコードを最初にテストする段階で発見されるはずです。
次へ -- 式の解釈
     private static Func<int, int> CreateBoundResource()
{
    using (var constant = new Resource()) // constant is captured by the expression tree
    {
} }
Expression<Func<int, int>> expression = (b) => constant.Argument + b;
var rVal = expression.Compile();
return rVal;
 
    前へ -- 式の実行
ここでは、式ツリーの構造を調べるコードを作成します。式ツリー内のすべてのノードは、Expression から派生したクラスのオ
ブジェクトになります。
そうした設計上、式ツリーのすべてのノードへのアクセスには、比較的単純な再帰的操作を使用します。 一般的な方法では、 はじめにルート ノードの種類を確認します。
ノード型に子がある場合は、再帰的に子にアクセスします。 それぞれの子ノードで、ルート ノードで使用したプロセスを繰り返し ます。つまり、種類を確認し、型に子がある場合は、それぞれの子にアクセスします。
子を持たない式の確認
まずは、単純な式ツリーの各ノードにアクセスしてみましょう。 次に示すのは、定数式を作成し、次にそのプロパティを調べるコー ドです。
このコードの出力は、次のようになります。
では、この式を調べ、式に関する重要なプロパティを書き込むコードを作成します。 次に示すのがそのコードです。
単純な加算式の確認 このセクションの導入として、加算のサンプルから始めます。
この式ツリーを宣言するために var を使用していません。それは代入の右側は暗黙的に型指定されているためです。
ルート ノードは LambdaExpression です。 => 演算子の右側で関心があるコードを取得するため、 LambdaExpression の子 のいずれかを検索する必要があります。 このセクションのすべての式について、この操作を行います。 親ノードは
LambdaExpression の戻り値の型を検索するのに役立ちます。
この式の各ノードを調べるには、いくつかのノードに再帰的にアクセスする必要があります。 次に示すのは、最初の単純な実装 です。
     var constant = Expression.Constant(24, typeof(int));
Console.WriteLine($"This is a/an {constant.NodeType} expression type");
Console.WriteLine($"The type of the constant value is {constant.Type}");
Console.WriteLine($"The value of the constant value is {constant.Value}");
     This is an Constant expression type
The type of the constant value is System.Int32
The value of the constant value is 24
   Expression<Func<int>> sum = () => 1 + 2;
      式の解釈
2020/11/02 • • Edit Online
 
  このサンプル コードから、次のような出力が得られます。
    This expression is a/an Lambda expression type
The name of the lambda is <null>
The return type is System.Int32
The expression has 2 arguments. They are:
        Parameter Type: System.Int32, Name: a
        Parameter Type: System.Int32, Name: b
The body is a/an Add expression
The left side is a Parameter expression
        Parameter Type: System.Int32, Name: a
The right side is a Parameter expression
        Parameter Type: System.Int32, Name: b
 上記のサンプル コードには、繰り返しが多数あることがわかります。 ここで、繰り返しを整理して、より汎用的な式ノード ビジ ターを作成します。 それには、再帰的なアルゴリズムを記述する必要があります。 どのノードにも子を持つ型である可能性があ ります。 子を持つすべてのノードで、その子にアクセスし、ノードの種類を確認することが必要です。 次に示す整理したバージョ ンでは、加算操作にアクセスするために再帰を使用しています。
   Expression<Func<int, int, int>> addition = (a, b) => a + b;
Console.WriteLine($"This expression is a {addition.NodeType} expression type");
Console.WriteLine($"The name of the lambda is {((addition.Name == null) ? "<null>" : addition.Name)}");
Console.WriteLine($"The return type is {addition.ReturnType.ToString()}");
Console.WriteLine($"The expression has {addition.Parameters.Count} arguments. They are:");
foreach(var argumentExpression in addition.Parameters)
{
    Console.WriteLine($"\tParameter Type: {argumentExpression.Type.ToString()}, Name:
{argumentExpression.Name}");
}
var additionBody = (BinaryExpression)addition.Body;
Console.WriteLine($"The body is a {additionBody.NodeType} expression");
Console.WriteLine($"The left side is a {additionBody.Left.NodeType} expression");
var left = (ParameterExpression)additionBody.Left;
Console.WriteLine($"\tParameter Type: {left.Type.ToString()}, Name: {left.Name}");
Console.WriteLine($"The right side is a {additionBody.Right.NodeType} expression");
var right= (ParameterExpression)additionBody.Right;
Console.WriteLine($"\tParameter Type: {right.Type.ToString()}, Name: {right.Name}");
     // Base Visitor class:
public abstract class Visitor
{
    private readonly Expression node;
    protected Visitor(Expression node)
    {
        this.node = node;
    }
    public abstract void Visit(string prefix);
    public ExpressionType NodeType => this.node.NodeType;
    public static Visitor CreateFromExpression(Expression node)
    {
        switch(node.NodeType)
        {
            case ExpressionType.Constant:
                return new ConstantVisitor((ConstantExpression)node);
            case ExpressionType.Lambda:
                return new LambdaVisitor((LambdaExpression)node);
            case ExpressionType.Parameter:
                return new ParameterVisitor((ParameterExpression)node);
case ExpressionType.Add:

 } }
}
} }
case ExpressionType.Add:
    return new BinaryVisitor((BinaryExpression)node);
default:
    Console.Error.WriteLine($"Node not processed yet: {node.NodeType}");
    return default(Visitor);
 // Lambda Visitor
public class LambdaVisitor : Visitor
{
    private readonly LambdaExpression node;
    public LambdaVisitor(LambdaExpression node) : base(node)
    {
        this.node = node;
    }
    public override void Visit(string prefix)
    {
        Console.WriteLine($"{prefix}This expression is a {NodeType} expression type");
        Console.WriteLine($"{prefix}The name of the lambda is {((node.Name == null) ? "<null>" :
node.Name)}");
Console.WriteLine($"{prefix}The return type is {node.ReturnType.ToString()}");
Console.WriteLine($"{prefix}The expression has {node.Parameters.Count} argument(s). They are:");
// Visit each parameter:
foreach (var argumentExpression in node.Parameters)
{
    var argumentVisitor = Visitor.CreateFromExpression(argumentExpression);
    argumentVisitor.Visit(prefix + "\t");
}
Console.WriteLine($"{prefix}The expression body is:");
// Visit the body:
var bodyVisitor = Visitor.CreateFromExpression(node.Body);
bodyVisitor.Visit(prefix + "\t");
// Binary Expression Visitor:
public class BinaryVisitor : Visitor
{
    private readonly BinaryExpression node;
    public BinaryVisitor(BinaryExpression node) : base(node)
    {
        this.node = node;
    }
    public override void Visit(string prefix)
    {
} }
Console.WriteLine($"{prefix}This binary expression is a {NodeType} expression");
var left = Visitor.CreateFromExpression(node.Left);
Console.WriteLine($"{prefix}The Left argument is:");
left.Visit(prefix + "\t");
var right = Visitor.CreateFromExpression(node.Right);
Console.WriteLine($"{prefix}The Right argument is:");
right.Visit(prefix + "\t");
// Parameter visitor:
public class ParameterVisitor : Visitor
{
    private readonly ParameterExpression node;
    public ParameterVisitor(ParameterExpression node) : base(node)
    {
        this.node = node;
    }
public override void Visit(string prefix)
  
  このアルゴリズムは、任意の LambdaExpression にアクセスするアルゴリズムの基礎となります。このコードには穴が多数ありま す。つまり、ここで作成したコードでは、検出される可能性がある一連の式ツリーのノードのうち、ごく一部のサンプルしか探索さ れません。それでも、このコードからかなりのことを学ぶことができます。(Visitor.CreateFromExpression メソッドのdefault case では、新しいノード型が検出されると、エラー コンソールにメッセージが出力されます。 これによって、新しい式の型を追加 する必要があることがわかります。)
上記の加算式でこのビジターを実行すると、次のような出力が得られます。
     This expression is a/an Lambda expression type
The name of the lambda is <null>
The return type is System.Int32
The expression has 2 argument(s). They are:
        This is an Parameter expression type
        Type: System.Int32, Name: a, ByRef: False
        This is an Parameter expression type
        Type: System.Int32, Name: b, ByRef: False
The expression body is:
        This binary expression is a Add expression
        The Left argument is:
                This is an Parameter expression type
                Type: System.Int32, Name: a, ByRef: False
        The Right argument is:
                This is an Parameter expression type
                Type: System.Int32, Name: b, ByRef: False
 こうして、より汎用的なビジターを実装すると、多種多様な式の型にアクセスして処理できるようになります。
さまざまなレベルの加算式の確認 次に、もっと複雑な例を取り上げます。ただし、ノード型は引き続き加算だけにとどめます。
これをビジターアルゴリズムで実行する前に、出力がどうなるか、思考訓練をしてください。 + 演算子は二項演算子です。つ まり、左側オペランドと右側オペランドを表す 2 つの子を持っている必要があります。 正しいと考えられるツリーを構築する方法 はいくつかあります。
  Expression<Func<int>> sum = () => 1 + 2 + 3 + 4;
        {
        Console.WriteLine($"{prefix}This is an {NodeType} expression type");
        Console.WriteLine($"{prefix}Type: {node.Type.ToString()}, Name: {node.Name}, ByRef:
{node.IsByRef}");
    }
}
// Constant visitor:
public class ConstantVisitor : Visitor
{
    private readonly ConstantExpression node;
    public ConstantVisitor(ConstantExpression node) : base(node)
    {
        this.node = node;
    }
    public override void Visit(string prefix)
    {
} }
Console.WriteLine($"{prefix}This is an {NodeType} expression type");
Console.WriteLine($"{prefix}The type of the constant value is {node.Type}");
Console.WriteLine($"{prefix}The value of the constant value is {node.Value}");
 
  可能性のある答えを 2 つに分けて考えれば、最も見込みがある答えに着目できます。 1 つ目は、 結合規則が右から左 の式 です。 2 つ目は、 結合規則が左から右 の式です。 これら 2 つの書式の利点は、任意の数の加算式に拡張できる点です。
この式をビジターで実行すると、表示された出力から、この単純な加算式では 結合関係が左から右 に評価されることを検証で きます。
このサンプルを実行して、完全な式ツリーを表示するために、ソースの式ツリーに 1 つ変更を加える必要がありました。 式ツリー に含まれるのがすべて定数である場合、結果のツリーに含まれるのは定数値の 10 だけです。コンパイラはすべての加算を実 行し、式を最も単純な形式に変換します。 元のツリーを確認するには、式に 1 つの変数を追加するだけで十分です。
これを合計するビジターを作成し、実行すれば、次の出力が得られます。
  Expression<Func<int, int>> sum = (a) => 1 + a + 3 + 4;
     This expression is a/an Lambda expression type
The name of the lambda is <null>
The return type is System.Int32
The expression has 1 argument(s). They are:
        This is an Parameter expression type
        Type: System.Int32, Name: a, ByRef: False
The expression body is:
        This binary expression is a Add expression
        The Left argument is:
                This binary expression is a Add expression
                The Left argument is:
                        This binary expression is a Add expression
                        The Left argument is:
                                This is an Constant expression type
                                The type of the constant value is System.Int32
                                The value of the constant value is 1
                        The Right argument is:
                                This is an Parameter expression type
                                Type: System.Int32, Name: a, ByRef: False
                The Right argument is:
                        This is an Constant expression type
                        The type of the constant value is System.Int32
                        The value of the constant value is 3
        The Right argument is:
                This is an Constant expression type
                The type of the constant value is System.Int32
                The value of the constant value is 4
 このビジター コードを使用して、他のサンプルを実行すれば、そのコードが表わすツリーを確認できます。 次に示す例は、上記の sum3 式です(コンパイラが定数を計算するのを防ぐためにパラメーターを追加しています)。
ビジターからの出力は、次のようになります。
  Expression<Func<int, int, int>> sum3 = (a, b) => (1 + a) + (3 + b);
    Expression<Func<int>> sum1 = () => 1 + (2 + (3 + 4));
Expression<Func<int>> sum2 = () => ((1 + 2) + 3) + 4;
Expression<Func<int>> sum3 = () => (1 + 2) + (3 + 4);
Expression<Func<int>> sum4 = () => 1 + ((2 + 3) + 4);
Expression<Func<int>> sum5 = () => (1 + (2 + 3)) + 4;
 
   かっこは出力の一部ではないことに注意してください。 入力式のかっこを表すノードは、式ツリーの中にありません。 式ツリーの 構造体には、優先順位を伝達するために必要なすべての情報が含まれています。
このサンプルの拡張
このサンプルは、最も基本的な式ツリーのみを処理します。このセクションに示されるコードでは、整数定数と二項演算子 + のみを扱います。 次に、最後のサンプルとして、より複雑な式を扱うビジターに更新します。 次の式に対応させることにします。
このコードは、数学の 階乗 関数に対して考えられる実装の 1 つです。 このコードの記述方法によって、式にラムダ式を代入し て式ツリーを構築する場合の 2 つの制限事項が強調されています。 第 1 に、ステートメント形式のラムダは使用できません。 つまり、C# で一般的なループ、ブロック、if / else ステートメント、その他の制御構造を使用できないということです。 式の使用 だけに制限されます。 第 2 に、同じ式を再帰的に呼び出すことができません。 式が既にデリゲートになっている場合は呼び出 せますが、式ツリー形式で呼び出すことはできません。 これらの制限をなくす方法については、「式ツリーの構築」セクションを参 照してください。
この式では、次の型のノードすべてが使用されています。
1. 等号 (二項式)
2. 乗算 (二項式)
3. 条件付き(?:式)
4. メソッド呼び出し式 ( Range() と Aggregate() を呼び出す)
ビジターアルゴリズムを修正する方法の1つは、アルゴリズムの実行を繰り返し、default 句に行き着くたびにノード型を記述 することです。 数回繰り返せば、検出の可能性がある各ノードを確認できます。 その段階で、必要なものがすべて揃います。 結果は次のようになります。
    Expression<Func<int, int>> factorial = (n) =>
    n == 0 ?
1:
Enumerable.Range(1, n).Aggregate((product, factor) => product * factor);
       This expression is a/an Lambda expression type
The name of the lambda is <null>
The return type is System.Int32
The expression has 2 argument(s). They are:
        This is an Parameter expression type
        Type: System.Int32, Name: a, ByRef: False
        This is an Parameter expression type
        Type: System.Int32, Name: b, ByRef: False
The expression body is:
        This binary expression is a Add expression
        The Left argument is:
                This binary expression is a Add expression
                The Left argument is:
                        This is an Constant expression type
                        The type of the constant value is System.Int32
                        The value of the constant value is 1
                The Right argument is:
                        This is an Parameter expression type
                        Type: System.Int32, Name: a, ByRef: False
        The Right argument is:
                This binary expression is a Add expression
                The Left argument is:
                        This is an Constant expression type
                        The type of the constant value is System.Int32
                        The value of the constant value is 3
                The Right argument is:
                        This is an Parameter expression type
                        Type: System.Int32, Name: b, ByRef: False
 
  ConditionalVisitor と MethodCallVisitor がこれら 2 つのノードを処理します。
   public static Visitor CreateFromExpression(Expression node)
{
    switch(node.NodeType)
    {
} }
case ExpressionType.Constant:
    return new ConstantVisitor((ConstantExpression)node);
case ExpressionType.Lambda:
    return new LambdaVisitor((LambdaExpression)node);
case ExpressionType.Parameter:
    return new ParameterVisitor((ParameterExpression)node);
case ExpressionType.Add:
case ExpressionType.Equal:
case ExpressionType.Multiply:
    return new BinaryVisitor((BinaryExpression)node);
case ExpressionType.Conditional:
    return new ConditionalVisitor((ConditionalExpression)node);
case ExpressionType.Call:
    return new MethodCallVisitor((MethodCallExpression)node);
default:
    Console.Error.WriteLine($"Node not processed yet: {node.NodeType}");
    return default(Visitor);
 
    式ツリーの出力は、次のようになります。
  public class ConditionalVisitor : Visitor
{
    private readonly ConditionalExpression node;
    public ConditionalVisitor(ConditionalExpression node) : base(node)
    {
        this.node = node;
    }
    public override void Visit(string prefix)
    {
} }
Console.WriteLine($"{prefix}This expression is a {NodeType} expression");
var testVisitor = Visitor.CreateFromExpression(node.Test);
Console.WriteLine($"{prefix}The Test for this expression is:");
testVisitor.Visit(prefix + "\t");
var trueVisitor = Visitor.CreateFromExpression(node.IfTrue);
Console.WriteLine($"{prefix}The True clause for this expression is:");
trueVisitor.Visit(prefix + "\t");
var falseVisitor = Visitor.CreateFromExpression(node.IfFalse);
Console.WriteLine($"{prefix}The False clause for this expression is:");
falseVisitor.Visit(prefix + "\t");
public class MethodCallVisitor : Visitor
{
    private readonly MethodCallExpression node;
    public MethodCallVisitor(MethodCallExpression node) : base(node)
    {
        this.node = node;
    }
    public override void Visit(string prefix)
    {
        Console.WriteLine($"{prefix}This expression is a {NodeType} expression");
        if (node.Object == null)
            Console.WriteLine($"{prefix}This is a static method call");
        else
        {
            Console.WriteLine($"{prefix}The receiver (this) is:");
            var receiverVisitor = Visitor.CreateFromExpression(node.Object);
            receiverVisitor.Visit(prefix + "\t");
}
        var methodInfo = node.Method;
        Console.WriteLine($"{prefix}The method name is {methodInfo.DeclaringType}.{methodInfo.Name}");
        // There is more here, like generic arguments, and so on.
        Console.WriteLine($"{prefix}The Arguments are:");
        foreach(var arg in node.Arguments)
        {
            var argVisitor = Visitor.CreateFromExpression(arg);
            argVisitor.Visit(prefix + "\t");
        }
} }

     サンプル ライブラリの拡張
このセクションのサンプルでは、式ツリーのノードにアクセスして調べるための中核的な手法を示します。 ここでは、式ツリーのノー ドにアクセスする主要なタスクに重点的に取り組むために必要な多くのアクションについて説明しました。
第 1 に、ビジターは整数の定数だけを処理します。 定数値は他の数値型になることができ、C# 言語ではそれらの型同士の 変換や昇格がサポートされています。 このコードのより堅牢なバージョンには、それらすべての機能が反映されています。
最後のサンプルでも、想定されるノード型のサブセットを認識できます。 コードの処理が失敗する式をさらに読み込ませることも できます。 完全な実装は、ExpressionVisitor という名前で .NET Standard に含まれていて、想定されるすべてのノード型を 処理できます。
  This expression is a/an Lambda expression type
The name of the lambda is <null>
The return type is System.Int32
The expression has 1 argument(s). They are:
        This is an Parameter expression type
        Type: System.Int32, Name: n, ByRef: False
The expression body is:
        This expression is a Conditional expression
        The Test for this expression is:
                This binary expression is a Equal expression
                The Left argument is:
                        This is an Parameter expression type
                        Type: System.Int32, Name: n, ByRef: False
                The Right argument is:
                        This is an Constant expression type
                        The type of the constant value is System.Int32
                        The value of the constant value is 0
        The True clause for this expression is:
                This is an Constant expression type
                The type of the constant value is System.Int32
                The value of the constant value is 1
        The False clause for this expression is:
                This expression is a Call expression
                This is a static method call
                The method name is System.Linq.Enumerable.Aggregate
                The Arguments are:
                        This expression is a Call expression
                        This is a static method call
                        The method name is System.Linq.Enumerable.Range
                        The Arguments are:
                                This is an Constant expression type
                                The type of the constant value is System.Int32
                                The value of the constant value is 1
                                This is an Parameter expression type
                                Type: System.Int32, Name: n, ByRef: False
                        This expression is a Lambda expression type
                        The name of the lambda is <null>
                        The return type is System.Int32
                        The expression has 2 arguments. They are:
                                This is an Parameter expression type
                                Type: System.Int32, Name: product, ByRef: False
                                This is an Parameter expression type
                                Type: System.Int32, Name: factor, ByRef: False
                        The expression body is:
                                This binary expression is a Multiply expression
                                The Left argument is:
                                        This is an Parameter expression type
                                        Type: System.Int32, Name: product, ByRef: False
                                The Right argument is:
                                        This is an Parameter expression type
                                        Type: System.Int32, Name: factor, ByRef: False

  最後に、この記事で使用したライブラリはデモ用および学習用として構築しました。 ライブラリの最適化は行っていません。 ライ ブラリを記述したのは、使用した構造体を明確にし、ノードのアクセスに使用した手法を浮き彫りにして、その内容を分析する ためです。 運用環境への実装では、今回試みたよりもさらにパフォーマンスに注意を払うことになります。
こうした制限があるとはいえ、式ツリーを読み、理解するアルゴリズムの作成を問題なく進めていけるはずです。
次へ -- 式の構築

    前回 -- 式の解釈
これまでに説明した式ツリーは、いずれもC#コンパイラで作成したものです。 Expression<Func<T>> や他の同様の型として型 指定された変数に割り当てるラムダ式を作成するだけの手順でしたが、 式ツリーを作成する方法は他にもあります。 実行時に メモリ内で式を構築する必要があるというシナリオはよくあります。
式ツリーは不変なので、式ツリーの構築は複雑です。 不変とは、リーフからルートにいたるまでツリーを構築する必要があることを 意味します。 式ツリーの構築に使用する API がこれを反映しています。ノードの構築に使用するメソッドは、そのすべての子を 引数として取得します。 いくつかの例を挙げながら手法を説明します。
ノードの作成
比較的単純な例から始めましょう。 これまでに使用してきた加算式を使用します。
式ツリーを構築するには、リーフ ノードを構築する必要があります。 リーフ ノードは定数なので、 Expression.Constant メソッド を使用してノードを作成できます。
次に、加算式を構築します。
加算式を構築したら、ラムダ式を作成できます。
引数がないので、これはとても単純なラムダ式です。 このセクションの後半では、引数をパラメーターにマップし、より複雑な式を 構築する方法について説明します。
この例のように単純な式の場合、すべての呼び出しを 1 つのステートメントにまとめることもできます。
ツリーの構築
メモリ内に式ツリーを構築する基本的な方法です。 一般的に、複雑なツリーの場合はノードの種類が多く、ツリー内のノード数 も多くなります。 もう 1 つの例を使って、式ツリーを作成するときに一般的に構築する 2 つのノードについて説明します。引数
   Expression<Func<int>> sum = () => 1 + 2;
      var one = Expression.Constant(1, typeof(int));
var two = Expression.Constant(2, typeof(int));
   var addition = Expression.Add(one, two);
   var lambda = Expression.Lambda(addition);
     var lambda = Expression.Lambda(
    Expression.Add(
        Expression.Constant(1, typeof(int)),
        Expression.Constant(2, typeof(int))
    )
);
 式ツリーの構築
2020/11/02 • • Edit Online
 
 ノードとメソッド呼び出しノードです。 式ツリーを構築して次の式を作成しましょう。
まず x と y のパラメーター式を作成します。
乗算式と加算式の作成方法は、これまでに説明したパターンどおりです。
次に、 Math.Sqrt の呼び出しのために、メソッド呼び出し式を作成する必要があります。
最後に、メソッド呼び出しをラムダ式に組み込み、忘れずにラムダ式の引数を定義します。
このやや複雑な例では、式ツリーの作成に必要になることが多い手法がいくつか見られます。
まず、パラメーターまたはローカル変数を表すオブジェクトは、使用前に作成しておく必要があります。 オブジェクトの作成後は、 式ツリーのどこでも必要な場所で使用できます。
次に、MethodInfo オブジェクトを作成するには、リフレクションAPIの一部を使用する必要があります。これは、そのメソッドにア クセスする式ツリーを作成できるようにするためです。 使用するリフレクション API は、.NET Core プラットフォームで使用できるも のに限定する必要があります。 繰り返しになりますが、こうした手法は他の式ツリーにも応用されます。
コードの構築の詳細
このような API を使用して構築できるものに制限はありませんが、 構築する式ツリーが複雑になるほど、コードの管理と読み取 りが困難になります。
このコードと同じ式ツリーを構築してみましょう。
    Expression<Func<double, double, double>> distanceCalc =
    (x, y) => Math.Sqrt(x * x + y * y);
     var xParameter = Expression.Parameter(typeof(double), "x");
var yParameter = Expression.Parameter(typeof(double), "y");
     var xSquared = Expression.Multiply(xParameter, xParameter);
var ySquared = Expression.Multiply(yParameter, yParameter);
var sum = Expression.Add(xSquared, ySquared);
      var sqrtMethod = typeof(Math).GetMethod("Sqrt", new[] { typeof(double) });
var distance = Expression.Call(sqrtMethod, sum);
     var distanceLambda = Expression.Lambda(
    distance,
    xParameter,
    yParameter);
  
     上の例では、式ツリーを構築せず、デリゲートのみを構築しました。 Expression クラスを使用して、ステートメント形式のラムダ を構築することはできません。 同じ機能を構築するために必要なコード例を次に示します。 この例が複雑なのは、 while ルー プを構築する API がなく、条件テストを含むループと、ループを抜けるためのラベル ターゲットを構築する必要があるためです。
    var nArgument = Expression.Parameter(typeof(int), "n");
var result = Expression.Variable(typeof(int), "result");
// Creating a label that represents the return value
LabelTarget label = Expression.Label(typeof(int));
var initializeResult = Expression.Assign(result, Expression.Constant(1));
// This is the inner block that performs the multiplication,
// and decrements the value of 'n'
var block = Expression.Block(
    Expression.Assign(result,
        Expression.Multiply(result, nArgument)),
    Expression.PostDecrementAssign(nArgument)
);
// Creating a method body.
BlockExpression body = Expression.Block(
    new[] { result },
    initializeResult,
    Expression.Loop(
        Expression.IfThenElse(
            Expression.GreaterThan(nArgument, Expression.Constant(1)),
            block,
            Expression.Break(label, result)
),
label )
);
 階乗関数の式ツリーを構築するコードは、かなり長く複雑になります。また、通常のコーディング作業では避けたいラベルや break ステートメントなどの要素が多くなってしまいます。
このセクションでは、この式ツリーのすべてのノードにアクセスするビジター コードも更新し、このサンプルで作成したノードに関する 情報を書き出しました。 GitHub の dotnet/docs レポジトリで、サンプル コードを表示またはダウンロードすることができます。 自分でサンプルをビルドし、実行してみてください。 ダウンロード方法については、「サンプルおよびチュートリアル」を参照してくだ さい。
API の確認
.NET Core では、式ツリーの API をたどることがやや難しくはありますが、問題ありません。 その目的は、実行時にコードを生成 するコードを作成するという、かなり複雑な作業だからです。 C# 言語で使用できるすべてのコントロール構造体をサポートしな がら、API のアクセス領域をできるだけ少なくするバランスを取るため、必然的に複雑な作業になります。 このバランスとは、多く のコントロール構造体は、C# コンストラクトではなく、上位のコンストラクトからコンパイラが生成する基のロジックを示すコンストラ クトで表されることを意味します。
   Func<int, int> factorialFunc = (n) =>
{
    var res = 1;
    while (n > 1)
    {
res = res * n;
n--; }
    return res;
};
 
  また、現時点では、   クラス メソッドを使用して直接構築できない C# 式があります。 一般的に、C# 5 と C# 6 で 追加された最新の演算子と式です (たとえば、 async は構築できず、新しい ?. 演算子は直接作成できません)。
次回 -- 式の変換
 Expression
 
    前回 -- 式の構築
この最終セクションでは、式ツリーの各ノードにアクセスし、その式ツリーに変更を加えたコピーを構築する方法について説明しま す。 これらの手法は、2 つの重要なシナリオで使用されます。 1 つ目は、別の環境に変換するために、式ツリーで表現されるア ルゴリズムを理解する場合です。 2 つ目は、作成したアルゴリズムを変更する場合です。 この目的として、ログ記録の追加、メ ソッド呼び出しの取得と追跡などがあります。
変換はアクセスすること
式ツリーを変換するために構築するコードは、既に説明した、ツリーのすべてのノードにアクセスする式です。 式ツリーを変換す るときに、すべてのノードにアクセスします。また、アクセスしながら新しいツリーを構築します。 新しいツリーには、元のノードの参 照や、ツリーに配置した新しいノードが含まれる場合があります。
それでは、実際に式ツリーにアクセスし、ノードの置き換えを含む新しいツリーを作成してみましょう。 この例では、定数を 10 倍 大きい定数に置き換えます。 それ以外に式ツリーの変更はありません。 定数の値を読み取って新しい定数で置き換えるので はなく、定数ノードを、乗算を実行する新しいノードで置き換えます。
ここで定数ノードを見つけたら、子が元の定数である新しい乗算ノードと定数 10 を作成します。
    private static Expression ReplaceNodes(Expression original)
{
    if (original.NodeType == ExpressionType.Constant)
    {
        return Expression.Multiply(original, Expression.Constant(10));
    }
    else if (original.NodeType == ExpressionType.Add)
    {
        var binaryExpression = (BinaryExpression)original;
        return Expression.Add(
            ReplaceNodes(binaryExpression.Left),
            ReplaceNodes(binaryExpression.Right));
}
    return original;
}
 元のノードを置き換えるには、変更を含む新しいツリーを構築します。 置き換えたツリーをコンパイルし、実行して確認すること ができます。
    var one = Expression.Constant(1, typeof(int));
var two = Expression.Constant(2, typeof(int));
var addition = Expression.Add(one, two);
var sum = ReplaceNodes(addition);
var executableFunc = Expression.Lambda(sum);
var func = (Func<int>)executableFunc.Compile();
var answer = func();
Console.WriteLine(answer);
 新しいツリーの構築は、既存のツリー内のノードへのアクセスと、新しいノードの作成とツリーへの挿入を組み合わせた操作で す。
この例は、式ツリーが不変である重要性を示しています。 上の作成した新しいツリーには、新しく作成したノード、既存のツリー
式ツリーを変換する
2020/11/02 • • Edit Online
 
 のノードが混在しています。 既存のツリーのノードは変更できないので、安全です。 また、メモリ効率も大幅に向上します。 同 じノードを 1 つのツリー全体、または複数の式ツリーで使用できます。 ノードは変更できないので、必要に応じていつでも同じ ノードを再利用できます。
加算の走査と実行
加算ノードのツリーをたどり、結果を計算する 2 つ目のビジターを構築して、このことを検証してみましょう。 そのために、これまで に見てきたビジターに何点か変更を加えます。 この新しいバージョンでは、この時点までの加算演算の部分的な合計が返され ます。 定数式の場合、これは単に定数式の値です。 加算式の場合、ツリーの走査が完了すると、結果は左右のオペランドの 合計になります。
    var one = Expression.Constant(1, typeof(int));
var two = Expression.Constant(2, typeof(int));
var three= Expression.Constant(3, typeof(int));
var four = Expression.Constant(4, typeof(int));
var addition = Expression.Add(one, two);
var add2 = Expression.Add(three, four);
var sum = Expression.Add(addition, add2);
// Declare the delegate, so we can call it
// from itself recursively:
Func<Expression, int> aggregate = null;
// Aggregate, return constants, or the sum of the left and right operand.
// Major simplification: Assume every binary expression is an addition.
aggregate = (exp) =>
    exp.NodeType == ExpressionType.Constant ?
    (int)((ConstantExpression)exp).Value :
    aggregate(((BinaryExpression)exp).Left) + aggregate(((BinaryExpression)exp).Right);
var theSum = aggregate(sum);
Console.WriteLine(theSum);
 長いコードですが、概念はとてもわかりやすいものです。 このコードでは、深さ優先検索で子にアクセスします。 定数ノードが検 出されると、ビジターから定数値が返されます。 ビジターが両方の子にアクセスすると、それらの子のサブツリーの合計が計算され ます。 加算ノードで、合計を計算できるようになります。 式ツリー内のすべてのノードがアクセスされると、合計が計算されます。 実行をトレースするには、デバッガーでサンプルを実行して実行をトレースします。
ツリーを走査して、ノードを分析し、合計を計算する方法を簡単にしてみましょう。 大量のトレース情報を含む更新版の Aggregate メソッドを次に示します。

  同じ式に対して実行すると、次の出力が生成されます。
    10
Found Addition Expression
Computing Left node
Found Addition Expression
Computing Left node
Found Constant: 1
Left is: 1
Computing Right node
Found Constant: 2
Right is: 2
Computed sum: 3
Left is: 3
Computing Right node
Found Addition Expression
Computing Left node
Found Constant: 3
Left is: 3
Computing Right node
Found Constant: 4
Right is: 4
Computed sum: 7
Right is: 7
Computed sum: 10
10
 出力をトレースし、上のコードの手順を確認します。 コードがツリーをたどって合計を見つけるときに、各ノードにアクセスし、合 計を計算する方法を理解できます。
次に、 sum1 が指定された式を使用して、別の実行処理を見てみましょう。
  Expression<Func<int> sum1 = () => 1 + (2 + (3 + 4));
 この式の実行の出力を次に示します。
   private static int Aggregate(Expression exp)
{
    if (exp.NodeType == ExpressionType.Constant)
    {
        var constantExp = (ConstantExpression)exp;
        Console.Error.WriteLine($"Found Constant: {constantExp.Value}");
        return (int)constantExp.Value;
    }
    else if (exp.NodeType == ExpressionType.Add)
    {
        var addExp = (BinaryExpression)exp;
        Console.Error.WriteLine("Found Addition Expression");
        Console.Error.WriteLine("Computing Left node");
        var leftOperand = Aggregate(addExp.Left);
        Console.Error.WriteLine($"Left is: {leftOperand}");
        Console.Error.WriteLine("Computing Right node");
        var rightOperand = Aggregate(addExp.Right);
        Console.Error.WriteLine($"Right is: {rightOperand}");
        var sum = leftOperand + rightOperand;
        Console.Error.WriteLine($"Computed sum: {sum}");
        return sum;
}
    else throw new NotSupportedException("Haven't written this yet");
}
 
    最終的な答えは同じですが、ツリーの走査はまったく異なります。 ノードは別の順序で走査されます。これは、優先する演算が 異なるツリーが構成されていたためです。
詳細情報
このサンプルは、式ツリーで表されるアルゴリズムを走査し、解釈するために構築するコードのごく一部です。 式ツリーを別の言語 に変換する汎用的なライブラリを構築するために必要なすべての作業の説明については、Matt Warren のこのシリーズを参照 してください。 式ツリーに含まれる任意のコードを変換する方法について、詳しく説明されています。
式ツリーの真の力がおわかりいただけたでしょうか。 コードのセットを確認し、そのコードに必要な変更を加え、変更されたバー ジョンを実行することができます。 式ツリーは不変なので、既存のツリーのコンポーネントを使用して新しいツリーを作成できま す。 その結果、変更した式ツリーの作成に必要なメモリ量が最小限に抑えられます。
次回 -- まとめ
   Found Addition Expression
Computing Left node
Found Constant: 1
Left is: 1
Computing Right node
Found Addition Expression
Computing Left node
Found Constant: 2
Left is: 2
Computing Right node
Found Addition Expression
Computing Left node
Found Constant: 3
Left is: 3
Computing Right node
Found Constant: 4
Right is: 4
Computed sum: 7
Right is: 7
Computed sum: 9
Right is: 9
Computed sum: 10
10
 
    前へ -- 式の変換 このシリーズでは、式ツリーを使用して、コードをデータとして解釈する動的なプログラムを作成し、そのコードに基づいて新しい
機能を構築する方法について説明してきました。
式ツリーを調べれば、アルゴリズムの目的を理解することができます。 そのコードを調べるだけではなく、 元のコードの変更バー ジョンを表す新しい式ツリーを構築することができます。
また式ツリーは、アルゴリズムを参照して、そのアルゴリズムを別の言語や環境に変換するためにも使用できます。 制限事項
C#の新しい言語要素の中には、式ツリーに正しく変換できないものもあります。式ツリーに await 式や async ラムダ式を含 めることはできません。 C# 6 リリースで追加された機能の多くは、式ツリーで記述されたとおりには表示されません。 新しい機能 は、等価の形式 (以前の構文) で式ツリーに公開されます。 このことは、それほど大きな制約にはならない場合もあります。 実 際、式ツリーを解釈するコードは多くの場合、新しい言語機能が導入されても、以前と同様に動作します。
これらの制限事項があっても、式ツリーでは、データ構造として表されたコードの解釈や変更に依存する動的アルゴリズムを作 成することが可能です。 式ツリーは強力なツールであり、Entity Framework などのリッチなライブラリで目的の機能を達成でき る .NET エコシステムの 1 機能です。
式ツリーのまとめ
2020/03/18 • • Edit Online
 
                相互運用性は、アンマネージ コードへの既存の投資を保持して活用できるようにします。 共通言語ランタイム (CLR) の制御 下で実行されるコードはマネージド コードと呼ばれ、CLR の外部で実行されるコードはアンマネージド コードと呼ばれます。 アン マネージ コードの例は、COM、COM +、C++ コンポーネント、ActiveX コンポーネント、および Microsoft Windows API で す。
.NET では、プラットフォーム呼び出しサービス、System.Runtime.InteropServices 名前空間、C++ 相互運用性、および COM 相互運用性 (COM 相互運用機能) を通して、アンマネージド コードの相互運用を可能にしています。
このセクションの内容
相互運用性の概要
C# のマネージド コードとアンマネージド コードの間で相互運用する方法について説明します。 C# の機能を使用して Office 相互運用オブジェクトにアクセスする方法
Office のプログラミングを容易にするために Visual C# に導入されている機能について説明します。 COM 相互運用機能を使用したプログラミングでインデックス付きプロパティを使用する方法
インデックス付きプロパティを使用して、パラメーターを持つ COM プロパティにアクセスする方法について説明します。
プラットフォーム呼び出しを使用して WAV ファイルを再生する方法
プラットフォーム呼び出しサービスを使用して、Windows オペレーティング システム上の .wav サウンド ファイルを再生する方法 について説明します。
チュートリアル:Office プログラミング
Excel ブックと、ブックへのリンクを含む Word 文書を作成する方法を示します。
COM クラスの例
C# クラスを COM オブジェクトとして公開する方法を示します。
C# 言語仕様
詳細については、「C# 言語の仕様」の「基本概念」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性
のある情報源です。 関連項目
Marshal.ReleaseComObject
C# プログラミング ガイド アンマネージ コードとの相互運用 チュートリアル: Office プログラミング
相互運用性 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      XML 文書化コメントは、ユーザー定義型またはユーザー定義メンバーの定義の上に追加する特殊なコメントです。 このコメント が特殊な理由は、コンパイル時にコンパイラで処理して、XML 文書化ファイルを生成できることです。 コンパイラによって生成さ れた XML ファイルは、.NET アセンブリと共に配布できます。これにより、Visual Studio や他の IDE で、IntelliSense を使用し て型やメンバーに関する概要情報を表示できます。 さらに、DocFX や Sandcastle のようなツールを使用して XML ファイルを 実行し、API リファレンスの Web サイトを生成することができます。
XML 文書化コメントは、その他すべてのコメントと同じように、コンパイラによって無視されます。 コンパイル時に XML ファイルを生成するには、次のいずれかを実行します。
.NET Core を使用してコマンド ラインからアプリケーションを開発している場合は、.csproj プロジェクト ファイルの <PropertyGroup> セクションに GenerateDocumentationFile 要素を追加できます。 また、 DocumentationFile 要 素を使用して、ドキュメント ファイルへのパスを直接指定することもできます。 次の例では、プロジェクト ディレクトリの中
に、アセンブリと同じルート ファイル名で XML ファイルが生成されます。
これは、次の指定と同じです。
Visual Studio を使用してアプリケーションを開発する場合は、プロジェクトを右クリックして、 [プロパティ] を選択しま す。 プロパティ ダイアログ ボックスで、 [ビルド] タブをクリックし、 [XML ドキュメント ファイル] をオンにします。 コンパイ ラがファイルを書き込む場所を変更することもできます。
コマンド ラインから .NET アプリケーションをコンパイルする場合は、コンパイル時に -doc コンパイラ オプションを追加してく ださい。
XML 文書化コメントには、3 つのスラッシュ ( /// ) と、XML 形式のコメント本文を使用します。 例:
チュートリアル
基本的な数式ライブラリを文書化して、新しい開発者が理解/参加しやすく、サードパーティの開発者が使用しやすいものにす る方法を確認しましょう。
シンプルな数式ライブラリのコードを次に示します。
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
   <DocumentationFile>bin\$(Configuration)\$(TargetFramework)\$(AssemblyName).xml</DocumentationFile>
     /// <summary>
/// This class does something.
/// </summary>
public class SomeClass
{
}
 XML コメントを含むコードの文書化 2020/11/02 • • Edit Online
 
        サンプル ライブラリでは、4 つの主要な算術演算 ( add 、 subtract 、 multiply 、 divide ) が、 int と double のデータ型 でサポートされています。
  /*
    The main Math class
    Contains all methods for performing basic math functions
*/
public class Math
{
    // Adds two integers and returns the result
    public static int Add(int a, int b)
    {
        // If any parameter is equal to the max value of an integer
        // and the other is greater than zero
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    // Adds two doubles and returns the result
    public static double Add(double a, double b)
    {
        if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    // Subtracts an integer from another and returns the result
    public static int Subtract(int a, int b)
    {
return a - b; }
    // Subtracts a double from another and returns the result
    public static double Subtract(double a, double b)
    {
return a - b; }
    // Multiplies two integers and returns the result
    public static int Multiply(int a, int b)
    {
return a * b; }
    // Multiplies two doubles and returns the result
    public static double Multiply(double a, double b)
    {
return a * b; }
    // Divides an integer by another and returns the result
    public static int Divide(int a, int b)
    {
return a / b; }
    // Divides a double by another and returns the result
    public static double Divide(double a, double b)
    {
return a / b; }
}

 このライブラリを使用するがそのソース コードにはアクセスできないサード パーティの開発者向けに、コードから API リファレンス ド キュメントを作成できるようにする必要があります。 前述のように、このために XML ドキュメント タグを使用できます。 そこで、C# コンパイラがサポートする標準の XML タグを紹介します。
<summary>
<summary> タグは、型またはメンバーに関する簡単な情報を追加します。この例では、タグの使い方を示すために、このタグを Math クラス定義と最初の Add メソッドに追加しています。コードのそれ以外の部分にも適用してかまいません。
     /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main Math class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    // Adds two integers and returns the result
    /// <summary>
    /// Adds two integers and returns the result.
    /// </summary>
    public static int Add(int a, int b)
    {
        // If any parameter is equal to the max value of an integer
        // and the other is greater than zero
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
}
  <summary> は重要なタグです。IntelliSenseやAPIのリファレンスドキュメントでは、このタグの内容が型やメンバーに関する主 要な情報源であるため、このタグを含めることをお勧めします。
<remarks>
<remarks> タグは、 <summary> タグで提供される型やメンバーに関する情報を補足します。 この例では、このタグをクラスに追 加します。
      /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main Math class.
/// Contains all methods for performing basic math functions.
/// </summary>
/// <remarks>
/// This class can add, subtract, multiply and divide.
/// </remarks>
public class Math
{
}
 <returns>
    <returns>
タグは、メソッド宣言の戻り値を記述します。前と同様に、次の例は最初の Add メソッドに追加した
<returns>
  
 タグを示しています。 その他のメソッドにも同様に追加できます。
    // Adds two integers and returns the result
/// <summary>
/// Adds two integers and returns the result.
/// </summary>
/// <returns>
/// The sum of two integers.
/// </returns>
public static int Add(int a, int b)
{
    // If any parameter is equal to the max value of an integer
    // and the other is greater than zero
    if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
        throw new System.OverflowException();
return a + b; }
 <value>
<value> タグは、プロパティに対して使用する点を除いて、 <returns> タグと同じです。 Math ライブラリに PI という静的プ ロパティがある場合、このタグを次のように使用します。
      /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main Math class.
/// Contains all methods for performing basic math functions.
/// </summary>
/// <remarks>
/// This class can add, subtract, multiply and divide.
/// These operations can be performed on both integers and doubles
/// </remarks>
public class Math
{
    /// <value>Gets the value of PI.</value>
    public static double PI { get; }
}
 <example>
<example> タグを使用してXML文書化情報に例を挿入します。そのために、子 <code> タグを使用します。
  
  code タグは、長い例で改行とインデント設定を維持します。 <para>
<para> タグは、親タグ内の内容を書式設定するために使用します。通常、 は <remarks> や <returns> などの タグの内側で使用して、テキストを段落に分割します。 クラス定義で タグの内容を書式設定できます。
    <para>
 <remarks>
    /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main Math class.
/// Contains all methods for performing basic math functions.
/// </summary>
/// <remarks>
/// <para>This class can add, subtract, multiply and divide.</para>
/// <para>These operations can be performed on both integers and doubles.</para>
/// </remarks>
public class Math
{
}
 <c>
これも書式設定のタグです。 <c> タグは、テキストの一部をコードとしてマークするために使用します。 <code> タグに似ていま すが、インラインで記述する点が異なります。タグの内容の一部として簡単なコード例を示すときに便利です。 Math クラスの ドキュメントを更新してみましょう。
    // Adds two integers and returns the result
/// <summary>
/// Adds two integers and returns the result.
/// </summary>
/// <returns>
/// The sum of two integers.
/// </returns>
/// <example>
/// <code>
/// int c = Math.Add(4, 5);
/// if (c > 10)
/// {
///     Console.WriteLine(c);
/// }
/// </code>
/// </example>
public static int Add(int a, int b)
{
    // If any parameter is equal to the max value of an integer
    // and the other is greater than zero
    if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
        throw new System.OverflowException();
return a + b; }
 
  <exception>
<exception> タグを使用すると、メソッドで特定の例外がスローされる可能性を開発者に知らせることができます。 Math ライ ブラリを見てみると、特定の条件が満たされた場合、両方の Add メソッドで例外がスローされることがわかります。一方、少し わかりにくいですが、 b パラメーターが 0 の場合は整数の Divide メソッドでも例外がスローされます。 ここで、このメソッドに例 外のドキュメントを追加します。
        /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
}
  /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Adds two integers and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two integers.
    /// </returns>
    /// <example>
    /// <code>
    /// int c = Math.Add(4, 5);
    /// if (c > 10)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than 0.</exception>
    public static int Add(int a, int b)
    {
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    /// <summary>
    /// Adds two doubles and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two doubles.
    /// </returns>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than zero.</exception>
    public static double Add(double a, double b)
    {

{
 cref 属性は、現在のコンパイル環境から使用できる例外の参照を表します。プロジェクトまたは参照されたアセンブリに定義 されている任意の型を指定できます。 コンパイラはその値を解決できない場合、警告を出します。
<see>
<see> タグでは、別のコード要素のドキュメントページへのクリック可能なリンクを作成できます。次の例では、2つの Add メ ソッドの間にクリック可能なリンクを作成します。
           if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    /// <summary>
    /// Divides an integer by another and returns the result.
    /// </summary>
    /// <returns>
    /// The division of two integers.
    /// </returns>
    /// <exception cref="System.DivideByZeroException">Thrown when a division by zero occurs.</exception>
    public static int Divide(int a, int b)
    {
return a / b; }
    /// <summary>
    /// Divides a double by another and returns the result.
    /// </summary>
    /// <returns>
    /// The division of two doubles.
    /// </returns>
    /// <exception cref="System.DivideByZeroException">Thrown when a division by zero occurs.</exception>
    public static double Divide(double a, double b)
    {
return a / b; }
}
 
    cref は必須属性です。現在のコンパイル環境から使用できる型またはその型のメンバーへの参照を表します。プロジェクトま たは参照されたアセンブリに定義されている任意の型を指定できます。
<seealso>
<seealso> タグは、 <see> タグと同じように使用します。 唯一の違いは、このタグの内容が一般的に「関連項目」セクションに 配置されることです。 ここで、 seealso タグを整数の Add メソッドに追加して、クラス内の、整数パラメーターを受け取る他の メソッドを参照します。
    /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Adds two integers and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two integers.
    /// </returns>
    /// <example>
    /// <code>
    /// int c = Math.Add(4, 5);
    /// if (c > 10)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than 0.</exception>
    /// See <see cref="Math.Add(double, double)"/> to add doubles.
    public static int Add(int a, int b)
    {
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    /// <summary>
    /// Adds two doubles and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two doubles.
    /// </returns>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than zero.</exception>
    /// See <see cref="Math.Add(int, int)"/> to add integers.
    public static double Add(double a, double b)
    {
        if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
}

    cref 属性は、現在のコンパイル環境から使用できる型またはその型のメンバーへの参照を表します。プロジェクトまたは参照 されたアセンブリに定義されている任意の型を指定できます。
<param>
<param> タグは、メソッドのパラメーターを記述するために使用します。double型の Add メソッドでの例を示します。タグで記 述するパラメーターは必須 name 属性です。
   /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Adds two integers and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two integers.
    /// </returns>
    /// <example>
    /// <code>
    /// int c = Math.Add(4, 5);
    /// if (c > 10)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than 0.</exception>
    /// See <see cref="Math.Add(double, double)"/> to add doubles.
    /// <seealso cref="Math.Subtract(int, int)"/>
    /// <seealso cref="Math.Multiply(int, int)"/>
    /// <seealso cref="Math.Divide(int, int)"/>
    public static int Add(int a, int b)
    {
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
}

  <typeparam>
<typeparam> タグは、 <param> タグと同じように使用しますが、ジェネリック型またはメソッド宣言で、ジェネリック パラメーターを 記述するために使用する点が異なります。簡単なジェネリックメソッドを Math クラスに追加して、ある数量が別の数量より大 きいかどうかを確認します。
      /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Checks if an IComparable is greater than another.
    /// </summary>
    /// <typeparam name="T">A type that inherits from the IComparable interface.</typeparam>
    public static bool GreaterThan<T>(T a, T b) where T : IComparable
    {
        return a.CompareTo(b) > 0;
    }
}
 <paramref>
場合によって、 タグでメソッドの動作を記述している最中に、パラメーターを参照することが必要になることがありま す。そのような場合は、 タグがまさに適しています。double型に基づく Add メソッドの概要を更新しましょう。
 <summary>
 <paramref>
 <param> タグと同様に、パラメーター名は必須 name 属性で指定されます。
   /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Adds two doubles and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two doubles.
    /// </returns>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than zero.</exception>
    /// See <see cref="Math.Add(int, int)"/> to add integers.
    /// <param name="a">A double precision number.</param>
    /// <param name="b">A double precision number.</param>
    public static double Add(double a, double b)
    {
        if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
}
 
  <typeparamref>
<typeparamref> タグは、 <paramref> タグと同じように使用しますが、ジェネリック型またはメソッド宣言で、ジェネリック パラメー ターを記述するために使用する点が異なります。 以前に作成した同じジェネリック メソッドを使用することができます。
      /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Checks if an IComparable <typeparamref name="T"/> is greater than another.
    /// </summary>
    /// <typeparam name="T">A type that inherits from the IComparable interface.</typeparam>
    public static bool GreaterThan<T>(T a, T b) where T : IComparable
    {
        return a.CompareTo(b) > 0;
    }
}
 <list>
<list> タグを使用して、ドキュメント情報を、順序指定済みリスト、順序指定されていないリスト、または表として書式設定し ます。 Math ライブラリがサポートするそれぞれの算術演算の順不同のリストを作成します。
    /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// </summary>
public class Math
{
    /// <summary>
    /// Adds two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two doubles.
    /// </returns>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than zero.</exception>
    /// See <see cref="Math.Add(int, int)"/> to add integers.
    /// <param name="a">A double precision number.</param>
    /// <param name="b">A double precision number.</param>
    public static double Add(double a, double b)
    {
        if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
}
 
   type 属性を number または table に変更することで、順序付きリストまたは表をそれぞれ作成できます。 <inheritdoc>
<inheritdoc> タグを使用して、基底クラス、インターフェイス、および同様のメソッドからXMLコメントを継承できます。これに より、重複する XML コメントの不要なコピーと貼り付けを行う必要がなくなり、XML コメントが自動的に同期されたままになりま す。
     /*
    The IMath interface
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// This is the IMath interface.
/// </summary>
public interface IMath
{
}
/// <inheritdoc/>
public class Math : IMath
{
}
 すべてをまとめた配置 ここまで、チュートリアルに沿ってコードに必要なタグを適用し、コードは次のようになっています。
   /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// <list type="bullet">
/// <item>
/// <term>Add</term>
/// <description>Addition Operation</description>
/// </item>
/// <item>
/// <term>Subtract</term>
/// <description>Subtraction Operation</description>
/// </item>
/// <item>
/// <term>Multiply</term>
/// <description>Multiplication Operation</description>
/// </item>
/// <item>
/// <term>Divide</term>
/// <description>Division Operation</description>
/// </item>
/// </list>
/// </summary>
public class Math
{
}
     /*
    The main Math class
    Contains all methods for performing basic math functions
*/

*/
  /// <summary>
/// The main <c>Math</c> class.
/// Contains all methods for performing basic math functions.
/// <list type="bullet">
/// <item>
/// <term>Add</term>
/// <description>Addition Operation</description>
/// </item>
/// <item>
/// <term>Subtract</term>
/// <description>Subtraction Operation</description>
/// </item>
/// <item>
/// <term>Multiply</term>
/// <description>Multiplication Operation</description>
/// </item>
/// <item>
/// <term>Divide</term>
/// <description>Division Operation</description>
/// </item>
/// </list>
/// </summary>
/// <remarks>
/// <para>This class can add, subtract, multiply and divide.</para>
/// <para>These operations can be performed on both integers and doubles.</para>
/// </remarks>
public class Math
{
    // Adds two integers and returns the result
    /// <summary>
    /// Adds two integers <paramref name="a"/> and <paramref name="b"/> and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two integers.
    /// </returns>
    /// <example>
    /// <code>
    /// int c = Math.Add(4, 5);
    /// if (c > 10)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than 0.</exception>
    /// See <see cref="Math.Add(double, double)"/> to add doubles.
    /// <seealso cref="Math.Subtract(int, int)"/>
    /// <seealso cref="Math.Multiply(int, int)"/>
    /// <seealso cref="Math.Divide(int, int)"/>
    /// <param name="a">An integer.</param>
    /// <param name="b">An integer.</param>
    public static int Add(int a, int b)
    {
        // If any parameter is equal to the max value of an integer
        // and the other is greater than zero
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    // Adds two doubles and returns the result
    /// <summary>
    /// Adds two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
    /// </summary>
    /// <returns>
    /// The sum of two doubles.
    /// </returns>
  
/// </returns>
      /// <example>
    /// <code>
    /// double c = Math.Add(4.5, 5.4);
    /// if (c > 10)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.OverflowException">Thrown when one parameter is max
    /// and the other is greater than 0.</exception>
    /// See <see cref="Math.Add(int, int)"/> to add integers.
    /// <seealso cref="Math.Subtract(double, double)"/>
    /// <seealso cref="Math.Multiply(double, double)"/>
    /// <seealso cref="Math.Divide(double, double)"/>
    /// <param name="a">A double precision number.</param>
    /// <param name="b">A double precision number.</param>
    public static double Add(double a, double b)
    {
        // If any parameter is equal to the max value of an integer
        // and the other is greater than zero
        if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    // Subtracts an integer from another and returns the result
    /// <summary>
    /// Subtracts <paramref name="b"/> from <paramref name="a"/> and returns the result.
    /// </summary>
    /// <returns>
    /// The difference between two integers.
    /// </returns>
    /// <example>
    /// <code>
    /// int c = Math.Subtract(4, 5);
    /// if (c > 1)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// See <see cref="Math.Subtract(double, double)"/> to subtract doubles.
    /// <seealso cref="Math.Add(int, int)"/>
    /// <seealso cref="Math.Multiply(int, int)"/>
    /// <seealso cref="Math.Divide(int, int)"/>
    /// <param name="a">An integer.</param>
    /// <param name="b">An integer.</param>
    public static int Subtract(int a, int b)
    {
return a - b; }
    // Subtracts a double from another and returns the result
    /// <summary>
    /// Subtracts a double <paramref name="b"/> from another double <paramref name="a"/> and returns the
result.
    /// </summary>
    /// <returns>
    /// The difference between two doubles.
    /// </returns>
    /// <example>
    /// <code>
    /// double c = Math.Subtract(4.5, 5.4);
    /// if (c > 1)
    /// {
    ///     Console.WriteLine(c);
  /// }

 /// }
/// </code>
/// </example>
/// See <see cref="Math.Subtract(int, int)"/> to subtract integers.
/// <seealso cref="Math.Add(double, double)"/>
/// <seealso cref="Math.Multiply(double, double)"/>
/// <seealso cref="Math.Divide(double, double)"/>
/// <param name="a">A double precision number.</param>
/// <param name="b">A double precision number.</param>
public static double Subtract(double a, double b)
{
return a - b; }
// Multiplies two integers and returns the result
/// <summary>
/// Multiplies two integers <paramref name="a"/> and <paramref name="b"/> and returns the result.
/// </summary>
/// <returns>
/// The product of two integers.
/// </returns>
/// <example>
/// <code>
/// int c = Math.Multiply(4, 5);
/// if (c > 100)
/// {
///     Console.WriteLine(c);
/// }
/// </code>
/// </example>
/// See <see cref="Math.Multiply(double, double)"/> to multiply doubles.
/// <seealso cref="Math.Add(int, int)"/>
/// <seealso cref="Math.Subtract(int, int)"/>
/// <seealso cref="Math.Divide(int, int)"/>
/// <param name="a">An integer.</param>
/// <param name="b">An integer.</param>
public static int Multiply(int a, int b)
{
return a * b; }
// Multiplies two doubles and returns the result
/// <summary>
/// Multiplies two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
/// </summary>
/// <returns>
/// The product of two doubles.
/// </returns>
/// <example>
/// <code>
/// double c = Math.Multiply(4.5, 5.4);
/// if (c > 100.0)
/// {
///     Console.WriteLine(c);
/// }
/// </code>
/// </example>
/// See <see cref="Math.Multiply(int, int)"/> to multiply integers.
/// <seealso cref="Math.Add(double, double)"/>
/// <seealso cref="Math.Subtract(double, double)"/>
/// <seealso cref="Math.Divide(double, double)"/>
/// <param name="a">A double precision number.</param>
/// <param name="b">A double precision number.</param>
public static double Multiply(double a, double b)
{
return a * b; }
 // Divides an integer by another and returns the result
  /// <summary>

    コードから、クリック可能な相互参照を含む、詳細なドキュメント Web サイトを生成できます。 ただし、別の問題に直面しま す。コードが読みにくくなります。 大量の情報を処理する必要があり、このコードを利用する開発者にとって非常に厄介です。 さいわい、これに対処するのに役立つ XML タグがあります。
<include>
 <include> タグでは、文書化コメントをソースコードファイルに直接配置するのではなく、ソースコードの型とメンバーを記述し
    /// <summary>
    /// Divides an integer <paramref name="a"/> by another integer <paramref name="b"/> and returns the
result.
    /// </summary>
    /// <returns>
    /// The quotient of two integers.
    /// </returns>
    /// <example>
    /// <code>
    /// int c = Math.Divide(4, 5);
    /// if (c > 1)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.DivideByZeroException">Thrown when <paramref name="b"/> is equal to 0.
</exception>
    /// See <see cref="Math.Divide(double, double)"/> to divide doubles.
    /// <seealso cref="Math.Add(int, int)"/>
    /// <seealso cref="Math.Subtract(int, int)"/>
    /// <seealso cref="Math.Multiply(int, int)"/>
    /// <param name="a">An integer dividend.</param>
    /// <param name="b">An integer divisor.</param>
    public static int Divide(int a, int b)
    {
return a / b; }
    // Divides a double by another and returns the result
    /// <summary>
    /// Divides a double <paramref name="a"/> by another double <paramref name="b"/> and returns the result.
    /// </summary>
    /// <returns>
    /// The quotient of two doubles.
    /// </returns>
    /// <example>
    /// <code>
    /// double c = Math.Divide(4.5, 5.4);
    /// if (c > 1.0)
    /// {
    ///     Console.WriteLine(c);
    /// }
    /// </code>
    /// </example>
    /// <exception cref="System.DivideByZeroException">Thrown when <paramref name="b"/> is equal to 0.
</exception>
    /// See <see cref="Math.Divide(int, int)"/> to divide integers.
    /// <seealso cref="Math.Add(double, double)"/>
    /// <seealso cref="Math.Subtract(double, double)"/>
    /// <seealso cref="Math.Multiply(double, double)"/>
    /// <param name="a">A double precision dividend.</param>
    /// <param name="b">A double precision divisor.</param>
    public static double Divide(double a, double b)
    {
return a / b; }
}
 
 た別個の XML ファイル内のコメントを参照できます。
ここで、すべてのXMLタグを、docs.xml という別のXMLファイルに移動します。ファイルの名前は何でもかまいません。
     <docs>
    <members name="math">
        <Math>
            <summary>
            The main <c>Math</c> class.
            Contains all methods for performing basic math functions.
            </summary>
            <remarks>
            <para>This class can add, subtract, multiply and divide.</para>
            <para>These operations can be performed on both integers and doubles.</para>
            </remarks>
        </Math>
        <AddInt>
            <summary>
            Adds two integers <paramref name="a"/> and <paramref name="b"/> and returns the result.
            </summary>
            <returns>
            The sum of two integers.
            </returns>
            <example>
            <code>
            int c = Math.Add(4, 5);
            if (c > 10)
            {
                Console.WriteLine(c);
            }
            </code>
            </example>
            <exception cref="System.OverflowException">Thrown when one parameter is max
            and the other is greater than 0.</exception>
            See <see cref="Math.Add(double, double)"/> to add doubles.
            <seealso cref="Math.Subtract(int, int)"/>
            <seealso cref="Math.Multiply(int, int)"/>
            <seealso cref="Math.Divide(int, int)"/>
            <param name="a">An integer.</param>
            <param name="b">An integer.</param>
        </AddInt>
        <AddDouble>
            <summary>
            Adds two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
            </summary>
            <returns>
            The sum of two doubles.
            </returns>
            <example>
            <code>
            double c = Math.Add(4.5, 5.4);
            if (c > 10)
            {
                Console.WriteLine(c);
            }
            </code>
            </example>
            <exception cref="System.OverflowException">Thrown when one parameter is max
            and the other is greater than 0.</exception>
            See <see cref="Math.Add(int, int)"/> to add integers.
            <seealso cref="Math.Subtract(double, double)"/>
            <seealso cref="Math.Multiply(double, double)"/>
            <seealso cref="Math.Divide(double, double)"/>
            <param name="a">A double precision number.</param>
            <param name="b">A double precision number.</param>
        </AddDouble>
        <SubtractInt>
            <summary>

<summary>
  result.
    Subtracts <paramref name="b"/> from <paramref name="a"/> and returns the result.
    </summary>
    <returns>
    The difference between two integers.
    </returns>
    <example>
    <code>
    int c = Math.Subtract(4, 5);
    if (c > 1)
    {
        Console.WriteLine(c);
    }
    </code>
    </example>
    See <see cref="Math.Subtract(double, double)"/> to subtract doubles.
    <seealso cref="Math.Add(int, int)"/>
    <seealso cref="Math.Multiply(int, int)"/>
    <seealso cref="Math.Divide(int, int)"/>
    <param name="a">An integer.</param>
    <param name="b">An integer.</param>
</SubtractInt>
<SubtractDouble>
    <summary>
    Subtracts a double <paramref name="b"/> from another double <paramref name="a"/> and returns the
    </summary>
    <returns>
    The difference between two doubles.
    </returns>
    <example>
    <code>
    double c = Math.Subtract(4.5, 5.4);
    if (c > 1)
    {
        Console.WriteLine(c);
    }
    </code>
    </example>
    See <see cref="Math.Subtract(int, int)"/> to subtract integers.
    <seealso cref="Math.Add(double, double)"/>
    <seealso cref="Math.Multiply(double, double)"/>
    <seealso cref="Math.Divide(double, double)"/>
    <param name="a">A double precision number.</param>
    <param name="b">A double precision number.</param>
</SubtractDouble>
<MultiplyInt>
    <summary>
    Multiplies two integers <paramref name="a"/> and <paramref name="b"/> and returns the result.
    </summary>
    <returns>
    The product of two integers.
    </returns>
    <example>
    <code>
    int c = Math.Multiply(4, 5);
    if (c > 100)
    {
        Console.WriteLine(c);
    }
    </code>
    </example>
    See <see cref="Math.Multiply(double, double)"/> to multiply doubles.
    <seealso cref="Math.Add(int, int)"/>
    <seealso cref="Math.Subtract(int, int)"/>
    <seealso cref="Math.Divide(int, int)"/>
    <param name="a">An integer.</param>
    <param name="b">An integer.</param>
</MultiplyInt>
  <MultiplyDouble>

<MultiplyDouble>
  result.
    <summary>
    Multiplies two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
    </summary>
    <returns>
    The product of two doubles.
    </returns>
    <example>
    <code>
    double c = Math.Multiply(4.5, 5.4);
    if (c > 100.0)
    {
        Console.WriteLine(c);
    }
    </code>
    </example>
    See <see cref="Math.Multiply(int, int)"/> to multiply integers.
    <seealso cref="Math.Add(double, double)"/>
    <seealso cref="Math.Subtract(double, double)"/>
    <seealso cref="Math.Divide(double, double)"/>
    <param name="a">A double precision number.</param>
    <param name="b">A double precision number.</param>
</MultiplyDouble>
<DivideInt>
    <summary>
    Divides an integer <paramref name="a"/> by another integer <paramref name="b"/> and returns the
    </summary>
    <returns>
    The quotient of two integers.
    </returns>
    <example>
    <code>
    int c = Math.Divide(4, 5);
    if (c > 1)
    {
        Console.WriteLine(c);
    }
    </code>
    </example>
    <exception cref="System.DivideByZeroException">Thrown when <paramref name="b"/> is equal to 0.
    See <see cref="Math.Divide(double, double)"/> to divide doubles.
    <seealso cref="Math.Add(int, int)"/>
    <seealso cref="Math.Subtract(int, int)"/>
    <seealso cref="Math.Multiply(int, int)"/>
    <param name="a">An integer dividend.</param>
</exception>
result.
Divides a double <paramref name="a"/> by another double <paramref name="b"/> and returns the
</summary>
<returns>
The quotient of two doubles.
</returns>
<example>
<code>
double c = Math.Divide(4.5, 5.4);
if (c > 1.0)
{
    Console.WriteLine(c);
}
</code>
</example>
<exception cref="System.DivideByZeroException">Thrown when <paramref name="b"/> is equal to 0.
</exception>
    <param name="b">An integer divisor.</param>
</DivideInt>
<DivideDouble>
    <summary>
See <see cref="Math.Divide(int, int)"/> to divide integers.
  <seealso cref="Math.Add(double, double)"/>

 上に示した XML では、各メンバーの文書化コメントが、タグの働きを表す名前の付いたタグの内側に直接記述されています。 自分の方法を選択できます。XMLコメントを別のファイルに移動したので、<include> タグを使用して、コードがどのように読 みやすくなるか見てみましょう。
                <seealso cref="Math.Add(double, double)"/>
            <seealso cref="Math.Subtract(double, double)"/>
            <seealso cref="Math.Multiply(double, double)"/>
            <param name="a">A double precision dividend.</param>
            <param name="b">A double precision divisor.</param>
        </DivideDouble>
    </members>
</docs>
     /*
    The main Math class
    Contains all methods for performing basic math functions
*/
/// <include file='docs.xml' path='docs/members[@name="math"]/Math/*'/>
public class Math
{
    // Adds two integers and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/AddInt/*'/>
    public static int Add(int a, int b)
    {
        // If any parameter is equal to the max value of an integer
        // and the other is greater than zero
        if ((a == int.MaxValue && b > 0) || (b == int.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    // Adds two doubles and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/AddDouble/*'/>
    public static double Add(double a, double b)
    {
        // If any parameter is equal to the max value of an integer
        // and the other is greater than zero
        if ((a == double.MaxValue && b > 0) || (b == double.MaxValue && a > 0))
            throw new System.OverflowException();
return a + b; }
    // Subtracts an integer from another and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/SubtractInt/*'/>
    public static int Subtract(int a, int b)
    {
return a - b; }
    // Subtracts a double from another and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/SubtractDouble/*'/>
    public static double Subtract(double a, double b)
    {
return a - b; }
    // Multiplies two integers and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/MultiplyInt/*'/>
    public static int Multiply(int a, int b)
    {
return a * b; }
    // Multiplies two doubles and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/MultiplyDouble/*'/>

     /// <include file='docs.xml' path='docs/members[@name="math"]/MultiplyDouble/*'/>
 このようになります。コードは読みやすい状態に戻り、しかも文書化の情報は失われていません。 file は、文書化の情報を含むXMLファイルの名前を表す属性です。
path は、指定した file に含まれる tag name への XPath クエリを表す属性です。
name は、コメントの前に配置するタグの名前指定子を表す属性です。
id 属性は、name の代わりに使用でき、コメントの前にあるタグのIDを表します。 ユーザー定義タグ
上に示したすべてのタグは、C# コンパイラで認識されるタグを表します。 ただし、ユーザー独自のタグも自由に定義できます。 Sandcastle などのツールを使用すると、<event> や <note> などの追加のタグや、名前空間の文書化もサポートされます。 カスタムまたは社内ドキュメント生成ツールを標準タグと共に使用して、HTML から PDF への複数の出力形式をサポートできま す。
推奨事項
コードを文書化することをお勧めするのには、さまざまな理由があります。 いくつかのベスト プラクティス、一般的なユース ケース
のシナリオ、XML 文書化タグを C# コードで使用するときに知っておく必要があることを以下に示します。
整合性を保つため、一般に公開されているすべての型とそのメンバーを文書化する必要があります。 必要な文書化はすべ て実行してください。
プライベート メンバーも XML コメントを使用して文書化できます。 ただし、これによりライブラリの内部 (機密の可能性があ る) の動作が公開されます。
型とそのメンバーには、少なくとも <summary> タグが必要です。そのタグの内容がIntelliSenseで必要なためです。 文書化のテキストは、句点で終わる完全な文を使用して作成する必要があります。 部分クラスは完全にサポートされ、文書化の情報は、その型の 1 つのエントリに連結されます。
コンパイラは、 <exception> 、 <include> 、 <param> 、 <see> 、 <seealso> 、 <typeparam> の各タグの構文を確認しま す。
コンパイラは、ファイルのパスおよびコードの他の部分への参照を含むパラメーターを検証します。 関連項目
XML ドキュメント コメント (C# プログラミング ガイド) ドキュメント コメント用の推奨タグ (C# プログラミング ガイド)
              public static double Multiply(double a, double b)
    {
return a * b; }
    // Divides an integer by another and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/DivideInt/*'/>
    public static int Divide(int a, int b)
    {
return a / b; }
    // Divides a double by another and returns the result
    /// <include file='docs.xml' path='docs/members[@name="math"]/DivideDouble/*'/>
    public static double Divide(double a, double b)
    {
return a / b; }
}
 
     このチュートリアルでは、.NET でのバージョン管理のしくみについて学習します。 また、ライブラリのバージョン管理を行う際や、ラ イブラリを新しいバージョンにアップグレードする際の考慮事項についても学習します。
ライブラリの作成
一般用途向けの .NET ライブラリを作成したことがある開発者であれば、新しい更新プログラムをロールアウトする必要に迫られ た経験もあることでしょう。 このプロセスのあり方によって、既存のコードを新バージョンのライブラリへとシームレスに移行できるか どうかは大きく左右されます。 ここでは、新しいリリースを作成する際に考慮すべき点について、いくつか説明します。
セマンティック バージョン管理
セマンティック バージョン管理 (略して SemVer) は、特定のマイルス トーン イベントを示すためにライブラリの各バージョンに適用 される命名規則です。 うまく管理すれば、ライブラリに適用されたバージョン情報によって、同じライブラリの旧バージョンを使用し たプロジェクトとの互換性を開発者が確認できるようになります。
SemVerに対する最も基本的なアプローチは、3コンポーネント形式 MAJOR.MINOR.PATCH です。
MAJOR は、互換性のないAPI変更を加えたときにインクリメントされます
MINOR は、下位互換性のある方法で機能を追加したときにインクリメントされます PATCH は、下位互換性のあるバグ修正を行ったときにインクリメントされます
.NET ライブラリにバージョン情報を適用する際には、他のシナリオ (プレリリース バージョンなど) を指定することもできます。 下位互換性
ライブラリの新バージョンをリリースする際、特に大きな懸念事項となるのが、旧バージョンとの互換性です。 旧バージョンに依存 するコードが再コンパイル後に新バージョンで機能する場合、ライブラリの新バージョンは旧バージョンに対してソース互換性があ るということになります。 旧バージョンに依存するアプリケーションが再コンパイルを経ずに新バージョンで機能する場合、ライブラリ の新バージョンはバイナリ互換性があるということになります。
次に示すのは、旧バージョンのライブラリとの下位互換性を維持するうえでの考慮事項です。
仮想メソッド:新バージョンで仮想メソッド非仮想にした場合は、そのメソッドをオーバーライドするプロジェクトを更新する必要 があります。 これはきわめて重大な変更であり、極力回避することをお勧めします。 メソッドのシグネチャ:メソッドの動作を更新するためにそのシグネチャも変更する必要がある場合は、代わりにオーバー ロード を作成して、そのメソッドに対するコード呼び出しがその後も機能するようにしてください。 旧メソッドのシグネチャは、新しいメ ソッド シグネチャを呼び出すようにいつでも操作して、実装の整合性を維持できます。
Obsolete 属性:この属性をコード内で使用すると、現在非推奨に指定されていて、今後のバージョンで削除される可能性 が高いクラスやクラス メンバーを指定することができます。 これにより、ライブラリを使用している開発者が、今後の重大な変 更に余裕を持って準備できるようになります。 省略可能なメソッド引数:これまで省略可能であったメソッド引数を必須にしたり、それらの既定値を変更する場合は、それ らの引数が指定されていないすべてのコードを更新する必要があります。
新バージョンのライブラリへの更新を行いやすくすれば、その分、ユーザーがアップグレードを早く完了できるようになります。 アプリケーション構成ファイル
     NOTE
必須の引数を省略可能にしても、メソッドの動作が変更されない限り、影響はほとんどありません。
 C# でのバージョン管理 2020/04/27 • • Edit Online
 
    .NET 開発者の皆さんは、ほとんどのタイプのプロジェクトで   ファイルを使用しているのではないでしょうか。 このシン プルな構成ファイルは、新しい更新プログラムのロールアウトをスムーズにするうえで大いに役立ちます。 通常、ライブラリを設計 する際には、定期的に変更される可能性が高い情報を app.config ファイルに保存します。そうすれば、それらの情報が更新 された際にも、ライブラリの再コンパイルを行うことなく、旧バージョンの構成ファイルを新しいバージョンに置き換えるだけで済みま す。
ライブラリの使用
他の開発者によって作成された .NET ライブラリを使用する場合には、新バージョンのライブラリが自分のプロジェクトに対して完 全互換ではない場合が多く、それらの変更にうまく対応するために、コードを更新しなければならないことも少なくありません。
幸いなことに、C# と .NET エコシステムでは、重大な変更をもたらす可能性がある新バージョンのライブラリと正常に連携できる よう、アプリを簡単に更新するための機能や技術が提供されています。
アセンブリ バインド リダイレクト
app.config ファイルを使用して、アプリで使用するライブラリのバージョンを更新できます。 バインド リダイレクトというものを追加 することで、アプリを再コンパイルしなくても、新しいライブラリ バージョンを使用することができます。 次の例は、アプリの app.configファイルを更新して、当初のコンパイルに使用された 1.0.0 バージョンではなく、1.0.1 パッチバージョンの
ReferencedLibrary が使用されるようにする方法を示しています。
      <dependentAssembly>
    <assemblyIdentity name="ReferencedLibrary" publicKeyToken="32ab4ba45e0a69a1" culture="en-us" />
    <bindingRedirect oldVersion="1.0.0" newVersion="1.0.1" />
</dependentAssembly>
     NOTE
このアプローチは、新バージョンの ReferencedLibrary がアプリに対してバイナリ互換性を持っている場合にのみ有効です。 互換性を判 断するときに注意すべき変更点については、上記の「下位互換性」セクションをご覧ください。
  new
new 修飾子を使用して、基底クラスの継承メンバーを非表示にできます。これは、派生クラスが基底クラスの更新に対応でき るようにするための 1 つの手段です。
次の例を参照してください。
 app.config
 
  出力
上記の例では、 DerivedClass によって BaseClass 内の MyMethod メソッドを非表示にしています。 つまり、派生クラス内に 既に存在しているメンバーが新バージョンのライブラリ内の基底クラスによって追加された場合には、派生クラスのメンバーに
new 修飾子を使用するだけで、基底クラスのメンバーを非表示にすることができます。
new 修飾子が指定されなかった場合、派生クラスは既定で基底クラスの競合メンバーを非表示にします。コンパイラの警告が 生成されますが、コードはコンパイルされます。 つまり、既存のクラスに新しいメンバーを追加するだけで、新バージョンのライブラ リは依存先のコードに対して、ソースとバイナリの両方の互換性を持つことになります。
override
override 修飾子を使用した場合、派生実装は基底クラスメンバーの実装を非表示にはせず、そのメンバーを拡張します。 基底クラスのメンバーには、 virtual 修飾子が適用されている必要があります。
    A base method
A derived method
         public class BaseClass
{
    public void MyMethod()
    {
        Console.WriteLine("A base method");
    }
}
public class DerivedClass : BaseClass
{
    public new void MyMethod()
    {
        Console.WriteLine("A derived method");
    }
}
public static void Main()
{
    BaseClass b = new BaseClass();
    DerivedClass d = new DerivedClass();
    b.MyMethod();
    d.MyMethod();
}
 
  出力
override 修飾子はコンパイル時に評価され、オーバーライドする仮想メンバーが見つからない場合には、コンパイラがエラーを スローします。
説明されている手法の知識を持ち、それらを使用する状況を理解しておくと、ライブラリのバージョン間の移行を容易にするため に今後も役立ちます。
    Base Method One: Method One
Derived Method One: Derived Method One
     public class MyBaseClass
{
    public virtual string MethodOne()
    {
        return "Method One";
    }
}
public class MyDerivedClass : MyBaseClass
{
    public override string MethodOne()
    {
        return "Derived Method One";
    }
}
public static void Main()
{
    MyBaseClass b = new MyBaseClass();
    MyDerivedClass d = new MyDerivedClass();
    Console.WriteLine("Base Method One: {0}", b.MethodOne());
    Console.WriteLine("Derived Method One: {0}", d.MethodOne());
}
 
                        C# ガイドの方法に関するセクションでは、一般的な質問に対する簡単な回答が見つかります。 場合によっては、記事が複数 のセクションで表示されることもあります。 複数の検索パスで見つけやすいようにしました。
一般的な C# の概念
C# の開発者には一般的な方法といえるヒントやコツがいくつかあります。
オブジェクト初期化子を使用してオブジェクトを初期化する。 メソッドに構造体を渡す場合とクラスを渡す場合の違いについて理解する。 演算子のオーバーロードを使用する。 カスタム拡張メソッドを実装して呼び出す。 C#のプログラマでもVisualBasicの My 名前空間を使用する場合がある。 拡張メソッドを使用して enum 型の新しいメソッドを作成する。
クラス、レコード、構造体のメンバー
クラス、レコード、および構造体を作成してプログラムを実装します。 次の手法は、クラス、レコード、または構造体を作成すると きによく使用されます。
自動的に実装されたプロパティを宣言する。 読み取り/書き込みのプロパティを宣言して使用する。 定数を定義する。
文字列出力を提供するために ToString メソッドをオーバーライドする。 抽象プロパティを定義する。
XML ドキュメント機能を使用してコードを文書化する。
インターフェイス メンバーを明示的に実装してパブリック インターフェイスを簡潔に保つ。 2 つのインターフェイスのメンバーを明示的に実装する。
コレクションの操作 次の記事は、データのコレクションの操作に役立ちます。
コレクション初期化子を使用してディクショナリを初期化する。 文字列の処理
文字列は、文字列の表示または操作に使用される基本的なデータ型です。 次の記事で、文字列に関する一般的なプラク ティスを説明しています。
文字列を比較する。 文字列の内容を変更する。 文字列が数値を表すかどうかを判断する。
String.Split を使用して文字列を区切る。 複数の文字列を 1 つに結合する。 文字列内のテキストを検索する。
  型の変換
方法 (C#) 2021/03/09 • • Edit Online
 
                           オブジェクトを別の型に変換しなければならない場合があります。
文字列が数値を表すかどうかを判断する。
16 進数を表す文字列と数値を変換する。
文字列を DateTime に変換する。
バイト配列を int に変換する。
文字列を数値に変換する。
パターンマッチングで as と is の演算子を使用して異なる型に安全にキャストする。 カスタムの型変換を定義する。
型が null 許容値型であるかを判断する。
null 許容値型と null 非許容値型の間で変換する。
等価比較と順序付け比較 等価に関する独自のルールを定義する、またはその型のオブジェクト間の自然な順序を定義する型を作成することができます。
参照に基づく等価性をテストする。 型の値に基づく等価性を定義する。
例外処理
.NET プログラムは、例外がスローされたことによってメソッドの作業が完了しなかったことを報告します。 次の記事では、例外の 操作について説明します。
try および catch を使用して例外を処理する。
finally 句を使用してリソースをクリーンアップする。 非 CLS (共通言語仕様) の例外から回復する。
デリゲートおよびイベント
デリゲートおよびイベントは、弱く結合されたコード ブロックを伴うストラテジ向けの機能を提供します。
デリゲートを宣言し、インスタンス化して使用する。 マルチキャスト デリゲートを結合する。
イベントは、通知を発行またはサブスクライブするためのメカニズムを提供します。
イベントのサブスクリプションとサブスクリプションの解除。 インターフェイスで宣言されたイベントを実装する。 コードによってイベントを発行するときに .NET ガイドラインに準拠する。 派生クラスから基底クラスで定義されているイベントを発生させる。 カスタム イベント アクセサーを実装する。
LINQ のプラクティス
LINQ では、LINQ クエリ式パターンをサポートするすべてのデータ ソースのクエリを実行するコードを記述できます。 次の記事
は、パターンの理解と、さまざまなデータ ソースの操作に役立ちます。
コレクションのクエリを実行する。 クエリでラムダ式を使用する。
クエリ式で var を使用する。 クエリから要素のプロパティのサブセットを返す。 複雑なフィルターを使用してクエリを記述する。
  
              データ ソースの要素を並べ替える。 複数のキーに基づいて要素を並べ替える。 プロジェクションの型を制御する。
ソース シーケンス内の値の出現箇所をカウントする。 中間値を計算する。 複数のソースからデータをマージする。
2 つのシーケンスの差集合を見つける。 空のクエリ結果をデバッグする。
LINQ クエリにカスタム メソッドを追加する。
複数のスレッドおよび非同期処理
最新のプログラムでは、多くの場合、非同期操作を使用します。 次の記事は、これらの手法の使用方法を理解するのに役立 ちます。
System.Threading.Tasks.Task.WhenAll を使用して非同期のパフォーマンスを向上させる。
async および await を使用して複数のWeb要求を並行して作成する。 スレッド プールを使用する。
プログラムのコマンド ライン引数
通常、C# のプログラムにはコマンド ライン引数が含まれます。 次の記事では、そのようなコマンド ライン引数にアクセスして処 理する方法について説明します。
for を使用してすべてのコマンドライン引数を取得する。
 
      String.Split メソッドは、1 つまたは複数の区切り記号に基づいて入力文字列を分割することで部分文字列の配列を作成し ます。 このメソッドは、英語のように単語の間にスペースがある文章の場合に、単語の境界で文字列を分割する最も簡単な方 法になります。 他の特定の文字や文字列で文字列を分割する際にも利用されます。
次のコードは一般的なフレーズを単語ごとの文字列の配列に分割します。
区切り文字のインスタンスごとに、返される配列で値が生成されます。 連続する区切り文字により、返される配列の値として空 の文字列が生成されます。 空白文字を区切り記号として使用する次の例では、空の文字列がどのように作成されるかを確認 できます。
この動作により、コンマ区切り値 (CSV) ファイルなどの形式で表形式データを簡単に表すことができます。 連続するコンマは空 の列を表します。
任意の StringSplitOptions.RemoveEmptyEntries パラメーターを渡し、返される配列で空の文字列を除外できます。 返さ れるコレクションの処理が複雑な場合、LINQ を使用し、結果のシーケンスを操作できます。
String.Split では、複数の区切り文字を使用できます。 次の例ではスペース、コンマ、ピリオド、コロン、タブを区切り文字として 使用しています。これらは配列で Split に渡されます。 コードの一番下にあるループは、返される配列の各単語を表示します。
    NOTE
この記事の C# 例は、Try.NET インライン コード ランナーとプレイグラウンドで実行されます。 [ ] ボタンを選択すると、対話型ウィンドウで例 が実行されます。 コードを実行したら、コードを変更し、 [ ] をもう一度選択して変更後のコードを実行できます。 変更後のコードが対話 型ウィンドウで実行されるか、コンパイルできなかった場合、対話型ウィンドウにすべての C# コンパイラ エラー メッセージが表示されます。
     string phrase = "The quick brown fox jumps over the lazy dog.";
string[] words = phrase.Split(' ');
foreach (var word in words)
{
    System.Console.WriteLine($"<{word}>");
}
     string phrase = "The quick brown    fox     jumps over the lazy dog.";
string[] words = phrase.Split(' ');
foreach (var word in words)
{
    System.Console.WriteLine($"<{word}>");
}
 C# で String.Split を使用して文字列を分割する方
法
2021/03/06 • • Edit Online
 
      区切りの連続するインスタンスにより、出力配列で空の文字列が生成されます。
    char[] delimiterChars = { ' ', ',', '.', ':', '\t' };
string text = "one\ttwo :,five six seven";
System.Console.WriteLine($"Original text: '{text}'");
string[] words = text.Split(delimiterChars);
System.Console.WriteLine($"{words.Length} words in text:");
foreach (var word in words)
{
    System.Console.WriteLine($"<{word}>");
}
 String.Split は、文字列の配列 (1 つの文字ではなく、対象の文字列を解析するための区切り記号として機能する文字シー ケンス) を受け取ることができます。
    string[] separatingStrings = { "<<", "..." };
string text = "one<<two......three<four";
System.Console.WriteLine($"Original text: '{text}'");
string[] words = text.Split(separatingStrings, System.StringSplitOptions.RemoveEmptyEntries);
System.Console.WriteLine($"{words.Length} substrings in text:");
foreach (var word in words)
{
    System.Console.WriteLine(word);
}
 関連項目
文字列から要素を抽出する
C# プログラミング ガイド 文字列
.NET 正規表現
   char[] delimiterChars = { ' ', ',', '.', ':', '\t' };
string text = "one\ttwo three:four,five six seven";
System.Console.WriteLine($"Original text: '{text}'");
string[] words = text.Split(delimiterChars);
System.Console.WriteLine($"{words.Length} words in text:");
foreach (var word in words)
{
    System.Console.WriteLine($"<{word}>");
}
 
        連結とは、ある文字列を別の文字列の末尾に追加するプロセスです。 文字列を連結するには、 + 演算子を使用します。 文字列リテラルと文字列定数の場合、連結はコンパイル時に行われ、実行時には行われません。 文字列変数の連結は実行 時にのみ行われます。
次の例では、ソース コードを読みやすくするために、連結を使用して長い文字列リテラルを短い文字列に分割しています。 これ らの部分は、コンパイル時に単一の文字列に連結されます。 関係する文字列の数に関係なく、実行時にパフォーマンス コスト は発生しません。
    NOTE
この記事の C# 例は、Try.NET インライン コード ランナーとプレイグラウンドで実行されます。 [ ] ボタンを選択すると、対話型ウィンドウで例 が実行されます。 コードを実行したら、コードを変更し、 [ ] をもう一度選択して変更後のコードを実行できます。 変更後のコードが対話 型ウィンドウで実行されるか、コンパイルできなかった場合、対話型ウィンドウにすべての C# コンパイラ エラー メッセージが表示されます。
     // Concatenation of literals is performed at compile time, not run time.
string text = "Historically, the world of data and the world of objects " +
"have not been well integrated. Programmers work in C# or Visual Basic " +
"and also in SQL or XQuery. On the one side are concepts such as classes, " +
"objects, fields, inheritance, and .NET Framework APIs. On the other side " +
"are tables, columns, rows, nodes, and separate languages for dealing with " +
"them. Data types often require translation between the two worlds; there are " +
"different standard functions. Because the object world has no notion of query, a " +
"query can only be represented as a string without compile-time type checking or " +
"IntelliSense support in the IDE. Transferring data from SQL tables or XML trees to " +
"objects in memory is often tedious and error-prone.";
System.Console.WriteLine(text);
 文字列変数を連結する場合は、 + または += 演算子、文字列補間または String.Format、String.Concat、String.Join、StringBuilder.Appendメソッドを使用できます。 + 演算子は使い方が簡単 で、直感的なコードにすることができます。1つのステートメントで複数の + 演算子を使用している場合でも、文字列の内容 がコピーされるのは 1 回のみです。 次のコードは、 + および += 演算子を使用して文字列を連結する例を示しています。
    string userName = "<Type your name here>";
string dateString = DateTime.Today.ToShortDateString();
// Use the + and += operators for one-time concatenations.
string str = "Hello " + userName + ". Today is " + dateString + ".";
System.Console.WriteLine(str);
str += " How are you today?";
System.Console.WriteLine(str);
 式によっては、次のコードに示すように、文字列補間を使用して文字列を連結する方が簡単な場合があります。
複数の文字列を連結する方法 (C# ガイド) 2020/11/02 • • Edit Online
 
              NOTE
文字列連結操作において、C# コンパイラでは null 文字列は空の文字列と同様に扱われます。
 文字列を連結する他のメソッドとして、String.Format があります。 このメソッドは、少数のコンポーネント文字列から文字列を 作成する場合に有効です。
他にも、結合するソース文字列の数がわからないループ内の文字列を結合する場合、ソース文字列の実際の数は大きくなる 可能性があります。 StringBuilder クラスは、このようなシナリオのために設計されています。 次のコードでは、StringBuilder ク ラスの Append メソッドを使用して文字列を連結しています。
文字列の連結または StringBuilder クラスを選択する理由に関するページで詳細をご確認ください。
コレクションからの文字列を結合する別のオプションとして、String.Concat メソッドを使用する方法があります。 ソース文字列を 区切り記号で区切る必要がある場合は、String.Join メソッドを使用します。 次のコードでは、両方のメソッドを使用して単語 の配列を結合します。
最後に、LINQ および Enumerable.Aggregate メソッドを使用して、コレクションからの文字列を結合できます。 このメソッド は、ラムダ式を使用してソース文字列を結合します。 ラムダ式は、各文字列を既存の蓄積に追加する処理を行います。 次の 例では、配列内の各単語の間にスペースを追加することによって単語の配列を結合します。
関連項目
    // Use StringBuilder for concatenation in tight loops.
var sb = new System.Text.StringBuilder();
for (int i = 0; i < 20; i++)
{
    sb.AppendLine(i.ToString());
}
System.Console.WriteLine(sb.ToString());
      string[] words = { "The", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog." };
var unreadablePhrase = string.Concat(words);
System.Console.WriteLine(unreadablePhrase);
var readablePhrase = string.Join(" ", words);
System.Console.WriteLine(readablePhrase);
     string[] words = { "The", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog." };
var phrase = words.Aggregate((partialPhrase, word) =>$"{partialPhrase} {word}");
System.Console.WriteLine(phrase);
 String
   string userName = "<Type your name here>";
string date = DateTime.Today.ToShortDateString();
// Use string interpolation to concatenate strings.
string str = $"Hello {userName}. Today is {date}.";
System.Console.WriteLine(str);
str = $"{str} How are you today?";
System.Console.WriteLine(str);
 
   StringBuilder
C# プログラミング ガイド 文字列

                2 つの主な戦略を使用して、文字列のテキストを検索することができます。 String クラスのメソッドは特定のテキストを検索しま す。 正規表現はテキストのパターンを検索します。
string 型は、System.String クラスのエイリアスであり、文字列の内容を検索するための多数の便利なメソッドを提供します。 その中に Contains、StartsWith、EndsWith、IndexOf、LastIndexOf が含まれています。 System.Text.RegularExpressions.Regex クラスでは、テキストのパターンを検索するための豊富なボキャブラリが提供されま す。 この記事では、これらの手法と、ニーズに最適なメソッドを選択する方法について説明します。
文字列にテキストが含まれていますか?
String.Contains、String.StartsWith、String.EndsWith メソッドでは、特定のテキストの文字列を検索します。 次の例は、こ
れらの各メソッドと、大文字と小文字を区別しない検索を使用するバリエーションを示しています。
    NOTE
この記事の C# 例は、Try.NET インライン コード ランナーとプレイグラウンドで実行されます。 [ ] ボタンを選択すると、対話型ウィンドウで例 が実行されます。 コードを実行したら、コードを変更し、 [ ] をもう一度選択して変更後のコードを実行できます。 変更後のコードが対話 型ウィンドウで実行されるか、コンパイルできなかった場合、対話型ウィンドウにすべての C# コンパイラ エラー メッセージが表示されます。
     string factMessage = "Extension methods have all the capabilities of regular static methods.";
// Write the string and include the quotation marks.
Console.WriteLine($"\"{factMessage}\"");
// Simple comparisons are always case sensitive!
bool containsSearchResult = factMessage.Contains("extension");
Console.WriteLine($"Contains \"extension\"? {containsSearchResult}");
// For user input and strings that will be displayed to the end user,
// use the StringComparison parameter on methods that have it to specify how to match strings.
bool ignoreCaseSearchResult = factMessage.StartsWith("extension",
System.StringComparison.CurrentCultureIgnoreCase);
Console.WriteLine($"Starts with \"extension\"? {ignoreCaseSearchResult} (ignoring case)");
bool endsWithSearchResult = factMessage.EndsWith(".", System.StringComparison.CurrentCultureIgnoreCase); Console.WriteLine($"Ends with '.'? {endsWithSearchResult}");
 上の例は、これらのメソッドを使用する重要なポイントを示しています。 既定では、検索で大文字と小文字が区別されます。 大文字と小文字を区別しない検索を指定する場合は、StringComparison.CurrentCultureIgnoreCase 列挙値を使用し ます。
検索対象テキストは文字列のどこにありますか?
IndexOf および LastIndexOf メソッドでは、文字列のテキストも検索します。 これらのメソッドは、検索されるテキストの場所を 返します。テキストが見つからない場合は、-1 が返されます。次の例では、"methods"という単語の最初と最後の出現箇 所の検索を示し、その間のテキストを表示します。
文字列を検索する方法
2020/11/02 • • Edit Online
 
     正規表現を使用する特定のテキストの検索
文字列の検索には、System.Text.RegularExpressions.Regex クラスを使用できます。 これらの検索の複雑さは、単純なテキ スト パターンから複雑なテキスト パターンまでさまざまです。
次のコード例では、文章内の "the" または "their" という単語を検索します (大文字と小文字の区別は無視されます)。 静的 メソッドの Regex.IsMatch で検索を実行します。 検索対象の文字列と、検索パターンを指定します。 この例では、3 番目の 引数で大文字と小文字を区別しない検索を指定します。 詳細については、 「System.Text.RegularExpressions.RegexOptions」を参照してください。
検索パターンで検索対象のテキストを説明します。 次の表では、検索パターンの各要素について説明します (以下の表では、 C#文字列で \\ としてエスケープされる必要がある、単一の \ を使用します)。
the テキスト "the" と一致
(eir)? "eir" の 0 個または 1 個の出現箇所と一致 \s 空白文字と一致
                   string[] sentences =
{
    "Put the water over there.",
    "They're quite thirsty.",
    "Their water bottles broke."
};
string sPattern = "the(ir)?\\s";
foreach (string s in sentences)
{
    Console.Write($"{s,24}");
    if (System.Text.RegularExpressions.Regex.IsMatch(s, sPattern,
System.Text.RegularExpressions.RegexOptions.IgnoreCase))
    {
        Console.WriteLine($"  (match for '{sPattern}' found)");
} else {
        Console.WriteLine();
    }
}
    string factMessage = "Extension methods have all the capabilities of regular static methods.";
// Write the string and include the quotation marks.
Console.WriteLine($"\"{factMessage}\"");
// This search returns the substring between two strings, so
// the first index is moved to the character just after the first string.
int first = factMessage.IndexOf("methods") + "methods".Length;
int last = factMessage.LastIndexOf("methods");
string str2 = factMessage.Substring(first, last - first);
Console.WriteLine($"Substring between \"methods\" and \"methods\": '{str2}'");
 
   文字列はパターンに従っていますか?
次のコードでは正規表現を使用して、配列の各文字列の形式を検証します。 各文字列が電話番号の形式であることが検 証されます。つまり、3 グループの数値がダッシュで区切られ、最初の 2 グループには 3 桁の数値が含まれ、3 つ目のグループに は4桁の数値が含まれることが検証されます。検索パターンでは正規表現の ^\\d{3}-\\d{3}-\\d{4}$ を使用します。詳 細については、「正規表現言語 - クイック リファレンス」をご覧ください。
^ 文字列の先頭と一致 \d{3} 3 桁の文字と完全に一致 - '-' 文字と一致
\d{3} 3 桁の文字と完全に一致 - '-' 文字と一致
\d{4} 4 桁の文字と完全に一致 $ 文字列の末尾と一致
                                  TIP
string メソッドは、通常、正確な文字列を検索するときに選択することをお勧めします。 正規表現は、ソース文字列で何らかのパターン を検索する場合に適しています。
  
        この単一の検索パターンは多くの有効な文字列と一致します。 単一のテキスト文字列ではなく、パターンの検索やパターンに 対する検証を行う場合は、正規表現が適しています。
関連項目
C# プログラミング ガイド
文字列
LINQ と文字列 System.Text.RegularExpressions.Regex .NET 正規表現
正規表現言語 - クイック リファレンス
.NET の文字列を使用するためのベスト プラクティス
   string[] numbers =
{
    "123-555-0190",
    "444-234-22450",
    "690-555-0178",
    "146-893-232",
    "146-555-0122",
    "4007-555-0111",
    "407-555-0111",
    "407-2-5555",
    "407-555-8974",
    "407-2ab-5555",
    "690-555-8148",
    "146-893-232-"
};
string sPattern = "^\\d{3}-\\d{3}-\\d{4}$";
foreach (string s in numbers)
{
    Console.Write($"{s,14}");
    if (System.Text.RegularExpressions.Regex.IsMatch(s, sPattern))
    {
        Console.WriteLine(" - valid");
    }
else {
        Console.WriteLine(" - invalid");
    }
}
 
          この記事では、既存の を変更して string を生成するためのいくつかの手法を示します。紹介するすべての手法 で、変更の結果が オブジェクトとして返されます。 元と変更後の文字列が異なるインスタンスであることを示すために、 例では、新しい変数に結果が格納されています。各例を実行するとき、元の string と変更後の新しい string を調べるこ とができます。
この記事ではいくつかの手法を示します。 既存のテキストは置き換えることができます。 パターンを検索して、一致するテキスト を他のテキストに置き換えることができます。 文字列は、一連の文字として扱うことができます。 空白を削除する便利なメソッド も使用できます。 シナリオに最も近い手法を選択してください。
テキストの置換 次のコードでは、既存のテキストを代替のテキストと置き換えることで新しい文字列が作成されます。
先のコードは、文字列のこの不変プロパティを示しています。先の例では、元の文字列 source が変更されていないことがわ かります。String.Replaceメソッドによって、変更を含む新しい string が生成されます。
Replace メソッドは、文字列または単一の文字のどちらかを置き換えることができます。 どちらの場合も、検索で見つかったすべ てのテキストが置き換えられます。 次の例では、すべての ' ' の文字が '_' に置き換えられます。
ソース文字列は変更されず、置き換えられた新しい文字列が返されます。 空白のトリミング
String.Trim、String.TrimStart、および String.TrimEnd メソッドを使用して、先頭または末尾の空白を削除することができま す。 次のコードは、それぞれの例を示しています。 ソース文字列は変更されません。これらのメソッドは、変更した内容を含む新 しい文字列を返します。
string
 string
      NOTE
この記事の C# 例は、Try.NET インライン コード ランナーとプレイグラウンドで実行されます。 [ ] ボタンを選択すると、対話型ウィンドウで例 が実行されます。 コードを実行したら、コードを変更し、 [ ] をもう一度選択して変更後のコードを実行できます。 変更後のコードが対話 型ウィンドウで実行されるか、コンパイルできなかった場合、対話型ウィンドウにすべての C# コンパイラ エラー メッセージが表示されます。
     string source = "The mountains are behind the clouds today.";
// Replace one substring with another with String.Replace.
// Only exact matches are supported.
var replacement = source.Replace("mountains", "peaks");
Console.WriteLine($"The source string is <{source}>");
Console.WriteLine($"The updated string is <{replacement}>");
       string source = "The mountains are behind the clouds today.";
// Replace all occurrences of one char with another.
var replacement = source.Replace(' ', '_');
Console.WriteLine(source);
Console.WriteLine(replacement);
 C# で文字列の内容を変更する方法 2020/11/02 • • Edit Online
 
            テキストの削除
String.Remove メソッドを使用して文字列からテキストを削除することができます。 このメソッドによって、特定のインデックスから 始まる文字が削除されます。 次の例は、String.IndexOf とそれに続く Remove を使用して文字列からテキストを削除する方 法を示しています。
    string source = "Many mountains are behind many clouds today.";
// Remove a substring from the middle of the string.
string toRemove = "many ";
string result = string.Empty;
int i = source.IndexOf(toRemove);
if (i >= 0)
{
    result= source.Remove(i, toRemove.Length);
}
Console.WriteLine(source);
Console.WriteLine(result);
 一致パターンの置換
正規表現を使用すると、テキスト一致パターンを新しいテキストに置き換えることができます (パターンで定義されている場合もあ ります)。 次の例では、System.Text.RegularExpressions.Regex クラスを使用してソース文字列でパターンを検索し、適切な 大文字と小文字に置き換えています。 Regex.Replace(String, String, MatchEvaluator, RegexOptions) メソッドは、置換の ロジックをその引数の1つとして提供する機能を受け取ります。この例で、関数 LocalReplaceMatchCase は、サンプルメソッ ド内で宣言されたローカル関数です。 LocalReplaceMatchCase は、System.Text.StringBuilderクラスを使用して大文字と 小文字が適切な置換文字列を作成します。
正規表現は、既知のテキストよりもパターンに従ったテキストを検索して置き換える場合に特に役立ちます。 詳細については、 「文字列を検索する方法」を参照してください。 検索パターン "the\s" は、単語 "the" とその後の空白文字を検索します。 パ ターンのこの部分により、ソース文字列の "there" は一致しなくなります。 正規表現言語要素の詳細については、「正規表現 言語 - クイック リファレンス」をご覧ください。
     // Remove trailing and leading white space.
string source = "    I'm wider than I need to be.      ";
// Store the results in a new string variable.
var trimmedResult = source.Trim();
var trimLeading = source.TrimStart();
var trimTrailing = source.TrimEnd();
Console.WriteLine($"<{source}>");
Console.WriteLine($"<{trimmedResult}>");
Console.WriteLine($"<{trimLeading}>");
Console.WriteLine($"<{trimTrailing}>");
 
       StringBuilder.ToString メソッドによって、StringBuilder オブジェクトの内容と不変の文字列が返されます。
各文字の変更
文字列から文字配列を生成し、配列の内容を変更して、変更された配列の内容から新しい文字列を作成できます。
次の例は、文字列の文字のセットを置き換える方法を示しています。 最初に、String.ToCharArray() メソッドを使用して文字 の配列が作成されます。 IndexOf メソッドを使用して "fox" という単語の開始インデックスを検索します。 次の 3 つの文字が、 別の単語に置き換えられます。 最後に、新しい文字列が更新された文字配列から構築されます。
    string phrase = "The quick brown fox jumps over the fence";
Console.WriteLine(phrase);
char[] phraseAsChars = phrase.ToCharArray();
int animalIndex = phrase.IndexOf("fox");
if (animalIndex != -1)
{
    phraseAsChars[animalIndex++] = 'c';
    phraseAsChars[animalIndex++] = 'a';
    phraseAsChars[animalIndex] = 't';
}
string updatedPhrase = new string(phraseAsChars);
Console.WriteLine(updatedPhrase);
 プログラムによって文字列の内容を作成する
文字列は不変なので、これまでの例ではすべて、一時的な文字列または文字の配列を作成しています。 ハイパフォーマンスの シナリオでは、これらのヒープの割り当てを回避することが望ましい場合があります。 .NET Core では String.Create メソッドを提 供しており、中間の一時的な文字列の割り当てを回避しながら、コールバックを介してプログラムによって文字列の文字の内容 を入力できます。
   string source = "The mountains are still there behind the clouds today.";
// Use Regex.Replace for more flexibility.
// Replace "the" or "The" with "many" or "Many".
// using System.Text.RegularExpressions
string replaceWith = "many ";
source = System.Text.RegularExpressions.Regex.Replace(source, "the\\s", LocalReplaceMatchCase,
    System.Text.RegularExpressions.RegexOptions.IgnoreCase);
Console.WriteLine(source);
string LocalReplaceMatchCase(System.Text.RegularExpressions.Match matchExpression)
{
    // Test whether the match is capitalized
    if (Char.IsUpper(matchExpression.Value[0]))
    {
        // Capitalize the replacement string
        System.Text.StringBuilder replacementBuilder = new System.Text.StringBuilder(replaceWith);
        replacementBuilder[0] = Char.ToUpper(replacementBuilder[0]);
        return replacementBuilder.ToString();
} else {
        return replaceWith;
    }
}
 
    アンセーフ コードを使用して固定ブロック内の文字列を変更することは可能ですが、文字列が作成された後に文字列の内容 を変更することは強くお勧めしません。 そうすると、予期できない方法で中断が発生します。 たとえば、誰かがあなたの文字列 と同じ内容の文字列をインターン処理する場合、その人はあなたのコピーを取得し、あなたが文字列を変更しようとしていると は想定しません。
関連項目
.NET 正規表現
正規表現言語 - クイック リファレンス
   // constructing a string from a char array, prefix it with some additional characters
char[] chars = { 'a', 'b', 'c', 'd', '\0' };
int length = chars.Length + 2;
string result = string.Create(length, chars, (Span<char> strContent, char[] charArray) =>
{
    strContent[0] = '0';
    strContent[1] = '1';
    for (int i = 0; i < charArray.Length; i++)
    {
        strContent[i + 2] = charArray[i];
    }
});
Console.WriteLine(result);
 
          文字列を比較して、次の 2 つの質問のいずれかに回答します。"これら 2 つの文字列は等しいですか" または "これらを並べ替 えるときにどのような順序でこれらの文字列を配置しますか"
これら 2 つの質問は、文字列比較に影響する要因によって複雑になります。
序数に基づく比較または言語的な比較を選択することができます。 大文字小文字が重要かどうかを選択できます。 カルチャに固有の比較を選択できます。 言語的な比較は、カルチャおよびプラットフォームに依存します。
文字列を比較するときに、それらの間で順序を定義します。 比較は、文字列のシーケンスの並べ替えに使用されます。 シーケ ンスが既知の順序の場合、ソフトウェアと人間の両方が簡単に検索できます。 その他の比較では、文字列が等しいかどうかを 確認する場合があります。 これらの類似性チェックは等値に似ていますが、大文字小文字の違いなど、いくつかの違いは無視 される場合があります。
既定の序数の比較 既定では、最も一般的な操作は次のとおりです。
String.Equals
String.Equality と String.Inequality。つまり、それぞれ等価演算子 == と != 。
大文字と小文字を区別する序数の比較を実行し、必要に応じて現在のカルチャを使用します。 次に例を示します。
    NOTE
この記事の C# 例は、Try.NET インライン コード ランナーとプレイグラウンドで実行されます。 [ ] ボタンを選択すると、対話型ウィンドウで例 が実行されます。 コードを実行したら、コードを変更し、 [ ] をもう一度選択して変更後のコードを実行できます。 変更後のコードが対話 型ウィンドウで実行されるか、コンパイルできなかった場合、対話型ウィンドウにすべての C# コンパイラ エラー メッセージが表示されます。
     string root = @"C:\users";
string root2 = @"C:\Users";
bool result = root.Equals(root2);
Console.WriteLine($"Ordinal comparison: <{root}> and <{root2}> are {(result ? "equal." : "not equal.")}");
result = root.Equals(root2, StringComparison.Ordinal);
Console.WriteLine($"Ordinal comparison: <{root}> and <{root2}> are {(result ? "equal." : "not equal.")}");
Console.WriteLine($"Using == says that <{root}> and <{root2}> are {(root == root2 ? "equal" : "not
equal")}");
 既定の序数の比較では、文字列を比較するときに言語の規則を考慮しません。 2 つの文字列のそれぞれの Char オブジェク トのバイナリ値を比較します。 その結果、既定の序数の比較でも大文字と小文字が区別されます。
String.Equalsと == および != 演算子を使用した等価性のテストは、String.CompareToとCompare(String,String)の メソッドを使用した文字列の比較とは異なります。 等価性のテストでは大文字と小文字を区別する序数の比較が行われます が、比較メソッドでは大文字と小文字だけでなく、現在のカルチャを使用してカルチャを区別する比較が行われます。 既定の 比較メソッドでは多くの場合、さまざまな種類の比較が実行されるため、実行する比較の種類を明示的に指定するオーバー
C# で文字列を比較する方法 2021/03/09 • • Edit Online
 
        ロードを呼び出して、コードの意図を常に明確にすることをお勧めします。 大文字と小文字を区別しない、序数に基づく比較
String.Equals(String, StringComparison) メソッドでは、StringComparison.OrdinalIgnoreCase の StringComparison 値を指定して、 大文字と小文字を区別しない、序数に基づく比較ができるようにします。 StringComparison 引数に StringComparison.OrdinalIgnoreCase の値を指定すると、大文字と小文字を区別しない序数に基づく比較が実行され る、静的な String.Compare(String, String, StringComparison) メソッドもあります。 これを次のコードに示します。
    string root = @"C:\users";
string root2 = @"C:\Users";
bool result = root.Equals(root2, StringComparison.OrdinalIgnoreCase);
bool areEqual = String.Equals(root, root2, StringComparison.OrdinalIgnoreCase);
int comparison = String.Compare(root, root2, comparisonType: StringComparison.OrdinalIgnoreCase);
Console.WriteLine($"Ordinal ignore case: <{root}> and <{root2}> are {(result ? "equal." : "not equal.")}");
Console.WriteLine($"Ordinal static ignore case: <{root}> and <{root2}> are {(areEqual ? "equal." : "not
equal.")}");
if (comparison < 0)
    Console.WriteLine($"<{root}> is less than <{root2}>");
else if (comparison > 0)
    Console.WriteLine($"<{root}> is greater than <{root2}>");
else
    Console.WriteLine($"<{root}> and <{root2}> are equivalent in order");
 大文字と小文字を区別しない、序数に基づく比較を実行すると、これらのメソッドではインバリアント カルチャの大文字と小文 字の区別が使用されます。
言語的な比較
現在のカルチャの言語の規則を使用して文字列の順序を指定することもできます。 これは、"単語の並べ替え順序" と呼ばれ ることもあります。 言語的な比較を実行するときには、一部の英数字以外の Unicode 文字に、特別な重みが割り当てられる 場合があります。 たとえば、ハイフン ("-") に割り当てられる重みは小さいため、並べ替え順序で "coop" と "co-op" の出現位 置が隣接します。 さらに、いくつかの Unicode 文字が Char インスタンスのシーケンスと等しくなる可能性があります。 次の例で は、ドイツ語で "They dance in the street" という語句を 一方の文字列では "ss" (U+0073 U+0073)、もう一方の文字列 では 'ß' (U+00DF) を使って表しています。 言語的に (Windows では)、"en-US" と "de-DE" の両方のカルチャで、"ss" はド イツ語の Essetz: 'ß' 文字と同じです。

    このサンプルでは、言語的な比較に依存するオペレーティング システムの性質を示します。 対話型ウィンドウのホストは、Linux ホストです。 言語比較および序数比較は、同じ結果を生成します。 Windows ホストで同じこのサンプルを実行する場合、次 の出力が表示されます。
Windows では、言語的な比較から序数に基づく比較に変更した場合に、"cop"、"coop"、および "co-op" の並べ替え順序 は変更されます。 ドイツ語の 2 つの文も、異なる比較の種類を使用して異なる方法で比較されます。
特定のカルチャを使用した比較
このサンプルでは en-US と de-DE のカルチャの CultureInfo オブジェクトを格納しています。 比較は、カルチャ固有の比較を確
保するために CultureInfo オブジェクトを使用して実行されます。
使用されるカルチャは言語的な比較に影響します。 次の例は、"en-US" カルチャと "de-DE" カルチャを使用する 2 つのドイツ 語の文の比較の結果を示しています。
    <coop> is less than <co-op> using invariant culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using invariant culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using invariant culture
<co-op> is less than <cop> using ordinal comparison
    string first = "Sie tanzen auf der Straße.";
string second = "Sie tanzen auf der Strasse.";
Console.WriteLine($"First sentence is <{first}>");
Console.WriteLine($"Second sentence is <{second}>");
bool equal = String.Equals(first, second, StringComparison.InvariantCulture);
Console.WriteLine($"The two strings {(equal == true ? "are" : "are not")} equal.");
showComparison(first, second);
string word = "coop";
string words = "co-op";
string other = "cop";
showComparison(word, words);
showComparison(word, other);
showComparison(words, other);
void showComparison(string one, string two)
{
    int compareLinguistic = String.Compare(one, two, StringComparison.InvariantCulture);
    int compareOrdinal = String.Compare(one, two, StringComparison.Ordinal);
    if (compareLinguistic < 0)
        Console.WriteLine($"<{one}> is less than <{two}> using invariant culture");
    else if (compareLinguistic > 0)
        Console.WriteLine($"<{one}> is greater than <{two}> using invariant culture");
    else
        Console.WriteLine($"<{one}> and <{two}> are equivalent in order using invariant culture");
    if (compareOrdinal < 0)
        Console.WriteLine($"<{one}> is less than <{two}> using ordinal comparison");
    else if (compareOrdinal > 0)
        Console.WriteLine($"<{one}> is greater than <{two}> using ordinal comparison");
    else
}
Console.WriteLine($"<{one}> and <{two}> are equivalent in order using ordinal comparison");
 
    カルチャに依存した比較は、一般的にユーザーによる文字列入力とユーザーによる他の文字列入力の比較および並べ替えに 使用されます。 これらの文字列の文字および並べ替え規則は、ユーザーのコンピューターのロケールによって異なる場合がありま す。 同一の文字を含む文字列でも、現在のスレッドのカルチャに応じて、異なる方法で並べ替えられます。 さらに、Windows コンピューターでローカルでこのサンプル コードを試すと、次の結果が表示されます。
言語的な比較は、現在のカルチャに依存し、OS に依存します。 文字列の比較を使用する場合は、これを考慮してください。
配列の言語的な並べ替えと文字列の検索 次の例は、現在のカルチャに依存する言語的な比較を使用して、配列内の文字列を並べ替えおよび検索する方法を示して
    <coop> is less than <co-op> using en-US culture
<coop> is greater than <co-op> using ordinal comparison
<coop> is less than <cop> using en-US culture
<coop> is less than <cop> using ordinal comparison
<co-op> is less than <cop> using en-US culture
<co-op> is less than <cop> using ordinal comparison
   string first = "Sie tanzen auf der Straße.";
string second = "Sie tanzen auf der Strasse.";
Console.WriteLine($"First sentence is <{first}>");
Console.WriteLine($"Second sentence is <{second}>");
var en = new System.Globalization.CultureInfo("en-US");
// For culture-sensitive comparisons, use the String.Compare
// overload that takes a StringComparison value.
int i = String.Compare(first, second, en, System.Globalization.CompareOptions.None);
Console.WriteLine($"Comparing in {en.Name} returns {i}.");
var de = new System.Globalization.CultureInfo("de-DE");
i = String.Compare(first, second, de, System.Globalization.CompareOptions.None);
Console.WriteLine($"Comparing in {de.Name} returns {i}.");
bool b = String.Equals(first, second, StringComparison.CurrentCulture);
Console.WriteLine($"The two strings {(b ? "are" : "are not")} equal.");
string word = "coop";
string words = "co-op";
string other = "cop";
showComparison(word, words, en);
showComparison(word, other, en);
showComparison(words, other, en);
void showComparison(string one, string two, System.Globalization.CultureInfo culture)
{
    int compareLinguistic = String.Compare(one, two, en, System.Globalization.CompareOptions.None);
    int compareOrdinal = String.Compare(one, two, StringComparison.Ordinal);
    if (compareLinguistic < 0)
        Console.WriteLine($"<{one}> is less than <{two}> using en-US culture");
    else if (compareLinguistic > 0)
        Console.WriteLine($"<{one}> is greater than <{two}> using en-US culture");
    else
        Console.WriteLine($"<{one}> and <{two}> are equivalent in order using en-US culture");
    if (compareOrdinal < 0)
        Console.WriteLine($"<{one}> is less than <{two}> using ordinal comparison");
    else if (compareOrdinal > 0)
        Console.WriteLine($"<{one}> is greater than <{two}> using ordinal comparison");
    else
}
Console.WriteLine($"<{one}> and <{two}> are equivalent in order using ordinal comparison");

   います。 System.StringComparer パラメーターを取得する静的な Array メソッドを使用します。 この例では、現在のカルチャを使用して文字列の配列を並べ替える方法を示します。
    string[] lines = new string[]
{
    @"c:\public\textfile.txt",
    @"c:\public\textFile.TXT",
    @"c:\public\Text.txt",
    @"c:\public\testfile2.txt"
};
Console.WriteLine("Non-sorted order:");
foreach (string s in lines)
{
    Console.WriteLine($"   {s}");
}
Console.WriteLine("\n\rSorted order:");
// Specify Ordinal to demonstrate the different behavior.
Array.Sort(lines, StringComparer.CurrentCulture);
foreach (string s in lines)
{
    Console.WriteLine($"   {s}");
}
 配列が並べ替えられた後は、バイナリ検索を使用してエントリを検索できます。 バイナリ検索は、コレクションの中央で開始さ れ、要求された文字列がコレクションのどちらの半分に含まれているかを判断します。 各後続の比較は、半分にコレクションの 残りの部分を半分に細分化します。 配列は StringComparer.CurrentCulture を使用して並べ替えられます。 ローカル関数
ShowWhere は、文字列が見つかった場所に関する情報を表示します。文字列が見つからなかった場合、返された値は、見 つからなかった場合にどこにあるべきかを示します。
 
        コレクションの序数に基づく並べ替えと検索
次のコードでは、System.Collections.Generic.List<T> コレクション クラスを使用して文字列を格納します。 文字列 は、List<T>.Sort メソッドを使用して並べ替えられます。 このメソッドでは、2 つの文字列の順序を比較するデリゲートが必要 です。 String.CompareTo メソッドは、その比較関数を提供します。 このサンプルを実行し、順序を確認します。 この並べ替 え操作では、大文字小文字を区別する序数の並べ替えを使用します。 静的な String.Compare メソッドを使用し、別の比 較規則を指定します。
  string[] lines = new string[]
{
    @"c:\public\textfile.txt",
    @"c:\public\textFile.TXT",
    @"c:\public\Text.txt",
    @"c:\public\testfile2.txt"
};
Array.Sort(lines, StringComparer.CurrentCulture);
string searchString = @"c:\public\TEXTFILE.TXT";
Console.WriteLine($"Binary search for <{searchString}>");
int result = Array.BinarySearch(lines, searchString, StringComparer.CurrentCulture);
ShowWhere<string>(lines, result);
Console.WriteLine($"{(result > 0 ? "Found" : "Did not find")} {searchString}");
void ShowWhere<T>(T[] array, int index)
{
    if (index < 0)
    {
        index = ~index;
        Console.Write("Not found. Sorts between: ");
        if (index == 0)
            Console.Write("beginning of sequence and ");
        else
            Console.Write($"{array[index - 1]} and ");
        if (index == array.Length)
            Console.WriteLine("end of sequence.");
        else
            Console.WriteLine($"{array[index]}.");
} else {
        Console.WriteLine($"Found at index {index}.");
    }
}

  並べ替えられたら、バイナリ検索を使用して文字列の一覧を検索できます。 次の例では、同じ比較関数を使用して、並べ替 えられた一覧を検索する方法を示します。ローカル関数 ShowWhere は、要求されたテキストの場所、またはあるべき場所を 示します。
    List<string> lines = new List<string>
{
    @"c:\public\textfile.txt",
    @"c:\public\textFile.TXT",
    @"c:\public\Text.txt",
    @"c:\public\testfile2.txt"
};
Console.WriteLine("Non-sorted order:");
foreach (string s in lines)
{
    Console.WriteLine($"   {s}");
}
Console.WriteLine("\n\rSorted order:");
lines.Sort((left, right) => left.CompareTo(right));
foreach (string s in lines)
{
    Console.WriteLine($"   {s}");
}
 
             並べ替えと検索に常に同じ種類の比較を使用してください。 並べ替えと検索に異なる種類の比較を使用すると、予期しない 結果になります。
System.Collections.Hashtable、System.Collections.Generic.Dictionary<TKey,TValue>、および System.Collections.Generic.List<T>などのコレクションクラスには、要素またはキーの種類が string の場 合、System.StringComparer パラメーターを取るコンストラクターが用意されています。 通常は、これらのコンストラクターをでき るだけ使用し、StringComparer.Ordinal または StringComparer.OrdinalIgnoreCase を指定する必要があります。
参照の等価性と文字列インターン
どの例でも ReferenceEquals を使用していません。 このメソッドによって、2 つの文字列が同じオブジェクトであるかどうかが判 断されます。異なる場合、文字列比較で結果が一致しません。 次の例は、C# の 文字列のインターン 機能を示しています。 プログラムで 2 つ以上の同じ文字列変数を宣言すると、コンパイラはそれらをすべて同じ場所に保管します。 ReferenceEquals メソッドを呼び出すと、2 つの文字列がメモリ内の同じオブジェクトを実際に参照していることを確認できま す。 インターン処理を回避するには、String.Copy メソッドを使用します。 コピーが行われた後、同じ値が含まれていても、2 つ の文字列は別の記憶場所を使用します。次の例を実行し、文字列 a と b がインターン処理されることを示します。これ は、同じ記憶域を共有することを意味します。文字列 a と c は異なります。
   List<string> lines = new List<string>
{
    @"c:\public\textfile.txt",
    @"c:\public\textFile.TXT",
    @"c:\public\Text.txt",
    @"c:\public\testfile2.txt"
};
lines.Sort((left, right) => left.CompareTo(right));
string searchString = @"c:\public\TEXTFILE.TXT";
Console.WriteLine($"Binary search for <{searchString}>");
int result = lines.BinarySearch(searchString);
ShowWhere<string>(lines, result);
Console.WriteLine($"{(result > 0 ? "Found" : "Did not find")} {searchString}");
void ShowWhere<T>(IList<T> collection, int index)
{
    if (index < 0)
    {
        index = ~index;
        Console.Write("Not found. Sorts between: ");
        if (index == 0)
            Console.Write("beginning of sequence and ");
        else
            Console.Write($"{collection[index - 1]} and ");
        if (index == collection.Count)
            Console.WriteLine("end of sequence.");
        else
            Console.WriteLine($"{collection[index]}.");
} else {
        Console.WriteLine($"Found at index {index}.");
    }
}

                NOTE
文字列の等価をテストする場合、実行する比較の種類を明示的に指定するメソッドを使用する必要があります。 コードを保守しやすく、 読みやすくすることができます。 StringComparison 列挙パラメーターを取る System.String および System.Array クラスのメソッドのオー バーロードを使用します。 実行する比較の種類を指定します。 等価をテストするときには、 == および != 演算子を使用しないでくださ い。 String.CompareTo インスタンス メソッドは常に、序数に基づいた大文字小文字を区別する比較を実行します。 これらは、文字列を アルファベット順に並べ替える場合に適しています。
 String.Intern メソッドを呼び出すことで、文字列をインターンしたり、既存のインターンされた文字列への参照を取得したりでき ます。 文字列がインターンされているかどうかを確認するには、String.IsInterned メソッドを呼び出します。
関連項目
System.Globalization.CultureInfo System.StringComparer
文字列
文字列の比較 アプリケーションのグローバライズとローカライズ
   string a = "The computer ate my source code.";
string b = "The computer ate my source code.";
if (String.ReferenceEquals(a, b))
    Console.WriteLine("a and b are interned.");
else
    Console.WriteLine("a and b are not interned.");
string c = String.Copy(a);
if (String.ReferenceEquals(a, c))
    Console.WriteLine("a and c are interned.");
else
    Console.WriteLine("a and c are not interned.");
 
     オブジェクトはポリモーフィックであるため、基本クラス型の変数で派生型を保持できます。 派生型のインスタンス メンバーにアク セスするには、値をキャストして派生型に戻す必要があります。 ただし、キャストでは、InvalidCastException がスローされるリ スクが生まれます。 C# には、パターン マッチング ステートメントがあります。これは成功する場合のみという条件でキャストを実行 します。 C# には、値が特定の型であることをテストする is 演算子と as 演算子もあります。
パターンマッチングに is ステートメントを使用する方法の例を次に示します。
パターン マッチング、is 演算子、as 演算子を使
用して安全にキャストする方法
2020/11/02 • • Edit Online
 
     上記のサンプルでは、パターン マッチング構文のいくつかの機能が示されています。 if (a is Mammal m) ステートメントにより、 テストと初期化の割り当てが結合されます。この割り当ては、テストに成功した場合にのみ行われます。変数 m は、それが 割り当てられている埋め込み if ステートメントでのみ範囲に入ります。後で同じメソッドで m にアクセスすることはできませ
  class Animal
{
    public void Eat() { Console.WriteLine("Eating."); }
    public override string ToString()
    {
        return "I am an animal.";
    }
}
class Mammal : Animal { }
class Giraffe : Mammal { }
class SuperNova { }
class Program
{
    static void Main(string[] args)
    {
        var g = new Giraffe();
        var a = new Animal();
        FeedMammals(g);
        FeedMammals(a);
        // Output:
        // Eating.
        // Animal is not a Mammal
        SuperNova sn = new SuperNova();
        TestForMammals(g);
        TestForMammals(sn);
        // Output:
        // I am an animal.
        // SuperNova is not a Mammal
    }
    static void FeedMammals(Animal a)
    {
        if (a is Mammal m)
        {
m.Eat(); }
else {
            Console.WriteLine($"{a.GetType().Name} is not a Mammal");
        }
}
    static void TestForMammals(object o)
    {
        // You also can use the as operator and test for null
        // before referencing the variable.
        var m = o as Mammal;
        if (m != null)
        {
            Console.WriteLine(m.ToString());
} else {
            Console.WriteLine($"{o.GetType().Name} is not a Mammal");
        }
} }
// variable 'm' is not in scope here, and can't be used.

   ん。 前の例では、 as 演算子を使用してオブジェクトを指定した型に変換する方法も示されています。 次の例で示されているように、null 許容値型に値があるかどうかをテストする目的で同じ構文を使用することもできます。
    class Program
{
    static void Main(string[] args)
    {
        int i = 5;
        PatternMatchingNullable(i);
        int? j = null;
        PatternMatchingNullable(j);
        double d = 9.78654;
        PatternMatchingNullable(d);
        PatternMatchingSwitch(i);
        PatternMatchingSwitch(j);
        PatternMatchingSwitch(d);
}
    static void PatternMatchingNullable(System.ValueType val)
    {
        if (val is int j) // Nullable types are not allowed in patterns
        {
            Console.WriteLine(j);
        }
        else if (val is null) // If val is a nullable type with no value, this expression is true
        {
            Console.WriteLine("val is a nullable type with the null value");
        }
else {
            Console.WriteLine("Could not convert " + val.ToString());
        }
}
    static void PatternMatchingSwitch(System.ValueType val)
    {
        switch (val)
        {
}
} }
case int number:
    Console.WriteLine(number);
    break;
case long number:
    Console.WriteLine(number);
    break;
case decimal number:
    Console.WriteLine(number);
    break;
case float number:
    Console.WriteLine(number);
    break;
case double number:
    Console.WriteLine(number);
    break;
case null:
    Console.WriteLine("val is a nullable type with the null value");
    break;
default:
    Console.WriteLine("Could not convert " + val.ToString());
    break;
 
 上記のサンプルでは、変換で使用するパターンマッチング構文の他の機能が示されています。 null 値を具体的に探すことで null パターンの変数をテストできます。 変数のランタイム値が null のとき、 is ステートメントで型を確認すると必ず false が返されます。 パターン マッチング is ステートメントでは、 int? や Nullable<int> など、null 許容値型が許可されません が、他の値の型についてはテストできます。前の例の is パターンはnull許容値型に限定されません。また、これらのパター ンを使用して、参照型の変数に値があるか、 null であるかをテストすることもできます。
上の例では、変数をさまざまな型の1つにすることができる switch ステートメントで型パターンを使用する方法も示されていま す。
変数が特定の型かどうかのテストだけを行い、それを新しい変数に代入しない場合は、参照型とnull許容値型に対して is 演算子と as 演算子を使用できます。次のコードでは、パターンマッチングが導入される前にC#言語に含まれていた is ス テートメントと as ステートメントを使用し、変数が指定の型かどうかをテストする方法が示されています。
      class Animal
{
    public void Eat() { Console.WriteLine("Eating."); }
    public override string ToString()
    {
        return "I am an animal.";
    }
}
class Mammal : Animal { }
class Giraffe : Mammal { }
class SuperNova { }
class Program
{
    static void Main(string[] args)
    {
        // Use the is operator to verify the type.
        // before performing a cast.
        Giraffe g = new Giraffe();
        UseIsOperator(g);
        // Use the as operator and test for null
        // before referencing the variable.
        UseAsOperator(g);
        // Use the as operator to test
        // an incompatible type.
        SuperNova sn = new SuperNova();
        UseAsOperator(sn);
        // Use the as operator with a value type.
        // Note the implicit conversion to int? in
        // the method body.
        int i = 5;
        UseAsWithNullable(i);
        double d = 9.78654;
        UseAsWithNullable(d);
    }
    static void UseIsOperator(Animal a)
    {
        if (a is Mammal)
        {
            Mammal m = (Mammal)a;
m.Eat(); }
}
    static void UsePatternMatchingIs(Animal a)
    {

 ご覧のとおり、このコードとパターン マッチング コードを比較することで、テストと割り当てが 1 回のステートメントで組み合わされ、 パターン マッチング構文がより強固になります。 可能な限り、パターン マッチングを使用してください。
   } }
    if (a is Mammal m)
    {
m.Eat(); }
static void UseAsOperator(object o)
{
    Mammal m = o as Mammal;
    if (m != null)
    {
        Console.WriteLine(m.ToString());
    }
else {
        Console.WriteLine($"{o.GetType().Name} is not a Mammal");
    }
}
static void UseAsWithNullable(System.ValueType val)
{
    int? j = val as int?;
    if (j != null)
    {
        Console.WriteLine(j);
    }
else {
        Console.WriteLine("Could not convert " + val.ToString());
    }
}
 
      コンパイラでは、コードの構文とセマンティクスを検証するように、アプリケーション コードの詳細なモデルをビルドします。 このモデ ルを使用して、ソース コードから実行可能な出力をビルドします。 .NET Compiler Platform SDK では、このモデルへのアクセ スが提供されます。 Microsoft では、生産性を向上させるために、IntelliSense、リファクタリング、インテリジェントな名前の変 更、"すべての参照の検索"、"定義へ移動" などの統合開発環境 (IDE) 機能をますます使用するようになっています。 コード の品質を向上させるためにコード分析ツールを使用し、アプリケーションの構築に役立てるためにコード ジェネレーターを使用し ます。 これらのツールがスマートになったので、アプリケーション コードを処理するときに、コンパイラのみが作成するモデルにますま すツールがアクセスする必要が生じます。 これが Roslyn API の主要な目的です。不透明なボックスを開いて、ツールとエンド ユーザーが豊富な情報コンパイラを共有することを許可するためにこのコードがあります。 コンパイラは Roslyn の使用により、 ソース コード イン、オブジェクト コード アウトの曖昧なトランスレーターではなく、次のようなプラットフォームになります。ツールとア プリケーションのコード関連のタスクで使用できる API。
.NET Compiler Platform SDK の概念
.NET Compiler Platform SDK は、コードにフォーカスされたツールとアプリケーションの作成における参入障壁を劇的に低くしま す。 これにより、メタプログラミング、コードの生成と変換、C# と Visual Basic 言語の対話型の使用、ドメイン固有の言語での C# と Visual Basic の埋め込みなどの領域で、多くのイノベーションの機会が生み出されます。
.NET Compiler Platform SDK を使用すると、コードの誤りを見つける "アナライザー " と、修正する "コード修正機能*" を構 築できます。 "*アナライザー*" によって構文 (コードの構造) とセマンティクスを把握し、修正すべき使用方法を検出します。 "*コード修正機能*" では、アナライザーまたはコンパイラ診断によって検出されたコードの誤りに対処するための 1 つまたは複 数の修正方法が提案されます。 通常、アナライザーと関連付けられているコード修正は、1 つのプロジェクトにまとめてパッケー ジ化されます。
アナライザーとコード修正機能では、スタティック分析を使用してコードを理解します。 コードを実行したり、その他のテストのメ リットを提供したりすることはありません。 ただし、バグ、保守性の低いコード、または標準ガイドライン違反につながることが多い 使用方法を指摘することができます。
アナライザーとコード修正機能に加えて、.NET Compiler Platform SDK では "*コード リファクタリング*" を構築することもできま す。 また、C# または Visual Basic のコードベースの調査と理解を可能にする API のセットも 1 つ用意されています。 この単一 のコードベースを使用できるため、.NET Compiler Platform SDK によって提供される構文と意味の分析 API を利用して、簡 単にアナライザーとコード修正機能を記述できます。 コンパイラによって行う分析を何度も繰り返している大規模なタスクから解 放されると、プロジェクトやライブラリの一般的なコーディング エラーの検出と修正という、より集中したタスクに専念することができ ます。
小さな利点として、独自のプロジェクトでコード解析機能を記述するよりも、Visual Studio で読み込んだほうがアナライザーと コード修正機能が小さくなり、使用するメモリがはるかに少なくなります。 コンパイラと Visual Studio とで使用される同じクラスを 利用して、独自の静的分析ツールを作成できます。 つまり、チームは IDE のパフォーマンスに顕著な影響をあたえることなく、ア ナライザーとコード修正機能を使用できるということです。
アナライザーとコード修正機能の記述には、3 つの主なシナリオがあります。
1. "_チームのコーディング標準を適用する*"
2. ライブラリ パッケージと共にガイダンスを提供する 3. 一般的なガイダンスを提供する
チームのコーディング標準を適用する
多くのチームには、他のチーム メンバーとのコード レビューを介して適用されたコーディング標準があります。 アナライザーとコード
.NET Compiler Platform SDK
2021/03/06 • • Edit Online
 
        修正を使用すると、このプロセスの効率をさらに高めることができます。 開発者がチームの他のユーザーと作業を共有するとき に、コード レビューが行われます。 開発者はコメントを受け取る前に、新機能を完成させるために必要な投資を常に行うことに なります。 チームの慣行に合わない習慣を徹底するには、数週間かかる場合があります。
開発者がコードを記述すると同時にアナライザーは実行されます。 開発者は、すぐにガイダンスに従うように促す即時フィード バックを受け取ります。 開発者はプロトタイプの作成を始めるとすぐに、準拠したコードを記述する習慣を身に付けます。 その コードが人間によるコードレビューできるようになるときには、すべての標準的なガイダンスが適用されています。
チームは、チームのコーディング規約に違反している一般的な規約を探すアナライザーとコード修正機能をビルドできます。 これ らは標準を適用するために、各開発者のマシンにインストールできます。
ライブラリ パッケージと共にガイダンスを提供する
NuGet には .NET 開発者が使用できる豊富なライブラリがあります。 それらは Microsoft から提供されたり、サード パーティの 会社から提供されたり、コミュニティ メンバーやボランティアから提供されたものです。 開発者がこれらのライブラリを活用すると、 ライブラリはより多く導入され、さらによいレビューを得ることができます。
ドキュメントの提供のほか、ライブラリの一般的な誤用を見つけて修正するアナライザーとコード修正を提供できます。 これらの 迅速な修正は、開発者が早く成功するために役立ちます。
NuGet 上の自分のライブラリを使用して、アナライザーとコード修正をパッケージ化することができます。 このシナリオでは、お客 様の NuGet パッケージをインストールする開発者もすべて、このアナライザー パッケージをインストールします。 お客様のライブラ リを使用しているすべての開発者が、誤りや修正案への即時フィードバックの形式で、お客様のチームからガイダンスをすぐに受 け取ります。
一般的なガイダンスを提供する
.NET 開発者コミュニティによって、うまく機能するパターンと避けた方がよいパターンが経験を通じて発見されています。 数人の コミュニティ メンバーが、推奨されるパターンを適用するアナライザーを作成しています。 理解を深めると、常に新しいアイデアの 余地が生まれます。
これらのアナライザーは、Visual Studio Marketplace にアップロードしたり、Visual Studio を使用して開発者がダウンロードし たりすることができます。 言語とプラットフォームの初心者の方は承認済みのプラクティスをすばやく学習し、.NET 体験で生産性 を早く向上させることができます。 これらが広く使われるようになると、コミュニティがこれらのプラクティスを導入します。
次の手順
.NET Compiler Platform SDK には、コードの生成、分析、リファクタリングを行うために、最新の言語オブジェクト モデルが含ま れています。 このセクションでは、.NET Compiler Platform SDK の概念的な概要を示します。 詳細については、クイックス タート、サンプル、チュートリアルのセクションで確認できます。
.NET Compiler Platform SDK の概念の詳細については、次の 5 つのトピックを参照してください。
構文ビジュアライザーでコードを調べる
.NET Compiler Platform SDK の概念とオブジェクト モデル 構文の使用
セマンティクスの使用
ワークスペースの使用
    TIP
独自のアナライザーを構築する前に、組み込みのものを確認してください。 詳細については、コード スタイル規則に関する記事を参照してく ださい。
 まず .NET Compiler Platform SDK をインストールする必要があります。

 インストール手順 - Visual Studio インストーラー
Visual Studio インストーラーで .NET Compiler Platform SDK を見つけるには、以下の 2 つの異なる方法がありま
す。
Visual Studio インストーラーを使用したインストール - ワークロード ビュー
.NET Compiler Platform SDK は、Visual Studio 拡張機能の開発ワークロードの一部として自動的に選択されません。 省 略可能なコンポーネントとして選択する必要があります。
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. Visual Studio 拡張機能の開発ワークロードを確認します。
4. 概要ツリーの [Visual Studio 拡張機能の開発] ノードを開きます。
5. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 省略可能なコンポーネントの最後に表示されま
す。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. 概要ツリーの [個別のコンポーネント] ノードを開きます。 2. [DGML エディター] のチェック ボックスをオンにします。
Visual Studio インストーラーを使用したインストール - [個別のコンポーネント] タブ
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. [個別のコンポーネント] タブを選択します。
4. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 [コンパイラ、ビルド ツール、およびランタイム] セ
クションの上部に表示されます。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. [DGML エディター] チェック ボックスをオンにします。 [コード ツール] セクションに表示されます。

   コンパイラは、多くの場合、人間がコードを読み取り、理解する方法とは異なる構造化された規則に従って書き込まれたコード を処理します。 コンパイラで使用されるモデルの基礎知識は、Roslyn ベースのツールを構築するときに使用する API を理解す るのに必須です。
コンパイラ パイプラインの機能領域
.NET Compiler Platform SDK は、従来のコンパイラ パイプラインを反映する API レイヤーを提供することで、コンシューマーに
C# と Visual Basic コンパイラーのコード分析を公開します。
このパイプラインの各フェーズは別のコンポーネントです。 最初に、解析フェーズで、言語文法に従う構文にソース テキストをトー クン化して解析します。 2 番目に、宣言フェーズで、ソースとインポートされたメタデータを分析して、名前付け規則を形成しま す。 次に、バインド フェーズで、コード内の識別子をシンボルと一致させます。 最後に、生成フェーズで、コンパイラによって構 築されたすべての情報でアセンブリを生成します。
これらの各フェーズに応じて、.NET Compiler Platform SDK はオブジェクト モデルを公開します。これにより、各フェーズの情報 にアクセスできます。 解析フェーズでは構文ツリーを公開し、宣言フェーズでは階層シンボル テーブルを公開し、バインド フェー ズではコンパイラのセマンティック分析結果を公開します。生成フェーズは IL バイト コードを生成する API です。
  .NET Compiler Platform SDK モデルについて 2021/03/06 • • Edit Online
 
  各コンパイラは、これらのコンポーネントを一緒に単一のエンド ツー エンド全体として結合します。
これらの API は、Visual Studio で使用されるものと同じです。 たとえば、コードのアウトライン表示と書式設定機能では構文ツ リーを使用し、オブジェクト ブラウザー とナビゲーション機能ではシンボル テーブルを使用します。リファクタリングと 定義へ移動 ではセマンティック モデルを使用し、エディット コンティニュ では、生成 API を含む、これらすべてを使用します。
API レイヤー
.NET Compiler SDK は、いくつかの API レイヤー (コンパイラ API、診断 API、スクリプティング API、ワークスペース API) で構成
されています。
コンパイラ API
コンパイラ レイヤーには、構文とセマンティックの両方のコンパイラ パイプラインの各フェーズで公開される情報に対応するオブジェ クト モデルが含まれています。 また、コンパイラ レイヤーには、アセンブリ参照、コンパイラ オプション、ソース コード ファイルを含 む、コンパイラの単一呼び出しの不変のスナップショットも含まれています。 C# 言語と Visual Basic 言語を表す 2 つの異なる API があります。 これら 2 つの API の形は似ていますが、各言語を忠実に再現するために調整されます。 このレイヤーは Visual Studio のコンポーネントには依存しません。
診断 API
分析の一環として、コンパイラにより、構文、セマンティック、および限定代入エラーからさまざまな警告と情報診断に至るすべて をカバーする一連の診断情報が生成される場合があります。 コンパイラ API レイヤーは拡張可能な API を介して診断情報を 公開し、ユーザー定義のアナライザーをコンパイル プロセスに接続できるようにします。 これにより、StyleCop のようなツールで生 成されるものなど、ユーザー定義の診断情報を、コンパイラ定義の診断情報と一緒に生成することができます。 この方法で診 断情報を生成すると、ポリシーに基づくビルドの停止、エディターでの破線の即時表示、コード修正の提案などの操作の診断に 依存する、MSBuild や Visual Studio などのツールに自然に統合できるという利点があります。
スクリプト API
ホスト API とスクリプト API は、コンパイラ レイヤーの一部です。 コード スニペットを実行して、ランタイム実行コンテキストを蓄積 する場合にこれらを使用できます。 C# 対話型 REPL (Read-Evaluate-Print Loop) ではこれらの API を使用します。 REPL では、コードの書き込み時に対話的にコードを実行して、スクリプト言語として C# を使用できます。
ワークスペース API
ワークスペース レイヤーにはワークスペース API が含まれます。この API は、ソリューション全体でのコード分析とリファクタリングの 開始点となります。 単一オブジェクト モデルにソリューションのプロジェクトに関するすべての情報を簡単にまとめることができ、コ ンパイラ レイヤー オブジェクト モデルに直接アクセスできます。ファイルの解析、オプションの構成、プロジェクト間の依存関係の 管理は必要ありません。
さらに、ワークスペース レイヤーには、Visual Studio IDE のような、ホスト環境内で機能するコード分析およびリファクタリング

 ツールを実装するときに使用される一連の API も示されます。 たとえば、すべての参照の検索、書式設定、コード生成 API な どです。
このレイヤーは Visual Studio のコンポーネントには依存しません。

         "構文ツリー" は、コンパイラ API によって公開される基本的な変更不可のデータ構造です。 これらのツリーは、ソース コードの 字句および構文構造を表します。 これらは、次の 2 つの重要な目的を果たします。
IDE、アドイン、コード分析ツール、リファクタリングなどのツールで、ユーザーのプロジェクトのソース コードの構文構造を表示し て処理できるようにします。
リファクタリングや IDE などのツールで、自然な方法でソース コードを作成、変更、再配置できるようにします。テキストを直 接編集する必要がありません。 ツリーを作成して操作することで、ツールでソース コードを簡単に作成して再配置することが できます。
構文ツリー
構文ツリーは、コンパイル、コード分析、バインディング、リファクタリング、IDE 機能、コード生成に使用されるプライマリ構造で す。 ソース コードは、最初に識別され、多くのよく知られている構造的な言語要素の 1 つに分類されないと、どの部分も認識 されません。
構文ツリーには、次の 3 つのキー属性があります。
すべてのソース情報を完全に忠実に保持します。 完全な忠実性とは、構文ツリーには、ソース テキスト内で見つかったすべ ての情報、すべての文法的なコンストラクト、すべての構文トークン、およびその間にある他のすべてのもの (空白文字、コメ ント、プリプロセッサ ディレクティブを含む) が含まれることを意味します。 たとえば、ソースに記載されている各リテラルは、入 力されているとおりに表されます。 また、構文ツリーは、プログラムが不完全または形式が正しくないときにも、スキップされた トークンまたは見つからないトークンを表すことで、ソース コードのエラーをキャプチャします。 解析元の正確なテキストを生成できます。 任意の構文ノードから、そのノードで root 化されたサブツリーのテキスト表現を 取得できます。 これは、ソース テキストを構築および編集する方法として構文ツリーが使用できることを意味します。 ツリー を作成することで、暗黙的に同等のテキストを作成しています。また、既存のツリーへの変更から新しいツリーを作成すること で、効果的にテキストを編集しています。
これらは変更不可であり、スレッドセーフです。 ツリーの取得後は、コードの現在の状態のスナップショットで、変化することは ありません。 これにより、ロックや重複を発生させずに、複数のユーザーが異なるスレッドで同時に同じ構文ツリーと対話でき ます。 ツリーは変更不可でツリーを直接変更することはできないため、ツリーの追加のスナップショットを作成することで構文ツ リーを作成および変更するファクトリ メソッドが役立ちます。 基になるノードを再利用するという点でツリーは効果的であるた め、追加のメモリをほとんど使用せずに、新しいバージョンをすばやく再構築することができます。
構文ツリーは、文字どおりのツリー データ構造で、非終端構造の要素が他の要素の親となります。 各構文ツリーは、ノード、 トークン、およびトリビアで構成されます。
構文ノード
構文ノードは、構文ツリーのプライマリ要素の 1 つです。 これらのノードは、宣言、ステートメント、句、および式などの構文構造 を表します。 構文ノードの各カテゴリは、Microsoft.CodeAnalysis.SyntaxNode から派生した別のクラスによって表されます。 一連のノード クラスは拡張できません。
すべての構文ノードは、構文ツリー内の非終端ノードで、これは他のノードとトークンを常に子として持つことを意味します。 別 のノードの子として、各ノードは SyntaxNode.Parent プロパティからアクセスできる親ノードを持ちます。 ノードとツリーは変更で きないため、ノードの親が変わることはありません。 ツリーのルートには Null 親があります。
各ノードには SyntaxNode.ChildNodes() メソッドがあり、子ノードのリストをソース テキスト内の位置に基づいて順番に返しま す。 このリストにはトークンは含まれていません。 各ノードに は、DescendantNodes、DescendantTokens、DescendantTrivia などの子孫を調べるメソッドもあります。これらは、そのノー
構文の使用
2021/03/06 • • Edit Online
 
                    ドをルートとするサブツリー内に存在するすべてのノード、トークン、またはトリビアのリストを表しています。
さらに、構文ノードの各サブクラスは、厳密に型指定されたプロパティを通じて、まったく同じ子を公開します。 たとえ ば、BinaryExpressionSyntax ノード クラスには二項演算子に固有の 3 つのプロパティ、Left、OperatorToken、Right があり ます。 Left と Right の型は ExpressionSyntax で、OperatorToken の型は SyntaxToken です。
一部の構文ノードには、省略可能な子があります。 たとえば、IfStatementSyntax には省略可能な ElseClauseSyntax があ ります。 子が存在しない場合、プロパティは null を返します。
構文トークン
構文トークンとは、コードの最小の構文フラグメントを表す、言語文法の終端です。 これらが他のノードやトークンの親になるこ とはありません。 構文トークンは、キーワード、識別子、リテラル、および句読点で構成されます。
効率を高めるため、SyntaxToken 型は CLR 値型になっています。 そのため、構文ノードとは異なり、すべての種類のトークン に対して 1 つの構造しかなく、プロパティを組み合わせることで、表現されているトークンの種類に応じて意味を持たせます。
たとえば、整数リテラル トークンは、数値を表します。 リテラル トークンには、トークンの範囲となる未加工のソース テキストに加 え、正確にデコードされた整数値を示す Value プロパティがあります。 このプロパティは、多くのプリミティブ型の 1 つである場合 があるため、Object として型指定されます。
ValueText プロパティは Value プロパティと同じ情報を提供しますが、このプロパティは常に String として型指定されます。 C# ソース テキスト内の識別子には、Unicode のエスケープ文字を含めることができますが、エスケープ シーケンスの構文自体は、 識別子名の一部と見なされません。 そのため、トークンの範囲である未加工のテキストにはエスケープ シーケンスが含まれます が、ValueText プロパティには含まれません。 代わりに、エスケープで識別される Unicode 文字が含まれます。 たとえば、ソース テキストに \u03C0 として記述された識別子が含まれている場合、このトークンのValueTextプロパティは π を返します。
構文トリビア
構文トリビアは、空白、コメント、およびプリプロセッサ ディレクティブなど、コードを通常に理解するためにはさほど重要ではない ソース テキストの部分を表します。 構文トークンと同じく、トリビアも値型です。 トリビアのすべての種類を記述するために 1 つの Microsoft.CodeAnalysis.SyntaxTrivia 型が使用されます。
トリビアは通常の言語構文の一部ではなく、任意の 2 つのトークンの間の任意の場所に表示できるため、トリビアはノードの子 として構文ツリーには含まれません。 しかしトリビアは、リファクタリングなどの機能を実装するときや、ソース テキストへの忠実性 を維持するには重要なため、構文ツリーの一部として存在します。
トークンの SyntaxToken.LeadingTrivia または SyntaxToken.TrailingTrivia コレクションを調べることで、トリビアにアクセスでき ます。 ソース テキストが解析される時に、トリビアのシーケンスがトークンに関連付けられます。 一般に、その後トークンは任意の トリビアを次のトークンまで同じ行で所有します。 その行以降のすべてのトリビアは、後続のトークンに関連付けられます。 ソース ファイル内の最初のトークンがすべての初期トリビアを取得し、ファイル内のトリビアの最後のシーケンスが EOF トークンに付加さ れます。それ以外の場合は幅が 0 になります。
構文ノードやトークンとは異なり、構文トリビアには親がありません。 しかし、構文トリビアはツリーの一部で、それぞれが 1 つの トークンに関連付けられているため、SyntaxTrivia.Token プロパティを使用して、トリビアが関連付けられているトークンにアクセ スすることができます。
範囲
ノード、トークン、またはトリビアはそれぞれ、ソース テキスト内の各自の位置と構成文字数を把握しています。 テキストの位置 は、0から始まる char インデックスの32ビット整数値として表されます。TextSpanオブジェクトは開始位置と文字数で、どち らも整数として表されます。 TextSpan の長さが 0 の場合、2 つの文字の間の場所を参照します。
各ノードには、Span、FullSpan という 2 つの TextSpan プロパティが含まれます。
Span プロパティは、ノードのサブツリー内の最初のトークンの先頭から最後のトークンの末尾までのテキスト範囲です。 この範囲 には、先頭または末尾のトリビアはいずれも含まれません。
 
                FullSpan プロパティは、ノードの通常の範囲に加え、任意の先頭または末尾のトリビアの範囲を含むテキスト範囲です。 次に例を示します。
ブロック内のステートメント ノードには、1 つの縦棒 (|) によって示される範囲があります。 これには文字
throw new Exception("Not right."); が含まれています。 完全な範囲は、二重の縦棒 (||) によって示されます。 これには、
範囲と同じ文字と先頭および末尾のトリビアに関連付けられている文字が含まれます。 種類
ノード、トークン、またはトリビアにはそれぞれ、表される正確な構文要素を識別する System.Int32 型の SyntaxNode.RawKind プロパティがあります。 この値は、言語固有の列挙型にキャストすることができます。 C# または Visual Basicの各言語には、文法で可能なすべてのノード、トークン、およびトリビア要素を一覧表示する、1つの SyntaxKind 列挙 型 (それぞれ Microsoft.CodeAnalysis.CSharp.SyntaxKind と Microsoft.CodeAnalysis.VisualBasic.SyntaxKind) がありま す。 この変換は、CSharpExtensions.Kind または VisualBasicExtensions.Kind の拡張メソッドにアクセスすることで自動的に 行われます。
RawKind プロパティは、同じノード クラスを共有する構文ノード型の簡単なあいまいさ排除を可能にします。 トークンとトリビア では、このプロパティは要素の型を区別するための唯一の方法です。
たとえば、1 つの BinaryExpressionSyntax クラスに、Left、OperatorToken、および Right が子としてあるとします。 Kind プ ロパティは、構文ノードの種類が AddExpression、SubtractExpression、または MultiplyExpression であるかどうかを識別 します。
エラー
ソース テキストに構文エラーが含まれている場合でも、ソースへのラウンドトリップが可能な完全な構文ツリーが公開されます。 パーサーは、定義されている言語の構文に準拠しないコードを検出すると、次の 2 つのいずれかの手法を使って構文ツリーを 作成します。
パーサーが特定の種類のトークンを想定していたがそれが見つからない場合、その見つからないトークンを構文ツリーの 想定されていた場所に挿入することがあります。 見つからないトークンは、想定されていた実際のトークンを表しますが、 範囲は空で、そのSyntaxNode.IsMissingプロパティは true を返します。
パーサーが解析を続行できるトークンが見つかるまでトークンをスキップすることがあります。 この場合、スキップされたトー クンは、SkippedTokensTrivia の種類を持つトリビア ノードとしてアタッチされます。
    ||
if (x > 3) {
// this is bad
    |throw new Exception("Not right.");|  // better exception?||
}
       TIP
IsKind (C# の場合) または IsKind (VB の場合) の拡張メソッドを使用して、種類を確認することをお勧めします。
 
       構文ツリーは、ソース コードの字句および構文構造を表します。 ソースのすべての宣言とロジックを説明するにはこの情報だけ で十分ですが、参照内容を識別するには十分ではありません。 名前は以下を表す場合があります。
型
フィールド メソッド ローカル変数
これらはそれぞれ一意に異なりますが、実際に識別子が指しているものを判別するには、多くの場合、言語規則をよく理解す る必要があります。
ソース コードで表されるプログラム要素がいくつかあります。プログラムは、以前にコンパイルされ、アセンブリ ファイルにパッケージ 化されたライブラリを参照することもできます。 アセンブリで使用できるソース コードはありません (したがって、構文ノードやツリー もありません) が、プログラムは引き続き、その内部の要素を参照することができます。
これらのタスクには、セマンティック モデル が必要です。
ソース コードの構文モデルだけでなく、セマンティック モデルでも言語規則がカプセル化されます。これにより、参照される正しいプ ログラム要素と識別子を簡単に一致させることができます。
コンパイル
コンパイルは、C# または Visual Basic プログラムのコンパイルに必要なすべてを表します。これには、アセンブリ参照、コンパイラ オプション、ソース ファイルがすべて含まれます。
この情報はすべて 1 か所にあるため、ソース コードに含まれる要素を詳細に説明することができます。 コンパイルでは、宣言さ れる型、メンバー、または変数をそれぞれシンボルとして表します。 コンパイルにはさまざまなメソッドが含まれています。これら は、ソース コードで宣言されているか、アセンブリからメタデータとしてインポートされたシンボルを見つけて関連付けるのに役立ち ます。
構文ツリーと同じように、コンパイルは不変です。 作成したコンパイルを自分自身で変更することも、共有する可能性のある他 のユーザーが変更することもできません。 ただし、既存のコンパイルから新しいコンパイルを作成することはできます。その際に、 変更を指定します。 たとえば、追加のソース ファイルまたはアセンブリ参照が含まれる場合があることを除き、既存のコンパイルと あらゆる点で同じコンパイルを作成できます。
Symbols
シンボルは、ソース コードで宣言されたか、メタデータとしてアセンブリからインポートされた異なる要素を表します。 すべての名前 空間、型、メソッド、プロパティ、フィールド、イベント、パラメーター、またはローカル変数はシンボルで表されます。
Compilation 型のさまざまなメソッドとプロパティは、シンボルを見つけるのに役立ちます。 たとえば、共通のメタデータ名で宣言 された型のシンボルを見つけることができます。 グローバル名前空間をルートとするシンボルのツリーとしてシンボル テーブル全体 にアクセスすることもできます。
シンボルには、他の参照シンボルなど、ソースまたはメタデータからコンパイラが判別した追加情報も含まれます。 各種類のシン ボルは ISymbol から派生した個別のインターフェイスによって表され、それぞれ独自のメソッドとプロパティで、コンパイラが収集し た情報が詳細に示されます。 これらのプロパティの多くは、他のシンボルを直接参照します。 たとえ ば、IMethodSymbol.ReturnType プロパティは、メソッドから返される実際の型のシンボルを示します。
シンボルは、ソース コードとメタデータ間の名前空間、型、メンバーの共通表現を示します。 たとえば、ソース コードで宣言され
セマンティクスの使用
2021/03/06 • • Edit Online
 
   たメソッドと、メタデータからインポートされたメソッドは両方とも、同じプロパティを持つ IMethodSymbol で表されます。
シンボルは System.Reflection API で表される CLR 型システムと概念が似ていますが、型だけでなく、モデル化を行うという点 で優れています。 名前空間、ローカル変数、ラベルはすべてシンボルです。 また、シンボルは、CLR 概念ではなく、言語概念を 表します。 重複するものが多くありますが、意味のある違いも多くあります。 たとえば、C# または Visual Basic の反復子メソッ ドは単一のシンボルです。 ただし、反復子メソッドが CLR メタデータに変換された場合、それは 1 つの型および複数のメソッドと なります。
セマンティック モデル
セマンティック モデルは、1 つのソース ファイルに対するすべてのセマンティック情報を表します。 これを使用して以下を検出でき ます。
ソース内の特定の場所で参照されているシンボル。 任意の式の結果の型。 エラーや警告など、すべての診断情報。 ソース領域内外への変数のフロー状態。 より予測的な質問に対する回答。

      ワークスペース レイヤーは、ソリューション全体でのコード分析とリファクタリングの開始点となります。 このレイヤー内のワークス ペース API では、単一のオブジェクト モデルにソリューションのプロジェクトに関するすべての情報を簡単にまとめることができ、ソー ス テキスト、構文ツリー、セマンティック モデル、コンパイルのようなコンパイラ レイヤー オブジェクト モデルに直接アクセスできま す。ファイルの解析、オプションの構成、プロジェクト相互の依存性の管理は必要はありません。
IDE のようなホスト環境では、開いているソリューションに応じてワークスペースが提供されます。 単にソリューション ファイルを読 み込んで、IDE の外部でこのモデルを使用することもできます。
ワークスペース
ワークスペースは、ソリューションをプロジェクトのコレクションとしてアクティブに表現するものです。プロジェクトにはそれぞれドキュメ ントのコレクションが含まれます。 通常、ワークスペースは、ユーザーがプロパティを入力または操作するときに常に変化するホスト 環境に関連付けられます。
Workspace では、ソリューションの現在のモデルにアクセスできます。 ホスト環境が変わった場合、ワークスペースは対応するイ ベントを発生させ、Workspace.CurrentSolution プロパティが更新されます。 たとえば、ソース ドキュメントのいずれかに対応 するテキスト エディターにユーザーが入力した場合、ワークスペースでは、ソリューションのモデル全体が変更され、どのドキュメント が変更されたかを通知するイベントを使用します。 したがって、新しいモデルを分析して正しいかどうかを確認したり、重要な領 域を強調表示したり、あるいはコードの変更を提案することで、これらの変更に対応できます。
ホスト環境から切断されているか、ホスト環境がないアプリケーションで使用されるスタンドアロンのワークスペースを作成すること もできます。
ソリューション、プロジェクト、およびドキュメント
キーが押されるたびにワークスペースが変更されることがありますが、ソリューションのモデルを単独で操作することができます。
ソリューションはプロジェクトとドキュメントの不変モデルです。 つまり、モデルはロックしたり複製したりしなくても共有することができ ます。 Workspace.CurrentSolution プロパティからソリューション インスタンスを取得した後、そのインスタンスが変わることはあ りません。 ただし、構文ツリーやコンパイルの場合と同じように、既存のソリューションと特定の変更に基づいて新しいインスタンス を構築することで、ソリューションを変更できます。 ワークスペースで変更を反映するには、変更されたソリューションをワークス ペースに明示的に適用し直す必要があります。
プロジェクトは、不変ソリューション モデル全体の一部です。 ソース コード ドキュメント、解析とコンパイル オプション、アセンブリと プロジェクト間の両方の参照をすべて表します。 プロジェクトから対応するコンパイルにアクセスできます。プロジェクトの依存関 係を判別したり、ソース ファイルを解析する必要はありません。
ドキュメントも不変ソリューション モデル全体の一部です。 ドキュメントは単一のソース ファイルを表すものであり、そこからファイル のテキスト、構文ツリー、セマンティック モデルにアクセスできます。
次の図は、ワークスペースとホスト環境やツールとの関係、および編集がどのように行われるかを示しています。
ワークスペースの使用
2021/03/06 • • Edit Online
 
  まとめ
Roslyn では一連のコンパイラ API とワークスペース API が公開されます。これらの API は、ソース コードに関する豊富な情報を 提供し、C# および Visual Basic 言語を完全に再現します。 .NET Compiler Platform SDK は、コードにフォーカスされたツー ルとアプリケーションの作成における参入障壁を劇的に低くします。 これにより、メタプログラミング、コードの生成と変換、C# と Visual Basic 言語の対話型の使用、ドメイン固有の言語での C# と Visual Basic の埋め込みなどの領域で、多くのイノベー ションの機会が生み出されます。

      この記事では、.NET Compiler Platform ("Roslyn") SDK の一部として同梱されている Syntax Visualizer ツールの概要を 説明します。 Syntax Visualizer は、構文ツリーを検査および調査するときに役立つツール ウィンドウです。 これは、分析する コードのモデルを理解するために欠かせないツールです。 .NET Compiler Platform (“Roslyn”) SDK を使用して、独自のアプ リケーションを開発するときのデバッグにも役立ちます。 最初のアナライザーを作成するときに、このツールを開きます。 この Visualizer は、API で使用されるモデルを理解するのに役立ちます。 SharpLab や LINQPad などのツールを使用しても、コー ドを調査し、構文ツリーを理解することができます。
インストール手順 - Visual Studio インストーラー
Visual Studio インストーラーで .NET Compiler Platform SDK を見つけるには、以下の 2 つの異なる方法がありま
す。
Visual Studio インストーラーを使用したインストール - ワークロード ビュー
.NET Compiler Platform SDK は、Visual Studio 拡張機能の開発ワークロードの一部として自動的に選択されません。 省 略可能なコンポーネントとして選択する必要があります。
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. Visual Studio 拡張機能の開発ワークロードを確認します。
4. 概要ツリーの [Visual Studio 拡張機能の開発] ノードを開きます。
5. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 省略可能なコンポーネントの最後に表示されま
す。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. 概要ツリーの [個別のコンポーネント] ノードを開きます。 2. [DGML エディター] のチェック ボックスをオンにします。
Visual Studio インストーラーを使用したインストール - [個別のコンポーネント] タブ
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. [個別のコンポーネント] タブを選択します。
4. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 [コンパイラ、ビルド ツール、およびランタイム] セ
クションの上部に表示されます。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. [DGML エディター] チェック ボックスをオンにします。 [コード ツール] セクションに表示されます。
「.NET Compiler Platform SDK の概念とオブジェクト モデル」の記事を読んで、.NET Compiler Platform SDK で使われてい る概念をよく理解してください。 この記事では、構文ツリー、ノード、トークン、およびトリビアについて説明されています。
Syntax Visualizer
Syntax Visualizer を使用すると、Visual Studio IDE 内の現在アクティブなエディター ウィンドウで、C# または Visual Basic のコード ファイルの構文ツリーを検査できます。 Syntax Visualizer を起動するには、 [ビュー] > [その他のウィンドウ] >
Visual Studio で Roslyn Syntax Visualizer を使って
コードを調べる
2020/11/02 • • Edit Online
 
  [Syntax Visualizer] の順にクリックします。 右上隅の [サイド リンク バー] ツールバーを使用することもできます。 「syntax」 と開くコマンドを入力すると、Syntax Visualizer が表示されます。
このコマンドにより、Syntax Visualizer がフローティング ツール ウィンドウとして開きます。 開いているコード エディター ウィンドウ がない場合は、次の図に示すように、表示は空白になります。
このツール ウィンドウを、Visual Studio 内の任意の場所 (左側など) にドッキングします。 Visualizer によって、現在のコード ファイルに関する情報が表示されます。
[ファイル] > [新しいプロジェクト] コマンドを使用して、新しいプロジェクトを作成します。 Visual Basic または C# のプロジェク トを作成することができます。 Visual Studio でこのプロジェクトのメイン コード ファイルが開かれるときに、Visualizer によってそ の構文ツリーが表示されます。 この Visual Studio インスタンスで既存の C#/Visual Basic ファイルを開き、Visualizer でその ファイルの構文ツリーを表示することができます。 Visual Studio 内で複数のコード ファイルを開いている場合、Visualizer は現 在アクティブなコード ファイル (キーボードのフォーカスがあるコード ファイル) の構文ツリーを表示します。
C#
Visual Basic
 
   前出の画像のように、Visualizer ツール ウィンドウでは、上部に構文ツリーが表示され、下部にプロパティ グリッドが表示されま す。 プロパティ グリッドには、ツリーで現在選択されている項目のプロパティが表示されます。これには、項目の .NET 型と種類 (SyntaxKind) が含まれます。
構文ツリーは、ノード、トークン、およびトリビアの 3 つの項目の型で構成されています。 これらの型については、構文の使用 の 記事で詳しく説明されています。 項目は型ごとに異なる色を使用して表されています。 使用されている色の概要については、 [凡例] ボタンをクリックします。
ツリー内の各項目には、独自のスパンも表示されています。 スパンは、テキスト ファイル内のそのノードのインデックス (開始位 置と終了位置) です。 前出の C# の例では、選択されている "UsingKeyword [0..5)" トークンには、5 文字の幅のスパン [0..5) があります。 "[..)" の表記は、開始インデックスはスパンの一部ですが、終了インデックスはそうではないことを意味します。
ツリーを移動するには、次の 2 つの方法があります。
ツリー内の項目を展開またはクリックします。 Visualizer により、この項目のスパンに対応するテキストがコード エディターで自 動的に選択されます。
コード エディターで、テキストをクリックまたは選択します。 前出の Visual Basic の例では、コード エディターで "Module Module1" を含む行を選択すると、Visualizer によってツリー内の対応する ModuleStatement ノードに自動的に移動さ れます。
スパンがエディターで選択したテキストのスパンと最も一致する項目が、Visualizer により強調表示されます。 Visualizerは、アクティブなコードファイル内の変更に合わせてツリーを更新します。 Console.WriteLine() への呼び出しを
Main() 内に追加します。入力すると、Visualizerによってツリーが更新されます。
Console. を入力したら、入力を一旦停止します。ツリーには、ピンク色の項目がいくつかあります。この時点では、型指定さ れたコードにはエラー ('診断' とも呼ばれる) があります。 これらのエラーは、構文ツリー内のノード、トークン、およびトリビアに添 付されます。 エラーが添付された項目が、Visualizer によってピンク色の背景で強調表示されます。 ピンク色で表示されている 任意の項目の上にポインターを置くと、エラーを調査することができます。 Visualizer では、構文エラー (型指定されたコードの 構文に関連するエラー) のみが表示され、セマンティック エラーは表示されません。
構文グラフ
ツリー内の任意の項目を右クリックし、 [View Directed Syntax Graph](有向構文グラフの表示) をクリックします。
   
  C#
Visual Basic
Visualizerにより、選択した項目をルートとするサブツリーのグラフィカル表現が表示されます。C#の例で Main() のメソッドに 対応する MethodDeclaration ノードに、これらの手順を試してみます。 Visualizer により、次のような構文グラフが表示さ れます。
  構文グラフ ビューアーには、その色分けスキームの凡例を表示するオプションがあります。 マウスを使って、構文グラフ内の個々 の項目にポインターを合わせても、その項目に対応するプロパティを表示することができます。
ツリー内の異なる項目の構文グラフを繰り返し表示することができます。グラフは常に Visual Studio 内の同じウィンドウに表示 されます。 このウィンドウを Visual Studio 内の任意の場所にドッキングすることで、新しい構文グラフを表示するためにタブを切 り替える必要がなくなります。 多くの場合、下部 (コード エディター ウィンドウの下) にドッキングすると便利です。
Visualizer ツール ウィンドウと構文グラフ ウィンドウを使用するためのドッキング レイアウトを次に示します。
 デュアル モニターの設定では、2 つ目のモニターに構文グラフ ウィンドウを配置することもできます。 セマンティクスの検査
Syntax Visualizer を使用すると、シンボルとセマンティクス情報についての基本的な検査ができます。 C# の例で Main() 内に double x = 1 + 1; を入力します。 次に、コード エディター ウィンドウで式 1 + 1 を選択します。 Visualizer で
AddExpression ノードが強調表示されます。 この [AddExpression] をクリックし、 [View Symbol (if any)](シンボル の表示 (ある場合)) をクリックします。 メニュー項目のほとんどに "if any" 修飾子があることに注目してください。 Syntax Visualizer は、ノードのプロパティ (すべてのノードに提示されない場合があるプロパティを含む) を検査します。
 
 ビジュアライザー内のプロパティ グリッドが、次の図のように更新されます。式のシンボル は、SynthesizedIntrinsicOperatorSymbol と Kind = Method です。
同じ AddExpression ノードに対し、 [View TypeSymbol (if any)](TypeSymbol の表示 (ある場合)) を試してみま す。Visualizerのプロパティグリッドが、次の図に示すように更新され、選択された式の型が Int32 であることを示します。
同じ AddExpression ノードに対し、 [View Converted TypeSymbol (if any)](変換された TypeSymbol の表示 (ある場合))を試してみます。プロパティグリッドが更新され、次の図に示すように、式の型は Int32 で、式の変換後の型は
Double であることを示します。 Double に変換する必要があるコンテキストで Int32 式が発生するため、このノードには変 換後の型のシンボル情報が含まれます。この変換により、代入演算子の左側にある変数 x に指定された Double 型を満 たします。
     
  最後に、同じ AddExpression ノードに対し、 [View Constant Value (if any)](定数値の表示 (ある場合)) を試し てみます。プロパティグリッドには、式の値が、値 2 を持つコンパイル時の定数であることが示されます。
前の例は Visual Basic でもレプリケートできます。 Visual Basic ファイルで Dim x As Double = 1 + 1 を入力します。 コード エディター ウィンドウで式 1 + 1 を選択します。 Visualizer で対応する AddExpression ノードが強調表示されます。 この AddExpression に対して上記の手順を繰り返すと、同一の結果になるはずです。
Visual Basic でさらに多くのコードを調べます。 メインの Visual Basic ファイルを次のコードで更新します。
  
    このコードは、ファイルの上部にある型 System.Console にマップする C という名前の別名を導入し、この別名を Main() の 内部で使用します。 Main() メソッド内部で、この別名の使用を選択します ( C.WriteLine() の C )。 Visualizer で、対応 する IdentifierName ノードが選択されます。 このノードを右クリックし、 [View Symbol (if any)](シンボルの表示 (あ る場合))をクリックします。プロパティグリッドには、次の図に示すように、この識別子が型 System.Console にバインドされて いることが示されます。
同じ IdentifierName ノードに対して、 [View AliasSymbol (if any)](AliasSymbol の表示 (ある場合)) を試して みます。プロパティグリッドには、識別子が System.Console ターゲットにバインドされている C という名前の別名であることが 示されます。つまり、プロパティグリッドでは、識別子 C に対応するAliasSymbolに関する情報が提供されます。
        Imports C = System.Console
Module Program
    Sub Main(args As String())
        C.WriteLine()
    End Sub
End Module
 
   任意の宣言された型、メソッド、プロパティに対応するシンボルを検査します。 Visualizer で対応するノードを選択し、 [View Symbol (if any)](シンボルの表示 (ある場合)) をクリックします。 Sub Main() メソッドを選択します。メソッドの本文も含 めます。 Visualizer で対応する SubBlock ノードに対し、 [View Symbol (if any)](シンボルの表示 (ある場合)) をク リックします。プロパティグリッドには、このSubBlockのMethodSymbolの名前が Main で、戻り値の型が Void である ことが示されます。
上記の Visual Basic の例は、C# で簡単にレプリケートできます。 別名の Imports C = System.Console の代わりに
using C = System.Console; を入力します。 C# で上記の手順を行うと、Visualizer ウィンドウの結果はまったく同じになりま
す。
セマンティックの検査操作は、ノードでのみ使用できます。 トークンまたはトリビアでは使用できません。 すべてのノードに検査す る興味深いセマンティック情報があるわけではありません。 ノードに興味深いセマンティック情報がない場合は、 [View * Symbol (if any)](シンボルの表示 (ある場合)) をクリックすると、空白のプロパティ グリッドが表示されます。
    セマンティック分析を実行するための API の詳細については、「セマンティクスの使用」概要ドキュメントを参照してください。

 Syntax Visualizer を閉じる
Syntax Visualizer ウィンドウは、ソース コードを調べるのに使用しない場合には閉じることができます。 Syntax Visualizer で は、コード内を移動してソースを編集および変更するたびに表示が更新されます。 使用しない場合は、邪魔に感じる場合が あります。

   このチュートリアルでは、Syntax API について学習します。 Syntax API では、C# または Visual Basic プログラムを記述する データ構造へのアクセスが提供されます。 これらのデータ構造には、あらゆるサイズのあらゆるプログラムを完全に表すことができ る十分な情報があります。 これらの構造では、正しくコンパイルして実行される完全なプログラムを記述できます。 エディターで は、書き込み時に、不完全なプログラムを記述することもできます。
この優れた式を有効にする場合、Syntax API を構成する API とデータ構造が必然的に複雑になります。 まずは、一般的な "Hello World" プログラムのデータ構造がどのようになるかを見てみましょう。
    using System;
using System.Collections.Generic;
using System.Linq;
namespace HelloWorld
{
    class Program
    {
} }
static void Main(string[] args)
{
    Console.WriteLine("Hello World!");
}
 上のプログラムのテキストを見てください。 使い慣れた要素であることがわかります。 テキスト全体は単一のソース ファイル (コン パイル ユニット) を表しています。 そのソース ファイルの最初の 3 行は using ディレクティブです。 残りのソースは名前空間 宣言に含まれています。 名前空間宣言には子クラス宣言が含まれています。 クラス宣言には 1 つのメソッド宣言が含まれて います。
Syntax API では、コンパイル ユニットを表すルートを含むツリー構造が作成されます。 ツリー内のノードは、using ディレクティ ブ、名前空間宣言およびプログラムの他のすべての要素を表しています。 ツリー構造は最下位レベルまで続きます。文字列 "Hello World!" は、引数の子孫である文字列リテラル トークンです。 Syntax API では、プログラムの構造体へのアクセスが 提供されます。 特定のコード プラクティスに対してクエリを実行し、ツリー全体をウォークしてコードを理解し、既存のツリーを変 更して新しいツリーを作成することができます。
その簡単な説明では、Syntax API を使用してアクセスできる情報の種類の概要を示します。 Syntax API は、C# の使い慣れ たコード コンストラクトを記述する正式な API にすぎません。 完全な機能には、改行、空白、インデントを含め、コードの書式 設定方法に関する情報が含まれます。 この情報を使用して、人間のプログラマまたはコンパイラによって書き込まれ、読み取ら れるコードを完全に表すことができます。 この構造を使用することで、深い意味のあるレベルのソース コードと対話することができ ます。 テキスト文字列はもう存在しませんが、C# プログラムの構造を表すデータはあります。
まず .NET Compiler Platform SDK をインストールする必要があります。 インストール手順 - Visual Studio インストーラー
Visual Studio インストーラーで .NET Compiler Platform SDK を見つけるには、以下の 2 つの異なる方法がありま す。
Visual Studio インストーラーを使用したインストール - ワークロード ビュー
.NET Compiler Platform SDK は、Visual Studio 拡張機能の開発ワークロードの一部として自動的に選択されません。 省 略可能なコンポーネントとして選択する必要があります。
構文解析の概要
2020/11/02 • • Edit Online
 
        1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. Visual Studio 拡張機能の開発ワークロードを確認します。
4. 概要ツリーの [Visual Studio 拡張機能の開発] ノードを開きます。
5. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 省略可能なコンポーネントの最後に表示されま
す。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. 概要ツリーの [個別のコンポーネント] ノードを開きます。 2. [DGML エディター] のチェック ボックスをオンにします。
Visual Studio インストーラーを使用したインストール - [個別のコンポーネント] タブ
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. [個別のコンポーネント] タブを選択します。
4. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 [コンパイラ、ビルド ツール、およびランタイム] セ
クションの上部に表示されます。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. [DGML エディター] チェック ボックスをオンにします。 [コード ツール] セクションに表示されます。
構文ツリーについて
C# コードの構造の分析には Syntax API を使用します。 Syntax API では、パーサー、構文ツリー、および構文ツリーを分析 して構築するためのユーティリティを公開します。 これを使用して、特定の構文要素のコードの検索またはプログラムのコードの 読み取りを行います。
構文ツリーは、C# および Visual Basic プログラムを理解するために C# および Visual Basic コンパイラで使用されるデータ構造 です。 構文ツリーは、プロジェクトのビルド時、または開発者が F5 キーを押したときに実行されるのと同じパーサーによって生成 されます。 構文ツリーは言語に対して完全に忠実であり、コード ファイル内のすべての情報はツリーで表されます。 構文ツリー をテキストに書き込むことで、解析された元の正確なテキストが再現されます。 構文ツリーは不変でもあります。構文ツリーを作 成した後で変更することはできません。 ツリーのコンシューマーは、データが変更されないことを認識したうえで、ロックやその他の コンカレンシー手段を使用せずに、複数のスレッドでツリーを分析できます。 API を使用して、新しいツリーを作成することができ ます。その場合、既存のツリーを変更します。
構文ツリーの 4 つの基本的な構成要素は次のとおりです。
Microsoft.CodeAnalysis.SyntaxTree クラス。インスタンスで解析ツリー全体を表します。 SyntaxTree は、言語固有の派 生物を持つ抽象クラスです。 Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree (または Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree) クラスの解析メソッドを使用して、C# (または Visual Basic) のテキストを解析します。
Microsoft.CodeAnalysis.SyntaxNode クラス。インスタンスで、宣言、ステートメント、句、および式などの構文構造を表し ます。
Microsoft.CodeAnalysis.SyntaxToken 構造。個々のキーワード、ID、演算子、または句読点を表します。
最後は Microsoft.CodeAnalysis.SyntaxTrivia 構造です。これは、トークン、プリプロセス ディレクティブ、およびコメントの 間の空白など、重要でない情報を構文的に表します。
トリビア、トークン、およびノードは、Visual Basic または C# コードのフラグメント内のすべてを完全に表すツリーを形成するため に階層的に構成されます。 この構造は、Syntax Visualizer ウィンドウを使用して確認することができます。 Visual Studio で、 [ビュー] > [その他のウィンドウ] > [Syntax Visualizer](Syntax Visualizer) の順に選択します。 たとえ ば、Syntax Visualizer を使用して調べた上記の C# ソース ファイルは、次の図のようになります。
SyntaxNode: 青 | SyntaxToken: 緑 | SyntaxTrivia: 赤

   このツリー構造を移動することで、ステートメント、式、トークン、またはコード ファイルのわずかな空白を見つけることができます。
Syntax API を使用してコード ファイルで何でも見つけることはできますが、ほとんどのシナリオでは、コードの小さなスニペットの確 認や、特定のステートメントまたはフラグメントの検索が必要です。 以下の 2 つの例では、コードの構造の参照、または単一ス テートメントの検索を行う場合の一般的な使用方法を示します。
ツリーの走査
2 つの方法で構文ツリー内のノードを調べることができます。 ツリーを走査して、各ノードを調べることができます。あるいは、特 定の要素やノードに対してクエリを実行することができます。
手動による走査
このサンプルの完成したコードは、GitHub のリポジトリで確認できます。

  次のようにして、新しい C# の Stand-Alone Code Analysis Tool プロジェクトを作成します。
Visual Studio で、 [ファイル] > [新規] > [プロジェクト] の順に選択して、[新しいプロジェクト] ダイアログを表示します。 [Visual C#] > [機能拡張] で、 [Stand-Alone Code Analysis Tool] を選択します。
プロジェクトに "SyntaxTreeManualTraversal" という名前を付けて、[OK] をクリックします。
前述の基本的な"HelloWorld!"プログラムを分析します。HelloWorldプログラムのテキストを Program クラスの定数とし て追加します。
             const string programText =
@"using System;
using System.Collections;
using System.Linq;
using System.Text;
namespace HelloWorld
{
    class Program
    {
} }";
static void Main(string[] args)
{
    Console.WriteLine(""Hello, World!"");
}
  次に、以下のコードを追加して、 programText 定数のコード テキストの構文ツリーをビルドします。 次の行を Main メソッドに 追加します。
これら 2 行でツリーを作成し、そのツリーのルート ノードを取得します。 これでツリー内のノードを調べることができます。 以下の 行を Main メソッドに追加して、ツリー内のルートノードのプロパティをいくつか表示します。
アプリケーションを実行して、このツリー内のルート ノードについて、コードで検出された内容を確認します。
通常、コードについて学習する場合、ツリーを走査します。 この例では、使い慣れたコードを分析して、API を調べます。 次の コードを追加して、 root ノードの最初のメンバーを調べます。
    SyntaxTree tree = CSharpSyntaxTree.ParseText(programText);
CompilationUnitSyntax root = tree.GetCompilationUnitRoot();
     WriteLine($"The tree is a {root.Kind()} node.");
WriteLine($"The tree has {root.Members.Count} elements in it.");
WriteLine($"The tree has {root.Usings.Count} using statements. They are:");
foreach (UsingDirectiveSyntax element in root.Usings)
    WriteLine($"\t{element.Name}");
    NOTE
構文ツリー型では継承を使用して、プログラムのさまざまな場所で有効なさまざまな構文要素を記述します。 これらの API を使用すること は、多くの場合、特定の派生型にプロパティまたはコレクション メンバーをキャストすることを意味します。 次の例では、割り当てとキャストは 別のステートメントであり、明示的に型指定された変数を使用します。 コードを読み取り、API の戻り値の型と返されるオブジェクトのランタ イム型を確認することができます。 実際には、暗黙的に型指定された変数を使用して、API 名に依存して、調べられるオブジェクトの型を 記述するのがより一般的です。
 
      そのメンバーは Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax です。 namespace HelloWorld 宣言のスコープ内ですべてを表します。 次のコードを追加して、 HelloWorld 名前空間内で宣言されているノードを調べま す。
プログラムを実行して、学習した内容を確認します。
宣言が Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax であることがわかったので、その型の新しい変数 を宣言して、クラス宣言を調べます。このクラスには1つのメンバー(Main メソッド)のみが含まれます。次のコードを追加して
Main メソッドを見つけ、それをMicrosoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntaxにキャストします。
メソッド宣言ノードには、メソッドに関するすべての構文情報が含まれています。 次は、 Main メソッドの戻り値の型、引数の数 と型、およびメソッドの本文を表示します。 次のコードを追加します。
     WriteLine($"There are {helloWorldDeclaration.Members.Count} members declared in this namespace.");
WriteLine($"The first member is a {helloWorldDeclaration.Members[0].Kind()}.");
     var programDeclaration = (ClassDeclarationSyntax)helloWorldDeclaration.Members[0];
WriteLine($"There are {programDeclaration.Members.Count} members declared in the
{programDeclaration.Identifier} class.");
WriteLine($"The first member is a {programDeclaration.Members[0].Kind()}.");
var mainDeclaration = (MethodDeclarationSyntax)programDeclaration.Members[0];
     WriteLine($"The return type of the {mainDeclaration.Identifier} method is {mainDeclaration.ReturnType}."); WriteLine($"The method has {mainDeclaration.ParameterList.Parameters.Count} parameters.");
foreach (ParameterSyntax item in mainDeclaration.ParameterList.Parameters)
    WriteLine($"The type of the {item.Identifier} parameter is {item.Type}.");
WriteLine($"The body text of the {mainDeclaration.Identifier} method follows:");
WriteLine(mainDeclaration.Body.ToFullString());
var argsParameter = mainDeclaration.ParameterList.Parameters[0];
 プログラムを実行して、このプログラムについて検出したすべての情報を表示します。
    The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
}
    MemberDeclarationSyntax firstMember = root.Members[0];
WriteLine($"The first member is a {firstMember.Kind()}.");
var helloWorldDeclaration = (NamespaceDeclarationSyntax)firstMember;
 
             クエリ メソッド
ツリーの走査に加え、Microsoft.CodeAnalysis.SyntaxNode で定義されているクエリ メソッドを使用して、構文ツリーを調べる こともできます。 XPath を使い慣れていれば、これらのメソッドをすぐに使いこなすことができます。 LINQ でこれらのメソッドを使 用することで、ツリー内の内容をすばやく検索できます。 SyntaxNode に は、DescendantNodes、AncestorsAndSelf、ChildNodes などのクエリ メソッドがあります。
これらのクエリ メソッドを使用すれば、ツリーを移動せずに、 Main メソッドに対する引数を検索することができます。 次のコード を Main メソッドの下部に追加します。
    var firstParameters = from methodDeclaration in root.DescendantNodes()
                                        .OfType<MethodDeclarationSyntax>()
                      where methodDeclaration.Identifier.ValueText == "Main"
                      select methodDeclaration.ParameterList.Parameters.First();
var argsParameter2 = firstParameters.Single();
WriteLine(argsParameter == argsParameter2);
 最初のステートメントでは LINQ 式と DescendantNodes メソッドを使用して、前の例と同じパラメーターを検索します。
プログラムを実行すると、ツリーを手動で移動する場合と同じパラメーターが LINQ 式で検出されたことがわかります。
このサンプルでは WriteLine ステートメントを使用して、走査された構文ツリーに関する情報を表示します。デバッガーで完成 したプログラムを実行して、さらに理解を深めることもできます。 hello world プログラム用に作成された構文ツリーの一部である メソッドとプロパティをさらに調べることができます。
構文ウォーカー
多くの場合、構文ツリーで特定の型のノード (ファイル内のすべてのプロパティ宣言など) をすべて検索する必要があります。 Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker クラスを拡張 し、VisitPropertyDeclaration(PropertyDeclarationSyntax) メソッドをオーバーライドして、構造を事前に認識せずに、構 文ツリーのすべてのプロパティ宣言を処理します。 CSharpSyntaxWalker は、ノードとその各子に再帰的にアクセスする特定の 種類の CSharpSyntaxVisitor です。
この例では、構文ツリーを調べるCSharpSyntaxWalkerを実装します。 System 名前空間をインポートしていない using ディレクティブを収集します。
新しい C# のStand-Alone Code Analysis Tool プロジェクトを作成し、"SyntaxWalker" という名前を付けます。 このサンプルの完成したコードは、GitHub のリポジトリで確認できます。 GitHub のサンプルには、このチュートリアルで説明され
ている両方のプロジェクトが含まれています。 上記のサンプルと同様に、分析しようとしているプログラムのテキストを保持する文字列定数を定義できます。
  
       このソース テキストには、4 つの異なる場所 (ファイル レベル、最上位の名前空間、2 つの入れ子になった名前空間) に分散さ れている using ディレクティブが含まれます。この例では、コードに対してクエリを実行するCSharpSyntaxWalkerクラスを使 用する主なシナリオに焦点を当てます。 using 宣言を検索するためにルート構文ツリー内のすべてのノードにアクセスするのは 面倒です。 代わりに、派生クラスを作成し、ツリー内の現在のノードが using ディレクティブである場合にのみ、呼び出されるメ ソッドをオーバーライドします。ビジターは他のノード型に対して何も行いません。この単一のメソッドで各 using ステートメント を調べ、 System 名前空間にはない名前空間のコレクションをビルドします。 すべての using ステートメント ( using ステート メントのみ) を調べる CSharpSyntaxWalker をビルドします。
これでプログラム テキストを定義したので、 SyntaxTree を作成して、そのツリーのルートを取得する必要があります。
次は、新しいクラスを作成します。 Visual Studio で、 [プロジェクト] > [新しい項目の追加] の順に選択します。 [新しい 項目の追加] ダイアログで、ファイル名として「UsingCollector.cs」と入力します。
UsingCollector クラスで using ビジター機能を実装します。まず、CSharpSyntaxWalkerから UsingCollector クラスを 派生させます。
収集する名前空間ノードを保持する記憶域が必要です。 UsingCollector クラスでパブリックの読み取り専用プロパティを宣 言します。その場合、以下の変数を使用して、検索する UsingDirectiveSyntax ノードを格納します。
      SyntaxTree tree = CSharpSyntaxTree.ParseText(programText);
CompilationUnitSyntax root = tree.GetCompilationUnitRoot();
     class UsingCollector : CSharpSyntaxWalker
    public ICollection<UsingDirectiveSyntax> Usings { get; } = new List<UsingDirectiveSyntax>();
 基本クラスの CSharpSyntaxWalker では、構文ツリー内の各ノードにアクセスするロジックを実装します。 派生クラスは、対象
           const string programText =
@"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
namespace TopLevel
{
    using Microsoft;
    using System.ComponentModel;
    namespace Child1
    {
        using Microsoft.Win32;
        using System.Runtime.InteropServices;
class Foo { } }
    namespace Child2
    {
        using System.CodeDom;
        using Microsoft.CSharp;
class Bar { } }
}";
 
      となる特定のノードに対して呼び出されたメソッドをオーバーライドします。 この例では、 using ディレクティブが対象となります。 つまり、VisitUsingDirective(UsingDirectiveSyntax) メソッドをオーバーライドする必要があります。 このメソッドへの 1 つの引 数は Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax オブジェクトです。 これがビジターを使用する最も重 要は利点です。特定のノード型に既にキャストされている引数を使用して、オーバーライドされたメソッドを呼び出します。 Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax クラスには、インポートされる名前空間の名前を格納する Name プロパティがあります。 それは Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax です。 VisitUsingDirective(UsingDirectiveSyntax) オーバーライドで次のコードを追加します。
    public override void VisitUsingDirective(UsingDirectiveSyntax node)
{
    WriteLine($"\tVisitUsingDirective called with {node.Name}.");
    if (node.Name.ToString() != "System" &&
        !node.Name.ToString().StartsWith("System."))
    {
        WriteLine($"\t\tSuccess. Adding {node.Name}.");
        this.Usings.Add(node);
    }
}
  前の例と同様に、このメソッドを理解するのに役立つさまざまな WriteLine ステートメントを追加しました。呼びされるタイミン グと、毎回渡される引数を確認できます。
最後に、2行のコードを追加して を作成し、ルートノードにアクセスするようにして、using ステートメントを すべて収集する必要があります。次に、 ループを追加して、コレクターが検出した using ステートメントをすべて表 示します。
プログラムをコンパイルして実行します。 次の出力が表示されます。
 UsingCollector
 foreach
    var collector = new UsingCollector();
collector.Visit(root);
foreach (var directive in collector.Usings)
{
    WriteLine(directive.Name);
}
             VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
 おめでとうございます! Syntax API を使用して、C# ソース コードで特定の種類の C# ステートメントと宣言を検索しました。

      このチュートリアルでは、構文 API の知識を前提としています。 「構文解析の概要」という記事が入門編になっています。 このチュートリアルでは、シンボル API とバインドの API について学習します。 これらの API は、プログラムの_意味論的意味_
に関する情報を提供します。 プログラムのシンボルが表す型について質問したり、回答したりできます。 .NET Compiler Platform SDK をインストールする必要があります。
インストール手順 - Visual Studio インストーラー
Visual Studio インストーラーで .NET Compiler Platform SDK を見つけるには、以下の 2 つの異なる方法がありま
す。
Visual Studio インストーラーを使用したインストール - ワークロード ビュー
.NET Compiler Platform SDK は、Visual Studio 拡張機能の開発ワークロードの一部として自動的に選択されません。 省 略可能なコンポーネントとして選択する必要があります。
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. Visual Studio 拡張機能の開発ワークロードを確認します。
4. 概要ツリーの [Visual Studio 拡張機能の開発] ノードを開きます。
5. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 省略可能なコンポーネントの最後に表示されま
す。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. 概要ツリーの [個別のコンポーネント] ノードを開きます。 2. [DGML エディター] のチェック ボックスをオンにします。
Visual Studio インストーラーを使用したインストール - [個別のコンポーネント] タブ
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. [個別のコンポーネント] タブを選択します。
4. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 [コンパイラ、ビルド ツール、およびランタイム] セ
クションの上部に表示されます。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. [DGML エディター] チェック ボックスをオンにします。 [コード ツール] セクションに表示されます。
コンパイルとシンボルについて
.NET コンパイラ SDK での作業が増えると、構文 API とセマンティック API の違いに詳しくなります。 構文 API では、プログラム の_構造_を見ることができます。 ただし、多くの場合、プログラムの意味論または_意味_に関する豊富な情報が必要になりま す。 Visual Basic または C# の緩いコード ファイルまたはスニペットは分離して構文的に解析できますが、孤立状態では、"この 変数の型は何ですか" のような質問を問うことに意味がありません。 型名の意味は、アセンブリ参照、名前空間インポート、そ の他のコード ファイルに依存することがあります。 このような問いには、セマンティック API で、具体的には Microsoft.CodeAnalysis.Compilation クラスで答えられます。
Compilation のインスタンスはコンパイラで見られるように 1 つのプロジェクトに類似し、Visual Basic または C# のプログラムをコ
セマンティック解析の概要
2020/03/18 • • Edit Online
 
         ンパイルするために必要なすべてを表します。 コンパイルには、コンパイルするソース ファイルのセット、アセンブリ参照、コンパイ ラ オプションが含まれます。 この文脈のその他すべての情報を利用し、コードの意味を推論できます。 Compilation では、型、 名前空間、メンバー、名前やその他の式が参照する変数などのエンティティであるシンボルを見つけることができます。 名前や 式をシンボルと関連付けるプロセスをバインドと呼んでいます。
Microsoft.CodeAnalysis.SyntaxTree と同様に、Compilation は言語固有の派生物を持つ抽象クラスです。 コンパイルのイ ンスタンスを作成するとき、Microsoft.CodeAnalysis.CSharp.CSharpCompilation (または Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation) クラスでファクトリ メソッドを呼び出す必要があります。
シンボルにクエリを実行する
このチュートリアルでは、"Hello World" プログラムをもう一度見てみます。 今回、プログラムの中のシンボルにクエリを実行し、そ のシンボルが表す型を理解します。 名前空間の型について問い、型で利用できるメソッドを確認します。
このサンプルの完成したコードは、GitHub のリポジトリで確認できます。
    NOTE
構文ツリー型では継承を使用して、プログラムのさまざまな場所で有効なさまざまな構文要素を記述します。 これらの API を使用すること は、多くの場合、特定の派生型にプロパティまたはコレクション メンバーをキャストすることを意味します。 次の例では、割り当てとキャストは 別のステートメントであり、明示的に型指定された変数を使用します。 コードを読み取り、API の戻り値の型と返されるオブジェクトのランタ イム型を確認することができます。 実際には、暗黙的に型指定された変数を使用して、API 名に依存して、調べられるオブジェクトの型を 記述するのがより一般的です。
 次のようにして、新しい C# の Stand-Alone Code Analysis Tool プロジェクトを作成します。
Visual Studio で、 [ファイル] > [新規] > [プロジェクト] の順に選択して、[新しいプロジェクト] ダイアログを表示します。 [Visual C#] > [機能拡張] で、 [Stand-Alone Code Analysis Tool] を選択します。
プロジェクトに "SemanticQuickStart" という名前を付け、[OK] をクリックします。
前述の基本的な"HelloWorld!"プログラムを分析します。HelloWorldプログラムのテキストを Program クラスの定数とし て追加します。
             const string programText =
@"using System;
using System.Collections.Generic;
using System.Text;
namespace HelloWorld
{
    class Program
    {
} }";
static void Main(string[] args)
{
    Console.WriteLine(""Hello, World!"");
}
  次に、以下のコードを追加して、 programText 定数のコード テキストの構文ツリーをビルドします。 次の行を Main メソッドに 追加します。
    SyntaxTree tree = CSharpSyntaxTree.ParseText(programText);
CompilationUnitSyntax root = tree.GetCompilationUnitRoot();
 次に、作成済みのツリーから CSharpCompilation をビルドします。 "Hello World" サンプルは、String 型と Console 型に基

                   づきます。コンパイルでこの2つの型を宣言するアセンブリを参照する必要があります。 Main メソッドに次の行を追加し、適切 なアセンブリの参照を含む、構文ツリーのコンパイルを作成します。
CSharpCompilation.AddReferences メソッドはコンパイルに参照を追加します。 MetadataReference.CreateFromFile メ ソッドは参照としてアセンブリを読み込みます。
セマンティック モデルにクエリを実行する
Compilation が与えられたら、その Compilation に含まれている SyntaxTree について SemanticModel を求めることができ ます。 セマンティック モデルは、通常は IntelliSense から得られるすべての情報源としてとらえることができます。 SemanticModel は "この場所のスコープ内にはどのような名前があるか"、"このメソッドからアクセスできるメンバーはどれか"、 "このテキストのブロックではどのような変数が使用されているか"、"この名前/式は何を参照しているか" のような質問に答えるこ とができます。 このステートメントを追加し、セマンティック モデルを作成します。
名前をバインドする
Compilation は SyntaxTree から SemanticModel を作成します。 モデルを作成したら、それにクエリを実行し、最初の using ディレクティブを見つけ、 System 名前空間のシンボル情報を取得できます。 この 2 つの行を Main メソッドに追加
し、セマンティック モデルを作成し、最初の using ステートメントのシンボルを取得します。
先のコードは、最初の using ディレクティブの名前をバインドして、 System 名前空間の Microsoft.CodeAnalysis.SymbolInfo を取得する方法を示しています。 先のコードでは、構文モデルを利用してコードの構 造を見つけることも確認できます。セマンティック モデルを使用し、その意味を理解します。 構文モデルは、using ステートメン トの文字列 System を見つけます。 セマンティック モデルには、 System 名前空間に定義されている型に関するすべての情 報があります。
SymbolInfo オブジェクトから、SymbolInfo.Symbol プロパティを利用して Microsoft.CodeAnalysis.ISymbol を取得できま す。 このプロパティは、この式が参照するシンボルを返します。 何も参照しない式の場合 (数値リテラルなど)、このプロパティは
null です。SymbolInfo.Symbolがnullではないとき、ISymbol.Kindはシンボルの型を示します。この例で は、ISymbol.KindプロパティはSymbolKind.Namespaceです。次のコードを Main メソッドに追加します。 System 名前 空間のシンボルを取得し、 System 名前空間で宣言されているすべての子名前空間を表示します。
    var compilation = CSharpCompilation.Create("HelloWorld")
    .AddReferences(MetadataReference.CreateFromFile(
        typeof(string).Assembly.Location))
    .AddSyntaxTrees(tree);
   SemanticModel model = compilation.GetSemanticModel(tree);
      // Use the syntax tree to find "using System;"
UsingDirectiveSyntax usingSystem = root.Usings[0];
NameSyntax systemName = usingSystem.Name;
// Use the semantic model for symbol information:
SymbolInfo nameInfo = model.GetSymbolInfo(systemName);
          var systemSymbol = (INamespaceSymbol)nameInfo.Symbol;
foreach (INamespaceSymbol ns in systemSymbol.GetNamespaceMembers())
{
    Console.WriteLine(ns);
}
 プログラムを実行します。次の出力が表示されるはずです。

           NOTE
この出力には、 System 名前空間の子名前空間の一部が含まれていません。 このコンパイルに存在し、 System.String が宣言されて いるアセンブリのみを参照するすべての名前空間が表示されます。 他のアセンブリで宣言されている名前空間は、このコンパイルでは認識さ れません。
   式をバインドする
先のコードでは、名前にバインドしてシンボルを見つける方法を確認できます。 C# プログラムには、バウンドできて名前ではな い式が他にあります。 この機能を見るために、単純な文字列リテラルのバインドにアクセスしましょう。
"Hello World" プログラムに Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax が含まれ、"Hello, World!" 文字列がコンソールに表示されます。
プログラムの中で 1 つの文字列リテラルを見つけることで、 "Hello, World!" 文字列が見つかります。 構文ノードが見つかった ら、セマンティックモデルからそのノードの型情報を取得します。次のコードを Main メソッドに追加します。
Microsoft.CodeAnalysis.TypeInfo 構造体には TypeInfo.Type プロパティが含まれます。このプロパティによって、リテラルの型 に関するセマンティック情報にアクセスできます。 この例では、 string 型です。 このプロパティをローカル変数に割り当てる宣言 を追加します。
このチュートリアルの終わりとして、 string を返す string 型で宣言されているすべてのパブリック メソッドのシーケンスを作成 する LINQ クエリをビルドしましょう。 このクエリは複雑になります。そのため、1 行ずつビルドしてから 1 つのクエリとして再構築し ます。 このクエリのソースは、 string 型で宣言されているすべてのメンバーのシーケンスです。
そのソース シーケンスには、プロパティやフィールドなど、すべてのメンバーが含まれています。そのた め、ImmutableArray<T>.OfType メソッドでフィルター処理し、Microsoft.CodeAnalysis.IMethodSymbol オブジェクトであ る要素を見つけます。
    // Use the syntax model to find the literal string:
LiteralExpressionSyntax helloWorldString = root.DescendantNodes()
    .OfType<LiteralExpressionSyntax>()
    .Single();
// Use the semantic model for type information:
TypeInfo literalInfo = model.GetTypeInfo(helloWorldString);
    var stringTypeSymbol = (INamedTypeSymbol)literalInfo.Type;
      var allMembers = stringTypeSymbol.GetMembers();
    System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
 
   次に、パブリック メソッドのみを返す別のフィルターを追加し、 string を返します。
    var publicStringReturningMethods = methods
    .Where(m => m.ReturnType.Equals(stringTypeSymbol) &&
    m.DeclaredAccessibility == Accessibility.Public);
 名前プロパティのみを選択します。オーバーロードを削除し、別個の名前のみを選択します。
LINQ クエリ構文で完全クエリをビルドし、コンソールにすべてのメソッド名を表示することもできます。
  var distinctMethods = publicStringReturningMethods.Select(m => m.Name).Distinct();
     foreach (string name in (from method in stringTypeSymbol
                         .GetMembers().OfType<IMethodSymbol>()
                         where method.ReturnType.Equals(stringTypeSymbol) &&
                         method.DeclaredAccessibility == Accessibility.Public
                         select method.Name).Distinct())
{
    Console.WriteLine(name);
}
 プログラムをビルドして実行します。 次の出力が表示されます。
    Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
 セマンティック API を使用し、このプログラムの含まれるシンボルに関する情報を見つけ、表示しました。
 var methods = allMembers.OfType<IMethodSymbol>();
 
     このチュートリアルは、「構文解析の概要」および「セマンティック解析の概要」クイック スタートで説明した概念と手法に基づいて 作成されています。 これらのクイック スタートをまだ完了していない場合は、このクイック スタートを始める前に完了する必要があ ります。
このクイック スタートでは、構文ツリーを作成および変換する手法を学習します。 前のクイック スタートで学習した手法と組み合 わせて、初めてのコマンド ライン リファクタリングを作成します。
インストール手順 - Visual Studio インストーラー
Visual Studio インストーラーで .NET Compiler Platform SDK を見つけるには、以下の 2 つの異なる方法がありま
す。
Visual Studio インストーラーを使用したインストール - ワークロード ビュー
.NET Compiler Platform SDK は、Visual Studio 拡張機能の開発ワークロードの一部として自動的に選択されません。 省 略可能なコンポーネントとして選択する必要があります。
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. Visual Studio 拡張機能の開発ワークロードを確認します。
4. 概要ツリーの [Visual Studio 拡張機能の開発] ノードを開きます。
5. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 省略可能なコンポーネントの最後に表示されま
す。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. 概要ツリーの [個別のコンポーネント] ノードを開きます。 2. [DGML エディター] のチェック ボックスをオンにします。
Visual Studio インストーラーを使用したインストール - [個別のコンポーネント] タブ
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. [個別のコンポーネント] タブを選択します。
4. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 [コンパイラ、ビルド ツール、およびランタイム] セ
クションの上部に表示されます。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. [DGML エディター] チェック ボックスをオンにします。 [コード ツール] セクションに表示されます。
不変性と .NET コンパイラ プラットフォーム
不変性 は、.NET コンパイラ プラットフォームの基本原則です。 不変データ構造は、作成後には変更できません。 不変データ 構造は、複数のコンシューマーから安全かつ同時に共有、分析できます。 コンシューマーが、予期できない方法で別のコン シューマーに影響を及ぼす危険はありません。 アナライザーには、ロックやその他のコンカレンシー手段は不要です。 この規則 は、構文ツリー、コンパイル、記号、セマンティック モデルなど、出現するすべてのデータ構造に当てはまります。 既存の構造体 を変更するのではなく、API は古いオブジェクトに対して指定された相違点に基づいて、新しいオブジェクトを作成します。 この 概念を構文ツリーに適用して、変換を使用して新しいツリーを作成します。
構文変換の概要
2021/03/06 • • Edit Online
 
                ツリーの作成と変換
構文の変換では、2 つの方法のうち 1 つを選択します。 ファクトリ メソッド は、置き換える特定のノードや、新しいコードを挿 入する特定の場所を検索するときに最もよく使用されます。 リライター は、プロジェクト全体をスキャンして、置き換えるコード パターンを探す場合に最適です。
ファクトリ メソッドを使用してノードを作成する
最初の構文変換では、ファクトリ メソッドを使用します。 using System.Collections; ステートメントを using System.Collections.Generic; ステートメントで置き換えます。 この例
は、Microsoft.CodeAnalysis.CSharp.SyntaxFactory ファクトリ メソッドを使用して Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode オブジェクトを作成する方法を示しています。 ノード、トークン、トリ ビア の各種類に対して、その種類のインスタンスを作成するファクトリ メソッドが用意されています。 ボトムアップ方式でノードを 階層的に構成して、構文ツリーを作成します。 次に、既存のプログラムを変換して、既存のノードを作成した新しいツリーで置 き換えます。
Visual Studio を起動し、新しい C# の Stand-Alone Code Analysis Tool プロジェクトを作成します。 Visual Studio で、 [ファイル] > [新規] > [プロジェクト] の順に選択して、[新しいプロジェクト] ダイアログを表示します。 [Visual C#] > [機能拡張] で、 [Stand-Alone Code Analysis Tool] を選択します。 このクイック スタートには 2 つのサンプル プロジェク トがあるため、ソリューションに「SyntaxTransformationQuickStart」、プロジェクトに「ConstructionCS」という名前を付 けます。 [OK] をクリックします。
このプロジェクトでは、Microsoft.CodeAnalysis.CSharp.SyntaxFactory クラスのメソッドを使用して、 System.Collections.Generic 名前空間を表すMicrosoft.CodeAnalysis.CSharp.Syntax.NameSyntaxを構築します。
Program.cs の先頭に、次のusingディレクティブを追加します。
using System.Collections.Generic; ステートメントを表すツリーをビルドするための 名前構文ノード を作成します。 NameSyntax は、C# に現れる 4 つの型の基底クラスです。 これらの 4 つの型の名前を組み合わせて、C# 言語中に出現す るすべての名前を作成できます。
Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax: System や Microsoft のような、単一のシンプルな名前を表 します。
Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax: List<int> のような、ジェネリック型またはジェネリック メソッドの名前を表します。
Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax: System.IO のような、 <left-name>.<right-identifier-or-generic-name> 形式の修飾名を表します。
Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax: LibraryV2::Foo のような、アセンブリ外部エイ リアスを使用した名前を表します。
IdentifierName(String)メソッドを使用して、NameSyntaxノードを作成します。 Program.cs で、Main メソッドに次のコー ドを追加します。
上のコードでは、IdentifierNameSyntaxオブジェクトを作成して変数 name に割り当てます。RoslynAPIの多くは、関連の 型を使用しやすくするために基底クラスを返します。NameSyntaxである変数 name は、QualifiedNameSyntaxをビルドす るときに再利用できます。 サンプルをビルドするときに、型の推定を使用しないでください。 このプロジェクトではそのステップを自 動化します。
        using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static System.Console;
             NameSyntax name = IdentifierName("System");
WriteLine($"\tCreated the identifier {name}");
 これで名前が作成されました。 次に、QualifiedNameSyntax をビルドして、ツリー内にさらに多くのノードをビルドします。 新し

        いツリーでは、name を名前の左側として使用し、   名前空間の新しいIdentifierNameSyntaxを QualifiedNameSyntax の右側として使用します。   に次のコードを追加します。
コードを再度実行し、結果を確認します。 コードを表すノードのツリーをビルドします。 このパターンを繰り返して、名前空間 System.Collections.Generic のQualifiedNameSyntaxをビルドします。 Program.cs に次のコードを追加します。
プログラムを再度実行して、追加するコード用のツリーがビルドされたことを確認します。 変更されたツリーを作成する
これで、1 つのステートメントを含む小さな構文ツリーがビルドされました。 新しいノードを作成するための API は、単一のステー トメントや他の小規模なコード ブロックを作成するときに適した選択肢です。 しかし、より大規模なコード ブロックをビルドすると きは、ノードを置き換えたり既存のツリーにノードを挿入するためのメソッドを使用する必要があります。 すでに説明したように、 構文ツリーは不変です。 構文 API には、作成後に既存の構文ツリーを変更するメカニズムはありません。 その代わり、既存の ツリーへの変更に基づいて新しいツリーを生成するメソッドが用意されています。 With* メソッドは、SyntaxNodeから派生した 具象クラス内、または SyntaxNodeExtensions クラスで宣言された拡張メソッド内で定義されます。 これらのメソッドは、既存 のノードの子プロパティに変更を適用することで新しいノードを作成します。 さらに、ReplaceNode 拡張メソッドを使用すると、 サブツリー内の子孫ノードを置き換えることができます。 このメソッドも、新しく作成された子ノードをポイントするように親を更新 し、このプロセスをツリー全体で上位に向かって繰り返します (このプロセスを、ツリーの "再スピン" と呼びます)。
次のステップでは、(小規模な)プログラム全体を表すツリーを作成した後で、それを変更します。 Program クラスの先頭に次の コードを追加します。
Collections
  program.cs
     name = QualifiedName(name, IdentifierName("Collections"));
WriteLine(name.ToString());
       name = QualifiedName(name, IdentifierName("Generic"));
WriteLine(name.ToString());
              private const string sampleCode =
@"using System;
using System.Collections;
using System.Linq;
using System.Text;
namespace HelloWorld
{
    class Program
    {
} }";
static void Main(string[] args)
{
    Console.WriteLine(""Hello, World!"");
}
     NOTE
このコード例では、 System.Collections.Generic 名前空間ではなく System.Collections 名前空間を使用します。
   次に、 Main メソッドの末尾に、テキストを解析してツリーを作成する次のコードを追加します。
    SyntaxTree tree = CSharpSyntaxTree.ParseText(sampleCode);
var root = (CompilationUnitSyntax)tree.GetRoot();
 
                この例では、WithName(NameSyntax) メソッドを使用して、UsingDirectiveSyntax ノード内の名前を先ほどのコードで作成 した名前に置き換えます。
名前 System.Collections を先ほどのコードで作成した名前に置き換えるには、WithName(NameSyntax)メソッドを使用 して新しいUsingDirectiveSyntaxノードを作成します。 Main メソッドの末尾に次のコードを追加します。
プログラムを実行し、出力を注意深く見てください。ルートツリーに newUsing が配置されていません。元のツリーは変更され ていません。
新しいツリーを作成するために、ReplaceNode 拡張メソッドを使用した次のコードを追加します。 新しいツリーが、既存のイン ポートを更新された newUsing ノードで置き換えた結果として作成されます。この新しいツリーを既存の root に割り当てま す。
再びプログラムを実行します。今度は、ツリーに System.Collections.Generic 名前空間が正しくインポートされます。 SyntaxRewriters を使用してツリーを変換する
With* メソッドとReplaceNodeメソッドは、構文ツリーの個々のブランチを変換するのに便利な手段です。 Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter クラスは、構文ツリー上で複数の変換を実行します。 Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter クラスは Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> のサブクラスです。 CSharpSyntaxRewriter は、特定 の型の SyntaxNode に変換を適用します。 構文ツリー内にその型が存在すれば、複数の型の SyntaxNode オブジェクトに変 換を適用できます。 このクイック スタートの 2 番目のプロジェクトでは、型の推定が使用される可能性があるすべての場所の ローカル変数宣言に含まれる明示的な型を削除する、コマンド ライン リファクタリングを作成します。
新しい C# の Stand-Alone Code Analysis Tool プロジェクトを作成します。 Visual Studio で、 SyntaxTransformationQuickStart ソリューションノードを右クリックします。[追加]>[新しいプロジェクト]を選択して、[新 しいプロジェクト] ダイアログ を表示します。 [Visual C#] > [機能拡張] で、 [Stand-Alone Code Analysis Tool] を
選択します。 プロジェクトに「 TransformationCS 」という名前を付けて、[OK] をクリックします。
最初のステップは、変換を実行するための CSharpSyntaxRewriter から派生したクラスを作成することです。 新しいクラスのファ イルをプロジェクトに追加します。 Visual Studio で、 [プロジェクト] > [クラスの追加...] を選択します。 [新しい項目の追 加] ダイアログで、ファイル名として「 TypeInferenceRewriter.cs 」を入力します。
TypeInferenceRewriter.cs ファイルに次のusingディレクティブを追加します。
次に、TypeInferenceRewriter クラスでCSharpSyntaxRewriterクラスを拡張します。
次のコードを追加して、SemanticModel を保持する読み取り専用の private フィールドを宣言し、コンストラクター内で初期 化します。 このフィールドは、後で型の推定を使用できる場所を特定するために必要になります。
     var oldUsing = root.Usings[1];
var newUsing = oldUsing.WithName(name);
WriteLine(root.ToString());
       root = root.ReplaceNode(oldUsing, newUsing);
WriteLine(root.ToString());
           using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
    public class TypeInferenceRewriter : CSharpSyntaxRewriter
 
        VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax) メソッドをオーバーライドします。
    public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{
}
     NOTE
Roslyn API の多くは、返される実際の ランタイム型の基底クラスである戻り値の型を宣言します。 多くのシナリオでは、ノードが別の種類の ノードに完全に置き換えられることがあり、削除される場合もあります。 この例で は、VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax) メソッドは LocalDeclarationStatementSyntax の派生型 ではなく SyntaxNode を返します。 このリライターは、既存のノードに基づいて新しい LocalDeclarationStatementSyntax ノードを返しま す。
  このクイックスタートでは、ローカル変数宣言を処理します。これは foreach ループ、for ループ、LINQ式、ラムダ式などの 他の宣言にも拡張できます。 さらに、このリライターは、次のような最も単純な形式の宣言しか変換しません。
自分で探究したい場合は、次のような変数宣言の型の完成したサンプルを拡張することを検討してください。
次のコードを VisitLocalDeclarationStatement メソッドの本体に追加して、これらの形式の宣言の書き換えをスキップするよ うにします。
  Type variable = expression;
     // Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
      if (node.Declaration.Variables.Count > 1)
{
    return node;
}
if (node.Declaration.Variables[0].Initializer == null)
{
    return node;
}
 このメソッドは、 node パラメーターを変更せずに返すことにより、書き換えが行われないことを示します。 いずれの if 式も true でない場合、ノードは初期化で可能な宣言を表します。 以下のステートメントを追加して、宣言で指定されている型の 名前を抽出し、それを SemanticModel フィールドを使用してバインドして、型のシンボルを取得できるようにします。
   private readonly SemanticModel SemanticModel;
public TypeInferenceRewriter(SemanticModel semanticModel) => SemanticModel = semanticModel;
 
      さらに、次のステートメントを追加して、初期化子式をバインドします。
最後に、次の if ステートメントを追加して、初期化子式の型が指定の型と一致した場合に既存の型名を var キーワード で置き換えるようにします。
  var initializerInfo = SemanticModel.GetTypeInfo(declarator.Initializer.Value);
     if (SymbolEqualityComparer.Default.Equals(variableType, initializerInfo.Type))
{
    TypeSyntax varTypeName = SyntaxFactory.IdentifierName("var")
        .WithLeadingTrivia(variableTypeName.GetLeadingTrivia())
        .WithTrailingTrivia(variableTypeName.GetTrailingTrivia());
    return node.ReplaceNode(variableTypeName, varTypeName);
}
else {
    return node;
}
 宣言では初期化子式が基底クラスまたはインターフェイスにキャストされる場合があるので、この条件が必要です。 必要な場合 は、割り当ての左側の型と右側の型が一致しません。 このようなケースで明示的な型を削除すると、プログラムのセマンティクス が変わってしまいます。 var はコンテキスト キーワードであるため、 var はキーワードではなく識別子として指定されます。 垂 直方向の空白とインデントを維持するために、先頭および末尾のトリビア(空白)が古い型名から var キーワードへと転送され ています。 型名は実際には宣言ステートメントの孫であるため、 With* よりも ReplaceNode を使用して LocalDeclarationStatementSyntax を変換するほうが簡単です。
これで TypeInferenceRewriter が完成しました。 Program.cs ファイルに戻って例を完成させましょう。テスト用の Compilation を作成し、そこから SemanticModel を取得します。 その SemanticModel を使用して、
TypeInferenceRewriter を試します。このステップは最後に実行します。それまでの間、テスト用のコンパイルを表すプレース ホルダー変数を宣言しておきます。
しばらくすると、CreateTestCompilation メソッドが存在しないことを通知するエラーの波線が表示されます。Ctrl+.キーを 押して電球を開き、Enterキーを押して[メソッドスタブの生成]コマンドを呼び出します。このコマンドにより、Program クラス 内に CreateTestCompilation メソッドのメソッドスタブが生成されます。このメソッドについては後で説明します。
      Compilation test = CreateTestCompilation();
       var declarator = node.Declaration.Variables.First();
var variableTypeName = node.Declaration.Type;
var variableType = (ITypeSymbol)SemanticModel
    .GetSymbolInfo(variableTypeName)
    .Symbol;
 
      テスト用の Compilation 内の各 SyntaxTree を反復処理する次のコードを記述します。 処理ごとに、そのツリーの SemanticModelを持った新しい TypeInferenceRewriter が初期化されます。
     foreach (SyntaxTree sourceTree in test.SyntaxTrees)
{
    SemanticModel model = test.GetSemanticModel(sourceTree);
    TypeInferenceRewriter rewriter = new TypeInferenceRewriter(model);
    SyntaxNode newSource = rewriter.Visit(sourceTree.GetRoot());
    if (newSource != sourceTree.GetRoot())
    {
        File.WriteAllText(sourceTree.FilePath, newSource.ToFullString());
    }
}
  作成した foreach ステートメント内に次のコードを追加して、各ソースツリーで変換が実行されるようにします。このコードは、 何らかの編集が行われた場合に、変換された新しいツリーを条件付きで書き出します。 リライターは、型の推定を使用して単 純化される可能性があるローカル変数宣言が 1 つ以上見つかった場合にのみ、ツリーを変更します。
File.WriteAllText コードの下に波線が表示されるはずです。 電球を選択し、必要な using System.IO; ステートメントを 追加します。
完了までもう少しです。 最後の 1 ステップは、Compilation の作成です。 このクイック スタートでは型の推定を一度も使用し ていないので、テスト ケースとするには完璧です。 残念ながら、C# プロジェクト ファイルからコンパイルを作成する方法について は、このチュートリアルの対象外です。 しかし幸いなことに、これまでの手順に慎重に従ってきたならば希望が持てます。
CreateTestCompilation メソッドの内容を次のコードに置き換えます。このクイックスタートで説明したプロジェクトに偶然にも 一致するテスト用コンパイルが作成されます。
    SyntaxNode newSource = rewriter.Visit(sourceTree.GetRoot());
if (newSource != sourceTree.GetRoot())
{
    File.WriteAllText(sourceTree.FilePath, newSource.ToFullString());
}
    
  幸運を祈ってプロジェクトを実行しましょう。 Visual Studio で、 [デバッグ] > [デバッグの開始] を選択します。 Visual Studio で、プロジェクト内のファイルが変更されたという通知が表示されるはずです。 [すべてに適用] をクリックして、変更されたファイ ルをリロードします。 それらを調べて成果を確認しましょう。 明示的で冗長な型指定子がすべてなくなるとどれほどコードがすっ きり見えるかに注目してください。
おめでとうございます! コンパイラ API を使用して、C# プロジェクト内のすべてのファイルで特定の構文パターンを検索し、それら のパターンに一致するソース コードのセマンティクスを分析して変換する独自のリファクタリングを作成できました。 これであなたも 正式なリファクタリングの作成者です!
   String programPath = @"..\..\..\Program.cs";
String programText = File.ReadAllText(programPath);
SyntaxTree programTree =
               CSharpSyntaxTree.ParseText(programText)
                               .WithFilePath(programPath);
String rewriterPath = @"..\..\..\TypeInferenceRewriter.cs";
String rewriterText = File.ReadAllText(rewriterPath);
SyntaxTree rewriterTree =
               CSharpSyntaxTree.ParseText(rewriterText)
                               .WithFilePath(rewriterPath);
SyntaxTree[] sourceTrees = { programTree, rewriterTree };
MetadataReference mscorlib =
        MetadataReference.CreateFromFile(typeof(object).Assembly.Location);
MetadataReference codeAnalysis =
        MetadataReference.CreateFromFile(typeof(SyntaxTree).Assembly.Location);
MetadataReference csharpCodeAnalysis =
        MetadataReference.CreateFromFile(typeof(CSharpSyntaxTree).Assembly.Location);
MetadataReference[] references = { mscorlib, codeAnalysis, csharpCodeAnalysis };
return CSharpCompilation.Create("TransformationCS",
    sourceTrees,
    references,
    new CSharpCompilationOptions(OutputKind.ConsoleApplication));
 
    .NET Compiler Platform SDK には、C# または Visual Basic コードをターゲットとするカスタム警告を作成するために必要な ツールが用意されています。 アナライザー には、規則違反を認識するコードが含まれています。 コード修正 には、違反を修 正するコードが含まれています。 実装する規則には、コード構造から、コーディング スタイル、名前付け規則などがあります。 .NET Compiler Platform には、開発者がコードを作成するときに分析を実行するためのフレームワークと、コードを修正するた めのすべての Visual Studio UI 機能が用意されています。具体的には、エディターに波線を表示する、Visual Studio のエラー 一覧を表示する、"電球" の提案を作成する、推奨される修正の豊富なプレビューを表示するなどの機能です。
このチュートリアルでは、Roslyn API を使用して アナライザー とそれに付随する コード修正 の作成について説明します。 アナ ライザーは、ソース コードの分析を実行し、問題をユーザーに報告する方法の 1 つです。 必要に応じて、アナライザーは、ユー ザーのソース コードに対する変更を表すコード修正を提供することもできます。 このチュートリアルでは、 const 修飾子を使用 して宣言できますが、実際は宣言されていないローカル変数宣言を検出するアナライザーを作成します。 付随するコード修正 は、それらの宣言を修正して const 修飾子を追加します。
必須コンポーネント
Visual Studio 2019 バージョン 16.7 以降
Visual Studio インストーラーで .NET Compiler Platform SDK をインストールする必要があります。 インストール手順 - Visual Studio インストーラー
Visual Studio インストーラーで .NET Compiler Platform SDK を見つけるには、以下の 2 つの異なる方法がありま す。
Visual Studio インストーラーを使用したインストール - ワークロード ビュー
.NET Compiler Platform SDK は、Visual Studio 拡張機能の開発ワークロードの一部として自動的に選択されません。 省
略可能なコンポーネントとして選択する必要があります。
1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. Visual Studio 拡張機能の開発ワークロードを確認します。
4. 概要ツリーの [Visual Studio 拡張機能の開発] ノードを開きます。
5. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 省略可能なコンポーネントの最後に表示されま
す。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. 概要ツリーの [個別のコンポーネント] ノードを開きます。 2. [DGML エディター] のチェック ボックスをオンにします。
Visual Studio インストーラーを使用したインストール - [個別のコンポーネント] タブ 1. Visual Studio インストーラーを実行します。
2. [変更] を選択します。
3. [個別のコンポーネント] タブを選択します。
4. [.NET Compiler Platform SDK] のチェック ボックスをオンにします。 [コンパイラ、ビルド ツール、およびランタイム] セ
チュートリアル: 最初のアナライザーとコード修
正を作成する
2020/11/02 • • Edit Online
 
 クションの上部に表示されます。
また、必要に応じて、DGML エディターのビジュアライザーでグラフを表示します。
1. [DGML エディター] チェック ボックスをオンにします。 [コード ツール] セクションに表示されます。 アナライザーの作成と検証にはいくつかの手順があります。
1. ソリューションを作成します。
2. アナライザーの名前と説明を登録します。
3. アナライザーの警告と推奨事項を報告します。 4. 推奨事項を受け取るコード修正を実装します。 5. 単体テストで分析を改善します。
アナライザー テンプレートを調べる アナライザーは、ローカル定数に変換できるローカル変数宣言をユーザーに報告します。 次に例を示します。
上記のコードでは、 x には定数値が割り当てられており、変更されることはありません。 これは const 修飾子を使用して宣 言できます。
変数を定数にすることができるかどうかを判断するために、構文解析、初期化子式の定数分析、および変数に書き込まれな いというデータフロー分析が必要です。 .NET Compiler Platform には、この分析を簡単に実行できる API が用意されていま す。 最初の手順は、新しい C# の コード修正を含むアナライザー プロジェクトを作成することです。
Visual Studio で、 [ファイル] > [新規] > [プロジェクト] の順に選択して、[新しいプロジェクト] ダイアログを表示します。 [Visual C#] > [Extensibility] で、 [Analyzer with code fix (.NET Standard)](コード修正付きアナライザー (.NET Standard)) を選択します。
プロジェクトに「 MakeConst 」という名前を付けて、[OK] をクリックします。
コード修正テンプレート付きアナライザー テンプレートを使用すると、アナライザーとコード修正を含むプロジェクト、単体テスト プ ロジェクト、VSIX プロジェクトという 3 つのプロジェクトが作成されます。 既定のスタートアップ プロジェクトは VSIX プロジェクトで す。 F5 キーを押して、VSIX プロジェクトを開始します。 これにより、新しいアナライザーが読み込まれた Visual Studio の 2 つ 目のインスタンスが開始されます。
開始した 2 つ目の Visual Studio インスタンスで、新しい C# コンソール アプリケーション プロジェクトを作成します (.NET Core または .NET Framework プロジェクトが動作し、アナライザーはソース レベルで動作します)。波線の下線が表示されているトー クンにマウス カーソルを移動すると、アナライザーに設定されている警告テキストが表示されます。
テンプレートを使用すると、次の図のように、型名が小文字の個々の型宣言に対して警告を報告するアナライザーが作成され ます。
    int x = 0;
Console.WriteLine(x);
     const int x = 0;
Console.WriteLine(x);
     TIP
アナライザーを実行するときは、Visual Studio の 2 つ目のコピーを開始します。 この 2 つ目のコピーは、別のレジストリ ハイブを使用して設 定を保存します。 これにより、Visual Studio の 2 つのコピーのビジュアル設定を区別することができます。 Visual Studio の実験的な実行 のために、別のテーマを選択することができます。 また、設定のローミングや、Visual Studio アカウントへのログインには、Visual Studio の実 験的な実行が使用されません。 そのため、設定を分けておくことができます。
 
    また、テンプレートには、小文字を含むすべての型名をすべて大文字に変更するコード修正も用意されています。 警告が表示 された電球をクリックすると、推奨される変更が表示されます。 推奨される変更を受け入れると、型の名前と、ソリューション内の その型に対するすべての参照が更新されます。 最初のアナライザーの動作を確認したら、2 つ目の Visual Studio インスタンス を閉じ、アナライザー プロジェクトに戻ります。
アナライザーのすべての変更をテストするために、Visual Studio の 2 つ目のコピーを開始して、新しいコードを作成する必要は ありません。 このテンプレートを使用すると、単体テスト プロジェクトも自動的に作成されます。 このプロジェクトには 2 つのテスト が含まれています。 TestMethod1 では、診断をトリガーせずにコードを分析するテストの一般的な形式が表示されます。
TestMethod2 では、診断をトリガーするテストの形式が表示され、推奨されたコード修正が適用されます。アナライザーとコー ド修正をビルドするときに、異なるコード構造のテストを作成して作業を検証します。 アナライザーの単体テストは、Visual Studio を使用して対話的にテストするよりもはるかに簡単です。
アナライザーの登録を作成する このテンプレートを使用すると、MakeConstAnalyzer.csファイルに初期の DiagnosticAnalyzer クラスが作成されます。こ
の初期のアナライザーは、あらゆるアナライザーが持つ 2 つの重要な特性を示しています。 すべての診断アナライザーは、動作する言語を記述する [DiagnosticAnalyzer] 属性を提供する必要があります。
すべての診断アナライザーは、DiagnosticAnalyzer クラスから派生する必要があります。
このテンプレートは、アナライザーの一部である基本機能も示しています。
1. アクションを登録します。 アクションは、アナライザーをトリガーしてコード違反を調べるコードの変更を表します。 Visual Studio で、登録済みのアクションと一致するコード編集が検出されると、アナライザーの登録済みメソッドが呼び出されま す。
2. 診断を作成します。 アナライザーで違反を検出されると、違反をユーザーに通知するために Visual Studio で使用される診 断オブジェクトが作成されます。
DiagnosticAnalyzer.Initialize(AnalysisContext) メソッドのオーバーライドでアクションを登録します。 このチュートリアルでは、 構文ノード にアクセスしてローカル宣言を探し、定数値を持つものを調べます。 宣言が定数であれば、アナライザーによって診 断が作成され、報告されます。
最初の手順は、登録定数が"MakeConst"アナライザーを示すように、登録定数と Initialize メソッドを更新することで す。 ほとんどの文字列定数は、文字列リソース ファイルで定義されています。 ローカリゼーションを容易にするには、この手法に 従うことをお勧めします。 MakeConst アナライザー プロジェクト用に Resources.resx ファイルを開きます。 これでリソース エ ディターが表示されます。 文字列リソースを次のように更新します。
を "変数を定数に変更できる" に変更します。 を "定数に変更できる" に変更します。
      TIP
アナライザーの単体テストは、アナライザーをトリガーするべきコード構造とトリガーするべきではないコード構造を知りたいときに最適なツール です。 Visual Studio のもう 1 つのコピーにアナライザーを読み込むことは、まだ検討していない可能性のあるコンストラクトを探索して見つけ るために最適なツールです。
      AnalyzerTitle
   AnalyzerMessageFormat
 
    を "定数にする" に変更します。
また、[アクセス修飾子]ドロップダウンを public に変更します。こうすることで、単体テストでこれらの定数を簡単に使用で
きるようになります。 完了すると、次の図のようにリソース エディターが表示されます。
残りの変更はアナライザー ファイル内にあります。 Visual Studio で MakeConstAnalyzer.cs を開きます。 登録済みアク ションを、シンボル対して動作するものから構文に対して動作するものに変更します。
MakeConstAnalyzerAnalyzer.Initialize メソッドで、シンボルにアクションを登録する行を見つけます。
これを次の行で置き換えます。
この変更後は、AnalyzeSymbol メソッドを削除できます。このアナライザーでは、SymbolKind.NamedTypeステートメントで はなくSyntaxKind.LocalDeclarationStatementステートメントが検査されます。 AnalyzeNode に赤い波線が表示されてい ることに注意してください。追加したコードは、宣言されていない AnalyzeNode メソッドを参照しています。次のコードを使用 してそのメソッドを宣言します。
次のコードに示すように、MakeConstAnalyzer.csの Category を"Usage"に変更します。
定数の可能性があるローカル宣言を見つける
次は AnalyzeNode メソッドの最初のバージョンを作成してみましょう。 次のコードのように、 const の可能性がありますが実際 はそうではない単一のローカル宣言を探します。
最初の手順は、ローカル宣言を見つけることです。MakeConstAnalyzer.csの AnalyzeNode に次のコードを追加します。
アナライザーにローカル宣言 (ローカル宣言のみ) の変更が登録されているため、このキャストは常に成功します。 他のノードの 種類では AnalyzeNode メソッドへの呼び出しがトリガーされません。 次に、 const 修飾子の宣言を確認します。 見つかった ら、すぐに戻ります。次のコードでは、ローカル宣言の const 修飾子を探します。
     context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
     context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze |
GeneratedCodeAnalysisFlags.None);
context.EnableConcurrentExecution();
context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.LocalDeclarationStatement);
        private void AnalyzeNode(SyntaxNodeAnalysisContext context)
{
}
    private const string Category = "Usage";
      int x = 0;
Console.WriteLine(x);
    var localDeclaration = (LocalDeclarationStatementSyntax)context.Node;
   AnalyzerDescription
 
         最後に、変数を const にすることができることを確認する必要があります。つまり、初期化後に決して割り当てられないことを 確認します。
SyntaxNodeAnalysisContextを使用していくつかのセマンティック解析を実行します。 context 引数を使用して、ローカル 変数の宣言を const にすることができるかどうかを判断します。Microsoft.CodeAnalysis.SemanticModelは、単一のソー ス ファイル内のすべてのセマンティック情報を表します。 詳細については、セマンティック モデルに関する記事を参照してください。 Microsoft.CodeAnalysis.SemanticModel を使用して、ローカル宣言ステートメントでデータ フロー分析を実行します。 次 に、このデータ フロー分析の結果を使用して、ローカル変数が他の場所の新しい値で上書きされないようにします。 変数の GetDeclaredSymbol 拡張メソッドを呼び出して変数の ILocalSymbol を取得し、データ フロー分析の DataFlowAnalysis.WrittenOutsideコレクションに含まれていないことを確認します。 AnalyzeNode メソッドの末尾に次の コードを追加します。
      // Perform data flow analysis on the local declaration.
var dataFlowAnalysis = context.SemanticModel.AnalyzeDataFlow(localDeclaration);
// Retrieve the local symbol for each variable in the local declaration
// and ensure that it is not written outside of the data flow analysis region.
var variable = localDeclaration.Declaration.Variables.Single();
var variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable);
if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))
{
return; }
 この追加したコードで、変数は変更されなくなります。そのため、 const にすることができます。 それでは診断を呼び出してみま しょう。 AnalyzeNode の最後の行に次のコードを追加します。
F5 キーを押してアナライザーを実行して、進行状況を確認できます。 以前に作成したコンソール アプリケーションを読み込み、 次のテスト コードを追加することができます。
電球が表示され、アナライザーから診断が報告されます。 ただし、電球には、テンプレートで生成されたコード修正が使用され ているので、大文字にすることができることがわかります。 次のセクションでは、コード修正の記述方法について説明します。
コード修正を記述する
アナライザーで、1 つまたは複数のコード修正が表示される可能性があります。 コード修正では、報告された問題を解決する
編集が定義されます。 作成したアナライザーに、const キーワードを挿入するコード修正を用意することができます。
   context.ReportDiagnostic(Diagnostic.Create(Rule, context.Node.GetLocation()));
     int x = 0;
Console.WriteLine(x);
     const int x = 0;
Console.WriteLine(x);
 エディターの電球の UI からユーザーが選択すると、Visual Studio によってコードが変更されます。
   // make sure the declaration isn't already const:
if (localDeclaration.Modifiers.Any(SyntaxKind.ConstKeyword))
{
return; }
 
      テンプレートによって追加された MakeConstCodeFixProvider.cs ファイルを開きます。 このコード修正は、診断アナライ ザーによって生成された診断 ID に既に関連付けられていますが、まだ適切なコード変換が実装されていません。 まず、テンプ レート コードの一部を削除する必要があります。 タイトルの文字列を "定数にする" に変更します。
次に MakeUppercaseAsync メソッドを削除しますこれで適用されなくなります。
すべてのコード修正プロバイダーは CodeFixProvider から派生します。 これらはすべて CodeFixProvider.RegisterCodeFixesAsync(CodeFixContext) をオーバーライドし、使用できるコード修正を報告します。
RegisterCodeFixesAsync で、診断に合わせて、次のように検索している先祖ノードの種類を LocalDeclarationStatementSyntax に変更します。
次に、最後の行を変更してコード修正を登録します。この修正で、既存の宣言に const 修飾子を追加した結果の新しいド キュメントが作成されます。
シンボル に追加したコードに、赤い波線が表示されている点に注目してください。 次のコードのように、 の宣言を追加します。
新しい MakeConstAsync メソッドによって、ユーザーのソースファイルを表すDocumentは、const 宣言を含む新しい Document に変換されます。
宣言ステートメントの前に挿入される新しい const キーワードトークンを作成します。先頭にtriviaがあれば、まず宣言ス テートメントの最初のトークンから削除し、それを const トークンにアタッチします。 MakeConstAsync メソッドに次のコードを追 加します。
  private const string title = "Make constant";
       var declaration = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType<LocalDeclarationStatementSyntax> ().First();
     // Register a code action that will invoke the fix.
context.RegisterCodeFix(
    CodeAction.Create(
        title: title,
        createChangedDocument: c => MakeConstAsync(context.Document, declaration, c),
        equivalenceKey: title),
    diagnostic);
  MakeConstAsync
 MakeConstAsync
    private async Task<Document> MakeConstAsync(Document document,
   LocalDeclarationStatementSyntax localDeclaration,
   CancellationToken cancellationToken)
{ }
       // Remove the leading trivia from the local declaration.
var firstToken = localDeclaration.GetFirstToken();
var leadingTrivia = firstToken.LeadingTrivia;
var trimmedLocal = localDeclaration.ReplaceToken(
    firstToken, firstToken.WithLeadingTrivia(SyntaxTriviaList.Empty));
// Create a const token with the leading trivia.
var constToken = SyntaxFactory.Token(leadingTrivia, SyntaxKind.ConstKeyword,
SyntaxFactory.TriviaList(SyntaxFactory.ElasticMarker));
 次に、以下のコードを使用して宣言に const トークンを追加します。

  次に、C# の書式設定規則に合わせて新しい宣言の書式を設定します。 既存のコードに合わせて変更の書式を設定する と、エクスペリエンスが向上します。 既存のコードの直後に次のステートメントを追加します。
このコード用に新しい名前空間が必要です。次の using ディレクティブをファイルの先頭に追加します。
最後の手順は編集です。 このプロセスには 3 つの手順があります。
1. 既存のドキュメントのハンドルを取得する。
2. 既存の宣言を新しい宣言で置き換えて、新しいドキュメントを作成する。 3. 新しいドキュメントを返す。
MakeConstAsync メソッドの末尾に次のコードを追加します。
コード修正を試す準備が整いました。 F5 キーを押して、Visual Studio の 2 つ目のインスタンスでアナライザー プロジェクトを実 行します。 2 つ目の Visual Studio インスタンスで、新しい C# コンソール アプリケーション プロジェクトを作成し、定数値を使用 して初期化されたローカル変数宣言をいくつか Main メソッドに追加します。 次のように警告として報告されることがわかりま す。
ここでは、さまざまな作業を行いました。 const にすることができる宣言には、波線が表示されています。ただし、まだするべき ことがあります。 これは、 i で始まる宣言に const を追加し、次に j を追加し、最後に k を追加して改善することができ ます。 ただし、 k で始まる const 修飾子を異なる順序で追加すると、アナライザーによってエラーが生成されます。 i と j の両方が既に const でなければ、 k を const と宣言できません。 変数を宣言して初期化できるさまざまな方法を確実に 処理できるように、さらに分析を行う必要があります。
データ駆動型テストをビルドする
アナライザーとコード修正は、const にすることができる単一の宣言という単純なケースで動作します。 この実装によって間違い が発生する可能性のある宣言ステートメントは数多くあります。 このようなケースには、テンプレートによって作成される単体テス ト ライブラリを使用して対処します。 これは、Visual Studio の 2 つ目のコピーを繰り返し開くよりもはるかに高速です。
    // Add an annotation to format the new local declaration.
var formattedLocal = newLocal.WithAdditionalAnnotations(Formatter.Annotation);
   using Microsoft.CodeAnalysis.Formatting;
      // Replace the old local declaration with the new local declaration.
var oldRoot = await document.GetSyntaxRootAsync(cancellationToken);
var newRoot = oldRoot.ReplaceNode(localDeclaration, formattedLocal);
// Return document with transformed tree.
return document.WithSyntaxRoot(newRoot);
     // Insert the const token into the modifiers list, creating a new modifiers list.
var newModifiers = trimmedLocal.Modifiers.Insert(0, constToken);
// Produce the new local declaration.
var newLocal = trimmedLocal
    .WithModifiers(newModifiers)
    .WithDeclaration(localDeclaration.Declaration);
 
 単体テスト プロジェクトで MakeConstUnitTests.cs ファイルを開きます。 テンプレートによって、アナライザーとコード修正の 単体テスト用に 2 つの共通パターンに従う 2 つのテストが作成されています。 は、診断を報告すべきではないと きに、アナライザーから診断が報告されないようにするテストのパターンを示します。 は、診断を報告し、コード修 正を実行するためのパターンを示します。
アナライザーのほぼすべてのテストのコードは、この 2 つのパターンのいずれかに従います。 1 つ目の手順では、これらのテストを データ駆動型テストとして修正することができます。 次に、さまざまなテスト入力を表す新しい文字列定数を追加することで、新 しいテストを簡単に作成できます。
効率化するには、1 つ目の手順を 2 つのテストをデータ駆動型テストにリファクターします。 すると、必要な作業は、新しいテス トのたびに、いくつかの文字列定数を定義するだけになります。 リファクター時に、両方のメソッドをわかりやすい名前に変更しま す。 診断が呼び出されないように、 TestMethod1 をこのテストに置き換えます。
診断で警告がトリガーされないようにするコード フラグメントすることで、このテスト用に新しいデータ行を作成することができま す。ソースコードフラグメントに対してトリガーされる診断がない場合、VerifyCSharpDiagnostic のこのオーバーロードは成功 します。
次に、 TestMethod2 をこのテストに置き換えて、診断を呼び出し、ソース コード フラグメントに対してコード修正を適用するよう にします。
 TestMethod1
 TestMethod2
     [DataTestMethod]
[DataRow("")]
public void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)
{
    VerifyCSharpDiagnostic(testCode);
}
       [DataTestMethod]
[DataRow(LocalIntCouldBeConstant, LocalIntCouldBeConstantFixed, 10, 13)]
public void WhenDiagnosticIsRaisedFixUpdatesCode(
    string test,
    string fixTest,
    int line,
    int column)
{
    var expected = new DiagnosticResult
    {
        Id = MakeConstAnalyzer.DiagnosticId,
        Message = new LocalizableResourceString(nameof(MakeConst.Resources.AnalyzerMessageFormat),
MakeConst.Resources.ResourceManager, typeof(MakeConst.Resources)).ToString(),
        Severity = DiagnosticSeverity.Warning,
        Locations =
};
new[] {
        new DiagnosticResultLocation("Test0.cs", line, column)
}
    VerifyCSharpDiagnostic(test, expected);
    VerifyCSharpFix(test, fixTest);
}
  また、前のコードでは、想定される診断結果を構築する変更をいくつかコードに加えました。これには MakeConst アナライザー に登録されたパブリック定数が使用されます。 さらに、入力ソースと修正済みソース用に 2 つの文字列定数が使用されます。
UnitTest クラスに次の文字列定数を追加します。
 
  これらの 2 つのテストを実行して、合格することを確認します。 Visual Studio で、 [テスト] > [Windows] > [テスト エクス プローラー] の順に選択して、 テスト エクスプローラー を開きます。 次に、 [すべて実行] リンクを選択します。
有効な宣言のテストを作成する
一般的な規則として、アナライザーはできるだけ早く終了し、最低限の作業を行う必要があります。 ユーザーがコードを編集す ると、Visual Studio では登録済みのアナライザーが呼び出されます。 応答性は重要な要件です。 診断を呼び出すべきでは ないコードのテストケースがいくつかあります。 このアナライザーは、このようなテストのうち、初期化後に変数が割り当てられる ケースのテストを既に処理しています。 そのケースを表すために、テストに次の文字列定数を追加します。
    private const string VariableAssigned = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
int i = 0;
    Console.WriteLine(i++);
}
 次に、以下のスニペットに示すように、このテストのデータ行を追加します。
   private const string LocalIntCouldBeConstant = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
int i = 0;
    Console.WriteLine(i);
}
private const string LocalIntCouldBeConstantFixed = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    const int i = 0;
    Console.WriteLine(i);
}
 
  このテストも合格します。 次に、まだ処理していない条件の定数を追加します。 既にconstなので、既に const である宣言:
    private const string AlreadyConst = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    const int i = 0;
    Console.WriteLine(i);
}
 使用する価値がないため、初期化子がない宣言:
    private const string NoInitializer = @"
using System;
namespace MakeConstTest
{
    class Program
    {
        static void Main(string[] args)
        {
} }
}";
int i;
i = 0;
Console.WriteLine(i);
 コンパイル時の定数にすることはできないため、初期化子が定数ではない宣言:
    private const string InitializerNotConstant = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    int i = DateTime.Now.DayOfYear;
    Console.WriteLine(i);
}
 C# は複数の宣言を 1 つのステートメントとして許可するので、さらに複雑になる可能性があります。 次のテスト ケース文字列
   [DataTestMethod]
[DataRow(""),
 DataRow(VariableAssigned)]
public void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)
 
 定数を考えてみましょう。
    private const string MultipleInitializers = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    int i = 0, j = DateTime.Now.DayOfYear;
    Console.WriteLine(i, j);
}
 変数 i は定数にすることができますが、変数 j はできません。そのため、このステートメントをconst宣言にすることはできま せん。これらすべてのテストについて DataRow 宣言を追加します。
     [DataTestMethod]
[DataRow(""),
    DataRow(VariableAssigned),
    DataRow(AlreadyConst),
    DataRow(NoInitializer),
    DataRow(InitializerNotConstant),
    DataRow(MultipleInitializers)]
public void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)
 テストをもう一度実行すると、これらの新しいテスト ケースが失敗することがわかります。 正しい宣言を無視するようにアナライザーを更新する
アナライザーの AnalyzeNode メソッドにいくつか拡張を追加して、これらの条件に一致するコードをフィルター処理する必要があ ります。これらはすべて関連する条件なので、同様の変更でこれらすべての条件を修正します。 AnalyzeNode に次の変更を 加えます。
セマンティック分析では、単一の変数宣言を調査しました。 このコードは、同じステートメントで宣言されたすべての変数を 調査する foreach ループ内に配置する必要があります。
宣言された各変数には初期化子が必要です。 宣言された各変数の初期化子は、コンパイル時定数にする必要があります。
AnalyzeNode メソッドで、元のセマンティック分析を置き換えます。
        // Perform data flow analysis on the local declaration.
var dataFlowAnalysis = context.SemanticModel.AnalyzeDataFlow(localDeclaration);
// Retrieve the local symbol for each variable in the local declaration
// and ensure that it is not written outside of the data flow analysis region.
var variable = localDeclaration.Declaration.Variables.Single();
var variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable);
if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))
{
return; }
 次のコード スニペットのようにします。

    最初の foreach ループで、構文解析を使用して各変数宣言を調査します。最初の検査で、変数に初期化子があることを 確認します。 2 つ目の検査で、初期化子が定数であることを確認します。 2 つ目のループには、元のセマンティック分析があり ます。 セマンティック検査は、パフォーマンスに大きな影響があるため、別のループに配置されています。 テストをもう一度実行す ると、すべてが合格になるはずです。
最後の仕上げを加える
完了までもう少しです。 アナライザーが処理できる条件がまだいくつかあります。 Visual Studio では、ユーザーがコードを記述し ているときにアナライザーが呼び出されます。 コンパイルされないコードに対してアナライザーが呼び出されることはよくあります。 診断アナライザーの AnalyzeNode メソッドは、定数値を変数型に変換できるかどうかを検査しません。そのため、現在の実装 では、int i = "abc" のような正しくない宣言でもそのままローカル定数に変換されます。 このような条件に対して次のソース文 字列定数を追加します。
     private const string DeclarationIsInvalid = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    int x = ""abc"";
}
 また、参照型が正しく処理されません。 参照型に使用できる唯一の定数値は、文字列リテラルを許可する System.String の 場合を除き、 null です。 つまり、 const string s = "abc" は有効ですが、 const object s = "abc" は有効ではありませ ん。 このコード スニペットで、次の条件を検証します。
     // Ensure that all variables in the local declaration have initializers that
// are assigned with constant values.
foreach (var variable in localDeclaration.Declaration.Variables)
{
    var initializer = variable.Initializer;
    if (initializer == null)
    {
return; }
    var constantValue = context.SemanticModel.GetConstantValue(initializer.Value);
    if (!constantValue.HasValue)
    {
return; }
}
// Perform data flow analysis on the local declaration.
var dataFlowAnalysis = context.SemanticModel.AnalyzeDataFlow(localDeclaration);
foreach (var variable in localDeclaration.Declaration.Variables)
{
    // Retrieve the local symbol for each variable in the local declaration
    // and ensure that it is not written outside of the data flow analysis region.
    var variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable);
    if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))
    {
return; }
}
 
  さらに徹底するには、文字列の定数宣言を作成できるように別のテストを追加します。 次のスニペットでは、診断を呼び出す コードと、修正が適用された後のコードの両方を定義しています。
    private const string ConstantIsString = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
} }";
static void Main(string[] args)
{
    string s = ""abc"";
}
private const string ConstantIsStringFixed = @"
using System;
namespace MakeConstTest
{
    class Program
    {
static void Main(string[] args)
{
    const string s = ""abc"";
}
 最後に、変数が var キーワードで宣言されている場合、コード修正で適切な処理が実行されず、C#言語でサポートされて いない const var 宣言が生成されます。 このバグを修正するには、コード修正で var キーワードを推定型の名前に置き換 える必要があります。
    private const string ReferenceTypeIsntString = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    object s = ""abc"";
}
 
    これらの変更で、両方のテストのデータ行の宣言が更新されます。 次のコードは、すべてのデータ行の属性を使用したこれらの テストを示しています。
  private const string DeclarationUsesVar = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
} }";
static void Main(string[] args)
{
var item = 4; }
private const string DeclarationUsesVarFixedHasType = @"
using System;
namespace MakeConstTest
{
    class Program
    {
static void Main(string[] args)
{
    const int item = 4;
}
private const string StringDeclarationUsesVar = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    var item = ""abc"";
}
private const string StringDeclarationUsesVarFixedHasType = @"
using System;
namespace MakeConstTest
{
    class Program
    {
} }";
static void Main(string[] args)
{
    const string item = ""abc"";
}

    幸いにも、上記のすべてのバグは、ここで学んだテクニックを使って解決できます。
最初のバグを修正するには、まず DiagnosticAnalyzer.cs を開き、各ローカル宣言の初期化子が検査される foreach ルー プを見つけて、それらに定数値が割り当てられていることを確認します。 最初の foreach ループの 直前 に
context.SemanticModel.GetTypeInfo() を呼び出し、宣言されたローカル宣言の型に関する詳細情報を取得します。
次に、 foreach ループ内に、各初期化子が変数型に変換できることを確認します。 初期化子が定数であることを確認した ら、次の検査を追加します。
     var variableTypeName = localDeclaration.Declaration.Type;
var variableType = context.SemanticModel.GetTypeInfo(variableTypeName).ConvertedType;
     //No diagnostics expected to show up
[DataTestMethod]
[DataRow(""),
 DataRow(VariableAssigned),
 DataRow(AlreadyConst),
 DataRow(NoInitializer),
 DataRow(InitializerNotConstant),
 DataRow(MultipleInitializers),
 DataRow(DeclarationIsInvalid),
 DataRow(ReferenceTypeIsntString)]
public void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)
{
    VerifyCSharpDiagnostic(testCode);
}
[DataTestMethod]
[DataRow(LocalIntCouldBeConstant, LocalIntCouldBeConstantFixed, 10, 13),
 DataRow(ConstantIsString, ConstantIsStringFixed, 10, 13),
 DataRow(DeclarationUsesVar, DeclarationUsesVarFixedHasType, 10, 13),
 DataRow(StringDeclarationUsesVar, StringDeclarationUsesVarFixedHasType, 10, 13)]
public void WhenDiagosticIsRaisedFixUpdatesCode(
    string test,
    string fixTest,
    int line,
    int column)
{
    var expected = new DiagnosticResult
    {
        Id = MakeConstAnalyzer.DiagnosticId,
        Message = new LocalizableResourceString(nameof(MakeConst.Resources.AnalyzerMessageFormat),
MakeConst.Resources.ResourceManager, typeof(MakeConst.Resources)).ToString(),
        Severity = DiagnosticSeverity.Warning,
        Locations =
};
new[] {
        new DiagnosticResultLocation("Test0.cs", line, column)
}
    VerifyCSharpDiagnostic(test, expected);
    VerifyCSharpFix(test, fixTest);
}
   // Ensure that the initializer value can be converted to the type of the
// local declaration without a user-defined conversion.
var conversion = context.SemanticModel.ClassifyConversion(initializer.Value, variableType);
if (!conversion.Exists || conversion.IsUserDefined)
{
return; }
 
 次の変更は、最後の変更に基づいています。 最初の foreach ループの中かっこの前に、定数が文字列または null の場合に ローカル宣言の型を検査する次のコードを追加します。
    // Special cases:
//  * If the constant value is a string, the type of the local declaration
//    must be System.String.
//  * If the constant value is null, the type of the local declaration must
//    be a reference type.
if (constantValue.Value is string)
{
    if (variableType.SpecialType != SpecialType.System_String)
    {
return; }
}
else if (variableType.IsReferenceType && constantValue.Value != null)
{
return; }
 var キーワードを正しい型名に置き換えるには、コード修正プロバイダーに少しコードを追加する必要があります。 CodeFixProvider.cs に戻ります。 追加するコードで、次の手順が実行されます。
宣言が var 宣言かどうかを検査し、その場合は次の処理を実行します。 推定型の新しい型を作成します。
型宣言がエイリアスでないことを確認します。 その場合は、 を宣言することができます。
var がこのプログラムの型名でないことを確認します(その場合、 は有効です)。 完全な型名を簡略化する
多数のコードが必要なようですが、そうではありません。 newLocal を宣言し、初期化する行を次のコードに置き換えます。 newModifiers の初期化直後に配置します。
 const var
 const var
  
   Simplifier型を使用するには、1つの using ディレクティブを追加する必要があります。
テストを実行します。テストはすべて合格するはずです。 完成したアナライザーを実行してみてください。 Ctrl + F5 キーを押し て、Roslyn Preview 拡張機能が読み込まれた Visual Studio の 2 つ目のインスタンスでアナライザー プロジェクトを実行しま す。
2 つ目の Visual Studio インスタンスで、新しい C# コンソール アプリケーション プロジェクトを作成し、 int x = "abc"; を Main メソッドに追加します。 最初のバグ修正のおかげで、このローカル変数宣言について警告は報告されません (ただし、 想定どおりコンパイラ エラーが発生します)。
次に、Main メソッドに object s = "abc"; を追加します。 2 つ目のバグ修正のおかげで、警告は報告されません。
最後に、 var キーワードを使用する別のローカル変数を追加します。 警告が報告され、左側の下部に推奨が表示されま す。
波線にエディターのカレットを移動し、Ctrl + . キーを押します。 推奨されたコード修正が表示されます。 コード修正を選 択して、 var キーワードが正しく処理されていることを確認します。
最後に、次のコードを追加します。
  using Microsoft.CodeAnalysis.Simplification;
       int i = 2;
int j = 32;
int k = i + j;
    // If the type of the declaration is 'var', create a new type name
// for the inferred type.
var variableDeclaration = localDeclaration.Declaration;
var variableTypeName = variableDeclaration.Type;
if (variableTypeName.IsVar)
{
    var semanticModel = await document.GetSemanticModelAsync(cancellationToken);
    // Special case: Ensure that 'var' isn't actually an alias to another type
    // (e.g. using var = System.String).
    var aliasInfo = semanticModel.GetAliasInfo(variableTypeName);
    if (aliasInfo == null)
    {
        // Retrieve the type inferred for var.
        var type = semanticModel.GetTypeInfo(variableTypeName).ConvertedType;
} }
// Special case: Ensure that 'var' isn't actually a type named 'var'.
if (type.Name != "var")
{
    // Create a new TypeSyntax for the inferred type. Be careful
    // to keep any leading and trailing trivia from the var keyword.
    var typeName = SyntaxFactory.ParseTypeName(type.ToDisplayString())
        .WithLeadingTrivia(variableTypeName.GetLeadingTrivia())
        .WithTrailingTrivia(variableTypeName.GetTrailingTrivia());
    // Add an annotation to simplify the type name.
    var simplifiedTypeName = typeName.WithAdditionalAnnotations(Simplifier.Annotation);
    // Replace the type in the variable declaration.
    variableDeclaration = variableDeclaration.WithType(simplifiedTypeName);
}
// Produce the new local declaration.
var newLocal = trimmedLocal.WithModifiers(newModifiers)
                           .WithDeclaration(variableDeclaration);
 
    これらの変更の後は、最初の2つの変数にのみ赤い波線が表示されます。 i と j の両方に const を追加すると、 const になる可能性があるので、 k で新しい警告を受け取ります。
おめでとうございます! ここでは最初の .NET Compiler Platform 拡張機能を作成しました。これは、その場でコード分析を実 行し、問題を検出してそれを修正する簡単な修正案を提供する拡張機能です。 この過程で、.NET Compiler Platform SDK (Roslyn API) に含まれる多くのコード API を学びました。 サンプル GitHub リポジトリの完成したサンプルに対して作業を 検査することができます。
その他のリソース
構文解析の概要 セマンティック解析の概要

                            このセクションでは、C# 言語の重要な機能と、.NET 経由でアクセスできる C# の機能の詳細について説明します。
このセクションの大部分では、お客様が C# と一般的なプログラミングの概念について、ある程度の知識を持っていることを前提 としています。 プログラミングや C# についてまったくの初心者の方は、プログラミングの予備知識が必要ない C# の概要に関す るチュートリアルや「ブラウザーでの .NET のチュートリアル」を参照することをお勧めします。
特定のキーワード、演算子、およびプリプロセッサ ディレクティブについては、「C# リファレンス」を参照してください。 C# 言語の仕 様については、C# 言語仕様に関する記事をご覧ください。
プログラム セクション
インサイド C# プログラム Main() とコマンドライン引数
言語セクション
ステートメント、式、および演算子 型
クラスと構造体
インターフェイス
デリゲート
配列
文字列
プロパティ
インデクサー
イベント
ジェネリック
反復子
LINQ クエリ式
名前空間
アンセーフ コードとポインター XML ドキュメント コメント
プラットフォーム セクション
アプリケーション ドメイン
.NET のアセンブリ
属性
コレクション
例外と例外処理
ファイル システムとレジストリ (C# プログラミング ガイド) 相互運用性
リフレクション
C# プログラミング ガイド 2021/03/06 • • Edit Online
 
  関連項目
C# リファレンス

            このセクションでは C# プログラムの一般的な構造について説明し、標準的な "Hello, World!" の の例です。
このセクションの内容
C# プログラムの一般構造 識別子名
C# のコーディング規則
関連項目
C# の使用を開始する
C# プログラミング ガイド
C# リファレンス サンプルおよびチュートリアル
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。
関連項目
C# プログラミング ガイド
インサイド C# プログラム 2021/03/06 • • Edit Online
 
     C# プログラムは、1 つ以上のファイルで構成できます。 各ファイルには、0 個以上の名前空間を含めることができます。 名前空 間には、その他の名前空間以外に、クラス、構造体、インターフェイス、列挙型、デリゲートなどの型を含めることができます。 次に示すのは、これら要素をすべて含む C# プログラムのスケルトンです。
    // A skeleton of a C# program
using System;
namespace YourNamespace
{
    class YourClass
    {
    }
    struct YourStruct
    {
    }
    interface IYourInterface
    {
    }
    delegate int YourDelegate();
    enum YourEnum
    {
    }
    namespace YourNestedNamespace
    {
        struct YourStruct
        {
        }
}
    class YourMainClass
    {
} }
static void Main(string[] args)
{
    //Your program starts here...
}
 関連項目 詳細情報
クラス
構造体 名前空間 インターフェイス
C# プログラムの一般構造 (C# プログラミング ガ
イド)
2020/11/02 • • Edit Online
 
       デリゲート
C# 言語仕様
詳細については、「C# 言語の仕様」の「基本概念」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性
のある情報源です。 関連項目
C# プログラミング ガイド インサイド C# プログラム C# リファレンス

               識別子は、型 (クラス、インターフェイス、構造体、デリゲート、列挙型)、メンバー、変数、名前空間に割り当てる名前です。 識別子を有効にするには次の規則に従う必要があります。
識別子の名前は文字または _ で始まらなければなりません。
識別子には、Unicode 文字、10 進数文字、Unicode 接続文字、Unicode 結合文字、Unicode 書式設定文字を含 めることができます。 Unicode カテゴリの詳細については、Unicode カテゴリ データベースに関するページを参照してくださ い。識別子で @ プレフィックスを使用することで、C#キーワードに一致する識別子を宣言できます。 @ は識別子名の一 部ではありません。 たとえば、 @if の場合、 if という名前の識別子が宣言されます。 このような逐語的識別子は主に、 他の言語で宣言された識別子との相互運用性のために使用されます。
有効な識別子の完全な定義は、C# 言語仕様の「Identifiers」 (識別子) トピックにあります。 名前付け規則
規則に加え、.NET API 全体で使用されるさまざまな識別子命名規則があります。 慣例により、C# プログラムでは、型名、名 前空間、すべてのパブリックメンバーに PascalCase が使用されます。また、次の規則が一般的です。
インターフェイス名は大文字 I で始まります。
属性型は Attribute という単語で終わります。 列挙型では、フラグ以外に単数名詞が使用され、フラグに複数名詞が使用されます。
識別子には、連続する2つの _ 文字を含めないでください。このような文字は、コンパイラで生成される識別子のために 予約されています。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミング ガイド インサイド C# プログラム C# リファレンス
クラス
構造体型 名前空間 インターフェイス デリゲート
  識別子名
2020/03/18 • • Edit Online
 
     コーディング規則には、次の目的があります。 コードの見た目が統一されるため、コードを読むときに、レイアウトではなく内容に重点を置くことができます。 これにより、経験に基づいて推測することで、コードをより迅速に理解することができます。 コードのコピー、変更、および保守が容易になります。
コーディング規約により、C# のベスト プラクティスがわかります。
この記事のガイドラインは、サンプルおよびドキュメントを開発するために Microsoft によって使用されます。 命名規則
using ディレクティブが含まれていない簡単な例では、名前空間の修飾を使用します。 プロジェクトに名前空間が既定 でインポートされていることがわかっている場合は、その名前空間の各名前を完全修飾する必要はありません。 次の例 に示すように、修飾名が長すぎて 1 行に収まらない場合は、ドット (.) の後で改行できます。
他のガイドラインに合わせて、Visual Studio デザイナーのツールを使用して作成されたオブジェクトの名前を変更する 必要はありません。
レイアウト規則
コードの構造を強調する書式が使用され、コードが読みやすくなっているのが、優れたレイアウトです。 マイクロソフトの例とサン プルは、次の規則に準拠しています。
コード エディターの既定の設定 (スマート インデント、4 文字インデント、タブを空白として保存) を使用します。 詳細に ついては、「[オプション]、[テキスト エディター]、[C#]、[書式設定]」を参照してください。
1 つの行には 1 つのステートメントのみを記述します。
1 つの行には 1 つの宣言のみを記述します。
継続行にインデントが自動的に設定されない場合は、1 タブ ストップ (4 つの空白) 分のインデントを設定します。 メソッド定義とプロパティ定義の間に少なくとも 1 行の空白行を追加します。 次のコードに示すように、式に句を作成するときはかっこを使用します。
    var currentPerformanceCounterCategory = new System.Diagnostics.
    PerformanceCounterCategory();
     if ((val1 > val2) && (val1 > val3))
{
    // Take appropriate action.
}
 コメント規則
C# のコーディング規則 (C# プログラミング ガイ
ド)
2020/11/02 • • Edit Online
 
    コメントは、コード行の末尾ではなく別の行に記述します。 コメントのテキストは大文字で開始します。
コメントのテキストはピリオドで終了します。
次の例に示すように、コメント デリミター (//) とコメント テキストの間に空白を 1 つ挿入します。
アスタリスクを整形したブロックでコメントを囲まないようにします。
言語ガイドライン
以降のセクションでは、コード例とサンプルを準備する際に C# チームが従っている方法について説明します。
文字列型 (String) 次のコードに示すように、短い文字列を連結するときは文字列補間を使用します。
ループ内で文字列を追加する場合 (特に大量のテキストを処理する場合) は、StringBuilder オブジェクトを使用しま す。
    // The following declaration creates a query. It does not run
// the query.
   string displayName = $"{nameList[n].LastName}, {nameList[n].FirstName}";
     var phrase = "lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala";
var manyPhrases = new StringBuilder();
for (var i = 0; i < 10000; i++)
{
    manyPhrases.Append(phrase);
}
//Console.WriteLine("tra" + manyPhrases);
 暗黙的に型指定されるローカル変数 変数の型が割り当ての右側から明らかである場合、または厳密な型が重要でない場合は、ローカル変数の暗黙の型
指定を使用します。
割り当ての右側から型が明らかではない場合、var を使用しないでください。
変数の型を指定するときに変数名に頼らないでください。 変数名が正しくない場合があります。
    // When the type of a variable is clear from the context, use var
// in the declaration.
var var1 = "This is clearly a string.";
var var2 = 27;
     // When the type of a variable is not clear from the context, use an
// explicit type. You generally don't assume the type clear from a method name.
// A variable type is considered clear if it's a new operator or an explicit cast.
int var3 = Convert.ToInt32(Console.ReadLine());
int var4 = ExampleClass.ResultSoFar();
 
      dynamicの代わりに var を使用しないようにしてください。
for ループでループ変数の型を決定するときは、暗黙の型指定が使用されます。 次の例では、 for ステートメントで暗黙の型指定を使用しています。
foreach ループでループ変数の型を決定するときは、暗黙の型指定は使用されません。 次の例では、 foreach ステートメントで暗黙の型指定が使用されています。
    var phrase = "lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala";
var manyPhrases = new StringBuilder();
for (var i = 0; i < 10000; i++)
{
    manyPhrases.Append(phrase);
}
//Console.WriteLine("tra" + manyPhrases);
      foreach (char ch in laugh)
{
    if (ch == 'h')
        Console.Write("H");
    else
        Console.Write(ch);
}
Console.WriteLine();
     NOTE
反復可能コレクションの要素の型を誤って変更しないように注意してください。 たとえば、 foreach ステートメントで System.Linq.IQueryable から System.Collections.IEnumerable に切り替えるのは簡単ですが、これを行うとクエリの結果が変 更されます。
  Unsigned データ型
通常は、unsigned型ではなく int を使用します。C#では int を使用するのが一般的です。int を使用すると、他のラ
イブラリと対話しやすくなります。
配列 宣言行で配列を初期化するときは簡潔な構文を使用します。
    // Preferred syntax. Note that you cannot use var here instead of string[].
string[] vowels1 = { "a", "e", "i", "o", "u" };
// If you use explicit instantiation, you can use var.
var vowels2 = new string[] { "a", "e", "i", "o", "u" };
// If you specify an array size, you must initialize the elements one at a time.
var vowels3 = new string[5];
vowels3[0] = "a";
vowels3[1] = "e";
// And so on.
    // Naming the following variable inputInt is misleading.
// It is a string.
var inputInt = Console.ReadLine();
Console.WriteLine(inputInt);
 
     デリゲート デリゲート型のインスタンスを作成するときは簡潔な構文を使用します。
    // First, in class Program, define the delegate type and a method that
// has a matching signature.
// Define the type.
public delegate void Del(string message);
// Define a method that has a matching signature.
public static void DelMethod(string str)
{
    Console.WriteLine("DelMethod argument: {0}", str);
}
     // In the Main method, create an instance of Del.
// Preferred: Create an instance of Del by using condensed syntax.
Del exampleDel2 = DelMethod;
// The following declaration uses the full syntax.
Del exampleDel1 = new Del(DelMethod);
 例外処理における try-catch ステートメントと using ステートメント ほとんどの例外処理には、try-catch ステートメントを使用します。
    static string GetValueFromArray(string[] array, int index)
{
try {
        return array[index];
    }
    catch (System.IndexOutOfRangeException ex)
    {
        Console.WriteLine("Index is out of range: {0}", index);
throw; }
}
  C#のusingステートメントを使用して、コードを簡潔にします。try-finallyステートメントを使用するときに finally ブロックのコードがDisposeメソッドの呼び出しだけである場合は、using ステートメントを代わりに使用します。

  && 演算子および || 演算子 例外を回避し、不要な比較をスキップしてパフォーマンスを向上させるには、比較を実行する場合、次の例に示すように & の
代わりに && を、| の代わりに || を使用します。
    Console.Write("Enter a dividend: ");
var dividend = Convert.ToInt32(Console.ReadLine());
Console.Write("Enter a divisor: ");
var divisor = Convert.ToInt32(Console.ReadLine());
// If the divisor is 0, the second clause in the following condition
// causes a run-time error. The && operator short circuits when the
// first expression is false. That is, it does not evaluate the
// second expression. The & operator evaluates both, and causes
// a run-time error when divisor is 0.
if ((divisor != 0) && (dividend / divisor > 0))
{
    Console.WriteLine("Quotient: {0}", dividend / divisor);
}
else {
    Console.WriteLine("Attempted division by 0 ends up here.");
}
 new 演算子 次の宣言に示すように、暗黙の型指定を使用してオブジェクトのインスタンス化を簡潔な形式にします。
前の行は次の宣言に相当します。
オブジェクト初期化子を使用してオブジェクトの作成を簡略化します。
  var instance1 = new ExampleClass();
   ExampleClass instance2 = new ExampleClass();
    // This try-finally statement only calls Dispose in the finally block.
Font font1 = new Font("Arial", 10.0f);
try
{
    byte charset = font1.GdiCharSet;
}
finally {
    if (font1 != null)
    {
        ((IDisposable)font1).Dispose();
    }
}
// You can do the same thing with a using statement.
using (Font font2 = new Font("Arial", 10.0f))
{
    byte charset = font2.GdiCharSet;
}
 
  イベント処理
後で削除する必要のないイベント ハンドラーを定義する場合は、ラムダ式を使用します。
    public Form2()
{
    // You can use a lambda expression to define an event handler.
    this.Click += (s, e) =>
        {
            MessageBox.Show(
}; }
((MouseEventArgs)e).Location.ToString());
     // Using a lambda expression shortens the following traditional definition.
public Form1()
{
    this.Click += new EventHandler(Form1_Click);
}
void Form1_Click(object sender, EventArgs e)
{
    MessageBox.Show(((MouseEventArgs)e).Location.ToString());
}
 静的メンバー
静的メンバーは、クラス名 ClassName.StaticMember を使用して呼び出します。 こうすることで、静的アクセスが明確になり、 コードがよりわかりやすくなります。 派生クラスの名前を持つ基本クラスに定義された静的メンバーを指定しないでください。 この コードをコンパイルすると、コードが読みやすくなくなり、派生クラスに同じ名前の静的メンバーを追加すると、将来的にコードが 中断する場合があります。
LINQ クエリ
クエリ変数にはわかりやすい名前を使用します。次の例では、シアトル在住の顧客に seattleCustomers を使用して
います。
エイリアスを使用して、匿名型のプロパティ名の大文字と小文字の使用が正しい Pascal 形式になるようにします。
     var seattleCustomers = from customer in customers
                       where customer.City == "Seattle"
                       select customer.Name;
     var localDistributors =
    from customer in customers
    join distributor in distributors on customer.City equals distributor.City
    select new { Customer = customer, Distributor = distributor };
    // Object initializer.
var instance3 = new ExampleClass { Name = "Desktop", ID = 37414,
    Location = "Redmond", Age = 2.3 };
// Default constructor and assignment statements.
var instance4 = new ExampleClass();
instance4.Name = "Desktop";
instance4.ID = 37414;
instance4.Location = "Redmond";
instance4.Age = 2.3;
 
    結果のプロパティ名があいまいになる場合は、プロパティ名を変更します。 たとえば、クエリで顧客名と販売店 ID を返す 場合、クエリ結果で Name と ID をそのまま使用するのではなく、これらの名前を変更し、 Name が顧客の名前であ り、ID が販売店のIDであることを明確にします。
クエリ変数と範囲変数の宣言で暗黙の型指定を使用します。
前の例に示すように、クエリ句を from 句の下に配置します。
where 句を他のクエリ句より先に使用し、それ以降のクエリ句では、フィルター化されたデータセットが処理されるようにし
ます。
内部コレクションにアクセスするには、join 句ではなく複数の from 句を使用します。 たとえば、 Student オブジェクト のコレクションがあり、各オブジェクトに試験の点数のコレクションが含まれているとします。 次のクエリを実行すると、90 点 より高い点数とその点数を取った学生の姓が返されます。
セキュリティ 「安全なコーディングのガイドライン」のガイドラインに従ってください。
関連項目
Visual Basic のコーディング規則 安全なコーディングのガイドライン
    var localDistributors2 =
    from customer in customers
    join distributor in distributors on customer.City equals distributor.City
    select new { CustomerName = customer.Name, DistributorID = distributor.ID };
     var seattleCustomers = from customer in customers
                       where customer.City == "Seattle"
                       select customer.Name;
     var seattleCustomers2 = from customer in customers
                        where customer.City == "Seattle"
                        orderby customer.Name
                        select customer;
      // Use a compound from to access the inner sequence within each element.
var scoreQuery = from student in students
                 from score in student.Scores
                 where score > 90
                 select new { Last = student.LastName, score };
 
        Main メソッドは、C#アプリケーションのエントリポイントです(ライブラリおよびサービスでは、エントリポイントとしての Main メ ソッドは必要ありません)。アプリケーションを起動すると、最初に Main メソッドが呼び出されます。
C#プログラムのエントリポイントは1つのみです。 Main メソッドを持つクラスが2つ以上ある場合、プログラムをコンパイルする 際に -main コンパイラオプションを使用して、どの Main メソッドをエントリポイントとして使用するかを指定する必要がありま す。 詳細については、「-main (C# コンパイラ オプション)」を参照してください。
    class TestClass
{
    static void Main(string[] args)
    {
        // Display the number of command line arguments.
        Console.WriteLine(args.Length);
    }
}
 C#9以降では、次の例のように Main メソッドを省略し、Main メソッド内にあるかのようにC#ステートメントを記述することが できます。
暗黙的なエントリ ポイント メソッドを使用してアプリケーション コードを記述する方法の詳細については、「最上位レベルのステー トメント」を参照してください。
概要
Main メソッドは実行可能プログラムのエントリポイントであり、ここでプログラムの制御を開始および終了します。
Main は、クラスまたは構造体の内部で宣言されます。 Main はstaticである必要がありますが、publicである必要はあ りません (先ほどの例では、既定の private のアクセスを受け取ります)。外側のクラスまたは構造体は、static である必要は ありません。
Main の戻り値の型は、void または int のいずれかになります。C#7.1以降では Task または Task<int> になる場 合もあります。
Main で Task または が返される場合に限り、 Main の宣言に async 修飾子を含めることができます。 こ の条件により、 メソッドが明確に除外されることに注意してください。
Main メソッドを宣言する際、コマンドライン引数を含む string[] パラメーターは指定してもしなくてもかまいません。 Visual Studio を使用して Windows アプリケーションを作成する場合、このパラメーターを手動で追加するか GetCommandLineArgs() メソッドを使用して、コマンドライン引数を取得できます。 パラメーターは、インデックス 0 のコマン ドライン引数として読み取られます。 C や C++ とは異なり、プログラムの名前は、GetCommandLineArgs() の最初の要 素です。 args 配列の最初のコマンドライン引数として扱われることはありません。
    using System;
Console.WriteLine("Hello World!");
   Task<int>
 async void Main
 有効な Main の署名の一覧を次に示します。
Main() とコマンドライン引数 (C# プログラミン
グ ガイド) 2021/03/17 • • Edit Online
 
      前の例ではすべて、public アクセサー修飾子を使用しています。 これは一般的ですが、必須ではありません。
コンソール アプリケーションの Main で await を使用して非同期操作を開始する必要がある場合、戻り値の型 async 、
Task 、 Task<int> を追加することでプログラム コードを簡略化できます。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
csc.exe を使用したコマンド ラインからのビルド C# プログラミング ガイド
メソッド
インサイド C# プログラム
    public static void Main() { }
public static int Main() { }
public static void Main(string[] args) { }
public static int Main(string[] args) { }
public static async Task Main() { }
public static async Task<int> Main() { }
public static async Task Main(string[] args) { }
public static async Task<int> Main(string[] args) { }
 
       Main メソッドに引数を渡すには、次のいずれかの方法でメソッドを定義します。
  static int Main(string[] args)
   static void Main(string[] args)
     NOTE
Windows フォーム アプリケーションの Main メソッドでコマンド ライン引数を有効にするには、program.cs の Main のシグネチャを手動 で変更する必要があります。 Windows フォーム デザイナーが生成するコードは、入力パラメーターなしの Main を作成します。 Environment.CommandLine または Environment.GetCommandLineArgs を使用して、コンソールまたは Windows アプリケーション 内の任意の場所からコマンド ライン引数にアクセスすることもできます。
  Main メソッドのパラメーターはStringの配列で、コマンドライン引数を表しています。通常は、Length プロパティを調べて引 数があるかどうかを確認します。次はその例です。
    if (args.Length == 0)
{
    System.Console.WriteLine("Please enter a numeric argument.");
return 1; }
     TIP
args 配列を null にすることはできません。 そのため、null チェックを行わずに Length プロパティに安全にアクセスできます。
  また、Convertクラスまたは Parse メソッドを使って、文字列型の引数を数値型に変換できます。たとえば、次のステートメン トでは、string メソッドを使用して long をParse値に変換します。
C#の long 型を使うこともできます。これは Int64 のエイリアスです。
また、同じ変換に Convert クラスの ToInt64 メソッドを使うこともできます。
詳細については、次のトピックを参照してください。 Parse および Convert 例
   long num = Int64.Parse(args[0]);
   long num = long.Parse(args[0]);
     long num = Convert.ToInt64(s);
 コマンド ライン引数 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 コンソール アプリケーションでコマンド ライン引数を使用する方法の例を次に示します。 アプリケーションは、実行時に引数を 1 つ受け取り、整数に変換し、その値の階乗を計算しています。 引数がない場合は、アプリケーションの正しい使用方法を説明 するメッセージを表示します。
コマンド プロンプトからアプリケーションをコンパイルして実行するには、次の手順を実行します。
1. 次のコードをテキスト エディターに貼り付け、Factorial.cs という名前でテキスト ファイルとして保存します。

    2. [スタート] 画面または [スタート] メニューから、Visual Studio の [開発者コマンド プロンプト] ウィンドウを開き、先ほ ど作成したファイルが含まれているフォルダーに移動します。
3. 次のコマンドを入力してアプリケーションをコンパイルします。
  // Add a using directive for System if the directive isn't already present.
public class Functions
{
    public static long Factorial(int n)
    {
        // Test for invalid input.
        if ((n < 0) || (n > 20))
        {
return -1; }
        // Calculate the factorial iteratively rather than recursively.
        long tempResult = 1;
        for (int i = 1; i <= n; i++)
        {
            tempResult *= i;
        }
        return tempResult;
    }
}
class MainClass
{
    static int Main(string[] args)
    {
        // Test if input arguments were supplied.
        if (args.Length == 0)
        {
            Console.WriteLine("Please enter a numeric argument.");
            Console.WriteLine("Usage: Factorial <num>");
            return 1;
}
        // Try to convert the input arguments to numbers. This will throw
        // an exception if the argument is not a number.
        // num = int.Parse(args[0]);
        int num;
        bool test = int.TryParse(args[0], out num);
        if (!test)
        {
            Console.WriteLine("Please enter a numeric argument.");
            Console.WriteLine("Usage: Factorial <num>");
            return 1;
}
        // Calculate factorial.
        long result = Functions.Factorial(num);
        // Print result.
        if (result == -1)
            Console.WriteLine("Input must be >= 0 and <= 20.");
        else
            Console.WriteLine($"The Factorial of {num} is {result}.");
return 0; }
}
// If 3 is entered on command line, the
// output reads: The factorial of 3 is 6.

        アプリケーションにコンパイル エラーがなければ、Factorial.exe という名前の実行可能ファイルが作成されます。 4. 3 の階乗を計算する次のコマンドを入力します。
Factorial 3
5. 次の出力が生成されます: The factorial of 3 is 6.
関連項目
System.Environment
C# プログラミング ガイド
Main() とコマンドライン引数 コマンド ライン引数を表示する方法 Main() の戻り値
クラス
      NOTE
Visual Studio でアプリケーションを実行する場合、「[デバッグ] ページ (プロジェクト デザイナー)」のコマンド ライン引数を指定できます。
  csc Factorial.cs
 
    実行可能ファイルに対してコマンド ラインで指定した引数には、 Main に対する省略可能なパラメーターを介してアクセスでき ます。 引数は、文字列の配列の形式で指定します。 配列の各要素には、1 つの引数が格納されます。 引数間の空白は削 除されます。 たとえば、架空の実行可能ファイルを呼び出すためのコマンド ラインの例を次に示します。
MAIN
   executable.exe a b c
  "a" "b" "c"
   executable.exe one two
  "one" "two"
    executable.exe "one two" three
  "one two" "three"
     NOTE
Visual Studio でアプリケーションを実行する場合は、[デバッグ] ページ (プロジェクト デザイナー) でコマンド ライン引数を指定できます。
 例
この例は、コマンド ライン アプリケーションに渡されるコマンド ライン引数を示しています。 次の出力は、上の表の最初のエントリ に対するものです。
    class CommandLine
{
    static void Main(string[] args)
    {
} }
// The Length property provides the number of array elements.
Console.WriteLine($"parameter count = {args.Length}");
for (int i = 0; i < args.Length; i++)
{
    Console.WriteLine($"Arg[{i}] = [{args[i]}]");
}
/* Output (assumes 3 cmd line args):
    parameter count = 3
    Arg[0] = [a]
    Arg[1] = [b]
    Arg[2] = [c]
*/
 コマンド ライン引数を表示する方法 (C# プログ
ラミング ガイド) 2020/11/02 • • Edit Online
 
     関連項目
C# プログラミング ガイド
csc.exe を使用したコマンド ラインからのビルド Main() とコマンドライン引数
Main() の戻り値

      Main メソッドは void を返すことができます。
int を返すこともできます。
Main からの戻り値を使用しない場合は、 void を返すと少し簡単なコードにすることができます。 ただし、整数値を返すこと によって、プログラムが状態の情報を、実行可能ファイルを呼び出す他のプログラムまたはスクリプトに伝達することができます。
Main からの戻り値は、プロセスの終了コードとして扱われます。 void が Main から返された場合、終了コードは暗黙的に 0 になります。 次の例では、 Main からの戻り値にアクセスする方法を示します。
例
この例では、.NET Core コマンドライン ツールを使用します。 .NET Core コマンドライン ツールに慣れていない場合は、この概
要の記事を参照してください。
program.csの Main メソッドを次のように変更します。
    static void Main()
{
//... }
     static int Main()
{
//...
return 0; }
     // Save this program as MainReturnValTest.cs.
class MainReturnValTest
{
    static int Main()
    {
//...
return 0; }
}
 プログラムをWindowsで実行する場合、Main 関数からの戻り値はすべて1つの環境変数に格納されます。この環境変数 を取得するには、バッチファイルから ERRORLEVEL を使用するか、PowerShellから $LastExitCode を使用します。
dotnetCLIの dotnet build コマンドを使用してアプリケーションを構築できます。
次に、アプリケーションを実行して結果を表示する PowerShell スクリプトを作成します。 次のコードをテキスト ファイルに貼り付 け、プロジェクトが保存されているフォルダーに test.ps1 として保存します。 PowerShell プロンプトに「 test.ps1 」と入力して PowerShell スクリプトを実行します。
コードがゼロを返すため、バッチ ファイルで成功が報告されます。 ただし、MainReturnValTest.cs が 0 以外の値を返すように 変更して、プログラムを再コンパイルする場合、PowerShell スクリプトの後続の実行では失敗が報告されます。
     Main() の戻り値 (C# プログラミング ガイド) 2021/03/08 • • Edit Online
 
   dotnet run
     if ($LastExitCode -eq 0) {
    Write-Host "Execution succeeded"
} else {
    Write-Host "Execution Failed"
}
Write-Host "Return value = " $LastExitCode
 出力例
非同期 Main の戻り値
非同期Mainの戻り値によって、Main 内の非同期メソッドを呼び出すために必要な定型コードを、コンパイラで生成される コードに移動します。 以前のバージョンでは、このコンストラクトを出力して非同期コードを呼び出し、非同期操作が完了する までプログラムが実行されるようにする必要がありました。
    Execution succeeded
Return value = 0
     public static void Main()
{
    AsyncConsoleWork().GetAwaiter().GetResult();
}
private static async Task<int> AsyncConsoleWork()
{
    // Main body here
return 0; }
 現在のバージョンでは、以下のように書き換えられるようになりました。
新しい構文を使用すると、コンパイラから常に正しいコードが生成されるという利点があります。 コンパイラで生成されたコード
アプリケーションのエントリポイントから Task または Task<int> が返されると、コンパイラによって、アプリケーションコードで宣 言されたエントリ ポイント メソッドを呼び出す新しいエントリ ポイントが生成されます。 このエントリ ポイント名が
$GeneratedMain だとすると、これらのエントリポイントについて次のコードが生成されます。
static Task Main() の結果、 private static void $GeneratedMain() => Main().GetAwaiter().GetResult(); と同
    static async Task<int> Main(string[] args)
{
    return await AsyncConsoleWork();
}
       等のコードが生成されます。
 static Task Main(string[])
  private static void $GeneratedMain(string[] args) => Main(args).GetAwaiter().GetResult();
 生成されます。
の結果、
と同等のコードが
    static Task<int> Main()
の結果、
private static int $GeneratedMain() => Main().GetAwaiter().GetResult();
  
     と同等のコードが生成されます。
 static Task<int> Main(string[])
  private static int $GeneratedMain(string[] args) => Main(args).GetAwaiter().GetResult();
 成されます。
関連項目
C# プログラミング ガイド
C# リファレンス
Main() とコマンドライン引数 コマンド ライン引数を表示する方法
の結果、
と同等のコードが生
    NOTE
この例の Main メソッドで async 修飾子を使用した場合、同じコードが生成されます。
 
              このセクションでは、C# 言語でのプログラミングの概念について説明します。 このセクションの内容
TITLE
.NET のアセンブリ
Async および Await を使用した非同期プログラミング (C#)
属性 (C#)
共変性と反変性 (C#)
式ツリー (C#)
反復子 (C#)
アセンブリを作成および使用する方法について説明します。
C# の async および await キーワードを使用して非同期ソリューション を記述する方法を説明します。 チュートリアルが含まれています。
属性を使用して、型、フィールド、メソッド、プロパティなどのプログラミン グ要素に関する追加情報を指定する方法について説明します。
インターフェイスやデリゲートでのジェネリック型パラメーターの暗黙の型 変換を有効にする方法について説明します。
式ツリーを使用して、実行可能コードの動的変更を有効にする方法 について説明します。
コレクションのステップ実行に使用し、要素を一度に 1 つずつ返す、 反復子について説明します。
               コレクション (C#)
   .NET で提供されているコレクションの種類のいくつかについて説明しま す。 単純なコレクションおよびキーと値のペアのコレクションを使用する 方法を示します。
            統合言語クエリ (LINQ) (C#)
   C# の言語構文の強力なクエリ機能と、リレーショナル データベース、 XML ドキュメント、データセット、およびインメモリ コレクションを照会す るためのモデルについて説明します。
   リフレクション (C#)
  リフレクションを使用して、動的に型のインスタンスを作成する方法、 作成したインスタンスを既存のオブジェクトにバインドする方法、または 既存のオブジェクトから型を取得して、そのオブジェクトのメソッドを呼 び出したり、フィールドやプロパティにアクセスしたりする方法について説 明します。
 シリアル化 (C#)
関連項目
パフォーマンスに関するヒント
バイナリ、XML、および SOAP のシリアル化の主要な概念について説 明します。
アプリケーションのパフォーマンスの向上に役立つ基本的な規則につい て説明します。
        プログラミングの概念 (C#) 2020/11/02 • • Edit Online
 
    タスク非同期プログラミング モデル (TAP) では、非同期コードに対する抽象化が提供されます。 コードは、通常と同じようにス テートメントのシーケンスとして記述します。 次のステートメントが始まる前に、各ステートメントが完了するものとして、コードを読 むことができます。 これらのステートメントの一部は処理を開始し、進行中の作業を表す Task を返す可能性があるので、コンパ イラではいくつかの変換が実行されます。
それがこの構文の目的です。コードは、順番に実行されるステートメントのように書かれていますが、外部リソースの割り当てとタ スク完了のタイミングに基づいて、はるかに複雑な順序で実行されます。 それは、人が非同期のタスクを含むプロセスの指示を 与えるのと似ています。 この記事では、朝食を作る手順を例として使用し、 async キーワードと await キーワードによって、 一連の非同期命令を含むコードがどのように理解しやすくなるのかを見ていきます。 朝食を作る方法について説明する次の一 覧のような手順を作成します。
1. コーヒーをカップに注ぐ。
2. フライパンを熱し、卵を 2 個焼く。 3. ベーコンを 3 切れ焼く。
4. パンを 2 枚焼く。
5. トーストにバターとジャムを塗る。 6. オレンジ ジュースをグラスに注ぐ。
料理の経験があれば、これらの手順を非同期的に実行するでしょう。 卵用のフライパンを熱し始めてから、ベーコンを始めま す。 トースターにパンを入れたら、卵を焼き始めます。 プロセスの各ステップで、あるタスクを開始したら、準備ができているタスク に注意を向けます。
朝食の準備は、並列ではない非同期作業のよい例です。 1 人 (つまり 1 つのスレッド) で、これらすべてのタスクを処理できま す。 朝食の例を続けると、1 人で、最初の作業が完了する前に次の作業を開始して、非同期に朝食を作ることができます。 調理はそれを監視している人がいるかどうかに関係なく進行します。 卵用のフライパンを熱し始めたらすぐに、ベーコンを焼き始 めることができます。 ベーコンを焼き始めたら、パンをトースターに入れることができます。
並列アルゴリズムの場合は、複数の料理人 (つまりスレッド) が必要です。 1 人は卵を焼き、1 人はベーコンを焼く、といった具 合です。 それぞれは、1 つのタスクだけに集中します。 各料理人 (つまりスレッド) は、ベーコンを裏返すことができるようになるま で、またはトーストが飛び出すまで待つ間は、同期的にブロックされます。
それでは、これと同じ命令が C# ステートメントとして書かれている場合を考えてみましょう。
async および await を使用した非同期プログラミ
ング
2020/11/02 • • Edit Online
     using System;
using System.Threading.Tasks;
namespace AsyncBreakfast
{
    class Program
    {
        static void Main(string[] args)
        {
            Coffee cup = PourCoffee();
            Console.WriteLine("coffee is ready");
            Egg eggs = FryEggs(2);
            Console.WriteLine("eggs are ready");
Bacon bacon = FryBacon(3);
Console.WriteLine("bacon is ready");

Console.WriteLine("bacon is ready");
      Toast toast = ToastBread(2);
    ApplyButter(toast);
    ApplyJam(toast);
    Console.WriteLine("toast is ready");
    Juice oj = PourOJ();
    Console.WriteLine("oj is ready");
    Console.WriteLine("Breakfast is ready!");
}
private static Juice PourOJ()
{
    Console.WriteLine("Pouring orange juice");
    return new Juice();
}
private static void ApplyJam(Toast toast) =>
    Console.WriteLine("Putting jam on the toast");
private static void ApplyButter(Toast toast) =>
    Console.WriteLine("Putting butter on the toast");
private static Toast ToastBread(int slices)
{
    for (int slice = 0; slice < slices; slice++)
    {
        Console.WriteLine("Putting a slice of bread in the toaster");
    }
    Console.WriteLine("Start toasting...");
    Task.Delay(3000).Wait();
    Console.WriteLine("Remove toast from toaster");
    return new Toast();
}
private static Bacon FryBacon(int slices)
{
    Console.WriteLine($"putting {slices} slices of bacon in the pan");
    Console.WriteLine("cooking first side of bacon...");
    Task.Delay(3000).Wait();
    for (int slice = 0; slice < slices; slice++)
    {
        Console.WriteLine("flipping a slice of bacon");
    }
    Console.WriteLine("cooking the second side of bacon...");
    Task.Delay(3000).Wait();
    Console.WriteLine("Put bacon on plate");
    return new Bacon();
}
private static Egg FryEggs(int howMany)
{
    Console.WriteLine("Warming the egg pan...");
    Task.Delay(3000).Wait();
    Console.WriteLine($"cracking {howMany} eggs");
    Console.WriteLine("cooking the eggs ...");
    Task.Delay(3000).Wait();
    Console.WriteLine("Put eggs on plate");
    return new Egg();
}
private static Coffee PourCoffee()
{
    Console.WriteLine("Pouring coffee");
    return new Coffee();
  }

  同期的に準備された朝食は、合計が個々のタスクの合計であるため、約 30 分かかりました。
コンピューターによって、人と同じように命令が解釈されることはありません。 コンピューターでは、作業が完了するまで各ステート メントはブロックされ、完了すると次のステートメントに進みます。 それではおいしい朝食はできません。 後のタスクは、前のタスク が完了するまで開始されません。 朝食の支度でこんなことをしていると、ずっと長い時間がかかり、提供される前に冷めてしまう 料理もあるでしょう。
上のような手順をコンピューターに非同期に実行させたい場合は、非同期のコードを書く必要があります。
今日書いているプログラムでは、このようなことを考慮することが重要です。 クライアント プログラムを書くときは、ユーザー入力に 対する UI の応答性をよくする必要です。 Web からデータをダウンロードしている間、電話がフリーズしたようになるアプリケーショ ンではいけません。 サーバーのプログラムを書くときは、スレッドがブロックされては困ります。 それらのスレッドは、他の要求を処理 しているかもしれません。 非同期の代替手段が存在する場合に同期コードを使用すると、低コストでスケールアウトする能力が 低下してしまいます。 ブロックされたスレッドに料金を支払うことになります。
よくできた最新のアプリケーションには、非同期コードが必要です。 言語のサポートがない場合、非同期コードを書くには、コー ルバック、完了イベント、またはコードの本来の意図をわかりにくくしてしまうような他の手段が必要でした。 同期コードの利点 は、段階的なアクションによりスキャンと理解が容易なことです。 従来の非同期モデルでは、開発者はコードの基本的な処理 ではなく、コードの非同期的性質に注目することを余儀なくされました。
ブロックするのではなく待機する
上記のコードは、非同期的な操作を実行するために同期的なコードを作成するという、不適切な手法の例です。 このような コードを書くと、それを実行するスレッドは、他の作業を行うことができません。 何らかのタスクの処理中は割り込まれません。 パ ンを入れた後でトースターをじっと見詰めているようなものです。 トーストが飛び出すまで、誰かから話し掛けられても無視するで
    NOTE
Coffee 、 Egg 、 Bacon 、 Toast 、および Juice クラスは空です。 これらは、デモンストレーション目的の単なるマーカー クラスであ り、プロパティは含まれず、その他の目的はありません。
     }
} }
 
   しょう。
タスクの実行中にスレッドをブロックしないように、このコードを更新することから始めましょう。 await キーワードを使用すると、ブ ロックしない方法でタスクを開始し、タスクが完了したら実行を継続できます。 朝食作成コードの簡単な非同期バージョンは、 次のスニペットのようになります。
    static async Task Main(string[] args)
{
    Coffee cup = PourCoffee();
    Console.WriteLine("coffee is ready");
    Egg eggs = await FryEggsAsync(2);
    Console.WriteLine("eggs are ready");
    Bacon bacon = await FryBaconAsync(3);
    Console.WriteLine("bacon is ready");
    Toast toast = await ToastBreadAsync(2);
    ApplyButter(toast);
    ApplyJam(toast);
    Console.WriteLine("toast is ready");
    Juice oj = PourOJ();
    Console.WriteLine("oj is ready");
    Console.WriteLine("Breakfast is ready!");
}
     IMPORTANT
合計経過時間は、初期の同期バージョンとほぼ同じです。 このコードでは、非同期プログラミングの主要な機能のいくつかがまだ利用されて います。
     TIP
     FryEggsAsync
、 、 ToastBreadAsync のメソッド本体がすべて更新され、それぞれ Task<Egg> 、 Task<Bacon> が返されます。 メソッドは、元のバージョンから名前が変更され、"Async" サフィックスが含まれるようになっていま
FryBaconAsync
 、および
す。 これらの実装は、この記事で後述する最終バージョンの一部として表示されます。
Task<Toast>
 このコードでは、卵またはベーコンを調理している間、ブロックすることはありません。 ただし、このコードは他のタスクを開始しませ ん。 まだ、トースターにトーストを入れた後、トーストが飛び出すまで眺めています。 ただし、少なくとも誰かが注意を引こうとした ら反応するようにはなります。 複数の注文を受けるレストランでは、料理人は最初の朝食を作っている間に、別の朝食を作り 始めます。
この場合、開始してまだ完了していないタスクを待っている間、朝食作業スレッドはブロックされません。 一部のアプリケーション では、必要な変更はこれですべてです。 GUI アプリケーションは、この変更だけで引き続きユーザーに応答します。 ただし、この シナリオでは、これだけでは十分ではありません。 各コンポーネントのタスクを順番に実行したくはありません。 前のタスクの完了 を待機する前に、各コンポーネントのタスクを開始した方がよさそうです。
タスクを同時に開始する
多くのシナリオでは、複数の独立したタスクをすぐに開始する必要があります。 そうすれば、各タスクが完了したら、準備のできて いる他のタスクを続行できます。 朝食でたとえるなら、もっと早く朝食を準備できます。 また、すべての作業がほぼ同じタイミング で終了します。 できたての朝食を食べられます。
System.Threading.Tasks.Task および関連する型を使用して、進行中のタスクについて判断できます。 それを使用すると、実 際の朝食作成方法にさらに近いコードを記述できます。 卵、ベーコン、トーストの調理を同時に始めます。 それぞれでアクショ ンが必要になったら、そのタスクに注意を向け、次のアクションを行ってから、注意が必要な他のタスクを待ちます。

 タスクを開始し、作業を表すTaskオブジェクトを保持します。各タスクを await (待機)してから、結果を処理します。 朝食コードに対してこれらの変更を行いましょう。 最初のステップは、操作のタスクを開始するときに、それらを待機するのではな
く、保存することです。
    Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");
Task<Egg> eggsTask = FryEggsAsync(2);
Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Task<Bacon> baconTask = FryBaconAsync(3);
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");
Task<Toast> toastTask = ToastBreadAsync(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");
Console.WriteLine("Breakfast is ready!");
 次に、ベーコンと卵の await ステートメントを、メソッドの最後の朝食提供前に移動します。
    Coffee cup = PourCoffee();
Console.WriteLine("coffee is ready");
Task<Egg> eggsTask = FryEggsAsync(2);
Task<Bacon> baconTask = FryBaconAsync(3);
Task<Toast> toastTask = ToastBreadAsync(2);
Toast toast = await toastTask;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine("toast is ready");
Juice oj = PourOJ();
Console.WriteLine("oj is ready");
Egg eggs = await eggsTask;
Console.WriteLine("eggs are ready");
Bacon bacon = await baconTask;
Console.WriteLine("bacon is ready");
Console.WriteLine("Breakfast is ready!");
 
    非同期的に準備された朝食は、約 20 分かかりました。これは、いくつかのタスクを同時に実行できたことが理由です。
上のコードの方がより適切に動作します。 すべての非同期タスクを一度に開始します。 結果が必要なときにのみ、各タスクを 待機します。 上記のコードは、異なるマイクロサービスに要求を行って 1 つのページに結果をまとめる Web アプリケーションの コードに似ているかもしれません。すべての要求をすぐに行った後、すべてのタスクを await して、Webページを作成します。
タスクの合成
トーストを除き、朝食のすべての準備が同時に整います。 トーストの作成は、非同期操作 (パンを焼く) と同期操作 (バターと
ジャムを塗る) の合成です。 このコードの更新では、重要な概念が示されています。
上記のコードでは、Task または Task<TResult> オブジェクトを使用して実行中のタスクを保持できることを示しました。 結果を 使用する前に、各タスクを await します。次のステップは、他の作業の組み合わせを表すメソッドを作成することです。朝食 を提供するには、バターとジャムを塗る前にパンを焼くタスクを待機します。 次のコードでその作業を表すことができます。
    IMPORTANT
非同期操作とその後の同期操作の合成は、非同期操作です。 言い方を変えれば、操作の一部が非同期である場合、操作全体が非同 期になります。
     static async Task<Toast> MakeToastWithButterAndJamAsync(int number)
{
    var toast = await ToastBreadAsync(number);
    ApplyButter(toast);
    ApplyJam(toast);
    return toast;
}
 上のメソッドのシグニチャには async 修飾子が付いています。それにより、コンパイラに対して、このメソッドに await ステート メントが含まれることが通知されます。それには非同期操作が含まれています。 このメソッドは、パンを焼いてからバターとジャム を塗るタスクを表します。 このメソッドからは、これら 3 つの操作の合成を表す Task<TResult> が返されます。 これで、コードの メイン ブロックは次のようになります。

     この変更では、非同期コードを使用するための重要な手法が示されています。 タスクを返す新しいメソッドに操作を分離するこ とで、タスクを合成します。 そのタスクを待機するタイミングを選択できます。 他のタスクを同時に開始できます。
タスクを効率的に待機する
上記のコードの最後にある一連の await ステートメントは、 Task クラスのメソッドを使用することによって改良できます。 それ らの API の 1 つは WhenAll であり、これにより次のコードで示すように、引数リストのすべてのタスクが完了すると完了する Task が返されます。
もう1つのオプションは、WhenAnyを使用することです。これは、引数のいずれかが完了すると完了する Task<Task> が返さ れます。 返されたタスクを待機して、既に完了したことを把握できます。 次のコードでは、WhenAny を使用して最初のタスク が完了するのを待った後、その結果を処理する方法が示されています。 完了したタスクの結果を処理した後、 WhenAny に渡 すタスクの一覧からその完了したタスクを削除します。
    await Task.WhenAll(eggsTask, baconTask, toastTask);
Console.WriteLine("eggs are ready");
Console.WriteLine("bacon is ready");
Console.WriteLine("toast is ready");
Console.WriteLine("Breakfast is ready!");
      static async Task Main(string[] args)
{
    Coffee cup = PourCoffee();
    Console.WriteLine("coffee is ready");
    var eggsTask = FryEggsAsync(2);
    var baconTask = FryBaconAsync(3);
    var toastTask = MakeToastWithButterAndJamAsync(2);
    var eggs = await eggsTask;
    Console.WriteLine("eggs are ready");
    var bacon = await baconTask;
    Console.WriteLine("bacon is ready");
    var toast = await toastTask;
    Console.WriteLine("toast is ready");
    Juice oj = PourOJ();
    Console.WriteLine("oj is ready");
    Console.WriteLine("Breakfast is ready!");
}
 
    すべてを変更した後、コードの最終バージョンは のようになります。
     var breakfastTasks = new List<Task> { eggsTask, baconTask, toastTask };
while (breakfastTasks.Count > 0)
{
    Task finishedTask = await Task.WhenAny(breakfastTasks);
    if (finishedTask == eggsTask)
    {
        Console.WriteLine("eggs are ready");
    }
    else if (finishedTask == baconTask)
    {
        Console.WriteLine("bacon is ready");
    }
    else if (finishedTask == toastTask)
    {
        Console.WriteLine("toast is ready");
    }
    breakfastTasks.Remove(finishedTask);
}
 using System;
using System.Collections.Generic;
using System.Threading.Tasks;
namespace AsyncBreakfast
{
    class Program
    {
        static async Task Main(string[] args)
        {
            Coffee cup = PourCoffee();
            Console.WriteLine("coffee is ready");
            var eggsTask = FryEggsAsync(2);
            var baconTask = FryBaconAsync(3);
            var toastTask = MakeToastWithButterAndJamAsync(2);
            var breakfastTasks = new List<Task> { eggsTask, baconTask, toastTask };
            while (breakfastTasks.Count > 0)
            {
                Task finishedTask = await Task.WhenAny(breakfastTasks);
                if (finishedTask == eggsTask)
                {
                    Console.WriteLine("eggs are ready");
                }
                else if (finishedTask == baconTask)
                {
                    Console.WriteLine("bacon is ready");
                }
                else if (finishedTask == toastTask)
                {
                    Console.WriteLine("toast is ready");
                }
                breakfastTasks.Remove(finishedTask);
            }
            Juice oj = PourOJ();
            Console.WriteLine("oj is ready");
            Console.WriteLine("Breakfast is ready!");
}
        static async Task<Toast> MakeToastWithButterAndJamAsync(int number)
        {
            var toast = await ToastBreadAsync(number);
            ApplyButter(toast);

  } }
ApplyJam(toast);
    return toast;
}
private static Juice PourOJ()
{
    Console.WriteLine("Pouring orange juice");
    return new Juice();
}
private static void ApplyJam(Toast toast) =>
    Console.WriteLine("Putting jam on the toast");
private static void ApplyButter(Toast toast) =>
    Console.WriteLine("Putting butter on the toast");
private static async Task<Toast> ToastBreadAsync(int slices)
{
    for (int slice = 0; slice < slices; slice++)
    {
        Console.WriteLine("Putting a slice of bread in the toaster");
    }
    Console.WriteLine("Start toasting...");
    await Task.Delay(3000);
    Console.WriteLine("Remove toast from toaster");
    return new Toast();
}
private static async Task<Bacon> FryBaconAsync(int slices)
{
    Console.WriteLine($"putting {slices} slices of bacon in the pan");
    Console.WriteLine("cooking first side of bacon...");
    await Task.Delay(3000);
    for (int slice = 0; slice < slices; slice++)
    {
        Console.WriteLine("flipping a slice of bacon");
    }
    Console.WriteLine("cooking the second side of bacon...");
    await Task.Delay(3000);
    Console.WriteLine("Put bacon on plate");
    return new Bacon();
}
private static async Task<Egg> FryEggsAsync(int howMany)
{
    Console.WriteLine("Warming the egg pan...");
    await Task.Delay(3000);
    Console.WriteLine($"cracking {howMany} eggs");
    Console.WriteLine("cooking the eggs ...");
    await Task.Delay(3000);
    Console.WriteLine("Put eggs on plate");
    return new Egg();
}
private static Coffee PourCoffee()
{
    Console.WriteLine("Pouring coffee");
    return new Coffee();
}
   
   非同期に準備された朝食の最終バージョンは、約 15 分かかりました。これは、いくつかのタスクを同時に実行でき、コードで一 度に複数のタスクを監視して必要なときにのみアクションを実行できるようになったためです。
この最後のコードは非同期です。 人が朝食を作る方法が、より正確に反映されています。 上のコードを、この記事の最初の コード サンプルと比較してください。 中核となるアクションはコードを読むと明らかです。 このコードは、この記事の最初にある朝 食の作成手順と同じように読むことができます。 async および await の言語機能により、手順書に従うためにすべての人が 行う変換が提供されます。つまり、可能になったらタスクを開始し、タスク完了の待機をブロックしないようにします。
次の手順
タスク非同期プログラミング モデルについて

                パフォーマンスのボトルネックを回避しアプリケーション全体の応答性を向上させるために、非同期プログラミングを使用できます。 ただ、非同期アプリケーションを作成する従来の方法は複雑で、プログラムの作成、デバッグ、保守が困難な場合があります。
C# 5 では、.NET Framework 4.5 以降、.NET Core および Windows ランタイムの非同期サポートを利用した "非同期プロ グラミング" と呼ばれる簡単な方法が導入されました。 コンパイラがこれまで開発者が行っていた難しい作業を実行し、アプリ ケーションは同期コードに類似した論理構造を保持します。 その結果、わずかな作業量で非同期プログラミングのすべての利 点を得られます。
このトピックでは、非同期プログラミングをいつ、どのように使用するかの概要を紹介します。詳細と例を含むをサポート トピックへ のリンクもあります。
非同期による応答性の改善
Web アクセスなど、ブロックされる可能性がある操作には、非同期が必要となります。 Web リソースへのアクセスには、遅延が 発生することがあります。 このような操作が同期処理内でブロックされた場合、アプリケーション全体が待機する必要がありま す。 非同期処理では、ブロックする可能性のあるタスク終了するまで、アプリケーションは Web リソースに依存しない他の操作 を続行できます。
非同期プログラミングによって応答性を向上する一般的な領域を、次の表に示します。 .NET および Windows ランタイムの API の一覧には、非同期のプログラミングをサポートするメソッドが含まれます。
.NET WINDOWS
Web アクセス HttpClient Windows.Web.Http.HttpClient SyndicationClient
         ファイルの処理
  JsonSerializer StreamReader StreamWriter XmlReader XmlWriter
  StorageFile
   イメージの処理
      MediaCapture BitmapEncoder BitmapDecoder
 WCF プログラミング 同期操作と非同期操作
非同期性は、UI スレッドにアクセスするアプリケーションに対して特に有効です。これは、すべての UI 関連のアクティビティが一 般的に 1 つのスレッドを共有するためです。 同期アプリケーションでは、1 つのプロセスがブロックされるとすべてがブロックされま す。 アプリケーションが応答を停止するため、待機状態であるとは考えずに失敗したと結論付けることもあります。
非同期メソッドを使用すると、アプリケーションは UI に応答し続けます。 たとえば、ウィンドウのサイズ変更や最小化を実行した り、アプリケーション処理の完了待たずに、アプリケーションを閉じたりできます。
非同期ベースの方法は、非同期操作を設計する場合に選択できるオプションの一覧に、自動送信に相当するものを追加しま す。 つまり、開発者の少しの作業量で、従来の非同期プログラミングのすべての利点を取得できます。
   非同期メソッドの作成が簡単
非同期プログラミング モデル
2020/11/02 • • Edit Online
 
    C# の async キーワードと await キーワードは、非同期プログラミングの中核です。 これら 2 つのキーワードを使用すると、同期 メソッドの作成とほぼ同様の容易さで、.NET Framework、.NET Core または Windows ランタイムのリソースを使用して非同 期メソッドを作成できます。 async キーワードを使用して定義する非同期メソッドは、"asyncメソッド"として参照されます。
async メソッドの例を次に示します。 コードのほとんどは、見たことのあるものと思います。
ダウンロードできる Windows Presentation Foundation (WPF) の完全な例については、「C# の async および await を使用
した非同期プログラミング」を参照してください。
    public async Task<int> GetUrlContentLengthAsync()
{
    var client = new HttpClient();
    Task<string> getStringTask =
        client.GetStringAsync("https://docs.microsoft.com/dotnet");
    DoIndependentWork();
    string contents = await getStringTask;
    return contents.Length;
}
void DoIndependentWork()
{
    Console.WriteLine("Working...");
}
 上のサンプルからいくつかの方法を習得できます。メソッドシグネチャから始めます。これには async 修飾子が含まれていま す。戻り値の型は Task<int> です(他のオプションについては"戻り値の型"セクションを参照してください)。メソッド名の末尾 は Async です。メソッドの本体で、 により が返されます。つまり、タスクに await を指定 すると、 string が与えられます ( )。 タスクを待つ前に、 の string に依存しない作業を実行で きます。
await 演算子に特に注意してください。これは GetUrlContentLengthAsync を中断させます。
   GetStringAsync
   contents
 は が完了するまで続行できません。 の呼び出し元に戻されます。
その間、コントロールは
getStringTask が完了すると、コントロールがここに戻ります。
   次に、 await 演算子は getStringTask から string の結果を取得します。 returnステートメントによって整数の結果が指定されます。 GetUrlContentLengthAsync を待つメソッドは長さ値を取得しま
す。
GetUrlContentLengthAsync に GetStringAsync を呼び出してその完了を待機する間で実行できる作業がない場合、次の
1 つのステートメントで呼び出しと待機をするようにコードを簡略化できます。
次の特徴は、前の例を非同期のメソッドにするための概略です。 メソッドシグネチャは async 修飾子を含みます。 非同期メソッドの名前は、慣例により「Async」というサフィックスで終わります。 戻り値の型は次のいずれかになります:
    メソッドが、オペランドに TResult 型を持つステートメントを戻す場合、Task<TResult>。
Task<string>
 GetStringAsync
  GetUrlContentLengthAsync
getStringTask
 GetUrlContentLengthAsync
  string contents = await client.GetStringAsync("https://docs.microsoft.com/dotnet");
 
      メソッドがステートメントを戻さない、またはオペランドを持たないステートメントを戻す場合、Task。 非同期のイベント ハンドラーを作成する場合、 void 。
GetAwaiter メソッドがあるその他の任意の型(C#7.0以降)。 詳細については、「戻り値の型およびパラメーター」セクションを参照してください。
メソッドには、通常は1つ以上の await 式があり、待機中の非同期操作が完了するまでメソッドを続行できないポイ ントをマークします。 この間メソッドは中断し、メソッドの呼び出し元にコントロールを戻します。 このトピックの次のセクショ ンでは、中断ポイントで何が発生するかを説明します。
非同期のメソッドでは、指定のキーワードと型を使用して何を実行するかを示すと、コンパイラがその作業を引き継ぎます。作業 には、中断されたメソッドの待機ポイントにコントロールが戻された場合に実行される作業を、継続的に追跡することも含まれま す。 ループおよび例外処理など一部のルーチンのプロセスは、従来の非同期コードによる操作が困難な場合があります。 非 同期のメソッドでは、同期ソリューションの場合と同様にこれらの要素を記述すると、問題が解決します。
以前のバージョンの .NET Framework での非同期性の詳細については、「TPL と従来の .NET Framework 非同期プログラミ ング」を参照してください。
非同期メソッドでの動作
非同期プログラミングでは理解が必要な最も重要なことは、コントロール フローがどのようにメソッドからのメソッドに移動するかと いうことです。 次の図では、このプロセスについて説明します。
図の番号は次の手順に対応しています。呼び出し元メソッドで非同期メソッドを呼び出すときに始まります。
1. 呼び出し元メソッドで、 GetUrlContentLengthAsync 非同期メソッドを呼び出して待機します。
2. GetUrlContentLengthAsync は HttpClient インスタンスを作成し、文字列として Web サイトのコンテンツをダウンロー ドする GetStringAsync 非同期メソッドを呼び出します。
3. GetStringAsync に何かが発生するとプロセスが中断します。 Web サイトからのダウンロード処理、または他のブロック しているアクティビティを待機する必要が考えられます。 リソースのブロックを回避するために、 GetStringAsync は呼び 出し元の GetUrlContentLengthAsync にコントロールを戻します。
       
                GetStringAsync
TResult
GetUrlContentLengthAsync
       getStringTask
GetStringAsync
     4.
5. 6.
は   が文字列である Task<TResult> を返し、 変数にタスクを割り当てます。 タスクには
し、作業が完了すると実際の文字列値を生成するコミットメントがあります。
getStringTask が待機しないため、 は い他の作業を続行できます。 この作業は同期メソッド
は への呼び出しの進行中のプロセスを表
からの最終結果に依存しな への呼び出しによって表されます。
GetUrlContentLengthAsync
GetStringAsync
 DoIndependentWork
 DoIndependentWork は、作業を実行し、呼び出し元に戻る同期メソッドです。
は getStringTask からの結果なしで実行できる作業を使い果たしました。
は次に、ダウンロードする文字列の長さを計算しますが、メソッドに文字列が戻されるま で、メソッドはその値を計算できません。
そのため、GetUrlContentLengthAsync はawait演算子を使用してその進行を中断し、 を呼び出したメソッドにコントロールを戻します。 GetUrlContentLengthAsync は呼び出し元に を返しま す。 タスクは、ダウンロードされた文字列の長さの整数値を生成することの保証を表します。
 GetUrlContentLengthAsync
  GetUrlContentLengthAsync
   GetUrlContentLengthAsync
  Task<int>
    NOTE
   GetStringAsync
コントロールは 出された非同期プロセスの ない場合に、無駄になることがあります。
(結果として
) が に残ります。
が既に完了していて、
がそれを待機する前に完了した場合、 を中断してから戻ることは、呼び
で最終結果を待つ必要が
getStringTask
GetUrlContentLengthAsync
  GetUrlContentLengthAsync
GetUrlContentLengthAsync
  getStringTask
GetUrlContentLengthAsync
       7.
8.
呼び出し元メソッドの内部で、処理パターンが続行されます。呼び出し元は GetUrlContentLengthAsync からの結果 に依存しない他の作業をすることもあり、または直ちに待機状態になることもあります。 呼び出元メソッドで
GetUrlContentLengthAsync を待機し、 GetUrlContentLengthAsync で GetStringAsync を待機します。
GetStringAsync が完了し、文字列の結果を生成します。 文字列の結果は、 GetStringAsync への呼び出しによっ て、意図した形式では戻されません。 (メソッドは既に手順 3 のタスクで戻されていることに注意してください)。代わり に、文字列の結果は、getStringTask メソッドの完了を表すタスク内に格納されます。await演算子は、
getStringTask から結果を取得します。代入ステートメントは contents に取得された結果を割り当てます。
に文字列の結果がある場合、メソッドは文字列の長さを計算できます。 次に
の作業も完了し、待機しているイベント ハンドラーが再開できます。 トピックの最後にあ る完全なサンプルでは、イベント ハンドラーが長さの結果の値を取得して印刷することを確認できます。 非同期プログラ ミングの経験がない場合、同期および非同期の動作の違いを、少し時間を割いて考慮してください。 同期メソッドは作
業が完了すると戻されます (手順 5.) が、非同期のメソッドは、作業が中断されるとタスクの値を戻します。(手順 3. お よび 6.) 非同期のメソッドが最終的に作業を完了すると、タスクは完了とマークされ、結果が存在する場合はタスクに格 納されます。
    GetUrlContentLengthAsync
  GetUrlContentLengthAsync
API の非同期メソッド
非同期のプログラミングをサポートする GetStringAsync などのメソッドがどこにあるのかということです。.NETFramework4.5 以降および.NETCoreには、async および await で使用する多くのメンバーが含まれています。メンバー名に付記されてい る "Async" というサフィックスと、その戻り値の型である Task または Task<TResult> から識別できます。 たとえば、
System.IO.Stream のクラスには、同期メソッドのCopyTo、Read、およびWriteと共に、CopyToAsync、ReadAsyncおよび WriteAsync という同期メソッドが含まれています。
Windowsランタイムにも、Windowsアプリの async と await で使用できる多くのメソッドが含まれています。詳しくは、 UWP 開発について「Threading and async programming」(スレッドと非同期プログラミング) を、以前のバージョンの Windows ランタイムを使用している場合は「非同期プログラミング (Windows ストア アプリ)」と「クイック スタート: C# または Visual Basic での非同期 API の呼び出し」をご覧ください。
  
           スレッド
非同期のメソッドは非ブロッキング操作を意図しています。非同期のメソッドの await 式では、待機中のタスクの実行時に現 在のスレッドはブロックされません。 代わりに、式はメソッドの残りの部分の継続を登録し、非同期のメソッドの呼び出し元にコン トロールを戻します。
async および await キーワードは、追加のスレッドを作成する要因にはなりません。 非同期のメソッドは自分自身のスレッド で実行しないため、マルチスレッドは必要ありません。 メソッドは、現在の同期コンテキストで実行し、メソッドがアクティブな場合 に限りスレッドの時間を使用します。 Task.Run を使用して、CPU バインディングの作業をバックグラウンド スレッドに移動できま すが、バックグラウンド スレッドは、結果を待つだけのプロセスを援助しません。
非同期プログラミングへの非同期ベースのアプローチは、ほぼすべてのケースの既存のアプローチに推奨されます。 特に、このア プローチはコードがシンプルで競合状態からの保護の必要がないため、I/O バウンドの操作では、BackgroundWorker クラスよ りも優れています。 Task.Run メソッドと組み合わせると、非同期のプログラミングは CPU バインディングの操作に関して BackgroundWorkerよりも優れています。これは、非同期のプログラミングの場合、Task.Run でスレッドプールに転送する作 業から、コードの実行の調整の詳細が分離されるためです。
async と await
async 修飾子を使用して、メソッドが非同期メソッドであることを指定すると、次の 2 つの機能が有効になります。
マークされた非同期のメソッドは中断ポイントを示すためにawaitを使用できます。 await 演算子は、非同期のメソッ ドが、待機中の非同期のプロセスが完了するまでこのポイント以降を続行できないことを、コンパイラに指示します。 そ の間、コントロールは非同期のメソッドの呼び出し元に戻されます。
非同期のメソッドの await 式での中断は、メソッドからの終了を意図するものではなく、 finally ブロックは実行され ません。
マークされた非同期のメソッド自体は、呼び出し元のメソッドによって待機できます。
非同期のメソッドには、通常の await 演算子が1つ以上ありますが、await 式がない場合もコンパイラエラーの原因にはな りません。 中断ポイントをマークするために非同期のメソッドが await 演算子を使用しない場合、 async 修飾子が存在して も、メソッドは同期メソッドと同様に実行されます。 このようなメソッドには、コンパイラが警告を発行します。
async と await は、コンテキストキーワードです。詳細およびサンプルについては、次のトピックを参照してください: async
await
戻り値の型およびパラメーター
非同期メソッドは、通常TaskまたはTask<TResult>を返します。非同期のメソッド内で、await 演算子は、他の非同期の メソッドへの呼び出しから戻されたタスクに適用されます。
メソッドが、 TResult 型のオペランドを指定する return ステートメントを含む場合、Task<TResult> を戻り値の型として指定 します。
メソッドに Return ステートメントがない場合、または Return ステートメントがオペランドを戻さない場合、Task を戻り値の型とし て使用します。
C#7.0以降では、その型に GetAwaiter メソッドがある場合に限り、別の戻り値の型を指定できます。このような型の例とし て、ValueTask<TResult> が挙げられます。 これは、System.Threading.Tasks.Extension NuGet パッケージにあります。
次のサンプルは、Task<TResult> または Task を戻すメソッドを宣言して呼び出す方法を示します。
     
         それぞれ、進行中の作業を示すタスクを戻します。 タスクに非同期処理の状態に関する情報、および最終的にはプロセスから の最終結果、またはプロセスが成功しなかった場合に発生する例外をカプセル化します。
非同期のメソッドの戻り値の型としては、 void を指定できます。 この戻り値の型は主として、 void の戻り値の型が必要なイ ベント ハンドラーの定義に使用されます。 非同期のイベント ハンドラーは通常、非同期のプログラムの開始点として機能しま す。
void の戻り値の型を持つ非同期のメソッドは、待機できません。voidを戻すメソッドの呼び出し元では、このメソッドがスロー する例外をキャッチできません。
非同期のメソッドで in、ref、または out パラメーターを宣言することはできませんが、これらのパラメーターを持つメソッドを呼び出 すことはできます。 同様に、非同期メソッドは ref 戻り値を使用してメソッドを呼び出すことはできますが、参照を使用して値を 返すことはできません。
詳細および例については、「非同期の戻り値の型 (C#)」を参照してください。 非同期のメソッドで例外をキャッチする方法の詳 細については、「try-catch」を参照してください。
Windows ランタイム プログラミングの非同期 API には、タスクに類似した次のような戻り値の型の 1 つがあります。
IAsyncOperation<TResult> は Task<TResult> に対応します IAsyncAction は Task に対応します IAsyncActionWithProgress<TProgress> IAsyncOperationWithProgress<TResult,TProgress>
名前付け規則
慣例により、一般的に待機可能な型 (たとえば Task 、 Task<T> 、 ValueTask 、 ValueTask<T> ) を返すメソッドについては、 その名前の末尾に "Async" を付けます。 非同期操作を開始するメソッドであっても、そのメソッドが待機可能な型を返さない 場合は、メソッド名の末尾に "Async" を付けてはなりませんが、このメソッドが操作の結果を返したりスローしたりしないことを示 す "Begin" や "Start" などの動詞を先頭に付けることはかまいません。
イベント、基底クラス、またはインターフェイスのコントラクトが別の名前を表示している場合は、この慣例を無視できます。 たとえ ば、 OnButtonClick などの共通のイベント ハンドラーの名前は、変更しないことをお勧めします。
       async Task<int> GetTaskOfTResultAsync()
{
    int hours = 0;
    await Task.Delay(0);
    return hours;
}
Task<int> returnedTaskTResult = GetTaskOfTResultAsync();
int intResult = await returnedTaskTResult;
// Single line
// int intResult = await GetTaskOfTResultAsync();
async Task GetTaskAsync()
{
    await Task.Delay(0);
    // No return statement needed
}
Task returnedTask = GetTaskAsync();
await returnedTask;
// Single line
await GetTaskAsync();
 
                関連トピックとサンプル (Visual Studio) TITLE
   async と await を使用して複数の Web 要 求を並列実行する方法 (C#)
   複数のタスクを同時に開始する方法を示し ます。
   Async Sample:Make Multiple Web Requests in Parallel (非同期のサンプル: 複数の Web 要求を並行して作成する)
 非同期の戻り値の型 (C#)
ファイル アクセスに非同期を使用する (C#)
Channel 9 の非同期に関するビデオ
関連項目
async
await 非同期プログラミング 非同期の概要
非同期のメソッドが戻す型、および各型の 適切な使用方法を説明します。
async および await を使用してファイルにア クセスすることの利点の一覧と紹介です。
非同期のプログラミングに関するさまざまなビ デオへのリンクを示します。
   シグナル化メカニズムとしてキャンセル トークン を使用して、タスクをキャンセルします。
   非同期のソリューションに次の機能を追加す る方法を示します:
- タスクの一覧をキャンセルする (C#)
- 一定時間後にタスクをキャンセルする (C#) - 完了時に非同期タスクを処理する (C#)
       タスク ベースの非同期パターン (TAP)
   非同期パターンについて説明されています。 パターンは Task および Task<TResult> 型 に基づいています。
       
            非同期メソッドには、次の戻り値の型があります。
Task: 操作を実行し、値を返さない非同期メソッドの場合。 Task<TResult>: 値を返す非同期メソッドの場合。
void : イベント ハンドラーの場合。
C#7.0以降、アクセス可能な GetAwaiter を持つ任意の型です。
System.Runtime.CompilerServices.ICriticalNotifyCompletion メソッドによって返されるオブジェクトは、 GetAwaiter インターフェイスを実装する必要があります。
C# 8.0 以降、"非同期ストリーム" を返す非同期メソッドの場合は IAsyncEnumerable<T>。
非同期メソッドの詳細については、「Async および Await を使用した非同期プログラミング (C#)」を参照してください。 他にも、Windows ワークロードに固有の型がいくつか存在します。
DispatcherOperation: Windows に限定された非同期操作。
IAsyncAction: 値を返さない UWP の非同期アクション。
IAsyncActionWithProgress<TProgress>: 進行状況は報告するが値を返さない UWP の非同期アクション。 IAsyncOperation<TResult>: 値を返す UWP の非同期操作。 IAsyncOperationWithProgress<TResult,TProgress>: 進行状況を報告し値を返す UWP の非同期操作。
Task の戻り値の型
return ステートメントを含まない非同期メソッド、またはオペランドを返さない return ステートメントを含む非同期メソッド は、通常はTaskの戻り値の型を指定します。こうしたメソッドは、同期的に実行するように作成されている場合に void を返 します。非同期メソッドに戻り値の型Taskを使用した場合、呼び出し元のメソッドは await 演算子を使って、呼び出された async のメソッドが終了するまで、呼び出し元の完了を中断します。
次の例では、WaitAndApologizeAsync メソッドに ステートメントが含まれていないため、メソッドからはTaskオブジェク トが返されます。 Task を返すことで、 を待機できるようになります。Task型には戻り値がないた め、 Result プロパティを含みません。
      return
 WaitAndApologizeAsync
 非同期の戻り値の型 (C#) 2020/11/02 • • Edit Online
 
       WaitAndApologizeAsync を待機するには、voidを返す同期メソッドを呼び出す場合と同様に、await式でなく、awaitステー トメントを使用します。 この場合、await 演算子の適用によって値は生成されません。 ステートメントと式という用語を明確に するには、次の表を参照してください。
AWAIT
ステートメント
Expression
await SomeTaskMethodAsync()
TYPE
Task
Task<TResult>
            T result = await SomeTaskMethodAsync<T>();
   次のコードを見るとわかるように、WaitAndApologizeAsync の呼び出しをawait演算子の適用から分離することができます。 ただし Task は Result プロパティを持たないこと、またawait演算子が Task に適用されるときに値は生成されないことに 注意します。
次のコードは、 WaitAndApologizeAsync メソッドの呼び出しを、そのメソッドが返すタスクの待機から分離します。
      Task waitAndApologizeTask = WaitAndApologizeAsync();
string output =
    $"Today is {DateTime.Now:D}\n" +
    $"The current time is {DateTime.Now.TimeOfDay:t}\n" +
    "The current temperature is 76 degrees.\n";
await waitAndApologizeTask;
Console.WriteLine(output);
 Task<TResult> の戻り値の型
戻り値の型Task<TResult>は、オペランドが TResult であるreturnステートメントを含む非同期メソッドに使用されます。
次の例の メソッドには、整数を返す return ステートメントが含まれています。そのため、メソッド宣 言では、戻り値の型を と指定する必要があります。 非同期メソッド FromResult は、DayOfWeek を返す操作に 対するプレースホルダーです。
   GetLeisureHoursAsync
 Task<int>
   public static async Task DisplayCurrentInfoAsync()
{
    await WaitAndApologizeAsync();
    Console.WriteLine($"Today is {DateTime.Now:D}");
    Console.WriteLine($"The current time is {DateTime.Now.TimeOfDay:t}");
    Console.WriteLine("The current temperature is 76 degrees.");
}
static async Task WaitAndApologizeAsync()
{
    await Task.Delay(2000);
    Console.WriteLine("Sorry for the delay...\n");
}
// Example output:
//    Sorry for the delay...
//
// Today is Monday, August 17, 2020
// The current time is 12:59:24.2183304
// The current temperature is 76 degrees.
 
      GetLeisureHoursAsync が ShowTodaysInfo メソッドのawait式の中から呼び出されると、await式は GetLeisureHours メ ソッドから返されるタスクに格納されている整数値(leisureHours の値)を取得します。await式の詳細については、 「await」を参照してください。
次のコードが示すように、 GetLeisureHoursAsync への呼び出しを await のアプリケーションから分離すると、 await で から結果を取得する方法をよりよく理解できます。 メソッドの宣言から予想されるように、直ちに待機しない
メソッドの呼び出しは、 Task<int> を返します。 タスクは、この例の 変数に 割り当てられます。 は Task<TResult> であるため、Result 型の プロパティが含まれていま す。 この場合、 は整数型を表します。 await が getLeisureHoursTask に適用されると、 getLeisureHoursTask のResultプロパティの内容がawait式の評価となります。この値は ret 変数に割り当てられます。
   Task<T>
   GetLeisureHoursAsync
 getLeisureHoursTask
      IMPORTANT
Result プロパティは Blocking プロパティです。 タスクが終了する前にアクセスしようとすると、現在アクティブなスレッドは、タスクが完了して 値が使用可能になるまで、ブロックされます。 多くの場合、プロパティに直接アクセスする代わりに、 await を使用して値にアクセスする必 要があります。
前の例では、アプリケーションが終了する前に Main メソッドで message を出力できるように、Result プロパティの値を取得してメイン ス レッドをブロックしました。
      var getLeisureHoursTask = GetLeisureHoursAsync();
string message =
    $"Today is {DateTime.Today:D}\n" +
    "Today's hours of leisure: " +
    $"{await getLeisureHoursTask}";
Console.WriteLine(message);
 Void の戻り値の型
void 戻り値の型は、void 戻り値の型が必要な非同期イベントハンドラーで使用します。値を返さないイベントハンドラー 以外のメソッドについては、Taskを返す必要があります。これは、void を返す非同期メソッドを待機できないためです。このよ うなメソッドの呼び出し元は、呼び出された非同期メソッドが完了するまで待機せずに、完了するまで続行する必要がありま
getLeisureHoursTask
 TResult
 TResult
   public static async Task ShowTodaysInfoAsync()
{
    string message =
        $"Today is {DateTime.Today:D}\n" +
        "Today's hours of leisure: " +
        $"{await GetLeisureHoursAsync()}";
    Console.WriteLine(message);
}
static async Task<int> GetLeisureHoursAsync()
{
    DayOfWeek today = await Task.FromResult(DateTime.Now.DayOfWeek);
    int leisureHours =
        today is DayOfWeek.Saturday || today is DayOfWeek.Sunday
        ? 16 : 5;
    return leisureHours;
}
// Example output:
//    Today is Wednesday, May 24, 2017
//    Today's hours of leisure: 5
 
     す。 呼び出し元は、非同期メソッドによって生成される値や例外から独立している必要があります。
void を返す非同期メソッドの呼び出し元は、メソッドからスローされる例外をキャッチすることはできません。そのようなハンドルさ れない例外によって、アプリケーションが失敗する可能性が高くなります。 Task または Task<TResult> を返すメソッドから例外 がスローされた場合、例外は返されたタスクに格納されます。 タスクを待機しているときは、例外が再スローされます。 したがっ て、例外を生成する場合がある非同期メソッドは Task または Task<TResult> の戻り値の型を持つこと、またメソッドの呼び出 しが待機することを確認します。
非同期メソッドで例外をキャッチする方法の詳細については、「try-catch」の記事の「非同期メソッドの例外」セクションを参照 してください。
次の例では、非同期イベント ハンドラーの動作を示します。 コード例では、非同期イベント ハンドラーが終了したとき、その非 同期イベント ハンドラーからメイン スレッドに通知が送られる必要があります。 このため、メイン スレッドでは、非同期イベント ハ ンドラーの終了を待ってから、プログラムを終了することができます。
    using System;
using System.Threading.Tasks;
public class NaiveButton
{
    public event EventHandler? Clicked;
    public void Click()
    {
        Console.WriteLine("Somebody has clicked a button. Let's raise the event...");
        Clicked?.Invoke(this, EventArgs.Empty);
        Console.WriteLine("All listeners are notified.");
} }
public class AsyncVoidExample
{
    static readonly TaskCompletionSource<bool> s_tcs = new TaskCompletionSource<bool>();
    public static async Task MultipleEventHandlersAsync()
    {
        Task<bool> secondHandlerFinished = s_tcs.Task;
        var button = new NaiveButton();
        button.Clicked += OnButtonClicked1;
        button.Clicked += OnButtonClicked2Async;
        button.Clicked += OnButtonClicked3;
        Console.WriteLine("Before button.Click() is called...");
        button.Click();
        Console.WriteLine("After button.Click() is called...");
        await secondHandlerFinished;
    }
    private static void OnButtonClicked1(object? sender, EventArgs e)
    {
        Console.WriteLine("   Handler 1 is starting...");
        Task.Delay(100).Wait();
        Console.WriteLine("   Handler 1 is done.");
}
    private static async void OnButtonClicked2Async(object? sender, EventArgs e)
    {
        Console.WriteLine("   Handler 2 is starting...");
        Task.Delay(100).Wait();
        Console.WriteLine("   Handler 2 is about to go async...");
        await Task.Delay(500);
        Console.WriteLine("   Handler 2 is done.");
s_tcs.SetResult(true);

     一般化された async の戻り値の型と ValueTask<TResult> C#7.0以降、非同期メソッドで、アクセス可能な GetAwaiter メソッドを持つ任意の型を返すことができます。
Task および Task<TResult> は参照型であるため、特に厳密なループ処理で割り当てが発生すると、パフォーマンスが重要な パスのメモリ割り当てが、パフォーマンスに悪影響を及ぼすことがあります。 一般化された戻り値の型のサポートにより、参照型で はなく、軽量な値の型を返すことができ、追加のメモリ割り当てを回避することが可能です。
.NET には、一般化されたタスク戻り値の軽量な実装として、System.Threading.Tasks.ValueTask<TResult> 構造が用意さ れています。 System.Threading.Tasks.ValueTask<TResult> 型を使用するには、 System.Threading.Tasks.Extensions NuGet パッケージをプロジェクトに追加する必要があります。 次の例では、ValueTask<TResult> 構造を使用して、2 つのさい ころを転がしたときの値を取得します。
          s_tcs.SetResult(true);
    }
    private static void OnButtonClicked3(object? sender, EventArgs e)
    {
        Console.WriteLine("   Handler 3 is starting...");
        Task.Delay(100).Wait();
        Console.WriteLine("   Handler 3 is done.");
} }
// Example output:
//
// Before button.Click() is called...
// Somebody has clicked a button. Let's raise the event...
//    Handler 1 is starting...
//    Handler 1 is done.
//    Handler 2 is starting...
//    Handler 2 is about to go async...
//    Handler 3 is starting...
//    Handler 3 is done.
// All listeners are notified.
// After button.Click() is called...
//    Handler 2 is done.
    
   IAsyncEnumerable<T> を使用する非同期ストリーム
C# 8.0 以降は、非同期メソッドから IAsyncEnumerable<T> で表される非同期ストリームが返される場合があります。 非同 期ストリームを使用すると、非同期呼び出しが繰り返される要素がチャンクで生成されるときに、ストリームから読み取られた項 目を列挙できます。 次の例は、非同期ストリームを生成する非同期メソッドを示しています。
    static async IAsyncEnumerable<string> ReadWordsFromStreamAsync()
{
    string data =
        @"This is a line of text.
          Here is the second line of text.
          And there is one more for good measure.
          Wait, that was the penultimate line.";
    using var readStream = new StringReader(data);
    string line = await readStream.ReadLineAsync();
    while (line != null)
    {
        foreach (string word in line.Split(' ', StringSplitOptions.RemoveEmptyEntries))
        {
            yield return word;
        }
        line = await readStream.ReadLineAsync();
    }
}
 前の例では、文字列から非同期に行を読み取ります。 各行が読み取られると、コードによって文字列内の各単語が列挙され ます。 呼び出し元では、 await foreach ステートメントを使用して各単語を列挙します。 このメソッドを使用すると、ソース文
    using System;
using System.Threading.Tasks;
class Program
{
    static readonly Random s_rnd = new Random();
    static async Task Main() =>
        Console.WriteLine($"You rolled {await GetDiceRollAsync()}");
    static async ValueTask<int> GetDiceRollAsync()
    {
        Console.WriteLine("Shaking dice...");
        int roll1 = await RollAsync();
        int roll2 = await RollAsync();
        return roll1 + roll2;
    }
    static async ValueTask<int> RollAsync()
    {
        await Task.Delay(500);
        int diceRoll = s_rnd.Next(1, 7);
        return diceRoll;
    }
}
// Example output:
//    Shaking dice...
//    You rolled 8
 
    字列から次の行を非同期的に読み取る必要があるときに待機できます。 関連項目
FromResult
完了時の非同期タスクの処理
Async および Await を使用した非同期プログラミング (C#) async
await

        非同期のコンソール アプリケーションは、終了まで待機しない場合にキャンセルすることができます。 このトピックの例に従うと、 Web サイトの一覧のコンテンツをダウンロードするアプリケーションにキャンセルを追加できます。 各タスクに CancellationTokenSource インスタンスを関連付けると、多くのタスクをキャンセルすることができます。 Enter キーを選択する と、完了していないすべてのタスクがキャンセルされます。
このチュートリアルの内容:
.NET コンソール アプリケーションの作成 キャンセルをサポートする非同期アプリケーションの作成 キャンセル通知のデモンストレーション
前提条件 このチュートリアルには、次のものが必要です。
.NET 5.0 以降の SDK 統合開発環境 (IDE)
Visual Studio、Visual Studio Code、または Visual Studio for Mac をお勧めします サンプル アプリケーションの作成
新しい.NETCoreコンソールアプリケーションを作成します。 dotnet new console コマンドを使用するか、VisualStudioから 作成できます。 任意のコード エディターで Program.cs ファイルを開きます。
using ステートメントの置換
既存の using ステートメントを次の宣言に置き換えます。
フィールドを追加する
Program クラス定義で、次の3つのフィールドを追加します。
     using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
  タスクの一覧をキャンセルする (C#) 2021/03/06 • • Edit Online
 
      CancellationTokenSourceは、要求されるキャンセルをCancellationTokenに通知するために使用されます。 HttpClient では、HTTP要求を送信してHTTP応答を受信する機能が公開されます。 s_urlList には、このアプリケーションで処理を計 画するすべての URL が格納されます。
アプリケーション エントリ ポイントの更新 コンソールアプリケーションのメインエントリポイントは、Main メソッドです。既存のメソッドを以下に置き換えます。
     static async Task Main()
{
    Console.WriteLine("Application started.");
    Console.WriteLine("Press the ENTER key to cancel...\n");
    Task cancelTask = Task.Run(() =>
    {
        while (Console.ReadKey().Key != ConsoleKey.Enter)
        {
            Console.WriteLine("Press the ENTER key to cancel...");
        }
        Console.WriteLine("\nENTER key pressed: cancelling downloads.\n");
        s_cts.Cancel();
    });
    Task sumPageSizesTask = SumPageSizesAsync();
    await Task.WhenAny(new[] { cancelTask, sumPageSizesTask });
    Console.WriteLine("Application ending.");
}
 更新した Main メソッドは、asyncmainと見なされるようになります。これにより、実行可能ファイルへの非同期エントリポイン
   static readonly CancellationTokenSource s_cts = new CancellationTokenSource();
static readonly HttpClient s_client = new HttpClient
{
    MaxResponseContentBufferSize = 1_000_000
};
static readonly IEnumerable<string> s_urlList = new string[]
{
    "https://docs.microsoft.com",
    "https://docs.microsoft.com/aspnet/core",
    "https://docs.microsoft.com/azure",
    "https://docs.microsoft.com/azure/devops",
    "https://docs.microsoft.com/dotnet",
    "https://docs.microsoft.com/dynamics365",
    "https://docs.microsoft.com/education",
    "https://docs.microsoft.com/enterprise-mobility-security",
    "https://docs.microsoft.com/gaming",
    "https://docs.microsoft.com/graph",
    "https://docs.microsoft.com/microsoft-365",
    "https://docs.microsoft.com/office",
    "https://docs.microsoft.com/powershell",
    "https://docs.microsoft.com/sql",
    "https://docs.microsoft.com/surface",
    "https://docs.microsoft.com/system-center",
    "https://docs.microsoft.com/visualstudio",
    "https://docs.microsoft.com/windows",
    "https://docs.microsoft.com/xamarin"
};
 
        トが可能になります。 いくつかの指示メッセージがコンソールに出力され、次に   という名前の Task インスタンスが宣 言されます。これにより、コンソールのキー ストロークが読み取られるようになります。 Enter キーが押される と、CancellationTokenSource.Cancel() の呼び出しが行われます。 これにより、キャンセルが通知されるようになります。 次 に、 sumPageSizesTask 変数が SumPageSizesAsync メソッドから割り当てられています。 両方のタスクは次に Task.WhenAny(Task[]) に渡され、2 つのタスクのいずれかが完了したときに続行されるようになります。
  非同期の合計ページ サイズ メソッドの作成 Main メソッドの下に、 SumPageSizesAsync メソッドを追加します。
     static async Task SumPageSizesAsync()
{
    var stopwatch = Stopwatch.StartNew();
    int total = 0;
    foreach (string url in s_urlList)
    {
        int contentLength = await ProcessUrlAsync(url, s_client, s_cts.Token);
        total += contentLength;
    }
    stopwatch.Stop();
    Console.WriteLine($"\nTotal bytes returned:  {total:#,#}");
    Console.WriteLine($"Elapsed time:          {stopwatch.Elapsed}\n");
}
  このメソッドを開始するには、Stopwatch をインスタンス化して開始します。 次に、 ProcessUrlAsync を呼び出します。 反復処理のたびに、 s_cts.Token が
Task<TResult> が返されます。 TResult は整数です。
プロセス メソッドの追加
SumPageSizesAsync メソッドの下に次の ProcessUrlAsync メソッドを追加します。
内の各 URL をループし、 メソッドに渡され、コードから
       int total = 0;
foreach (string url in s_urlList)
{
    int contentLength = await ProcessUrlAsync(url, s_client, s_cts.Token);
    total += contentLength;
}
       static async Task<int> ProcessUrlAsync(string url, HttpClient client, CancellationToken token)
{
    HttpResponseMessage response = await client.GetAsync(url, token);
    byte[] content = await response.Content.ReadAsByteArrayAsync(token);
    Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
    return content.Length;
}
   どのURLに対しても、このメソッドにより、提供される client インスタンスが使用され、応答が byte[] として取得されます。 CancellationToken インスタンスは、HttpClient.GetAsync(String, CancellationToken) および HttpContent.ReadAsByteArrayAsync()メソッドに渡されます。 token は、要求されるキャンセルの登録に使用されます。 URL と長さがコンソールに出力された後、長さが返されます。
アプリケーション出力の例
s_urlList
 ProcessUrlAsync
 cancelTask
 
    コード例全体
次のコードは、この例の Program.cs ファイルの完全なテキストです。
     Application started.
Press the ENTER key to cancel...
https://docs.microsoft.com
https://docs.microsoft.com/aspnet/core
https://docs.microsoft.com/azure
https://docs.microsoft.com/azure/devops
https://docs.microsoft.com/dotnet
https://docs.microsoft.com/dynamics365
https://docs.microsoft.com/education
ENTER key pressed: cancelling downloads.
Application ending.
37,357
 85,589
398,939
 73,663
 67,452
 48,582
 22,924
 using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
class Program
{
    static readonly CancellationTokenSource s_cts = new CancellationTokenSource();
    static readonly HttpClient s_client = new HttpClient
    {
        MaxResponseContentBufferSize = 1_000_000
    };
    static readonly IEnumerable<string> s_urlList = new string[]
    {
            "https://docs.microsoft.com",
            "https://docs.microsoft.com/aspnet/core",
            "https://docs.microsoft.com/azure",
            "https://docs.microsoft.com/azure/devops",
            "https://docs.microsoft.com/dotnet",
            "https://docs.microsoft.com/dynamics365",
            "https://docs.microsoft.com/education",
            "https://docs.microsoft.com/enterprise-mobility-security",
            "https://docs.microsoft.com/gaming",
            "https://docs.microsoft.com/graph",
            "https://docs.microsoft.com/microsoft-365",
            "https://docs.microsoft.com/office",
            "https://docs.microsoft.com/powershell",
            "https://docs.microsoft.com/sql",
            "https://docs.microsoft.com/surface",
            "https://docs.microsoft.com/system-center",
            "https://docs.microsoft.com/visualstudio",
            "https://docs.microsoft.com/windows",
            "https://docs.microsoft.com/xamarin"
};
    static async Task Main()
    {
        Console.WriteLine("Application started.");
        Console.WriteLine("Press the ENTER key to cancel...\n");
        Task cancelTask = Task.Run(() =>
        {

        関連項目
CancellationToken
CancellationTokenSource
Async および Await を使用した非同期プログラミング (C#)
次の手順
指定した時間の経過後の非同期タスクのキャンセル (C#)
             while (Console.ReadKey().Key != ConsoleKey.Enter)
            {
                Console.WriteLine("Press the ENTER key to cancel...");
            }
            Console.WriteLine("\nENTER key pressed: cancelling downloads.\n");
            s_cts.Cancel();
        });
        Task sumPageSizesTask = SumPageSizesAsync();
        await Task.WhenAny(new[] { cancelTask, sumPageSizesTask });
        Console.WriteLine("Application ending.");
    }
    static async Task SumPageSizesAsync()
    {
        var stopwatch = Stopwatch.StartNew();
        int total = 0;
        foreach (string url in s_urlList)
        {
            int contentLength = await ProcessUrlAsync(url, s_client, s_cts.Token);
            total += contentLength;
        }
        stopwatch.Stop();
        Console.WriteLine($"\nTotal bytes returned:  {total:#,#}");
        Console.WriteLine($"Elapsed time:          {stopwatch.Elapsed}\n");
    }
    static async Task<int> ProcessUrlAsync(string url, HttpClient client, CancellationToken token)
    {
        HttpResponseMessage response = await client.GetAsync(url, token);
        byte[] content = await response.Content.ReadAsByteArrayAsync(token);
        Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
        return content.Length;
    }
}

          CancellationTokenSource.CancelAfter メソッドを使用すると、一定の時間が過ぎた後に非同期操作が完了するまで待たな い場合に、キャンセルすることができます。 このメソッドは、 CancelAfter 式によって指定された時間内に完了しない、関連付 けられたタスクのキャンセルをスケジュールします。
この例は、タスクの一覧のキャンセル (C#)に関する記事で開発したコードに追加して、Web サイトの一覧をダウンロードしてそ れぞれのコンテンツの長さを表示します。
このチュートリアルの内容:
既存の .NET コンソール アプリケーションの更新
キャンセルのスケジュール
前提条件 このチュートリアルには、次のものが必要です。
タスクの一覧のキャンセル (C#) のチュートリアルでアプリケーションを作成しておきます .NET 5.0 以降の SDK
統合開発環境 (IDE)
Visual Studio、Visual Studio Code、または Visual Studio for Mac をお勧めします アプリケーション エントリ ポイントの更新
既存の Main メソッドを以下に置き換えます。
     static async Task Main()
{
    Console.WriteLine("Application started.");
try {
        await SumPageSizesAsync();
    }
    catch (TaskCanceledException)
    {
        Console.WriteLine("\nTasks cancelled: timed out.\n");
    }
finally {
        s_cts.Dispose();
    }
    Console.WriteLine("Application ending.");
}
s_cts.CancelAfter(3500);
 更新された Main メソッドで、いくつかの指示メッセージがコンソールに書き込まれます。trycatch内 で、CancellationTokenSource.CancelAfter(Int32) を呼び出してキャンセルをスケジュールします。 これにより、一定の期間 後にキャンセルが通知されます。
指定した時間の経過後の非同期タスクのキャンセ
ル (C#) 2021/03/06 • • Edit Online
 
   次に、SumPageSizesAsync メソッドが待機されます。スケジュールされたキャンセルよりも、すべてのURLの処理が早く行われ ると、アプリケーションは終了します。 ただし、すべての URL が処理される前にスケジュールされたキャンセルがトリガーされる と、TaskCanceledException がスローされます。
アプリケーション出力の例
    Application started.
https://docs.microsoft.com
https://docs.microsoft.com/aspnet/core
https://docs.microsoft.com/azure
https://docs.microsoft.com/azure/devops
Tasks cancelled: timed out.
Application ending.
37,357
 85,589
398,939
 73,663
 コード例全体
次のコードは、この例の Program.cs ファイルの完全なテキストです。
    using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
class Program
{
    static readonly CancellationTokenSource s_cts = new CancellationTokenSource();
    static readonly HttpClient s_client = new HttpClient
    {
        MaxResponseContentBufferSize = 1_000_000
    };
    static readonly IEnumerable<string> s_urlList = new string[]
    {
            "https://docs.microsoft.com",
            "https://docs.microsoft.com/aspnet/core",
            "https://docs.microsoft.com/azure",
            "https://docs.microsoft.com/azure/devops",
            "https://docs.microsoft.com/dotnet",
            "https://docs.microsoft.com/dynamics365",
            "https://docs.microsoft.com/education",
            "https://docs.microsoft.com/enterprise-mobility-security",
            "https://docs.microsoft.com/gaming",
            "https://docs.microsoft.com/graph",
            "https://docs.microsoft.com/microsoft-365",
            "https://docs.microsoft.com/office",
            "https://docs.microsoft.com/powershell",
            "https://docs.microsoft.com/sql",
            "https://docs.microsoft.com/surface",
            "https://docs.microsoft.com/system-center",
            "https://docs.microsoft.com/visualstudio",
            "https://docs.microsoft.com/windows",
            "https://docs.microsoft.com/xamarin"
};
    static async Task Main()
    {
Console.WriteLine("Application started.");

        関連項目
CancellationToken
CancellationTokenSource
Async および Await を使用した非同期プログラミング (C#) タスクの一覧をキャンセルする (C#)
 try {
            await SumPageSizesAsync();
        }
        catch (TaskCanceledException)
        {
            Console.WriteLine("\nTasks cancelled: timed out.\n");
        }
finally {
            s_cts.Dispose();
        }
        Console.WriteLine("Application ending.");
    }
    static async Task SumPageSizesAsync()
    {
        var stopwatch = Stopwatch.StartNew();
        int total = 0;
        foreach (string url in s_urlList)
        {
            int contentLength = await ProcessUrlAsync(url, s_client, s_cts.Token);
            total += contentLength;
        }
        stopwatch.Stop();
        Console.WriteLine($"\nTotal bytes returned:  {total:#,#}");
        Console.WriteLine($"Elapsed time:          {stopwatch.Elapsed}\n");
    }
    static async Task<int> ProcessUrlAsync(string url, HttpClient client, CancellationToken token)
    {
        HttpResponseMessage response = await client.GetAsync(url, token);
        byte[] content = await response.Content.ReadAsByteArrayAsync(token);
        Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
        return content.Length;
    }
}
s_cts.CancelAfter(3500);

       Task.WhenAny を使用すると、複数のタスクを、開始された順番に処理するのでなく、同時に開始して完了するごとに 1 つず つ処理できます。
クエリを使用して、タスクのコレクションを作成する例を次に示します。 各タスクは、指定された Web サイトのコンテンツをダウン ロードします。 while ループの各反復で、待機されている WhenAny への呼び出しは、最初にダウンロードを終了するタスクの コレクションにあるタスクを返します。 タスクはコレクションから削除され、処理されます。 ループは、コレクションのタスクがなくなるま で繰り返されます。
サンプル アプリケーションの作成
新しい .NET Core コンソール アプリケーションを作成します。 dotnet new console コマンドを使用するか、Visual Studio を使
用して作成できます。 任意のコード エディターで Program.cs ファイルを開きます。 using ステートメントの置換
既存の using ステートメントを次の宣言に置き換えます。
フィールドを追加する
Program クラスの定義に、次の2つのフィールドを追加します。
    using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
  完了時の非同期タスクの処理 (C#) 2021/03/06 • • Edit Online
 
     HttpClient では、HTTP要求を送信してHTTP応答を受信する機能が公開されます。 s_urlList には、このアプリケーショ ンで処理を計画するすべての URL が格納されます。
アプリケーション エントリ ポイントの更新 コンソールアプリケーションのメインエントリポイントは、Main メソッドです。既存のメソッドを以下に置き換えます。
更新した Main メソッドは、asyncmainと見なされるようになります。これにより、実行可能ファイルへの非同期エントリポイン トが可能になります。 これは、 SumPageSizesAsync の呼び出しを表しています。
非同期の合計ページ サイズ メソッドの作成 Main メソッドの下に、 SumPageSizesAsync メソッドを追加します。
  static Task Main() => SumPageSizesAsync();
      static readonly HttpClient s_client = new HttpClient
{
    MaxResponseContentBufferSize = 1_000_000
};
static readonly IEnumerable<string> s_urlList = new string[]
{
    "https://docs.microsoft.com",
    "https://docs.microsoft.com/aspnet/core",
    "https://docs.microsoft.com/azure",
    "https://docs.microsoft.com/azure/devops",
    "https://docs.microsoft.com/dotnet",
    "https://docs.microsoft.com/dynamics365",
    "https://docs.microsoft.com/education",
    "https://docs.microsoft.com/enterprise-mobility-security",
    "https://docs.microsoft.com/gaming",
    "https://docs.microsoft.com/graph",
    "https://docs.microsoft.com/microsoft-365",
    "https://docs.microsoft.com/office",
    "https://docs.microsoft.com/powershell",
    "https://docs.microsoft.com/sql",
    "https://docs.microsoft.com/surface",
    "https://docs.microsoft.com/system-center",
    "https://docs.microsoft.com/visualstudio",
    "https://docs.microsoft.com/windows",
    "https://docs.microsoft.com/xamarin"
};
 
        このメソッドを開始するには、Stopwatch をインスタンス化して開始します。 それには、実行時にタスクのコレクションを作成する クエリが含まれます。次のコードの ProcessUrlAsync への各呼び出しは、TResult が整数であるTask<TResult>を返しま す。
LINQ での遅延実行のため、各タスクを開始するには Enumerable.ToList を呼び出します。
while ループでは、コレクション内の各タスクに対して次の手順が実行されます。
1. WhenAny への呼び出しを待機し、コレクション内で最初にダウンロードが終了したタスクを識別します。
2. コレクションからそのタスクを削除します。
3. finishedTask への呼び出しから返される、 ProcessUrlAsync を待機します。 finishedTask 変数は Task<TResult>が整数である TResult です。次の例に示すように、タスクは既に完了していますが、ダウンロードした Web サイトの長さの取得を待機します。 タスクが失敗した場合、 がスローされる Task<TResult>.Resultプロパティの読み取りとは異なり、 await からは に格納されている最初 の子の例外がスローされます。
      IEnumerable<Task<int>> downloadTasksQuery =
    from url in s_urlList
    select ProcessUrlAsync(url, s_client);
   List<Task<int>> downloadTasks = downloadTasksQuery.ToList();
    Task<int> finishedTask = await Task.WhenAny(downloadTasks);
   downloadTasks.Remove(finishedTask);
      AggregateException
 AggregateException
  total += await finishedTask;
    static async Task SumPageSizesAsync()
{
    var stopwatch = Stopwatch.StartNew();
    IEnumerable<Task<int>> downloadTasksQuery =
        from url in s_urlList
        select ProcessUrlAsync(url, s_client);
    List<Task<int>> downloadTasks = downloadTasksQuery.ToList();
    int total = 0;
    while (downloadTasks.Any())
    {
        Task<int> finishedTask = await Task.WhenAny(downloadTasks);
        downloadTasks.Remove(finishedTask);
        total += await finishedTask;
    }
    stopwatch.Stop();
    Console.WriteLine($"\nTotal bytes returned:  {total:#,#}");
    Console.WriteLine($"Elapsed time:          {stopwatch.Elapsed}\n");
}
 
  プロセス メソッドの追加
SumPageSizesAsync メソッドの下に次の ProcessUrlAsync メソッドを追加します。
どのURLに対しても、このメソッドにより、提供される client インスタンスが使用され、応答が byte[] として取得されます。 URL と長さがコンソールに出力された後、長さが返されます。
ダウンロードされた長さが常に同じ順序では表示されないことを確認するために、プログラムを複数回実行します。
Caution
ループで WhenAny を使って、例に示すように、いくつかのタスクを格納する問題を解決できます。ただし、多数のタスクが処理 する場合、他のアプローチがより効率的です。 詳細と例については、「Processing Tasks as they complete」 (完了したタスク を処理する) を参照してください。
コード例全体
次のコードは、この例の Program.cs ファイルの完全なテキストです。
      static async Task<int> ProcessUrlAsync(string url, HttpClient client)
{
    byte[] content = await client.GetByteArrayAsync(url);
    Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
    return content.Length;
}
        using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
namespace ProcessTasksAsTheyFinish
{
    class Program
    {
        static readonly HttpClient s_client = new HttpClient
        {
            MaxResponseContentBufferSize = 1_000_000
        };
        static readonly IEnumerable<string> s_urlList = new string[]
        {
            "https://docs.microsoft.com",
            "https://docs.microsoft.com/aspnet/core",
            "https://docs.microsoft.com/azure",
            "https://docs.microsoft.com/azure/devops",
            "https://docs.microsoft.com/dotnet",
            "https://docs.microsoft.com/dynamics365",
            "https://docs.microsoft.com/education",
            "https://docs.microsoft.com/enterprise-mobility-security",
            "https://docs.microsoft.com/gaming",
            "https://docs.microsoft.com/graph",
            "https://docs.microsoft.com/microsoft-365",
            "https://docs.microsoft.com/office",
            "https://docs.microsoft.com/powershell",
            "https://docs.microsoft.com/sql",
            "https://docs.microsoft.com/surface",
            "https://docs.microsoft.com/system-center",
            "https://docs.microsoft.com/visualstudio",
            "https://docs.microsoft.com/windows",
            "https://docs.microsoft.com/xamarin"
};

      関連項目
WhenAny
Async および Await を使用した非同期プログラミング (C#)
} }
};
static Task Main() => SumPageSizesAsync();
static async Task SumPageSizesAsync()
{
    var stopwatch = Stopwatch.StartNew();
    IEnumerable<Task<int>> downloadTasksQuery =
        from url in s_urlList
        select ProcessUrlAsync(url, s_client);
    List<Task<int>> downloadTasks = downloadTasksQuery.ToList();
    int total = 0;
    while (downloadTasks.Any())
    {
        Task<int> finishedTask = await Task.WhenAny(downloadTasks);
        downloadTasks.Remove(finishedTask);
        total += await finishedTask;
    }
    stopwatch.Stop();
    Console.WriteLine($"\nTotal bytes returned:  {total:#,#}");
    Console.WriteLine($"Elapsed time:          {stopwatch.Elapsed}\n");
}
static async Task<int> ProcessUrlAsync(string url, HttpClient client)
{
 byte[] content = await client.GetByteArrayAsync(url);
Console.WriteLine($"{url,-60} {content.Length,10:#,#}");
    return content.Length;
}
// Example output:
// https://docs.microsoft.com/windows
// https://docs.microsoft.com/gaming
// https://docs.microsoft.com/dotnet
// https://docs.microsoft.com/dynamics365
// https://docs.microsoft.com/surface
// https://docs.microsoft.com
// https://docs.microsoft.com/azure/devops
// https://docs.microsoft.com/xamarin
// https://docs.microsoft.com/system-center
// https://docs.microsoft.com/enterprise-mobility-security
// https://docs.microsoft.com/microsoft-365
// https://docs.microsoft.com/visualstudio
// https://docs.microsoft.com/office
// https://docs.microsoft.com/azure
// https://docs.microsoft.com/graph
// https://docs.microsoft.com/education
// https://docs.microsoft.com/powershell
// https://docs.microsoft.com/aspnet/core
// https://docs.microsoft.com/sql
// Total bytes returned: 1,249,485
// Elapsed time:          00:00:02.7068725
 25,513
 30,705
 69,626
 50,756
 35,519
 39,531
 75,837
 60,284
 43,444
 28,946
 43,278
 31,414
 42,292
401,113
 46,831
 25,098
 58,173
 87,763
 53,362

         ファイルにアクセスする際に非同期機能を使用できます。 非同期機能を使用すると、コールバックの使用や複数のメソッドまた はラムダ式へのコードの分割を行わずに、非同期メソッドを呼び出すことができます。 同期コードを非同期コードにするには、同 期メソッドの代わりに非同期メソッドを呼び出して、コードにいくつかのキーワードを追加するだけで済みます。
ファイル アクセスの呼び出しに非同期性を適用する利点には、次のようなものがあります。
非同期性により、UI アプリケーションの応答性が向上します。非同期処理を開始した UI スレッドが他の処理を実行できる ためです。 UI スレッドが、時間のかかるコード、たとえば 50 ミリ秒を超えるコードを実行する必要がある場合、I/O が完了し て、UI スレッドがキーボードやマウス入力などのイベントを再度処理できるようになるまで、UI が停止することがあります。 非同期性を適用すると、スレッドの必要性が軽減され、ASP.NET などのサーバー ベースのアプリケーションのスケーラビリティ が向上します。 アプリケーションが応答ごとに専用スレッドを使用している場合、1,000 個の要求を同時に処理するには、 1,000 個のスレッドが必要です。 非同期操作では、待機中にスレッドを使用する必要はほとんどありません。 既存の I/O 完了スレッドが最後に少しだけ使用されます。
現状ではファイル アクセス操作の待機時間が非常に短くても、将来に大幅に長くなる可能性があります。 たとえば、地球 の裏側にあるサーバーにファイルが移動される場合があります。
非同期機能の使用に伴うオーバーヘッドはわずかです。
非同期タスクは簡単に並列実行できます。
適切なクラスを使用する
このトピックの簡単な例では、File.WriteAllTextAsync と File.ReadAllTextAsync について説明します。 ファイル I/O 操作を有 限制御するには、FileStream クラスを使用します。これには、オペレーティング システムのレベルで非同期 I/O を発生させるオプ ションがあります。 このオプションを使用することにより、多くの場合、スレッド プール スレッドがブロックされるのを回避できます。 こ のオプションを有効にするには、コンストラクター呼び出しで useAsync=true または options=FileOptions.Asynchronous 引 数を指定します。
ファイル パスを指定して StreamReader と StreamWriter を直接開いた場合、それらでこのオプションを使用することはできませ ん。 一方、FileStream クラスによって開かれた Stream を使用する場合は、このオプションを使用できます。 UI アプリでは、ス レッド プール スレッドがブロックされても、非同期呼び出しは高速になります。これは、UI スレッドは待機中にブロックされないた めです。
テキストを書き込む
次の例では、ファイルにテキストを書き込みます。 各 await ステートメントに達すると、メソッドは直ちに終了します。 ファイル I/O が完了すると、メソッドは await ステートメントの後のステートメントから再開します。 async 修飾子は、await ステートメントを 使用するメソッドの定義に含まれます。
簡単な例
      public async Task SimpleWriteAsync()
{
    string filePath = "simple.txt";
    string text = $"Hello World";
    await File.WriteAllTextAsync(filePath, text);
}
 有限制御の例
ファイルへの非同期アクセス (C#) 2020/11/02 • • Edit Online
 
       元の例には await sourceStream.WriteAsync(encodedText, 0, encodedText.Length); ステートメントがあります。これは、次 の 2 つのステートメントの省略形です。
最初のステートメントはタスクを返し、ファイル処理を開始します。 await が含まれた 2 番目のステートメントによって、メソッドが 直ちに終了し、別のタスクを返します。 ファイル処理が完了すると、await の後のステートメントに実行が戻ります。
テキストを読み取る 次の例では、ファイルからテキストを読み取ります。 簡単な例
有限制御の例
テキストはバッファーに格納されます。この例では StringBuilder に配置されます。 前の例と異なり、await の評価で値が生成 されます。ReadAsyncメソッドによってTask<Int32>が返されます。処理の完了後、awaitの評価によって Int32 値
numRead が生成されます。詳しくは、「非同期の戻り値の型(C#)」をご覧ください。
     Task theTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
await theTask;
     public async Task SimpleReadAsync()
{
    string filePath = "simple.txt";
    string text = await File.ReadAllTextAsync(filePath);
    Console.WriteLine(text);
}
     public async Task ProcessWriteAsync()
{
    string filePath = "temp.txt";
    string text = $"Hello World{Environment.NewLine}";
    await WriteTextAsync(filePath, text);
}
async Task WriteTextAsync(string filePath, string text)
{
    byte[] encodedText = Encoding.Unicode.GetBytes(text);
    using var sourceStream =
        new FileStream(
            filePath,
            FileMode.Create, FileAccess.Write, FileShare.None,
            bufferSize: 4096, useAsync: true);
    await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
}
 
    並列非同期 I/O
次の例では、10 個のテキスト ファイルを記述する並列処理を示します。 簡単な例
     public async Task ProcessReadAsync()
{
try {
else {
            Console.WriteLine($"file not found: {filePath}");
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}
async Task<string> ReadTextAsync(string filePath)
{
    using var sourceStream =
        new FileStream(
            filePath,
            FileMode.Open, FileAccess.Read, FileShare.Read,
            bufferSize: 4096, useAsync: true);
    var sb = new StringBuilder();
    byte[] buffer = new byte[0x1000];
    int numRead;
    while ((numRead = await sourceStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
    {
        string text = Encoding.Unicode.GetString(buffer, 0, numRead);
        sb.Append(text);
    }
    return sb.ToString();
}
string filePath = "temp.txt";
if (File.Exists(filePath) != false)
{
    string text = await ReadTextAsync(filePath);
    Console.WriteLine(text);
}
 public async Task SimpleParallelWriteAsync()
{
    string folder = Directory.CreateDirectory("tempfolder").Name;
    IList<Task> writeTaskList = new List<Task>();
    for (int index = 11; index <= 20; ++ index)
    {
        string fileName = $"file-{index:00}.txt";
        string filePath = $"{folder}/{fileName}";
        string text = $"In file {index}{Environment.NewLine}";
        writeTaskList.Add(File.WriteAllTextAsync(filePath, text));
    }
    await Task.WhenAll(writeTaskList);
}
 
         有限制御の例
WriteAsyncメソッドは、ファイルごとにタスクを返します。タスクはタスクの一覧に追加されます。 await Task.WhenAll(tasks); ステートメントはメソッドを終了し、すべてのタスクのファイル処理が完了すると、メソッド内で再開します。
この例では、タスクの完了後、finally ブロックのすべてのFileStreamインスタンスを閉じます。 using ステートメントで FileStream が作成された場合は、タスクが完了する前に FileStream が破棄されることがあります。
パフォーマンスの向上の多くは、非同期処理ではなく並列処理によって実現されます。 非同期性の利点は、複数のスレッドや ユーザー インターフェイス スレッドが拘束されない点にあります。
        public async Task ProcessMulitpleWritesAsync()
{
    IList<FileStream> sourceStreams = new List<FileStream>();
try {
} }
string folder = Directory.CreateDirectory("tempfolder").Name;
IList<Task> writeTaskList = new List<Task>();
for (int index = 1; index <= 10; ++ index)
{
    string fileName = $"file-{index:00}.txt";
    string filePath = $"{folder}/{fileName}";
    string text = $"In file {index}{Environment.NewLine}";
    byte[] encodedText = Encoding.Unicode.GetBytes(text);
    var sourceStream =
        new FileStream(
            filePath,
            FileMode.Create, FileAccess.Write, FileShare.None,
            bufferSize: 4096, useAsync: true);
    Task writeTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
    sourceStreams.Add(sourceStream);
    writeTaskList.Add(writeTask);
}
    await Task.WhenAll(writeTaskList);
}
finally {
foreach (FileStream sourceStream in sourceStreams)
{
    sourceStream.Close();
}
 WriteAsync メソッドと ReadAsync メソッドを使用すると、CancellationToken を指定して、途中で処理をキャンセルすることが できます。 詳細については、「マネージド スレッドのキャンセル」を参照してください。
関連項目
Async および Await を使用した非同期プログラミング (C#) 非同期の戻り値の型 (C#)

         属性は、メタデータまたは宣言型の情報を、コード (アセンブリ、型、メソッド、プロパティなど) に関連付けるための優れた方法で す。 属性をプログラム要素に関連付けると、リフレクション と呼ばれる手法を使用して、実行時にその属性を照会することがで きます。 詳細については、「リフレクション (C#)」を参照してください。
属性には、次の特徴があります。
属性は、プログラムにメタデータを追加します。 メタデータ は、プログラムで定義された型に関する情報です。 すべての .NET アセンブリには、アセンブリで定義された型および型のメンバーを記述する、指定されたメタデータのセットが含まれます。 カス タム属性を追加して、必要な追加情報を指定することができます。 詳細については、「カスタム属性の作成 (C#)」を参照 してください。
属性は、アセンブリ全体、モジュール、またはクラスやプロパティなどのより小さいプログラム要素に 1 つ以上適用することがで きます。
属性は、メソッドやプロパティと同じ方法で引数を受け取ることができます。 リフレクションを使用して、プログラム自身のメタデータや他のプログラムのメタデータを調べることができます。 詳しくは、「リフレ クションを使用した属性へのアクセス (C#)」をご覧ください。
属性の使用 属性は、ほぼすべての宣言に配置できますが、属性によっては、有効な宣言の型が制限されている場合もあります。 C# で
は、角かっこ ([]) で囲んだ属性の名前を、適用先のエンティティの宣言の前に配置して、属性を指定します。 この例では、SerializableAttribute 属性を使用してクラスに特性を適用します。
属性 DllImportAttribute を持つメソッドは次の例のように宣言されます。
次の例のように、宣言には、複数の属性を配置できます。
特定のエンティティで複数回指定できる属性もあります。 このような複数回指定できる属性の例として ConditionalAttribute があります。
    [Serializable]
public class SampleClass
{
    // Objects of this type can be serialized.
}
     [System.Runtime.InteropServices.DllImport("user32.dll")]
extern static void SampleMethod();
   using System.Runtime.InteropServices;
     void MethodA([In][Out] ref double x) { }
void MethodB([Out][In] ref double x) { }
void MethodC([In, Out] ref double x) { }
 属性 (C#) 2021/03/06 • • Edit Online
 
      NOTE
慣例により、属性名はすべて "Attribute" という単語で終わります。これは、.NET ライブラリの他の項目と区別するためです。 ただし、コード 内で属性を使用する場合は、attribute サフィックスを指定する必要はありません。 たとえば、 は
[DllImportAttribute] と同等ですが、.NET クラス ライブラリでは は属性の実際の名前を表します。
 [DllImport]
  DllImportAttribute
 属性のパラメーター
属性の多くは、位置指定パラメーター、名前のないパラメーター、または名前付きパラメーターを持っています。 どの位置指定パ ラメーターも、特定の順序で指定する必要があり、省略することはできません。 名前付きパラメーターは省略可能で、任意の 順序で指定することができます。 位置指定パラメーターは、最初に指定します。 たとえば、次の 3 つの属性は同等です。
最初のパラメーターである DLL 名は位置指定パラメーターであり、常に最初に指定されます。他のパラメーターは名前付きパラ メーターです。 この例の場合、名前付きパラメーターの既定値はどちらも false なので、省略することができます。 位置指定パ ラメーターは、属性コンストラクターのパラメーターに対応します。 名前付きまたは省略可能なパラメーターは、属性のプロパティ またはフィールドのどちらかに対応します。 パラメーターの既定値については、個々の属性のドキュメントを参照してください。
属性の対象
属性の 対象 は、属性が適用されるエンティティです。 たとえば、属性は、クラス、特定のメソッド、またはアセンブリ全体に適用 できます。 既定では、属性はその後に続く要素に適用されます。 ただし、明示的に指定すれば、メソッド、属性のパラメー ター、属性の戻り値などにも適用できます。
    [DllImport("user32.dll")]
[DllImport("user32.dll", SetLastError=false, ExactSpelling=false)]
[DllImport("user32.dll", ExactSpelling=false, SetLastError=false)]
 属性の対象を明示的に識別するには、次の構文を使用します。
次の表に、使用可能な target の値を示します。
assembly
module
field
event
method
param
アセンブリ全体
現在のアセンブリ モジュール クラスまたは構造体のフィールド event
メソッドまたは get および set メソッド パラメーターまたは set
プロパティ アクセサー
プロパティ アクセサー パラメーター
  [target : attribute-list]
                                  [Conditional("DEBUG"), Conditional("TEST1")]
void TraceMethod()
{
// ... }
 
            property プロパティ
    return
   メソッド、プロパティ インデクサー、または get プロパティ アクセサーの 戻り値
 type 構造体、クラス、インターフェイス、列挙型、またはデリゲート 対象の値 field を指定して、auto-implementedプロパティに作成されたバッキングフィールドに属性を適用します。
次の例では、アセンブリとモジュールに属性を適用する方法を示します。 詳細については、「共通の属性 (C#)」を参照してくだ さい。
C# でメソッド、メソッドのパラメーター、およびメソッドの戻り値に属性を適用する方法の例を次に示します。
      using System;
using System.Reflection;
[assembly: AssemblyTitleAttribute("Production assembly 4")]
[module: CLSCompliant(true)]
     // default: applies to method
[ValidatedContract]
int Method1() { return 0; }
// applies to method
[method: ValidatedContract]
int Method2() { return 0; }
// applies to parameter
int Method3([ValidatedContract] string contract) { return 0; }
// applies to return value
[return: ValidatedContract]
int Method4() { return 0; }
     NOTE
 ValidatedContract
  ValidatedContract
 が有効になるように定義されるターゲットが何であっても、 return は指定する必要があります。これは、
 が戻り値にのみ適用されるように定義されている場合でも必要です。 つまり、コンパイラは AttributeUsage 情 報を使用して、あいまいな属性ターゲットを解決しません。 詳細については、「AttributeUsage (C#)」を参照してください。
 属性の一般的な使用法 次の表に、コードでの属性の一般的な使用法をいくつか示します。
Webサービスの WebMethod 属性を使用してメソッドをマークして、メソッドがSOAPプロトコルを介して呼び出されるように します。 詳細については、「WebMethodAttribute」を参照してください。
ネイティブ コードと相互運用するときにメソッドのパラメーターをマーシャリングする方法を記述します。 詳細については、 「MarshalAsAttribute」を参照してください。
クラス、メソッド、およびインターフェイスの COM プロパティを記述します。 DllImportAttribute クラスを使用してアンマネージ コードを呼び出します。 タイトル、バージョン、説明、または商標についてのアセンブリを記述します。 永続化のためにシリアル化するクラスのメンバーを記述します。
 
         XML シリアル化のためにクラス メンバーと XML ノード間をマップする方法を記述します。 メソッドのセキュリティ要件を記述します。
セキュリティを適用するための特性を指定します。
コードを容易にデバッグできる状態に保つために、ジャスト イン タイム (JIT) コンパイラによって最適化を制御します。 メソッドの呼び出し元に関する情報を取得します。
関連項目 詳細については次を参照してください:
カスタム属性の作成 (C#) リフレクションを使用した属性へのアクセス (C#) 属性を使用して C/C++ の共用体を作成する方法 (C#) 共通属性 (C#)
呼び出し元情報 (C#)
関連項目
C# プログラミング ガイド リフレクション (C#) 属性
C# での属性の使用

    属性クラスを定義することで、独自のカスタム属性を作成できます。属性クラスは、Attribute の直接的または間接的な派生ク ラスです。これにより、メタデータの中で属性の定義をすばやく簡単に特定できます。 型にそれを記述したプログラマーの名前で タグを付けるとします。 Author というカスタム属性クラスを定義します。
     [System.AttributeUsage(System.AttributeTargets.Class |
                       System.AttributeTargets.Struct)
]
public class AuthorAttribute : System.Attribute
{
    private string name;
    public double version;
    public AuthorAttribute(string name)
    {
        this.name = name;
        version = 1.0;
    }
}
    クラス名 は属性の名前 Author であり、サフィックス Attribute が付きます。このクラスは から派生しているので、カスタム属性クラスです。 コンストラクターのパラメーターはカスタム属性の位置指定 パラメーターです。 この例では、 name が位置指定パラメーターになります。 パブリックな読み取り/書き込みフィールドまたはプロ パティは名前付きパラメーターです。この場合は、 が唯一の名前付きパラメーターです。 AttributeUsage 属性を使
用して、クラスと struct の宣言に対してのみ 属性を有効にしていることに注意してください。 この新しい属性の使用方法は次のとおりです。
AttributeUsage には名前付きパラメーター AllowMultiple があります。これを使用すると、カスタム属性が1回しか指定で きない属性か、または複数回指定できる属性かを設定できます。 次のコード例では、複数回指定できる属性が作成されま す。
次のコード例では、同じ型の複数の属性が 1 つのクラスに適用されます。
AuthorAttribute
 System.Attribute
  version
  Author
    [Author("P. Ackerman", version = 1.1)]
class SampleClass
{
    // P. Ackerman's code goes here...
}
       [System.AttributeUsage(System.AttributeTargets.Class |
                       System.AttributeTargets.Struct,
                       AllowMultiple = true)  // multiuse attribute
public class AuthorAttribute : System.Attribute
]
 カスタム属性の作成 (C#) 2020/11/02 • • Edit Online
 
         関連項目
System.Reflection
C# プログラミング ガイド
カスタム属性の記述
リフレクション (C#)
属性 (C#) リフレクションを使用した属性へのアクセス (C#) AttributeUsage (C#)
   [Author("P. Ackerman", version = 1.1)]
[Author("R. Koch", version = 1.2)]
class SampleClass
{
    // P. Ackerman's code goes here...
    // R. Koch's code goes here...
}
 
    カスタム属性を定義し、それらをソース コード内に配置することができても、その情報を取得して操作する手段がなければ、ほと んど価値はありません。 リフレクションを使用すれば、カスタム属性を使用して定義された情報を取得することができます。 鍵と なるメソッドは GetCustomAttributes です。このメソッドは、ソースコード属性の実行時の等価オブジェクトを配列で返します。 このメソッドには、いくつかのオーバー ロード バージョンがあります。 詳細については、「Attribute」を参照してください。
次のような属性指定は、
概念的には次の記述と同じです。
ただし、属性について が照会されるまで、コードは実行されません。 SampleClass について
を呼び出すと、 Author オブジェクトが作成され、上記のように初期化されます。 クラスに他の属性が ある場合は、他の属性オブジェクトも同様に作成されます。 GetCustomAttributes はその後、 Author オブジェクトと配列内
の他の属性オブジェクトを返します。 その後、この配列を反復処理し、各配列要素の型に基づいてどの属性が適用されたかを 確認して、属性オブジェクトから情報を抽出することができます。
例
完全な例を次に示します。 カスタム属性が定義され、複数のエンティティに適用された後、リフレクションを使用して取得されて います。
     [Author("P. Ackerman", version = 1.1)]
class SampleClass
     Author anonymousAuthorObject = new Author("P. Ackerman");
anonymousAuthorObject.version = 1.1;
   SampleClass
  GetCustomAttributes
  リフレクションを使用した属性へのアクセス
(C#)
2020/11/02 • • Edit Online
     // Multiuse attribute.
[System.AttributeUsage(System.AttributeTargets.Class |
                       System.AttributeTargets.Struct,
                       AllowMultiple = true)  // Multiuse attribute.
]
public class Author : System.Attribute
{
    string name;
    public double version;
    public Author(string name)
    {
        this.name = name;
        // Default value.
        version = 1.0;
    }
    public string GetName()
    {
        return name;
    }
}

         関連項目
System.Reflection
Attribute
C# プログラミング ガイド 属性に格納されている情報の取得 リフレクション (C#)
 // Class with the Author attribute.
[Author("P. Ackerman")]
public class FirstClass
{
// ... }
// Class without the Author attribute.
public class SecondClass
{
// ... }
// Class with multiple Author attributes.
[Author("P. Ackerman"), Author("R. Koch", version = 2.0)]
public class ThirdClass
{
// ... }
class TestAuthorAttribute
{
    static void Test()
    {
        PrintAuthorInfo(typeof(FirstClass));
        PrintAuthorInfo(typeof(SecondClass));
        PrintAuthorInfo(typeof(ThirdClass));
}
    private static void PrintAuthorInfo(System.Type t)
    {
        System.Console.WriteLine("Author information for {0}", t);
        // Using reflection.
        System.Attribute[] attrs = System.Attribute.GetCustomAttributes(t);  // Reflection.
        // Displaying output.
        foreach (System.Attribute attr in attrs)
        {
            if (attr is Author)
            {
                Author a = (Author)attr;
                System.Console.WriteLine("
} }
/* Output:
    Author information for FirstClass
       P. Ackerman, version 1.00
    Author information for SecondClass
    Author information for ThirdClass
{0}, version {1:f}", a.GetName(), a.version);
} }
*/
R. Koch, version 2.00
P. Ackerman, version 1.00

   属性 (C#) カスタム属性の作成 (C#)

    属性を使用すると、構造体のメモリ内での配置をカスタマイズできます。 たとえば、 StructLayout(LayoutKind.Explicit) 属 性と FieldOffset 属性を使用すると、C/C++の共用体と呼ばれるものを作成できます。
例
このコード セグメントでは、 TestUnion のすべてのフィールドがメモリ内の同じ場所で開始されます。
      // Add a using directive for System.Runtime.InteropServices.
[System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
struct TestUnion
{
    [System.Runtime.InteropServices.FieldOffset(0)]
    public int i;
    [System.Runtime.InteropServices.FieldOffset(0)]
    public double d;
    [System.Runtime.InteropServices.FieldOffset(0)]
    public char c;
    [System.Runtime.InteropServices.FieldOffset(0)]
    public byte b;
}
 例 次の例でも、明示的に設定されたさまざまな場所でフィールドが開始されます。
属性を使用して C/C++ の共用体を作成する方法
(C#)
2020/11/02 • • Edit Online
 
         2 つの整数フィールド、 i1 および i2 は、 lg と同じメモリ位置を共有します。 このような構造体配置の制御は、プラット フォームを呼び出すときに便利です。
関連項目
System.Reflection Attribute
C# プログラミング ガイド 属性
リフレクション (C#)
属性 (C#)
カスタム属性の作成 (C#) リフレクションを使用した属性へのアクセス (C#)
   // Add a using directive for System.Runtime.InteropServices.
[System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]
struct TestExplicit
{
    [System.Runtime.InteropServices.FieldOffset(0)]
    public long lg;
    [System.Runtime.InteropServices.FieldOffset(0)]
    public int i1;
    [System.Runtime.InteropServices.FieldOffset(4)]
    public int i2;
    [System.Runtime.InteropServices.FieldOffset(8)]
    public double d;
    [System.Runtime.InteropServices.FieldOffset(12)]
    public char c;
    [System.Runtime.InteropServices.FieldOffset(14)]
    public byte b;
}
 
               多くのアプリケーションで、関連するオブジェクトのグループの作成および管理が必要になります。 オブジェクトをグループ化するに は、オブジェクトの配列を作成する方法と、オブジェクトのコレクションを作成する方法があります。
配列は、数が固定されている厳密に型指定されたオブジェクトの作成および処理に最も適しています。 配列の詳細について は、「配列」を参照してください。
コレクションは、オブジェクトのグループをより柔軟に処理できます。 配列の場合とは違って、コレクションで扱うオブジェクトのグ ループは、アプリケーションの変更に伴う必要に応じて動的に拡大および縮小できます。 コレクションによっては、コレクションに含 まれるオブジェクトのキーを割り当てると、そのキーを使用してオブジェクトを迅速に取り出すことができます。
コレクションはクラスであるため、そのコレクションに要素を追加するには、事前にそのクラスのインスタンスを宣言する必要がありま す。
含まれる要素が 1 つのデータ型だけのコレクションの場合は、System.Collections.Generic 名前空間のクラスのいずれかを使 用できます。 ジェネリック コレクションでは、タイプ セーフが強制されるため、他のデータ型を追加することはできません。 ジェネリッ ク コレクションから要素を取得する場合は、データ型を判断したり、変換したりする必要はありません。
このトピックの内容
単純なコレクションを使用する コレクションの種類
System.Collections.Generic のクラス System.Collections.Concurrent のクラス System.Collections のクラス
キーと値のペアのコレクションを実装する LINQ を使用してコレクションにアクセスする コレクションを並べ替える
カスタム コレクションを定義する
反復子
単純なコレクションを使用する このセクションの例は、厳密に型指定されたオブジェクトの一覧を使用できる、ジェネリックの List<T> クラスを使用します。 次の例は、文字列の一覧を作成した後、foreach ステートメントを使用して文字列を反復処理します。
    NOTE
このトピックの例には、 System.Collections.Generic 名前空間および System.Linq 名前空間の using ディレクティブがあります。
   コレクション (C#) 2020/11/02 • • Edit Online
 
   コレクションのコンテンツが既知の場合、コレクションの初期化にコレクション初期化子を使用できます。 詳細については、「オブ ジェクト初期化子とコレクション初期化子」を参照してください。
次の例は、コレクションへの要素の追加にコレクション初期化子を使用する以外、前の例と同じです。
    // Create a list of strings by using a
// collection initializer.
var salmons = new List<string> { "chinook", "coho", "pink", "sockeye" };
// Iterate through the list.
foreach (var salmon in salmons)
{
    Console.Write(salmon + " ");
}
// Output: chinook coho pink sockeye
  コレクションを反復処理するには、foreach ステートメントの代わりに、forステートメントを使用できます。インデックス位置に よってコレクションの要素にアクセスすることで、これを実現します。 要素のインデックスは、0 から開始し、要素の数から 1 少な い値で終了します。
次の例は、 for の代わりに foreach を使用して、コレクションの要素を反復処理します。
     // Create a list of strings by using a
// collection initializer.
var salmons = new List<string> { "chinook", "coho", "pink", "sockeye" };
for (var index = 0; index < salmons.Count; index++)
{
    Console.Write(salmons[index] + " ");
}
// Output: chinook coho pink sockeye
 次の例は、削除するオブジェクトを指定して、コレクションから要素を削除します。
   // Create a list of strings.
var salmons = new List<string>();
salmons.Add("chinook");
salmons.Add("coho");
salmons.Add("pink");
salmons.Add("sockeye");
// Iterate through the list.
foreach (var salmon in salmons)
{
    Console.Write(salmon + " ");
}
// Output: chinook coho pink sockeye
 
      次の例では、ジェネリックリストからすべての要素を削除します。 foreach ステートメントの代わりに、降順に反復するforス テートメントを使用します。 これは、RemoveAt メソッドを実行すると、削除された要素の後にある各要素のインデックス値が小 さくなるためです。
    var numbers = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
// Remove odd numbers.
for (var index = numbers.Count - 1; index >= 0; index--)
{
    if (numbers[index] % 2 == 1)
    {
        // Remove the element by specifying
        // the zero-based index in the list.
        numbers.RemoveAt(index);
} }
// Iterate through the list.
// A lambda expression is placed in the ForEach method
// of the List(T) object.
numbers.ForEach(
    number => Console.Write(number + " "));
// Output: 0 2 4 6 8
  List<T>の要素の型は、独自のクラスでも定義できます。次の例では、Galaxy が使用するList<T>クラスがコードに定義さ れます。
   // Create a list of strings by using a
// collection initializer.
var salmons = new List<string> { "chinook", "coho", "pink", "sockeye" };
// Remove an element from the list by specifying
// the object.
salmons.Remove("coho");
// Iterate through the list.
foreach (var salmon in salmons)
{
    Console.Write(salmon + " ");
}
// Output: chinook pink sockeye
 
            コレクションの種類
.NET は、多くの共通のコレクションを提供します。 各コレクションの型は、固有の目的に合わせてデザインされています。 このセクションでは、次の共通のコレクション クラスをいつくか説明します:
System.Collections.Generic クラス System.Collections.Concurrent クラス System.Collections クラス
System.Collections.Generic のクラス
System.Collections.Generic 名前空間の 1 つのクラスを使用すると、ジェネリック コレクションを作成できます。 ジェネリック コレ クションは、コレクション内のすべての項目が同じデータ型である場合に便利です。 ジェネリック コレクションには該当するデータ型 しか追加できないため、厳密な型指定が適用されます。
次のテーブルは System.Collections.Generic 名前空間でよく使用されるクラスの一覧です:
    Dictionar y<TKey,TValue> List<T>
Queue<T> SortedList<TKey,TValue>
Stack<T>
キーに基づいて編成された、キーと値のペアのコレクションを表します。
インデックスを使用してアクセスできる、オブジェクトの一覧を表しま す。 リストの検索、並べ替え、および変更のメソッドを提供します。
先入れ先出し (FIFO) のオブジェクトのコレクションを表します。 関連付けられた IComparer<T> 実装に基づいて、キーにより並べ
替えられた、キーと値のペアのコレクションを表します。 後入れ先出し (LIFO) のオブジェクトのコレクションを表します。
                     private static void IterateThroughList()
{
    var theGalaxies = new List<Galaxy>
        {
            new Galaxy() { Name="Tadpole", MegaLightYears=400},
            new Galaxy() { Name="Pinwheel", MegaLightYears=25},
            new Galaxy() { Name="Milky Way", MegaLightYears=0},
            new Galaxy() { Name="Andromeda", MegaLightYears=3}
};
    foreach (Galaxy theGalaxy in theGalaxies)
    {
        Console.WriteLine(theGalaxy.Name + "  " + theGalaxy.MegaLightYears);
    }
    // Output:
    //  Tadpole  400
    //  Pinwheel  25
    //  Milky Way  0
    //  Andromeda  3
}
public class Galaxy
{
    public string Name { get; set; }
    public int MegaLightYears { get; set; }
}
 
                      詳細については、「一般的に使用されるコレクション型」、「コレクション クラスの選択」、「System.Collections.Generic」を参照 してください。
System.Collections.Concurrent のクラス
.NET Framework 4 以降のバージョンでは、System.Collections.Concurrent 名前空間のコレクションによって、複数のスレッ
ドからコレクション項目にアクセスするための効率的なスレッド セーフ操作が可能になります。
System.Collections.Concurrent 名前空間のクラスは、複数のスレッドがコレクションに同時にアクセスするとき に、System.Collections.Generic 名前空間および System.Collections 名前空間の対応する型の代わりに使用する必要が あります。 詳しくは、「スレッド セーフなコレクション」と「System.Collections.Concurrent」を参照してください。
System.Collections.Concurrent 名前空間に は、BlockingCollection<T>、ConcurrentDictionary<TKey,TValue>、ConcurrentQueue<T>、および ConcurrentStack<T> などのクラスがあります。
System.Collections のクラス System.Collections名前空間のクラスでは、要素は、固有の型のオブジェクトとしてではなく Object 型のオブジェクトとして
格納されます。
できる限り、System.Collections.Generic 名前空間の従来の型の代わりに、System.Collections.Concurrent 名前空間ま
たは System.Collections 名前空間のジェネリックコレクションを使用します。 次のテーブルは System.Collections 名前空間でよく使用されるクラスの一覧です:
       必要に応じてサイズが動的に拡大されるオブジェクトの配列を表しま す。
キーのハッシュ コードに基づいて編成された、キーと値のペアのコレク ションを表します。
先入れ先出し (FIFO) のオブジェクトのコレクションを表します。
Dictionary<TKey,TValue> ジェネリック コレクションでは、各要素のキーを使用してコレクションの要素にアクセスできます。 ディ クショナリに追加される各エントリは、値とその値に関連付けられたキーで構成されます。 Dictionary クラスはハッシュテーブル として実装されているため、キーを使用した値の取得は非常に高速になります。
次の例では Dictionary のコレクションを作成し、 foreach ステートメントを使用してディクショナリを反復処理します。
ArrayList
Hashtable
Queue
Stack
System.Collections.Specialized 名前空間には、文字列専用のコレクションやリンク リスト、ハイブリッド ディクショナリなど、厳
密に型指定された専用のコレクション クラスが用意されています。 キーと値のペアのコレクションを実装する
            後入れ先出し (LIFO) のオブジェクトのコレクションを表します。
     
        コレクション初期化子を使用して Dictionary コレクションをビルドする代わりに、 BuildDictionary および AddToDictionary メソッドを次のメソッドに置換できます。
    private static Dictionary<string, Element> BuildDictionary2()
{
    return new Dictionary<string, Element>
    {
        {"K",
            new Element() { Symbol="K", Name="Potassium", AtomicNumber=19}},
        {"Ca",
            new Element() { Symbol="Ca", Name="Calcium", AtomicNumber=20}},
        {"Sc",
            new Element() { Symbol="Sc", Name="Scandium", AtomicNumber=21}},
        {"Ti",
            new Element() { Symbol="Ti", Name="Titanium", AtomicNumber=22}}
}; }
  次の例では、キーによって項目をすばやく検索するために、ContainsKeyのItem[]メソッドと Dictionary プロパティを使用し
  private static void IterateThruDictionary()
{
    Dictionary<string, Element> elements = BuildDictionary();
    foreach (KeyValuePair<string, Element> kvp in elements)
    {
} }
Element theElement = kvp.Value;
Console.WriteLine("key: " + kvp.Key);
Console.WriteLine("values: " + theElement.Symbol + " " +
    theElement.Name + " " + theElement.AtomicNumber);
private static Dictionary<string, Element> BuildDictionary()
{
    var elements = new Dictionary<string, Element>();
    AddToDictionary(elements, "K", "Potassium", 19);
    AddToDictionary(elements, "Ca", "Calcium", 20);
    AddToDictionary(elements, "Sc", "Scandium", 21);
    AddToDictionary(elements, "Ti", "Titanium", 22);
    return elements;
}
private static void AddToDictionary(Dictionary<string, Element> elements,
    string symbol, string name, int atomicNumber)
{
    Element theElement = new Element();
    theElement.Symbol = symbol;
    theElement.Name = name;
    theElement.AtomicNumber = atomicNumber;
    elements.Add(key: theElement.Symbol, value: theElement);
}
public class Element
{
    public string Symbol { get; set; }
    public string Name { get; set; }
    public int AtomicNumber { get; set; }
}

     ます。 Item プロパティでは、C#の   を使用して   コレクションの項目にアクセスできます。
elements[symbol]
      private static void FindInDictionary(string symbol)
{
    Dictionary<string, Element> elements = BuildDictionary();
    if (elements.ContainsKey(symbol) == false)
    {
        Console.WriteLine(symbol + " not found");
    }
else {
        Console.WriteLine("found: " + theElement.Name);
    }
}
Element theElement = elements[symbol];
 次の例では、キーによって項目をすばやく検索するために、TryGetValue メソッドを代わりに使用します。
    private static void FindInDictionary2(string symbol)
{
    Dictionary<string, Element> elements = BuildDictionary();
    Element theElement = null;
    if (elements.TryGetValue(symbol, out theElement) == false)
        Console.WriteLine(symbol + " not found");
    else
}
Console.WriteLine("found: " + theElement.Name);
 LINQ を使用してコレクションにアクセスする
統合言語クエリ (LINQ) を使用してコレクションにアクセスできます。 LINQ クエリは、フィルター処理、並べ替え、およびグループ
化の機能を提供します。 詳細については、C# での LINQ の概要に関するページを参照してください。
次の例では、ジェネリック List に対してLINQクエリを実行します。LINQクエリは、結果が格納されている別のコレクションを 戻します。
elements

         コレクションを並べ替える
次の例では、コレクションを並べ替えるための手順を示しています。この例は、Car に格納されているList<T>クラスのインス タンスの並べ替えを実行します。 Car クラスは、IComparable<T>のメソッドの実装を必要とするCompareToインターフェイ スを実装します。
CompareToメソッドに対する各呼び出しは、並べ替えに使用される単一の比較を実行します。 CompareTo メソッドのユー ザーが作成したコードは、現在のオブジェクトと別のオブジェクトとの各比較の値を戻します。 現在のオブジェクトが別のオブジェク トよりも小さい場合はゼロ未満の値を、大きい場合はゼロ以上の値を、等しい場合はゼロを戻します。 これによって、より大き い、より小さい、等しい、の条件をコードに定義することができます。
のメソッドでは、cars.Sort() ステートメントがリストを並べ替えます。SortのList<T>メソッドへの呼び出しによっ て、 メソッドは Car 内の List オブジェクトに自動的に呼び出されます。
   ListCars
 CompareTo
  private static void ShowLINQ()
{
    List<Element> elements = BuildList();
    // LINQ Query.
    var subset = from theElement in elements
                 where theElement.AtomicNumber < 22
                 orderby theElement.Name
                 select theElement;
    foreach (Element theElement in subset)
    {
        Console.WriteLine(theElement.Name + " " + theElement.AtomicNumber);
    }
    // Output:
    //  Calcium 20
    //  Potassium 19
    //  Scandium 21
}
private static List<Element> BuildList()
{
    return new List<Element>
    {
        { new Element() { Symbol="K", Name="Potassium", AtomicNumber=19}},
        { new Element() { Symbol="Ca", Name="Calcium", AtomicNumber=20}},
        { new Element() { Symbol="Sc", Name="Scandium", AtomicNumber=21}},
        { new Element() { Symbol="Ti", Name="Titanium", AtomicNumber=22}}
}; }
public class Element
{
    public string Symbol { get; set; }
    public string Name { get; set; }
    public int AtomicNumber { get; set; }
}
    private static void ListCars()
{
    var cars = new List<Car>
    {
        { new Car() { Name = "car1", Color = "blue", Speed = 20}},
        { new Car() { Name = "car2", Color = "red", Speed = 50}},
        { new Car() { Name = "car3", Color = "green", Speed = 10}},
        { new Car() { Name = "car4", Color = "blue", Speed = 50}},
        { new Car() { Name = "car5", Color = "blue", Speed = 30}},
        { new Car() { Name = "car6", Color = "red", Speed = 60}},

    { new Car() { Name = "car6", Color = "red", Speed = 60}},
    カスタム コレクションを定義する
IEnumerable<T> または IEnumerable のインターフェイスを実装してコレクションを定義できます。
カスタム コレクションを定義できますが、通常は、.NET に含まれるコレクションを使用することが推奨されます。これについては、こ の記事のコレクションの種類で既に説明されています。
次の例は、   という名前のカスタム コレクション クラスを定義します。 このクラスは、IEnumerable メソッドの実装を必
         { new Car() { Name = "car7", Color = "green", Speed = 50}}
    };
    // Sort the cars by color alphabetically, and then by speed
    // in descending order.
    cars.Sort();
    // View all of the cars.
    foreach (Car thisCar in cars)
    {
        Console.Write(thisCar.Color.PadRight(5) + " ");
        Console.Write(thisCar.Speed.ToString() + " ");
        Console.Write(thisCar.Name);
        Console.WriteLine();
}
// Output:
// blue 50 car4 // blue 30 car5 // blue 20 car1 // green 50 car7 // green 10 car3 // red 60car6 // red 50car2
}
public class Car : IComparable<Car>
{
    public string Name { get; set; }
    public int Speed { get; set; }
    public string Color { get; set; }
    public int CompareTo(Car other)
    {
        // A call to this method makes a single comparison that is
        // used for sorting.
        // Determine the relative order of the objects being compared.
        // Sort by color alphabetically, and then by speed in
        // descending order.
        // Compare the colors.
        int compare;
        compare = String.Compare(this.Color, other.Color, true);
        // If the colors are the same, compare the speeds.
        if (compare == 0)
        {
            compare = this.Speed.CompareTo(other.Speed);
            // Use descending order for speed.
            compare = -compare;
        }
        return compare;
    }
}
 AllColors
 
     要とする GetEnumerator インターフェイスを実装します。
   GetEnumerator メソッドは、 ColorEnumerator クラスのインスタンスを戻します。 ColorEnumerator は、IEnumerator プロパ ティ、Current メソッド、および MoveNext メソッドの実装を必要とする Reset インターフェイスを実装します。
    private static void ListColors()
{
    var colors = new AllColors();
    foreach (Color theColor in colors)
    {
        Console.Write(theColor.Name + " ");
    }
    Console.WriteLine();
    // Output: red blue green
}
// Collection class.
public class AllColors : System.Collections.IEnumerable
{
    Color[] _colors =
    {
        new Color() { Name = "red" },
        new Color() { Name = "blue" },
        new Color() { Name = "green" }
};
    public System.Collections.IEnumerator GetEnumerator()
    {
        return new ColorEnumerator(_colors);
        // Instead of creating a custom enumerator, you could
        // use the GetEnumerator of the array.
        //return _colors.GetEnumerator();
}
    // Custom enumerator.
    private class ColorEnumerator : System.Collections.IEnumerator
    {
        private Color[] _colors;
        private int _position = -1;
        public ColorEnumerator(Color[] colors)
        {
            _colors = colors;
        }
        object System.Collections.IEnumerator.Current
        {
get {
                return _colors[_position];
            }
}
        bool System.Collections.IEnumerator.MoveNext()
        {
            _position++;
            return (_position < _colors.Length);
        }
        void System.Collections.IEnumerator.Reset()
        {
            _position = -1;
        }
} }

             Iterators
反復子は、コレクションに対するカスタムイテレーションを実行するために使用されます。反復子は、メソッドまたは get アクセ サーのいずれかです。 反復子は、yield return ステートメントを使用して、コレクションの各要素を 1 回に 1 つ返します。
foreachステートメントを使用して、反復子を呼び出します。 foreach ループの各イテレーションは、反復子を呼び出します。 yield return ステートメントが反復子に到達すると、式が戻され、コードの現在の位置が保持されます。 次回、反復子が呼
び出されると、この位置から実行が再開されます。
詳細については、「反復子 (C#)」を参照してください。
次の例は、反復子メソッドを使用します。 反復子メソッドには、for ループ内に yield return ステートメントがあります。 メソッドでは、 foreach ステートメント本文の各イテレーションが、反復子メソッドの呼び出しを作成し、これ
が次の ステートメントに続行されます。
     ListEvenNumbers
 yield return
    private static void ListEvenNumbers()
{
    foreach (int number in EvenSequence(5, 18))
    {
        Console.Write(number.ToString() + " ");
    }
    Console.WriteLine();
    // Output: 6 8 10 12 14 16 18
}
private static IEnumerable<int> EvenSequence(
    int firstNumber, int lastNumber)
{
    // Yield even numbers in the range.
    for (var number = firstNumber; number <= lastNumber; number++)
    {
} }
if (number % 2 == 0)
{
    yield return number;
}
 関連項目
オブジェクト初期化子とコレクション初期化子 プログラミングの概念 (C#)
Option Strict ステートメント
LINQ to Objects (C#)
Parallel LINQ (PLINQ)
コレクションとデータ構造体
コレクション クラスの選択 コレクション内での比較と並べ替え ジェネリック コレクションを使用する状況
   // Element class.
public class Color
{
    public string Name { get; set; }
}
 
      C# では、共変性と反変性により、配列型、デリゲート型、およびジェネリック型引数の暗黙の参照変換が可能になります。 共 変性は代入互換性を維持し、反変性はこれを反転させます。
次のコードでは、代入互換性、共変性、および反変性の違いについて説明します。
    // Assignment compatibility.
string str = "test";
// An object of a more derived type is assigned to an object of a less derived type.
object obj = str;
// Covariance.
IEnumerable<string> strings = new List<string>();
// An object that is instantiated with a more derived type argument
// is assigned to an object instantiated with a less derived type argument.
// Assignment compatibility is preserved.
IEnumerable<object> objects = strings;
// Contravariance.
// Assume that the following method is in the class:
// static void SetObject(object o) { }
Action<object> actObject = SetObject;
// An object that is instantiated with a less derived type argument
// is assigned to an object instantiated with a more derived type argument.
// Assignment compatibility is reversed.
Action<string> actString = actObject;
 配列の共変性により、強い派生型の配列から弱い派生型の配列への暗黙の型変換が可能になります。 ただし、次のコード 例に示すように、この操作はタイプ セーフではありません。
メソッド グループの共変性と反変性のサポートにより、メソッド シグネチャをデリゲート型と一致させることができます。 これにより、 一致するシグネチャを持つメソッドだけでなく、デリゲート型で指定された型よりも強い派生型 (共変性) を返すメソッドや、弱い 派生型 (反変性) のパラメーターを受け取るメソッドを、デリゲートに割り当てることができます。 詳細については、「デリゲートの 変性 (C#)」および「デリゲートの変性の使用 (C#)」を参照してください。
次のコード例は、メソッド グループでの共変性と反変性のサポートを示しています。
    object[] array = new String[10];
// The following statement produces a run-time exception.
// array[0] = 10;
 共変性と反変性 (C#) 2020/11/02 • • Edit Online
 
               .NET Framework 4 以降のバージョンでは、C# でジェネリック インターフェイスと汎用デリゲートでの共変性と反変性がサポート され、ジェネリック型パラメーターの暗黙の型変換が可能になっています。 詳細については、「ジェネリック インターフェイスの変性 (C#)」および「デリゲートの変性 (C#)」を参照してください。
次のコード例は、ジェネリック インターフェイスの暗黙の参照変換を示しています。
ジェネリック インターフェイスや汎用デリゲートは、そのジェネリック パラメーターが共変または反変として宣言されている場合、バリ アントと呼ばれます。 C# では、独自のバリアント インターフェイスおよびデリゲートを作成できます。 詳細については、「バリアント ジェネリック インターフェイスの作成 (C#)」および「デリゲートの変性 (C#)」を参照してください。
    IEnumerable<String> strings = new List<String>();
IEnumerable<Object> objects = strings;
 関連トピック
TITLE
ジェネリック インターフェイスの変性 (C#)
バリアント ジェネリック インターフェイスの作成 (C#)
デリゲートの変性 (C#)
デリゲートの変性の使用 (C#)
ジェネリック インターフェイスの共変性と反変性について説明し、.NET のバリアント ジェネリック インターフェイスの一覧を示します。
カスタムのバリアント インターフェイスを作成する方法を示します。
汎用および非汎用デリゲートの共変性と反変性について説明し、 .NET のバリアント汎用デリゲートの一覧を示します。
非汎用デリゲートでの共変性と反変性のサポートを使用して、メソッド シグネチャをデリゲート型に一致させる方法について説明します。
           ジェネリック コレクションに対するインターフェイスでの変性の使用 (C#)
   IEnumerable<T> および IComparable<T> インターフェイスでの共 変性と反変性のサポートがコードの再利用にどのように役立つかを示 します。
         Func および Action 汎用デリゲートでの変性の使用 (C#)
    Func および Action デリゲートでの共変性と反変性のサポートが コードの再利用にどのように役立つかを示します。
    static object GetObject() { return null; }
static void SetObject(object obj) { }
static string GetString() { return ""; }
static void SetString(string str) { }
static void Test()
{
    // Covariance. A delegate specifies a return type as object,
    // but you can assign a method that returns a string.
    Func<object> del = GetString;
    // Contravariance. A delegate specifies a parameter type as string,
    // but you can assign a method that takes an object.
    Action<string> del2 = SetObject;
}
 
              .NET Framework 4 では、既存のいくつかのジェネリック インターフェイスに対して、変性のサポートが導入されています。 変性 のサポートにより、これらのインターフェイスを実装するクラスの暗黙的な変換が可能になりました。
.NET Framework 4 以降では、次のインターフェイスがバリアントです。 IEnumerable<T> (T は共変です)
IEnumerator<T> (T は共変です)
IQueryable<T> (T は共変です) IGrouping<TKey,TElement>(TKey と TElement は共変です) IComparer<T> (T は反変です)
IEqualityComparer<T> (T は反変です)
IComparable<T> (T は反変です)
.NET Framework 4.5 以降では、次のインターフェイスがバリアントです。
IReadOnlyList<T> (T は共変です)
IReadOnlyCollection<T> (T は共変です)
共変性により、メソッドの戻り値の型の派生を、インターフェイスのジェネリック型パラメーターで定義されている型よりも強くするこ とができます。 ここでは、共変性機能について説明するために、 および という ジェネリック インターフェイスについて考えます。 インターフェイスは、 インターフェ イスを継承しません。 ただし、 String 型は 型を継承します。場合によっては、これらのインターフェイスのオブジェクト を、相互に割り当てる必要が生じることもあるでしょう。 これを次のコード例に示します。
.NET Framework の以前のバージョンでは、C# ではこのコードを実行するとコンパイル エラーが発生し、Visual Basic では がオンの場合にエラーが発生します。 今後は、IEnumerable<T> インターフェイスが共変になったので、上記
の例のように、 の代わりに strings を使用できるようになりました。
反変性により、メソッドの引数の型の派生を、インターフェイスのジェネリック パラメーターで指定されている型よりも弱くすることが できます。ここでは、反変性について説明するために、 クラスのインスタンスを比較するための BaseComparer クラ スを作成した場合について考えます。 クラスは、 インターフェイスを実装しま す。 IEqualityComparer<T> インターフェイスが反変になったので、 を使用して、 クラスを継承す るクラスのインスタンスを比較することができます。 これを次のコード例に示します。
   IEnumerable<Object>
IEnumerable<String>
  IEnumerable<String>
IEnumerable<Object>
  Object
    IEnumerable<String> strings = new List<String>();
IEnumerable<Object> objects = strings;
  Option Strict
  objects
  BaseClass
 BaseComparer
 IEqualityComparer<BaseClass>
  BaseComparer
BaseClass
ジェネリック インターフェイスの変性 (C#) 2020/11/02 • • Edit Online
 
         詳しくは、「ジェネリック コレクションに対するインターフェイスでの変性の使用 (C#)」をご覧ください。
ジェネリック インターフェイスでの変性がサポートされるのは参照型だけです。 値型は変性をサポートしていません。 たとえば、整
数は値型によって表されるため、 IEnumerable<int> を暗黙的に IEnumerable<object> に変換することはできません。
また、バリアント インターフェイスを実装するクラスは、現在でもインバリアントであることを忘れないようにしてください。 たとえ ば、List<T>が共変インターフェイスIEnumerable<T>を実装しても、List<String> を List<Object> に暗黙的に変換す ることはできません。 これを次のコード例に示します。
関連項目
ジェネリック コレクションに対するインターフェイスでの変性の使用 (C#) バリアント ジェネリック インターフェイスの作成 (C#)
ジェネリック インターフェイス
デリゲートの変性 (C#)
      IEnumerable<int> integers = new List<int>();
// The following statement generates a compiler error,
// because int is a value type.
// IEnumerable<Object> objects = integers;
       // The following line generates a compiler error
// because classes are invariant.
// List<Object> list = new List<String>();
// You can use the interface object instead.
IEnumerable<Object> listObjects = new List<String>();
    // Simple hierarchy of classes.
class BaseClass { }
class DerivedClass : BaseClass { }
// Comparer class.
class BaseComparer : IEqualityComparer<BaseClass>
{
    public int GetHashCode(BaseClass baseInstance)
    {
        return baseInstance.GetHashCode();
    }
    public bool Equals(BaseClass x, BaseClass y)
    {
        return x == y;
    }
}
class Program
{
    static void Test()
    {
} }
IEqualityComparer<BaseClass> baseComparer = new BaseComparer();
// Implicit conversion of IEqualityComparer<BaseClass> to
// IEqualityComparer<DerivedClass>.
IEqualityComparer<DerivedClass> childComparer = baseComparer;
 
      インターフェイスのジェネリック型パラメーターは、共変または反変として宣言できます。 "共変性" により、インターフェイス メソッド の戻り値の型の派生を、ジェネリック型パラメーターで定義されている型よりも強くすることができます。 "反変性" により、インター フェイス メソッドの引数の型の派生を、ジェネリック パラメーターで指定されている型よりも弱くすることができます。 共変または反 変のジェネリック型パラメーターを持つジェネリック インターフェイスは、"バリアント" と呼ばれます。
バリアント ジェネリック インターフェイスの宣言
バリアントジェネリックインターフェイスは、ジェネリック型パラメーターの in キーワードと out キーワードを使用して宣言できま す。
ジェネリック型パラメーターを共変として宣言するには、 out キーワードを使用します。 共変の型は、次の条件を満たす必要が あります。
型がインターフェイス メソッドの戻り値の型としてのみ使用され、メソッド引数の型として使用されない。 この例を以下に 示します。ここでは、型 R が共変として宣言されています。
この規則には例外が 1 つあります。 反変の汎用デリゲートをメソッド パラメーターとして使用する場合は、型をデリゲート のジェネリック型パラメーターとして使用できます。次の例では、型 R によって示します。詳細については、次を参照し てください。デリゲート (Visual Basic) の変性とFunc および Action 汎用デリゲート (Visual Basic) を使用して変性しま す。
    NOTE
.NET Framework 4 では、既存のいくつかのジェネリック インターフェイスに対して、変性のサポートが導入されています。 .NET のバリアント イ ンターフェイスの一覧については、「ジェネリック インターフェイスの変性 (C#)」を参照してください。
     IMPORTANT
C# の ref 、 in 、 out パラメーターは、バリアントにすることはできません。 また、値の型も変性をサポートしていません。
     interface ICovariant<out R>
{
    R GetSomething();
    // The following statement generates a compiler error.
    // void SetSomething(R sampleArg);
}
     interface ICovariant<out R>
{
    void DoSomething(Action<R> callback);
}
 型がインターフェイス メソッドのジェネリック制約として使用されない。 これを次のコードに示します。
バリアント ジェネリック インターフェイスの作
成 (C#) 2020/11/02 • • Edit Online
 
  ジェネリック型パラメーターを反変として宣言するには、 in キーワードを使用します。 反変の型は、メソッド引数の型としてのみ 使用でき、インターフェイス メソッドの戻り値の型として使用できません。 また、反変の型はジェネリック制約にも使用できます。 次のコードでは、反変のインターフェイスを宣言し、そのメソッドの 1 つにジェネリック制約を使用する方法を示します。
次のコード例に示すように、同一インターフェイス内の異なる型パラメーターで、共変性と反変性の両方をサポートすることもでき ます。
バリアント ジェネリック インターフェイスの実装
バリアント ジェネリック インターフェイスをクラスに実装する場合は、インバリアント インターフェイスに使用するのと同じ構文を使用 します。 次のコード例では、共変のインターフェイスをジェネリック クラスに実装する方法を示します。
    interface IContravariant<in A>
{
    void SetSomething(A sampleArg);
    void DoSomething<T>() where T : A;
    // The following statement generates a compiler error.
    // A GetSomething();
}
     interface IVariant<out R, in A>
{
    R GetSomething();
    void SetSomething(A sampleArg);
    R GetSetSomethings(A sampleArg);
}
     interface ICovariant<out R>
{
    R GetSomething();
}
class SampleImplementation<R> : ICovariant<R>
{
    public R GetSomething()
    {
// Some code.
        return default(R);
    }
}
 バリアント インターフェイスを実装するクラスは不変です。 次に例を示します。
   interface ICovariant<out R>
{
    // The following statement generates a compiler error
    // because you can use only contravariant or invariant types
    // in generic constraints.
    // void DoSomething<T>() where T : R;
}
 
  バリアント ジェネリック インターフェイスの拡張
バリアント ジェネリック インターフェイスを拡張するときは、 in キーワードと out キーワードを使用して、派生インターフェイスで 変性をサポートするかどうかを明示的に指定する必要があります。 コンパイラでは、拡張されているインターフェイスからの変性の 推論は行われません。 たとえば、次のようなインターフェイスがあるとします。
IInvariant<T> インターフェイスのジェネリック型パラメーター T は不変であるのに対して、 IExtCovariant<out T> の型パラ メーターは共変ですが、どちらのインターフェイスでも同じインターフェイスを拡張します。 これと同じ規則が、反変のジェネリック型 パラメーターにも当てはまります。
拡張インターフェイスのジェネリック型パラメーター T が不変であれば、ジェネリック型パラメーター T が共変のインターフェイスと 反変のインターフェイスの両方を拡張する 1 つのインターフェイスを作成できます。 これを次のコード例に示します。
ただし、一方のインターフェイスでジェネリック型パラメーター T が共変として宣言されている場合は、それを拡張インターフェイス で反変として宣言することはできません。その逆についても同様です。 これを次のコード例に示します。
あいまいさの回避
バリアント ジェネリック インターフェイスの実装時には、変性によってあいまいさが発生することがあります。 このようなあいまいさは 避ける必要があります。
たとえば、同一のバリアント ジェネリック インターフェイスを、異なるジェネリック型パラメーターを使用して 1 つのクラスに明示的に 実装すると、あいまいさが発生する可能性があります。 この場合、コンパイラでエラーは生成されませんが、実行時にどのイン ターフェイスの実装が選択されるかは明確ではありません。 このあいまいさにより、コードで特定しにくいバグが発生する可能性 があります。 次のコード例について考えます。
    interface ICovariant<out T> { }
interface IInvariant<T> : ICovariant<T> { }
interface IExtCovariant<out T> : ICovariant<T> { }
       interface ICovariant<out T> { }
interface IContravariant<in T> { }
interface IInvariant<T> : ICovariant<T>, IContravariant<T> { }
     interface ICovariant<out T> { }
// The following statement generates a compiler error.
// interface ICoContraVariant<in T> : ICovariant<T> { }
    // The interface is covariant.
ICovariant<Button> ibutton = new SampleImplementation<Button>();
ICovariant<Object> iobj = ibutton;
// The class is invariant.
SampleImplementation<Button> button = new SampleImplementation<Button>();
// The following statement generates a compiler error
// because classes are invariant.
// SampleImplementation<Object> obj = button;
 
       この例では、 pets.GetEnumerator メソッドで Cat と Dog がどのように選択されるかが明らかではありません。 そのため、コー ドで問題が発生する可能性があります。
関連項目
ジェネリック インターフェイスの変性 (C#)
Func および Action 汎用デリゲートでの変性の使用 (C#)
  // Simple class hierarchy.
class Animal { }
class Cat : Animal { }
class Dog : Animal { }
// This class introduces ambiguity
// because IEnumerable<out T> is covariant.
class Pets : IEnumerable<Cat>, IEnumerable<Dog>
{
    IEnumerator<Cat> IEnumerable<Cat>.GetEnumerator()
    {
        Console.WriteLine("Cat");
        // Some code.
        return null;
}
    IEnumerator IEnumerable.GetEnumerator()
    {
// Some code.
        return null;
    }
    IEnumerator<Dog> IEnumerable<Dog>.GetEnumerator()
    {
        Console.WriteLine("Dog");
        // Some code.
        return null;
} }
class Program
{
    public static void Test()
    {
        IEnumerable<Animal> pets = new Pets();
        pets.GetEnumerator();
    }
}

        共変のインターフェイスのメソッドでは、そのインターフェイスで指定された型よりも強い派生型を返すことができます。 反変のイン ターフェイスのメソッドでは、そのインターフェイスで指定された型よりも弱い派生型のパラメーターを受け取ることができます。
.NET Framework 4 では、既存のいくつかのインターフェイスが共変および反変になります。 その中には、IEnumerable<T> や IComparable<T> があります。 これにより、派生型のコレクションに対して、基本型のジェネリック コレクションを操作するメソッド を再利用できます。
.NET のバリアント インターフェイスの一覧については、「ジェネリック インターフェイスの変性 (C#)」を参照してください。 ジェネリック コレクションの変換
次の例は、IEnumerable<T> インターフェイスにおける共変性のサポートの利点を示しています。 メソッドは、 パラメーターとして 型のコレクションを受け取ります。 ただし、 Employee は を継承しているた め、 型のコレクションで再利用できます。
 PrintFullName
   IEnumerable<Person>
Person
 IEnumerable<Employee>
    // Simple hierarchy of classes.
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
public class Employee : Person { }
class Program
{
    // The method has a parameter of the IEnumerable<Person> type.
    public static void PrintFullName(IEnumerable<Person> persons)
    {
        foreach (Person person in persons)
        {
            Console.WriteLine("Name: {0} {1}",
            person.FirstName, person.LastName);
        }
}
    public static void Test()
    {
} }
IEnumerable<Employee> employees = new List<Employee>();
// You can pass IEnumerable<Employee>,
// although the method expects IEnumerable<Person>.
PrintFullName(employees);
 ジェネリック コレクションの比較 次の例は、IComparer<T>インターフェイスにおける反変性のサポートの利点を示しています。 PersonComparer クラスは、
 ジェネリック コレクションに対するインター
フェイスでの変性の使用 (C#) 2020/11/02 • • Edit Online
 
       インターフェイスを実装します。 ただし、   は   を継承しているため、   型の一 連のオブジェクトを比較するためにこのクラスを再利用できます。
IComparer<Person>
Employee
Employee
        // Simple hierarchy of classes.
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
public class Employee : Person { }
// The custom comparer for the Person type
// with standard implementations of Equals()
// and GetHashCode() methods.
class PersonComparer : IEqualityComparer<Person>
{
    public bool Equals(Person x, Person y)
    {
        if (Object.ReferenceEquals(x, y)) return true;
        if (Object.ReferenceEquals(x, null) ||
            Object.ReferenceEquals(y, null))
            return false;
        return x.FirstName == y.FirstName && x.LastName == y.LastName;
    }
    public int GetHashCode(Person person)
    {
} }
if (Object.ReferenceEquals(person, null)) return 0;
int hashFirstName = person.FirstName == null
    ? 0 : person.FirstName.GetHashCode();
int hashLastName = person.LastName.GetHashCode();
return hashFirstName ^ hashLastName;
class Program
{
    public static void Test()
    {
        List<Employee> employees = new List<Employee> {
               new Employee() {FirstName = "Michael", LastName = "Alexander"},
               new Employee() {FirstName = "Jeff", LastName = "Price"}
};
        // You can pass PersonComparer,
        // which implements IEqualityComparer<Person>,
        // although the method expects IEqualityComparer<Employee>.
        IEnumerable<Employee> noduplicates =
            employees.Distinct<Employee>(new PersonComparer());
        foreach (var employee in noduplicates)
            Console.WriteLine(employee.FirstName + " " + employee.LastName);
} }
 関連項目
ジェネリック インターフェイスの変性 (C#)
Person

     .NET Framework 3.5 では、C# のすべてのデリゲートで、メソッド シグネチャとデリゲート型を一致させるために変性 (共変性と 反変性) のサポートが導入されました。 つまり、シグネチャが一致するメソッドだけでなく、デリゲート型で指定された型よりも強い 派生型を返す (共変性) メソッドや、弱い派生型のパラメーターを受け取る (反変性) メソッドを、デリゲートに割り当てることがで きます。 これには、汎用デリゲートと非汎用デリゲートの両方が含まれます。
たとえば、次のコードについて考えます。このコードには、2 つのクラスと、汎用と非汎用の 2 つのデリゲートが含まれています。
SampleDelegate 型または SampleGenericDelegate<A, R> 型のデリゲートを作成する場合、そのデリゲートには、次のいずれ かのメソッドを割り当てることができます。
    public class First { }
public class Second : First { }
public delegate First SampleDelegate(Second a);
public delegate R SampleGenericDelegate<A, R>(A a);
       // Matching signature.
public static First ASecondRFirst(Second second)
{ return new First(); }
// The return type is more derived.
public static Second ASecondRSecond(Second second)
{ return new Second(); }
// The argument type is less derived.
public static First AFirstRFirst(First first)
{ return new First(); }
// The return type is more derived
// and the argument type is less derived.
public static Second AFirstRSecond(First first)
{ return new Second(); }
 次のコード例は、メソッド シグネチャとデリゲート型の間の暗黙的な変換を示しています。
    // Assigning a method with a matching signature
// to a non-generic delegate. No conversion is necessary.
SampleDelegate dNonGeneric = ASecondRFirst;
// Assigning a method with a more derived return type
// and less derived argument type to a non-generic delegate.
// The implicit conversion is used.
SampleDelegate dNonGenericConversion = AFirstRSecond;
// Assigning a method with a matching signature to a generic delegate.
// No conversion is necessary.
SampleGenericDelegate<Second, First> dGeneric = ASecondRFirst;
// Assigning a method with a more derived return type
// and less derived argument type to a generic delegate.
// The implicit conversion is used.
SampleGenericDelegate<Second, First> dGenericConversion = AFirstRSecond;
 その他の例については、「デリゲートの変性の使用 (C#)」および「Func および Action 汎用デリゲートでの変性の使用 (C#)」を 参照してください。
デリゲートの変性 (C#) 2020/11/02 • • Edit Online
 
         ジェネリック型パラメーターの変性
.NET Framework 4 以降では、デリゲート間の暗黙的な変換を有効にできるため、ジェネリック型パラメーターによって汎用デリ ゲートにさまざまな型が指定されていても、型が変性の要件を満たすように相互に継承されていれば、それらの汎用デリゲート は相互に割り当てることができます。
暗黙的な変換を有効にするには、 in キーワードまたは out キーワードを使用して、デリゲートでジェネリック パラメーターを共 変または反変として明示的に宣言する必要があります。
次のコード例は、共変のジェネリック型パラメーターが指定されたデリゲートを作成する方法を示しています。
    // Type T is declared covariant by using the out keyword.
public delegate T SampleGenericDelegate <out T>();
public static void Test()
{
    SampleGenericDelegate <String> dString = () => " ";
    // You can assign delegates to each other,
    // because the type T is declared covariant.
    SampleGenericDelegate <Object> dObject = dString;
}
 変性サポートのみを使用してメソッド シグネチャをデリゲート型に一致させ、 in キーワードと out キーワードを使用しない場 合、同等のラムダ式かメソッドを使用すれば、デリゲートをインスタンス化できることがありますが、デリゲートを別のデリゲートに割 り当てることはできません。
次のコード例では、 が を継承していますが、 SampleGenericDelegate<String> を に明示的に変換することはできません。 この問題を修正するには、ジェネリック パラメーター
T を out キーワードでマークします。
   String
Object
 SampleGenericDelegate<Object>
    public delegate T SampleGenericDelegate<T>();
public static void Test()
{
    SampleGenericDelegate<String> dString = () => " ";
    // You can assign the dObject delegate
    // to the same lambda expression as dString delegate
    // because of the variance support for
    // matching method signatures with delegate types.
    SampleGenericDelegate<Object> dObject = () => " ";
    // The following statement generates a compiler error
    // because the generic type T is not marked as covariant.
    // SampleGenericDelegate <Object> dObject = dString;
}
 .NET のバリアント型パラメーターが含まれる汎用デリゲート
.NET Framework 4 では、既存の複数の汎用デリゲートで、ジェネリック型パラメーターに対して変性サポートが導入されまし
た。
System名前空間の Action デリゲート。Action<T>、Action<T1,T2>など System名前空間の Func デリゲート。Func<TResult>、Func<T,TResult>など Predicate<T> デリゲート
Comparison<T> デリゲート
 
     Converter<TInput,TOutput> デリゲート
使用例を含む詳細については、「Func および Action 汎用デリゲートでの変性の使用 (C#)」を参照してください。
汎用デリゲートのバリアント型パラメーターの宣言
汎用デリゲートに共変または反変のジェネリック型パラメーターがある場合、そのデリゲートは "バリアント汎用デリゲート" と呼ばれ ます。
汎用デリゲートのジェネリック型パラメーターを共変として宣言するには、 out キーワードを使用します。 共変の型は、メソッドの 戻り値の型としてのみ使用できます。メソッド引数の型として使用することはできません。 共変の汎用デリゲートを宣言する方 法を次のコード例に示します。
汎用デリゲートのジェネリック型パラメーターを反変として宣言するには、 in キーワードを使用します。 反変の型は、メソッド引 数の型としてのみ使用できます。メソッドの戻り値の型として使用することはできません。 反変の汎用デリゲートを宣言する方法 を次のコード例に示します。
  public delegate R DCovariant<out R>();
   public delegate void DContravariant<in A>(A a);
     IMPORTANT
C# の ref 、 in 、 out パラメーターを、バリアントとしてマークすることはできません。
 同じデリゲートで、型パラメーターが異なる場合は、変性と共変性の両方をサポートすることもできます。 これを次の例に示しま す。
バリアント汎用デリゲートのインスタンス化と呼び出し
バリアント デリゲートのインスタンス化および呼び出しは、インバリアント デリゲートのインスタンス化および呼び出しと同様に行うこ とができます。 次の例では、ラムダ式によってデリゲートをインスタンス化します。
バリアント汎用デリゲートの結合
バリアント デリゲートは結合しないでください。 Combine メソッドはバリアント デリゲートの変換をサポートしていないため、デリ ゲートが厳密に同じ型である必要があります。そのため、次のコード例に示すように、Combineメソッドまたは + 演算子を使 用してデリゲートを結合すると、実行時例外が発生する可能性があります。
値型と参照型でのジェネリック型パラメーターの変性 ジェネリック型パラメーターの変性がサポートされるのは参照型だけです。 たとえば、整数は値型であるため、   を
  public delegate R DVariant<in A, out R>(A a);
     DVariant<String, String> dvariant = (String str) => str + " ";
dvariant("test");
     Action<object> actObj = x => Console.WriteLine("object: {0}", x);
Action<string> actStr = x => Console.WriteLine("string: {0}", x);
// All of the following statements throw exceptions at run time.
// Action<string> actCombine = actStr + actObj;
// actStr += actObj;
// Delegate.Combine(actStr, actObj);
  DVariant<int>
 
       または   に暗黙的に変換することはできません。 次の例は、値型ではジェネリック型パラメーターの変性がサポートされないことを示しています。
DVariant<Object>
DVariant<long>
      // The type T is covariant.
public delegate T DVariant<out T>();
// The type T is invariant.
public delegate T DInvariant<T>();
public static void Test()
{
    int i = 0;
    DInvariant<int> dInt = () => i;
    DVariant<int> dVariantInt = () => i;
    // All of the following statements generate a compiler error
    // because type variance in generic parameters is not supported
    // for value types, even if generic type parameters are declared variant.
    // DInvariant<Object> dObject = dInt;
    // DInvariant<long> dLong = dInt;
    // DVariant<Object> dVariantObject = dVariantInt;
    // DVariant<long> dVariantLong = dVariantInt;
}
 関連項目
ジェネリック
Func および Action 汎用デリゲートでの変性の使用 (C#) デリゲートを結合する方法 (マルチキャスト デリゲート)

       メソッドをデリゲートに割り当てると、"共変性" と "反変性" により、デリゲート型をメソッドのシグネチャに柔軟に一致させることが できます。 共変性により、メソッドの戻り値の型の派生を、デリゲートに定義されている型よりも強くできます。 また、反変性によ り、メソッドのパラメーター型の派生をデリゲート型よりも弱くできます。
例 1:共変性 説明
この例は、デリゲート シグネチャ内の戻り値の型から派生した戻り値の型を持つメソッドで、デリゲートをどのように使用できるか を示しています。 DogsHandler が返すデータ型は Dogs です。これは、デリゲートに定義された Mammals 型の派生型です。
コード
      class Mammals {}
class Dogs : Mammals {}
class Program
{
    // Define the delegate.
    public delegate Mammals HandlerMethod();
    public static Mammals MammalsHandler()
    {
        return null;
    }
    public static Dogs DogsHandler()
    {
        return null;
    }
    static void Test()
    {
        HandlerMethod handlerMammals = MammalsHandler;
        // Covariance enables this assignment.
        HandlerMethod handlerDogs = DogsHandler;
    }
}
 例 2:反変性 説明
この例は、型がデリゲート シグネチャ パラメーター型の基本データ型であるパラメーターを持つメソッドでデリゲートを使用する方 法を示しています。 反変性により、複数のハンドラーの代わりに単一のイベント ハンドラーを使用できます。 次の例では、2 つ のデリゲートを使用します。
Button.KeyDown イベントのシグネチャを定義する KeyEventHandler デリゲート。 そのシグネチャ:
  public delegate void KeyEventHandler(object sender, KeyEventArgs e)
 Button.MouseClick イベントのシグネチャを定義する MouseEventHandler デリゲート。 そのシグネチャ:
デリゲートの変性の使用 (C#) 2020/11/02 • • Edit Online
 
         この例では、イベントハンドラーとEventArgsパラメーターが定義され、そのパラメーターを使用し、Button.KeyDown と Button.MouseClick の両方のイベントが処理されます。これが可能になるのは、EventArgsはKeyEventArgsと
MouseEventArgs の両方の基本データ型であるためです。 コード
     // Event handler that accepts a parameter of the EventArgs type.
private void MultiHandler(object sender, System.EventArgs e)
{
    label1.Text = System.DateTime.Now.ToString();
}
public Form1()
{
    InitializeComponent();
    // You can use a method that has an EventArgs parameter,
    // although the event expects the KeyEventArgs parameter.
    this.button1.KeyDown += this.MultiHandler;
    // You can use the same method
    // for an event that expects the MouseEventArgs parameter.
    this.button1.MouseClick += this.MultiHandler;
}
 関連項目
デリゲートの変性 (C#)
Func および Action 汎用デリゲートでの変性の使用 (C#)
 public delegate void MouseEventHandler(object sender, MouseEventArgs e)
 
     以下の例では、 Func 汎用デリゲートと Action 汎用デリゲートの共変性と反変性を使用して、メソッドの再利用を可能に し、コードの柔軟性を高める方法を示します。
共変性と反変性の詳細については、「デリゲートの変性 (C# )」を参照してください。 デリゲートと共変の型パラメーターの使用
次の例は、 Func 汎用デリゲートにおける共変性のサポートの利点を示しています。 パラメーターを受け取り、 型のオブジェクトを返します。 ただし、このメソッドは 割り当てることもできます。これは が Person を継承するためです。
メソッドは、 型の デリゲートに
  FindByTitle
String
  Employee
Func<String, Person>
  Employee
    // Simple hierarchy of classes.
public class Person { }
public class Employee : Person { }
class Program
{
    static Employee FindByTitle(String title)
    {
        // This is a stub for a method that returns
        // an employee that has the specified title.
        return new Employee();
}
    static void Test()
    {
} }
// Create an instance of the delegate without using variance.
Func<String, Employee> findEmployee = FindByTitle;
// The delegate expects a method to return Person,
// but you can assign it a method that returns Employee.
Func<String, Person> findPerson = FindByTitle;
// You can also assign a delegate
// that returns a more derived type
// to a delegate that returns a less derived type.
findPerson = findEmployee;
 デリゲートと反変の型パラメーターの使用
   次の例は、 Action 汎用デリゲートにおける反変性のサポートの利点を示しています。 AddToContacts メソッドは、 Person 型のパラメーターを受け取ります。ただし、このメソッドは Action<Employee> デリゲートに割り当てることもできます。これは
Employee が Person を継承するためです。
   Func および Action 汎用デリゲート (Visual Basic)
の変性の使用
2020/11/02 • • Edit Online
 
    関連項目
共変性と反変性 (C#) ジェネリック
   public class Person { }
public class Employee : Person { }
class Program
{
    static void AddToContacts(Person person)
    {
        // This method adds a Person object
        // to a contact list.
    }
    static void Test()
    {
} }
// Create an instance of the delegate without using variance.
Action<Person> addPersonToContacts = AddToContacts;
// The Action delegate expects
// a method that has an Employee parameter,
// but you can assign it a method that has a Person parameter
// because Employee derives from Person.
Action<Employee> addEmployeeToContacts = AddToContacts;
// You can also assign a delegate
// that accepts a less derived parameter to a delegate
// that accepts a more derived parameter.
addEmployeeToContacts = addPersonToContacts;
 
                式ツリーでは、コードがツリー状のデータ構造で表示されます。各ノードは 1 つの式に対応しています。たとえば、メソッドの呼び 出しや x < y のような二項演算などです。
式ツリーで表されるコードはコンパイルおよび実行できます。 これによって、実行可能なコードの動的な変更、さまざまなデータ ベースでの LINQ クエリの実行、および動的クエリの作成が可能になります。 LINQ の式ツリーの詳細については、「式ツリーを 使用して動的クエリを作成する方法 (C#)」をご覧ください。
また、式ツリーを動的言語ランタイム (DLR) に使用することで、動的言語と .NET の間の相互運用性が実現し、コンパイラ ライ ターで Microsoft Intermediate language (MSIL) ではなく式ツリーを出力できるようになります。 DLR の詳細については、 「動的言語ランタイムの概要」を参照してください。
匿名のラムダ式に基づいて、C# と Visual Basic コンパイラで式ツリーを作成できます。または、System.Linq.Expressions 名 前空間を使用して手動で式ツリーを作成できます。
ラムダ式からの式ツリーの作成
ラムダ式が Expression<TDelegate> 型の変数に割り当てられている場合、コンパイラはラムダ式を表す式ツリーを構築する コードを出力します。
C# コンパイラは、式形式のラムダ (つまり単一行のラムダ) からのみ式ツリーを生成できます。 ステートメント形式のラムダ (つまり 複数行のラムダ) は解析できません。 C# のラムダ式の詳細については、「ラムダ式」を参照してください。
次のコード例は、ラムダ式 num => num < 5 を表す式ツリーを C# コンパイラで作成する方法を示しています。
API を使用した式ツリーの作成
API を使用して式ツリーを作成するには、Expression クラスを使用します。 このクラスには、特定の型を持つ式ツリー ノードを 作成する静的ファクトリ メソッドが含まれます。たとえば、変数またはパラメーターを表す ParameterExpression や、メソッドの 呼び出しを表す MethodCallExpression などです。 ParameterExpression、MethodCallExpression などの式固有の型 も、System.Linq.Expressions 名前空間で定義されます。 これらの型は、Expression 抽象型から派生したものです。
次のコード例は、APIを使用して、ラムダ式 num => num < 5 を表す式ツリーを作成する方法を示しています。
   Expression<Func<int, bool>> lambda = num => num < 5;
      // Add the following using directive to your code file:
// using System.Linq.Expressions;
// Manually build the expression tree for
// the lambda expression num => num < 5.
ParameterExpression numParam = Expression.Parameter(typeof(int), "num");
ConstantExpression five = Expression.Constant(5, typeof(int));
BinaryExpression numLessThanFive = Expression.LessThan(numParam, five);
Expression<Func<int, bool>> lambda1 =
    Expression.Lambda<Func<int, bool>>(
        numLessThanFive,
        new ParameterExpression[] { numParam });
  .NETFramework4以降の式ツリーAPIは、割り当て式、制御フロー式(ループ、条件ブロック)、および try-catch ブロックも サポートしています。 API を使用すると、C# コンパイラのラムダ式から作成できる式ツリーよりも複雑な式ツリーを作成できます。
式ツリー (C#) 2020/11/02 • • Edit Online
 
  次の例は、数値の階乗を計算する式ツリーを作成する方法を示しています。
    // Creating a parameter expression.
ParameterExpression value = Expression.Parameter(typeof(int), "value");
// Creating an expression to hold a local variable.
ParameterExpression result = Expression.Parameter(typeof(int), "result");
// Creating a label to jump to from a loop.
LabelTarget label = Expression.Label(typeof(int));
// Creating a method body.
BlockExpression block = Expression.Block(
    // Adding a local variable.
    new[] { result },
    // Assigning a constant to a local variable: result = 1
    Expression.Assign(result, Expression.Constant(1)),
    // Adding a loop.
        Expression.Loop(
    // Adding a conditional block into the loop.
           Expression.IfThenElse(
    // Condition: value > 1
               Expression.GreaterThan(value, Expression.Constant(1)),
    // If true: result *= value --
               Expression.MultiplyAssign(result,
                   Expression.PostDecrementAssign(value)),
    // If false, exit the loop and go to the label.
               Expression.Break(label, result)
           ),
    // Label to jump to.
label )
);
// Compile and execute an expression tree.
int factorial = Expression.Lambda<Func<int, int>>(block, value).Compile()(5);
Console.WriteLine(factorial);
// Prints 120.
 詳細については、「Generating Dynamic Methods with Expression Trees in Visual Studio 2010 (Visual Studio 2010 での式ツリーによる動的メソッドの生成)」を参照し、Visual Studio 2010 以降のバージョンについても同じ方法を適用してくだ さい。
式ツリーの解析
次のコード例は、ラムダ式 num => num < 5 を表す式ツリーを各部分に分解する方法を示しています。
 
           式ツリーの不変性
式ツリーは変更できません。 つまり、式ツリーを変更するには、既存の式ツリーをコピーしてツリー内のノードを置き換えることで、 新しい式ツリーを作成する必要があります。 式ツリー ビジターを使用して、既存の式ツリーを走査することができます。 詳細につ いては、「式ツリーを変更する方法 (C#)」を参照してください。
式ツリーのコンパイル
Expression<TDelegate> 型に含まれる Compile メソッドにより、式ツリーが表すコードを実行可能なデリゲートにコンパイルし ます。
次のコード例は、式ツリーをコンパイルして結果のコードを実行する方法を示しています。
    // Creating an expression tree.
Expression<Func<int, bool>> expr = num => num < 5;
// Compiling the expression tree into a delegate.
Func<int, bool> result = expr.Compile();
// Invoking the delegate and writing the result to the console.
Console.WriteLine(result(4));
// Prints True.
// You can also use simplified syntax
// to compile and run an expression tree.
// The following line can replace two previous statements.
Console.WriteLine(expr.Compile()(4));
// Also prints True.
 詳細については、「式ツリーを実行する方法 (C#)」を参照してください。 関連項目
System.Linq.Expressions
式ツリーを実行する方法 (C#) 式ツリーを変更する方法 (C#) ラムダ式 動的言語ランタイムの概要
   // Add the following using directive to your code file:
// using System.Linq.Expressions;
// Create an expression tree.
Expression<Func<int, bool>> exprTree = num => num < 5;
// Decompose the expression tree.
ParameterExpression param = (ParameterExpression)exprTree.Parameters[0];
BinaryExpression operation = (BinaryExpression)exprTree.Body;
ParameterExpression left = (ParameterExpression)operation.Left;
ConstantExpression right = (ConstantExpression)operation.Right;
Console.WriteLine("Decomposed expression: {0} => {1} {2} {3}",
                  param.Name, left.Name, operation.NodeType, right.Value);
// This code produces the following output:
// Decomposed expression: num => num LessThan 5
 
  プログラミングの概念 (C#)

            このトピックでは、式ツリーを実行する方法について説明します。 式ツリーを実行すると値が返される場合がありますが、メソッド の呼び出しなどの処理が実行されるだけの場合もあります。
実行できるのは、ラムダ式を表す式ツリーのみです。 ラムダ式を表す式ツリーの型は、LambdaExpression または Expression<TDelegate> です。 このような式ツリーを実行するには、Compile メソッドを呼び出して実行可能なデリゲートを 作成した後、そのデリゲートを呼び出します。
式ツリーがラムダ式を表さない場合、Lambda<TDelegate>(Expression, IEnumerable<ParameterExpression>) メソッド を呼び出すことで、元の式ツリーを本体に含む新しいラムダ式を作成できます。 その後、このセクションの説明のとおりにラムダ式 を実行できます。
例
次のコード例は、ラムダ式を作成して実行することで数値の累乗を表す式ツリーの実行方法を示しています。 このコードを実 行すると、累乗された数値を表す結果が表示されます。
    NOTE
デリゲートの型が不明な場合、つまり、ラムダ式が LambdaExpression 型であり Expression<TDelegate> 型ではない場合には、デリゲー トを直接呼び出さずに、デリゲートに対して DynamicInvoke メソッドを呼び出す必要があります。
     // The expression tree to execute.
BinaryExpression be = Expression.Power(Expression.Constant(2D), Expression.Constant(3D));
// Create a lambda expression.
Expression<Func<double>> le = Expression.Lambda<Func<double>>(be);
// Compile the lambda expression.
Func<double> compiledExpression = le.Compile();
// Execute the lambda expression.
double result = compiledExpression();
// Display the result.
Console.WriteLine(result);
// This code produces the following output:
// 8
 コードのコンパイル
System.Linq.Expressions 名前空間をインクルードします。
関連項目
式ツリー (C#) 式ツリーを変更する方法 (C#)
式ツリーを実行する方法 (C#) 2020/11/02 • • Edit Online
 
      このトピックでは、式ツリーを変更する方法について説明します。 式ツリーは変更不可であるため、直接変更を加えることができ ません。 式ツリーを変更するには、既存の式ツリーのコピーを作成する必要があります。コピーを作成する際に、必要な変更を 加えます。 ExpressionVisitor クラスを使用して、既存の式ツリーを走査し、走査した各ノードをコピーすることができます。
式ツリーを変更するには
1. 新しいコンソール アプリケーション プロジェクトを作成します。
2. ファイルに System.Linq.Expressions 名前空間の using ディレクティブを 追加します。
3. AndAlsoModifier クラスをプロジェクトに追加します。
      public class AndAlsoModifier : ExpressionVisitor
{
    public Expression Modify(Expression expression)
    {
        return Visit(expression);
    }
    protected override Expression VisitBinary(BinaryExpression b)
    {
        if (b.NodeType == ExpressionType.AndAlso)
        {
b.Method); }
Expression left = this.Visit(b.Left);
Expression right = this.Visit(b.Right);
// Make this binary expression an OrElse operation instead of an AndAlso operation.
return Expression.MakeBinary(ExpressionType.OrElse, left, right, b.IsLiftedToNull,
        return base.VisitBinary(b);
    }
}
 このクラスは、AND 条件演算を表す式を変更するための特別なクラスで、ExpressionVisitorクラスを継承します。こ のクラスによって条件 AND が条件 OR に変更されます。そのために、クラスは基本データ型のVisitBinaryメソッドを オーバーライドします。 AND 条件式は二項式で表されるためです。 VisitBinary メソッドでは、渡される式が AND 条件演算を表す場合、 AND 条件演算子ではなく OR 条件演算子を含む新しい式がコードによって作成されます。
VisitBinary に渡される式が AND 条件演算を表さない場合は、基底クラスの実装が延期されます。 基底クラスのメ ソッドによって、渡された式ツリーに似たノードが作成されますが、そのノードのサブツリーは、ビジターによって再帰的に作 成される式ツリーに置き換えられます。
4. ファイルに System.Linq.Expressions 名前空間の using ディレクティブを 追加します。
5. 式ツリーを作成し、それをメソッドに渡して変更するコードを、Program.cs ファイルの Main メソッドに追加します。
   式ツリーを変更する方法 (C#) 2020/11/02 • • Edit Online
 
     次のコードは、 AND 条件演算を含む式を作成し、 AndAlsoModifier クラスのインスタンスを作成して、このクラスの Modify メソッドにその式を渡します。元の式ツリーと変更された式ツリーの両方が出力され、変更内容が表示されま
す。
6. アプリケーションをコンパイルして実行します。
関連項目
式ツリーを実行する方法 (C#) 式ツリー (C#)
    Expression<Func<string, bool>> expr = name => name.Length > 10 && name.StartsWith("G");
Console.WriteLine(expr);
AndAlsoModifier treeModifier = new AndAlsoModifier();
Expression modifiedExpr = treeModifier.Modify((Expression) expr);
Console.WriteLine(modifiedExpr);
/*  This code produces the following output:
    name => ((name.Length > 10) && name.StartsWith("G"))
    name => ((name.Length > 10) || name.StartsWith("G"))
*/
 
             データ ソースに対して IQueryable または IQueryable<T> を定義するコードについて考えてみます。
    var companyNames = new[] {
    "Consolidated Messenger", "Alpine Ski House", "Southridge Video",
    "City Power & Light", "Coho Winery", "Wide World Importers",
    "Graphic Design Institute", "Adventure Works", "Humongous Insurance",
    "Woodgrove Bank", "Margie's Travel", "Northwind Traders",
    "Blue Yonder Airlines", "Trey Research", "The Phone Company",
    "Wingtip Toys", "Lucerne Publishing", "Fourth Coffee"
};
// We're using an in-memory array as the data source, but the IQueryable could have come
// from anywhere -- an ORM backed by a database, a web request, or any other LINQ provider.
IQueryable<string> companyNamesSource = companyNames.AsQueryable();
var fixedQry = companyNames.OrderBy(x => x);
 このコードを実行するたびに、同じクエリが実行されます。 実行時の状態に応じてさまざまなクエリを実行するコードが必要にな る可能性があるため、これは多くの場合、あまり役に立ちません。 この記事では、実行時の状態に基づいて別のクエリを実行す る方法について説明します。
IQueryable または IQueryable<T> および式ツリー 基本的に、IQueryable には次の 2 つのコンポーネントがあります。
Expression — 式ツリーの形式である、現在のクエリのコンポーネントの言語およびデータソースに依存しない表現。 Provider — 現在のクエリを値または値のセットに具体化する方法を認識している LINQ プロバイダーのインスタンス。
動的なクエリのコンテキストでは、通常、プロバイダーは同じままとなります。クエリの式ツリーはクエリによって異なります。 式ツリーは変更できません。別の式ツリー — したがって、別のクエリ — が必要な場合は、既存の式ツリーを新しいもの (した
がって、新しい IQueryable) に変換する必要があります。 次のセクションでは、実行時の状態に応じて異なる方法でクエリを実行する特定の手法について説明します。
式ツリー内から実行時の状態を使用する
追加の LINQ メソッドを呼び出す
LINQ メソッドに渡される式ツリーを変更する
Expression でファクトリ メソッドを使用して、Expression<TDelegate> 式ツリー式を構築する IQueryable の式ツリーにメソッド呼び出しノードを追加する
文字列を構築し、動的 LINQ ライブラリを使用する 式ツリー内から実行時の状態を使用する
LINQ プロバイダーでサポートされていると仮定した場合にクエリを動的に実行する最も簡単な方法は、次のコード例の length など、閉じ込められた変数を使用して、クエリ内の実行時の状態を直接参照することです。
 実行時の状態に基づくクエリの実行 (C#) 2021/03/06 • • Edit Online
 
          内部式ツリー—したがって、クエリ—は変更されていません。このクエリの場合は、length の値が変更されているため、異なる 値が返されます。
追加の LINQ メソッドを呼び出す
一般に、Queryable の組み込みの LINQ メソッドでは、次の 2 つの手順を行います。
メソッド呼び出しを表す MethodCallExpression で現在の式ツリーをラップする。 ラップされた式ツリーをプロバイダーに戻し、プロバイダーの IQueryProvider.Execute メソッドを使用して値を返す か、IQueryProvider.CreateQuery メソッドを使用して変換されたクエリ オブジェクトを返す。
元のクエリを、IQueryable<T> を返すメソッドの結果に置き換えて、新しいクエリを取得できます。 次の例のように、実行時の 状態に基づいて条件付きでこれを行うことができます。
    // bool sortByLength = /* ... */;
var qry = companyNamesSource;
if (sortByLength)
{
    qry = qry.OrderBy(x => x.Length);
}
 LINQ メソッドに渡される式ツリーを変更する 実行時の状態に応じて、LINQ メソッドに異なる式を渡すことができます。
    // string? startsWith = /* ... */;
// string? endsWith = /* ... */;
Expression<Func<string, bool>> expr = (startsWith, endsWith) switch
{
    ("" or null, "" or null) => x => true,
    (_, "" or null) => x => x.StartsWith(startsWith),
    ("" or null, _) => x => x.EndsWith(endsWith),
    (_, _) => x => x.StartsWith(startsWith) || x.EndsWith(endsWith)
};
var qry = companyNamesSource.Where(expr);
 LinqKit の PredicateBuilder などのサードパーティ製ライブラリを使用して、さまざまなサブ式を構成することもできます。
   var length = 1;
var qry = companyNamesSource
    .Select(x => x.Substring(0, length))
    .Distinct();
Console.WriteLine(string.Join(",", qry));
// prints: C, A, S, W, G, H, M, N, B, T, L, F
length = 2;
Console.WriteLine(string.Join(",", qry));
// prints: Co, Al, So, Ci, Wi, Gr, Ad, Hu, Wo, Ma, No, Bl, Tr, Th, Lu, Fo
 
               ファクトリ メソッドを使用して式ツリーとクエリを構築する
この時点までのすべての例では、コンパイル時に要素型 — string — (したがって、クエリの型 — IQueryable<string> ) がわ かっています。 要素型に関係なくクエリにコンポーネントを追加したり、要素型に応じて異なるコンポーネントを追加したりするこ とが、必要になる場合があります。 System.Linq.Expressions.Expression でファクトリ メソッドを使用して、最初から式ツリーを 作成し、実行時に特定の要素型に合わせて式を調整することができます。
Expression<TDelegate> の構築
LINQ メソッドのいずれかに渡す式を構築する場合、実際には Expression<TDelegate> のインスタンスを構築することになり
ます。ここで、 TDelegate は Func<string, bool> 、 Action 、カスタム デリゲート型などの何らかのデリゲート型です。 Expression<TDelegate> は LambdaExpression から継承されます。これは、次のような完全なラムダ式を表します。
LambdaExpression には次の 2 つのコンポーネントがあります。
パラメーター リスト — — Parameters プロパティによって表されます
本文 — — Body プロパティによって表されます。 Expression<TDelegate> を構築するための基本的な手順は次のとおりです。
Parameter ファクトリ メソッドを使用して、ラムダ式内の各パラメーター (存在する場合) に ParameterExpression オブ ジェクトを定義する。
定義した ParameterExpression と、Expression のファクトリ メソッドを使用して、LambdaExpression の本体を作成 します。 たとえば、 x.StartsWith("a") を表す式はこのように構築できます。
       Expression<Func<string, bool>> expr = x => x.StartsWith("a");
  (string x)
 x.StartsWith("a")
  ParameterExpression x = Parameter(typeof(string), "x");
     // This is functionally equivalent to the previous example.
// using LinqKit;
// string? startsWith = /* ... */;
// string? endsWith = /* ... */;
Expression<Func<string, bool>>? expr = PredicateBuilder.New<string>(false);
var original = expr;
if (!string.IsNullOrEmpty(startsWith))
{
    expr = expr.Or(x => x.StartsWith(startsWith));
}
if (!string.IsNullOrEmpty(endsWith))
{
    expr = expr.Or(x => x.EndsWith(endsWith));
}
if (expr == original)
{
    expr = x => true;
}
var qry = companyNamesSource.Where(expr);
 
     適切な Lambda ファクトリ メソッドのオーバーロードを使用して、コンパイル時に型指定された Expression<TDelegate> にパラメーターと本文をラップする。
次のセクションでは、LINQ メソッドに渡す Expression<TDelegate> を構築することが望ましいシナリオについて説明し、ファク トリ メソッドを使用してそれを行う方法の完全な例を示します。
シナリオ たとえば、複数のエンティティ型があるとします。
これらのいずれかのエンティティ型については、string フィールドの1つに特定のテキストが含まれているエンティティのみをフィル ター処理して返す必要があります。 については、 FirstName と LastName のプロパティを検索する必要があります。
しかし、 Car については、 Model プロパティのみを検索する必要があります。
IQueryable<Person> 用にカスタム関数を1つと、IQueryable<Car> 用にもう1つを記述することもできますが、次の関数で は、特定の要素型に関係なく、このフィルターを既存のすべてのクエリに追加します。
例
  Expression<Func<string, bool>> expr = Lambda<Func<string, bool>>(body, x);
     record Person(string LastName, string FirstName, DateTime DateOfBirth);
record Car(string Model, int Year);
   Person
      string term = /* ... */;
var personsQry = new List<Person>()
    .AsQueryable()
    .Where(x => x.FirstName.Contains(term) || x.LastName.Contains(term));
     string term = /* ... */;
var carsQry = new List<Car>()
    .AsQueryable()
    .Where(x => x.Model.Contains(term));
      Expression body = Call(
    x,
    typeof(string).GetMethod("StartsWith", new[] { typeof(string) })!,
    Constant("a")
);
 
       TextFilter 関数ではIQueryable<T>(IQueryableだけでなく)を受け取って返すため、テキストフィルターの後にコンパイル 時に型指定されたクエリ要素をさらに追加できます。
  // using static System.Linq.Expressions.Expression;
IQueryable<T> TextFilter<T>(IQueryable<T> source, string term)
{
    if (string.IsNullOrEmpty(term)) { return source; }
    // T is a compile-time placeholder for the element type of the query.
    Type elementType = typeof(T);
    // Get all the string properties on this specific type.
    PropertyInfo[] stringProperties =
        elementType.GetProperties()
            .Where(x => x.PropertyType == typeof(string))
            .ToArray();
    if (!stringProperties.Any()) { return source; }
    // Get the right overload of String.Contains
    MethodInfo containsMethod = typeof(string).GetMethod("Contains", new[] { typeof(string) })!;
    // Create a parameter for the expression tree:
    // the 'x' in 'x => x.PropertyName.Contains("term")'
    // The type of this parameter is the query's element type
    ParameterExpression prm = Parameter(elementType);
    // Map each property to an expression tree node
    IEnumerable<Expression> expressions = stringProperties
        .Select(prp =>
            // For each property, we have to construct an expression tree node like
x.PropertyName.Contains("term")
            Call(
// .Contains(...)
// .PropertyName
// x
// "term"
) );
Property(
    prm,
prp ),
containsMethod,
Constant(term)
    // Combine all the resultant expression nodes using ||
    Expression body = expressions
        .Aggregate(
            (prev, current) => Or(prev, current)
);
    // Wrap the expression body in a compile-time-typed lambda expression
    Expression<Func<T, bool>> lambda = Lambda<Func<T, bool>>(body, prm);
    // Because the lambda is compile-time-typed (albeit with a generic parameter), we can use it with the
Where method
    return source.Where(lambda);
}

              IQueryable の式ツリーにメソッド呼び出しノードを追加する
IQueryable<T> の代わりに IQueryable がある場合、汎用 LINQ メソッドを直接呼び出すことはできません。 代替手段の 1 つは、上記のように内部式ツリーをビルドし、リフレクションを使用して、式ツリーに渡すときに適切な LINQ メソッドを呼び出すこ とです。
LINQ メソッドの呼び出しを表す MethodCallExpression でツリー全体をラップすることにより、LINQ メソッドの機能を複製する こともできます。
    IQueryable TextFilter_Untyped(IQueryable source, string term)
{
    if (string.IsNullOrEmpty(term)) { return source; }
    Type elementType = source.ElementType;
    // The logic for building the ParameterExpression and the LambdaExpression's body is the same as in the
previous example,
    // but has been refactored into the constructBody function.
    (Expression? body, ParameterExpression? prm) = constructBody(elementType, term);
    if (body is null) {return source;}
    Expression filteredTree = Call(
        typeof(Queryable),
        "Where",
        new[] { elementType},
        source.Expression,
        Lambda(body, prm!)
);
    return source.Provider.CreateQuery(filteredTree);
}
 この場合、コンパイル時の T 汎用プレースホルダーがないため、Expression<TDelegate>の代わりに、コンパイル時の型情 報を必要としない、LambdaExpression を生成する Lambda オーバーロードを使用することに注意してください。
動的 LINQ ライブラリ
ファクトリ メソッドを使用した式ツリーの構築は比較的複雑です。文字列を作成する方が簡単です。 動的 LINQ ライブラリで は、Queryableで標準 LINQ メソッドに対応する IQueryable の拡張メソッドのセットを公開し、式ツリーではなく特殊な構 文で文字列を受け入れます。 ライブラリで文字列から適切な式ツリーが生成され、結果として変換された IQueryable を返す ことができます。
たとえば、前の例は次のように書き換えることができます。
   var qry = TextFilter(
        new List<Person>().AsQueryable(),
        "abcd"
    )
    .Where(x => x.DateOfBirth < new DateTime(2001, 1, 1));
var qry1 = TextFilter(
        new List<Car>().AsQueryable(),
"abcd" )
    .Where(x => x.Year == 2010);
 
     関連項目
式ツリー (C#)
式ツリーを実行する方法 (C#) 実行時における述語フィルターの動的指定
   // using System.Linq.Dynamic.Core
IQueryable TextFilter_Strings(IQueryable source, string term) {
    if (string.IsNullOrEmpty(term)) { return source; }
    var elementType = source.ElementType;
    // Get all the string property names on this specific type.
    var stringProperties =
        elementType.GetProperties()
            .Where(x => x.PropertyType == typeof(string))
            .ToArray();
    if (!stringProperties.Any()) { return source; }
    // Build the string expression
    string filterExpr = string.Join(
" || ",
        stringProperties.Select(prp => $"{prp.Name}.Contains(@0)")
    );
    return source.Where(filterExpr, term);
}
 
           アプリケーションをデバッグするときに、式ツリーの構造および内容を分析できます。 式ツリーの構造の概要を簡単に取得するに は、 DebugView プロパティ使用できます。このプロパティでは、特殊な構文を使って式ツリーが表されます。 ( DebugView はデ バッグ モードでのみ使用できることに注意してください。)
DebugView は文字列なので、組み込まれているテキストビジュアライザーを使って、複数行で表示できます。テキストビジュア ライザーを使うには、 DebugView ラベルの隣にある虫眼鏡アイコンから選択します。
または、式ツリー用のカスタム ビジュアライザーをインストールして使うこともできます。例:
ReadableExpressions (MIT ライセンス、Visual Studio Marketplace で使用可能): 式ツリーがテーマを設定できる
C# コードとしてレンダリングされます。さまざまなレンダリング オプションがあります。
Expression Tree Visualizer (MIT ライセンス) では、式ツリーとその個々のノードのツリー ビューが提供されます。
       式ツリーのデバッグ (Visual Studio) (C#) 2020/11/02 • • Edit Online
 
      式ツリーのビジュアライザーを開くには
1. [データヒント] 、 [ウォッチ] ウィンドウ、 [自動変数] ウィンドウ、または [ローカル] ウィンドウで、式ツリーの横に表示さ れている虫眼鏡のアイコンをクリックします。
使用可能なビジュアライザーの一覧が表示されます。
2. 使用するビジュアライザーをクリックします。 関連項目
式ツリー (C#)
Visual Studio でのデバッグ カスタム ビジュアライザーを作成する
DebugView 構文
  
           DebugView プロパティ (デバッグ時にのみ利用可能) を指定すると、式ツリーが文字列でレンダリングされます。 構文の大部 分はかなりわかりやすいです。特別なケースについて以降のセクションで説明します。
各例の後に、DebugView を含むブロック コメントが示されています。 ParameterExpression
ParameterExpression変数名は、先頭に記号 $ を付けて表示されます。 パラメーターに名前がない場合、 $var1 や $var2 など、自動的に生成された名前が割り当てられます。 使用例
    ParameterExpression numParam =  Expression.Parameter(typeof(int), "num");
/*
$num */
ParameterExpression numParam =  Expression.Parameter(typeof(int));
/*
$var1 */
 ConstantExpression
整数値、文字列、および null を表すConstantExpressionオブジェクトの場合、定数の値が表示されます。
C# リテラルとしての標準のサフィックスを持つ数値型の場合、サフィックスが値に追加されます。 さまざまな数値型に関連するサ
フィックスを次の表に示します。
System.UInt32 System.Int64 System.UInt64 System.Double System.Single System.Decimal
使用例
uint U long L ulong UL double D float F decimal M
                                       DebugView の構文 2021/03/06 • • Edit Online
 
       BlockExpression BlockExpressionオブジェクトの型がブロック内の最後の式の型と異なる場合、その型が山かっこ(< と >)内に表示されま
す。 それ以外の場合、BlockExpression オブジェクトの型は表示されません。 使用例
    BlockExpression block = Expression.Block(Expression.Constant("test"));
/*
    .Block() {
        "test"
} */
BlockExpression block =  Expression.Block(typeof(Object), Expression.Constant("test"));
/*
    .Block<System.Object>() {
        "test"
} */
 LambdaExpression
LambdaExpression オブジェクトは、デリゲート型と共に表示されます。
ラムダ式に名前がない場合、 #Lambda1 や #Lambda2 など、自動的に生成された名前が割り当てられます。 使用例
      LambdaExpression lambda =  Expression.Lambda<Func<int>>(Expression.Constant(1));
/*
    .Lambda #Lambda1<System.Func'1[System.Int32]>() {
        1
} */
LambdaExpression lambda = Expression.Lambda<Func<int>>(Expression.Constant(1), "SampleLambda", null); /*
    .Lambda #SampleLambda<System.Func'1[System.Int32]>() {
        1
} */
 LabelExpression
LabelExpression オブジェクトの既定値を指定した場合、その値が LabelTarget オブジェクトの前に表示されます。
   int num = 10;
ConstantExpression expr = Expression.Constant(num);
/*
10 */
double num = 10;
ConstantExpression expr = Expression.Constant(num);
/*
10D */
 
    トークンは、ラベルの開始を示します。   トークンは、ジャンプ先のターゲットを示します。 ラベルに名前がない場合、 #Label1 や #Label2 など、自動的に生成された名前が割り当てられます。 使用例
.Label
.LabelTarget
        LabelTarget target = Expression.Label(typeof(int), "SampleLabel");
BlockExpression block = Expression.Block(
    Expression.Goto(target, Expression.Constant(0)),
    Expression.Label(target, Expression.Constant(-1))
);
/*
.Block() {
} */
} */
.Goto SampleLabel { 0 };
.Label
    -1
.LabelTarget SampleLabel:
LabelTarget target = Expression.Label();
BlockExpression block = Expression.Block(
    Expression.Goto(target),
    Expression.Label(target)
);
/*
.Block() {
.Goto #Label1 { };
.Label
.LabelTarget #Label1:
 checked 演算子
checked演算子は、演算子の前に # 記号が付く形式で表示されます。たとえば、checked加算演算子は #+ と表示さ
れます。 使用例
    Expression expr = Expression.AddChecked( Expression.Constant(1), Expression.Constant(2));
/*
1 #+ 2 */
Expression expr = Expression.ConvertChecked( Expression.Constant(10.0), typeof(int));
/*
    #(System.Int32)10D
*/
 
        反復子を使用して、リストや配列などのコレクションをステップ実行することができます。
iteratorメソッドまたは get アクセサーは、コレクションに対するカスタムイテレーションを実行します。反復子メソッドは、yield return ステートメントを使用して、各要素を 1 回に 1 つ返します。 yield return ステートメントに達すると、コードの現在の 場所が記憶されます。 次回、iterator 関数が呼び出されると、この位置から実行が再開されます。
foreach ステートメントまたは LINQ クエリを使用して、クライアント コードから反復子を呼び出します。
次の例では、 foreach ループの最初の反復子により、最初の yield return ステートメントに達するまで SomeNumbers iterator メソッドで実行が続行されます。 このイテレーションは 3 の値を返し、iterator メソッドの現在の場所が保持されます。 ループの次のイテレーションでは、iterator メソッドの実行が中断した場所から続行し、 yield return ステートメントに達したと きに再度停止します。 このイテレーションは 5 の値を返し、ここでも iterator メソッドの現在の場所が保持されます。 iterator メソッドの最後に達すると、ループが完了します。
         static void Main()
{
    foreach (int number in SomeNumbers())
    {
        Console.Write(number.ToString() + " ");
    }
    // Output: 3 5 8
    Console.ReadKey();
}
public static System.Collections.IEnumerable SomeNumbers()
{
    yield return 3;
    yield return 5;
    yield return 8;
}
 Iteratorメソッドまたは get アクセサーの戻り値の型は、IEnumerable、IEnumerable<T>、IEnumerator、または IEnumerator<T> となります。
yield break ステートメントを使用すると、反復を終了できます。
単純な反復子
次の例では、for ループ内に 1 つの yield return ステートメントが含まれます。 Main では、 foreach ステートメント本文の 各イテレーションで iterator 関数が呼び出され、これが次の yield return ステートメントに続行されます。
     NOTE
このトピックの単純な反復子の例を除くすべての例には、 System.Collections および System.Collections.Generic 名前空間の using ディレクティブが含まれています。
      反復子 (C#) 2020/11/02 • • Edit Online
 
     コレクション クラスを作成する
次の例の DaysOfTheWeek クラスは、GetEnumeratorメソッドを必要とするIEnumerableインターフェイスを実装します。コン
パイラは、IEnumeratorを返す GetEnumerator メソッドを暗黙的に呼び出します。
GetEnumerator メソッドは、 yield return ステートメントを使用して、各文字列を一度に 1 つ返します。
        static void Main()
{
    DaysOfTheWeek days = new DaysOfTheWeek();
    foreach (string day in days)
    {
        Console.Write(day + " ");
    }
    // Output: Sun Mon Tue Wed Thu Fri Sat
    Console.ReadKey();
}
public class DaysOfTheWeek : IEnumerable
{
    private string[] days = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
    public IEnumerator GetEnumerator()
    {
} }
for (int index = 0; index < days.Length; index++)
{
    // Yield each day of the week.
    yield return days[index];
}
 次の例では、動物のコレクションを含む Zoo クラスを作成します。
クラス インスタンス ( ) を参照する ステートメントでは、 メソッドが暗黙的に呼び出されます。 Birds および プロパティを参照する ステートメントでは、 という名前のiteratorメソッド
が使用されます。
   Mammals
theZoo
foreach
GetEnumerator
   foreach
AnimalsForType
   static void Main()
{
    foreach (int number in EvenSequence(5, 18))
    {
        Console.Write(number.ToString() + " ");
    }
    // Output: 6 8 10 12 14 16 18
    Console.ReadKey();
}
public static System.Collections.Generic.IEnumerable<int>
    EvenSequence(int firstNumber, int lastNumber)
{
    // Yield even numbers in the range.
    for (int number = firstNumber; number <= lastNumber; number++)
    {
} }
if (number % 2 == 0)
{
    yield return number;
}
      
   static void Main()
{
    Zoo theZoo = new Zoo();
    theZoo.AddMammal("Whale");
    theZoo.AddMammal("Rhinoceros");
    theZoo.AddBird("Penguin");
    theZoo.AddBird("Warbler");
    foreach (string name in theZoo)
    {
        Console.Write(name + " ");
    }
    Console.WriteLine();
    // Output: Whale Rhinoceros Penguin Warbler
    foreach (string name in theZoo.Birds)
    {
        Console.Write(name + " ");
    }
    Console.WriteLine();
    // Output: Penguin Warbler
    foreach (string name in theZoo.Mammals)
    {
        Console.Write(name + " ");
    }
    Console.WriteLine();
    // Output: Whale Rhinoceros
    Console.ReadKey();
}
public class Zoo : IEnumerable
{
    // Private members.
    private List<Animal> animals = new List<Animal>();
    // Public methods.
    public void AddMammal(string name)
    {
        animals.Add(new Animal { Name = name, Type = Animal.TypeEnum.Mammal });
    }
    public void AddBird(string name)
    {
        animals.Add(new Animal { Name = name, Type = Animal.TypeEnum.Bird });
    }
    public IEnumerator GetEnumerator()
    {
        foreach (Animal theAnimal in animals)
        {
            yield return theAnimal.Name;
        }
}
    // Public members.
    public IEnumerable Mammals
    {
        get { return AnimalsForType(Animal.TypeEnum.Mammal); }
    }
    public IEnumerable Birds
    {
        get { return AnimalsForType(Animal.TypeEnum.Bird); }
    }
// Private methods.
  
       // Private methods.
 ジェネリック リストと共に反復子を使用する
次の例の Stack<T> ジェネリック クラスは、IEnumerable<T> ジェネリック インターフェイスを実装しています。 Push メソッドで は、 T 型の配列に値を割り当てます。 GetEnumerator メソッドは、 yield return ステートメントを使って配列値を返しま す。
ジェネリック メソッド GetEnumerator だけでなく、非ジェネリック メソッド GetEnumerator も実装する必要があります。 これ は、IEnumerable<T> が IEnumerable から継承するためです。 非ジェネリック実装は、ジェネリック実装に従います。
例では名前付き反復子を使用して、同じデータ コレクションでのさまざまな反復処理をサポートします。 この場合の名前付き 反復子は、 TopToBottom プロパティと BottomToTop プロパティ、および TopN メソッドです。
BottomToTop プロパティは get アクセサーで反復子を使用します。
          private IEnumerable AnimalsForType(Animal.TypeEnum type)
{
    foreach (Animal theAnimal in animals)
    {
} }
if (theAnimal.Type == type)
{
    yield return theAnimal.Name;
}
    // Private class.
    private class Animal
    {
        public enum TypeEnum { Bird, Mammal }
        public string Name { get; set; }
        public TypeEnum Type { get; set; }
    }
}
  static void Main()
{
    Stack<int> theStack = new Stack<int>();
    //  Add items to the stack.
    for (int number = 0; number <= 9; number++)
    {
        theStack.Push(number);
    }
    // Retrieve items from the stack.
    // foreach is allowed because theStack implements IEnumerable<int>.
    foreach (int number in theStack)
    {
        Console.Write("{0} ", number);
    }
    Console.WriteLine();
    // Output: 9 8 7 6 5 4 3 2 1 0
    // foreach is allowed, because theStack.TopToBottom returns IEnumerable(Of Integer).
    foreach (int number in theStack.TopToBottom)
    {
        Console.Write("{0} ", number);
    }
    Console.WriteLine();
    // Output: 9 8 7 6 5 4 3 2 1 0
    foreach (int number in theStack.BottomToTop)
    {

          Console.Write("{0} ", number);
    }
    Console.WriteLine();
    // Output: 0 1 2 3 4 5 6 7 8 9
    foreach (int number in theStack.TopN(7))
    {
        Console.Write("{0} ", number);
    }
    Console.WriteLine();
    // Output: 9 8 7 6 5 4 3
    Console.ReadKey();
}
public class Stack<T> : IEnumerable<T>
{
    private T[] values = new T[100];
    private int top = 0;
    public void Push(T t)
    {
        values[top] = t;
top++; }
    public T Pop()
    {
top--;
        return values[top];
    }
    // This method implements the GetEnumerator method. It allows
    // an instance of the class to be used in a foreach statement.
    public IEnumerator<T> GetEnumerator()
    {
        for (int index = top - 1; index >= 0; index--)
        {
            yield return values[index];
        }
}
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
    public IEnumerable<T> TopToBottom
    {
        get { return this; }
    }
    public IEnumerable<T> BottomToTop
    {
get {
} }
for (int index = 0; index <= top - 1; index++)
{
    yield return values[index];
}
public IEnumerable<T> TopN(int itemsFromTop)
{
    // Return less than itemsFromTop if necessary.
    int startIndex = itemsFromTop >= top ? 0 : top - itemsFromTop;
    for (int index = top - 1; index >= startIndex; index--)
    {
  
        構文情報
反復子は、メソッドまたは get アクセサーとして指定できます。反復子を、イベント、インスタンスコンストラクター、静的コンス トラクター、静的ファイナライザーで指定することはできません。
yield return ステートメントの式の型を、反復子によって返される IEnumerable<T> の型引数に暗黙的に変換する必要が あります。
C#の場合、反復子メソッドで in 、 ref 、 out パラメーターを指定することはできません。
C#の場合、 yield は予約語ではなく、 return または break キーワードの前に使用される場合にのみ、特別な意味を持
ちます。 技術的な実装
メソッドとして反復子を記述しても、コンパイラが入れ子のクラス (つまり、事実上、ステート マシン) に変換します。 このクラス は、クライアントコードで foreach ループが続く限り、反復子の位置を追跡します。
コンパイラの動作を確認するには、Ildasm.exe ツールを使用して、iterator メソッドに対して生成される Microsoft 中間言語 コードを表示します。
クラスまたは構造体用の反復子を作成する場合、IEnumerator インターフェイス全体を実装する必要はありません。 コンパイ ラは、反復子を検出すると、IEnumerator または IEnumerator<T> インターフェイスの Current 、 MoveNext 、および
Dispose メソッドを自動的に生成します。
foreach ループの連続する反復ごとに(または IEnumerator.MoveNext を直接呼び出すと)、前の ステートメ ントの後で次の反復子コード本体が再開されます。 その後、反復子本体の最後に到達するか、 ステートメント が検出されるまで、次の yield return ステートメントに続行されます。
反復子は、IEnumerator.Reset メソッドをサポートしません。 反復処理を最初から再度行う場合は、新しい反復子を取得す る必要があります。 反復子メソッドによって返される反復子に対して Reset を呼び出すと、NotSupportedException がスロー されます。
詳細については、「C# 言語の仕様」を参照してください。 反復子の使用
反復子を使用すると、複雑なコードを使用して一覧シーケンスを設定する必要がある場合に、 foreach ループの単純さを維 持することができます。 これは次のような場合に役立ちます。
最初の foreach ループイテレーションの後に一覧シーケンスを変更する。
最初の foreach ループイテレーションの前に大きい一覧が完全に読み込まれないようにする。例として、ページフェッ チでのテーブル行のバッチの読み込みなどがあります。 また、別の例として、EnumerateFiles メソッドでの .NET 内の反 復子の実装があります。
反復子に一覧の作成をカプセル化する。 iterator メソッドでは、一覧を作成してから、ループで各結果を生成すること ができます。
              関連項目
yield return
 yield break
   } }
    yield return values[index];
}
 
      System.Collections.Generic IEnumerable<T> foreach、in
yield
配列での foreach の使用 ジェネリック

     統合言語クエリ (LINQ) は、C# 言語への直接的なクエリ機能の統合に基づくテクノロジのセットの名前です。 これまでは、デー タに対するクエリは、コンパイル時の型チェックや IntelliSense のサポートがない単純な文字列として表現されてきました。 さら に、SQL データベース、XML ドキュメント、さまざまな Web サービスなど、各種データ ソースの異なるクエリ言語を学習する必 要があります。 LINQ では、クエリは、クラス、メソッド、イベントと同様に、ファースト クラスの言語コンストラクトです。 厳密に型 指定されているオブジェクトのコレクションに対して、言語キーワードと使い慣れた演算子を用いてクエリを記述します。 LINQ ファミリのテクノロジを使用することで、オブジェクト (LINQ to Objects)、リレーショナル データベース ()、XML (LINQ to SQL)、 XML (LINQ to XML) に対して一貫した方法でクエリを利用できます。
クエリを記述する開発者にとって、最も目立つ LINQ の "統合言語" 部分は、クエリ式です。 クエリ式は、宣言型の "クエリ構 文" で記述されます。 クエリ構文を使用することで、フィルター処理、並べ替え、グループ化などのデータ ソースに対する操作 を、最小限のコードで実行できます。 同一の基本的なクエリ式のパターンを使用して、SQL データベース、ADO.NET データセッ ト、XML ドキュメントとストリーム、および .NET コレクション内のデータを照会して変換できます。
C# を使って LINQ クエリを記述できます。対象は、IEnumerable またはジェネリック IEnumerable<T> インターフェイスをサ ポートする SQL Server データベース、XML ドキュメント、ADO.NET データセット、その他のオブジェクトのコレクションです。 サー ド パーティからも、多くの Web サービスとその他のデータベース実装に対する LINQ のサポートが提供されます。
次の例は、完全なクエリ操作を示しています。完全な操作には、データソースの作成、クエリ式の定義、および foreach ス テートメントでのクエリの実行が含まれています。
     class LINQQueryExpressions
{
    static void Main()
    {
} }
// Specify the data source.
int[] scores = new int[] { 97, 92, 81, 60 };
// Define the query expression.
IEnumerable<int> scoreQuery =
    from score in scores
    where score > 80
    select score;
// Execute the query.
foreach (int i in scoreQuery)
{
    Console.Write(i + " ");
}
// Output: 97 92 81
 次の Visual Studio の図は、SQL Server データベースに対して部分的に完了した LINQ クエリを示しています。このクエリは C# および Visual Basic の両方で記述されており、完全な型チェックと IntelliSense に対応しています。
統合言語クエリ (LINQ) 2020/11/02 • • Edit Online
 
                   クエリ式の概要
クエリ式を使用して、任意の LINQ 対応データ ソースのデータを照会して変換することができます。 たとえば、1 つのクエリで SQL データベースからデータを取得し、出力として XML ストリームを生成できます。
クエリ式は、多くの使い慣れた C# 言語の構成体を使用するため、簡単に習得できます。 クエリ式内の変数はすべて厳密に型指定されますが、多くの場合、型はコンパイラが推測できるため、明示的に指定する 必要はありません。 詳細については、「LINQ クエリ操作での型の関係」を参照してください。
クエリは、たとえば foreach ステートメントでクエリ変数を反復処理するまで実行されません。詳細については、「LINQクエ リの概要」を参照してください。
コンパイル時に、クエリ式は、C# 仕様に規定された規則に従って、標準クエリ演算子メソッドの呼び出しに変換されます。 クエリ構文を使用して表現できるすべてのクエリは、メソッド構文でも表現することができます。 ただし、ほとんどの場合、クエ リ構文のほうが読みやすく、簡潔です。 詳細については、「# 言語仕様」と「標準クエリ演算子の概要」を参照してください。 原則として、LINQ クエリを記述するときは、可能であれば常にクエリ構文を使用し、必要な場合にメソッド構文を使用する ことをお勧めします。 この 2 つの異なる形式の間には、セマンティックの違いもパフォーマンスの違いもありません。 多くの場 合、クエリ式のほうが、メソッド構文で記述された同等の式よりも読みやすくなります。
Count や Max など一部のクエリ操作には、同等のクエリ式の句がないため、メソッドの呼び出しとして表す必要があります。 メソッド構文は、さまざまな方法でクエリ構文と組み合わせることができます。 詳細については、「LINQ でのクエリ構文とメ ソッド構文」を参照してください。 クエリ式は、クエリの適用対象の種類によって、式ツリーまたはデリゲートにコンパイルすることができます。 IEnumerable<T> クエリはデリゲートにコンパイルされます。 IQueryable および IQueryable<T> クエリは式ツリーにコンパイルされます。 詳細 については、「式ツリー」を参照してください。
次の手順
LINQ の詳細については、最初に「クエリ式の基本」で基本的な概念を理解してから、関心のある LINQ テクノロジのドキュメン トを参照してください。
XML ドキュメント:LINQ to XML
ADO.NET Entity Framework:LINQ to Entities
.NET のコレクション、ファイル、文字列など:LINQ to Objects
LINQ 全般をより深く理解するには、「C# での LINQ」を参照してください。
C# での LINQ の使用を開始するには、「LINQ の使用」チュートリアルを参照してください。
 
   "クエリ" は、データ ソースからデータを取得する式です。 クエリは通常、専用のクエリ言語で表されます。 これまでに、リレーショナ ル データベース用の SQL や XML 用の XQuery など、データ ソースの種類に合わせてさまざまな言語が開発されてきました。 このため、開発者は、サポートする必要のあるデータ ソースの種類やデータ形式ごとに、新しいクエリ言語を習得する必要があり ました。 LINQ は、さまざまな種類のデータ ソースやデータ形式のデータを操作するための一貫したモデルを提供することにより、 この負担を軽減します。 LINQ クエリでは、操作の対象は常にオブジェクトになります。 共通の基本的なコーディング パターンを 使用することで、LINQ プロバイダーを利用できる XML ドキュメント、SQL データベース、ADO.NET データセット、.NET コレク ション、その他の任意の形式のデータを照会したり変換したりできます。
クエリ操作の 3 つの手順
LINQ クエリ操作はすべて、次の 3 つの手順で構成されます。 1. データ ソースを取得します。
2. クエリを作成します。
3. クエリを実行します。
クエリ操作の 3 つの手順がソース コードでどのように表されるかを次の例に示します。 この例では、わかりやすくするために整数 の配列をデータ ソースとして使用していますが、他のデータ ソースを使用する場合にも同じ概念が当てはまります。 このコード は、このトピックの残りの部分全体を通して参照されます。
    class IntroToLINQ
{
    static void Main()
    {
} }
// The Three Parts of a LINQ Query:
// 1. Data source.
int[] numbers = new int[7] { 0, 1, 2, 3, 4, 5, 6 };
// 2. Query creation.
// numQuery is an IEnumerable<int>
var numQuery =
    from num in numbers
    where (num % 2) == 0
    select num;
// 3. Query execution.
foreach (int num in numQuery)
{
    Console.Write("{0,1} ", num);
}
 次の図は、クエリ操作全体を表しています。 LINQ では、クエリの実行はクエリ自体とは別個のものです。 つまり、クエリ変数を 作成するだけでは、データは取得されません。
LINQ クエリの概要 (C#) 2020/11/02 • • Edit Online
 
               データ ソース
前の例では、データ ソースが配列であるため、暗黙的にジェネリック IEnumerable<T> インターフェイスがサポートされます。 つ まり、LINQでクエリを実行できるということです。クエリは foreach ステートメントで実行されますが、foreach には IEnumerable または IEnumerable<T> が必要です。 IEnumerable<T> をサポートする型や、ジェネリック IQueryable<T> などの派生インターフェイスは、クエリ可能型と呼ばれます。
クエリ可能型は、変更や特別な処理を行わなくても、LINQ データ ソースとして使用できます。 ソース データがメモリ内にクエリ 可能型として存在していない場合、LINQ プロバイダーは、そのような型としてソース データを表す必要があります。 たとえ ば、LINQ to XML では、クエリ可能な XElement 型に XML ドキュメントが読み込まれます。
LINQ to SQL では、まず、デザイン時に手動で、または Visual Studio で LINQ to SQL ツールを使用して、オブジェクト リレー ショナル マッピングを作成します。 オブジェクトに対するクエリを記述すると、実行時には、LINQ to SQL によってデータベースとの 通信が処理されます。 次の例では、 Customers がデータベース内の特定のテーブルを表し、クエリ結果の型 IQueryable<T> が IEnumerable<T> から派生しています。
それぞれの種類のデータ ソースを作成する方法の詳細については、対応する LINQ プロバイダーのドキュメントを参照してくださ い。 ただし、基本的な規則は非常に単純です。LINQ データ ソースは、ジェネリック IEnumerable<T> インターフェイス、また はこれを継承するインターフェイスをサポートする任意のオブジェクトです。
      // Create a data source from an XML document.
// using System.Xml.Linq;
XElement contacts = XElement.Load(@"c:\myContactList.xml");
      Northwnd db = new Northwnd(@"c:\northwnd.mdf");
// Query for customers in London.
IQueryable<Customer> custQuery =
    from cust in db.Customers
    where cust.City == "London"
    select cust;
     NOTE
非ジェネリック IEnumerable インターフェイスをサポートする ArrayList などの型も、LINQ データ ソースとして使用できます。 詳細について は、「LINQ を使用して ArrayList にクエリを実行する方法 (C#)」を参照してください。
 
      クエリ
クエリでは、データ ソースからどのような情報を取得するかを指定します。 オプションとして、情報が返される前に、その情報を並 べ替え、グループ化し、構造化する方法を指定することもできます。 クエリはクエリ変数に格納され、クエリ式で初期化されま す。 クエリを簡単に記述できるようにするために、C# に新しいクエリ構文が導入されています。
前の例のクエリでは、整数の配列からすべての偶数が返されます。 クエリ式には、 from 、 where 、および select の 3 つの 句が含まれています (SQL に詳しい方は、句の順番が SQL での順番とは逆になっていることに気付かれると思います)。 from 句はデータ ソースを指定し、 where 句はフィルターを適用し、 select 句は返される要素の種類を指定します。 これらのクエ リ句およびその他のクエリ句の詳細については、「統合言語クエリ (LINQ)」セクションを参照してください。 今の段階で重要な点 は、LINQ では、クエリ変数自体は何も処理を行わず、データを返さないという点です。 この時点では、後でクエリが実行される ときに結果の生成に必要となる情報が格納されるだけです。 背後でどのようにクエリが構築されるかについては、「標準クエリ演 算子の概要 (C#)」をご覧ください。
クエリの実行 遅延実行
先に説明したように、クエリ変数自体が行うのはクエリ コマンドの格納のみです。 実際のクエリの実行は、 foreach ステートメン トでクエリ変数が反復処理されるまで延期されます。 この概念を "遅延実行" と呼びます。遅延実行の例を次に示します。
foreach ステートメントでは、クエリ結果の取得も行われます。たとえば、前のクエリでは、返されるシーケンスの各値が反復変 数 num に(一度に1つずつ)格納されます。
クエリ変数自体にはクエリ結果は格納されないので、必要に応じて何度でもクエリを実行できます。 たとえば、別のアプリケー ションによって頻繁に更新されるデータベースがあるとします。 自分のアプリケーションでは、最新のデータを取得するクエリを 1 つ 作成し、それを一定の間隔で繰り返し実行することで、毎回異なる結果を取得できます。
即時実行の強制
一連のソース要素に対して集計関数を実行するクエリでは、最初にそれらの要素を反復処理する必要があります。 このような クエリには、 Count 、 Max 、 Average 、 First などがあります。 これらのクエリでは、明示的に foreach ステートメントを使用 しなくても同等の処理が実行されます。これは、結果を返すためにクエリ自体が foreach を使用する必要があるからです。 こ れらの種類のクエリでは、 IEnumerable コレクションではなく、単一の値が返されることにも注意してください。 次のクエリは、ソー ス配列に含まれている偶数の数を返します。
      NOTE
クエリは、メソッド構文を使用して表すこともできます。 詳細については、「LINQ でのクエリ構文とメソッド構文」を参照してください。
      //  Query execution.
foreach (int num in numQuery)
{
    Console.Write("{0,1} ", num);
}
          var evenNumQuery =
    from num in numbers
    where (num % 2) == 0
    select num;
int evenNumCount = evenNumQuery.Count();
 クエリの即時実行を強制し、その結果をキャッシュするには、ToList メソッドまたは ToArray メソッドを呼び出します。

          クエリ式の直後に foreach ループを配置することでも実行を強制できます。 ただし、 ToList または ToArray を呼び出した 場合は、単一のコレクション オブジェクトにすべてのデータをキャッシュする処理も行われます。
関連項目
C# の LINQ の概要
チュートリアル: C# でのクエリの作成 統合言語クエリ (LINQ) foreach、in
クエリ キーワード (LINQ)
   List<int> numQuery2 =
    (from num in numbers
     where (num % 2) == 0
     select num).ToList();
// or like this:
// numQuery3 is still an int[]
var numQuery3 =
    (from num in numbers
     where (num % 2) == 0
     select num).ToArray();
 
            LINQ クエリは、.NET Framework のバージョン 2.0 で導入されたジェネリック型に基づいています。 クエリを記述するために、 ジェネリックについて詳しく知っておく必要ありません。 ただし、次の 2 つの基本的な概念を理解しておくと役立ちます。
1. List<T> などのジェネリック コレクション クラスのインスタンスを作成するときに、リストに保持されるオブジェクトの型で "T" を置き換えます。 たとえば、文字列のリストは List<string> で表され、 Customer オブジェクトのリストは
List<Customer> で表されます。ジェネリックリストは厳密に型指定されるため、要素をObjectとして格納するコレク ションと比べて多くの利点があります。 Customer を List<string> に追加しようとすると、コンパイル時にエラーが発生 します。 実行時に型キャストを実行する必要がないため、ジェネリック コレクションを使用するのは簡単です。
2. IEnumerable<T> は、 foreach ステートメントを使用してジェネリック コレクションのクラスを列挙できるようにするイン ターフェイスです。 ArrayList などの非ジェネリック コレクション クラスが IEnumerable をサポートするように、ジェネリック コ レクション クラスは、IEnumerable<T> をサポートします。
ジェネリックの詳細については、「ジェネリック」を参照してください。 LINQ クエリの IEnumerable<T> 変数
LINQ クエリ変数は、IEnumerable<T>、または IQueryable<T> などの派生型として型指定されます。 として型指定されたクエリ変数が見つかった場合は、クエリが実行されたときに 0 個以上の
オブジェクトのシーケンスが作成されることを意味します。
       IEnumerable<Customer>
 Customer
    IEnumerable<Customer> customerQuery =
    from cust in customers
    where cust.City == "London"
    select cust;
foreach (Customer customer in customerQuery)
{
    Console.WriteLine(customer.LastName + ", " + customer.FirstName);
}
 詳細については、「LINQ クエリ操作での型の関係」を参照してください。 コンパイラによるジェネリック型の宣言の処理
必要に応じて、var キーワードを使用することにより、ジェネリックの構文を回避することもできます。 var キーワードは、 from 句で指定されたデータ ソースを調べてクエリ変数の型を推論するようにコンパイラに指示します。 次の例では、前の例と同じコン パイル済みのコードが生成されます。
    var customerQuery2 =
    from cust in customers
    where cust.City == "London"
    select cust;
foreach(var customer in customerQuery2)
{
    Console.WriteLine(customer.LastName + ", " + customer.FirstName);
}
 var キーワードは、変数の型が明らかな場合、または入れ子にされたジェネリック型(グループクエリで生成されたものなど)を
LINQ とジェネリック型 (C#) 2020/11/02 • • Edit Online
 
   明示的に指定する必要がない場合に便利です。 一般に、 var を使用すると、他の開発者にとってコードが読みにくくなる可 能性があることを理解しておくことをお勧めします。 詳細については、「暗黙的に型指定されるローカル変数」を参照してくださ い。
関連項目
ジェネリック

         このトピックでは、LINQ クエリ式とクエリで実行する一般的な操作について、簡単に説明します。 詳細については、以下のト ピックを参照してください。
LINQ クエリ式 標準クエリ演算子の概要 (C#) チュートリアル: C# でのクエリの作成
データ ソースの取得
LINQ クエリで必要な最初の手順は、データ ソースを指定することです。 ほとんどのプログラミング言語と同じように、C# でも、 変数を使用する前に宣言しておく必要があります。 LINQ クエリでは、データ ソース ( customers ) および "範囲変数" ( cust ) を導入するために from 句が最初に使用されます。
範囲変数は、 ループの反復変数と似ていますが、クエリ式では実際の反復は発生しません。 クエリが実行されると、 範囲変数は の連続する各要素への参照として機能します。 cust の型はコンパイラで推論できるため、明示的 に指定する必要はありません。追加の範囲変数は、let 句で導入できます。詳しくは、「let句」をご覧ください。
フィルター処理
最も一般的なクエリ操作は、ブール式の形式でフィルターを適用することです。 クエリにフィルターを使用すると、式の条件に該 当する要素だけがクエリから返されます。結果は、where 句を使って生成されます。フィルターは、実質的にはソースシーケン スから除外する要素を指定します。次の例では、住所がロンドンにある customers だけが返されます。
使い慣れたC#論理 AND 演算子と論理 OR 演算子を使用すると、必要なだけのフィルター式を where 句に適用できま す。 たとえば、住所が "London" にあり、かつ ( AND ) 名前が "Devon" の顧客だけを返すには、次のコードを記述します。
    NOTE
既に SQL や XQuery などのクエリ言語に精通している場合は、このトピックの大部分を省略できます。 LINQ クエリ式における句の順序に ついて理解するには、次のセクションの " from 句" を参照してください。
      //queryAllCustomers is an IEnumerable<Customer>
var queryAllCustomers = from cust in customers
select cust;
  foreach
 customers
    NOTE
ArrayList などの非ジェネリック データ ソースの場合は、範囲変数を明示的に型指定する必要があります。 詳細については、「LINQ を使 用して ArrayList にクエリを実行する方法 (C#)」および「from 句」を参照してください。
      var queryLondonCustomers = from cust in customers
                           where cust.City == "London"
select cust;
 LINQ クエリの基本操作 (C#) 2020/11/02 • • Edit Online
 
    住所がロンドンまたはパリにある顧客を返すには、次のコードを記述します。
  where cust.City == "London" || cust.City == "Paris"
 詳しくは、「where 句」をご覧ください。 順序
返されたデータを並べ替えると便利なことがよくあります。 orderby 句を使用すると、並べ替える型の既定の比較子に従って、 返されたシーケンスの要素が並べ替えられます。たとえば、次のクエリは Name プロパティに基づいて結果を並び替えるように拡 張できます。 Name は文字列であるため、既定の比較子によって、アルファベット順(AからZ)で並べ替えられます。
結果を逆の順序(ZからA)で並び替えるには、orderby...descending 句を使用します。 詳細については、「orderby 句」を参照してください。
グループ化
指定したキーに基づいて結果をグループ化するには、 group 句を使用します。 たとえば、結果を City 別にグループ化するよ うに指定して、住所がロンドンまたはパリにあるすべての顧客を個々のグループに分けることができます。 この場合は、
cust.City がキーになります。
     var queryLondonCustomers3 =
    from cust in customers
    where cust.City == "London"
    orderby cust.Name ascending
    select cust;
       // queryCustomersByCity is an IEnumerable<IGrouping<string, Customer>>
  var queryCustomersByCity =
      from cust in customers
      group cust by cust.City;
  // customerGroup is an IGrouping<string, Customer>
  foreach (var customerGroup in queryCustomersByCity)
  {
      Console.WriteLine(customerGroup.Key);
      foreach (Customer customer in customerGroup)
      {
          Console.WriteLine("    {0}", customer.Name);
      }
}
 group 句を使用したクエリが終了すると、結果は複数リストのリストという形式になります。リストの各要素はオブジェクトであ り、そのオブジェクトには、 Key メンバーとそのキーに基づいてグループ化された要素のリストが含まれます。 グループのシーケンス を生成するクエリを反復処理する場合は、入れ子になった foreach ループを使用する必要があります。外側のループは各グ ループを反復処理し、内側のループは各グループのメンバーを反復処理します。
グループ操作の結果を参照する必要がある場合は、 into キーワードを使用して、さらに照会可能な識別子を作成します。 次のクエリでは、顧客が 2 人より多いグループだけが返されます。
  where cust.City == "London" && cust.Name == "Devon"
 
         詳しくは、「group 句」をご覧ください。 結合
結合操作は、データ ソースで明示的にモデル化されていないシーケンス間に関連付けを作成します。 たとえば、結合を実行し て、住所地が同じすべての顧客と販売業者を検索することができます。LINQでは、join 句はデータベーステーブルを直接 の対象とするのではなく、オブジェクトのコレクションを対象として機能します。
LINQでは、SQLほど頻繁に join を使用する必要はありません。これは、オブジェクトモデルでは、LINQの外部キーが項目 のコレクションを保持するプロパティとして表されるためです。 たとえば、 Customer オブジェクトには Order オブジェクトのコレク ションが含まれます。 結合を実行しなくても、ドット表記を使用して注文にアクセスできます。
詳細については、「join 句」を参照してください。 選択 (投影)
select 句はクエリの結果を生成し、返される各要素の"シェイプ"つまり型を指定します。たとえば、完全な Customer オブ ジェクト、1 つのメンバーのみ、メンバーのサブセット、または計算や新しいオブジェクトの作成に基づいた、まったく異なる種類の 結果のいずれで結果が構成されるかを指定できます。 select 句でソース要素のコピー以外のものを生成する場合、その操 作は投影と呼ばれます。 投影を使用したデータの変換は、LINQ クエリ式の強力な機能です。 詳細については、「LINQ によ るデータ変換 (C#)」と「select 句」を参照してください。
関連項目
LINQ クエリ式
チュートリアル: C# でのクエリの作成 クエリ キーワード (LINQ)
匿名型
    var innerJoinQuery =
    from cust in customers
    join dist in distributors on cust.City equals dist.City
    select new { CustomerName = cust.Name, DistributorName = dist.Name };
    from order in Customer.Orders...
       // custQuery is an IEnumerable<IGrouping<string, Customer>>
var custQuery =
    from cust in customers
    group cust by cust.City into custGroup
    where custGroup.Count() > 2
    orderby custGroup.Key
    select custGroup;
 
   統合言語クエリ (LINQ) で行うことができるのは、データの取得だけではありません。 データ変換のための強力なツールとしても 使用できます。 LINQ クエリを使用することにより、ソース シーケンスを入力として使用し、さまざまな方法で加工して新しい出 力シーケンスを作成できます。 要素自体を変更せずに、並べ替えやグループ化してシーケンス自体を変更できます。 しかし、 LINQ クエリの最も強力な機能は、新しい型を作成する機能です。 この操作は select 句内で行います。 たとえば、次のタスク を実行できます。
複数の入力シーケンスを結合して、新しい型の単一の出力シーケンスを作成する。
ソース シーケンス内の各要素の単一のプロパティまたは複数のプロパティを構成要素とする出力シーケンスを作成する。 ソース データに対して実行した操作の結果を構成要素とする出力シーケンスを作成する。 別の形式で出力シーケンスを作成する。 たとえば、SQL の行またはテキスト ファイルのデータを XML に変換できます。
これらはほんの一例です。 これらの変換を、同じクエリ内でさまざまな方法で組み合わせて使用することもできます。 また、ある クエリの出力シーケンスを別のクエリの入力シーケンスとして使用することもできます。
複数の入力を 1 つの出力シーケンスに結合する
LINQ クエリを使用して、複数の入力シーケンスの要素を含む 1 つの出力シーケンスを作成できます。 次の例は、2 つのインメ モリ データ構造を結合する方法を示していますが、ソースが XML、SQL、または DataSet のデータを結合する場合にも同じ基 本原則を適用できます。 次の 2 つのクラス型があるとします。
    class Student
{
    public string First { get; set; }
    public string Last {get; set;}
    public int ID { get; set; }
    public string Street { get; set; }
    public string City { get; set; }
    public List<int> Scores;
}
class Teacher
{
    public string First { get; set; }
    public string Last { get; set; }
    public int ID { get; set; }
    public string City { get; set; }
}
 クエリの例を次に示します。
LINQ によるデータ変換 (C#) 2020/11/02 • • Edit Online
 
     詳細については、「join 句」および「select 句」を参照してください。
各ソース要素のサブセットを選択する
ソース シーケンスの各要素のサブセットを選択するには、主に次の 2 つの方法があります。
  class DataTransformations
{
    static void Main()
    {
        // Create the first data source.
        List<Student> students = new List<Student>()
        {
            new Student { First="Svetlana",
                Last="Omelchenko",
                ID=111,
                Street="123 Main Street",
                City="Seattle",
                Scores= new List<int> { 97, 92, 81, 60 } },
            new Student { First="Claire",
                Last="O’Donnell",
                ID=112,
                Street="124 Main Street",
                City="Redmond",
                Scores= new List<int> { 75, 84, 91, 39 } },
            new Student { First="Sven",
};
Last="Mortensen",
ID=113,
Street="125 Main Street",
City="Lake City",
Scores= new List<int> { 88, 94, 65, 91 } },
        // Create the second data source.
        List<Teacher> teachers = new List<Teacher>()
        {
            new Teacher { First="Ann", Last="Beebe", ID=945, City="Seattle" },
            new Teacher { First="Alex", Last="Robinson", ID=956, City="Redmond" },
            new Teacher { First="Michiyo", Last="Sato", ID=972, City="Tacoma" }
};
        // Create the query.
        var peopleInSeattle = (from student in students
                    where student.City == "Seattle"
                    select student.Last)
                    .Concat(from teacher in teachers
                            where teacher.City == "Seattle"
                            select teacher.Last);
        Console.WriteLine("The following students and teachers live in Seattle:");
        // Execute the query.
        foreach (var person in peopleInSeattle)
        {
            Console.WriteLine(person);
        }
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
/* Output:
    The following students and teachers live in Seattle:
    Omelchenko
    Beebe
*/

  1. ソース要素の 1 つのメンバーのみを選択するには、ドット演算を使用します。 次の例で、   オブジェクトに City という文字列を含むいくつかのパブリックプロパティが含まれているとします。このクエリを実行すると、文字列の出
力シーケンスが生成されます。
2. ソース要素からの複数のプロパティを含む要素を作成するには、名前付きオブジェクトまたは匿名型を指定したオブジェ クト初期化子を使用します。次の例は、匿名型を使用して各 Customer 要素の2つのプロパティをカプセル化する方 法を示しています。
詳細については、「オブジェクト初期化子とコレクション初期化子」および「匿名型」を参照してください。 インメモリ オブジェクトを XML に変換する
LINQ クエリを使用すると、インメモリ データ構造、SQL データベース、ADO.NET データセット、XML ストリーム、または XML ド キュメントの間でデータ変換を簡単に行うことができます。 インメモリ データ構造のオブジェクトを XML 要素に変換する例を次に 示します。
    var query = from cust in Customers
            select cust.City;
      var query = from cust in Customer
            select new {Name = cust.Name, City = cust.City};
     class XMLTransform
{
    static void Main()
    {
60}},
// Create the data source by using a collection initializer.
// The Student class was defined previously in this topic.
List<Student> students = new List<Student>()
{
    new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores = new List<int>{97, 92, 81,
    new Student {First="Claire", Last="O’Donnell", ID=112, Scores = new List<int>{75, 84, 91, 39}},
    new Student {First="Sven", Last="Mortensen", ID=113, Scores = new List<int>{88, 94, 65, 91}},
};
// Create the query.
var studentsToXML = new XElement("Root",
    from student in students
    let scores = string.Join(",", student.Scores)
    select new XElement("student",
               new XElement("First", student.First),
               new XElement("Last", student.Last),
               new XElement("Scores", scores)
            ) // end "student"
        ); // end "Root"
// Execute the query.
Console.WriteLine(studentsToXML);
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
} }
 このコードを実行すると、次の XML 出力が生成されます。
 Customer
 
     詳細については、「C# での XML ツリーの作成 (LINQ to XML)」を参照してください。 ソース要素に対して操作を実行する
出力シーケンスには、ソース シーケンスの要素または要素のプロパティが 1 つも含まれない場合があります。 代わりに、ソース要 素を入力引数として使用することで計算された値のシーケンスを出力として生成できます。
次のクエリでは、円の半径を表す一連の数値を取得し、各半径での面積を計算し、計算された領域で書式設定された文字 列を含む出力シーケンスを返します。
出力シーケンスの各文字列は、文字列補間を使用して書式設定されます。 補間された文字列には、文字列の開始引用符 の前に $ が含まれます。操作は、補間された文字列内に配置された中かっこ内で実行できます。これらの操作を実行する と、結果が連結されます。
    NOTE
クエリが他のドメインに変換される場合、クエリ式でのメソッド呼び出しはサポートされません。 たとえば、LINQ to SQL で C# の通常のメソッ ドを呼び出すことはできません。これは、C# のメソッドのコンテキストが SQL Server にないためです。 ただし、ストアド プロシージャをメソッド にマップして呼び出すことは可能です。 詳細については、「ストアド プロシージャ」を参照してください。
    <Root>
  <student>
    <First>Svetlana</First>
    <Last>Omelchenko</Last>
    <Scores>97,92,81,60</Scores>
  </student>
  <student>
    <First>Claire</First>
    <Last>O'Donnell</Last>
    <Scores>75,84,91,39</Scores>
  </student>
  <student>
    <First>Sven</First>
    <Last>Mortensen</Last>
    <Scores>88,94,65,91</Scores>
  </student>
</Root>
 
        関連項目
統合言語クエリ (LINQ) (C#) LINQ to SQL
LINQ to DataSet
LINQ to XML (C#)
LINQ クエリ式 select 句
   class FormatQuery
{
    static void Main()
    {
} }
// Data source.
double[] radii = { 1, 2, 3 };
// LINQ query using method syntax.
IEnumerable<string> output =
    radii.Select(r => $"Area for a circle with a radius of '{r}' = {r * r * Math.PI:F2}");
/*
// LINQ query using query syntax.
IEnumerable<string> output =
    from rad in radii
    select $"Area for a circle with a radius of '{rad}' = {rad * rad * Math.PI:F2}";
*/
foreach (string s in output)
{
    Console.WriteLine(s);
}
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    Area for a circle with a radius of '1' = 3.14
    Area for a circle with a radius of '2' = 12.57
    Area for a circle with a radius of '3' = 28.27
*/
 
   クエリを効果的に記述するには、クエリ操作全体における変数の型の相互関係を理解する必要があります。 これらの関係を理 解しておくと、このドキュメント内のLINQのサンプルやコード例を理解しやすくなります。また、var を使用して変数を暗黙的 に型指定した場合に、背後でどのような処理が行われるかを理解することもできます。
LINQ クエリ操作は、データ ソース、クエリ自体、およびクエリの実行において厳密に型指定されます。 クエリの変数の型には、 データソース内の要素の型および foreach ステートメントの反復変数の型との互換性が必要です。この厳密な型指定によ り、コンパイル時に型のエラーが検出され、実際にエラーが発生する前にそのエラーを修正できます。
これらの型の関係を示すために、後の例の大部分では、すべての変数に明示的な型指定を使用しています。 最後の例で は、var を使用して暗黙的な型指定を行う場合でも、同じ基本原則が適用されることを示します。
ソース データを変換しないクエリ
次の図は、データの変換を行わない LINQ to Objects クエリ操作を示しています。 ソースには文字列のシーケンスが含まれて いるので、クエリ出力も文字列のシーケンスです。
1. データ ソースの型引数によって、範囲変数の型が決まります。
2. 選択したオブジェクトの型によって、クエリ変数の型が決まります。 ここでは、 name は文字列です。 したがって、クエリ変
数は IEnumerable<string> になります。
3. クエリ変数は、 foreach ステートメントで反復処理されます。 クエリ変数は文字列のシーケンスなので、反復変数も文
字列です。
ソース データを変換するクエリ
次の図は、単純なデータ変換を行うLINQtoSQLクエリ操作を示しています。このクエリは、Customer オブジェクトのシーケン スを入力として受け取り、 Name プロパティのみを結果に選択します。 Name は文字列なので、クエリは出力として文字列の シーケンスを作成します。
     LINQ クエリ操作での型の関係 (C#) 2020/11/02 • • Edit Online
 
   1. 2.
3.
データ ソースの型引数によって、範囲変数の型が決まります。
ステートメントは、完全な Name オブジェクトではなく、 プロパティを返します。 Name は文字列な
ので、 の型引数は string ではなく になります。
custNameQuery は文字列のシーケンスなので、 foreach ループの反復変数も string です。
  select
Customer
   custNameQuery
Customer
     次の図は、もう少し複雑な変換を示しています。 select ステートメントは、元の Customer オブジェクトのメンバーを2つだけ 取り込む匿名型を返します。
 1. 2.
データ ソースの型引数は、常にクエリの範囲変数の型です。
select ステートメントによって匿名型が生成されるため、クエリ変数は var を使用して暗黙的に型指定する必要が あります。
  クエリ変数の型が暗黙的なので、 foreach ループの反復変数も暗黙的にする必要があります。 コンパイラによる型情報の推論
クエリ操作における変数の関係を理解することは大切ですが、この処理をコンパイラで自動的に行う方法もあります。 var キー ワードは、クエリ操作の任意のローカル変数に使用できます。 次の図は、前に説明した例 2 と類似しています。 ここでは、コン パイラがクエリ操作の各変数について、厳密な型を指定します。
3.
 var の詳細については、「暗黙的に型指定されたローカル変数」を参照してください。

    統合言語クエリ (LINQ) の入門的なドキュメントでは、ほとんどのクエリが、LINQ の宣言型クエリ構文を使用して記述されてい ます。 ただし、クエリ構文は、コードのコンパイル時に、.NET 共通言語ランタイム (CLR) 用のメソッド呼び出しに変換する必要 があります。 これらのメソッド呼び出しが、標準クエリ演算子 ( Where 、 Select 、 GroupBy 、 Join 、 Max 、 Average など) を 呼び出します。 これらは、クエリ構文ではなくメソッド構文を使用して直接呼び出すことができます。
クエリ構文とメソッド構文は意味的には同じものですが、多くの人は、クエリ構文のほうがシンプルで読みやすいと感じます。 一 部のクエリは、メソッド呼び出しとして表現する必要があります。 たとえば、指定した条件に一致する要素の数を取得するクエリ を表すには、メソッド呼び出しを使用する必要があります。 また、ソース シーケンスで最大の値を持つ要素を取得するクエリに も、メソッド呼び出しを使用する必要があります。 System.Linq 名前空間の標準クエリ演算子のリファレンス ドキュメントでは、 通常、メソッド構文が使用されます。 そのため、LINQ クエリの記述をこれから学習する初心者にとっても、クエリやクエリ式自体 の中でメソッド構文をどのように使用すればよいか理解しておくことは有用です。
標準クエリ演算子の拡張メソッド
次の例は、シンプルなクエリ式と、メソッド ベースのクエリとして記述された、意味的に同等のクエリを示したものです。
       class QueryVMethodSyntax
{
    static void Main()
    {
} }
/*
Output:
6 8 10 12
6 8 10 12 */
int[] numbers = { 5, 10, 8, 3, 6, 12};
//Query syntax:
IEnumerable<int> numQuery1 =
    from num in numbers
    where num % 2 == 0
    orderby num
    select num;
//Method syntax:
IEnumerable<int> numQuery2 = numbers.Where(num => num % 2 == 0).OrderBy(n => n);
foreach (int i in numQuery1)
{
    Console.Write(i + " ");
}
Console.WriteLine(System.Environment.NewLine);
foreach (int i in numQuery2)
{
    Console.Write(i + " ");
}
// Keep the console open in debug mode.
Console.WriteLine(System.Environment.NewLine);
Console.WriteLine("Press any key to exit");
Console.ReadKey();
 LINQ でのクエリ構文とメソッド構文 (C#) 2020/11/02 • • Edit Online
 
          2 つの例からの出力は同じです。 クエリ変数の型は、どちらの形式でも同じです: IEnumerable<T>。
 メソッド ベースのクエリを理解するために、より詳しく調べていきましょう。 式の右側を見ると、 where 句が オブジェクト のインスタンス メソッドとして表されていることがわかります。これは、既におわかりのように、 の型を持っていま す。ジェネリック型のIEnumerable<T>インターフェイスについて知識があれば、これが Where メソッドではないことがわかるで しょう。しかし、VisualStudioIDEでIntelliSenseの入力補完リストを呼び出すと、Where メソッドだけでなく、Select、
SelectMany 、 Join 、 Orderby など、他にも多くのメソッドが表示されます。 これらはすべて、標準クエリ演算子です。
一見、IEnumerable<T> が再定義され、これらのメソッドが追加されたかのように見えますが、実際にはそうではありません。 標準クエリ演算子は、拡張メソッドという新しい種類のメソッドとして実装されています。 拡張メソッドは、既存の型を "拡張" し ます。これらは、あたかもその型のインスタンス メソッドであるかのように呼び出すことができます。 標準クエリ演算子が IEnumerable<T> を拡張しているため、 numbers.Where(...) を書き込むことができます。
LINQの初心者が拡張メソッドについて知っておくべき最も重要なことは、適切な using ディレクティブを使用して、アプリケー ションのスコープ内にそれらを取り込む方法です。 アプリケーションの観点から見れば、拡張メソッドは通常のインスタンス メソッド と同じものです。
拡張メソッドについて詳しくは、「拡張メソッド」をご覧ください。 標準クエリ演算子について詳しくは、「標準クエリ演算子の概要 (C#)」をご覧ください。 一部の LINQ プロバイダー (LINQ to SQL や LINQ to XML など) では、IEnumerable<T> 以外の型 に対応するため、独自の標準クエリ演算子と追加の拡張メソッドを実装しています。
ラムダ式
上記の例では、条件式( )がインライン引数として Where メソッドに渡さています: このインライン式は、ラムダ式と呼ばれます。 これを使用すると、本来であれば、匿名メソッ
ド、ジェネリック デリゲート、式ツリーなど、より複雑な形式で記述しなければならないコードを、簡単に記述できます。 C# で は、=> がラムダ演算子で、"goesto"という読み方をします。演算子の左側にある num は、クエリ式の num に対応する入 力変数です。 コンパイラは、 numbers がジェネリック IEnumerable<T> 型であることがわかっているため、 num の型を推論で きます。 ラムダの本体は、クエリ構文や、C# のその他の式やステートメントの式と同じです。これには、メソッド呼び出しやその他 の複雑なロジックを含めることができます。 "戻り値" は、式の結果だけです。
LINQ の初心者の場合、ラムダを広範に使用する必要はありません。 ただし、一部のクエリはメソッド構文でしか表現できず、 ラムダ式が必須となるものもあります。 ラムダに慣れてきたら、これが LINQ のツールボックスで使用できる強力で柔軟なツールで あることがおわかりいただけるでしょう。 詳細については、「ラムダ式」を参照してください。
クエリの構成可能性
上記の例で、 OrderBy メソッドは Where への呼び出しでドット演算子を使用して起動されています。 Where は、フィルター 処理されたシーケンスを生成し、その後 Orderby は、そのシーケンスをソートして操作しています。 クエリが IEnumerable を 返すので、開発者は、メソッド呼び出しをつないでいきながら、メソッド構文でそれらを編成します。 これが、クエリ構文を使って クエリを記述する際に、コンパイラがバック グラウンドで行っていることなのです。 また、クエリ変数にはクエリの結果が格納されな いので、開発者はそれが実行された後でも、それを随時変更したり、新しいクエリのベースとして使用することができます。
     num % 2 == 0
IEnumerable<int>
numbers
   Where(num => num % 2 == 0).
    
     このセクションでは、C# 3.0 で導入された新しい言語構成要素について説明します。 これらの新機能はすべてある程度まで LINQ クエリで使用されていますが、LINQ だけでなく、これらの機能が役立つと思われるあらゆる状況で使用できます。
クエリ式
クエリ式は、SQL や XQuery に似た宣言型構文を使用して、IEnumerable コレクションを照会します。 クエリ構文は、コンパイ ル時に、LINQ プロバイダーの標準クエリ演算子拡張メソッドの実装に対するメソッド呼び出しに変換されます。 アプリケーション は、 using ディレクティブを使用して適切な名前空間を指定することにより、スコープ内の標準クエリ演算子を制御します。 次 のクエリ式では、文字列の配列を受け取り、文字列の最初の文字を基に文字列をグループ化し、グループを並び替えていま す。
詳細については、「LINQ クエリ式」を参照してください。 暗黙的に型指定された変数 (var)
変数を宣言して初期化するときに、型を明示的に指定する代わりに、次に示すように var 修飾子を使用すると、コンパイラが 型を推論して代入するように指示できます。
var として宣言された変数は、明示的に型を指定した変数とまったく同じように厳密に型指定されます。 var を使用すると 匿名型を作成できますが、ローカル変数にのみ使用できます。 また、暗黙的な型指定を使用して、配列を宣言することもでき ます。
詳細については、「暗黙的に型指定されるローカル変数」を参照してください。 オブジェクト初期化子とコレクション初期化子
オブジェクト初期化子とコレクション初期化子を使用すると、オブジェクトのコンストラクターを明示的に呼び出さなくても、オブジェ クトを初期化できます。 通常、初期化子は、ソース データを新しいデータ型に投影するクエリ式で使用されます。 パブリックな
Name プロパティと Phone プロパティを持つ Customer という名前のクラスがある場合、オブジェクト初期化子は次のコードのよ うに使用できます。
引き続き Customer クラスの例を進めます。 IncomingOrders というデータ ソースがあり、 OrderSize が大きな注文ごとに、そ の注文に基づいて新しい Customer を作成するとします。LINQクエリをこのデータソースで実行し、オブジェクト初期化を使 用してコレクションを満たすことができます。
    var query = from str in stringArray
            group str by str[0] into stringGroup
            orderby stringGroup.Key
            select stringGroup;
     var number = 5;
var name = "Virginia";
var query = from str in stringArray
            where str[0] == 'm'
            select str;
    var cust = new Customer { Name = "Mike", Phone = "555-1212" };
     LINQ をサポートする C# の機能 2020/11/02 • • Edit Online
 
            データ ソースには、 OrderSize など、 Customer クラス以外にもプロパティが存在する可能性がありますが、オブジェクト初期化 を利用することで、クエリから返されるデータは目的のデータ型に形成されます。今回のクラスに関連するデータを選択します。 その結果、必要とする新しい Customer が IEnumerable に入力されました。上記は次のようなLINQのメソッド構文でも記 述できます。
詳細については次を参照してください: オブジェクト初期化子とコレクション初期化子 標準クエリ演算子のクエリ式構文
匿名型
匿名型はコンパイラによって作成され、型名はコンパイラにしかわかりません。 匿名型を使用すると、個別に名前付き型を定義 しなくても、クエリ結果内のプロパティのセットを一時的にグループ化できるため便利です。 次に示すように、匿名型は new 式と オブジェクト初期化子を使用して初期化されます。
詳細については、「匿名型」を参照してください。 拡張メソッド
拡張メソッドは型に関連付けることができる静的メソッドであるため、その型のインスタンス メソッドと同じように呼び出すことがで きます。 この機能を使用すると、既存の型を実際に変更しなくても、その型に新しいメソッドを実質的に "追加" できます。 標 準クエリ演算子は、IEnumerable<T> を実装する任意の型で LINQ クエリ機能を実現する拡張メソッドのセットです。
詳細については、「拡張メソッド」を参照してください。 ラムダ式
ラムダ式は、=> 演算子を使用して関数本体からパラメーター入力を分離するインライン関数で、コンパイル時にデリゲートまた は式ツリーに変換されます。 LINQ プログラミングでは、標準クエリ演算子に対する直接メソッド呼び出しを行う場合にラムダ式 を使用します。
詳細については次を参照してください: 匿名関数
ラムダ式 式ツリー (C#)
関連項目
      var newLargeOrderCustomers = IncomingOrders.Where(x => x.OrderSize > 5).Select(y => new Customer { Name =
y.Name, Phone = y.Phone });
   select new {name = cust.Name, phone = cust.Phone};
 統合言語クエリ (LINQ) (C#)
   var newLargeOrderCustomers = from o in IncomingOrders
                            where o.OrderSize > 5
                            select new Customer { Name = o.Name, Phone = o.Phone };
 
       このチュートリアルでは、LINQ クエリ式の記述に使用される C# 言語機能について説明します。 C# プロジェクトの作成
Visual Studio でプロジェクトを作成するには 1. Visual Studio を起動します。
2. メニュー バーで、 [ファイル] 、 [新規作成] 、 [プロジェクト] の順にクリックします。 [新しいプロジェクト] ダイアログ ボックスが表示されます。
3. [インストール済み] 、 [テンプレート] 、 [Visual C#] の順に展開し、 [コンソール アプリケーション] を選択します。 4. [名前] テキスト ボックスで、別の名前を入力するか、既定の名前をそのまま使用し、 [OK] ボタンを選択します。
ソリューション エクスプローラーに新しいプロジェクトが表示されます。 5.プロジェクトには、System.Core.dllへの参照と、System.Linq名前空間の using ディレクティブが使用されています。
メモリ内データ ソースの作成
クエリのデータ ソースは、 Student オブジェクトのシンプルなリストです。 各 Student レコードには、名前、姓、およびクラスでの テストの点数を表す整数の配列が含まれます。 このコードをプロジェクトにコピーします。 これには、次のような特徴があります。
Student クラスは自動実装プロパティで構成されています。 リスト内の各生徒は、オブジェクト初期化子で初期化されます。 リスト自体は、コレクション初期化子で初期化されます。
この全体的なデータ構造は、コンストラクターへの明示的な呼び出しや、明示的なメンバー アクセスを行うことなく初期化され、 インスタンス化されます。 これらの新機能について詳しくは、「自動実装プロパティ」および「オブジェクト初期化子とコレクション初 期化子」をご覧ください。
データ ソースを追加するには
Student クラスと、初期化された生徒リストを、プロジェクト内の Program クラスに追加します。
    NOTE
以下に示すのは Visual Studio 用の手順です。 別の開発環境を使用している場合は、System.Core.dll への参照と System.Linq 名前 空間の using ディレクティブを使用したコンソール プロジェクトを作成してください。
      チュートリアル: C# でのクエリの作成 (LINQ) 2020/11/02 • • Edit Online
 
   生徒リストに新しい生徒を追加するには
1. 新しい Student を Students リストに追加し、目的の名前とテスト点数を使用します。 オブジェクト初期化子の構文をよ
り効果的に学習するために、新しい生徒の情報をすべて入力するようにしてください。
クエリの作成
簡単なクエリを作成するには
アプリケーションの Main メソッドで、シンプルなクエリを作成します。このクエリでは、実行時に、最初のテストの点数が 90を超える全生徒のリストを生成するようにします。 Student オブジェクト全体が選択されているため、クエリの型は
IEnumerable<Student> です。コードでは、varキーワードを使用して暗黙的型指定を使用することもできますが、結 果を明確に示すために、明示的型指定を使用します。(var について詳しくは、「暗黙的に型指定されたローカル変 数」をご覧ください。)
なお、クエリの範囲変数(student)は、ソース内の各 Student への参照として機能し、各オブジェクトのメンバーアク セスを提供します。
クエリの実行 クエリを実行するには
1. クエリを実行する foreach ループを記述します。 コードについては、以下の点に注意してください。 返されたシーケンス内の各要素は、 foreach ループ内の反復変数を通じてアクセスされます。 この変数の型は Student で、クエリ変数の型は互換性があります ( IEnumerable<Student> )。
          // Create the query.
// The first line could also be written as "var studentQuery ="
IEnumerable<Student> studentQuery =
    from student in students
    where student.Scores[0] > 90
    select student;
     2. このコードを追加したら、アプリケーションをビルドして実行し、 [コンソール] ウィンドウで結果を表示します。
   public class Student
{
    public string First { get; set; }
    public string Last { get; set; }
    public int ID { get; set; }
    public List<int> Scores;
}
// Create a data source by using a collection initializer.
static List<Student> students = new List<Student>
{
    new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int> {97, 92, 81,
60}},
    new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int> {75, 84, 91, 39}},
    new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int> {88, 94, 65, 91}},
    new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int> {97, 89, 85, 82}},
    new Student {First="Debra", Last="Garcia", ID=115, Scores= new List<int> {35, 72, 91, 70}},
    new Student {First="Fadi", Last="Fakhouri", ID=116, Scores= new List<int> {99, 86, 90, 94}},
    new Student {First="Hanying", Last="Feng", ID=117, Scores= new List<int> {93, 92, 80, 87}},
    new Student {First="Hugo", Last="Garcia", ID=118, Scores= new List<int> {92, 90, 83, 78}},
    new Student {First="Lance", Last="Tucker", ID=119, Scores= new List<int> {68, 79, 88, 92}},
    new Student {First="Terry", Last="Adams", ID=120, Scores= new List<int> {99, 82, 81, 79}},
    new Student {First="Eugene", Last="Zabokritski", ID=121, Scores= new List<int> {96, 85, 91, 60}},
    new Student {First="Michael", Last="Tucker", ID=122, Scores= new List<int> {94, 92, 91, 91}}
};
 
    別のフィルター条件を追加するには
1. クエリを改良するために、 where 句で複数のブール条件を結合することができます。 次のコードでは、最初の点数が
90より高く、最後の点数が80未満の生徒が返されるようにするための条件を追加しています。 where 句は次のコー ドのようになります。
詳しくは、「where 句」をご覧ください。
クエリの変更 結果を並べ替えるには
  1.
2.
3.
クエリの結果は、一定の基準で順序付けしたほうが見やすくなります。 返されたシーケンスは、ソース要素内のアクセス 可能なフィールドによって順序付けすることができます。 たとえば、次の 句では、各生徒の名前を基準にし て、AからZへのアルファベット順で結果を並べるようにしています。次の 句をクエリに追加します(where ス テートメントの直後、 select ステートメントの前)。
orderby 句を変更し、最初のテストの点数を基準にして、結果を逆順(最高点から最低点)で並べるようにします。
WriteLine 書式文字列を変更して、点数を表示できるようにします。
詳しくは、「orderby 句」をご覧ください。
where student.Scores[0] > 90 && student.Scores[3] < 80
     結果をグループ化するには
1. グループ化は、クエリ式の強力な機能です。 グループ句を使用したクエリでは、グループのシーケンスが生成され、各グ
ループ自体に、 Key と、そのグループの全メンバーで構成されたシーケンスが含まれます。 次の新しいクエリでは、生徒 の姓の頭文字をキーに使用して、生徒をグループ化しています。
orderby
 orderby
  orderby student.Last ascending
   orderby student.Scores[0] descending
   Console.WriteLine("{0}, {1} {2}", student.Last, student.First, student.Scores[0]);
    // Execute the query.
// var could be used here also.
foreach (Student student in studentQuery)
{
    Console.WriteLine("{0}, {1}", student.Last, student.First);
}
// Output:
// Omelchenko, Svetlana
// Garcia, Cesar
// Fakhouri, Fadi
// Feng, Hanying
// Garcia, Hugo
// Adams, Terry
// Zabokritski, Eugene
// Tucker, Michael
 
    2. クエリの型が変更されたことに注意してください。 char 型をキーに持つグループのシーケンスと、 のシーケンスが生成されるようになりました。 クエリの型が変更されたため、次のコードでは されています。
オブジェクト 実行ループも変更
    // studentGroup is a IGrouping<char, Student>
foreach (var studentGroup in studentQuery2)
{
    Console.WriteLine(studentGroup.Key);
    foreach (Student student in studentGroup)
    {
        Console.WriteLine("   {0}, {1}",
                  student.Last, student.First);
} }
// Output:
// O
//   Omelchenko, Svetlana
//   O'Donnell, Claire
// M
//   Mortensen, Sven
// G
//   Garcia, Cesar
//   Garcia, Debra
//   Garcia, Hugo
// F
//   Fakhouri, Fadi
//   Feng, Hanying
// T
//   Tucker, Lance
//   Tucker, Michael
// A
//   Adams, Terry
// Z
//   Zabokritski, Eugene
 3. アプリケーションを実行し、 [コンソール] ウィンドウで結果を表示します。 詳しくは、「group 句」をご覧ください。
変数を暗黙的に型指定するには
1. の IEnumerables を明示的にコーディングするのは非常に面倒です。 var を使用すれば、同じクエリや
ループをはるかに効率的に記述できます。 var キーワードは、オブジェクトの型を変更しません。型を推論 するようにコンパイラに指示するだけです。 studentQuery の型と反復変数 group を var に変更し、クエリを再実 行します。内部の foreach ループで、反復変数の型は Student のままになっており、クエリは以前と同様に機能し ます。反復変数 s を var に変更し、クエリを再実行します。まったく同じ結果が得られます。
 IGroupings
foreach
Student
   foreach
      // studentQuery2 is an IEnumerable<IGrouping<char, Student>>
var studentQuery2 =
    from student in students
    group student by student.Last[0];
 
   var について詳しくは、「暗黙的に型指定されたローカル変数」をご覧ください。
グループをキー値で順序付けるには
1. 前のクエリを実行すると、グループはアルファベット順になりません。 これを変えるには、 group 句の後に orderby 句を
記述する必要があります。 しかし orderby 句を使用するには、まず、 group 句によって作成されたグループへの参照 として機能する識別子が必要になります。この識別子は、次のように into キーワード使用して記述します。
     var studentQuery3 =
    from student in students
    group student by student.Last[0];
foreach (var groupOfStudents in studentQuery3)
{
    Console.WriteLine(groupOfStudents.Key);
    foreach (var student in groupOfStudents)
    {
        Console.WriteLine("   {0}, {1}",
            student.Last, student.First);
} }
// Output:
// O
//   Omelchenko, Svetlana
//   O'Donnell, Claire
// M
//   Mortensen, Sven
// G
//   Garcia, Cesar
//   Garcia, Debra
//   Garcia, Hugo
// F
//   Fakhouri, Fadi
//   Feng, Hanying
// T
//   Tucker, Lance
//   Tucker, Michael
// A
//   Adams, Terry
// Z
//   Zabokritski, Eugene
 
  このクエリを実行すると、グループがアルファベット順に並べ替えられます。
let を使用して識別子を導入するには
1. let キーワードを使用すると、任意の式の結果の識別子をクエリ式に導入できます。 この識別子は、次の例のように
便利に使用できます。式の結果を格納することで、何度も計算を行う必要がなくなり、パフォーマンスの向上につながり ます。
   var studentQuery4 =
    from student in students
    group student by student.Last[0] into studentGroup
    orderby studentGroup.Key
    select studentGroup;
foreach (var groupOfStudents in studentQuery4)
{
    Console.WriteLine(groupOfStudents.Key);
    foreach (var student in groupOfStudents)
    {
        Console.WriteLine("   {0}, {1}",
            student.Last, student.First);
} }
// Output:
//A
//   Adams, Terry
//F
//   Fakhouri, Fadi
//   Feng, Hanying
//G
//   Garcia, Cesar
//   Garcia, Debra
//   Garcia, Hugo
//M
//   Mortensen, Sven
//O
//   Omelchenko, Svetlana
//   O'Donnell, Claire
//T
//   Tucker, Lance
//   Tucker, Michael
//Z
//   Zabokritski, Eugene
 
   詳しくは、「let 句」をご覧ください。
クエリ式でメソッド構文を使用するには
1. 「LINQ でのクエリ構文とメソッド構文」で説明したように、一部のクエリ操作は、メソッド構文を使用することでのみ表現
できます。次のコードは、ソースシーケンス内の各 Student の合計点数を計算し、そのクエリの結果に対して Average() メソッドを呼び出して、クラスの平均点数を計算します。
      var studentQuery6 =
    from student in students
    let totalScore = student.Scores[0] + student.Scores[1] +
        student.Scores[2] + student.Scores[3]
    select totalScore;
double averageScore = studentQuery6.Average();
Console.WriteLine("Class average score = {0}", averageScore);
// Output:
// Class average score = 334.166666666667
 select 句で変換またはプロジェクトを実行するには
1. クエリでは、ソース シーケンス内の要素とは異なる要素のシーケンスを生成することがよくあります。 前のクエリと実行ルー
プを削除またはコメントアウトして、次のコードに置き換えます。クエリが(Students ではなく)文字列のシーケンスを返 すことに注意してください。このことは、 foreach ループに反映されます。
     // studentQuery5 is an IEnumerable<string>
// This query returns those students whose
// first test score was higher than their
// average score.
var studentQuery5 =
    from student in students
    let totalScore = student.Scores[0] + student.Scores[1] +
        student.Scores[2] + student.Scores[3]
    where totalScore / 4 < student.Scores[0]
    select student.Last + " " + student.First;
foreach (string s in studentQuery5)
{
    Console.WriteLine(s);
}
// Output:
// Omelchenko Svetlana
// O'Donnell Claire
// Mortensen Sven
// Garcia Cesar
// Fakhouri Fadi
// Feng Hanying
// Garcia Hugo
// Adams Terry
// Zabokritski Eugene
// Tucker Michael
 
        2. このチュートリアルの前のコードでは、クラスの平均点が約 334 と示されました。 合計点がクラス平均よりも高い Students のシーケンスを (生徒の Student ID と共に) 生成するには、 select ステートメントで匿名型を使用でき
ます。
       var studentQuery8 =
    from student in students
    let x = student.Scores[0] + student.Scores[1] +
        student.Scores[2] + student.Scores[3]
    where x > averageScore
    select new { id = student.ID, score = x };
foreach (var item in studentQuery8)
{
    Console.WriteLine("Student ID: {0}, Score: {1}", item.id, item.score);
}
// Output:
// Student ID: 113, Score: 338
// Student ID: 114, Score: 353
// Student ID: 116, Score: 369
// Student ID: 117, Score: 352
// Student ID: 118, Score: 343
// Student ID: 120, Score: 341
// Student ID: 122, Score: 368
 次の手順
C# でのクエリ操作の基本が理解できたら、興味がある種類の LINQ プロバイダーについて、ドキュメントやサンプルを読んでみま しょう。
LINQ to SQL
LINQ to DataSet LINQ to XML (C#) LINQ to Objects (C#)
関連項目
統合言語クエリ (LINQ) (C#) LINQ クエリ式
   IEnumerable<string> studentQuery7 =
    from student in students
    where student.Last == "Garcia"
    select student.First;
Console.WriteLine("The Garcias in the class are:");
foreach (string s in studentQuery7)
{
    Console.WriteLine(s);
}
// Output:
// The Garcias in the class are:
// Cesar
// Debra
// Hugo
 
                       "標準クエリ演算子" は、LINQ パターンを形成するメソッドです。 これらのメソッドの大部分はシーケンスに対して機能します。こ こでシーケンスとは、IEnumerable<T> インターフェイスまたは IQueryable<T> インターフェイスを実装している型のオブジェクト のことです。 標準クエリ演算子には、フィルター処理、プロジェクション、集計、並べ替えなどのクエリ機能が用意されています。
LINQ 標準クエリ演算子には 2 つのセットがあります。1 つは IEnumerable<T> 型のオブジェクトを操作する演算子、もう 1 つ は IQueryable<T> 型のオブジェクトを操作する演算子です。 各セットを構成するメソッドは、それぞれ、Enumerable および Queryable クラスの静的メンバーです。 そのメソッドの操作対象である型の "拡張メソッド" として定義されています。 拡張メ ソッドは、静的メソッド構文またはインスタンス メソッド構文のいずれかを使用して呼び出すことができます。
さらに、いくつかの標準クエリ演算子メソッドが、IEnumerable<T> または IQueryable<T> を基にする型以外の型を操作しま す。 Enumerable 型は、このような 2 つのメソッドを定義し、その両方が IEnumerable 型のオブジェクトを操作します。 これら のメソッド Cast<TResult>(IEnumerable) と OfType<TResult>(IEnumerable) を使用して、LINQ パターンでクエリされるパラ メーター化されていないまたは非ジェネリック型のコレクションを有効にすることができます。 これを行うには、厳密に型指定された オブジェクトのコレクションを作成します。 Queryable クラスは、型 Queryable のオブジェクトを操作する 2 つの類似したメソッド Cast<TResult>(IQueryable) と OfType<TResult>(IQueryable) を定義します。
標準クエリ演算子の実行のタイミングは、シングルトン値を返すか、値のシーケンスを返すかで異なります。 これらのシングルトン 値を返すメソッド (たとえば、Average と Sum) は、すぐに実行されます。 シーケンスを返すメソッドは、クエリの実行を遅延さ せ、列挙可能なオブジェクトを返します。
メモリ内コレクションを操作するメソッド、つまり IEnumerable<T> を拡張するメソッドの場合、返される列挙可能なオブジェクト は、メソッドに渡された引数をキャプチャします。 オブジェクトが列挙されると、クエリ演算子のロジックが使用され、クエリ結果が 返されます。
対照的に、IQueryable<T> を拡張するメソッドではいかなるクエリ動作も実装されません。 実行するクエリを表す式ツリーがビ ルドされます。 クエリの処理は、ソース IQueryable<T> オブジェクトによって処理されます。
クエリ メソッドの呼び出しは 1 回のクエリにまとめてチェーン化できるため、クエリが複雑になることがあります。 次のコード例は、標準クエリ演算子を使用してシーケンスに関する情報を取得する方法を示しています。
標準クエリ演算子の概要 (C#) 2020/11/02 • • Edit Online
 
          クエリ式の構文
頻繁に使用される標準クエリ演算子の中には、C# および Visual Basic 言語専用のキーワード構文が使用されているものがあ ります。こうした構文では、標準クエリ演算子を、"クエリ 式" の一部として呼び出すことができます。 専用キーワードおよびそれ に対応する構文が使用されている標準クエリ演算子の詳細については、「標準クエリ演算子のクエリ式構文 (C#)」を参照して ください。
標準クエリ演算子の拡張
標準クエリ演算子のセットを拡張するには、対象のドメインまたはテクノロジに適したドメイン固有のメソッドを作成します。 ま た、標準クエリ演算子を、リモート評価、クエリ変換、最適化などの追加サービスが用意されている独自の実装で置き換えるこ ともできます。 例については、「AsEnumerable」を参照してください。
関連項目 次のリンクをクリックすると、さまざまな標準クエリ演算子に関する追加情報を機能別に提供する記事に移動します。 データの並べ替え (C#)
セット操作 (C#)
データのフィルター処理 (C#)
量指定子操作 (C#)
  string sentence = "the quick brown fox jumps over the lazy dog";
// Split the string into individual words to create a collection.
string[] words = sentence.Split(' ');
// Using query expression syntax.
var query = from word in words
            group word.ToUpper() by word.Length into gr
            orderby gr.Key
            select new { Length = gr.Key, Words = gr };
// Using method-based query syntax.
var query2 = words.
    GroupBy(w => w.Length, w => w.ToUpper()).
    Select(g => new { Length = g.Key, Words = g }).
    OrderBy(o => o.Length);
foreach (var obj in query)
{
    Console.WriteLine("Words of length {0}:", obj.Length);
    foreach (string word in obj.Words)
        Console.WriteLine(word);
}
// This code example produces the following output:
//
// Words of length 3:
// THE
// FOX
// THE
// DOG
// Words of length 4:
// OVER
// LAZY
// Words of length 5:
// QUICK
// BROWN
// JUMPS

                 射影操作 (C#) データのパーティション分割 結合演算 (C#) データのグループ化 (C#) 生成操作 (C#) 等価演算 (C#) 要素操作 (C#) データ型の変換 (C#) 連結演算 (C#) 集計操作 (C#)
関連項目
Enumerable
Queryable
LINQ クエリの概要 (C#) 標準クエリ演算子のクエリ式構文 (C#) 実行方法による標準クエリ演算子の分類 (C#) 拡張メソッド

                    頻繁に使用される標準クエリ演算子の中には、C# 言語専用のキーワード構文が使用されているものがあります。こうした構文 では、標準クエリ演算子を、"クエリ式" の一部として呼び出すことができます。 クエリ式はメソッド ベースの方法とは異なり、より 読み取りやすいクエリの表現形式です。 クエリ式の句は、コンパイル時にクエリ メソッドへの呼び出しに変換されます。
クエリ式の構文表 次の表は、同等なクエリ式の句がある標準クエリ演算子の一覧です。
C #
   Cast
   明示的に型指定された範囲変数を使用します。例: from int i in numbers
(詳しくは、「from 句」をご覧ください。)
    GroupBy
  group ... by
- または -
group ... by ... into ...
(詳しくは、「group 句」をご覧ください。)
    GroupJoin<TOuter,TInner,TKey,TResult> (IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter,TKey>, Func<TInner,TKey>, Func<TOuter,IEnumerable<TInner>,TResult>)
   join ... in ... on ... equals ... into ...
(詳しくは、「join 句」をご覧ください。)
   Join<TOuter,TInner,TKey,TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter,TKey>, Func<TInner,TKey>, Func<TOuter,TInner,TResult>)
   join ... in ... on ... equals ...
(詳しくは、「join 句」をご覧ください。)
   OrderBy<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>)
   orderby
(詳しくは、「orderby 句」をご覧ください。)
   OrderByDescending<TSource,TKey> (IEnumerable<TSource>, Func<TSource,TKey>)
   orderby ... descending
(詳しくは、「orderby 句」をご覧ください。)
   Select
   select
(詳しくは、「select 句」をご覧ください。)
   SelectMany
   複数の from 句を使用します。 (詳しくは、「from 句」をご覧ください。)
 標準クエリ演算子のクエリ式構文 (C#) 2020/11/02 • • Edit Online
 
            C #
   ThenBy<TSource,TKey>(IOrderedEnumerable<TSource>, Func<TSource,TKey>)
   orderby ..., ...
(詳しくは、「orderby 句」をご覧ください。)
   ThenByDescending<TSource,TKey> (IOrderedEnumerable<TSource>, Func<TSource,TKey>)
   orderby ..., ... descending
(詳しくは、「orderby 句」をご覧ください。)
    Where
  where
(詳しくは、「where 句」をご覧ください。)
 関連項目
Enumerable
Queryable
標準クエリ演算子の概要 (C#) 実行方法による標準クエリ演算子の分類 (C#)

      標準クエリ演算子メソッドの LINQ to Objects 実装は、主に 2 とおりの方法 (即時と遅延) で実行されます。 遅延実行を使 用するクエリ演算子は、さらに 2 つのカテゴリ (ストリーミングと非ストリーミング) に分けることができます。 それぞれのクエリ演算子 がどのように動作するかを把握しておくと、指定したクエリの結果を理解するうえで役立ちます。 これは、データ ソースが変更さ れる場合や、別のクエリに基づいてさらにクエリを作成する場合に特に便利です。 このトピックでは、標準クエリ演算子を、その 実行方法に基づいて分類します。
実行方法
イミディエイト
即時実行とは、クエリが宣言されたコード内の位置で、データ ソースが読み取られ、演算が実行されることを意味します。 列挙 できない単一の結果を返す標準クエリ演算子は、すべて即時に実行されます。
遅延
遅延実行とは、クエリが宣言されたコード内の位置では演算が実行されないことを意味します。 演算は、 foreach ステートメ ントを使用するなどの方法により、クエリ変数が列挙されたときにのみ実行されます。 つまり、クエリの実行結果は、クエリの定義 時ではなくクエリの実行時のデータ ソースの内容に依存します。 クエリ変数が複数回列挙される場合は、そのたびに結果が変 わる可能性があります。 戻り値の型が IEnumerable<T> または IOrderedEnumerable<TElement> の標準クエリ演算子 は、ほとんどが遅延実行されます。
遅延実行を使用するクエリ演算子は、さらにストリーミングか非ストリーミングに分類できます。
ストリーム
ストリーミング演算子では、要素を生成する前にすべてのソース データを読み取る必要はありません。 実行時に、ストリーミング 演算子は読み取ったソース要素ごとに演算を実行し、必要に応じて要素を生成します。 ストリーミング演算子は、結果の要 素を生成できるまでソース要素の読み取りを続行します。 つまり、結果の要素を 1 つ生成するために複数のソース要素が読 み取られる場合があります。
非ストリーミング
非ストリーミング演算子では、結果の要素を生成する前にすべてのソース データを読み取る必要があります。 並べ替えやグ
ループ化などの演算はこのカテゴリに分類されます。 実行時に、非ストリーミング クエリ演算子はすべてのソース データを読み 取ってデータ構造に格納し、演算を実行して結果の要素を生成します。
 分類表 次の表では、各標準クエリ演算子メソッドを、その実行方法に基づいて分類しています。
    NOTE
2 つの列にマークが付けられている演算子では、2 つの入力シーケンスが演算に使用され、各シーケンスの評価は異なります。 この場合、遅 延実行のストリーミングで評価されるのは、常にパラメーター リストの最初のシーケンスになります。
 ( )
( )
        Aggregate TSource x All Boolean x
               実行方法による標準クエリ演算子の分類 (C#) 2020/11/02 • • Edit Online
 
                        (
)
( )
        Any
AsEnumerable Average
Cast
Concat
Contains
Count DefaultIfEmpty Distinct
ElementAt ElementAtOrDefault Empty
Except
First
FirstOrDefault GroupBy
GroupJoin
Intersect
Join
Last
LastOrDefault LongCount
Max
Min
Boolean
IEnumerable<T>
1 つの数値
IEnumerable<T>
IEnumerable<T>
Boolean
Int32
IEnumerable<T>
IEnumerable<T>
TSource
TSource
IEnumerable<T>
IEnumerable<T>
TSource
TSource
IEnumerable<T>
IEnumerable<T>
IEnumerable<T>
IEnumerable<T>
TSource
TSource
Int64
1 つの数値、TSource、 または TResult
1 つの数値、TSource、 または TResult
x
x
x x
x x x
x x
X
x x
x X
x
x x x
X
x x x X
                                                                                                                                                                                              x x X x
x
                                             
                                 (
) ( )
        OfType OrderBy
OrderByDescending
Range
Repeat
Reverse
Select SelectMany SequenceEqual Single SingleOrDefault Skip
SkipWhile Sum
Take TakeWhile ThenBy
ThenByDescending
ToArray
To D i c t i o n a r y
ToList ToLookup
IEnumerable<T>
IOrderedEnumerable <TElement>
IOrderedEnumerable <TElement>
IEnumerable<T> IEnumerable<T> IEnumerable<T> IEnumerable<T> IEnumerable<T> Boolean TSource
TSource
IEnumerable<T>
IEnumerable<T>
1 つの数値
IEnumerable<T>
IEnumerable<T>
IOrderedEnumerable <TElement>
IOrderedEnumerable <TElement>
TSource 配列 Dictionar y<TKey,TVa l
ue> IList<T>
ILookup<TKey,TElem ent>
x
x x
x x
x X
x x
x
x
x
                                                                                X x x
x
                                                                                x
X
                    x x
x x
                                        Union
IEnumerable<T>
x
     
      ( )
( )
      Where IEnumerable<T> X
   関連項目
Enumerable
標準クエリ演算子の概要 (C#) 標準クエリ演算子のクエリ式構文 (C#) LINQ to Objects (C#)

             並べ替え操作では、1 つ以上の属性に基づいてシーケンスの要素を並べ替えます。 並べ替えの第 1 条件で、要素に対して 一回目の並べ替えが実行されます。 第 2 条件を指定すると、第 1 条件で並べ替えられた各グループ内の要素を並べ替える ことができます。
次の図は、文字のシーケンスに対してアルファベット順の並べ替え操作を実行した結果を示しています。
次のセクションでは、データの並べ替えを実行する標準クエリ演算子のメソッドの一覧を示します。 メソッド
C #
    OrderBy
   値を昇順に並べ替えます。
    orderby
   Enumerable.OrderBy Quer yable.OrderBy
   OrderByDescending
 値を降順に並べ替えます。
  orderby ... descending
 Enumerable.OrderByDescen ding
Quer yable.OrderByDescendi ng
   ThenBy
   2 番目の並べ替えを昇順で実 行します。
    orderby ..., ...
   Enumerable.ThenBy Quer yable.ThenBy
   ThenByDescending
 2 番目の並べ替えを降順で実 行します。
  orderby ..., ... descending
 Enumerable.ThenByDescend ing
Quer yable.ThenByDescendi ng
    Reverse
   コレクションの要素の順序を反 転させます。
    該当なし。
   Enumerable.Reverse Q u e r y a b l e . Re v e r s e
 クエリ式の構文例
1 番目の並べ替えの例
1 番目の並べ替え (昇順)
次の例は、LINQクエリで orderby 句を使用して、配列内の文字列を文字列長に従って昇順に並べ替える方法を示してい ます。
 データの並べ替え (C#) 2020/11/02 • • Edit Online
 
  1 番目の並べ替え (降順)
次の例は、LINQクエリで orderby descending 句を使用して、文字列を最初の文字に従って降順に並べ替える方法を示し ています。
     string[] words = { "the", "quick", "brown", "fox", "jumps" };
IEnumerable<string> query = from word in words
                            orderby word.Substring(0, 1) descending
select word;
foreach (string str in query)
    Console.WriteLine(str);
/* This code produces the following output:
    the
    quick
    jumps
    fox
    brown
*/
 2 番目の並べ替えの例
2 番目の並べ替え (昇順)
次の例は、LINQクエリで orderby 句を使用して、配列内の文字列に対して1番目および2番目の並べ替えを実行する 方法を示しています。 文字列は、最初に文字列長を基準として、次に文字列の最初の文字を基準として、どちらも昇順に 並べ替えられます。
    string[] words = { "the", "quick", "brown", "fox", "jumps" };
IEnumerable<string> query = from word in words
                            orderby word.Length
select word;
foreach (string str in query)
    Console.WriteLine(str);
/* This code produces the following output:
    the
    fox
    quick
    brown
    jumps
*/
 
       2 番目の並べ替え (降順)
次の例は、LINQクエリで orderby descending 句を使用して、1番目の並べ替えを昇順で実行し、2番目の並べ替えを降
順で実行する方法を示しています。 各文字列は、最初に文字列長を基準として、次に文字列の最初の文字を基準として 並べ替えられます。
     string[] words = { "the", "quick", "brown", "fox", "jumps" };
IEnumerable<string> query = from word in words
                            orderby word.Length, word.Substring(0, 1) descending
select word;
foreach (string str in query)
    Console.WriteLine(str);
/* This code produces the following output:
    the
    fox
    quick
    jumps
    brown
*/
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
orderby 句
join 句の結果の順序指定
任意のワードまたはフィールドを基準にテキスト データの並べ替えまたはフィルター処理を実行する方法 (LINQ) (C#)
   string[] words = { "the", "quick", "brown", "fox", "jumps" };
IEnumerable<string> query = from word in words
                            orderby word.Length, word.Substring(0, 1)
select word;
foreach (string str in query)
    Console.WriteLine(str);
/* This code produces the following output:
    fox
    the
    brown
    jumps
    quick
*/
 
            LINQ のセット操作は、同一または別個のコレクション (またはセット) に等しい要素があるかどうかに基づいて、結果を生成する クエリ操作です。
次のセクションでは、セット操作を実行する標準クエリ演算子のメソッドの一覧を示します。 メソッド
C #
   Distinct
   コレクションから重複する値を削 除します。
   該当なし。
   Enumerable.Distinct Quer yable.Distinct
   除く
 差集合 (一方のコレクションにだ け存在し、もう一方のコレクショ ンには出現しない要素) を返し ます。
 該当なし。
 Enumerable.Except Quer yable.Except
   交差
  積集合 (2 つのコレクションのそ れぞれに出現する要素) を返し ます。
  該当なし。
  Enumerable.Intersect Quer yable.Intersect
    和集合
   和集合 (2 つのコレクションのど ちらかに出現する一意の要素) を返します。
    該当なし。
   Enumerable.Union Quer yable.Union
 セット操作の比較
Distinct
次の例は、文字のシーケンスに対する Enumerable.Distinct メソッドの動作を示しています。 返されたシーケンスには、入力 シーケンスからの一意の要素が格納されています。
 セット操作 (C#) 2020/11/02 • • Edit Online
 
    除く
次の例で、Enumerable.Except の動作を説明します。 返されたシーケンスには、1 つ目の入力シーケンスのうち、2 つ目の入 力シーケンスには存在しない要素が格納されています。
     string[] planets1 = { "Mercury", "Venus", "Earth", "Jupiter" };
string[] planets2 = { "Mercury", "Earth", "Mars", "Jupiter" };
IEnumerable<string> query = from planet in planets1.Except(planets2)
                            select planet;
foreach (var str in query)
{
    Console.WriteLine(str);
}
/* This code produces the following output:
 *
* Venus */
 交差
次の例で、Enumerable.Intersect の動作を説明します。 返されたシーケンスには、両方の入力シーケンスに共通する要素が 格納されています。
    string[] planets = { "Mercury", "Venus", "Venus", "Earth", "Mars", "Earth" };
IEnumerable<string> query = from planet in planets.Distinct()
                            select planet;
foreach (var str in query)
{
    Console.WriteLine(str);
}
/* This code produces the following output:
 *
 * Mercury
 * Venus
 * Earth
 * Mars
*/
 
      和集合
次の例は、2 つの文字シーケンスに対する和集合演算を示しています。 返されたシーケンスには、両方の入力シーケンスから の一意の要素が格納されています。
     string[] planets1 = { "Mercury", "Venus", "Earth", "Jupiter" };
string[] planets2 = { "Mercury", "Earth", "Mars", "Jupiter" };
IEnumerable<string> query = from planet in planets1.Union(planets2)
                            select planet;
foreach (var str in query)
{
    Console.WriteLine(str);
}
/* This code produces the following output:
 *
 * Mercury
 * Venus
 * Earth
 * Jupiter
 * Mars
*/
 関連項目
System.Linq
標準クエリ演算子の概要 (C#) 文字列コレクションを結合および比較する方法 (LINQ) (C#) 2 つのリストの差集合を見つける方法 (LINQ) (C#)
   string[] planets1 = { "Mercury", "Venus", "Earth", "Jupiter" };
string[] planets2 = { "Mercury", "Earth", "Mars", "Jupiter" };
IEnumerable<string> query = from planet in planets1.Intersect(planets2)
                            select planet;
foreach (var str in query)
{
    Console.WriteLine(str);
}
/* This code produces the following output:
 *
 * Mercury
 * Earth
 * Jupiter
 */
 
         フィルター処理とは、特定の条件を満たす要素のみが含まれるように結果セットを限定する操作のことです。 選択とも呼ばれま す。
次の図は、文字のシーケンスをフィルター処理した結果を示したものです。 フィルター処理操作の述語では、文字が "A" でなけ ればならないことが指定されています。
次のセクションでは、選択を実行する標準クエリ演算子メソッドの一覧を示します。 メソッド
C #
    OfType
  指定した型にキャストできるかど うかにより、値を選択します。
  該当なし。
  Enumerable.OfType Q u e r y a b l e . O f Ty p e
    Where
   述語関数に基づいて値を選択 します。
    where
   Enumerable.Where Quer yable.Where
 クエリ式の構文例
次の例では、 where 句を使って、配列から特定の長さを持つ文字列をフィルター処理します。
    string[] words = { "the", "quick", "brown", "fox", "jumps" };
IEnumerable<string> query = from word in words
                            where word.Length == 3
select word;
foreach (string str in query)
    Console.WriteLine(str);
/* This code produces the following output:
the
fox */
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
データのフィルター処理 (C#) 2020/11/02 • • Edit Online
 
      where 句
実行時における述語フィルターの動的指定
リフレクションを使用してアセンブリのメタデータにクエリを実行する方法 (LINQ) (C#) 指定された属性または名前のファイルを照会する方法 (C#)
任意のワードまたはフィールドを基準にテキスト データの並べ替えまたはフィルター処理を実行する方法 (LINQ) (C#)

          量指定子操作は、シーケンス内の要素の一部またはすべてが条件を満たしているかどうかを示す Boolean 値を返します。
次の図は、2 つの異なるソース シーケンスに対する、2 つの異なる量指定子操作を示しています。 最初の操作では、1 つ以 上の要素が文字'A'であるかどうかを尋ねていて、その結果は true です。2番目の操作では、すべての要素が文字'A'で あるかどうかを尋ねていて、その結果は true です。
次のセクションでは、量指定子操作を実行する標準クエリ演算子のメソッドの一覧を示します。 メソッド
C #
    すべて
  シーケンス内のすべての要素が 条件を満たしているかどうかを調 べます。
  該当なし。
  Enumerable.All Quer yable.All
   どれでも可
  シーケンス内のいずれかの要素 が条件を満たしているかどうかを 調べます。
  該当なし。
  Enumerable.Any Quer yable.Any
    内容
   指定した要素がシーケンスに格 納されているかどうかを調べま す。
    該当なし。
   Enumerable.Contains Quer yable.Contains
 クエリ式の構文例
すべて
次の例では、 All を使用して、すべての文字列が特定の長さであることを確認します。
量指定子操作 (C#) 2020/11/02 • • Edit Online
 
  どれでも可
次の例では、Any を使用して、任意の文字列が"o"で開始されることを確認します。
    class Market
{
    public string Name { get; set; }
    public string[] Items { get; set; }
}
public static void Example()
{
    List<Market> markets = new List<Market>
    {
        new Market { Name = "Emily's", Items = new string[] { "kiwi", "cheery", "banana" } },
        new Market { Name = "Kim's", Items = new string[] { "melon", "mango", "olive" } },
        new Market { Name = "Adam's", Items = new string[] { "kiwi", "apple", "orange" } },
};
    // Determine which market have any fruit names start with 'o'
    IEnumerable<string> names = from market in markets
                                where market.Items.Any(item => item.StartsWith("o"))
                                select market.Name;
    foreach (string name in names)
    {
        Console.WriteLine($"{name} market");
    }
    // This code produces the following output:
    //
    // Kim's market
    // Adam's market
}
    class Market
{
    public string Name { get; set; }
    public string[] Items { get; set; }
}
public static void Example()
{
    List<Market> markets = new List<Market>
    {
        new Market { Name = "Emily's", Items = new string[] { "kiwi", "cheery", "banana" } },
        new Market { Name = "Kim's", Items = new string[] { "melon", "mango", "olive" } },
        new Market { Name = "Adam's", Items = new string[] { "kiwi", "apple", "orange" } },
};
    // Determine which market have all fruit names length equal to 5
    IEnumerable<string> names = from market in markets
                                where market.Items.All(item => item.Length == 5)
                                select market.Name;
    foreach (string name in names)
    {
        Console.WriteLine($"{name} market");
    }
    // This code produces the following output:
    //
    // Kim's market
}
 
     内容
次の例では、 Contains を使用して、配列に特定の要素が含まれることを確認します。
     class Market
{
    public string Name { get; set; }
    public string[] Items { get; set; }
}
public static void Example()
{
    List<Market> markets = new List<Market>
    {
        new Market { Name = "Emily's", Items = new string[] { "kiwi", "cheery", "banana" } },
        new Market { Name = "Kim's", Items = new string[] { "melon", "mango", "olive" } },
        new Market { Name = "Adam's", Items = new string[] { "kiwi", "apple", "orange" } },
};
    // Determine which market contains fruit names equal 'kiwi'
    IEnumerable<string> names = from market in markets
                                where market.Items.Contains("kiwi")
                                select market.Name;
    foreach (string name in names)
    {
        Console.WriteLine($"{name} market");
    }
    // This code produces the following output:
    //
    // Emily's market
    // Adam's market
}
 関連項目
System.Linq
標準クエリ演算子の概要 (C#) 実行時における述語フィルターの動的指定 指定されたワードのセットを含む文章を照会する方法 (LINQ) (C#)

       射影とは、オブジェクトを、必要なプロパティだけで構成された別の形式に変換する操作のことをいいます。 射影を使用すること により、個々のオブジェクトから構築された新しい型を作成できます。 プロパティを投影し、それに対して数値演算関数を実行 できます。 また、元のオブジェクトを変更せずに射影することもできます。
次のセクションでは、射影を実行する標準クエリ演算子メソッドの一覧を示します。 メソッド
C #
   選択
  変換関数に基づいて値を射影 します。
   select
  Enumerable.Select Quer yable.Select
    SelectMany
   変換関数に基づいて値のシーケ ンスを射影し、それを 1 つのシー ケンスに平坦化します。
    複数の from 句を使用
   Enumerable.SelectMany Quer yable.SelectMany
 クエリ式の構文例 選択
次の例では、 select 句を使って、文字列リストにある各文字列の最初の文字を射影します。
     List<string> words = new List<string>() { "an", "apple", "a", "day" };
var query = from word in words
            select word.Substring(0, 1);
foreach (string s in query)
    Console.WriteLine(s);
/* This code produces the following output:
a a a d
*/
 SelectMany
次の例では、 from 句を複数使用して、文字列リストにある各文字列の各単語を射影します。
射影操作 (C#) 2020/11/02 • • Edit Online
 
  Select と SelectMany の比較
Select() と SelectMany() の機能はどちらも、ソース値から結果値(複数も可)を生成することです。 Select() は、ソース 値ごとに結果値を 1 つ生成します。 そのため、結果全体は、ソース コレクションと同じ数の要素を持つ 1 つのコレクションになり ます。 これに対し、 は、各ソース値から、連結されたサブコレクションを含む 1 つの総合的な結果を生成しま す。 に引数として渡される変換関数は、ソース値ごとに列挙可能な値のシーケンスを返す必要があります。 こ の列挙可能なシーケンスは SelectMany() によって連結されて、1つの大きなシーケンスが作成されます。
これら 2 つのメソッドのアクションの概念的な違いを次の 2 つの図に示します。 どちらも、セレクター (変換) 関数が各ソース値か ら花の配列を選択することを想定しています。
次の図は、 Select() がソース コレクションと同じ数の要素を持つコレクションを返すしくみを示しています。
次の図は、 SelectMany() が中間配列シーケンスを、各中間配列の値を含む最終的な結果値に連結するしくみを示してい ます。
    SelectMany()
 SelectMany()
       List<string> phrases = new List<string>() { "an apple a day", "the quick brown fox" };
var query = from phrase in phrases
            from word in phrase.Split(' ')
select word;
foreach (string s in query)
    Console.WriteLine(s);
/* This code produces the following output:
    an
    apple
    a
    day
    the
    quick
    brown
    fox
*/
 
    コード例
次の例は、 Select() と SelectMany() の動作を比較しています。 コードは、ソース コレクションの花の名前の各リストから最 初の 2 つの項目を取って "花束" を作成します。 この例では、変換関数 Select<TSource,TResult> (IEnumerable<TSource>, Func<TSource,TResult>) が使用する "単一の値" 自体が値のコレクションになっています。 各 サブシーケンスで各文字列を列挙するために追加の foreach ループを使用しています。
       class Bouquet
{
    public List<string> Flowers { get; set; }
}
static void SelectVsSelectMany()
{
    List<Bouquet> bouquets = new List<Bouquet>() {
        new Bouquet { Flowers = new List<string> { "sunflower", "daisy", "daffodil", "larkspur" }},
        new Bouquet{ Flowers = new List<string> { "tulip", "rose", "orchid" }},
        new Bouquet{ Flowers = new List<string> { "gladiolis", "lily", "snapdragon", "aster", "protea" }},
        new Bouquet{ Flowers = new List<string> { "larkspur", "lilac", "iris", "dahlia" }}
};
    // *********** Select ***********
    IEnumerable<List<string>> query1 = bouquets.Select(bq => bq.Flowers);
    // ********* SelectMany *********
    IEnumerable<string> query2 = bouquets.SelectMany(bq => bq.Flowers);
    Console.WriteLine("Results by using Select():");
    // Note the extra foreach loop here.
    foreach (IEnumerable<String> collection in query1)
        foreach (string item in collection)
            Console.WriteLine(item);
    Console.WriteLine("\nResults by using SelectMany():");
    foreach (string item in query2)
        Console.WriteLine(item);
    /* This code produces the following output:
       Results by using Select():
        sunflower
        daisy
        daffodil
        larkspur
        tulip
        rose
        orchid
        gladiolis
        lily
        snapdragon
        aster

     aster
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
select 句
複数のソースからオブジェクト コレクションにデータを設定する方法 (LINQ) (C#) グループを使用して 1 つのファイルを複数のファイルに分割する方法 (LINQ) (C#)
           protea
        larkspur
        lilac
        iris
        dahlia
       Results by using SelectMany():
        sunflower
        daisy
        daffodil
        larkspur
        tulip
        rose
        orchid
        gladiolis
        lily
        snapdragon
        aster
        protea
        larkspur
        lilac
iris
dahlia */
}
 
             LINQ におけるパーティション分割とは、要素を並べ替えずに入力シーケンスを 2 つのセクションに分割し、それらのセクションの 1 つを返す操作を指します。
次の図は、文字のシーケンスに対して 3 つの異なるパーティション分割操作を実行した結果を示しています。 最初の操作で は、シーケンスの最初の 3 つの要素が返されます。 2 番目の操作では、最初の 3 つの要素がスキップされ、残りの要素が返さ れます。 3 番目の操作では、シーケンスの最初の 2 つの要素がスキップされ、次の 3 つの要素が返されます。
次のセクションに、シーケンスのパーティション分割を実行する標準クエリ演算子メソッドの一覧を示します。 演算子
 C #
   Skip
  シーケンス内の指定した位置ま で要素をスキップします。
  該当なし。
  Enumerable.Skip Quer yable.Skip
   SkipWhile
  述語関数に基づき、条件を満 たさない要素が出現する位置 まで要素をスキップします。
  該当なし。
  Enumerable.SkipWhile Quer yable.SkipWhile
   Take
  シーケンス内の指定した位置ま での要素を取得します。
  該当なし。
  Enumerable.Take Q u e r y a b l e . Ta k e
    TakeWhile
   述語関数に基づき、条件を満 たさない要素が出現する位置 までの要素を取得します。
    該当なし。
   Enumerable.TakeWhile Q u e r y a b l e . Ta k e W h i l e
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
データのパーティション分割 (C#) 2020/11/02 • • Edit Online
 
         2 つのデータ ソースの "結合" とは、あるデータ ソースのオブジェクトを、共通の属性を共有する別のデータ ソースのオブジェクトと 関連付けることです。
相互に直接指定することができない関係を持つデータ ソースを対象とするクエリにおいて、Join は重要な操作になります。 オブ ジェクト指向プログラミングでは、これは一方向の関係における逆の方向など、モデル化されていないオブジェクト間の相関関係 を意味する場合があります。 一方向の関係の例として、City 型のプロパティを持つ Customer クラスがあるとします。ただし、 City クラスには、Customer オブジェクトのコレクションを表すプロパティはありません。 City オブジェクトのリストから各都市のすべ ての顧客を取得する場合は、結合演算を使用して顧客を検索できます。
LINQ framework で用意された結合メソッドは Join と GroupJoin です。 この 2 つのメソッドは、等結合 (キーが等しいかどう かに基づいて 2 つのデータ ソースを対応させる結合) を実行します。 (比較に関して、Transact-SQL では、"小なり" 演算子な どの "等値" 以外の結合演算子もサポートされます)。リレーショナル データベース用語で説明すると、Join は内部結合 (両方 のデータ セットで一致するオブジェクトだけが返される結合) を実装します。 リレーショナル データベース用語で GroupJoin メソッ ドに直接相当するものはありませんが、このメソッドは内部結合と左外部結合のスーパーセットを実装します。 左外部結合と は、最初 (左側) のデータ ソースの各要素を返す結合です。これらの要素は、もう一方のデータ ソースの要素と相関関係がな くても返されます。
次の図は、2 つのセットと、内部結合または左外部結合としてこれらのセットに含まれている要素の概念図を示しています。
 メソッド
クエリ式の構文例
Join
C #
   Join
   キー セレクター関数に基づいて 2 つのシーケンスの Join を行 い、値のペアを抽出します。
    join ... in ... on ... equals ...
   Enumerable.Join Quer yable.Join
    GroupJoin
   キー セレクター関数に基づいて 2 つのシーケンスの Join を行 い、各要素について結果として 得られる一致をグループ化しま す。
    join ... in ... on ... equals ... into ...
  Enumerable.GroupJoin Quer yable.GroupJoin
  次の例では、 join ... in ... on ... equals ... 句を使用し、特定の値に基づいて 2 つのシーケンスを結合します。
Join 演算 (C#) 2020/11/02 • • Edit Online
 
    GroupJoin
次の例では、 join ... in ... on ... equals ... into ... 句を使用し、特定の値に基づいて 2 つのシーケンスを結合し、要素ごとに 結果として得られる一致をグループ化します。
   class Product
{
    public string Name { get; set; }
    public int CategoryId { get; set; }
}
class Category
{
    public int Id { get; set; }
    public string CategoryName { get; set; }
}
public static void Example()
{
    List<Product> products = new List<Product>
    {
        new Product { Name = "Cola", CategoryId = 0 },
        new Product { Name = "Tea", CategoryId = 0 },
        new Product { Name = "Apple", CategoryId = 1 },
        new Product { Name = "Kiwi", CategoryId = 1 },
        new Product { Name = "Carrot", CategoryId = 2 },
};
    List<Category> categories = new List<Category>
    {
        new Category { Id = 0, CategoryName = "Beverage" },
        new Category { Id = 1, CategoryName = "Fruit" },
        new Category { Id = 2, CategoryName = "Vegetable" }
};
    // Join products and categories based on CategoryId
    var query = from product in products
                join category in categories on product.CategoryId equals category.Id
                select new { product.Name, category.CategoryName };
    foreach (var item in query)
    {
        Console.WriteLine($"{item.Name} - {item.CategoryName}");
    }
    // This code produces the following output:
    //
    // Cola - Beverage
    // Tea - Beverage
    // Apple - Fruit
    // Kiwi - Fruit
    // Carrot - Vegetable
}

       関連項目
System.Linq
標準クエリ演算子の概要 (C#) 匿名型
Join およびクロス積クエリの作成 join 句
  class Product
{
    public string Name { get; set; }
    public int CategoryId { get; set; }
}
class Category
{
    public int Id { get; set; }
    public string CategoryName { get; set; }
}
public static void Example()
{
    List<Product> products = new List<Product>
    {
        new Product { Name = "Cola", CategoryId = 0 },
        new Product { Name = "Tea", CategoryId = 0 },
        new Product { Name = "Apple", CategoryId = 1 },
        new Product { Name = "Kiwi", CategoryId = 1 },
        new Product { Name = "Carrot", CategoryId = 2 },
};
    List<Category> categories = new List<Category>
    {
        new Category { Id = 0, CategoryName = "Beverage" },
        new Category { Id = 1, CategoryName = "Fruit" },
        new Category { Id = 2, CategoryName = "Vegetable" }
};
    // Join categories and product based on CategoryId and grouping result
    var productGroups = from category in categories
                        join product in products on category.Id equals product.CategoryId into productGroup
                        select productGroup;
    foreach (IEnumerable<Product> productGroup in productGroups)
    {
        Console.WriteLine("Group");
        foreach (Product product in productGroup)
        {
            Console.WriteLine($"{product.Name,8}");
        }
}
    // This code produces the following output:
    //
    // Group
    //     Cola
    //
    // Group
    //    Apple
    //     Kiwi
    // Group
    //   Carrot
}
Tea

         複合キーを使用した Join
異種ファイルのコンテンツを結合する方法 (LINQ) (C#)
join 句の結果の順序指定
カスタム結合操作の実行
グループ化結合の実行
内部結合の実行
左外部結合の実行
複数のソースからオブジェクト コレクションにデータを設定する方法 (LINQ) (C#)

        グループ化とは、各グループの要素が共通の属性を持つようにデータをグループに分ける操作を指します。 次の図は、文字のシーケンスをグループ化した結果を示しています。 各グループのキーは文字です。
次のセクションでは、データ要素をグループ化する標準クエリ演算子メソッドの一覧を示します。 メソッド
C #
    GroupBy
  共通の属性を共有する要素を グループ化します。 各グループ は IGrouping<TKey,TElement> オブジェクトによって表されます。
   group ... by
- または -
group ... by ... into ...
   Enumerable.GroupBy Quer yable.GroupBy
    ToLookup
   キー セレクター関数に基づい て、Lookup<TKey,TElement > (一対多の辞書) に要素を挿 入します。
    該当なし。
   Enumerable.ToLookup
 クエリ式の構文例
次のコード例では、 group by 句を使用して、偶数か奇数かによってリスト内の整数をグループ化します。
 データのグループ化 (C#) 2020/11/02 • • Edit Online
 
          関連項目
System.Linq
標準クエリ演算子の概要 (C#)
group 句
入れ子になったグループの作成
拡張子別にファイルをグループ化する方法 (LINQ) (C#)
クエリ結果のグループ化
グループ化操作でのサブクエリの実行
グループを使用して 1 つのファイルを複数のファイルに分割する方法 (LINQ) (C#)
   List<int> numbers = new List<int>() { 35, 44, 200, 84, 3987, 4, 199, 329, 446, 208 };
IEnumerable<IGrouping<int, int>> query = from number in numbers
                                         group number by number % 2;
foreach (var group in query)
{
    Console.WriteLine(group.Key == 0 ? "\nEven numbers:" : "\nOdd numbers:");
    foreach (int i in group)
        Console.WriteLine(i);
}
/* This code produces the following output:
    Odd numbers:
    35
    3987
    199
329
    Even numbers:
    44
    200
    84
4 446 208
*/
 
          生成とは、値のシーケンスを新しく作成することを意味します。 次のセクションでは、生成を実行する標準クエリ演算子メソッドの一覧を示します。
メソッド
Empty
範囲
Repeat
関連項目
System.Linq
標準クエリ演算子の概要 (C#)
空のコレクションを返します。
一連の数値を含むコレクション を生成します。
繰り返される 1 つの値を含むコ レクションを生成します。
C #
該当なし。 該当なし。
該当なし。
Enumerable.Empty Enumerable.Range
Enumerable.Repeat
   DefaultIfEmpty
   空のコレクションを、既定値を持 つシングルトン コレクションに置 き換えます。
   該当なし。
   Enumerable.DefaultIfEmpty Quer yable.DefaultIfEmpty
                     生成操作 (C#) 2020/11/02 • • Edit Online
 
        2 つのシーケンスの対応する要素が等しく、要素数も同じである場合、これらのシーケンスは等しいと見なされます。 メソッド
C #
    SequenceEqual
    要素をペアにして比較すること で、2 つのシーケンスが等しいか どうかを判断します。
    該当なし。
   Enumerable.SequenceEqual Quer yable.SequenceEqual
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
2 つのフォルダーの内容を比較する方法 (LINQ) (C#)
等値演算 (C#) 2020/11/02 • • Edit Online
 
                     要素操作では、シーケンスから単一の特定の要素が返されます。 次のセクションでは、要素操作を実行する標準クエリ演算子のメソッドの一覧を示します。
メソッド
C #
   ElementAt
   コレクション内の指定されたイン デックス位置にある要素を返し ます。
   該当なし。
   Enumerable.ElementAt Quer yable.ElementAt
   ElementAtOrDefault
 コレクション内の指定したインデッ クス位置にある要素を返しま す。インデックスが範囲外の場 合は既定値を返します。
 該当なし。
 Enumerable.ElementAtOrDe fault
Quer yable.ElementAtOrDef ault
   First
   コレクションの最初の要素、また は条件を満たす最初の要素を 返します。
   該当なし。
   Enumerable.First Quer yable.First
   FirstOrDefault
 コレクションの最初の要素、また は条件を満たす最初の要素を 返します。 そのような要素が存 在しない場合は、既定値を返 します。
 該当なし。
 Enumerable.FirstOrDefault Quer yable.FirstOrDefault
Quer yable.FirstOrDefault<T Source>
(IQuer yable<TSource>)
   末尾
   コレクションの最後の要素、また は条件を満たす最後の要素を 返します。
   該当なし。
   Enumerable.Last Quer yable.Last
   LastOrDefault
  コレクションの最後の要素、また は条件を満たす最後の要素を 返します。 そのような要素が存 在しない場合は、既定値を返 します。
  該当なし。
  Enumerable.LastOrDefault Quer yable.LastOrDefault
   Single
  コレクションの唯一の要素、また は条件を満たす唯一の要素を 返します。 要素がない場合、ま たは複数の要素が返される場 合 は、InvalidOperationExcepti on をスローします。
  該当なし。
  Enumerable.Single Quer yable.Single
 要素操作 (C#) 2020/11/02 • • Edit Online
 
       C #
    SingleOrDefault
   コレクションの唯一の要素、また は条件を満たす唯一の要素を 返します。 返す要素がない場 合は、既定値を返します。 複 数の要素が返される場合 は、InvalidOperationExcepti on をスローします。
    該当なし。
   Enumerable.SingleOrDefault Quer yable.SingleOrDefault
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
ディレクトリ ツリー内で最もサイズの大きいファイルを照会する方法 (LINQ) (C#)

                     変換メソッドは、入力オブジェクトの型を変更します。
LINQ クエリの変換操作は、さまざまなアプリケーションで役に立ちます。 次にいくつかの例を示します。
Enumerable.AsEnumerable メソッドを使用すると、標準クエリ演算子の型のカスタム実装を非表示することができま す。
Enumerable.OfType メソッドを使用すると、LINQ クエリのパラメーター化されていないコレクションを有効にすることがで きます。
Enumerable.ToArray、Enumerable.ToDictionary、Enumerable.ToList、および Enumerable.ToLookup メソッドを 使用すると、クエリが列挙されるまで延期させるのではなく、即時のクエリ実行を強制することができます。
メソッド 次の表には、データ型の変換を実行する標準クエリ演算子メソッドの一覧が示されています。
名前が "As" で始まるこの表の変換メソッドは、ソース コレクションの静的型を変更しますが、ソース コレクションを列挙しませ ん。 名前が "To" で始まるメソッドは、ソース コレクションを列挙し、各項目を対応するコレクション型に変換します。
C #
AsEnumerable IEnumerable<T> として型指 該当なし。 Enumerable.AsEnumerable 定された入力を返します。
           AsQuer yable
   (ジェネリック) IEnumerable を (ジェネリック) IQueryable に変 換します。
   該当なし。
   Quer yable.AsQuer yable
   Cast
 コレクションの要素を指定した型 にキャストします。
 明示的に型指定された範囲変 数を使用します。 次に例を示 します。
 from string str in words
 Enumerable.Cast Quer yable.Cast
   OfType
  指定した型にキャストできるかど うかに応じて値をフィルター処理 します。
  該当なし。
  Enumerable.OfType Q u e r y a b l e . O f Ty p e
   ToArray
   コレクションを配列に変換しま す。 このメソッドはクエリの実行 を強制します。
   該当なし。
   Enumerable.ToArray
   To D i c t i o n a r y
  キー セレクター関数に基づい て、Dictionar y<TKey,TValue > に要素を変換します。 このメ ソッドはクエリの実行を強制しま す。
  該当なし。
  E n u m e r a b l e . To D i c t i o n a r y
 データ型の変換 (C#) 2020/11/02 • • Edit Online
 
         クエリ式の構文例
次のコード例では、サブタイプでのみ使用できるメンバーにアクセスする前に、明示的に型指定された範囲変数を使用して、型 をそのサブタイプにキャストしています。
C #
   ToList
   コレクションを List<T> に変換 します。 このメソッドはクエリの実 行を強制します。
   該当なし。
   Enumerable.ToList
    ToLookup
  キー セレクター関数に基づい て、Lookup<TKey,TElement > (一対多の辞書) に要素を変 換します。 このメソッドはクエリの 実行を強制します。
   該当なし。
  Enumerable.ToLookup
     class Plant {
    public string Name { get; set; }
}
class CarnivorousPlant : Plant
{
    public string TrapType { get; set; }
}
static void Cast()
{
    Plant[] plants = new Plant[] {
        new CarnivorousPlant { Name = "Venus Fly Trap", TrapType = "Snap Trap" },
        new CarnivorousPlant { Name = "Pitcher Plant", TrapType = "Pitfall Trap" },
        new CarnivorousPlant { Name = "Sundew", TrapType = "Flypaper Trap" },
        new CarnivorousPlant { Name = "Waterwheel Plant", TrapType = "Snap Trap" }
};
    var query = from CarnivorousPlant cPlant in plants
                where cPlant.TrapType == "Snap Trap"
                select cPlant;
    foreach (Plant plant in query)
        Console.WriteLine(plant.Name);
    /* This code produces the following output:
        Venus Fly Trap
        Waterwheel Plant
    */
}
 関連項目
System.Linq
標準クエリ演算子の概要 (C#)
from 句
LINQ クエリ式
LINQ を使用して ArrayList にクエリを実行する方法 (C#)

        連結とは、1 つのシーケンスを別のシーケンスに追加する演算を指します。 次の図は、2 つの文字シーケンスの連結演算を表しています。
次のセクションには、連結を実行する標準クエリ演算子メソッドの一覧が示されています。 メソッド
 C #
    Concat
   2 つのシーケンスを連結して 1 つのシーケンスにします。
    該当なし。
   Enumerable.Concat Quer yable.Concat
 関連項目
System.Linq
標準クエリ演算子の概要 (C#) 文字列コレクションを結合および比較する方法 (LINQ) (C#)
連結演算 (C#) 2020/11/02 • • Edit Online
 
                 集計の操作では、値の集合体から単一の値が計算されます。 たとえば、1 か月分の毎日の気温値から 1 日あたりの平均の 気温値を計算することが集計操作です。
次の図は、数値のシーケンスに対する 2 つの集計処理の結果を示しています。 最初の処理で数値が合計されます。 2 つ目 の処理でシーケンスの最大値が返されます。
次のセクションでは、集計処理を実行する標準クエリ演算子メソッドの一覧を示します。 メソッド
C #
    Aggregate
  コレクションの値に対してカスタム 集計処理を実行します。
  該当なし。
  Enumerable.Aggregate Quer yable.Aggregate
   平均
   値のコレクションの平均値を計 算します。
   該当なし。
   Enumerable.Average Quer yable.Average
   カウント
 コレクションの要素数をカウント します。述語関数を満たす要 素のみをカウントすることもでき ます。
 該当なし。
 Enumerable.Count Quer yable.Count
   LongCount
  大規模なコレクションの要素数 をカウントします。述語関数を 満たす要素のみをカウントするこ ともできます。
  該当なし。
  Enumerable.LongCount Quer yable.LongCount
   最大
  コレクション内の最大値を決定 します。
  該当なし。
  Enumerable.Max Quer yable.Max
   最小
  コレクション内の最小値を決定 します。
  該当なし。
  Enumerable.Min Quer yable.Min
    Sum
   コレクション内にある値の合計を 計算します。
    該当なし。
   Enumerable.Sum Quer yable.Sum
 集計処理 (C#) 2020/11/02 • • Edit Online
 
      関連項目
System.Linq
標準クエリ演算子の概要 (C#)
CSV テキスト ファイルの列値を計算する方法 (LINQ) (C#)
ディレクトリ ツリー内で最もサイズの大きいファイルを照会する方法 (LINQ) (C#) 一連のフォルダーの合計バイト数を照会する方法 (LINQ) (C#)

                "LINQ to Objects" という用語は、LINQ to SQL や LINQ to XML などの中間 LINQ プロバイダーまたは API を使用せずに、 LINQ クエリを任意の IEnumerable コレクションまたは IEnumerable<T> コレクションと直接組み合わせて使用することを意味 します。 LINQ を使用して、List<T>、Array、Dictionary<TKey,TValue> などの任意の列挙可能なコレクションを照会でき ます。 このコレクションは、ユーザー定義のコレクションでも、.NET API から返されたコレクションでもかまいません。
本質的に、LINQtoObjectsは、コレクションを扱うための新しい方法です。従来の方法では、複雑な foreach ループを記 述して、コレクションからデータを取得する方法を指定する必要がありました。 LINQ を使用する場合は、何を取得するかを表 す宣言コードを記述します。
また、LINQクエリには、従来の foreach ループと比べて、次の3つの重要な利点があります。 簡潔で読みやすい (特に複数の条件をフィルター処理する場合)。 強力なフィルター処理、並べ替え、およびグループ化機能を最小限のアプリケーション コードで実現できる。 ほとんど、またはまったく変更せずに、他のデータ ソースに移植できる。
通常、データに対して実行する操作が複雑なほど、従来の反復処理手法の代わりに LINQ を使用する利便性が高くなりま す。
このセクションでは、いくつか例を挙げながら、LINQ を使った方法を具体的に説明します。 すべてを網羅したものではありませ ん。
このセクションの内容
LINQ と文字列 (C#)
LINQ を使用して、文字列および文字列のコレクションの照会と変換を行う方法について説明します。 これらの基本原則を具 体的に示す記事へのリンクも含まれます。
LINQ とリフレクション (C#)
LINQ でリフレクションを使用する方法を示すサンプルへのリンクを示します。
LINQ とファイル ディレクトリ (C#)
LINQ を使用して、ファイル システムとやり取りする方法について説明します。 これらの概念を具体的に示す記事へのリンクも 含まれます。
LINQ を使用して ArrayList にクエリを実行する方法 (C#) C# で ArrayList を照会する方法を示します。
LINQ クエリのカスタム メソッドを追加する方法 (C#)
IEnumerable<T> インターフェイスに拡張メソッドを追加して、LINQ クエリに使用できるメソッド セットを拡張する方法について 説明します。
統合言語クエリ (LINQ) (C#)
LINQ について説明している記事へのリンクと、クエリを実行するコードの例を示します。
  LINQ to Objects (C#)
2020/11/02 • • Edit Online
 
                 文字列やそのコレクションは、LINQ を使って照会したり変換したりすることができます。 特に、テキスト ファイル内の半構造化さ れたデータでその利便性が発揮されます。 LINQ クエリは、従来の文字列関数や正規表現と組み合わせることができます。 た とえば、String.Split または Regex.Split メソッドを使用して、文字列の配列を作成し、その後で LINQ を使用してクエリを実 行したり変更したりすることができます。LINQクエリの where 句でRegex.IsMatchメソッドを使用できます。LINQを使用し て、正規表現によって返される MatchCollection の結果に対してクエリを実行したり変更したりすることができます。
このセクションで説明する手法を使えば、半構造化されたテキスト データを XML に変換することもできます。 詳細については、 「CSV ファイルから XML を生成する方法」を参照してください。
このセクションの例は、次の 2 つのカテゴリに分かれています。 テキスト ブロックに対するクエリ
String.Split メソッドまたは Regex.Split メソッドを使用して、テキスト ブロックをクエリ可能な小さな文字列の配列に分割するこ とによって、テキスト ブロックのクエリ、分析、および変更を実行できます。 単語や文、段落、ページなどの単位にソース テキスト を分割できるほか、クエリ内で必要であれば、さらに細かく分割することもできます。
文字列での単語の出現回数をカウントする方法 (LINQ) (C#) テキストに対する単純なクエリを LINQ で行う方法が紹介されています。
指定されたワードのセットを含む文章を照会する方法 (LINQ) (C#)
区切りを指定してテキスト ファイルを分割する方法やその各構成要素に対してクエリを実行する方法が紹介されていま
す。
文字列内の文字を照会する方法 (LINQ) (C#)
文字列がクエリ可能型であることを実証します。
LINQ クエリと正規表現を組み合わせる方法 (C#)
LINQ クエリで正規表現を使い、フィルター処理されたクエリ結果に対して複雑なパターン マッチを行う方法が紹介され ています。
半構造化されたテキスト形式データに対するクエリ
テキスト ファイルにはさまざまな種類がありますが、タブ区切りファイルやコンマ区切りファイル、固定長行など同様の形式を持っ た一連の行で構成されていることは少なくありません。 そのようなテキスト ファイルをメモリに読み込んだ後、LINQ を使って、必 要な行を照会したり編集したりすることができます。 複数ソースからのデータを組み合わせる作業も LINQ クエリなら簡単に行う ことができます。
2 つのリストの差集合を見つける方法 (LINQ) (C#) ある特定のリストには存在しているものの、それ以外には存在しない文字列をすべて探す方法が紹介されています。 任意のワードまたはフィールドを基準にテキスト データの並べ替えまたはフィルター処理を実行する方法 (LINQ) (C#) 単語やフィールドに基づいてテキスト行を並べ替える方法が紹介されています。 区切りファイルのフィールドの順序を変更する方法 (LINQ) (C#)
.csv ファイルの行に含まれるフィールドを並べ替える方法が紹介されています。
LINQ と文字列 (C#) 2020/11/02 • • Edit Online
 
        文字列コレクションを結合および比較する方法 (LINQ) (C#) 文字列リストをさまざまな方法で結合する方法が紹介されています。
複数のソースからオブジェクト コレクションにデータを設定する方法 (LINQ) (C#)
複数のテキスト ファイルをデータ ソースとしてオブジェクトのコレクションを作成する方法が紹介されています。 異種ファイルのコンテンツを結合する方法 (LINQ) (C#)
2 つのリストに含まれる文字列を、一致するキーを使って 1 つの文字列に結合する方法が紹介されています。 グループを使用して 1 つのファイルを複数のファイルに分割する方法 (LINQ) (C#)
1 つのファイルをデータ ソースとして新しいファイルを作成する方法が紹介されています。
CSV テキスト ファイルの列値を計算する方法 (LINQ) (C#)
.csv ファイルでテキスト データに対して数学的計算を実行する方法が紹介されています。 関連項目
統合言語クエリ (LINQ) (C#)
CSV ファイルから XML を生成する方法

     この例では、LINQ クエリを使用して、指定された単語が文字列内に出現する回数をカウントする方法を示します。 カウントを 実行するには、まず Split メソッドを呼び出して単語の配列を作成します。 Split メソッドを呼び出すと、パフォーマンスが低下し ます。 文字列に対する操作が単語のカウントのみである場合は、Matches または IndexOf メソッドの使用を検討してくださ い。 ただし、パフォーマンスが重要でない場合や、他の種類のクエリを実行する目的で事前に文章を分割している場合は、 LINQ を使用して単語や語句をカウントすることにも意味があります。
例
    class CountWords
{
    static void Main()
    {
        string text = @"Historically, the world of data and the world of objects" +
          @" have not been well integrated. Programmers work in C# or Visual Basic" +
          @" and also in SQL or XQuery. On the one side are concepts such as classes," +
          @" objects, fields, inheritance, and .NET APIs. On the other side" +
          @" are tables, columns, rows, nodes, and separate languages for dealing with" +
          @" them. Data types often require translation between the two worlds; there are" +
          @" different standard functions. Because the object world has no notion of query, a" +
          @" query can only be represented as a string without compile-time type checking or" +
          @" IntelliSense support in the IDE. Transferring data from SQL tables or XML trees to" +
          @" objects in memory is often tedious and error-prone.";
        string searchTerm = "data";
        //Convert the string into an array of words
        string[] source = text.Split(new char[] { '.', '?', '!', ' ', ';', ':', ',' },
StringSplitOptions.RemoveEmptyEntries);
        // Create the query.  Use ToLowerInvariant to match "data" and "Data"
        var matchQuery = from word in source
                         where word.ToLowerInvariant() == searchTerm.ToLowerInvariant()
                         select word;
        // Count the matches, which executes the query.
        int wordCount = matchQuery.Count();
        Console.WriteLine("{0} occurrences(s) of the search term \"{1}\" were found.", wordCount,
searchTerm);
        // Keep console window open in debug mode
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
} }
/* Output:
   3 occurrences(s) of the search term "data" were found.
*/
 コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
文字列での単語の出現回数をカウントする方法
(LINQ) (C#)
2020/11/02 • • Edit Online
 
  関連項目
LINQ と文字列 (C#)

   この例は、指定された一連の単語と一致する文言を含む文をテキスト ファイルから検索する方法を示しています。 この例では 検索語句の配列をハードコーディングしていますが、実行時に動的に設定することもできます。 この例のクエリを実行すると、 "Historically"、"data"、"integrated" という単語をすべて含んだ文が返されます。
例
    class FindSentences
{
    static void Main()
    {
        string text = @"Historically, the world of data and the world of objects " +
        @"have not been well integrated. Programmers work in C# or Visual Basic " +
        @"and also in SQL or XQuery. On the one side are concepts such as classes, " +
        @"objects, fields, inheritance, and .NET APIs. On the other side " +
        @"are tables, columns, rows, nodes, and separate languages for dealing with " +
        @"them. Data types often require translation between the two worlds; there are " +
        @"different standard functions. Because the object world has no notion of query, a " +
        @"query can only be represented as a string without compile-time type checking or " +
        @"IntelliSense support in the IDE. Transferring data from SQL tables or XML trees to " +
        @"objects in memory is often tedious and error-prone.";
        // Split the text block into an array of sentences.
        string[] sentences = text.Split(new char[] { '.', '?', '!' });
        // Define the search terms. This list could also be dynamically populated at runtime.
        string[] wordsToMatch = { "Historically", "data", "integrated" };
        // Find sentences that contain all the terms in the wordsToMatch array.
        // Note that the number of terms to match is not specified at compile time.
        var sentenceQuery = from sentence in sentences
                            let w = sentence.Split(new char[] { '.', '?', '!', ' ', ';', ':', ',' },
                                                    StringSplitOptions.RemoveEmptyEntries)
                            where w.Distinct().Intersect(wordsToMatch).Count() == wordsToMatch.Count()
                            select sentence;
        // Execute the query. Note that you can explicitly type
        // the iteration variable here even though sentenceQuery
        // was implicitly typed.
        foreach (string str in sentenceQuery)
        {
            Console.WriteLine(str);
}
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
} }
/* Output:
Historically, the world of data and the world of objects have not been well integrated
*/
 このクエリではまず、テキストを文単位に分割し、個々の単語を保持する文字列の配列に分割しています。 その各配列につい
指定されたワードのセットを含む文章を照会する
方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
    て、重複する単語を Distinct メソッドですべて削除したうえで、それらの単語の配列と   配列との Intersect 演 算を実行します。共通部分のカウントと wordsToMatch 配列のカウントとが一致した場合、文を構成する単語内にすべての 検索語句が見つかったものとして判断され、該当する文が返されます。
句読点を文字列から削除するために、Split の呼び出しでは句読点を区切り記号として使用しています。 この処理がないと、 たとえば"Historically,"という文字列があった場合に、wordsToMatch 配列内の"Historically"と一致しません。ソーステキ ストに使われている句読点の種類によっては、別の区切り記号を使う必要があります。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
   wordsToMatch
 
    String クラスはジェネリック IEnumerable<T> インターフェイスを実装しているため、任意の文字列を文字のシーケンスとしてク エリできます。 ただし、これは LINQ の一般的な使用方法ではありません。 複雑なパターン一致操作には、Regex クラスを使 用してください。
例
次の例では、文字列を対象にクエリを実行して、その文字列に含まれる数字の数を特定します。 クエリは、最初に使用された
後も "再利用" されます。 これができるのは、クエリ自体には実際の結果が格納されないためです。
    class QueryAString
{
    static void Main()
    {
        string aString = "ABCDE99F-J74-12-89A";
        // Select only those characters that are numbers
        IEnumerable<char> stringQuery =
          from ch in aString
          where Char.IsDigit(ch)
          select ch;
        // Execute the query
        foreach (char c in stringQuery)
            Console.Write(c + " ");
        // Call the Count method on the existing query.
        int count = stringQuery.Count();
        Console.WriteLine("Count = {0}", count);
        // Select all characters before the first '-'
        IEnumerable<char> stringQuery2 = aString.TakeWhile(c => c != '-');
        // Execute the second query
        foreach (char c in stringQuery2)
            Console.Write(c);
        Console.WriteLine(System.Environment.NewLine + "Press any key to exit");
        Console.ReadKey();
    }
}
/* Output:
  Output: 9 9 7 4 1 2 8 9
  Count = 8
  ABCDE99F
*/
 コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
文字列内の文字を照会する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
   LINQ と文字列 (C#)
LINQ クエリと正規表現を組み合わせる方法 (C#)

   この例では、Regex クラスを使用して正規表現を作成し、テキスト文字列内の複雑な一致を取得する方法を示します。 LINQ クエリを使用すると、正規表現で検索する必要のあるファイルだけをフィルターで抽出したり、結果の形式を指定したりす るのが簡単になります。
例
   LINQ クエリと正規表現を組み合わせる方法 (C#) 2020/11/02 • • Edit Online
  class QueryWithRegEx
{
    public static void Main()
    {
        // Modify this path as necessary so that it accesses your version of Visual Studio.
        string startFolder = @"C:\Program Files (x86)\Microsoft Visual Studio 14.0\";
        // One of the following paths may be more appropriate on your computer.
        //string startFolder = @"C:\Program Files (x86)\Microsoft Visual Studio\2017\";
        // Take a snapshot of the file system.
        IEnumerable<System.IO.FileInfo> fileList = GetFiles(startFolder);
        // Create the regular expression to find all things "Visual".
        System.Text.RegularExpressions.Regex searchTerm =
            new System.Text.RegularExpressions.Regex(@"Visual (Basic|C#|C\+\+|Studio)");
        // Search the contents of each .htm file.
        // Remove the where clause to find even more matchedValues!
        // This query produces a list of files where a match
        // was found, and a list of the matchedValues in that file.
        // Note: Explicit typing of "Match" in select clause.
        // This is required because MatchCollection is not a
        // generic IEnumerable collection.
        var queryMatchingFiles =
            from file in fileList
            where file.Extension == ".htm"
            let fileText = System.IO.File.ReadAllText(file.FullName)
            let matches = searchTerm.Matches(fileText)
            where matches.Count > 0
            select new
            {
                name = file.FullName,
                matchedValues = from System.Text.RegularExpressions.Match match in matches
                                select match.Value
};
        // Execute the query.
        Console.WriteLine("The term \"{0}\" was found in:", searchTerm.ToString());
        foreach (var v in queryMatchingFiles)
        {
            // Trim the path a bit, then write
            // the file name in which a match was found.
            string s = v.name.Substring(startFolder.Length - 1);
            Console.WriteLine(s);
            // For this file, write out all the matching strings
            foreach (var v2 in v.matchedValues)
            {
                Console.WriteLine("  " + v2);
            }
}

     }
 RegEx 検索で返されたMatchCollectionオブジェクトのクエリを実行することも可能です。この例では、一致した各文字列の 値のみが結果として生成されています。 しかし、LINQ を使用して、各種のフィルター処理、並べ替え、グループ化をそのコレク ションに対して実行することもできます。 MatchCollection が非ジェネリック IEnumerable コレクションなので、クエリで範囲変 数の型を明示的に記述する必要があります。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
LINQ とファイル ディレクトリ (C#)
           // Keep the console window open in debug mode
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    // This method assumes that the application has discovery
    // permissions for all folders under the specified path.
    static IEnumerable<System.IO.FileInfo> GetFiles(string path)
    {
        if (!System.IO.Directory.Exists(path))
            throw new System.IO.DirectoryNotFoundException();
        string[] fileNames = null;
        List<System.IO.FileInfo> files = new List<System.IO.FileInfo>();
        fileNames = System.IO.Directory.GetFiles(path, "*.*", System.IO.SearchOption.AllDirectories);
        foreach (string name in fileNames)
        {
            files.Add(new System.IO.FileInfo(name));
        }
        return files;
    }
}
 
      この例では、LINQ を使用して、2 つの文字列リストを比較し、names2.txt ではなく names1.txt でそれらの行を出力する方 法を示します。
データ ファイルを作成するには
1. 「文字列コレクションを結合および比較する方法 (LINQ) (C#)」に示されているように、ソリューション フォルダーに
names1.txt と names2.txt をコピーします。 例
    class CompareLists
{
    static void Main()
    {
} }
// Create the IEnumerable data sources.
string[] names1 = System.IO.File.ReadAllLines(@"../../../names1.txt");
string[] names2 = System.IO.File.ReadAllLines(@"../../../names2.txt");
// Create the query. Note that method syntax must be used here.
IEnumerable<string> differenceQuery =
  names1.Except(names2);
// Execute the query.
Console.WriteLine("The following lines are in names1.txt but not names2.txt");
foreach (string s in differenceQuery)
    Console.WriteLine(s);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit");
Console.ReadKey();
/* Output:
     The following lines are in names1.txt but not names2.txt
    Potra, Cristina
    Noriega, Fabricio
    Aw, Kam Foo
    Toyoshima, Tim
    Guy, Wey Yuan
    Garcia, Debra
*/
 Except、Distinct、Union、および Concat など、C# のいくつかの種類のクエリ操作は、メソッド ベースの構文でのみ表すことが できます。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
2 つのリストの差集合を見つける方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
    次の例では、コンマ区切り値などの構造化されたテキストの行を、行の任意のフィールドで並べ替える方法を示します。 フィール ドは、実行時に動的に指定できます。 scores.csv 内のフィールドは、学生の ID 番号と、それに続く 4 つのテストの点を表して いるものとします。
データを含むファイルを作成するには
1. 「 異種ファイルのコンテンツを結合する方法 (LINQ) (C#)」トピックから scores.csv のデータをコピーし、ソリューション フォル ダーに保存します。
例
任意のワードまたはフィールドを基準にテキスト データの並べ替えまたはフィルター処理を実行す
る方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
     この例では、メソッドからクエリ変数を返す方法についても示します。 コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
  public class SortLines
{
    static void Main()
    {
        // Create an IEnumerable data source
        string[] scores = System.IO.File.ReadAllLines(@"../../../scores.csv");
        // Change this to any value from 0 to 4.
        int sortField = 1;
        Console.WriteLine("Sorted highest to lowest by field [{0}]:", sortField);
        // Demonstrates how to return query from a method.
        // The query is executed here.
        foreach (string str in RunQuery(scores, sortField))
        {
            Console.WriteLine(str);
        }
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    // Returns the query variable, not query results!
    static IEnumerable<string> RunQuery(IEnumerable<string> source, int num)
    {
        // Split the string and sort on field[num]
        var scoreQuery = from line in source
                         let fields = line.Split(',')
                         orderby fields[num] descending
                         select line;
        return scoreQuery;
    }
}
/* Output (if sortField == 1):
   Sorted highest to lowest by field [1]:
    116, 99, 86, 90, 94
    120, 99, 82, 81, 79
    111, 97, 92, 81, 60
    114, 97, 89, 85, 82
    121, 96, 85, 91, 60
    122, 94, 92, 91, 91
    117, 93, 92, 80, 87
    118, 92, 90, 83, 78
    113, 88, 94, 65, 91
    112, 75, 84, 91, 39
    119, 68, 79, 88, 92
    115, 35, 72, 91, 70
*/

   コンマ区切り (CSV) ファイルは、テキスト ファイルです。多くの場合、行と列で表されるスプレッドシート データや他の表形式デー タの格納に使用されます。 Split メソッドを使用してフィールドを区切ると、LINQ を使用した CSV ファイルのクエリと操作がとて も簡単になります。 この手法は、CSV ファイルに限らず、行が構造化されているテキストの一部を並べ替えるときに利用できま す。
次の例では、学生の "名"、"姓"、"ID" を表す 3 つの列があります。 これらのフィールドは、学生の姓に基づいてアルファベット順 に並べられています。 クエリによって、ID 列が最初に表示され、学生の姓と名を結合して 2 列目に表示されるように列順を変 えます。 行は ID フィールドの順に並べ替えられます。 結果は新しいファイルに保存され、元のデータは変更されません。
データ ファイルを作成するには
1. 次の行を、spreadsheet1.csv というプレーン テキスト ファイルにコピーします。 プロジェクト フォルダーにファイルを保存し ます。
    Adams,Terry,120
Fakhouri,Fadi,116
Feng,Hanying,117
Garcia,Cesar,114
Garcia,Debra,115
Garcia,Hugo,118
Mortensen,Sven,113
O'Donnell,Claire,112
Omelchenko,Svetlana,111
Tucker,Lance,119
Tucker,Michael,122
Zabokritski,Eugene,121
 例
区切りファイルのフィールドの順序を変更する方
法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
       コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
LINQ とファイル ディレクトリ (C#)
CSV ファイルから XML を生成する方法 (C#)
  class CSVFiles
{
    static void Main(string[] args)
    {
        // Create the IEnumerable data source
        string[] lines = System.IO.File.ReadAllLines(@"../../../spreadsheet1.csv");
        // Create the query. Put field 2 first, then
        // reverse and combine fields 0 and 1 from the old field
        IEnumerable<string> query =
            from line in lines
            let x = line.Split(',')
            orderby x[2]
            select x[2] + ", " + (x[1] + " " + x[0]);
        // Execute the query and write out the new file. Note that WriteAllLines
        // takes a string[], so ToArray is called on the query.
        System.IO.File.WriteAllLines(@"../../../spreadsheet2.csv", query.ToArray());
        Console.WriteLine("Spreadsheet2.csv written to disk. Press any key to exit");
        Console.ReadKey();
    }
}
/* Output to spreadsheet2.csv:
111, Svetlana Omelchenko
112, Claire O'Donnell
113, Sven Mortensen
114, Cesar Garcia
115, Debra Garcia
116, Fadi Fakhouri
117, Hanying Feng
118, Hugo Garcia
119, Lance Tucker
120, Terry Adams
121, Eugene Zabokritski
122, Michael Tucker
*/

   この例では、複数行のテキストが含まれるファイルをマージし、結果を並び替える方法を示します。 具体的には、複数のテキス ト行からなる 2 つの集合の単純な連結、和集合、積集合を求める方法を示します。
プロジェクトとテキスト ファイルを設定するには
1. 次の名前を names1.txt という名前のテキスト ファイルにコピーし、プロジェクト フォルダーに保存します。
    Bankov, Peter
Holm, Michael
Garcia, Hugo
Potra, Cristina
Noriega, Fabricio
Aw, Kam Foo
Beebe, Ann
Toyoshima, Tim
Guy, Wey Yuan
Garcia, Debra
 2. 次の名前を names2.txt という名前のテキスト ファイルにコピーし、プロジェクト フォルダーに保存します。 2 つのファイル には、共通の名前がいくつか含まれていることに注意してください。
    Liu, Jinghao
Bankov, Peter
Holm, Michael
Garcia, Hugo
Beebe, Ann
Gilchrist, Beth
Myrcha, Jacek
Giakoumakis, Leo
McLin, Nkenge
El Yassir, Mehdi
 例
文字列コレクションを結合および比較する方法
(LINQ) (C#)
2020/11/02 • • Edit Online
     class MergeStrings
    {
        static void Main(string[] args)
        {
            //Put text files in your solution folder
            string[] fileA = System.IO.File.ReadAllLines(@"../../../names1.txt");
            string[] fileB = System.IO.File.ReadAllLines(@"../../../names2.txt");
            //Simple concatenation and sort. Duplicates are preserved.
            IEnumerable<string> concatQuery =
                fileA.Concat(fileB).OrderBy(s => s);
            // Pass the query variable to another function for execution.
            OutputQueryResults(concatQuery, "Simple concatenate and sort. Duplicates are preserved:");
            // Concatenate and remove duplicate names based on
            // default string comparer.
            IEnumerable<string> uniqueNamesQuery =

              fileA.Union(fileB).OrderBy(s => s);
        OutputQueryResults(uniqueNamesQuery, "Union removes duplicate names:");
        // Find the names that occur in both files (based on
        // default string comparer).
        IEnumerable<string> commonNamesQuery =
            fileA.Intersect(fileB);
        OutputQueryResults(commonNamesQuery, "Merge based on intersect:");
        // Find the matching fields in each list. Merge the two
        // results by using Concat, and then
        // sort using the default string comparer.
        string nameMatch = "Garcia";
        IEnumerable<String> tempQuery1 =
            from name in fileA
            let n = name.Split(',')
            where n[0] == nameMatch
            select name;
        IEnumerable<string> tempQuery2 =
            from name2 in fileB
            let n2 = name2.Split(',')
            where n2[0] == nameMatch
            select name2;
        IEnumerable<string> nameMatchQuery =
            tempQuery1.Concat(tempQuery2).OrderBy(s => s);
        OutputQueryResults(nameMatchQuery, $"Concat based on partial name match \"{nameMatch}\":");
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    static void OutputQueryResults(IEnumerable<string> query, string message)
    {
        Console.WriteLine(System.Environment.NewLine + message);
        foreach (string item in query)
        {
            Console.WriteLine(item);
        }
        Console.WriteLine("{0} total names in list", query.Count());
    }
}
/* Output:
    Simple concatenate and sort. Duplicates are preserved:
    Aw, Kam Foo
    Bankov, Peter
    Bankov, Peter
    Beebe, Ann
    Beebe, Ann
    El Yassir, Mehdi
    Garcia, Debra
    Garcia, Hugo
    Garcia, Hugo
    Giakoumakis, Leo
    Gilchrist, Beth
    Guy, Wey Yuan
    Holm, Michael
    Holm, Michael
    Liu, Jinghao
    McLin, Nkenge
    Myrcha, Jacek
    Noriega, Fabricio
    Potra, Cristina
    Toyoshima, Tim
    20 total names in list
  
   コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
LINQ とファイル ディレクトリ (C#)
   */
Union removes duplicate names:
Aw, Kam Foo
Bankov, Peter
Beebe, Ann
El Yassir, Mehdi
Garcia, Debra
Garcia, Hugo
Giakoumakis, Leo
Gilchrist, Beth
Guy, Wey Yuan
Holm, Michael
Liu, Jinghao
McLin, Nkenge
Myrcha, Jacek
Noriega, Fabricio
Potra, Cristina
Toyoshima, Tim
16 total names in list
Merge based on intersect:
Bankov, Peter
Holm, Michael
Garcia, Hugo
Beebe, Ann
4 total names in list
Concat based on partial name match "Garcia":
Garcia, Debra
Garcia, Hugo
Garcia, Hugo
3 total names in list
 
    この例では、さまざまなソースから一連の新しい型にデータをマージする方法を示します。
    NOTE
メモリ内データやファイル システム内のデータを、データベース内にあるデータに結合しようとしないでください。 このようなドメイン間結合を行う と、データベース クエリと他の種類のソースとで結合操作の定義方法に違いがあることが原因で、結果が未定義になる可能性があります。 また、データベース内に大量のデータが存在すると、こうした操作によってメモリ不足例外が発生するおそれがあります。 データベースのデータ をメモリ内データに結合するには、まずデータベース クエリで ToList または ToArray を呼び出してから、返されたコレクションで結合を 実行します。
   データ ファイルを作成するには
「異種ファイルのコンテンツを結合する方法 (LINQ) (C#)」の説明に従って、names.csv ファイルと scores.csv ファイルをプロジェ クト フォルダーにコピーします。
例
次の例は、2つのメモリ内文字列コレクションからマージされたデータを、名前付きの型 Student を使用して格納する方法を 示しています。各コレクションは、.csv 形式のスプレッドシート データをシミュレートしています。 1 つ目の文字列コレクションは学 生の名前と ID を表し、2 つ目のコレクションは学生 ID (最初の列) と 4 つの試験の点数を表しています。 外部キーとして ID が使用されます。
 複数のソースからオブジェクト コレクションに
データを設定する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
     using System;
using System.Collections.Generic;
using System.Linq;
class Student
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int ID { get; set; }
    public List<int> ExamScores { get; set; }
}
class PopulateCollection
{
    static void Main()
    {
        // These data files are defined in How to join content from
        // dissimilar files (LINQ).
        // Each line of names.csv consists of a last name, a first name, and an
        // ID number, separated by commas. For example, Omelchenko,Svetlana,111
        string[] names = System.IO.File.ReadAllLines(@"../../../names.csv");
        // Each line of scores.csv consists of an ID number and four test
        // scores, separated by commas. For example, 111, 97, 92, 81, 60
        string[] scores = System.IO.File.ReadAllLines(@"../../../scores.csv");
        // Merge the data sources using a named type.
        // var could be used instead of an explicit type. Note the dynamic

// var could be used instead of an explicit type. Note the dynamic
     select句では、オブジェクト初期化子を使用し、2つのソースのデータを使用して新しい Student オブジェクトそれぞれをインス タンス化しています。
クエリの結果を格納する必要がない場合は、名前付きの型よりも匿名型の方が便利です。 クエリが実行されたメソッドの外部 にクエリ結果を渡す場合は、名前付きの型が必要になります。 次の例では、前の例と同じタスクを実行しますが、名前付きの 型ではなく匿名型が使用します。
 } }
// creation of a list of ints for the ExamScores member. The first item
// is skipped in the split string because it is the student ID,
// not an exam score.
IEnumerable<Student> queryNamesScores =
    from nameLine in names
    let splitName = nameLine.Split(',')
    from scoreLine in scores
    let splitScoreLine = scoreLine.Split(',')
    where Convert.ToInt32(splitName[2]) == Convert.ToInt32(splitScoreLine[0])
    select new Student()
    {
        FirstName = splitName[0],
        LastName = splitName[1],
        ID = Convert.ToInt32(splitName[2]),
        ExamScores = (from scoreAsText in splitScoreLine.Skip(1)
                      select Convert.ToInt32(scoreAsText)).
                      ToList()
};
// Optional. Store the newly created student objects in memory
// for faster access in future queries. This could be useful with
// very large data files.
List<Student> students = queryNamesScores.ToList();
// Display each student's name and exam score average.
foreach (var student in students)
{
    Console.WriteLine("The average score of {0} {1} is {2}.",
        student.FirstName, student.LastName,
        student.ExamScores.Average());
}
//Keep console window open in debug mode
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    The average score of Omelchenko Svetlana is 82.5.
    The average score of O'Donnell Claire is 72.25.
    The average score of Mortensen Sven is 84.5.
    The average score of Garcia Cesar is 88.25.
    The average score of Garcia Debra is 67.
    The average score of Fakhouri Fadi is 92.25.
    The average score of Feng Hanying is 88.
    The average score of Garcia Hugo is 85.75.
    The average score of Tucker Lance is 81.75.
    The average score of Adams Terry is 85.25.
    The average score of Zabokritski Eugene is 83.
    The average score of Tucker Michael is 92.
*/

    関連項目
LINQ と文字列 (C#) オブジェクト初期化子とコレクション初期化子 匿名型
   // Merge the data sources by using an anonymous type.
// Note the dynamic creation of a list of ints for the
// ExamScores member. We skip 1 because the first string
// in the array is the student ID, not an exam score.
var queryNamesScores2 =
    from nameLine in names
    let splitName = nameLine.Split(',')
    from scoreLine in scores
    let splitScoreLine = scoreLine.Split(',')
    where Convert.ToInt32(splitName[2]) == Convert.ToInt32(splitScoreLine[0])
    select new
    {
        First = splitName[0],
        Last = splitName[1],
        ExamScores = (from scoreAsText in splitScoreLine.Skip(1)
                      select Convert.ToInt32(scoreAsText))
                      .ToList()
};
// Display each student's name and exam score average.
foreach (var student in queryNamesScores2)
{
    Console.WriteLine("The average score of {0} {1} is {2}.",
        student.First, student.Last, student.ExamScores.Average());
}
 
   この例では、2 つのファイルの内容をマージし、新しい方法でデータを整理する一連の新しいファイルを作成するための、1 つの 方法を示します。
データ ファイルを作成するには
1. 次の名前を names1.txt という名前のテキスト ファイルにコピーし、プロジェクト フォルダーに保存します。
    Bankov, Peter
Holm, Michael
Garcia, Hugo
Potra, Cristina
Noriega, Fabricio
Aw, Kam Foo
Beebe, Ann
Toyoshima, Tim
Guy, Wey Yuan
Garcia, Debra
 2. 次の名前を names2.txt という名前のテキスト ファイルにコピーし、プロジェクト フォルダーに保存します。2 つのファイルに は、共通の名前がいくつか含まれていることに注意してください。
    Liu, Jinghao
Bankov, Peter
Holm, Michael
Garcia, Hugo
Beebe, Ann
Gilchrist, Beth
Myrcha, Jacek
Giakoumakis, Leo
McLin, Nkenge
El Yassir, Mehdi
 例
グループを使用して 1 つのファイルを複数のファ
イルに分割する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
     class SplitWithGroups
{
    static void Main()
    {
        string[] fileA = System.IO.File.ReadAllLines(@"../../../names1.txt");
        string[] fileB = System.IO.File.ReadAllLines(@"../../../names2.txt");
        // Concatenate and remove duplicate names based on
        // default string comparer
        var mergeQuery = fileA.Union(fileB);
        // Group the names by the first letter in the last name.
        var groupQuery = from name in mergeQuery
                         let n = name.Split(',')
                         group name by n[0][0] into g
                         orderby g.Key
                         select g;

    このプログラムは、データ ファイルとしてグループごとに異なるファイルを同じフォルダーに書き込みます。 コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
 } }
// Create a new file for each group that was created
// Note that nested foreach loops are required to access
// individual items with each group.
foreach (var g in groupQuery)
{
    // Create the new file name.
    string fileName = @"../../../testFile_" + g.Key + ".txt";
    // Output to display.
    Console.WriteLine(g.Key);
    // Write file.
    using (System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName))
    {
        foreach (var item in g)
        {
            sw.WriteLine(item);
            // Output to console for example purposes.
            Console.WriteLine("   {0}", item);
} }
}
// Keep console window open in debug mode.
Console.WriteLine("Files have been written. Press any key to exit");
Console.ReadKey();
/* Output: A
Aw, Kam Foo B
       Bankov, Peter
Beebe, Ann E
       El Yassir, Mehdi
    G
       Garcia, Hugo
       Guy, Wey Yuan
       Garcia, Debra
       Gilchrist, Beth
       Giakoumakis, Leo
    H
       Holm, Michael
    L
       Liu, Jinghao
    M
       Myrcha, Jacek
       McLin, Nkenge
    N
       Noriega, Fabricio
    P
       Potra, Cristina
    T
       Toyoshima, Tim
*/

   LINQ と文字列 (C#)
LINQ とファイル ディレクトリ (C#)

   この例では、一致するキーとして共通の値を使用する 2 つのコンマ区切りファイルのデータを結合する方法を示します。 この方 法は、2 つのスプレッドシートのデータ、またはスプレッドシートのデータと別の形式のファイルのデータを、新しいファイルに結合す る必要がある場合に役立ちます。 この例は、変更を加えることで、あらゆる構造化テキスト ファイルに応用できます。
データ ファイルを作成するには
1. 次の行を scores.csv という名前のファイルにコピーし、プロジェクト フォルダーに保存します。 このファイルは、スプレッド
シートのデータを表しています。 列 1 は学生の ID、列 2 ~ 5 はテストの得点です。
    111, 97, 92, 81, 60
112, 75, 84, 91, 39
113, 88, 94, 65, 91
114, 97, 89, 85, 82
115, 35, 72, 91, 70
116, 99, 86, 90, 94
117, 93, 92, 80, 87
118, 92, 90, 83, 78
119, 68, 79, 88, 92
120, 99, 82, 81, 79
121, 96, 85, 91, 60
122, 94, 92, 91, 91
 2. 次の行を names.csv という名前のファイルにコピーし、プロジェクト フォルダーに保存します。 このファイルは、学生の姓、 名、および学生 ID が含まれるスプレッドシートを表しています。
    Omelchenko,Svetlana,111
O'Donnell,Claire,112
Mortensen,Sven,113
Garcia,Cesar,114
Garcia,Debra,115
Fakhouri,Fadi,116
Feng,Hanying,117
Garcia,Hugo,118
Tucker,Lance,119
Adams,Terry,120
Zabokritski,Eugene,121
Tucker,Michael,122
 例
異種ファイルのコンテンツを結合する方法
(LINQ) (C#)
2020/11/02 • • Edit Online
     using System;
using System.Collections.Generic;
using System.Linq;
class JoinStrings
{
    static void Main()
    {
        // Join content from dissimilar files that contain
        // related information. File names.csv contains the student

      関連項目
LINQ と文字列 (C#)
LINQ とファイル ディレクトリ (C#)
         // name plus an ID number. File scores.csv contains the ID
        // and a set of four test scores. The following query joins
        // the scores to the student names by using ID as a
        // matching key.
        string[] names = System.IO.File.ReadAllLines(@"../../../names.csv");
        string[] scores = System.IO.File.ReadAllLines(@"../../../scores.csv");
        // Name:    Last[0],       First[1],  ID[2]
        //          Omelchenko,    Svetlana,  11
        // Score:   StudentID[0],  Exam1[1]   Exam2[2],  Exam3[3],  Exam4[4]
        //          111,           97,        92,        81,        60
        // This query joins two dissimilar spreadsheets based on common ID value.
        // Multiple from clauses are used instead of a join clause
        // in order to store results of id.Split.
        IEnumerable<string> scoreQuery1 =
            from name in names
            let nameFields = name.Split(',')
            from id in scores
            let scoreFields = id.Split(',')
            where Convert.ToInt32(nameFields[2]) == Convert.ToInt32(scoreFields[0])
            select nameFields[0] + "," + scoreFields[1] + "," + scoreFields[2]
                   + "," + scoreFields[3] + "," + scoreFields[4];
        // Pass a query variable to a method and execute it
        // in the method. The query itself is unchanged.
        OutputQueryResults(scoreQuery1, "Merge two spreadsheets:");
        // Keep console window open in debug mode.
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    static void OutputQueryResults(IEnumerable<string> query, string message)
    {
        Console.WriteLine(System.Environment.NewLine + message);
        foreach (string item in query)
        {
            Console.WriteLine(item);
        }
        Console.WriteLine("{0} total names in list", query.Count());
    }
}
/* Output:
Merge two spreadsheets:
Omelchenko, 97, 92, 81, 60
O'Donnell, 75, 84, 91, 39
Mortensen, 88, 94, 65, 91
Garcia, 97, 89, 85, 82
Garcia, 35, 72, 91, 70
Fakhouri, 99, 86, 90, 94
Feng, 93, 92, 80, 87
Garcia, 92, 90, 83, 78
Tucker, 68, 79, 88, 92
Adams, 99, 82, 81, 79
Zabokritski, 96, 85, 91, 60
Tucker, 94, 92, 91, 91
12 total names in list
*/

   この例では、合計、平均、最小、最大などの集計計算を .csv ファイルの列に対して実行する方法について説明します。 ここ で説明する例の原則は、他の種類の構造化テキストにも適用できます。
ソース ファイルを作成するには
1. 次の行を scores.csv という名前のファイルにコピーし、プロジェクト フォルダーに保存します。 最初の列は学生 ID、それ
に続く列は 4 つの試験の点数を表していると仮定します。
    111, 97, 92, 81, 60
112, 75, 84, 91, 39
113, 88, 94, 65, 91
114, 97, 89, 85, 82
115, 35, 72, 91, 70
116, 99, 86, 90, 94
117, 93, 92, 80, 87
118, 92, 90, 83, 78
119, 68, 79, 88, 92
120, 99, 82, 81, 79
121, 96, 85, 91, 60
122, 94, 92, 91, 91
 例
CSV テキスト ファイルの列値を計算する方法
(LINQ) (C#)
2020/11/02 • • Edit Online
     class SumColumns
{
    static void Main(string[] args)
    {
        string[] lines = System.IO.File.ReadAllLines(@"../../../scores.csv");
        // Specifies the column to compute.
        int exam = 3;
        // Spreadsheet format:
        // Student ID    Exam#1  Exam#2  Exam#3  Exam#4
        // 111,          97,     92,     81,     60
        // Add one to exam to skip over the first column,
        // which holds the student ID.
        SingleColumn(lines, exam + 1);
        Console.WriteLine();
        MultiColumns(lines);
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
    }
    static void SingleColumn(IEnumerable<string> strs, int examNum)
    {
        Console.WriteLine("Single Column Query:");
        // Parameter examNum specifies the column to
        // run the calculations on. This value could be
// passed in dynamically at runtime.

 // passed in dynamically at runtime.
     // Variable columnQuery is an IEnumerable<int>.
    // The following query performs two steps:
    // 1) use Split to break each row (a string) into an array
    //    of strings,
    // 2) convert the element at position examNum to an int
    //    and select it.
    var columnQuery =
        from line in strs
        let elements = line.Split(',')
        select Convert.ToInt32(elements[examNum]);
    // Execute the query and cache the results to improve
    // performance. This is helpful only with very large files.
    var results = columnQuery.ToList();
    // Perform aggregate calculations Average, Max, and
    // Min on the column specified by examNum.
    double average = results.Average();
    int max = results.Max();
    int min = results.Min();
    Console.WriteLine("Exam #{0}: Average:{1:##.##} High Score:{2} Low Score:{3}",
             examNum, average, max, min);
}
static void MultiColumns(IEnumerable<string> strs)
{
    Console.WriteLine("Multi Column Query:");
    // Create a query, multiColQuery. Explicit typing is used
    // to make clear that, when executed, multiColQuery produces
    // nested sequences. However, you get the same results by
    // using 'var'.
    // The multiColQuery query performs the following steps:
    // 1) use Split to break each row (a string) into an array
    //    of strings,
    // 2) use Skip to skip the "Student ID" column, and store the
    //    rest of the row in scores.
    // 3) convert each score in the current row from a string to
    //    an int, and select that entire sequence as one row
    //    in the results.
    IEnumerable<IEnumerable<int>> multiColQuery =
        from line in strs
        let elements = line.Split(',')
        let scores = elements.Skip(1)
        select (from str in scores
                select Convert.ToInt32(str));
    // Execute the query and cache the results to improve
    // performance.
    // ToArray could be used instead of ToList.
    var results = multiColQuery.ToList();
    // Find out how many columns you have in results.
    int columnCount = results[0].Count();
    // Perform aggregate calculations Average, Max, and
    // Min on each column.
    // Perform one iteration of the loop for each column
    // of scores.
    // You can use a for loop instead of a foreach loop
    // because you already executed the multiColQuery
    // query by calling ToList.
    for (int column = 0; column < columnCount; column++)
    {
var results2 = from row in results
  select row.ElementAt(column);

   このクエリでは、Split メソッドを使用してテキストの各行が配列に変換されます。 各配列要素が列を表します。 最終的に、各 列のテキストが数値表記に変換されます。 ファイルがタブ区切りファイルの場合、 Split メソッドの引数を \t に変更します。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ と文字列 (C#)
LINQ とファイル ディレクトリ (C#)
   } }
}
/* Output:
               select row.ElementAt(column);
double average = results2.Average();
int max = results2.Max();
int min = results2.Min();
// Add one to column because the first exam is Exam #1,
// not Exam #0.
Console.WriteLine("Exam #{0} Average: {1:##.##} High Score: {2} Low Score: {3}",
              column + 1, average, max, min);
   Single Column Query:
   Exam #4: Average:76.92 High Score:94 Low Score:39
   Multi Column Query:
   Exam #1 Average: 86.08 High Score: 99 Low Score: 35
   Exam #2 Average: 86.42 High Score: 94 Low Score: 72
   Exam #3 Average: 84.75 High Score: 91 Low Score: 65
   Exam #4 Average: 76.92 High Score: 94 Low Score: 39
*/
 
         .NET のリフレクション API を使用すると、.NET アセンブリ内のメタデータを調べ、そのアセンブリ内にある型、型メンバー、パラメー ターなどのコレクションを作成できます。 これらのコレクションは、ジェネリック IEnumerable<T> インターフェイスをサポートするた め、LINQ を使用して照会できます。
次の例では、LINQ でリフレクションを使用して、指定した検索条件に一致するメソッドについてのメタデータを取得する方法を 示します。 この例のクエリでは、配列などの列挙可能な型を返すすべてのメソッドの名前をアセンブリ内で検索します。
例
    using System;
using System.Linq;
using System.Reflection;
class ReflectionHowTO
{
    static void Main()
    {
        Assembly assembly = Assembly.Load("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=
b77a5c561934e089");
        var pubTypesQuery = from type in assembly.GetTypes()
                    where type.IsPublic
                        from method in type.GetMethods()
                        where method.ReturnType.IsArray == true
                            || ( method.ReturnType.GetInterface(
                                typeof(System.Collections.Generic.IEnumerable<>).FullName ) != null
                            && method.ReturnType.FullName != "System.String" )
                        group method.ToString() by type.ToString();
        foreach (var groupOfMethods in pubTypesQuery)
        {
            Console.WriteLine("Type: {0}", groupOfMethods.Key);
            foreach (var method in groupOfMethods)
            {
                Console.WriteLine("  {0}", method);
            }
}
        Console.WriteLine("Press any key to exit... ");
        Console.ReadKey();
    }
}
 この例では、Assembly.GetTypes メソッドを使用して、指定したアセンブリ内の型の配列を返します。 パブリック型のみが返され るように、where フィルターが適用されています。 パブリック型ごとに、Type.GetMethods 呼び出しから返される MethodInfo 配列を使用してサブクエリが生成されます。 これらの結果はフィルター処理され、戻り値の型が配列か、IEnumerable<T> を 実装する型であるメソッドのみが返されます。 最後に、型名をキーとして使用して、これらの結果がグループ化されます。
関連項目
LINQ to Objects (C#)
リフレクションを使用してアセンブリのメタデー
タにクエリを実行する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
         .NET のリフレクション API を使用すると、.NET アセンブリ内のメタデータを調べ、そのアセンブリ内にある型、型メンバー、パラメー ターなどのコレクションを作成できます。 これらのコレクションは、ジェネリック IEnumerable<T> インターフェイスをサポートするた め、LINQ を使用して照会できます。
次の例では、LINQ でリフレクションを使用して、指定した検索条件に一致するメソッドについてのメタデータを取得する方法を 示します。 この例のクエリでは、配列などの列挙可能な型を返すすべてのメソッドの名前をアセンブリ内で検索します。
例
    using System;
using System.Linq;
using System.Reflection;
class ReflectionHowTO
{
    static void Main()
    {
        Assembly assembly = Assembly.Load("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=
b77a5c561934e089");
        var pubTypesQuery = from type in assembly.GetTypes()
                    where type.IsPublic
                        from method in type.GetMethods()
                        where method.ReturnType.IsArray == true
                            || ( method.ReturnType.GetInterface(
                                typeof(System.Collections.Generic.IEnumerable<>).FullName ) != null
                            && method.ReturnType.FullName != "System.String" )
                        group method.ToString() by type.ToString();
        foreach (var groupOfMethods in pubTypesQuery)
        {
            Console.WriteLine("Type: {0}", groupOfMethods.Key);
            foreach (var method in groupOfMethods)
            {
                Console.WriteLine("  {0}", method);
            }
}
        Console.WriteLine("Press any key to exit... ");
        Console.ReadKey();
    }
}
 この例では、Assembly.GetTypes メソッドを使用して、指定したアセンブリ内の型の配列を返します。 パブリック型のみが返され るように、where フィルターが適用されています。 パブリック型ごとに、Type.GetMethods 呼び出しから返される MethodInfo 配列を使用してサブクエリが生成されます。 これらの結果はフィルター処理され、戻り値の型が配列か、IEnumerable<T> を 実装する型であるメソッドのみが返されます。 最後に、型名をキーとして使用して、これらの結果がグループ化されます。
関連項目
LINQ to Objects (C#)
リフレクションを使用してアセンブリのメタデー
タにクエリを実行する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
                   多くのファイル システム操作は基本的にクエリであるため、LINQ での使用に最適です。
ここで示すクエリは破壊的ではありません。 元のファイルやフォルダーの内容が変更されることはありません。 これは、クエリは副 作用を引き起こすべきではないという規則に従っています。 一般に、参照元データを変更するコード (create、update、または delete の各演算子を実行するクエリなど) は、単にデータを照会するだけのコードとは分離する必要があります。
このセクションでは、以下のトピックについて説明します。
指定された属性または名前のファイルを照会する方法 (C#)
FileInfo オブジェクトで 1 つ以上のプロパティを調べ、ファイルを検索する方法を示します。
拡張子別にファイルをグループ化する方法 (LINQ) (C#) ファイル名拡張子に基づいて、FileInfo オブジェクトのグループを返す方法を示します。
一連のフォルダーの合計バイト数を照会する方法 (LINQ) (C#)
指定したディレクトリ ツリー内のすべてのファイルの合計バイト数を返す方法を示します。
2 つのフォルダーの内容を比較する方法 (LINQ) (C#)
指定した 2 つのフォルダーに存在するファイルをすべて返す方法と、一方のフォルダーにのみ存在し、もう一方には存在しない ファイルをすべて返す方法を示します。
ディレクトリ ツリー内で最もサイズの大きいファイルを照会する方法 (LINQ) (C#)
ディレクトリ ツリーで、最もサイズの大きいファイルまたは最もサイズの小さいファイル、あるいは指定した数のファイルを返す方法を 示します。
ディレクトリ ツリーで重複するファイルを照会する方法 (LINQ) (C#)
指定したディレクトリ ツリーの複数の場所に出現するすべてのファイル名をグループ化する方法を示します。 また、カスタム比較 演算子に基づいて、より複雑な比較を実行する方法も示します。
フォルダー内のファイルの内容にクエリを実行する方法 (LINQ) (C#) ツリー内のフォルダーを反復処理し、各ファイルを開き、ファイルの内容を照会する方法を示します。
コメント
ファイル システムの内容を正確に表し、例外を適切に処理するデータ ソースを作成する手順は複雑になります。 ここに示す例 では、指定したルート フォルダーおよびすべてのサブフォルダーの下にある、すべてのファイルを表す FileInfo オブジェクトのスナッ プショット コレクションを作成します。 各 FileInfo の実際の状態は、クエリの実行の開始時点から終了時点までの間に変化す る可能性があります。 たとえば、データ ソースとして使用する FileInfo オブジェクトの一覧を作成したとします。 クエリで
Length プロパティにアクセスしようとすると、FileInfoオブジェクトがファイルシステムにアクセスして Length の値を更新しようと します。 ファイルがもう存在しない場合は、ファイル システムを直接照会していなくても、クエリから FileNotFoundException が 返されます。 ここで示すクエリの中には、状況により、このような特定の例外を処理する個別のメソッドを使用しているものがあり ます。 別の方法として、FileSystemWatcher を使用して、データ ソースを動的に更新して常に最新の状態に保つこともできま す。
関連項目
LINQ to Objects (C#)
  LINQ とファイル ディレクトリ (C#) 2020/11/02 • • Edit Online
 
   この例では、指定されたディレクトリ ツリーで、指定されたファイル名拡張子 (".txt" など) を持つすべてのファイルを検索する方法 を示します。 また、ファイルの作成日時に基づいて、ツリー内の最も新しいファイルまたは最も古いファイルを返す方法も示しま す。
例
    class FindFileByExtension
{
    // This query will produce the full path for all .txt files
    // under the specified folder including subfolders.
    // It orders the list according to the file name.
    static void Main()
    {
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\";
        // Take a snapshot of the file system.
        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);
        // This method assumes that the application has discovery permissions
        // for all folders under the specified path.
        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
} }
//Create the query
IEnumerable<System.IO.FileInfo> fileQuery =
    from file in fileList
    where file.Extension == ".txt"
    orderby file.Name
    select file;
//Execute the query. This might write out a lot of files!
foreach (System.IO.FileInfo fi in fileQuery)
{
    Console.WriteLine(fi.FullName);
}
// Create and execute a new query by using the previous
// query as a starting point. fileQuery is not
// executed again until the call to Last()
var newestFile =
    (from file in fileQuery
     orderby file.CreationTime
     select new { file.FullName, file.CreationTime })
.Last();
Console.WriteLine("\r\nThe newest .txt file is {0}. Creation time: {1}",
    newestFile.FullName, newestFile.CreationTime);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit");
Console.ReadKey();
 指定された属性または名前のファイルを照会する
方法 (C#) 2020/11/02 • • Edit Online
 
   コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ to Objects (C#)
LINQ とファイル ディレクトリ (C#)

   この例では、LINQ を使用して、ファイルまたはフォルダーの一覧に対して、高度なグループ化および並べ替えを実行する方法を 示します。 また、Skip メソッドと Take メソッドを使用して、出力をページごとにコンソール ウィンドウに表示する方法も示します。
例
次のクエリは、指定されたディレクトリ ツリーの内容を、ファイル名の拡張子別にグループ化する方法を示しています。
   拡張子別にファイルをグループ化する方法
(LINQ) (C#)
2020/11/02 • • Edit Online
  class GroupByExtension
{
    // This query will sort all the files under the specified folder
    //  and subfolder into groups keyed by the file extension.
    private static void Main()
    {
        // Take a snapshot of the file system.
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\Common7";
        // Used in WriteLine to trim output lines.
        int trimLength = startFolder.Length;
        // Take a snapshot of the file system.
        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);
        // This method assumes that the application has discovery permissions
        // for all folders under the specified path.
        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
        // Create the query.
        var queryGroupByExt =
            from file in fileList
            group file by file.Extension.ToLower() into fileGroup
            orderby fileGroup.Key
            select fileGroup;
        // Display one group at a time. If the number of
        // entries is greater than the number of lines
        // in the console window, then page the output.
        PageOutput(trimLength, queryGroupByExt);
}
    // This method specifically handles group queries of FileInfo objects with string keys.
    // It can be modified to work for any long listings of data. Note that explicit typing
    // must be used in method signatures. The groupbyExtList parameter is a query that produces
    // groups of FileInfo objects with string keys.
    private static void PageOutput(int rootLength,
                                    IEnumerable<System.Linq.IGrouping<string, System.IO.FileInfo>>
groupByExtList)
    {
        // Flag to break out of paging loop.
        bool goAgain = true;
        // "3" = 1 line for extension + 1 for "Press any key" + 1 for input cursor.
        int numLines = Console.WindowHeight - 3;
// Iterate through the outer collection of groups.
foreach (var filegroup in groupByExtList)

    このプログラムの出力は、ローカルファイルシステムの詳細と startFolder の設定内容に応じて長くなる可能性があります。 すべての結果を確認できるように、次の例では、結果をページごとに出力する方法を示します。 同じ手法を Windows アプリ ケーションや Web アプリケーションに適用できます。 このコードでは、グループ内の項目をページごとに処理するため、 foreach ループを入れ子にする必要があります。 また、一覧内での現在位置を計算し、ユーザーがページングを停止してプログラムを終 了できるようにするロジックも追加されています。 この場合、ページング クエリは、元のクエリからキャッシュされた結果に対して実 行されます。 LINQ to SQL などの他のコンテキストでは、このようなキャッシュは必要ありません。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ to Objects (C#)
LINQ とファイル ディレクトリ (C#)
    } }
}
foreach (var filegroup in groupByExtList)
{
// Start a new extension at the top of a page.
int currentLine = 0;
// Output only as many lines of the current group as will fit in the window.
do
{
    Console.Clear();
    Console.WriteLine(filegroup.Key == String.Empty ? "[none]" : filegroup.Key);
    // Get 'numLines' number of items starting at number 'currentLine'.
    var resultPage = filegroup.Skip(currentLine).Take(numLines);
    //Execute the resultPage query
    foreach (var f in resultPage)
    {
        Console.WriteLine("\t{0}", f.FullName.Substring(rootLength));
    }
    // Increment the line counter.
    currentLine += numLines;
    // Give the user a chance to escape.
    Console.WriteLine("Press any key to continue or the 'End' key to break...");
    ConsoleKey key = Console.ReadKey().Key;
    if (key == ConsoleKey.End)
    {
        goAgain = false;
break; }
} while (currentLine < filegroup.Count());
if (goAgain == false)
    break;
 
   この例では、指定したフォルダーとそのすべてのサブフォルダーに格納されている全ファイルの合計バイト数を取得する方法につ いて説明します。
例
Sumは、select 句で選択されたすべての項目の値を加算するメソッドです。このクエリに少し変更を加え、Sumの代わりに Min メソッドまたは Max メソッドを呼び出せば、指定したディレクトリ ツリーの最大ファイルまたは最小ファイルを取得することがで きます。
 一連のフォルダーの合計バイト数を照会する方法
(LINQ) (C#)
2020/11/02 • • Edit Online
 
       指定したディレクトリ ツリー内のバイト数をカウントするだけならば、LINQ クエリを作成せずに行う方が効率的です。LINQ クエリ では、データ ソースとしてリスト コレクションを作成する際のオーバーヘッドが発生します。 LINQ を使ったアプローチは、クエリが 複雑化するか、同じデータ ソースに対して複数のクエリを実行する必要があるときに利便性が増します。
このクエリは、ファイルの長さを取得するために別のメソッドを呼び出しています。 その理由は、 GetFiles の呼び出しで FileInfo オブジェクトが作成された後に別のスレッドでファイルが削除された場合に発生する可能性のある例外を処理するため です。 FileInfo オブジェクトの作成後であっても、例外は発生する可能性があります。FileInfo オブジェクトは、Length プロパ ティが最初にアクセスされたときに最新の長さに基づいてそのプロパティを更新しようと試みるためです。 この操作をクエリの外側 の try-catch ブロックに置くことで、"副作用の原因となりうるような操作はクエリ内では行わない" という原則に従っているので す。 一般に、アプリケーションが不明な状態に陥ることのないよう、例外を処理する際には十分な注意が必要です。
   class QuerySize
{
    public static void Main()
    {
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\VC#";
        // Take a snapshot of the file system.
        // This method assumes that the application has discovery permissions
        // for all folders under the specified path.
        IEnumerable<string> fileList = System.IO.Directory.GetFiles(startFolder, "*.*",
System.IO.SearchOption.AllDirectories);
        var fileQuery = from file in fileList
                        select GetFileLength(file);
        // Cache the results to avoid multiple trips to the file system.
        long[] fileLengths = fileQuery.ToArray();
        // Return the size of the largest file
        long largestFile = fileLengths.Max();
        // Return the total number of bytes in all the files under the specified folder.
        long totalBytes = fileLengths.Sum();
        Console.WriteLine("There are {0} bytes in {1} files under {2}",
            totalBytes, fileList.Count(), startFolder);
        Console.WriteLine("The largest files is {0} bytes.", largestFile);
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
}
    // This method is used to swallow the possible exception
    // that can be raised when accessing the System.IO.FileInfo.Length property.
    static long GetFileLength(string filename)
    {
        long retval;
        try
        {
            System.IO.FileInfo fi = new System.IO.FileInfo(filename);
            retval = fi.Length;
        }
        catch (System.IO.FileNotFoundException)
        {
            // If a file is no longer present,
            // just add zero bytes to the total.
            retval = 0;
}
        return retval;
    }
}

   コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ to Objects (C#)
LINQ とファイル ディレクトリ (C#)

   この例では、2 つのファイル リストを比較する 3 つの方法を示します。
2 つのファイル リストが同一であるかどうかを指定するブール値をクエリする方法 両方のフォルダー内にあるファイルを取得するために、共通部分をクエリする方法
1 つのフォルダーにあり、もう 1 つのフォルダーにはないファイルを取得するために、差集合をクエリする方法
ここに示す FileComparer クラスは、標準クエリ演算子と共に、カスタム比較演算子クラスを使用する方法を示します。このク ラスは、実際のシナリオで使用することは想定されていません。 各フォルダーの内容が同一であるかどうかを判断するために、各 ファイルの名前と長さ (バイト) を使用するだけです。 実際のシナリオでは、この比較演算子を変更して、より厳密に等しいかど うかをチェックします。
例
    NOTE
ここに示す方法は、任意の型のオブジェクトのシーケンスを比較するために適用させることができます。
     2 つのフォルダーの内容を比較する方法 (LINQ)
(C#)
2020/11/02 • • Edit Online
  namespace QueryCompareTwoDirs
{
    class CompareDirs
    {
        static void Main(string[] args)
        {
            // Create two identical or different temporary folders
            // on a local drive and change these file paths.
            string pathA = @"C:\TestDir";
            string pathB = @"C:\TestDir2";
            System.IO.DirectoryInfo dir1 = new System.IO.DirectoryInfo(pathA);
            System.IO.DirectoryInfo dir2 = new System.IO.DirectoryInfo(pathB);
            // Take a snapshot of the file system.
            IEnumerable<System.IO.FileInfo> list1 = dir1.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
            IEnumerable<System.IO.FileInfo> list2 = dir2.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
            //A custom file comparer defined below
            FileCompare myFileCompare = new FileCompare();
            // This query determines whether the two folders contain
            // identical file lists, based on the custom file comparer
            // that is defined in the FileCompare class.
            // The query executes immediately because it returns a bool.
            bool areIdentical = list1.SequenceEqual(list2, myFileCompare);
            if (areIdentical == true)
            {
Console.WriteLine("the two folders are the same");

Console.WriteLine("the two folders are the same");
 } }
} }
} else {
    Console.WriteLine("The two folders are not the same");
}
// Find the common files. It produces a sequence and doesn't
// execute until the foreach statement.
var queryCommonFiles = list1.Intersect(list2, myFileCompare);
if (queryCommonFiles.Any())
{
    Console.WriteLine("The following files are in both folders:");
    foreach (var v in queryCommonFiles)
    {
        Console.WriteLine(v.FullName); //shows which items end up in result list
    }
} else {
    Console.WriteLine("There are no common files in the two folders.");
}
// Find the set difference between the two folders.
// For this example we only check one way.
var queryList1Only = (from file in list1
                      select file).Except(list2, myFileCompare);
Console.WriteLine("The following files are in list1 but not list2:");
foreach (var v in queryList1Only)
{
    Console.WriteLine(v.FullName);
}
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
// This implementation defines a very simple comparison
// between two FileInfo objects. It only compares the name
// of the files being compared and their length in bytes.
class FileCompare : System.Collections.Generic.IEqualityComparer<System.IO.FileInfo>
{
    public FileCompare() { }
    public bool Equals(System.IO.FileInfo f1, System.IO.FileInfo f2)
    {
        return (f1.Name == f2.Name &&
                f1.Length == f2.Length);
}
    // Return a hash that reflects the comparison criteria. According to the
    // rules for IEqualityComparer<T>, if Equals is true, then the hash codes must
    // also be equal. Because equality as defined here is a simple value equality, not
    // reference identity, it is possible that two or more objects will produce the same
    // hash code.
    public int GetHashCode(System.IO.FileInfo fi)
    {
        string s = $"{fi.Name}{fi.Length}";
        return s.GetHashCode();
    }
    
   コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ to Objects (C#)
LINQ とファイル ディレクトリ (C#)

     この例では、ファイル サイズ (バイト単位) に関連した 5 つのクエリを紹介しています。
最もサイズ (バイト単位) の大きいファイルを取得する方法。
最もサイズ (バイト単位) の小さいファイルを取得する方法。
指定したルート フォルダー配下のフォルダーから FileInfo オブジェクトの最大ファイルまたは最小ファイルを取得する方 法。
サイズが上位 10 番目までのファイルなど、一定の条件に該当するファイルを取得する方法。 指定サイズ未満のファイルを無視しながらバイト単位のサイズに基づいてファイルをグループ化する方法。
例
以下のコードでは 5 つのクエリを使用して、バイト単位のサイズに基づいてファイルを照会し、グループ化しています。 サンプル コードを参考にして、FileInfo オブジェクトが備えている他のさまざまなプロパティを簡単に照会することができます。
   ディレクトリ ツリー内で最もサイズの大きい
ファイルを照会する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
  class QueryBySize
{
    static void Main(string[] args)
    {
        QueryFilesBySize();
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    private static void QueryFilesBySize()
    {
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\";
        // Take a snapshot of the file system.
        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);
        // This method assumes that the application has discovery permissions
        // for all folders under the specified path.
        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
        //Return the size of the largest file
        long maxSize =
            (from file in fileList
             let len = GetFileLength(file)
             select len)
             .Max();
        Console.WriteLine("The length of the largest file under {0} is {1}",
            startFolder, maxSize);
        // Return the FileInfo object for the largest file
        // by sorting and selecting from beginning of list
        System.IO.FileInfo longestFile =
            (from file in fileList
             let len = GetFileLength(file)
             where len > 0

  } }
     orderby len descending
     select file)
    .First();
Console.WriteLine("The largest file under {0} is {1} with a length of {2} bytes",
                    startFolder, longestFile.FullName, longestFile.Length);
//Return the FileInfo of the smallest file
System.IO.FileInfo smallestFile =
    (from file in fileList
     let len = GetFileLength(file)
     where len > 0
     orderby len ascending
     select file).First();
Console.WriteLine("The smallest file under {0} is {1} with a length of {2} bytes",
                    startFolder, smallestFile.FullName, smallestFile.Length);
//Return the FileInfos for the 10 largest files
// queryTenLargest is an IEnumerable<System.IO.FileInfo>
var queryTenLargest =
    (from file in fileList
     let len = GetFileLength(file)
     orderby len descending
     select file).Take(10);
Console.WriteLine("The 10 largest files under {0} are:", startFolder);
foreach (var v in queryTenLargest)
{
    Console.WriteLine("{0}: {1} bytes", v.FullName, v.Length);
}
// Group the files according to their size, leaving out
// files that are less than 200000 bytes.
var querySizeGroups =
    from file in fileList
    let len = GetFileLength(file)
    where len > 0
    group file by (len / 100000) into fileGroup
    where fileGroup.Key >= 2
    orderby fileGroup.Key descending
    select fileGroup;
foreach (var filegroup in querySizeGroups)
{
Console.WriteLine(filegroup.Key.ToString() + "00000");
foreach (var item in filegroup)
{
    Console.WriteLine("\t{0}: {1}", item.Name, item.Length);
}
// This method is used to swallow the possible exception
// that can be raised when accessing the FileInfo.Length property.
// In this particular case, it is safe to swallow the exception.
static long GetFileLength(System.IO.FileInfo fi)
{
    long retval;
    try
    {
        retval = fi.Length;
    }
    catch (System.IO.FileNotFoundException)
    {
        // If a file is no longer present,
        // just add zero bytes to the total.
        retval = 0;
  
      retval = 0;
 このクエリは、完全な FileInfo オブジェクトを返すために、まずデータ ソース内の各ファイルを調べ、それらのファイルを Length プ ロパティの値で並べ替えています。 そうすることで、長さが最大である単一のファイルまたは一連のファイルを取得することができ ます。 リスト内の最初の要素は、First を使用して取得します。 先頭から n 件の要素を取得するには、Take を使用します。 並べ替え順序に Descending を指定することによって、最小の要素がリストの先頭に来るようにしています。
このクエリでは、GetFiles の呼び出しでFileInfoオブジェクトが作成された後に別のスレッドでファイルが削除された場合に発 生する例外の可能性に対処するために、別途設けられたメソッドを呼び出してファイル サイズ (バイト単位) を取得しています。 FileInfo オブジェクトの作成後であっても、例外は発生する可能性があります。FileInfo オブジェクトは、Length プロパティが最 初にアクセスされたときに最新のサイズ (バイト単位) に基づいてそのプロパティを更新しようと試みるためです。 この操作をクエリ の外側の try-catch ブロックに置くことで、"副作用の原因となりうるような操作はクエリ内では行わない" という原則に従っている のです。 一般に、アプリケーションが不明な状態に陥ることのないよう、例外を処理する際には十分な注意が必要です。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ to Objects (C#)
LINQ とファイル ディレクトリ (C#)
    }
        return retval;
    }
}
 
   同じ名前のファイルが複数のフォルダーに存在することがあります。 たとえば、Visual Studio インストール フォルダーでは、複数 のフォルダーに readme.htm ファイルが含まれています。 次の例は、指定したルート フォルダーの下で、このような重複したファイ ル名をクエリする方法を示しています。 また、2 番目の例では、名前のほかにサイズと LastWrite 時刻が一致するファイルをク エリする方法を示します。
例
   ディレクトリ ツリーで重複するファイルを照会
する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
  class QueryDuplicateFileNames
{
    static void Main(string[] args)
    {
        // Uncomment QueryDuplicates2 to run that query.
        QueryDuplicates();
        // QueryDuplicates2();
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
}
    static void QueryDuplicates()
    {
        // Change the root drive or folder if necessary
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\";
        // Take a snapshot of the file system.
        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);
        // This method assumes that the application has discovery permissions
        // for all folders under the specified path.
        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
        // used in WriteLine to keep the lines shorter
        int charsToSkip = startFolder.Length;
        // var can be used for convenience with groups.
        var queryDupNames =
            from file in fileList
            group file.FullName.Substring(charsToSkip) by file.Name into fileGroup
            where fileGroup.Count() > 1
            select fileGroup;
        // Pass the query to a method that will
        // output one page at a time.
        PageOutput<string, string>(queryDupNames);
}
    // A Group key that can be passed to a separate method.
    // Override Equals and GetHashCode to define equality for the key.
    // Override ToString to provide a friendly name for Key.ToString()
    class PortableKey
    {
        public string Name { get; set; }
        public DateTime LastWriteTime { get; set; }

  public long Length { get; set; }
        public override bool Equals(object obj)
        {
            PortableKey other = (PortableKey)obj;
            return other.LastWriteTime == this.LastWriteTime &&
                   other.Length == this.Length &&
                   other.Name == this.Name;
}
        public override int GetHashCode()
        {
            string str = $"{this.LastWriteTime}{this.Length}{this.Name}";
            return str.GetHashCode();
        }
        public override string ToString()
        {
            return $"{this.Name} {this.Length} {this.LastWriteTime}";
        }
    }
    static void QueryDuplicates2()
    {
        // Change the root drive or folder if necessary.
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\Common7";
        // Make the lines shorter for the console display
        int charsToSkip = startFolder.Length;
        // Take a snapshot of the file system.
        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);
        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
        // Note the use of a compound key. Files that match
        // all three properties belong to the same group.
        // A named type is used to enable the query to be
        // passed to another method. Anonymous types can also be used
        // for composite keys but cannot be passed across method boundaries
        //
        var queryDupFiles =
            from file in fileList
            group file.FullName.Substring(charsToSkip) by
                new PortableKey { Name = file.Name, LastWriteTime = file.LastWriteTime, Length = file.Length
} into fileGroup
            where fileGroup.Count() > 1
            select fileGroup;
        var list = queryDupFiles.ToList();
        int i = queryDupFiles.Count();
        PageOutput<PortableKey, string>(queryDupFiles);
    }
    // A generic method to page the output of the QueryDuplications methods
    // Here the type of the group must be specified explicitly. "var" cannot
    // be used in method signatures. This method does not display more than one
    // group per page.
    private static void PageOutput<K, V>(IEnumerable<System.Linq.IGrouping<K, V>> groupByExtList)
    {
        // Flag to break out of paging loop.
        bool goAgain = true;
        // "3" = 1 line for extension + 1 for "Press any key" + 1 for input cursor.
        int numLines = Console.WindowHeight - 3;
        // Iterate through the outer collection of groups.
        foreach (var filegroup in groupByExtList)
        {
  
   {
 最初のクエリでは、単純なキーを使用して一致を判断します。これにより、同じ名前を持つファイルが検索されますが、この場 合、各ファイルの内容が一致するとは限りません。 2 番目のクエリでは、複合キーを使用して、FileInfo オブジェクトの 3 つのプ ロパティと照合します。 このクエリでは、名前が同じで、内容も類似または一致するファイルが検索される可能性が高くなりま す。
コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ to Objects (C#)
LINQ とファイル ディレクトリ (C#)
               // Start a new extension at the top of a page.
            int currentLine = 0;
            // Output only as many lines of the current group as will fit in the window.
            do
            {
                Console.Clear();
                Console.WriteLine("Filename = {0}", filegroup.Key.ToString() == String.Empty ? "[none]" :
filegroup.Key.ToString());
} }
}
    // Get 'numLines' number of items starting at number 'currentLine'.
    var resultPage = filegroup.Skip(currentLine).Take(numLines);
    //Execute the resultPage query
    foreach (var fileName in resultPage)
    {
        Console.WriteLine("\t{0}", fileName);
    }
    // Increment the line counter.
    currentLine += numLines;
    // Give the user a chance to escape.
    Console.WriteLine("Press any key to continue or the 'End' key to break...");
    ConsoleKey key = Console.ReadKey().Key;
    if (key == ConsoleKey.End)
    {
        goAgain = false;
break; }
} while (currentLine < filegroup.Count());
if (goAgain == false)
    break;
 
    この例では、指定したディレクトリ ツリーに含まれるすべてのファイルを照会し、個々のファイルを開いて、その内容を調べていま す。 同様の手法を使えば、ディレクトリ ツリーの内容に対するインデックスや逆インデックスを作成することもできます。 この例で 行っているのは単純な文字列検索です。 しかし正規表現を使うと、もっと複雑なパターン マッチングを行うことができます。 詳 細については、「LINQ クエリと正規表現を組み合わせる方法 (C#)」を参照してください。
例
フォルダー内のテキスト ファイルの内容にクエ
リを実行する方法 (LINQ) (C#) 2020/11/02 • • Edit Online
 
     コードのコンパイル
System.Linq名前空間とSystem.IO名前空間に using ディレクティブを使用して、C#コンソールアプリケーションプロジェク トを作成します。
関連項目
LINQ とファイル ディレクトリ (C#)
  class QueryContents
{
    public static void Main()
    {
        // Modify this path as necessary.
        string startFolder = @"c:\program files\Microsoft Visual Studio 9.0\";
        // Take a snapshot of the file system.
        System.IO.DirectoryInfo dir = new System.IO.DirectoryInfo(startFolder);
        // This method assumes that the application has discovery permissions
        // for all folders under the specified path.
        IEnumerable<System.IO.FileInfo> fileList = dir.GetFiles("*.*",
System.IO.SearchOption.AllDirectories);
        string searchTerm = @"Visual Studio";
        // Search the contents of each file.
        // A regular expression created with the RegEx class
        // could be used instead of the Contains method.
        // queryMatchingFiles is an IEnumerable<string>.
        var queryMatchingFiles =
            from file in fileList
            where file.Extension == ".htm"
            let fileText = GetFileText(file.FullName)
            where fileText.Contains(searchTerm)
            select file.FullName;
        // Execute the query.
        Console.WriteLine("The term \"{0}\" was found in:", searchTerm);
        foreach (string filename in queryMatchingFiles)
        {
            Console.WriteLine(filename);
        }
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit");
        Console.ReadKey();
}
    // Read the contents of the file.
    static string GetFileText(string name)
    {
        string fileContents = String.Empty;
        // If the file has been deleted since we took
        // the snapshot, ignore it and return the empty string.
        if (System.IO.File.Exists(name))
        {
            fileContents = System.IO.File.ReadAllText(name);
        }
        return fileContents;
    }
}

  LINQ to Objects (C#)

           LINQ を使用して ArrayList などの非ジェネリックの IEnumerable コレクションをクエリする場合、範囲変数の型を明示的に宣 言して、オブジェクトの特定の型をコレクションに反映させる必要があります。たとえば、Student オブジェクトのArrayListがあ る場合、from 句は次のようになります。
範囲変数の型を指定することで、ArrayList内の各項目を Student にキャストします。
明示的に型指定された範囲変数をクエリ式で使用すると、Cast メソッドを呼び出した場合と同じ結果を得ることができます。 指定したキャストを実行できない場合、Cast は例外をスローします。 Cast および OfType は、非ジェネリックの IEnumerable 型で動作する、2 つの標準クエリ演算子メソッドです。 詳細については、「LINQ クエリ操作での型の関係」を参照してくださ い。
例
次の例では、ArrayList に対して単純なクエリを実行しています。 この例では、コードが Add メソッドを呼び出すときにオブジェク ト初期化子を使用していますが、これは必須ではありません。
     var query = from Student s in arrList
//...
  LINQ を使用して ArrayList にクエリを実行する方
法 (C#) 2020/11/02 • • Edit Online
 
     関連項目
LINQ to Objects (C#)
  using System;
using System.Collections;
using System.Linq;
namespace NonGenericLINQ
{
    public class Student
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int[] Scores { get; set; }
}
    class Program
    {
}
static void Main(string[] args)
{
    ArrayList arrList = new ArrayList();
    arrList.Add(
new Student {
                FirstName = "Svetlana", LastName = "Omelchenko", Scores = new int[] { 98, 92, 81, 60
            });
    arrList.Add(
new Student {
                FirstName = "Claire", LastName = "O’Donnell", Scores = new int[] { 75, 84, 91, 39 }
            });
    arrList.Add(
        new Student
            {
                FirstName = "Sven", LastName = "Mortensen", Scores = new int[] { 88, 94, 65, 91 }
            });
    arrList.Add(
new Student {
                FirstName = "Cesar", LastName = "Garcia", Scores = new int[] { 97, 89, 85, 82 }
            });
    var query = from Student student in arrList
                where student.Scores[0] > 95
                select student;
    foreach (Student s in query)
        Console.WriteLine(s.LastName + ": " + s.Scores[0]);
    // Keep the console window open in debug mode.
    Console.WriteLine("Press any key to exit.");
    Console.ReadKey();
} }
}
/* Output:
    Omelchenko: 98
Garcia: 97 */
    
           IEnumerable<T> インターフェイスに拡張メソッドを追加することで、LINQ クエリに使用するメソッド セットを拡張します。 たとえ ば、一連の値から単一の値を計算するために、平均や最大を求める標準的な演算に加えて、カスタムの集計メソッドを作成し ます。 また、一連の値を受け取って新しい一連の値を返す特定のデータ変換やカスタム フィルターとして動作するメソッドも作 成します。 このようなメソッドには、Distinct、Skip、Reverse があります。
IEnumerable<T> インターフェイスを拡張すると、列挙可能なコレクションにカスタム メソッドを適用できます。 詳細について は、「拡張メソッド」を参照してください。
集計メソッドを追加する
集計メソッドは、一連の値から単一の値を計算するメソッドです。 LINQ は、Average、Min、Max などの集計メソッドを提供
します。 IEnumerable<T> インターフェイスに拡張メソッドを追加することで、独自の集計メソッドを作成できます。 次のコード例は、 double 型の一連の数値から中央値を求める Median という拡張メソッドの作成方法を示しています。
      public static class LINQExtension
{
    public static double Median(this IEnumerable<double>? source)
    {
        if (!(source?.Any() ?? false))
        {
            throw new InvalidOperationException("Cannot compute median for a null or empty set.");
        }
        var sortedList = (from number in source
                          orderby number
                          select number).ToList();
        int itemIndex = sortedList.Count / 2;
        if (sortedList.Count % 2 == 0)
        {
            // Even number of items.
            return (sortedList[itemIndex] + sortedList[itemIndex - 1]) / 2;
        }
else {
            return sortedList[itemIndex];
        }
} }
// Odd number of items.
 この拡張メソッドは、IEnumerable<T> インターフェイスにある他の集計メソッドを呼び出すときと同じように、列挙可能な任意 のコレクションに対して呼び出すことができます。
double 型の配列に対して Median メソッドを使用する方法を次のコード例に示します。
  LINQ クエリのカスタム メソッドを追加する方法
(C#)
2020/11/02 • • Edit Online
 
   さまざまな型を受け取るために集計メソッドをオーバーロードする
集計メソッドでさまざまな型を受け取るように、集計メソッドをオーバーロードすることができます。 その標準的な方法として、型 ごとにオーバーロードを作成します。 または、ジェネリック型を受け取り、デリゲートを使って特定の型に変換するオーバーロードを 作成する方法もあります。 その両方の方法を組み合わせることもできます。
型ごとにオーバーロードを作成するには
サポート予定の型ごとに固有のオーバーロードを作成できます。 次のコード例では、 int 型の Median メソッドのオーバーロー ドを示します。
これで、次のコードに示すように、 integer 型と double 型の両方に対して、 Median のオーバーロードを呼び出すことができ るようになりました。
     //int overload
public static double Median(this IEnumerable<int> source) =>
    (from num in source select (double)num).Median();
        double[] numbers1 = { 1.9, 2, 8, 4, 5.7, 6, 7.2, 0 };
var query1 = numbers1.Median();
Console.WriteLine("double: Median = " + query1);
int[] numbers2 = { 1, 2, 3, 4, 5 };
var query2 = numbers2.Median();
Console.WriteLine("int: Median = " + query2);
/*
 This code produces the following output:
 Double: Median = 4.85
 Integer: Median = 3
*/
 ジェネリック オーバーロードを作成するには
一連のジェネリック オブジェクトを受け取るオーバーロードを作成することもできます。 このオーバーロードは、デリゲートをパラメー ターとして受け取り、ジェネリック型の一連のオブジェクトを特定の型に変換します。
次のコードは、Func<T,TResult>デリゲートをパラメーターとして受け取る Median メソッドのオーバーロードを示しています。こ のデリゲートは、ジェネリック型Tのオブジェクトを受け取り、double 型のオブジェクトを返します。
      // Generic overload.
public static double Median<T>(this IEnumerable<T> numbers,
                       Func<T, double> selector) =>
    (from num in numbers select selector(num)).Median();
 これで、任意の型の一連のオブジェクトに対して   メソッドを呼び出すことができます。 型に固有のメソッド オーバーロー
   double[] numbers = { 1.9, 2, 8, 4, 5.7, 6, 7.2, 0 };
var query = numbers.Median();
Console.WriteLine("double: Median = " + query);
/*
 This code produces the following output:
 Double: Median = 4.85
*/
  Median
 
     ドがない場合は、デリゲート パラメーターを渡す必要があります。 この目的で、C# ではラムダ式を使用できます。 また、Visual Basicに限り、メソッド呼び出しの代わりに Aggregate 句または Group By 句を使用した場合、その句のスコープにある任意 の値または式を渡すことができます。
次のコード例では、整数の配列と文字列の配列に対して Median メソッドを呼び出す方法を示します。文字列の場合は、 配列に格納されている文字列の長さの中央値が計算されます。 この例は、それぞれのケースについて、 Median メソッドに Func<T,TResult> デリゲート パラメーターを渡す方法を示しています。
        int[] numbers3 = { 1, 2, 3, 4, 5 };
/*
  You can use the num=>num lambda expression as a parameter for the Median method
  so that the compiler will implicitly convert its value to double.
  If there is no implicit conversion, the compiler will display an error message.
*/
var query3 = numbers3.Median(num => num);
Console.WriteLine("int: Median = " + query3);
string[] numbers4 = { "one", "two", "three", "four", "five" };
// With the generic overload, you can also use numeric properties of objects.
var query4 = numbers4.Median(str => str.Length);
Console.WriteLine("String: Median = " + query4);
/*
 This code produces the following output:
 Integer: Median = 3
 String: Median = 4
*/
 シーケンスを返すメソッドを追加する
IEnumerable<T> インターフェイスは、一連の値を返すカスタム クエリ メソッドを追加することで拡張できます。 その場合、メソッ ドで型 IEnumerable<T> のコレクションを返す必要があります。 このようなメソッドを使用すると、一連の値にフィルターまたは データ変換を適用することができます。
次の例では、コレクション内の最初の要素から1つおきに要素を返す AlternateElements という名前の拡張メソッドを作成す る方法を示しています。
     // Extension method for the IEnumerable<T> interface.
// The method returns every other element of a sequence.
public static IEnumerable<T> AlternateElements<T>(this IEnumerable<T> source)
{
    int i = 0;
    foreach (var element in source)
    {
if (i % 2 == 0) {
            yield return element;
        }
i++; }
}
 この拡張メソッドは、次のコードに示すとおり、IEnumerable<T> インターフェイスにある他のメソッドを呼び出すときと同じよう に、列挙可能な任意のコレクションに対して呼び出すことができます。

    関連項目
IEnumerable<T>
拡張メソッド
   string[] strings = { "a", "b", "c", "d", "e" };
var query5 = strings.AlternateElements();
foreach (var element in query5)
{
    Console.WriteLine(element);
}
/*
 This code produces the following output:
a c e
*/
 
             LINQ to ADO.NET では、統合言語クエリ (LINQ) プログラミング モデルを使用して ADO.NET 内の列挙可能なオブジェクトに 対してクエリを実行できます。
ADO.NET 統合言語クエリ (LINQ) には、3 つのテクノロジがあります。LINQ to DataSet、LINQ to SQL、LINQ to Entities で す。 LINQ to DataSet では、DataSet に対する高度で最適化されたクエリの実行が提供されます。LINQ to SQL では、SQL Server データベース スキーマに対して直接クエリを実行できます。LINQ to Entities では、Entity Data Model のクエリを実行 できます。
LINQ to DataSet
DataSet は、ADO.NET で最も幅広く使用されているコンポーネントの 1 つであり、ADO.NET の基礎である非接続型プログラミ
ングの重要な要素です。 こうした突出した特長がある反面、DataSet のクエリ機能には制限もあります。
LINQ to DataSet では、他の多くのデータ ソースで使用できるのと同じクエリ機能を使用することで、豊富なクエリ機能を
DataSet に組み込むことができます。 詳細については、「LINQ to DataSet」を参照してください。
LINQ to SQL
LINQ to SQL には、リレーショナル データをオブジェクトとして管理するためのランタイム インフラストラクチャが用意されています。 LINQ to SQL では、リレーショナル データベースのデータ モデルが、開発者のプログラミング言語で表されるオブジェクト モデルに 対応付けられています。 アプリケーションを実行すると、LINQ to SQL は、オブジェクト モデルの統合言語クエリを SQL に変換 し、それをデータベースに送信して実行します。 データベースから結果が返されると、LINQ to SQL で元の操作できるオブジェク トに変換されます。
LINQ to SQL には、データベースのストアド プロシージャ、ユーザー定義関数、オブジェクト モデルの継承のサポートが含まれて います。
詳細については、「LINQ to SQL」を参照してください。 LINQ to Entities
Entity Data Model では、リレーショナル データが .NET 環境にオブジェクトとして公開されます。 これにより、LINQ の利用に最 適なオブジェクト レイヤーが実現されます。開発者は、ビジネス ロジックの構築に使用する言語で、データベースを照会するクエ リを作成できます。 この機能は、LINQ to Entities と呼ばれます。 LINQ の詳細については、「LINQ to Entities」を参照してく ださい。
関連項目
LINQ と ADO.NET 統合言語クエリ (LINQ) (C#)
    NOTE
LINQ to ADO.NET のドキュメントは、.NET Framework SDK の ADO.NET のセクションにあります。「LINQ と ADO.NET」。
 LINQ to ADO.NET (ポータル ページ) 2020/11/02 • • Edit Online
 
          LINQ を拡張して、データ ソースを LINQ パターンでクエリできるようにする方法はいくつかあります。 データ ソースは、いくつか例 を挙げると、データ構造体、Web サービス、ファイル システム、またはデータベースの場合があります。 クエリの構文とパターンは 変わらないため、LINQ パターンを使用すると、クライアントは LINQ クエリが有効になっているデータ ソースを簡単にクエリできま す。 LINQ は、次の方法によってこれらのデータ ソースに拡張することができます。
型に IEnumerable<T> インターフェイスを実装し、その型の LINQ to Objects クエリを実行できるようにする。 型を拡張する Where や Select などの標準クエリ演算子メソッドを作成し、その型のカスタム LINQ クエリを有効にす
る。
データ ソース用に、IQueryable<T> インターフェイスを実装したプロバイダーを作成する。 このインターフェイスを実装し たプロバイダーは、式ツリーの形式で LINQ クエリを受け取ります。プロバイダーはこれをカスタマイズされた方法 (たとえば リモート) で実行できます。
データ ソース用に、既存の LINQ テクノロジを利用するプロバイダーを作成する。 そのようなプロバイダーは、クエリだけで なく、挿入、更新、および削除などの操作や、ユーザー定義型のマッピングも有効にします。
このトピックでは、これらのオプションについて説明します。
データ ソースの LINQ クエリを有効にする方法 インメモリ データ
インメモリ データの LINQ クエリを有効にする方法は 2 つあります。 データ型が IEnumerable<T> を実装する型の場合、 LINQ to Objects を使用してデータをクエリすることができます。 IEnumerable<T> インターフェイスを実装して型の列挙体を 有効にしても意味がない場合は、その型の LINQ 標準クエリ演算子メソッドを定義するか、または型を拡張する LINQ 標準ク エリ演算子メソッドを作成することができます。 標準クエリ演算子のカスタム実装は、結果を返すために遅延実行を使用する必 要があります。
リモート データ
リモート データ ソースの LINQ クエリを有効にするための最善の選択肢は、IQueryable<T> インターフェイスを実装することで
す。 しかしこれは、LINQ to SQL などのプロバイダーをデータ ソースに対して拡張することとは別です。 IQueryable LINQ プロバイダー
IQueryable<T> を実装する LINQ プロバイダーの複雑度にはかなりのばらつきがあります。 このセクションでは、さまざまなレベ ルの複雑度について説明します。
複雑度が低めの IQueryable プロバイダーは、多くの場合、Webサービスの単一のメソッドとやり取りします。この種のプロバ イダーは処理するクエリに特定の情報を受け取るので非常に高い固有性を持ちます。 クローズされた型システムを持ち、おそら く 1 つの結果型を公開します。 クエリはほとんどの場合、標準クエリ演算子の Enumerable 実装などを使用して、ローカルで 実行されます。 複雑度が低めのプロバイダーは、クエリを表す式ツリーのメソッド呼び出し式を 1 つだけ調べ、残りのクエリのロ ジックは他の場所で処理されるようにします。
複雑度が中レベルの IQueryable プロバイダーは、部分的に表現力が豊かなクエリ言語を持つデータソースを対象とします。 そのプロバイダーが Web サービスを対象とする場合、Web サービスの複数のメソッドとやり取りし、クエリが提示する問題に基づ いて呼び出すメソッドを選択します。 中レベルの複雑度のプロバイダーは、簡単なプロバイダーより型システムが豊富ですが、そ れでもその種類は限られています。 たとえば、このレベルのプロバイダーは走査できる一対多リレーションシップを持つ型を公開 する場合がありますが、ユーザー定義型のマッピング テクノロジは提供しません。
  データ ソースの LINQ クエリの有効化 2021/03/06 • • Edit Online
 
      LINQ to SQL プロバイダーなどの複雑な   プロバイダーは LINQ クエリ一式を、SQL などの表現力が豊かなクエリ 言語に変換する場合があります。 複雑なプロバイダーは、それほど複雑でないプロバイダーより一般的です。これは、より多様 な質問をクエリで処理できるためです。 さらに、オープンな型システムを持つため、ユーザー定義型をマップするために広範なイン フラストラクチャを含める必要があります。 複雑なプロバイダーの開発には、多大な労力を要します。
関連項目
IQueryable<T> IEnumerable<T> Enumerable 標準クエリ演算子の概要 (C#) LINQ to Objects (C#)
 IQueryable
 
        Visual Studio 統合開発環境 (IDE) では、LINQ アプリケーションの開発をサポートする次の機能が提供されています。 Object Relational Designer
オブジェクト リレーショナル デザイナーは、LINQ to SQL アプリケーションで使用できるビジュアル デザイン ツールです。基になる データベース内のリレーショナル データを表す、C# クラスを生成できます。 詳しくは、「Visual Studio の LINQ to SQL ツール」を ご覧ください。
SQLMetal コマンド ライン ツール
SQLMetal は、ビルド プロセスで使用できるコマンド ライン ツールです。既存のデータベースから、LINQ to SQL アプリケーション
で使用するためのクラスを生成できます。 詳しくは、「SqlMetal.exe (コード生成ツール)」をご覧ください。 LINQ 対応のコード エディター
C# のコード エディターでは、IntelliSense と書式設定機能によって、LINQ が広範囲にサポートされています。 Visual Studio デバッガーのサポート
Visual Studio デバッガーは、クエリ式のデバッグをサポートしています。 詳しくは、「LINQ のデバッグ」をご覧ください。
関連項目
統合言語クエリ (LINQ) (C#)
Visual Studio IDE およびツールの LINQ のサポー
ト (C#) 2020/11/02 • • Edit Online
 
         リフレクションによって、アセンブリ、モジュール、および型を記述する (Type 型の) オブジェクトが提供されます。 リフレクションを使 用すると、動的に型のインスタンスを作成したり、作成したインスタンスを既存のオブジェクトにバインドしたり、さらに既存のオブ ジェクトから型を取得してそのオブジェクトのメソッドを呼び出したり、フィールドやプロパティにアクセスしたりできます。 コードで属 性を使用している場合は、リフレクションを使用してそれらにアクセスできます。 詳細については、「属性」を参照してください。
次の例は、GetType() メソッドを使用して変数の型を取得する簡単なリフレクションを示しています。このメソッドは、 Object 基底クラスからすべての型に継承されるメソッドです。
     NOTE
.csファイルの先頭に using System; と using System.Reflection; を必ず追加してください。
       // Using GetType to obtain type information:
int i = 42;
Type type = i.GetType();
Console.WriteLine(type);
  出力は System.Int32 になります。 次の例では、リフレクションを使用して、読み込まれたアセンブリの完全名を取得します。
出力は System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e になります。
リフレクションの概要 リフレクションは、次の場合に役立ちます。
プログラムのメタデータ内の属性にアクセスする必要がある。 詳細については、「属性に格納されている情報の取得」を参照 してください。
アセンブリの型をチェックし、インスタンス化する。
実行時に新しい型を作成する。 System.Reflection.Emit でクラスを使います。 遅延バインディングを実行するために、実行時に作成された型でメソッドにアクセスする。 「型の動的な読み込みおよび使 用」を参照してください。
    // Using Reflection to get information of an Assembly:
Assembly info = typeof(int).Assembly;
Console.WriteLine(info);
        NOTE
C# のキーワード protected と internal は、中間言語 (IL) では意味を持たないため、リフレクション API でも使用されません。 IL で は、"ファミリ" および "アセンブリ" という用語がこれに相当します。 リフレクションを使用して internal メソッドを指定するに は、IsAssembly プロパティを使用します。 protected internal メソッドを指定するには、IsFamilyOrAssembly を使用します。
     関連項目
リフレクション (C#) 2021/03/06 • • Edit Online
 
        詳細情報
リフレクション
型情報の表示 リフレクションとジェネリック型 System.Reflection.Emit 属性に格納されている情報の取得
関連項目
C# プログラミング ガイド .NET のアセンブリ

          シリアル化は、オブジェクトを格納するか、メモリ、データベース、またはファイルに転送するためにバイト ストリームに変換するプロ セスです。 その主な目的は、必要なときに再作成できるように、オブジェクトの状態を保存しておくことです。 逆のプロセスは、 逆シリアル化と呼ばれます。
シリアル化のしくみ この図は、シリアル化の全体的なプロセスを示しています:
オブジェクトが、データを格納するストリームにシリアル化されます。 ストリームには、バージョン、カルチャ、アセンブリ名など、オブ ジェクトの種類に関する情報が含まれている場合もあります。 そのストリームから、オブジェクトをデータベース、ファイル、またはメ モリに格納できます。
シリアル化の使用方法
開発者は、シリアル化を使用して、オブジェクトの状態を保存し、必要に応じて、オブジェクトのストレージとデータ交換を指定す ることで、オブジェクトを再作成することができます。 開発者は、シリアル化を使用して次のようなアクションを実行できます。
Web サービスを使用してオブジェクトをリモート アプリケーションに送信する オブジェクトをあるドメインから別のドメインに渡す ファイアウォールを介してオブジェクトを JSON または XML 文字列として渡す アプリケーション間でセキュリティまたはユーザー固有の情報を保持する
JSON シリアル化
System.Text.Json 名前空間には、JavaScript Object Notation (JSON) シリアル化および逆シリアル化のためのクラスが含ま
れています。 JSON は、Web 経由でデータを共有するために一般的に使用されるオープン標準です。
JSON シリアル化では、オブジェクトのパブリック プロパティが、RFC 8259 JSON 仕様に準拠した文字列、バイト配列、またはス トリームにシリアル化されます。 JsonSerializer でクラスのインスタンスをシリアル化または逆シリアル化する方法を制御するに は、次の処理を行います。
JsonSerializerOptions オブジェクトを使用する
System.Text.Json.Serialization 名前空間からクラスまたはプロパティに属性を適用する カスタム コンバーターを実装する
バイナリ シリアル化と XML シリアル化
System.Runtime.Serialization 名前空間には、バイナリおよび XML シリアル化および逆シリアル化のためのクラスが含まれて
います。
バイナリ シリアル化では、バイナリ エンコードを使用して、ストレージやソケット ベースのネットワーク ストリームなどのためのコンパ
 シリアル化 (C#) 2020/11/02 • • Edit Online
 
              クトなシリアル化を生成します。 バイナリ シリアル化では、読み取り専用メンバーも含め、すべてのメンバーがシリアル化され、パ フォーマンスが向上します。
XML シリアル化では、オブジェクトのパブリック フィールドやパブリック プロパティ、またはメソッドのパラメーターや戻り値を、特定の XML スキーマ定義言語 (XSD) ドキュメントに準拠する XML ストリームにシリアル化します。 XML シリアル化では、XML に変 換されるパブリック プロパティとパブリック フィールドによって厳密に型指定されたクラスが生成されます。 System.Xml.Serialization には、XML のシリアル化および逆シリアル化のためのクラスが含まれています。 属性をクラスおよびク ラス メンバーに適用すると、XmlSerializer がそのクラスのインスタンスをシリアル化または逆シリアル化する方法を制御できま す。
オブジェクトをシリアル化可能にする
バイナリまたは XML シリアル化には、次が必要です。
シリアル化対象のオブジェクト シリアル化されたオブジェクトを格納するストリーム System.Runtime.Serialization.Formatter のインスタンス
この型のインスタンスをシリアル化できることを示すには、SerializableAttribute 属性を適用します。 型に SerializableAttribute 属性が適用されていない状態でシリアル化しようとすると、例外がスローされます。
フィールドがシリアル化されないようにするには、NonSerializedAttribute 属性を適用します。 シリアル化できる型のフィールド に、特定の環境に固有のポインター、ハンドル、その他のデータ構造が含まれているときに、そのフィールドを別の環境で意味が あるように再構成できない場合は、シリアル化不可にすることができます。
シリアル化されたクラスに、SerializableAttribute とマークされている他のクラスのオブジェクトへの参照が含まれている場合は、 これらのオブジェクトもシリアル化されます。
基本的なシリアル化とカスタムのシリアル化
バイナリおよび XML シリアル化は、2 つの方法で実行できます (基本およびカスタム)。
基本的なシリアル化では、.NET を使用して、オブジェクトが自動的にシリアル化されます。 唯一の要件は、クラスに SerializableAttribute 属性が適用されていることです。 NonSerializedAttribute を使用して、特定のフィールドがシリアル化 されないようにすることができます。
基本的なシリアル化を使用する場合、オブジェクトのバージョン管理によって問題が発生する場合があります。 バージョン管理 の問題が重要な場合は、カスタムのシリアル化を使用します。 基本的なシリアル化は、シリアル化を実行する最も簡単な方法 ですが、プロセスを細かく制御することはできません。
カスタムのシリアル化では、シリアル化するオブジェクトとシリアル化の方法を正確を指定できます。 クラスを SerializableAttribute でマークし、ISerializable インターフェイスを実装する必要があります。 カスタムの方法でオブジェクトを 逆シリアル化する場合は、カスタム コンストラクターを使用します。
デザイナーのシリアル化
デザイナーのシリアル化はシリアル化の特殊な形式であり、開発ツールに関連付けられているオブジェクトの永続性の種類を含 みます。 デザイナーのシリアル化は、後でオブジェクト グラフを復元できるように、オブジェクト グラフをソース ファイルに変換するプ ロセスです。 ソース ファイルには、コードとマークアップを含めることができますが、SQL テーブル情報を含めることもできます。
関連トピックと例
System.Text.Jsonの概要。System.Text.Json ライブラリを取得する方法を示します。
    WARNING
バイナリ シリアル化は危険です。 詳しくは、「BinaryFormatter セキュリティ ガイド」をご覧ください。
  
        .NET で JSON をシリアル化および逆シリアル化する方法。 JsonSerializer クラスを使用して JSON との間でオブジェクト データ の読み取りと書き込みを行う方法について説明します。
チュートリアル: オブジェクトの永続化 (Visual Studio (C#)) シリアル化によってインスタンス間でオブジェクトのデータを永続化して値を保存しておき、次にそのオブジェクトをインスタンス化す るときにその値を取得する方法を示します。
XML ファイルからオブジェクト データを読み取る方法 (C#)
XmlSerializer クラスを使用して、XML ファイルに以前に書き込まれたオブジェクト データを読み込む方法を示します。
XML ファイルにオブジェクト データを書き込む方法 (C#)
XmlSerializer クラスを使用して、クラスから XML ファイルにオブジェクトを書き込む方法を示します。

       XmlSerializer クラスを使用して、クラスから XML ファイルにオブジェクトを書き込む例を次に示します。 例
    public class XMLWrite
{
   static void Main(string[] args)
    {
        WriteXML();
    }
    public class Book
    {
        public String title;
    }
    public static void WriteXML()
    {
        Book overview = new Book();
        overview.title = "Serialization Overview";
        System.Xml.Serialization.XmlSerializer writer =
            new System.Xml.Serialization.XmlSerializer(typeof(Book));
        var path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) +
"//SerializationOverview.xml";
        System.IO.FileStream file = System.IO.File.Create(path);
        writer.Serialize(file, overview);
        file.Close();
    }
}
 コードのコンパイル シリアル化されるクラスには、パラメーターのないパブリック コンストラクターが必要です。
信頼性の高いプログラミング 次の条件を満たす場合は、例外が発生する可能性があります。
シリアル化されるクラスにパブリックなパラメーターなしのコンストラクターがない場合 ファイルが存在するものの、読み取り専用の場合 (IOException) パスが長すぎる (PathTooLongException)。
ディスクの空き領域がない場合 (IOException)
.NET セキュリティ
XML ファイルにオブジェクト データを書き込む
方法 (C#) 2020/11/02 • • Edit Online
 
    次のコード例では、ファイルが存在しない場合は新規にファイルを作成します。 アプリケーションでファイルを作成する必要がある 場合、そのアプリケーションにはフォルダーに対する Create アクセスが必要です。ファイルが既に存在する場合、アプリケーショ ンに必要なのは、より低い権限である Write アクセスだけです。フォルダーに対して Read アクセスを許可するのではなく、可 能な限りアプリケーションの配置時にファイルを作成しておき、1つのファイルに対してのみ Create アクセスを許可する方が安 全です。
関連項目
StreamWriter
XML ファイルからオブジェクト データを読み取る方法 (C#) シリアル化 (C#)
  
      次の例では、XmlSerializer クラスを使用して、XML ファイルに以前に書き込まれたオブジェクト データを読み込みます。 例
    public class Book
{
    public String title;
}
public void ReadXML()
{
    // First write something so that there is something to read ...
    var b = new Book { title = "Serialization Overview" };
    var writer = new System.Xml.Serialization.XmlSerializer(typeof(Book));
    var wfile = new System.IO.StreamWriter(@"c:\temp\SerializationOverview.xml");
    writer.Serialize(wfile, b);
    wfile.Close();
    // Now we can read the serialized book ...
    System.Xml.Serialization.XmlSerializer reader =
        new System.Xml.Serialization.XmlSerializer(typeof(Book));
    System.IO.StreamReader file = new System.IO.StreamReader(
        @"c:\temp\SerializationOverview.xml");
    Book overview =  (Book)reader.Deserialize(file);
    file.Close();
    Console.WriteLine(overview.title);
}
 コードのコンパイル
ファイル名 "c:\temp\SerializationOverview.xml" を、シリアル化されたデータを含むファイルの名前に置き換えます。 データの
シリアル化の詳細については、「XML ファイルにオブジェクト データを書き込む方法 (C#)」を参照してください。 クラスには、パラメーターのないパブリック コンストラクターが必要です。
パブリック プロパティとパブリック フィールドだけが逆シリアル化されます。
信頼性の高いプログラミング 次の条件を満たす場合は、例外が発生する可能性があります。
シリアル化されるクラスにパブリックなパラメーターなしのコンストラクターがない場合 ファイル内のデータが、逆シリアル化されるクラスのデータを表していない場合。 ファイルが存在しない (IOException)。
.NET セキュリティ
XML ファイルからオブジェクト データを読み取
る方法 (C#) 2020/11/02 • • Edit Online
 
     入力を常に検証し、信頼できないソースから決してデータを逆シリアル化しないでください。 再作成されたオブジェクトは、そのオ ブジェクトを逆シリアル化したコードと同じアクセス許可を持つローカル コンピューターで実行されます。 アプリケーションでデータを 使用する前に、入力をすべて検証してください。
関連項目
StreamWriter
XML ファイルにオブジェクト データを書き込む方法 (C#) シリアル化 (C#)
C# プログラミング ガイド

       シリアル化によってインスタンス間でオブジェクトのデータを永続化すると、値を保存しておき、次にそのオブジェクトをインスタンス 化するときに、その値を取得することができます。
このチュートリアルでは、基本的な Loan オブジェクトを作成し、そのデータをファイルに永続化します。その後、オブジェクトを再 作成するときに、そのファイルからデータを取得します。
    IMPORTANT
次の例では、ファイルが存在しない場合は、新しいファイルが作成されます。 アプリケーションでファイルを作成する必要がある場合、そのアプリ ケーションには、フォルダーに対する Create アクセス許可が必要です。 アクセス許可は、アクセス制御リストを使用して設定します。 ファイ ルが既に存在する場合、アプリケーションに必要なのは下位の Write アクセス許可だけです。 可能な場合は、(フォルダーに対して Create アクセス許可を付与するのではなく) 配置時にファイルを作成し、1 つのファイルに対してのみ Read アクセス許可を付与する方が 安全です。 また、ルート フォルダーや Program Files フォルダーにデータを書き込むより、ユーザー フォルダーに書き込む方が安全です。
      IMPORTANT
この例では、バイナリ形式のファイルにデータを格納します。 この形式は、パスワードやクレジット カード情報などの重要情報には使用しない でください。
 必須コンポーネント
ビルドして実行するには、.NET Core SDK をインストールします。
コード エディターをまだインストールしていなければ、お気に入りのエディターをインストールしてください。
この例では C# 7.3 が必要です。 「C# 言語のバージョンの選択」を参照してください
オンラインで .NET サンプルの GitHub リポジトリにアクセスしてサンプル コードを確認することができます。
loan オブジェクトを作成する
まず、 Loan クラスとそのクラスを使用するコンソール アプリケーションを作成します。
1. 新しいアプリケーションを作成します。 「 dotnet new console -o serialization 」と入力して serialization という名前 のサブディレクトリに新しいコンソール アプリケーションを作成します。
2. エディターでアプリケーションを開き、 Loan.cs という名前の新しいクラスを追加します。 3. Loan クラスに次のコードを追加します。
    TIP
コード エディターをインストールする必要がありますか。 Visual Studio をお試しください。
    チュートリアル: C# を使用してオブジェクトを
永続化する
2020/11/02 • • Edit Online
 
  また、 Loan クラスを使用するアプリケーションも作成する必要があります。 loan オブジェクトをシリアル化する
1. Program.cs を開きます。 次のコードを追加します。
PropertyChanged イベントのイベント ハンドラーを追加し、 Loan オブジェクトを変更して変更を表示する処理を行う数行を 追加します。 この追加は次のコードで確認できます。
この時点で、コードを実行して現在の出力を確認することができます。
   Loan TestLoan = new Loan(10000.0, 7.5, 36, "Neil Black");
      TestLoan.PropertyChanged += (_, __) => Console.WriteLine($"New customer value: {TestLoan.Customer}");
TestLoan.Customer = "Henry Clay";
Console.WriteLine(TestLoan.InterestRatePercent);
TestLoan.InterestRatePercent = 7.1;
Console.WriteLine(TestLoan.InterestRatePercent);
    public class Loan : INotifyPropertyChanged
 {
     public double LoanAmount { get; set; }
     public double InterestRatePercent { get; set; }
     [field:NonSerialized()]
     public DateTime TimeLastLoaded { get; set; }
     public int Term { get; set; }
     private string customer;
     public string Customer
     {
         get { return customer; }
         set
         {
} }
customer = value;
PropertyChanged?.Invoke(this,
  new PropertyChangedEventArgs(nameof(Customer)));
    [field: NonSerialized()]
    public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
    public Loan(double loanAmount,
                double interestRate,
                int term,
                string customer)
    {
        this.LoanAmount = loanAmount;
        this.InterestRatePercent = interestRate;
        this.Term = term;
        this.customer = customer;
} }
 
      このアプリケーションを繰り返し実行すると、常に同じ値が書き込まれます。 プログラムを実行するたびに新しい Loan オブジェク トが作成されます。 実際には利率は定期的に変わりますが、アプリケーションを実行するたびに変わるとは限りません。 シリアル 化コードとは、アプリケーションのインスタンス間で最新の利率を保持することを意味します。 次の手順では、Loan クラスにシリア ル化を追加して、利率を保持できるようにします。
シリアル化を使用したオブジェクトの永続化
Loanクラスの値を永続化するには、まず、クラスを Serializable 属性でマークする必要があります。Loanクラス定義の上に 次のコードを追加します。
SerializableAttributeは、クラス内のすべての要素がファイルに永続化できることをコンパイラに示します。 PropertyChanged イベントは保存する必要があるオブジェクト グラフの一部を表していないので、シリアル化しないようにします。 シリアル化すると、 そのイベントにアタッチされているすべてのオブジェクトがシリアル化されます。 NonSerializedAttribute は、 PropertyChanged イベント ハンドラーのフィールド宣言に追加できます。
C#7.3以降、field のターゲット値を使用して、自動実装プロパティのバッキングフィールドに属性をアタッチできるようになりま した。次のコードでは TimeLastLoaded プロパティを追加し、シリアル化可能ではないとマークします。
次に、LoanApp アプリケーションにシリアル化コードを追加します。 クラスをシリアル化してファイルに書き込むには、System.IO 名前空間と System.Runtime.Serialization.Formatters.Binary 名前空間を使用します。 次のコードのように、必要な名前 空間への参照を追加すると、完全修飾名の入力が不要になります。
次の手順では、オブジェクトの作成時にファイルからオブジェクトを逆シリアル化するコードを追加します。 次のコードのように、シ リアル化されたデータのファイル名を定数としてクラスに追加します。
次に、 TestLoan オブジェクトを作成する行の後に次のコードを追加します。
   [Serializable()]
       [field: NonSerialized()]
public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
      [field:NonSerialized()]
public DateTime TimeLastLoaded { get; set; }
     using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
   const string FileName = @"../../../SavedLoan.bin";
     New customer value: Henry Clay
7.5
7.1
 
     まず、ファイルが存在することを確認する必要があります。 ファイルが存在する場合は、バイナリ ファイルを読み取る Stream クラ スと、ファイルを変換する BinaryFormatter クラスを作成します。 ストリーム型を Loan オブジェクト型に変換する必要もありま す。
次に、クラスをファイルにシリアル化するコードを追加する必要があります。 Main メソッドの既存のコードの後に次のコードを追 加します。
この時点で、アプリケーションを再度ビルドして実行できます。 初めて実行すると、利率は 7.5 から始まり、7.1 に変更されま す。 いったんアプリケーションを閉じて、再び実行します。 利率を変更するコードの前でも、保存済みのファイルが読み込まれ、 利率は 7.1 であるというメッセージがアプリケーションから出力されます。
関連項目
シリアル化 (C#)
C# プログラミング ガイド
    Stream SaveFileStream = File.Create(FileName);
BinaryFormatter serializer = new BinaryFormatter();
serializer.Serialize(SaveFileStream, TestLoan);
SaveFileStream.Close();
    if (File.Exists(FileName))
{
    Console.WriteLine("Reading saved file");
    Stream openFileStream = File.OpenRead(FileName);
    BinaryFormatter deserializer = new BinaryFormatter();
    TestLoan = (Loan)deserializer.Deserialize(openFileStream);
    TestLoan.TimeLastLoaded = DateTime.Now;
    openFileStream.Close();
}
 
           アプリケーションを構成する C# コードは、キーワード、式、演算子から成るステートメントで構成されます。 このセクションには、 C# プログラムのこのような基本要素に関する情報が含まれています。
詳細については次を参照してください: ステートメント
演算子および式 式形式のメンバー 匿名関数 等価比較
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミングガイド キャストと型変換
ステートメント、式、および演算子 (C# プログ
ラミング ガイド) 2020/11/02 • • Edit Online
 
   プログラムが実行する処理は、ステートメントとして表されます。 一般的な処理には、変数の宣言、値の代入、メソッドの呼び 出し、コレクションに対するループ処理、条件に応じたコード ブロックへの分岐などがあります。 プログラム内でステートメントが実 行される順序は、制御フローまたは実行フローと呼ばれます。 制御フローは、実行時に渡された入力に対するプログラムの応 答に応じて、プログラムを実行するたびに変わる可能性があります。
ステートメントは、セミコロンで終わる単一行のコードか、1 つのブロックを形成する一連の単一行ステートメントで構成されま す。 ステートメント ブロックは中かっこ {} で囲み、入れ子になったブロックを含めることができます。 次のコードは、2 つの単一行 ステートメントの例と、1 つの複数行ステートメント ブロックを示しています。
        static void Main()
    {
        // Declaration statement.
        int counter;
        // Assignment statement.
        counter = 1;
        // Error! This is an expression, not an expression statement.
        // counter + 1;
        // Declaration statements with initializers are functionally
        // equivalent to  declaration statement followed by assignment statement:
        int[] radii = { 15, 32, 108, 74, 9 }; // Declare and initialize an array.
        const double pi = 3.14159; // Declare and initialize  constant.
        // foreach statement block that contains multiple statements.
        foreach (int radius in radii)
        {
            // Declaration statement with initializer.
            double circumference = pi * (2 * radius);
            // Expression statement (method invocation). A single-line
            // statement can span multiple text lines because line breaks
            // are treated as white space, which is ignored by the compiler.
            System.Console.WriteLine("Radius of circle #{0} is {1}. Circumference = {2:N2}",
                                    counter, radius, circumference);
            // Expression statement (postfix increment).
            counter++;
        } // End of foreach statement block
    } // End of Main method body.
} // End of SimpleStatements class.
/*
   Output:
    Radius of circle #1 = 15. Circumference = 94.25
    Radius of circle #2 = 32. Circumference = 201.06
    Radius of circle #3 = 108. Circumference = 678.58
    Radius of circle #4 = 74. Circumference = 464.96
    Radius of circle #5 = 9. Circumference = 56.55
*/
 ステートメントの種類
次の表は、C# のさまざまな種類のステートメントと、それぞれに関連付けられているキーワードの一覧です。詳細が記載されて いるトピックへのリンクも示しています。
ステートメント (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
         C# /
   宣言ステートメント
   宣言ステートメントは、新しい変数または定数を定義します。 変数 宣言では、必要に応じて変数に値を代入することができます。 定数 宣言では、常に代入が必要です。
 式ステートメント 値を計算する式ステートメントでは、変数に値を格納する必要があり ます。
   選択ステートメント
   選択ステートメントでは、1 つ以上の指定した条件に応じて、コードの さまざまなセクションに分岐することができます。 詳細については、次 のトピックを参照してください。
if
else switch case
   繰り返しステートメント
 繰り返しステートメントを使用すると、配列などのコレクションをループ 処理したり、指定した条件が満たされるまで同じステートメントのセッ トを繰り返し実行したりできます。 詳細については、次のトピックを参 照してください。
do
for foreach in while
   ジャンプ ステートメント
  ジャンプ ステートメントでは、別のコード セクションに制御を移します。 詳細については、次のトピックを参照してください。
break continue default goto return yield
   例外処理ステートメント
  例外処理ステートメントを使用すると、実行時に発生する例外状態 から適切に回復できます。 詳細については、次のトピックを参照してく ださい。
throw try-catch
tr y-finally
tr y-catch-finally
   checked と unchecked
   checked ステートメントと unchecked ステートメントを使用すると、 結果の値を保持するには小さすぎる変数に結果が格納される場合 に、数値演算でオーバーフローが発生するのを許可するかどうかを指 定できます。 詳細については、「checked」および「unchecked」を参 照してください。
 
     C# /
   await ステートメント
  メソッドに async 修飾子を付けると、そのメソッドで await 演算子を 使用できます。 コントロールが非同期メソッドの await 式に到達す ると、コントロールは呼び出し元に戻り、待機中のタスクが完了するま でメソッドの進行状況は中断されます。 タスクが完了すると、メソッド で実行を再開できます。
簡単な例については、「メソッド」の「非同期メソッド」セクションを参照 してください。 詳細については、「Async および Await を使用した非 同期プログラミング」を参照してください。
    yield return ステートメント
  反復子は、リストや配列など、コレクションに対するカスタム イテレー ションを実行します。 反復子は、 yield return ステートメントを使用 して、各要素を 1 回に1 つ返します。 yield return ステートメン トに達すると、コードの現在の場所が記憶されます。 反復子が次回 呼び出されたとき、この場所から実行が再開されます。
詳細については、「 反復子」を参照してください。
    fixed ステートメント
  fixed ステートメントは、移動可能な変数がガベージ コレクターにより 再配置されることを防ぎます。 詳細については、「fixed」を参照してく ださい。
   lock ステートメント
  lock ステートメントを使用すると、一度に 1 つのスレッドしかコード ブ ロックにアクセスしないように制限できます。 詳細については、「lock」 を参照してください。
   ラベル付きステートメント
  ステートメントにラベルを付与し、goto キーワードを使用して、そのラベ ル付きステートメントにジャンプできます (次の行の例を参照してくださ い)。
    空のステートメント
   空のステートメントは、1 つのセミコロンで構成されます。 このステート メントは何も実行しませんが、ステートメントが必要な場所で、どのよ うな処理も実行する必要がない場合に使用できます。
 宣言ステートメント
次のコードでは、最初の割り当てを使用した場合と使用しない場合の変数宣言の例と、必要な初期化を使用した定数宣言 の例を示します。
式ステートメント
次のコードでは、割り当て、割り当てによるオブジェクトの作成、およびメソッドの呼び出しなど、式ステートメントの例を示しま す。
    // Variable declaration statements.
double area;
double radius = 2;
// Constant declaration statement.
const double pi = 3.14159;
 
   空のステートメント
空のステートメントの 2 つの使用例を次に示します。
    void ProcessMessages()
{
    while (ProcessMessage())
        ; // Statement needed here.
}
void F() {
//...
    if (done) goto exit;
//...
exit:
    ; // Statement needed here.
}
 埋め込みステートメント
do、while、for、foreach などの一部のステートメントでは、その後に必ず埋め込みステートメントが続きます。 この埋め込みス テートメントは、単一のステートメントか、または複数のステートメントを中かっこ {} で囲んだステートメント ブロックです。 単一行 の埋め込みステートメントでも、次の例に示すように中かっこ {} で囲むことができます。
    // Recommended style. Embedded statement in  block.
foreach (string s in System.IO.Directory.GetDirectories(
                        System.Environment.CurrentDirectory))
{
    System.Console.WriteLine(s);
}
// Not recommended.
foreach (string s in System.IO.Directory.GetDirectories(
                        System.Environment.CurrentDirectory))
    System.Console.WriteLine(s);
 中かっこ {} で囲まれていない埋め込みステートメントは、宣言ステートメントやラベル付きステートメントにはできません。 以下の 例を参照してください。
    if(pointB == true)
    //Error CS1023:
    int radius = 5;
 エラーを修正するには、次のように埋め込みステートメントをブロックに配置します。
   // Expression statement (assignment).
area = 3.14 * (radius * radius);
// Error. Not  statement because no assignment:
//circ * 2;
// Expression statement (method invocation).
System.Console.WriteLine();
// Expression statement (new object creation).
System.Collections.Generic.List<string> strings =
    new System.Collections.Generic.List<string>();
 
       入れ子になったステートメント ブロック 次のコードに示すように、ステートメント ブロックを入れ子にすることができます。
    foreach (string s in System.IO.Directory.GetDirectories(
    System.Environment.CurrentDirectory))
{
    if (s.StartsWith("CSharp"))
    {
} }
if (s.EndsWith("TempFolder"))
{
return s; }
return "Not found.";
 到達できないステートメント コンパイラは、どのような状況でも特定のステートメントに制御フローが到達できないと判断すると、次の例のように、警告
CS0162 を生成します。
C# 言語仕様
詳細については、C# 言語仕様の「ステートメント」セクションを参照してください。
関連項目
C# プログラミング ガイド ステートメントのキーワード C# の演算子と式
    // An over-simplified example of unreachable code.
const int val = 5;
if (val < 4)
{
    System.Console.WriteLine("I'll never write anything."); //CS0162
}
    if (b == true)
{
    // OK:
    System.DateTime d = System.DateTime.Now;
    System.Console.WriteLine(d.ToLongDateString());
}
 
          式本体の定義を使用すると、簡潔でわかりやすい形式でメンバーの実装を指定できます。 サポートされる任意のメンバー (メ ソッドやプロパティなど) に関するロジックが単一の式で構成される場合は、常に式本体の定義を使用できます。 式本体の定 義には、次の一般的な構文があります。
この expression には有効な式を指定します。
式本体の定義のサポートは、メソッドと読み取り専用プロパティのために C# 6 で導入され、C# 7.0 で拡張されました。 式本体
  member => expression;
 の定義は、次の表の方メンバーで使用できます。
メソッド 読み取り専用プロパティ Property コンストラクター ファイナライザー インデクサー
メソッド
C# 6 C# 6 C# 7.0 C# 7.0 C# 7.0 C# 7.0
                           式形式のメソッドは、型がメソッドの戻り値の型と一致する値を返す単一の式、または、 void を返すメソッドの場合は何らか の処理を実行する単一の式で構成されます。 たとえば、一般的に、ToString メソッドをオーバーライドする型には、現在のオブ ジェクトの文字列形式を返す単一の式が含まれています。
次の例では、式本体の定義を使用して ToString メソッドをオーバーライドする クラスを定義します。 また、名前をコン ソールに表示する DisplayName メソッドも定義します。 ToString 式本体の定義に キーワードが使用されていない 点に注意してください。
 Person
   return
式形式のメンバー (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    詳細については、「メソッド (C# プログラミング ガイド)」を参照してください。 読み取り専用プロパティ
C# 6 以降では、式本体の定義を使用して読み取り専用プロパティを実装することができます。 そのためには、次の構文を使 用します。
次の例では、プライベート locationName フィールドの値を返す式本体の定義として読み取り専用の Name プロパティを実装 する Location クラスを定義します。
  PropertyType PropertyName => expression;
       public class Location
{
   private string locationName;
   public Location(string name)
   {
      locationName = name;
   }
   public string Name => locationName;
}
 プロパティの詳細については、「プロパティ (C# プログラミング ガイド)」を参照してください。 プロパティ
C#7.0以降では、式本体の定義を使用してプロパティ get と set アクセサーを実装することができます。これを実行する方 法を次の例に示します。
   using System;
public class Person
{
   public Person(string firstName, string lastName)
   {
      fname = firstName;
      lname = lastName;
   }
   private string fname;
   private string lname;
   public override string ToString() => $"{fname} {lname}".Trim();
   public void DisplayName() => Console.WriteLine(ToString());
}
class Example
{
   static void Main()
   {
      Person p = new Person("Mandy", "Dejesus");
      Console.WriteLine(p);
      p.DisplayName();
} }
 
     プロパティの詳細については、「プロパティ (C# プログラミング ガイド)」を参照してください。 コンストラクター
一般的に、コンストラクターの式本体の定義は、コンストラクターの引数を処理したり、インスタンスの状態を初期化したりする単 一の代入式またはメソッド呼び出しから構成されます。
次の例では、コンストラクターにnameという名前の文字列パラメーターが1つある Location クラスが定義されています。式 の本体の定義により Name プロパティに引数が割り当てられます。
     public class Location
{
   private string locationName;
   public Location(string name) => Name = name;
   public string Name
   {
      get => locationName;
      set => locationName = value;
   }
}
 詳細については、「コンストラクター (C# プログラミング ガイド)」を参照してください。 ファイナライザー
一般的に、ファイナライザーの式本体の定義には、アンマネージ リソースをリリースするステートメントなどのクリーンアップ ステート メントが含まれています。
次の例では、式本体の定義を使用して、ファイナライザーが呼び出されたことを示すファイナライザーを定義します。
    using System;
public class Destroyer
{
   public override string ToString() => GetType().Name;
   ~Destroyer() => Console.WriteLine($"The {ToString()} destructor is executing.");
}
 詳細については、「ファイナライザー (C# プログラミング ガイド)」を参照してください。
インデクサー
プロパティと同様に、 get アクセサーが値を返す単一のステートメントで構成される場合、または set アクセサーがシンプルな
   public class Location
{
   private string locationName;
   public Location(string name) => Name = name;
   public string Name
   {
      get => locationName;
      set => locationName = value;
   }
}
 
  代入を実行する場合、インデクサーの get と set アクセサーは、式本体の定義で構成されます。
次の例では、Sports というクラスを定義します。このクラスには、複数のスポーツ名を含む内部String配列があります。イン
デクサーの get および set アクセサーはいずれも、式本体の定義として実装されます。
     using System;
using System.Collections.Generic;
public class Sports
{
   private string[] types = { "Baseball", "Basketball", "Football",
                              "Hockey", "Soccer", "Tennis",
   public string this[int i]
   {
      get => types[i];
      set => types[i] = value;
   }
}
"Volleyball" };
 詳細については、「インデクサー (C# プログラミング ガイド)」を参照してください。

     匿名関数は、デリゲート型が必要とされる任意の場所で使用できる "インライン" のステートメントまたは式です。 名前付きデリ ゲートを初期化するときや、メソッドのパラメーターとして名前付きデリゲート型の代わりに渡したりするときに使用できます。
ラムダ式または匿名メソッドを使って匿名関数を作成できます。 ラムダ式を使った方がより簡潔で表現性に優れた方法でインラ イン コードを記述できるため、こちらを使うことをお勧めします。 匿名メソッドとは異なり、一部の型のラムダ式は式ツリー型に変 換することができます。
C# のデリゲートの進化
C# 1.0 では、コードのどこかで定義したメソッドを使用して明示的に初期化することで、デリゲートのインスタンスを作成していま した。 C# 2.0 では、デリゲートの呼び出しで実行できる名前なしのインライン ステートメント ブロックを記述する方法として、匿 名メソッドの概念が導入されました。 C# 3.0 では、ラムダ式が導入されました。ラムダ式は、概念的には匿名メソッドと似ていま すが、より表現力が豊かで簡潔です。 これら 2 つの機能は総称として匿名関数と呼ばれます。 一般的に、.NET Framework 3.5 以降のバージョンを対象とするアプリケーションであれば、ラムダ式を使用することが推奨されます。
次の例は、C# 1.0 から C# 3.0 のデリゲート作成の進化を示しています。
匿名関数 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
          C# 言語仕様
詳細については、「C# 言語仕様」の無名関数の式に関するセクションを参照してください。
関連項目
ステートメント、式、および演算子 ラムダ式
デリゲート
式ツリー (C#)
  class Test {
    delegate void TestDelegate(string s);
    static void M(string s)
    {
        Console.WriteLine(s);
    }
    static void Main(string[] args)
    {
} }
// Original delegate syntax required
// initialization with a named method.
TestDelegate testDelA = new TestDelegate(M);
// C# 2.0: A delegate can be initialized with
// inline code, called an "anonymous method." This
// method takes a string as an input parameter.
TestDelegate testDelB = delegate(string s) { Console.WriteLine(s); };
// C# 3.0. A delegate can be initialized with
// a lambda expression. The lambda also takes a string
// as an input parameter (x). The type of x is inferred by the compiler.
TestDelegate testDelC = (x) => { Console.WriteLine(x); };
// Invoke the delegates.
testDelA("Hello. My name is M and I write lines.");
testDelB("That's nothing. I'm anonymous and ");
testDelC("I'm a famous author.");
// Keep console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    Hello. My name is M and I write lines.
    That's nothing. I'm anonymous and
    I'm a famous author.
    Press any key to exit.
*/

         クエリ構文でラムダ式を直接使うことはありませんが、メソッドの呼び出しで使い、クエリ式はメソッドの呼び出しを含むことができま す。 実際、一部のクエリ操作はメソッド構文でのみ表現できます。 クエリ構文とメソッド構文の違いについて詳しくは、「LINQ で のクエリ構文とメソッド構文」をご覧ください。
例
次の例を見ると、Enumerable.Where 標準クエリ演算子を使用することにより、メソッド ベースのクエリでラムダ式を使用する方 法がわかります。 この例の Where メソッドにはデリゲート型 Func<T,TResult> の入力パラメーターがあり、そのデリゲートは入 力として整数を受け取ってブール値を返すことに注意してください。 ラムダ式は、そのデリゲートに変換できます。 これが Queryable.Where メソッドを使用する LINQ to SQL のクエリであったなら、パラメーターの型は
Expression<Func<int,bool>> になりますが、ラムダ式の表現はまったく同じです。式の型の詳細について は、System.Linq.Expressions.Expression に関する記事をご覧ください。
     class SimpleLambda
{
    static void Main()
    {
        // Data source.
        int[] scores = { 90, 71, 82, 93, 75, 82 };
        // The call to Count forces iteration of the source
        int highScoreCount = scores.Where(n => n > 80).Count();
        Console.WriteLine("{0} scores are greater than 80", highScoreCount);
        // Outputs: 4 scores are greater than 80
    }
}
 例
次の例では、クエリ式のメソッド呼び出しでラムダ式を使う方法を示します。 Sum 標準クエリ演算子はクエリ構文を使って呼び 出すことができないため、ラムダが必要です。
このクエリは最初に、 GradeLevel 列挙型で定義されている成績レベルに従って、学生をグループ分けします。 その後、各グ ループについて、各学生の合計点数を追加します。これには、2つの Sum 演算が必要です。内側の Sum は各学生の合 計点数を計算し、外側の Sum はグループ内のすべての学生の集計中の合計を保持します。
 クエリでラムダ式を使用する方法 (C# プログラ
ミング ガイド) 2020/11/02 • • Edit Online
 
     コードのコンパイル このコードを実行するには、メソッドをコピーして、「オブジェクトのコレクションにクエリを実行する」で提供されている
StudentClass に貼り付けた後、 Main メソッドからそれを呼び出します。 関連項目
ラムダ式 式ツリー (C#)
    private static void TotalsByGradeLevel()
{
    // This query retrieves the total scores for First Year students, Second Years, and so on.
    // The outer Sum method uses a lambda in order to specify which numbers to add together.
    var categories =
    from student in students
    group student by student.Year into studentGroup
    select new { GradeLevel = studentGroup.Key, TotalScore = studentGroup.Sum(s => s.ExamScores.Sum()) };
    // Execute the query.
    foreach (var cat in categories)
    {
        Console.WriteLine("Key = {0} Sum = {1}", cat.GradeLevel, cat.TotalScore);
    }
} /*
*/
Outputs:
Key = SecondYear Sum = 1014
Key = ThirdYear Sum = 964
Key = FirstYear Sum = 1058
Key = FourthYear Sum = 974
 
      2 つの値が等しいかどうかを比較することが必要な場合があります。 そのような場合、値が等価であること (等価性 と呼ばれる) をテストすることになります。等価性とは 2 つの変数に含まれる値が等しいことを意味します。 また、2 つの変数がメモリ内の同 一の基になるオブジェクトを参照しているかどうかを確認する必要がある場合もあります。 このタイプの等価は、参照の等価性 または 同一性 と呼ばれます。 ここでは、2 種類の等価について説明します。また、詳細について他のトピックへのリンクを示しま す。
参照の等価性
参照の等価とは、2 つのオブジェクト参照が同一の基になるオブジェクトを参照していることを意味します。 次の例に示すよう に、これは簡単な代入によって生じます。
    using System;
class Test
{
    public int Num { get; set; }
    public string Str { get; set; }
    static void Main()
    {
} }
Test a = new Test() { Num = 1, Str = "Hi" };
Test b = new Test() { Num = 1, Str = "Hi" };
bool areEqual = System.Object.ReferenceEquals(a, b);
// False:
System.Console.WriteLine("ReferenceEquals(a, b) = {0}", areEqual);
// Assign b to a.
b = a;
// Repeat calls with different results.
areEqual = System.Object.ReferenceEquals(a, b);
// True:
System.Console.WriteLine("ReferenceEquals(a, b) = {0}", areEqual);
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
 このコードでは、2 つのオブジェクトが作成されますが、代入ステートメント以降は、両方の参照が同一のオブジェクトを参照して います。 したがって、参照の等価性があります。 2 つの参照が同じオブジェクトを参照しているかどうかを判断するに は、ReferenceEquals メソッドを使用します。
参照の等価性の概念は参照型のみに適用されます。 値型オブジェクトには参照の等価性がありません。これは、値型のイン スタンスが変数に代入される場合、値のコピーが作成されるためです。 そのため、ボックス化を解除した 2 つの構造体でメモリ 内の同じ場所を参照することはできません。 さらに、ReferenceEquals を使用して 2 つの値型を比較する場合、オブジェクトに 含まれている値がすべて同一である場合でも、結果は常に false になります。これは、各変数が個別のオブジェクトインスタ ンスにボックス化されているためです。 詳細については、「参照の等価性 (同値) をテストする方法」を参照してください。
値の等価性
等価比較 (C# プログラミング ガイド) 2021/03/16 • • Edit Online
 
       値が等価であるとは、2 つのオブジェクトが同じ値を含むことを意味します。 int、bool などのプリミティブ値型では、値が等価で あることをテストするのは簡単です。 次の例に示すように、== 演算子を使用できます。
    int a = GetOriginalValue();
int b = GetCurrentValue();
// Test for value equality.
if (b == a)
{
    // The two integers are equal.
}
 それ以外のほとんどの型については、値が等価であることをテストするのは、もっと複雑です。特定の型で等価性がどのように定 義されるかを理解する必要があるからです。 複数のフィールドまたはプロパティを含むクラスおよび構造体では、多くの場合、値 が等価であるとは、すべてのフィールドまたはプロパティが同一の値を含むことであると定義されます。 たとえば、pointA.X が pointB.Xと等しく、pointA.YがpointB.Yと等しい場合、2つの Point オブジェクトは等価であると定義されます。レコードに おける値の等価性とは、型が一致し、かつプロパティおよびフィールドの値がすべて一致する場合にレコード型の 2 つの変数が 等しいことを意味します。
ただし、等価性を 1 つの型のすべてのフィールドに基づいて判断する必要はありません。 サブセットに基づいて判断できます。 所有していない型を比較する場合は、その型の等価性がどのように定義されるのかを明確に理解している必要があります。 独 自のクラスおよび構造体で値が等しいかどうかを定義する方法の詳細については、「型の値の等価性を定義する方法」を参照 してください。
浮動小数点値での値の等価性
バイナリのコンピューター上での浮動小数点演算には誤差があるため、浮動小数点値 (double および float) の等価比較には
問題があります。 詳細については、System.Double のトピックの「解説」を参照してください。 関連トピック
TITLE
参照の等価性 (同値) をテストする方法
型の値の等価性を定義する方法 C# プログラミング ガイド
型 レコード
関連項目
C# プログラミング ガイド
2 つの変数に参照の等価性があるかどうかを確認する方法を説明し ます。
型の値の等価性にカスタムの定義を指定する方法を説明します。 C# 言語の重要な機能に関する詳細情報へのリンクを示します。ま
た、.NET 経由でアクセスできる C# の機能について説明します。 C# 型システムについて説明し、詳細情報へのリンクを示します。
既定で値の等価性をテストするレコード型に関する情報を提供しま す。
                      
           レコードを定義すると、コンパイラにより、値の等価性が自動的に実装されます。 クラスまたは構造体を定義する場合は、型に 値の等価性 (同値) のカスタム定義を作成することが有用かどうかを判断します。 通常、値の等価性を実装するのは、その型 のオブジェクトがある種のコレクションに追加されることが想定されている場合、または、そのオブジェクトの主な目的が一連の フィールドまたはプロパティを格納することである場合です。 値の等価性は、型のすべてのフィールドおよびプロパティの比較に基 づいて定義できます。また、サブセットに基づいて定義することもできます。
いずれの場合も、クラスおよび構造体の両方について、等価性を保証する 5 つの条件に従って実装する必要があります (次の ルールの場合、 x 、 y 、 z が null ではないと想定しています)。
 1. 2. 3.
4.
x.Equals(x) は、 true を返します。 これは再帰プロパティと呼ばれます。
x.Equals(y) からは y.Equals(x) と同じ値が返されます。これは対照プロパティと呼ばれます。
(x.Equals(y) && y.Equals(z)) で true が返される場合、 x.Equals(z) で true が返されます。 これは推移的 プロパティと呼ばれます。
x.Equals(y) が連続して呼び出された場合は、xとyによって参照されるオブジェクトが変更されていない限り、同じ 値を返します。
     5.非null値はnullと等しくありません。ただし、CLRではすべてのメソッド呼び出しでnullがチェックされ、this 参照が nullの場合、 がスローされます。そのため、x.Equals(y) では、x がnullのときに例外が スローされます。 それにより、 の引数に基づき、ルール 1 または 2 が破られます。
構造体を定義すると、Object.Equals(Object) メソッドの System.ValueType オーバーライドから継承された値の等価性が既 定で実装されます。 この実装では、リフレクションを使用して、型のフィールドとプロパティをすべて調べます。 この実装によって正 しい結果が生成されますが、その型専用に記述したカスタム実装と比較すると、処理にかなり時間がかかります。
値の等価性に関する実装の詳細は、クラスと構造体で異なりますが、 等価性を実装するための基本的な手順については、 両方とも同じです。
1. 仮想 Object.Equals(Object) メソッドをオーバーライドします。 ほとんどの場合、 bool Equals( object obj ) の実装 には、System.IEquatable<T> インターフェイスの実装である型固有の メソッドを呼び出すだけで済みます (手順 2 を参照)。
2. 型固有の Equals メソッドを指定して、System.IEquatable<T> インターフェイスを実装します。 ここで実際の等価性 の比較を実行します。たとえば、型のフィールドを1~2個だけ比較することで等価性を定義できます。 Equals から 例外をスローしないでください。 クラスの場合のみ:このメソッドはクラスで宣言されているフィールドのみを調べます。 基底 クラスに含まれるフィールドを調べるには、base.Equals を呼び出す必要があります(Objectから型が直接継承された 場合は、この呼び出しを行わないでください。Object.Equals(Object) の Object 実装では参照の等価性チェックが実 行されるためです)。
3. 推奨、ただし省略可能: == および != 演算子をオーバーロードします。
4. 値の等価性を持つ 2 つのオブジェクトによって同じハッシュ コードが生成されるように、Object.GetHashCode をオー
バーライドします。
5. 省略可能:"大なり" または "小なり" の定義をサポートするには、型に対して IComparable<T> インターフェイスを実装 したうえで、<= および >= 演算子をオーバーロードします。
  NullReferenceException
 Equals
  Equals
   クラスまたは構造体の値の等価性を定義する方法
(C# プログラミング ガイド) 2021/03/16 • • Edit Online
 
  クラスの例
次の例は、クラス (参照型) で値の等価性を実装する方法を示しています。
      NOTE
C# 9.0 以降、レコードを利用し、不要な定型コードなしで値の等価性セマンティクスを取得できます。
  namespace ValueEquality
{
    using System;
    class TwoDPoint : IEquatable<TwoDPoint>
    {
        // Readonly auto-implemented properties.
        public int X { get; private set; }
        public int Y { get; private set; }
        // Set the properties in the constructor.
        public TwoDPoint(int x, int y)
        {
            if ((x < 1) || (x > 2000) || (y < 1) || (y > 2000))
            {
                throw new System.ArgumentException("Point must be in range 1 - 2000");
            }
this.X = x;
this.Y = y; }
        public override bool Equals(object obj)
        {
            return this.Equals(obj as TwoDPoint);
        }
        public bool Equals(TwoDPoint p)
        {
            // If parameter is null, return false.
            if (Object.ReferenceEquals(p, null))
            {
                return false;
            }
            // Optimization for a common success case.
            if (Object.ReferenceEquals(this, p))
            {
                return true;
            }
            // If run-time types are not exactly the same, return false.
            if (this.GetType() != p.GetType())
            {
                return false;
            }
            // Return true if the fields match.
            // Note that the base class is not invoked because it is
            // System.Object, which defines Equals as reference equality.
            return (X == p.X) && (Y == p.Y);
}
        public override int GetHashCode()
        {
            return X * 0x00010000 + Y;
        }
public static bool operator ==(TwoDPoint lhs, TwoDPoint rhs)

      {
        // Check for null on left side.
        if (Object.ReferenceEquals(lhs, null))
        {
            if (Object.ReferenceEquals(rhs, null))
            {
                // null == null = true.
                return true;
            }
            // Only the left side is null.
            return false;
        }
        // Equals handles case of null on right side.
        return lhs.Equals(rhs);
    }
    public static bool operator !=(TwoDPoint lhs, TwoDPoint rhs)
    {
        return !(lhs == rhs);
    }
}
// For the sake of simplicity, assume a ThreeDPoint IS a TwoDPoint.
class ThreeDPoint : TwoDPoint, IEquatable<ThreeDPoint>
{
    public int Z { get; private set; }
    public ThreeDPoint(int x, int y, int z)
        : base(x, y)
    {
        if ((z < 1) || (z > 2000))
        {
            throw new System.ArgumentException("Point must be in range 1 - 2000");
        }
this.Z = z; }
    public override bool Equals(object obj)
    {
        return this.Equals(obj as ThreeDPoint);
    }
    public bool Equals(ThreeDPoint p)
    {
        // If parameter is null, return false.
        if (Object.ReferenceEquals(p, null))
        {
            return false;
        }
        // Optimization for a common success case.
        if (Object.ReferenceEquals(this, p))
        {
            return true;
        }
        // Check properties that this class declares.
        if (Z == p.Z)
        {
            // Let base class check its own fields
            // and do the run-time type comparison.
            return base.Equals((TwoDPoint)p);
} else {
            return false;
        }
}
  
}
      public override int GetHashCode()
    {
        return (X * 0x100000) + (Y * 0x1000) + Z;
    }
    public static bool operator ==(ThreeDPoint lhs, ThreeDPoint rhs)
    {
        // Check for null.
        if (Object.ReferenceEquals(lhs, null))
        {
            if (Object.ReferenceEquals(rhs, null))
            {
                // null == null = true.
                return true;
            }
            // Only the left side is null.
            return false;
        }
        // Equals handles the case of null on right side.
        return lhs.Equals(rhs);
    }
    public static bool operator !=(ThreeDPoint lhs, ThreeDPoint rhs)
    {
        return !(lhs == rhs);
    }
}
class Program
{
    static void Main(string[] args)
    {
} }
ThreeDPoint pointA = new ThreeDPoint(3, 4, 5);
ThreeDPoint pointB = new ThreeDPoint(3, 4, 5);
ThreeDPoint pointC = null;
int i = 5;
Console.WriteLine("pointA.Equals(pointB) = {0}", pointA.Equals(pointB));
Console.WriteLine("pointA == pointB = {0}", pointA == pointB);
Console.WriteLine("null comparison = {0}", pointA.Equals(pointC));
Console.WriteLine("Compare to some other type = {0}", pointA.Equals(i));
TwoDPoint pointD = null;
TwoDPoint pointE = null;
Console.WriteLine("Two null TwoDPoints are equal: {0}", pointD == pointE);
pointE = new TwoDPoint(3, 4);
Console.WriteLine("(pointE == pointA) = {0}", pointE == pointA);
Console.WriteLine("(pointA == pointE) = {0}", pointA == pointE);
Console.WriteLine("(pointA != pointE) = {0}", pointA != pointE);
System.Collections.ArrayList list = new System.Collections.ArrayList();
list.Add(new ThreeDPoint(3, 4, 5));
Console.WriteLine("pointE.Equals(list[0]): {0}", pointE.Equals(list[0]));
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    pointA.Equals(pointB) = True
    pointA == pointB = True
    null comparison = False
  Compare to some other type = False

 Compare to some other type = False
 クラス (参照型) の場合、両方の Object.Equals(Object) メソッドの既定の実装で、参照の等価性の比較は実行されますが、 値の等価性のチェックは実行されません。 実装が仮想メソッドをオーバーライドする場合、その目的は、仮想メソッドに値の等 価性のセマンティクスを提供することです。
== 演算子と != 演算子は、オーバーロードされなくてもクラスで使用できます。ただし、既定の動作として参照の等価性の チェックが実行されます。 クラスで Equals メソッドをオーバーロードする場合は、 == 演算子と != 演算子をオーバーロード することをお勧めしますが、必須ではありません。
構造体の例
次の例は、構造体 (値型) で値の等価性を実装する方法を示しています。
               Two null TwoDPoints are equal: True
        (pointE == pointA) = False
        (pointA == pointE) = False
        (pointA != pointE) = True
        pointE.Equals(list[0]): False
*/ }
  using System;
struct TwoDPoint : IEquatable<TwoDPoint>
{
    // Read/write auto-implemented properties.
    public int X { get; private set; }
    public int Y { get; private set; }
    public TwoDPoint(int x, int y)
        : this()
{
X = x;
Y = x; }
    public override bool Equals(object obj)
    {
        if (obj is TwoDPoint)
        {
            return this.Equals((TwoDPoint)obj);
        }
        return false;
    }
    public bool Equals(TwoDPoint p)
    {
        return (X == p.X) && (Y == p.Y);
    }
    public override int GetHashCode()
    {
return X ^ Y; }
    public static bool operator ==(TwoDPoint lhs, TwoDPoint rhs)
    {
        return lhs.Equals(rhs);
    }
    public static bool operator !=(TwoDPoint lhs, TwoDPoint rhs)
    {
        return !(lhs.Equals(rhs));
    }
}
class Program

   class Program
{
    static void Main(string[] args)
    {
} }
TwoDPoint pointA = new TwoDPoint(3, 4);
TwoDPoint pointB = new TwoDPoint(3, 4);
int i = 5;
// Compare using virtual Equals, static Equals, and == and != operators.
// True:
Console.WriteLine("pointA.Equals(pointB) = {0}", pointA.Equals(pointB));
// True:
Console.WriteLine("pointA == pointB = {0}", pointA == pointB);
// True:
Console.WriteLine("object.Equals(pointA, pointB) = {0}", object.Equals(pointA, pointB));
// False:
Console.WriteLine("pointA.Equals(null) = {0}", pointA.Equals(null));
// False:
Console.WriteLine("(pointA == null) = {0}", pointA == null);
// True:
Console.WriteLine("(pointA != null) = {0}", pointA != null);
// False:
Console.WriteLine("pointA.Equals(i) = {0}", pointA.Equals(i));
// CS0019:
// Console.WriteLine("pointA == i = {0}", pointA == i);
// Compare unboxed to boxed.
System.Collections.ArrayList list = new System.Collections.ArrayList();
list.Add(new TwoDPoint(3, 4));
// True:
Console.WriteLine("pointA.Equals(list[0]): {0}", pointA.Equals(list[0]));
// Compare nullable to nullable and to non-nullable.
TwoDPoint? pointC = null;
TwoDPoint? pointD = null;
// False:
Console.WriteLine("pointA == (pointC = null) = {0}", pointA == pointC);
// True:
Console.WriteLine("pointC == pointD = {0}", pointC == pointD);
TwoDPoint temp = new TwoDPoint(3, 4);
pointC = temp;
// True:
Console.WriteLine("pointA == (pointC = 3,4) = {0}", pointA == pointC);
pointD = temp;
// True:
Console.WriteLine("pointD == (pointC = 3,4) = {0}", pointD == pointC);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    pointA.Equals(pointB) = True
    pointA == pointB = True
    Object.Equals(pointA, pointB) = True
    pointA.Equals(null) = False
    (pointA == null) = False
    (pointA != null) = True
    pointA.Equals(i) = False
    pointE.Equals(list[0]): True
    pointA == (pointC = null) = False
    pointC == pointD = True
    pointA == (pointC = 3,4) = True
    pointD == (pointC = 3,4) = True
*/
  
     構造体の場合、Object.Equals(Object) (System.ValueType でオーバーライドされるバージョン) の既定の実装で、リフレクショ ンを使用して値の等価性のチェックが実行され、型のすべてのフィールドの値が比較されます。実装が構造体の仮想 Equals メソッドをオーバーライドする場合、その目的は、値の等価性のチェックをより効率的に実行することと、オプションで、構造体の フィールドまたはプロパティの一部のサブセットに基づいて比較を行うことです。
== 演算子および != 演算子は、構造体が明示的にその演算子をオーバーロードしない限り、その構造体を操作できません。 関連項目
等価比較
C# プログラミング ガイド
    }
 
      独自の型で参照の等価性の比較をサポートするためにカスタム ロジックを実装する必要はありません。 この機能は、すべての 型に対して Object.ReferenceEquals 静的メソッドとして用意されています。
次の例に、2 つの変数の 参照の等価性、つまり、それらの変数がメモリ内で同一のオブジェクトを参照しているかどうかを確認 する方法を示します。
また、Object.ReferenceEqualsが値型に対して常に false を返す理由と、文字列が等しいかどうかを確認するために ReferenceEquals を使用しない理由を例に示します。
例
   参照の等価性 (同値) をテストする方法 (C# プロ
グラミング ガイド) 2021/03/06 • • Edit Online
  using System;
using System.Text;
namespace TestReferenceEquality
{
    struct TestStruct
    {
        public int Num { get; private set; }
        public string Name { get; private set; }
        public TestStruct(int i, string s) : this()
        {
Num = i;
Name = s; }
}
    class TestClass
    {
        public int Num { get; set; }
        public string Name { get; set; }
    }
    class Program
    {
        static void Main()
        {
            // Demonstrate reference equality with reference types.
            #region ReferenceTypes
            // Create two reference type instances that have identical values.
            TestClass tcA = new TestClass() { Num = 1, Name = "New TestClass" };
            TestClass tcB = new TestClass() { Num = 1, Name = "New TestClass" };
            Console.WriteLine("ReferenceEquals(tcA, tcB) = {0}",
                                Object.ReferenceEquals(tcA, tcB)); // false
            // After assignment, tcB and tcA refer to the same object.
            // They now have reference equality.
            tcB = tcA;
            Console.WriteLine("After assignment: ReferenceEquals(tcA, tcB) = {0}",
                                Object.ReferenceEquals(tcA, tcB)); // true
            // Changes made to tcA are reflected in tcB. Therefore, objects

 // Changes made to tcA are reflected in tcB. Therefore, objects
     Equals 汎用基底クラスのSystem.Objectの実装では、参照が等しいかどうかのチェックを実行しますが、このチェックを使用
 } }
}
// that have reference equality also have value equality.
tcA.Num = 42;
tcA.Name = "TestClass 42";
Console.WriteLine("tcB.Name = {0} tcB.Num: {1}", tcB.Name, tcB.Num);
#endregion
// Demonstrate that two value type instances never have reference equality.
#region ValueTypes
TestStruct tsC = new TestStruct( 1, "TestStruct 1");
// Value types are copied on assignment. tsD and tsC have
// the same values but are not the same object.
TestStruct tsD = tsC;
Console.WriteLine("After assignment: ReferenceEquals(tsC, tsD) = {0}",
                    Object.ReferenceEquals(tsC, tsD)); // false
#endregion
#region stringRefEquality
// Constant strings within the same assembly are always interned by the runtime.
// This means they are stored in the same location in memory. Therefore,
// the two strings have reference equality although no assignment takes place.
string strA = "Hello world!";
string strB = "Hello world!";
Console.WriteLine("ReferenceEquals(strA, strB) = {0}",
                 Object.ReferenceEquals(strA, strB)); // true
// After a new string is assigned to strA, strA and strB
// are no longer interned and no longer have reference equality.
strA = "Goodbye world!";
Console.WriteLine("strA = \"{0}\" strB = \"{1}\"", strA, strB);
Console.WriteLine("After strA changes, ReferenceEquals(strA, strB) = {0}",
                Object.ReferenceEquals(strA, strB)); // false
// A string that is created at runtime cannot be interned.
StringBuilder sb = new StringBuilder("Hello world!");
string stringC = sb.ToString();
// False:
Console.WriteLine("ReferenceEquals(stringC, strB) = {0}",
                Object.ReferenceEquals(stringC, strB));
// The string class overloads the == operator to perform an equality comparison.
Console.WriteLine("stringC == strB = {0}", stringC == strB); // true
#endregion
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    ReferenceEquals(tcA, tcB) = False
    After assignment: ReferenceEquals(tcA, tcB) = True
    tcB.Name = TestClass 42 tcB.Num: 42
    After assignment: ReferenceEquals(tsC, tsD) = False
    ReferenceEquals(strA, strB) = True
    strA = "Goodbye world!" strB = "Hello world!"
    After strA changes, ReferenceEquals(strA, strB) = False
    ReferenceEquals(stringC, strB) = False
    stringC == strB = True
*/

   しないようにお勧めします。クラスがメソッドをオーバーライドする場合、予期した結果が得られない可能性があるためです。 == 演算子と != 演算子についても同様です。 参照型を操作しようとしている場合、 == および != の既定の動作では参照が 等しいかどうかのチェックを実行します。 ただし、派生クラスは演算子をオーバーロードすることによって、値が等しいかどうかの チェックを実行します。 エラーが発生する可能性を最小限に抑えるために、2 つのオブジェクトの参照が等しいかどうかを確認す る必要がある場合は、常に ReferenceEquals を使用することをお勧めします。
同じアセンブリ内の定数文字列は、常に、実行時にインターンされます。 つまり、一意のリテラル文字列ごとにそのインスタンスが 1 つだけ保持されます。 ただし、ランタイムは実行時に作成された文字列がインターンされることを保証しません。また、異なる アセンブリの 2 つの等しい定数文字列がインターンされることも保証しません。
関連項目
等価比較

   型、変数、および値
C# は、厳密に型指定された言語です。 すべての変数および定数は、値に評価されるすべての式がそうであるように、型を持ち ます。 各メソッドの宣言は、各入力パラメーターと戻り値に対して、名前、パラメーターの数、型と種類 (値、参照、または出 力) を指定します。 .NET クラス ライブラリでは、一連の組み込みの数値型や、ファイル システム、ネットワーク接続、オブジェクト のコレクションと配列、日付など、さまざまな論理構造を表すより複雑な型が定義されています。 一般的な C# プログラムは、ク ラス ライブラリの型と、そのプログラムの問題領域に固有の概念をモデル化するユーザー定義の型を使用します。
型には、次のような項目の情報が保存されます。
その型の変数が必要とする記憶領域。 表すことができる最大値と最小値。
含まれるメンバー (メソッド、フィールド、イベントなど)。 継承元となった基本型。 実装されるインターフェイス。 実行時に変数に割り当てられるメモリの場所。 許可される演算の種類。
コンパイラは型情報を使用して、コード内で実行されるすべての演算が "タイプ セーフ" となるようにします。 たとえば、int 型の 変数を宣言すると、その変数は加算演算と減算演算で使用できます。 同じ演算を bool 型の変数に対して実行しようとする と、コンパイラで次の例のようなエラーが発生します。
    int a = 5;
int b = a + 2; //OK
bool test = true;
// Error. Operator '+' cannot be applied to operands of type 'int' and 'bool'.
int c = a + test;
     NOTE
C や C++ と異なり、C# では、bool を int に変換することはできません。
 コンパイラは、型情報を実行可能ファイル内にメタデータとして埋め込みます。 共通言語ランタイム (CLR: Common Language Runtime) は、実行時にこのメタデータを使用して、メモリの割り当て時および再要求時に、タイプ セーフであるかど うかを再度確認します。
変数宣言での型の指定
プログラム内で変数や定数を宣言するときは、その型を指定するか、var キーワードを使用して、コンパイラが型を推論できるよ うにする必要があります。 次の例では、組み込みの数値型と複雑なユーザー定義の型の両方を使用する変数宣言を示しま す。
型 (C# プログラミング ガイド) 2021/03/09 • • Edit Online
 
        メソッドのパラメーターおよび戻り値の型は、メソッドの宣言で指定します。 入力引数として int を使用する必要があり、戻り値 として文字列を返すメソッドのシグネチャを次に示します。
    public string GetName(int ID)
{
    if (ID < names.Length)
        return names[ID];
    else
        return String.Empty;
}
private string[] names = { "Spencer", "Sally", "Doug" };
 変数を宣言した後は、新しい型を使用して再宣言することはできず、宣言された型と互換性のない値を代入することもできま せん。たとえば、intを宣言してから、それに true のブール値を代入することはできません。ただし、たとえば新しい変数に代 入するときや、メソッドの引数として渡すときに、値を他の型に変換することは可能です。 データの損失を伴わない "型変換" は、コンパイラによって自動的に実行されます。 データの損失を伴う可能性のある変換には、ソース コードに cast を記述する 必要があります。
詳細については、「キャストと型変換」を参照してください。 組み込み型
C# には、整数、浮動小数点値、ブール式、テキスト文字、10 進数値などのデータを表現するための標準的な組み込みの型 が用意されています。また、組み込みの string 型や object 型もあります。これらの型は、どのC#プログラムでも使用で きます。 組み込み型の完全な一覧については、組み込みの型に関するページを参照してください。
カスタム型
独自のカスタム型を作成するには、struct、class、interface、enum、および record の各構造体を使用します。 .NET クラス ライブラリ自体が、マイクロソフトによって提供された、ユーザーが独自のアプリケーションで使用できるカスタムの型のコレクションで す。 既定では、クラス ライブラリで最も頻繁に使用される型は任意の C# プログラムで使用可能になっています。 それ以外は、 それらが定義されているアセンブリへのプロジェクト参照を明示的に追加した場合にのみ使用可能になります。 コンパイラがアセ ンブリを参照できるようになると、そのアセンブリ内で宣言されている型の変数 (および定数) をソース コード内で宣言できるように なります。 詳細については、「.NET クラス ライブラリの概要」を参照してください。
共通型システム
.NET で型システムを使用する場合は、次の 2 つの基本事項を理解しておく必要があります。
継承の原則がサポートされています。 他の型から型を派生させることができます。派生元の型は "基本型" と呼ばれます。 派生した型は、基本型のメソッド、プロパティ、およびその他のメンバーを (若干の制限付きで) 継承します。 基本型もなん らかの他の型から派生できます。この場合、派生した型はその継承階層内の両方の基本型のメンバーを継承します。 System.Int32 (C# のキーワードは int) などの組み込み数値型を含むすべての型は、最終的に System.Object (C# の
     // Declaration only:
float temperature;
string name;
MyClass myClass;
// Declaration with initializers (four examples):
char firstLetter = 'C';
var limit = 3;
int[] source = { 0, 1, 2, 3, 4, 5 };
var query = from item in source
            where item <= limit
select item;
 
       キーワードは object) という単一の基本型から派生します。 この一元化された型階層は、共通型システム (CTS) と呼ばれ ます。 C# での継承の詳細については、「継承」を参照してください。
CTS の各型は、"値型" または "参照型" として定義されます。 この型には、.NET クラス ライブラリのすべてのカスタムの型だ けでなく、ユーザーが独自に定義した型も含まれます。 struct キーワードを使用して定義した型は値型であり、すべての組 み込み数値型は structs です。classまたはrecordのキーワードを使用して定義した型は、参照型です。参照型と値 型では、コンパイル時の規則や実行時の動作が異なります。
次の図は、CTS における値型と参照型の関係を示しています。
値型
値型は、System.ValueType の派生型である System.Object から派生します。 System.ValueType から派生した型は、 CLR では特殊な動作をします。 値型の変数は、その値を直接含みます。つまり、変数がどのようなコンテキストで宣言されたと しても、必ずメモリがインラインで割り当てられます。 値型の変数には、独立したヒープ割り当てやガベージ コレクションのオー バーヘッドはありません。
値型には、構造体と列挙体の 2 つのカテゴリがあります。 組み込みの数値型は構造体であり、次のようにしてアクセスできるフィールドとメソッドを持ちます。
ただし、宣言とそこへの値の代入は、あたかも単純な非集約型であるかのように行うことができます。
値型は "シールド" です。つまり、System.Int32 などのどの値型からも型を派生させることはできません。 構造体は System.ValueType からしか継承できないため、ユーザー定義のクラスまたは構造体を継承する構造体を定義することはでき ません。 ただし、構造体は 1 つ以上のインターフェイスを実装できます。 構造体型は、実装する任意のインターフェイス型に
      NOTE
この図を見るとわかるように、最もよく使用される型はすべて System 名前空間に属しています。 しかし、型が属している名前空間は、その 型が値型と参照型のどちらであるかには関係ありません。
     // constant field on type byte.
byte b = byte.MaxValue;
     byte num = 0xA;
int i = 5;
char c = 'Z';
 
          キャストできます。このキャストを行うと、"ボックス化" 操作によって、構造体がマネージド ヒープ上の参照型オブジェクト内にラッ プされます。 ボックス化操作が発生するのは、入力パラメーターとして System.Object または任意のインターフェイス型を受け 取るメソッドに値型を渡した場合です。 詳細については、「ボックス化とボックス化解除」を参照してください。
独自のカスタム値型を作成するには、struct キーワードを使用します。 通常、構造体は、次の例に示すように、少数の関連 する変数のコンテナーとして使用します。
    public struct Coords
{
    public int x, y;
    public Coords(int p1, int p2)
    {
x = p1;
y = p2; }
}
 構造体の詳細については、構造体型に関する記事をご覧ください。 値型の詳細については、値型に関するページを参照して ください。
別の種類の値型として、列挙体があります。 列挙体は、一連の名前付き整数定数を定義します。 たとえば、.NET クラス ライ ブラリの System.IO.FileMode 列挙体には、ファイルを開く方法を指定する一連の名前付き整数定数が格納されています。 こ れは、次の例のように定義されます。
    public enum FileMode
{
    CreateNew = 1,
    Create = 2,
    Open = 3,
    OpenOrCreate = 4,
    Truncate = 5,
    Append = 6,
}
  定数 System.IO.FileMode.Create は、2という値を持ちます。しかし、人間がソースコードを読む場合は名前があるとわかり やすいため、このような場合は、リテラルの数値の定数を使用するよりも、列挙体を使用する方がよいと言えます。 詳細につい ては、「System.IO.FileMode」を参照してください。
すべての列挙体は、System.Enum の派生型である System.ValueType から派生します。 構造体に適用されるすべての規 則が、列挙体にも適用されます。 詳細については、「列挙型」を参照してください。
参照型
class、record、delegate、配列、または interface として定義された型は、"参照型" です。 参照型の変数を宣言した場 合、実行時には、new 演算子によってオブジェクトが明示的に作成されるまで、この変数には null が格納されます。または、 次の例に示すように new を使用して、別の場所で作成されたオブジェクトを割り当てることもできます。
インターフェイスは、それを実装するクラスオブジェクトで一緒に初期化する必要があります。 MyClass が IMyInterface を実 装している場合は、次の例のようにして IMyInterface のインスタンスを作成できます。
    MyClass mc = new MyClass();
MyClass mc2 = mc;
      IMyInterface iface = new MyClass();
 オブジェクトが作成されると、マネージド ヒープ上でメモリが割り当てられ、変数にはそのオブジェクトの場所への参照のみが格納

           されます。 マネージド ヒープを使用する型では、メモリの割り当て時と、CLR の自動メモリ管理機能 ("ガベージ コレクション") に よる再要求時の両方についてオーバーヘッドが発生します。 しかし、ガベージ コレクションも高度に最適化されるため、ほとんど のシナリオでは、パフォーマンス上の問題が発生することはありません。 ガベージ コレクションの詳細については、「自動メモリ管 理」を参照してください。
配列は、その要素が値型の場合でも、すべて参照型です。 配列は、System.Array クラスから暗黙的に派生しますが、C# に 用意されている次の例のような簡単な構文で宣言および使用します。
参照型では、継承が全面的にサポートされています。 クラスの作成時には、シールドとして定義されているものを除く、他のす べてのインターフェイスまたはクラスから継承できます。また、作成したクラスから他のクラスを継承し、仮想メソッドをオーバーライ ドすることもできます。 独自のクラスを作成する方法の詳細については、「クラスおよび構造体」を参照してください。 継承と仮 想メソッドの詳細については、「継承」を参照してください。
リテラル値の型
C# では、リテラル値の型がコンパイラによって決定されます。 数値リテラルの型指定の方法を指定するには、その数値の末尾に 文字を付加します。たとえば、値4.56をfloat型として扱うには、数値の後に"f"または"F"を付加して、4.56f のように指 定します。 文字を付加しない場合、リテラルの型はコンパイラによって推論されます。 文字サフィックスで指定できる型の詳細に ついては、「整数数値型」と「浮動小数点数値型」を参照してください。
リテラルは型指定され、すべての型は最終的に System.Object から派生するため、次のようなコードを記述してコンパイルでき ます。
    // Declare and initialize an array of integers.
int[] nums = { 1, 2, 3, 4, 5 };
// Access an instance property of System.Array.
int len = nums.Length;
     string s = "The answer is " + 5.ToString();
// Outputs: "The answer is 5"
Console.WriteLine(s);
Type type = 12345.GetType();
// Outputs: "System.Int32"
Console.WriteLine(type);
 ジェネリック型
クライアント コードが型のインスタンスを作成したときに提供される実際の型 (具象型) のプレースホルダーとして使用される 1 つ 以上の 型パラメーター で、型を宣言することもできます。 このような型は、ジェネリック型 と呼ばれます。 たとえば、.NET の型 System.Collections.Generic.List<T> には、慣例により T という名前が与えられる 1 つの型パラメーターがあります。この型の インスタンスを作成するときには、たとえば文字列の場合なら、リストに含まれるオブジェクトの型を次のように指定します。
型パラメーターを使用することで、同じクラスを再利用して任意の型の要素を格納できます。このとき、各要素をオブジェクトに 変換する必要はありません。 ジェネリック コレクション クラスが "厳密に型指定されたコレクション" と呼ばれるのは、コレクションの 要素の固有の型をコンパイラが認識しているためで、たとえば、前の例の stringList オブジェクトに整数を追加しようとする と、コンパイル時にエラーが発生します。 詳細については、「ジェネリック」を参照してください。
    List<string> stringList = new List<string>();
stringList.Add("String example");
// compile time error adding a type other than a string:
stringList.Add(4);
  
           暗黙の型、匿名型、および Null 許容値型
前にも説明したとおり、ローカル変数 (クラスのメンバーではない) の型を暗黙的に指定するには、var キーワードを使用します。 変数の型はコンパイル時に決定されますが、その型はコンパイラによって指定されます。 詳細については、「暗黙的に型指定さ れるローカル変数」を参照してください。
メソッドの境界を越えて格納したり受け渡したりする予定のない単純な一連の関連値に名前付きの型を作成するのは便利で はないこともあります。 このような場合は、"匿名型" を作成できます。 詳細については、「匿名型」を参照してください。
通常の値型には、null値を割り当てることができません。しかし、型の後ろに ? を付けることによって、Null許容値型を作成 できます。たとえば、int? は、null値も設定できる int 型です。Null許容値型は一般的な構造体型 System.Nullable<T> のインスタンスです。 Null 許容値型は、数値が null になる可能性のあるデータベースとの間でデータを 受け渡しする場合に、特に便利です。 詳細については、「Null 許容値型」を参照してください。
コンパイル時の型と実行時の型
変数は、コンパイル時と実行時で型が異なる場合があります。 "コンパイル時の型" は、ソースコード内の変数の宣言または推 論された型です。 "実行時の型" は、その変数によって参照されるインスタンスの型です。 次の例に示すように、多くの場合、こ れら 2 つの型は同じです。
そうでない場合、次の 2 つの例に示すように、コンパイル時の型が異なります。
前の例はどちらも、実行時の型が string です。 コンパイル時の型は最初が object 、2 番目が IEnumerable<char> で す。
変数の 2 つの型が異なる場合は、コンパイル時の型と実行時の型が適用されるタイミングを理解することが重要です。 コンパイ ル時の型によって、コンパイラによって実行されるすべてのアクションが決まります。 これらのコンパイラ アクションには、メソッド呼び 出しの解決、オーバーロードの解決、使用できる暗黙的および明示的なキャストが含まれます。 実行時の型によって、実行時 に解決されるすべてのアクションが決まります。 この実行時のアクションには、仮想メソッド呼び出しのディスパッチ、 is と
switch の式と、その他の型のテストAPIの評価が含まれます。コードが型とどのように対話するかを理解するには、どのアク ションがどの型に適用されるかを認識してください。
関連項目 詳細については、次の記事を参照してください。
キャストと型変換 ボックス化とボックス化解除 dynamic 型の使用
値型
参照型 クラスと構造体 匿名型 ジェネリック
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
  string message = "This is a string of characters";
     object anotherMessage = "This is another string of characters";
IEnumerable<char> someCharacters = "abcdefghijklmnopqrstuvwxyz";
     
    す。 関連項目
C# リファレンス
C# プログラミング ガイド XML データ型の変換 整数型

               C# はコンパイル時 (変数が宣言された後) に静的に型指定されるため、その型が変数の型に暗黙的に変換可能でない限り、 再び宣言したり、別の型の値を代入したりすることはできません。 たとえば、 string を int に暗黙的に変換することはでき ません。 そのため、次のコードに示すように、 i を int として宣言した後、"Hello" という文字列を代入することはできませ ん。
しかし場合によっては、別の型の変数やメソッドのパラメーターに値をコピーする必要が生じることもあります。 たとえば、パラメー ターが double として型指定されたメソッドに、整数の変数を渡す必要が生じることもあるでしょう。 また、クラス変数をインター フェイス型の変数に代入しなければならない場合もあるかもしれません。 この種の操作は、型変換と呼ばれます。 C# では、次 のような変換を実行できます。
暗黙的な変換: この変換は常に成功し、データが失われることがないため、特別な構文は必要ありません。 例として は、小さい整数型から大きい整数型への変換や、派生クラスから基底クラスへの変換が挙げられます。
明示的な変換 (キャスト) : 明示的な変換には、キャスト式が必要です。 変換時に情報が失われる可能性がある場 合や、その他の理由によって変換が成功しない可能性がある場合には、キャストが必要です。 典型的な例としては、 より精度の低い型 (または、より範囲が狭い型) に数値を変換する場合や、基底クラスのインスタンスを派生クラスに変 換する場合が挙げられます。
ユーザー定義の変換: ユーザー定義の変換は特殊なメソッドによって実行されます。これを定義することで、基本クラス と派生クラスの関係がないカスタム型間の明示的および暗黙的な変換が可能になります。 詳細については、「ユーザー 定義の変換演算子」 に関するページを参照してください。
ヘルパー クラスを使用する変換: 整数と System.DateTime オブジェクトの間、16 進文字列とバイト配列の間など、 互換性のない型の間で変換を行うには、System.BitConverter クラス、System.Convert クラス、および組み込み数 値型の Parse メソッド(Int32.Parseなど)を使用できます。詳細については、「バイト配列をintに変換する方法」、 「文字列を数値に変換する方法」、および「16 進文字列と数値型の間で変換する方法」を参照してください。
暗黙の変換
組み込みの数値型の場合、格納される値を切り捨てたり丸めたりしなくても変数に収めることができるのであれば、暗黙的な 変換を実行できます。 整数型の場合、これは、ソースの型の範囲が、ターゲットの型の範囲の適切なサブセットであるという意 味です。 たとえば、long 型の変数 (64 ビットの整数) は、int (32 ビットの整数) が格納できる任意の値を格納できます。 次の 例の場合、コンパイラは右側の num の値を bigNum に代入する前に、この値を long 型へと暗黙的に変換します。
すべての暗黙的な数値変換の完全なリストについては、組み込みの数値変換に関する記事の「暗黙的な数値変換」セクショ ンを参照してください。
     int i;
// error CS0029: Cannot implicitly convert type 'string' to 'int'
i = "Hello";
       // Implicit conversion. A long can
// hold any value an int can hold, and more!
int num = 2147483647;
long bigNum = num;
 参照型の場合は、特定のクラスから、その直接または間接的な基底クラスやインターフェイスに対して、常に暗黙的な変換が
キャストと型変換 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     存在します。 派生クラスには常に基底クラスのすべてのメンバーが含まれるため、特別な構文は必要ありません。
    Derived d = new Derived();
// Always OK.
Base b = d;
 明示的な変換
変換によって情報が失われるリスクがある場合は、コンパイラで明示的な変換を実行する必要があります。これをキャストと呼び ます。 キャストとは、変換を行う意図があることと、データが損失する可能性かランタイム時にキャストが失敗する可能性を認識 していることをコンパイラに明示的に知らせるための方法です。 キャストを実行するには、変換する値または変数の前に、キャス トする型をかっこで囲んで指定します。 次のプログラでは、double を int にキャストしています。このプログラムは、キャストなしで はコンパイルされません。
    class Test {
    static void Main()
    {
        double x = 1234.7;
        int a;
        // Cast double to int.
        a = (int)x;
        System.Console.WriteLine(a);
} }
// Output: 1234
 サポートされる明示的な数値変換の完全なリストについては、組み込みの数値変換に関する記事の「明示的な数値変換」セ クションを参照してください。
参照型の場合は、基本型から派生型に変換する必要がある場合に、明示的なキャストが必要です。
    // Create a new derived type.
Giraffe g = new Giraffe();
// Implicit conversion to base type is safe.
Animal a = g;
// Explicit conversion is required to cast back
// to derived type. Note: This will compile but will
// throw an exception at run time if the right-side
// object is not in fact a Giraffe.
Giraffe g2 = (Giraffe)a;
 参照型の間でキャスト操作を行っても、基になるオブジェクトの実行時の型は変わりません。そのオブジェクトへの参照として使 用される値の型だけが変更されます。 詳細については、「ポリモーフィズム」を参照してください。
実行時に発生する型変換の例外
一部の参照型変換では、キャストが有効になるかどうかをコンパイラで判断できません。 キャスト操作が正しくコンパイルされて も、実行時に失敗する可能性があります。 次の例に示すように、型キャストが実行時に失敗すると、InvalidCastException がスローされます。

           Test メソッドには Animal パラメーターがあるため、引数 a を Reptile に明示的にキャストすると、物騒な想定が行われ ます。 想定しない方が安全です。むしろ、型を確認してください。 C# では、キャストの実行前に互換性をテストできるよう、is 演算子が提供されています。 詳細については、「パターン マッチング、is 演算子、as 演算子を使用して安全にキャストする方 法」を参照してください。
C# 言語仕様
詳細については、C# 言語仕様の変換に関するセクションを参照してください。
関連項目
C# プログラミング ガイド
型
キャスト式 ユーザー定義の変換演算子 一般的な型変換 文字列を数値に変換する方法
   class Animal
{
    public void Eat() => System.Console.WriteLine("Eating.");
    public override string ToString() => "I am an animal.";
}
class Reptile : Animal { }
class Mammal : Animal { }
class UnSafeCast
{
    static void Main()
    {
        Test(new Mammal());
        // Keep the console window open in debug mode.
        System.Console.WriteLine("Press any key to exit.");
        System.Console.ReadKey();
}
    static void Test(Animal a)
    {
} }
// System.InvalidCastException at run time
// Unable to cast object of type 'Mammal' to type 'Reptile'
Reptile r = (Reptile)a;
 
      ボックス化とは、値型から object 型、またはその値型によって実装されている任意のインターフェイス型へ変換するプロセスの ことです。 共通言語ランタイム (CLR) により値型がボックス化されるとき、値は System.Object インスタンス内部にラップされ、 マネージド ヒープに格納されます。 ボックス化解除すると、値型がオブジェクトから抽出されます。 ボックス化は暗黙的に行わ れ、ボックス化解除すると明示的になります。 ボックス化とボックス化解除の概念は、任意の型の値をオブジェクトとして扱うとい う C# の型システムの統一されたビューに基づいています。
次の例では、整数の変数 i を"ボックス化"し、オブジェクト o に代入しています。
次に、オブジェクト o は、次のようにボックス化解除し、整数の変数 i に代入できます。
次のコードは、C# でのボックス化の使用例です。
    int i = 123;
// The following line boxes i.
object o = i;
     o = 123;
i = (int)o;  // unboxing
     byte[] array = { 0x64, 0x6f, 0x74, 0x63, 0x65, 0x74 };
string hexValue = Convert.ToHexString(array);
Console.WriteLine(hexValue);
/*Output:
  646F74636574
*/
 パフォーマンス
簡単な代入と比べて、ボックス化およびボックス化解除は負荷の大きいプロセスです。 値型をボックス化するときは、新しいオブ ジェクトを割り当てて構築する必要があります。 ボックス化ほどではありませんが、ボックス化解除に必要なキャストも大きな負 荷がかかります。 詳しくは、「パフォーマンス」をご覧ください。
ボックス化
ボックス化は、値型をガベージコレクションヒープに格納するために使用します。ボックス化とは、値型から object 型、または その値型によって実装されている任意のインターフェイス型への暗黙の変換のことです。 値型をボックス化すると、オブジェクト イ ンスタンスがヒープに割り当てられ、値が新しいオブジェクトにコピーされます。
値型の変数の宣言例を次に示します。
   int i = 123;
 次のステートメントは、変数 i にボックス化を暗黙的に適用します。
ボックス化とボックス化解除 (C# プログラミン
グ ガイド) 2020/11/02 • • Edit Online
 
  このステートメントによって、ヒープ上にある o 型の値を参照するオブジェクト参照 int がスタック上に作成されます。この値 は、変数 i に割り当てられた値型の値のコピーです。2つの変数 i と o の違いを次のボックス化変換の図に示します。
次の例に示すように、明示的にボックス化を実行することもできますが、明示的なボックス化は不要です。
説明
ここでは、ボックス化を使用して整数の変数 i をオブジェクト o に変換する例を示します。 変換後に、変数 i の値を
123 から 456 に変更します。この例は、元の値型とボックス化されたオブジェクトが別個のメモリ位置を使用するため、それぞ
れ別々の値を格納できることを示しています。 例
     int i = 123;
object o = (object)i;  // explicit boxing
     class TestBoxing
{
    static void Main()
    {
} }
int i = 123;
// Boxing copies the value of i into object o.
object o = i;
// Change the value of i.
i = 456;
// The change in i doesn't affect the value stored in o.
System.Console.WriteLine("The value-type value = {0}", i);
System.Console.WriteLine("The object-type value = {0}", o);
/* Output:
    The value-type value = 456
    The object-type value = 123
*/
 ボックス化解除
ボックス化解除とは、 object 型から値型へ、またはインターフェイス型からそのインターフェイスを実装している値型への明示的 な変換のことです。 ボックス化解除では、次の処理が行われます。
オブジェクト インスタンスが、指定された値型のボックス化された値であることを確認します。 インスタンスの値を値型の変数にコピーします。
    // Boxing copies the value of i into object o.
object o = i;
 
   次のステートメントに、ボックス化およびボックス化解除の両方を示します。
    int i = 123;
object o = i;
int j = (int)o;
// a value type
// boxing
// unboxing
 前のステートメントの結果は、次の図に示すとおりです。
実行時に値型のボックス化解除を成功させるには、ボックス化解除の対象項目が、同じ値型のインスタンスのボックス化によっ て既に作成済みのオブジェクトへの参照である必要があります。 null をボックス化解除しようとすると NullReferenceException が発生します。 互換性のない値型への参照をボックス化解除しようとする と、InvalidCastException が発生します。
例
次の例は、無効なボックス化解除の結果、 InvalidCastException が発生する場合を示しています。 try と catch を使 用すると、エラーの発生時にエラー メッセージが表示されます。
      class TestUnboxing
{
    static void Main()
    {
        int i = 123;
        object o = i;  // implicit boxing
try {
            System.Console.WriteLine("Unboxing OK.");
        }
        catch (System.InvalidCastException e)
        {
            System.Console.WriteLine("{0} Error: Incorrect unboxing.", e.Message);
        }
} }
int j = (short)o;  // attempt to unbox
 このプログラムの出力を以下に示します。
 Specified cast is not valid. Error: Incorrect unboxing.
エラーを修正するには、次のステートメントを変更します。
   int j = (short) o;
 この行を次のように変更します。

    ステートメントを変更すると、変換が実行されて次の出力が得られます。
 Unboxing OK.
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミング ガイド 参照型
値型
 int j = (int) o;
 
                  次の例では、BitConverter クラスを使用して、バイト配列を int に変換する方法、またバイト配列に戻す方法を示していま す。 たとえば、ネットワークからバイトを読み込んだ後、バイトから組み込みデータ型への変換が必要になる場合があります。 こ の例の ToInt32(Byte[], Int32) メソッド以外にも、バイト列を (バイト配列から) 他の組み込み型に変換する BitConverter ク ラスのメソッドがあります。次の表にそれらのメソッドを示します。
bool ToBoolean(Byte[], Int32) char ToChar(Byte[], Int32) double ToDouble(Byte[], Int32) short ToInt16(Byte[], Int32) int ToInt32(Byte[], Int32) long ToInt64(Byte[], Int32) float ToSingle(Byte[], Int32) ushort ToUInt16(Byte[], Int32) uint ToUInt32(Byte[], Int32) ulong ToUInt64(Byte[], Int32)
例
この例では、バイトの配列を初期化して、コンピューター アーキテクチャがリトル エンディアンである場合 (つまり、下位バイトから 先に格納する場合)は、配列を反転します。次に、ToInt32(Byte[],Int32)メソッドを呼び出して、配列内の4バイトを int に変換します。 ToInt32(Byte[], Int32) の 2 番目の引数は、バイト配列の開始インデックスを指定します。
                                                NOTE
出力は、コンピューター アーキテクチャのエンディアンによって異なる場合があります。
 バイト配列を int に変換する方法 (C# プログラミ
ング ガイド) 2021/03/06 • • Edit Online
 
      例
この例では、BitConverterクラスのGetBytes(Int32)メソッドを呼び出して、int をバイト配列に変換します。
    NOTE
出力は、コンピューター アーキテクチャのエンディアンによって異なる場合があります。
     byte[] bytes = BitConverter.GetBytes(201805978);
Console.WriteLine("byte array: " + BitConverter.ToString(bytes));
// Output: byte array: 9A-50-07-0C
 関連項目
BitConverter IsLittleEndian 型
   byte[] bytes = { 0, 0, 0, 25 };
// If the system architecture is little-endian (that is, little end first),
// reverse the byte array.
if (BitConverter.IsLittleEndian)
    Array.Reverse(bytes);
int i = BitConverter.ToInt32(bytes, 0);
Console.WriteLine("int: {0}", i);
// Output: int: 25
 
                string を数値に変換するには、数値型 ( int 、 long 、 double など) で見つかる Parse または TryParse メソッドを呼 び出すか、System.Convert クラスのメソッドを使用します。
メソッド(たとえば )または Parse メソッド(たとえば
) を呼び出す方がいくらか効率的で簡単です。 IConvertible を実装している一般的なオブ
ジェクトでは、Convert メソッドを使用するのがより便利です。
文字列に含まれていると思われる数値型(System.Int32型など)の Parse または TryParse メソッドを使用します。 Convert.ToInt32メソッドは、Parseを内部的に使用します。 Parse メソッドからは、変換された数値が返されます。
TryParse メソッドからは変換が成功したかどうかを示すブール値が返され、変換された数値は out パラメーターで戻されま す。 文字列の形式が無効である場合、 Parse では例外がスローされますが、 TryParse では false が返されます。
Parse メソッドを呼び出すときは常に例外処理を使用し、解析操作が失敗したときのFormatExceptionをキャッチする必要 があります。
Parse または TryParse メソッドを呼び出す
文字列の先頭と末尾の空白文字は、 Parse および メソッドによって無視されますが、その他のすべての文字は、 適切な数値型 ( int 、 long 、 ulong 、 float 、 など) を形成する文字である必要があります。 数値を形成する 文字列内に空白文字があると、エラーになります。 たとえば、"10"、"10.3"、または " 10 " を解析するために
decimal.TryParse を使用することはできますが、"10X"、"10"(埋め込みスペースに注意)、"10.3"(埋め込みスペースに注 意)、"10e1"(この場合は float.TryParse を使用)などからこのメソッドを使用して10を解析することはできません。値が
null またはString.Emptyの文字列は正常に解析できません。String.IsNullOrEmptyメソッドを呼び出すことで、解析を 試みる前に null または空の文字列を確認できます。
次の例は、 Parse および TryParse の呼び出しの成功例と失敗例の両方を示しています。
  TryParse
int.TryParse("11", out number)
 var number = int.Parse("11")
    TryParse
 decimal
   文字列を数値に変換する方法 (C# プログラミン
グ ガイド) 2021/03/08 • • Edit Online
 
      次の例は、先頭に数字 (16 進数文字を含む)、末尾に数字以外の文字を含むと予想される文字列を解析する 1 つのアプ ローチを示しています。 TryParse メソッドを呼び出す前に、文字列の先頭から新しい文字列に有効な文字を割り当てます。 解析対象の文字列には少数の文字が含まれるので、例では String.Concat メソッドを呼び出して新しい文字列に有効な文
  using System;
public static class StringConversion
{
    public static void Main()
    {
        string input = String.Empty;
        try
        {
            int result = Int32.Parse(input);
            Console.WriteLine(result);
        }
        catch (FormatException)
        {
            Console.WriteLine($"Unable to parse '{input}'");
        }
        // Output: Unable to parse ''
try {
            Console.WriteLine(numVal);
        }
        catch (FormatException e)
        {
            Console.WriteLine(e.Message);
        }
        // Output: -105
        if (Int32.TryParse("-105", out int j))
        {
            Console.WriteLine(j);
        }
else {
            Console.WriteLine("String could not be parsed.");
        }
        // Output: -105
try {
            int m = Int32.Parse("abc");
        }
        catch (FormatException e)
        {
            Console.WriteLine(e.Message);
        }
        // Output: Input string was not in a correct format.
        const string inputString = "abc";
        if (Int32.TryParse(inputString, out int numValue))
        {
            Console.WriteLine(numValue);
        }
else {
            Console.WriteLine($"Int32.TryParse could not parse '{inputString}' to an int.");
        }
        // Output: Int32.TryParse could not parse 'abc' to an int.
    }
}
int numVal = Int32.Parse("-105");

     字を割り当てます。 より大きな文字列の場合は、代わりに StringBuilder クラスを使用できます。
    using System;
public static class StringConversion
{
    public static void Main()
    {
        var str = "  10FFxxx";
        string numericString = string.Empty;
        foreach (var c in str)
        {
            // Check for numeric characters (hex in this case) or leading or trailing spaces.
            if ((c >= '0' && c <= '9') || (char.ToUpperInvariant(c) >= 'A' && char.ToUpperInvariant(c) <=
'F') || c == ' ')
            {
                numericString = string.Concat(numericString, c.ToString());
} else {
break; }
}
        if (int.TryParse(numericString, System.Globalization.NumberStyles.HexNumber, null, out int i))
        {
            Console.WriteLine($"'{str}' --> '{numericString}' --> {i}");
        }
        // Output: '  10FFxxx' --> '  10FF' --> 4351
        str = "   -10FFXXX";
        numericString = "";
        foreach (char c in str)
        {
            // Check for numeric characters (0-9), a negative sign, or leading or trailing spaces.
            if ((c >= '0' && c <= '9') || c == ' ' || c == '-')
            {
                numericString = string.Concat(numericString, c);
            }
else {
break; }
}
        if (int.TryParse(numericString, out int j))
        {
            Console.WriteLine($"'{str}' --> '{numericString}' --> {j}");
        }
        // Output: '   -10FFXXX' --> '   -10' --> -10
    }
}
 Convert メソッドを呼び出す
文字列を数値に変換するために使用できる Convert クラスのメソッドの一部を次の表に示します。
decimal ToDecimal(String) float ToSingle(String)
           
                 double
short
int
long
ushort
uint
ulong
ToDouble(String) ToInt16(String) ToInt32(String) ToInt64(String) ToUInt16(String) ToUInt32(String) ToUInt64(String)
                           次の例では、Convert.ToInt32(String) メソッドを呼び出して、入力文字列を int に変換します。例では、このメソッドからス ローされる可能性のある最も一般的な 2 種類の例外 (FormatException と OverflowException) をキャッチします。 Int32.MaxValue を超えずに結果の数値を増やすことができる場合、例では結果に 1 を加算し、出力を表示します。

   using System;
public class ConvertStringExample1
{
    static void Main(string[] args)
    {
        int numVal = -1;
        bool repeat = true;
        while (repeat)
        {
            Console.Write("Enter a number between −2,147,483,648 and +2,147,483,647 (inclusive): ");
            string input = Console.ReadLine();
            // ToInt32 can throw FormatException or OverflowException.
            try
            {
                numVal = Convert.ToInt32(input);
                if (numVal < Int32.MaxValue)
                {
                    Console.WriteLine("The new value is {0}", ++numVal);
                }
else {
                    Console.WriteLine("numVal cannot be incremented beyond its current value");
                }
           }
            catch (FormatException)
            {
} }
    Console.WriteLine("Input string is not a sequence of digits.");
}
catch (OverflowException)
{
    Console.WriteLine("The number cannot fit in an Int32.");
}
Console.Write("Go again? Y/N: ");
string go = Console.ReadLine();
if (go.ToUpper() != "Y")
{
    repeat = false;
}
}
// Sample Output:
//   Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive): 473
//   The new value is 474
//   Go again? Y/N: y
//   Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive): 2147483647
//   numVal cannot be incremented beyond its current value
//   Go again? Y/N: y
//   Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive): -1000
//   The new value is -999
//   Go again? Y/N: n
   
       以下の例では、次のタスクを実行する方法について説明します。 string の各文字の 16 進値を取得する。
16 進文字列の各値に対応する char を取得する。
16進 string をintに変換する。
16進 string をfloatに変換する。 バイト配列を16進 string に変換する。
例
この例では、string の各文字の16進値を出力しています。まず string を解析し、文字配列に変換します。次いで、そ の数値を取得するために、各文字でToInt32(Char)を呼び出します。最後に、その数を16進表現で string に書式設定 します。
          string input = "Hello World!";
char[] values = input.ToCharArray();
foreach (char letter in values)
{
    // Get the integral value of the character.
    int value = Convert.ToInt32(letter);
    // Convert the integer value to a hexadecimal value in string form.
    Console.WriteLine($"Hexadecimal value of {letter} is {value:X}");
}
/* Output:
    Hexadecimal value of H is 48
    Hexadecimal value of e is 65
    Hexadecimal value of l is 6C
    Hexadecimal value of l is 6C
    Hexadecimal value of o is 6F
    Hexadecimal value of   is 20
    Hexadecimal value of W is 57
    Hexadecimal value of o is 6F
    Hexadecimal value of r is 72
    Hexadecimal value of l is 6C
    Hexadecimal value of d is 64
    Hexadecimal value of ! is 21
*/
 例
この例は、16進値の string を解析し、各16進値に対応する文字を出力しています。まず、Split(Char[])メソッドを呼び 出して、各16進値を配列内の個別の string として取得します。次いでToInt32(String,Int32)を呼び出し、16進数値 を int の 10 進数値に変換します。ここでは、その文字コードに対応する文字を取得するための 2 つの方法を示しています。 1 つは、ConvertFromUtf32(Int32)を使用する方法です。これは、整数引数に対応する文字を string として返します。も う1つは、int を明示的にcharにキャストする方法です。
   16 進文字列と数値型の間で変換する方法 (C# プ
ログラミング ガイド) 2021/03/06 • • Edit Online
 
      例
この例では、Parse(String,NumberStyles)メソッドを呼び出し、16進数 string を整数に変換する、別の方法を示しま す。
例
次の例では、System.BitConverterクラスおよびUInt32.Parseメソッドを使用して、16進数の string をfloatに変換する 方法を示します。
     string hexString = "8E2";
int num = Int32.Parse(hexString, System.Globalization.NumberStyles.HexNumber);
Console.WriteLine(num);
//Output: 2274
      string hexString = "43480170";
uint num = uint.Parse(hexString, System.Globalization.NumberStyles.AllowHexSpecifier);
byte[] floatVals = BitConverter.GetBytes(num);
float f = BitConverter.ToSingle(floatVals, 0);
Console.WriteLine("float convert = {0}", f);
// Output: 200.0056
 例
次の例は、System.BitConverter クラスを使用して byte 配列を 16 進文字列に変換する方法を示します。
   string hexValues = "48 65 6C 6C 6F 20 57 6F 72 6C 64 21";
string[] hexValuesSplit = hexValues.Split(' ');
foreach (string hex in hexValuesSplit)
{
    // Convert the number expressed in base-16 to an integer.
    int value = Convert.ToInt32(hex, 16);
    // Get the character corresponding to the integral value.
    string stringValue = Char.ConvertFromUtf32(value);
    char charValue = (char)value;
    Console.WriteLine("hexadecimal value = {0}, int value = {1}, char value = {2} or {3}",
                        hex, value, stringValue, charValue);
}
/* Output:
    hexadecimal value = 48, int value = 72, char value = H or H
    hexadecimal value = 65, int value = 101, char value = e or e
    hexadecimal value = 6C, int value = 108, char value = l or l
    hexadecimal value = 6C, int value = 108, char value = l or l
    hexadecimal value = 6F, int value = 111, char value = o or o
    hexadecimal value = 20, int value = 32, char value =   or
    hexadecimal value = 57, int value = 87, char value = W or W
    hexadecimal value = 6F, int value = 111, char value = o or o
    hexadecimal value = 72, int value = 114, char value = r or r
    hexadecimal value = 6C, int value = 108, char value = l or l
    hexadecimal value = 64, int value = 100, char value = d or d
    hexadecimal value = 21, int value = 33, char value = ! or !
*/
 
     例
次の例は、.NET 5.0 で導入された Convert.ToHexString メソッドを呼び出すことによって、byte 配列を 16 進数文字列に変 換する方法を示しています。
    byte[] array = { 0x64, 0x6f, 0x74, 0x63, 0x65, 0x74 };
string hexValue = Convert.ToHexString(array);
Console.WriteLine(hexValue);
/*Output:
  646F74636574
*/
 関連項目
標準の数値書式指定文字列
型 文字列が数値を表しているかどうかを確認する方法
   byte[] vals = { 0x01, 0xAA, 0xB1, 0xDC, 0x10, 0xDD };
string str = BitConverter.ToString(vals);
Console.WriteLine(str);
str = BitConverter.ToString(vals).Replace("-", "");
Console.WriteLine(str);
/*Output:
  01-AA-B1-DC-10-DD
  01AAB1DC10DD
*/
 
     C#4では、dynamic という新しい型が導入されています。この型は静的な型ですが、dynamic 型のオブジェクトは静的な型 チェックをバイパスします。 ほとんどの場合、 object 型を使用する場合と同様に機能します。 コンパイル時には、 dynamic と して型指定された要素はあらゆる操作をサポートすると見なされます。 したがって、オブジェクトが COM API、IronPython など の動的言語、HTML ドキュメント オブジェクト モデル (DOM)、リフレクション、プログラムの他の場所のいずれから値を取得する のかを考慮する必要はありません。 ただし、コードが無効な場合には、実行時にエラーが検出されます。
たとえば、次のコードの インスタンス メソッドにパラメーターが 1 つしかない場合、 メソッドへの最初の呼び出しは引数を 2 つ含むため、コンパイラはこの呼び出しを無効と認識しま
す。 この呼び出しではコンパイラ エラーが発生します。 dynamic_ec.exampleMethod1(10, 4) メソッドの 2 番目の呼び出しは、 dynamic_ec の型が dynamic であるため、コンパイラによってチェックされません。そのため、コンパイラエラーは報告されませ ん。 ただし、このエラーがいつまでも検出されないということではありません。 実行時に検出されて実行時例外が発生します。
   exampleMethod1
 ec.exampleMethod1(10, 4)
       static void Main(string[] args)
{
    ExampleClass ec = new ExampleClass();
    // The following call to exampleMethod1 causes a compiler error
    // if exampleMethod1 has only one parameter. Uncomment the line
    // to see the error.
    //ec.exampleMethod1(10, 4);
    dynamic dynamic_ec = new ExampleClass();
    // The following line is not identified as an error by the
    // compiler, but it causes a run-time exception.
    dynamic_ec.exampleMethod1(10, 4);
    // The following calls also do not cause compiler errors, whether
    // appropriate methods exist or not.
    dynamic_ec.someMethod("some argument", 7, null);
    dynamic_ec.nonexistentMethod();
}
     class ExampleClass
{
    public ExampleClass() { }
    public ExampleClass(int v) { }
    public void exampleMethod1(int i) { }
    public void exampleMethod2(string str) { }
}
  これらの例におけるコンパイラの役割は、 dynamic として型指定されたオブジェクトまたは式に対して各ステートメントが何を実 行しようとしているかについて、情報をまとめてパッケージ化することです。 格納された情報が実行時に調べられ、無効なステー トメントがある場合は実行時例外が発生します。
ほとんどの動的操作は、結果自体が dynamic です。たとえば、次の例では testSum を使用している箇所にマウスポイン ターを置くと、IntelliSense によって型が (ローカル変数) dynamic testSum と表示されます。
  dynamic 型の使用 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   結果が dynamic ではない操作を次に示します。 から別の型への変換。
型の引数を含むコンストラクターの呼び出し。
たとえば、次の宣言の testInstance の型は、 dynamic ではなく、 ExampleClass です。
次の「変換」のセクションに変換例を示します。
変換
動的オブジェクトとその他の型との変換は簡単です。 そのため、開発者は動的な動作と動的でない動作を切り替えることがで きます。
次の例に示すように、任意のオブジェクトを動的な型に暗黙的に変換できます。
逆に、 dynamic 型の任意の式に暗黙的な変換を動的に適用できます。
dynamic 型の引数を使用したオーバーロードの解決
メソッド呼び出しの1つ以上の引数が dynamic 型を指定している場合、またはメソッド呼び出しの受信側が dynamic 型で ある場合は、コンパイル時ではなく実行時にオーバーロードの解決が実行されます。 次の例では、唯一のアクセス可能な
exampleMethod2 メソッドが文字列引数を受け取るように定義されている場合、 d1 を引数として送信すると、コンパイラ エ ラーは発生しませんが、実行時例外が発生します。 d1 の実行時の型は int であり、 exampleMethod2 には文字列が必 要であるため、オーバーロードの解決は実行時に失敗します。
 dynamic
  dynamic
     var testInstance = new ExampleClass(d);
     dynamic d1 = 7;
dynamic d2 = "a string";
dynamic d3 = System.DateTime.Today;
dynamic d4 = System.Diagnostics.Process.GetProcesses();
      int i = d1;
string str = d2;
DateTime dt = d3;
System.Diagnostics.Process[] procs = d4;
         // Valid.
ec.exampleMethod2("a string");
// The following statement does not cause a compiler error, even though ec is not
// dynamic. A run-time exception is raised because the run-time type of d1 is int.
ec.exampleMethod2(d1);
// The following statement does cause a compiler error.
//ec.exampleMethod2(7);
 動的言語ランタイム
   dynamic d = 1;
var testSum = d + 3;
// Rest the mouse pointer over testSum in the following statement.
System.Console.WriteLine(testSum);
 
         動的言語ランタイム (DLR) は、.NET Framework 4 に導入された API です。 DLR は、C# の   型だけでなく、 IronPython や IronRuby などの動的プログラミング言語の実装もサポートするインフラストラクチャを提供します。 DLR の詳細 については、「動的言語ランタイムの概要」を参照してください。
COM 相互運用
C# 4 には、Office オートメーション API などの COM API との相互運用エクスペリエンスを強化する複数の機能があります。 こ
の機能強化には、 dynamic 型の使用、および名前付き引数と省略可能な引数の使用が含まれます。
多くのCOMメソッドでは、型を object と指定することによって、引数の型と戻り値の型にバリエーションを持たせることができま す。 このためには、C# で厳密に型指定された変数と連携できるように値の明示的なキャストが必要でした。 -link (C# コンパ イラオプション)オプションを使用してコンパイルする場合、dynamic 型が導入されてCOMシグネチャの object のオカレンス を dynamic 型と同様に処理できるようになったため、ほとんどのキャストを回避できます。たとえば、MicrosoftOfficeExcelス プレッドシートのセルに dynamic 型を使用してアクセスする方法と、 dynamic 型を使用しないでアクセスする方法の対比を次 のステートメントに示します。
           // Before the introduction of dynamic.
((Excel.Range)excelApp.Cells[1, 1]).Value2 = "Name";
Excel.Range range2008 = (Excel.Range)excelApp.Cells[1, 1];
     // After the introduction of dynamic, the access to the Value property and
// the conversion to Excel.Range are handled by the run-time COM binder.
excelApp.Cells[1, 1].Value = "Name";
Excel.Range range2010 = excelApp.Cells[1, 1];
 関連トピック
TITLE
dynamic
動的言語ランタイムの概要
dynamic キーワードの使用法について説明します。
DLR の概要について説明します。DLR は動的言語の一連のサービス を共通言語ランタイム (CLR) に追加するランタイム環境です。
            チュートリアル: 動的オブジェクトの作成と使用
   動的なカスタム オブジェクト、および IronPython ライブラリにアク セスするプロジェクトを作成するための詳細な手順について説明しま す。
    C# の機能を使用して Office 相互運用オブジェクトにアクセスする方 法
    名前付き引数と省略可能な引数、 dynamic 型、および Office API オブジェクトへのアクセスを簡単にするその他の強化機能を使用 するプロジェクトを作成する方法について説明します。
  dynamic
 
            動的オブジェクトは、プロパティやメソッドなどのメンバーを、コンパイル時ではなく実行時に公開します。 これにより、静的な型や 書式に一致しない構造体と連携するオブジェクトを作成することができます。 たとえば、動的オブジェクトを使用して HTML ド キュメント オブジェクト モデル (DOM) を参照することもできます。HTML DOM には、有効な HTML マークアップ要素と属性の 任意の組み合わせを含めることができます。 各 HTML ドキュメントは一意であるため、特定の HTML ドキュメントのメンバーは 実行時に決定されます。HTML要素の属性を参照するための一般的な方法は、属性の名前を要素の GetProperty メソッ ドに渡す方法です。HTML要素 の id 属性を参照するには、まず <div> 要素への参照を取得し、そ の後 を使用します。 動的オブジェクトを使用する場合は、 id 属性を divElement.id と して参照できます。
動的オブジェクトを使用すると、IronPython や IronRuby などの動的言語にも簡単にアクセスできます。 動的オブジェクトを使 用して、実行時に解釈される動的スクリプトを参照することもできます。
動的オブジェクトを参照するには、遅延バインディングを使用します。 C# では、遅延バインディング オブジェクトの型は dynamic として指定します。VisualBasicでは、遅延バインディングオブジェクトの型は Object として指定します。詳しく
は、「dynamic」および「事前バインディングと遅延バインディング」をご覧ください。
カスタムの動的オブジェクトは、System.Dynamic 名前空間内のクラスを使用して作成できます。 たとえば、ExpandoObject を作成し、実行時にそのオブジェクトのメンバーを指定することもできます。 また、DynamicObject クラスを継承する、独自の 型を作成することもできます。 その後、DynamicObject クラスのメンバーをオーバーライドして、実行時の動的機能を提供する ことができます。
このチュートリアルでは、次のタスクを行います。
テキスト ファイルの内容をオブジェクトのプロパティとして動的に公開する、カスタム オブジェクトを作成する。
IronPython ライブラリを使用するプロジェクトを作成する。 必須コンポーネント
このチュートリアルを実行するには、IronPython for .NET が必要です。 最新バージョンを取得するには、ダウンロード ページに 移動します。
カスタム動的オブジェクトの作成
このチュートリアルで作成する最初のプロジェクトでは、テキスト ファイルの内容を検索するカスタムの動的オブジェクトを定義しま す。検索するテキストは、動的プロパティの名前によって指定されます。たとえば、呼び出しコードで dynamicFile.Sample が 指定された場合、動的クラスは "Sample" で始まるすべての行をファイルから取得し、それらを含んだ文字列のジェネリック リスト を返します。 検索では、大文字と小文字を区別しません。 動的クラスでは、2 つの省略可能な引数もサポートされています。 最初の引数は、検索オプションの列挙値です。この引数では、動的クラスが行の先頭、行の末尾、または行内の任意の場所 から一致を検索することを指定します。 2 番目の引数は、動的クラスが検索の前に各行から先頭と末尾の空白をトリミングす
  <div id="Div1">
  divElement.GetProperty("id")
       NOTE
次の手順で参照している Visual Studio ユーザー インターフェイス要素の一部は、お使いのコンピューターでは名前や場所が異なる場合が あります。 これらの要素は、使用している Visual Studio のエディションや独自の設定によって決まります。 詳細については、「IDE をカスタマ イズする」をご覧ください。
  チュートリアル: 動的オブジェクトの作成と使用
(C# および Visual Basic) 2021/03/06 • • Edit Online
 
    ることを指定します。 たとえば、呼び出しコードで と指定された場合、 動的クラスは行内の任意の場所にある "Sample" を検索します。 呼び出しコードで
dynamicFile.Sample(StringSearchOption.StartsWith, false) と指定された場合、動的クラスは、各行の先頭にある "Sample" を検索し、先頭と末尾のスペースは削除しません。 既定では、動的クラスは各行の先頭で一致を検索し、先頭と 末尾のスペースを削除します。
カスタムの動的クラスを作成するには
1. Visual Studio を起動します。
2. [ファイル] メニューの [新規作成] をポイントし、 [プロジェクト] をクリックします。
3. [新しいプロジェクト] ダイアログ ボックスの [プロジェクトの種類] ペインで、 [Windows] が選択されていることを確認 します。[テンプレート]ペインの[コンソールアプリケーション]を選択します。[名前]ボックスに DynamicSample と 入力して、 [OK] をクリックします。 新しいプロジェクトが作成されます。
4. DynamicSample プロジェクトを右クリックし、 [追加] をポイントした後、 [クラス] をクリックします。 [名前] ボックスに ReadOnlyFile と入力して、[OK]をクリックします。ReadOnlyFileクラスを含んだ新しいファイルが追加されます。
5. ReadOnlyFile.cs ファイルまたは ReadOnlyFile.vb ファイルの先頭に、次のコードを追加して System.IO および System.Dynamic 名前空間をインポートします。
6. カスタム動的オブジェクトでは、列挙型を使用して検索条件を決定します。 クラス ステートメントの前に、次の列挙定 義を追加します。
       using System.IO;
using System.Dynamic;
     Imports System.IO
Imports System.Dynamic
     public enum StringSearchOption
{
    StartsWith,
    Contains,
    EndsWith
}
     Public Enum StringSearchOption
    StartsWith
Contains
    EndsWith
End Enum
  7. 次のコード例に示すように、クラス ステートメントを更新して DynamicObject クラスを継承します。
8. ReadOnlyFile クラスに次のコードを追加して、ファイルパスのプライベートフィールドと、ReadOnlyFile クラスのコンス トラクターを定義します。
  class ReadOnlyFile : DynamicObject
     Public Class ReadOnlyFile
    Inherits DynamicObject
    dynamicFile.Sample(StringSearchOption.Contains)
 
      ' Store the path to the file and the initial line count value.
Private p_filePath As String
' Public constructor. Verify that file exists and store the path in
' the private variable.
Public Sub New(ByVal filePath As String)
    If Not File.Exists(filePath) Then
        Throw New Exception("File path does not exist.")
End If
    p_filePath = filePath
End Sub
    9. 次の GetPropertyValue メソッドを ReadOnlyFile クラスに追加します。 メソッドは検索条件を
(入力として) 受け取り、テキスト ファイルから検索条件に一致する行を返します。 れる動的メソッドは、 GetPropertyValue メソッドを呼び出して、それぞれの結果を取得します。
クラスによって提供さ
GetPropertyValue
 ReadOnlyFile
    // Store the path to the file and the initial line count value.
private string p_filePath;
// Public constructor. Verify that file exists and store the path in
// the private variable.
public ReadOnlyFile(string filePath)
{
    if (!File.Exists(filePath))
    {
        throw new Exception("File path does not exist.");
    }
    p_filePath = filePath;
}
 
   public List<string> GetPropertyValue(string propertyName,
                                     StringSearchOption StringSearchOption =
StringSearchOption.StartsWith,
                                     bool trimSpaces = true)
{
    StreamReader sr = null;
    List<string> results = new List<string>();
    string line = "";
    string testLine = "";
try {
sr = new StreamReader(p_filePath);
while (!sr.EndOfStream)
{
    line = sr.ReadLine();
    // Perform a case-insensitive search by using the specified search options.
    testLine = line.ToUpper();
    if (trimSpaces) { testLine = testLine.Trim(); }
    switch (StringSearchOption)
    {
} }
} catch {
case StringSearchOption.StartsWith:
    if (testLine.StartsWith(propertyName.ToUpper())) { results.Add(line); }
    break;
case StringSearchOption.Contains:
    if (testLine.Contains(propertyName.ToUpper())) { results.Add(line); }
    break;
case StringSearchOption.EndsWith:
    if (testLine.EndsWith(propertyName.ToUpper())) { results.Add(line); }
    break;
        // Trap any exception that occurs in reading the file and return null.
        results = null;
    }
finally {
        if (sr != null) {sr.Close();}
    }
    return results;
}
   
         10. GetPropertyValue メソッドの後に、DynamicObjectクラスのTryGetMemberメソッドをオーバーライドする次のコード を追加します。 TryGetMember メソッドは、動的クラスのメンバーが要求され、引数が指定されていない場合に呼び 出されます。 binder 引数には、参照されているメンバーに関する情報が含まれます。 result 引数は、指定したメ ンバーに対して返された結果を参照します。 TryGetMember メソッドはブール値を返します。要求されたメンバーが存 在する場合には true を返し、その他の場合には false を返します。
      // Implement the TryGetMember method of the DynamicObject class for dynamic member calls.
public override bool TryGetMember(GetMemberBinder binder,
                                  out object result)
{
    result = GetPropertyValue(binder.Name);
    return result == null ? false : true;
}
     ' Implement the TryGetMember method of the DynamicObject class for dynamic member calls.
Public Overrides Function TryGetMember(ByVal binder As GetMemberBinder,
                                       ByRef result As Object) As Boolean
    result = GetPropertyValue(binder.Name)
    Return If(result Is Nothing, False, True)
End Function
  11. TryGetMember メソッドの後に、DynamicObjectクラスのTryInvokeMemberメソッドをオーバーライドする次のコード
   Public Function GetPropertyValue(ByVal propertyName As String,
                                 Optional ByVal StringSearchOption As StringSearchOption =
StringSearchOption.StartsWith,
                                 Optional ByVal trimSpaces As Boolean = True) As List(Of String)
    Dim sr As StreamReader = Nothing
    Dim results As New List(Of String)
    Dim line = ""
    Dim testLine = ""
    Try
        sr = New StreamReader(p_filePath)
        While Not sr.EndOfStream
            line = sr.ReadLine()
            ' Perform a case-insensitive search by using the specified search options.
            testLine = UCase(line)
            If trimSpaces Then testLine = Trim(testLine)
            Select Case StringSearchOption
                Case StringSearchOption.StartsWith
                    If testLine.StartsWith(UCase(propertyName)) Then results.Add(line)
                Case StringSearchOption.Contains
                    If testLine.Contains(UCase(propertyName)) Then results.Add(line)
                Case StringSearchOption.EndsWith
                    If testLine.EndsWith(UCase(propertyName)) Then results.Add(line)
            End Select
        End While
    Catch
        ' Trap any exception that occurs in reading the file and return Nothing.
        results = Nothing
    Finally
        If sr IsNot Nothing Then sr.Close()
    End Try
    Return results
End Function
 
   を追加します。 TryInvokeMember メソッドは、動的クラスのメンバーが引数を使用して要求された場合に呼び出され ます。 binder 引数には、参照されているメンバーに関する情報が含まれます。 result 引数は、指定したメンバーに 対して返された結果を参照します。 args 引数には、メンバーに渡される引数の配列が含まれます。 TryInvokeMemberメソッドはブール値を返します。要求されたメンバーが存在する場合には true を返し、その他の 場合には false を返します。
TryInvokeMember メソッドのカスタムバージョンは、1つ目の引数として、前の手順で定義した StringSearchOption 列挙からの値を受け付けます。 メソッドは、2 つ目の引数としてブール値を受け付けます。 引数の 一方または両方が有効な値であれば、それらが メソッドに渡され、結果が取得されます。
     TryInvokeMember
 GetPropertyValue
    // Implement the TryInvokeMember method of the DynamicObject class for
// dynamic member calls that have arguments.
public override bool TryInvokeMember(InvokeMemberBinder binder,
                                     object[] args,
                                     out object result)
{
    StringSearchOption StringSearchOption = StringSearchOption.StartsWith;
    bool trimSpaces = true;
try {
        if (args.Length > 0) { StringSearchOption = (StringSearchOption)args[0]; }
    }
catch {
        throw new ArgumentException("StringSearchOption argument must be a StringSearchOption enum
value.");
}
try {
        if (args.Length > 1) { trimSpaces = (bool)args[1]; }
    }
catch {
        throw new ArgumentException("trimSpaces argument must be a Boolean value.");
    }
    result = GetPropertyValue(binder.Name, StringSearchOption, trimSpaces);
    return result == null ? false : true;
}
 
  12. ファイルを保存して閉じます。
サンプルのテキスト ファイルを作成するには
1. DynamicSample プロジェクトを右クリックし、 [追加] をポイントした後、 [新しい項目] をクリックします。 [インストー
ルされたテンプレート] ペインで [全般] をクリックし、 [テキスト ファイル] テンプレートを選択します。 [名前] ボックス で、既定の名前である TextFile1.txt をそのままにし、 [追加] をクリックします。 新しいテキスト ファイルがプロジェクトに 追加されます。
2. TextFile1.txtファイルに次のテキストをコピーします。
    List of customers and suppliers
Supplier: Lucerne Publishing (https://www.lucernepublishing.com/)
Customer: Preston, Chris
Customer: Hines, Patrick
Customer: Cameron, Maria
Supplier: Graphic Design Institute (https://www.graphicdesigninstitute.com/)
Supplier: Fabrikam, Inc. (https://www.fabrikam.com/)
Customer: Seubert, Roxanne
Supplier: Proseware, Inc. (http://www.proseware.com/)
Customer: Adolphi, Stephan
Customer: Koch, Paul
 3. ファイルを保存して閉じます。
カスタム動的オブジェクトを使用するサンプル アプリケーションを作成するには
1. ソリューション エクスプローラー で、Visual Basic を使用している場合は Module1.vb ファイルを、Visual C# を使用
している場合は Program.cs ファイルをダブルクリックします。
2.Mainプロシージャに次のコードを追加して、TextFile1.txtファイルの ReadOnlyFile クラスのインスタンスを作成します。 このコードは、遅延バインディングを使用して動的メンバーを呼び出し、"Customer" という文字列を含んだテキスト行を 取得します。
    ' Implement the TryInvokeMember method of the DynamicObject class for
' dynamic member calls that have arguments.
Public Overrides Function TryInvokeMember(ByVal binder As InvokeMemberBinder,
                                          ByVal args() As Object,
                                          ByRef result As Object) As Boolean
    Dim StringSearchOption As StringSearchOption = StringSearchOption.StartsWith
    Dim trimSpaces = True
    Try
        If args.Length > 0 Then StringSearchOption = CType(args(0), StringSearchOption)
    Catch
        Throw New ArgumentException("StringSearchOption argument must be a StringSearchOption enum
value.")
    End Try
    Try
        If args.Length > 1 Then trimSpaces = CType(args(1), Boolean)
    Catch
        Throw New ArgumentException("trimSpaces argument must be a Boolean value.")
End Try
    result = GetPropertyValue(binder.Name, StringSearchOption, trimSpaces)
    Return If(result Is Nothing, False, True)
End Function
 
      Dim rFile As Object = New ReadOnlyFile("..\..\TextFile1.txt")
For Each line In rFile.Customer
    Console.WriteLine(line)
Next
Console.WriteLine("----------------------------")
For Each line In rFile.Customer(StringSearchOption.Contains, True)
    Console.WriteLine(line)
Next
 3. ファイルを保存し、Ctrl キーを押しながら F5 キーを押してアプリケーションをビルドし、実行します。
動的言語ライブラリの呼び出し
このチュートリアルで作成する次のプロジェクトでは、動的言語 IronPython で記述されたライブラリにアクセスします。
カスタムの動的クラスを作成するには
1. Visual Studio で、 [ファイル] メニューの [新規作成] をポイントし、 [プロジェクト] をクリックします。
2. [新しいプロジェクト] ダイアログ ボックスの [プロジェクトの種類] ペインで、 [Windows] が選択されていることを確認 します。 [テンプレート] ペインの [コンソール アプリケーション] を選択します。 [名前] ボックスに
DynamicIronPythonSample と入力して、[OK]をクリックします。新しいプロジェクトが作成されます。
3. Visual Basic を使用している場合は、DynamicIronPythonSample プロジェクトを右クリックし、 [プロパティ] をクリック します。 [参照] タブをクリックします。 [追加] ボタンをクリックします。 Visual C# を使用している場合は、ソリューション エクスプローラー で [参照] フォルダーを右クリックし、 [参照の追加] をクリックします。
4. [参照] タブで、IronPython ライブラリがインストールされているフォルダーを参照します。 たとえば、C:\Program Files\IronPython 2.6 for .NET Framework 4.0 です。 IronPython.dll、IronPython.Modules.dll、Microsoft.Scripting.dll、および Microsoft.Dynamic.dll ラ イブラリを選択します。 [OK] をクリックします。
5. Visual Basic を使用している場合は、Module1.vb ファイルを編集します。 Visual C# を使用している場合は、 Program.cs ファイルを編集します。
6. ファイルの先頭に、IronPython ライブラリから Microsoft.Scripting.Hosting および IronPython.Hosting 名前空 間をインポートするための次のコードを追加します。
7. Main メソッドで、IronPython ライブラリをホストする新しい オブジェク トを作成するための次のコードを追加します。 オブジェクトは、IronPython ライブラリ モジュール
       using Microsoft.Scripting.Hosting;
using IronPython.Hosting;
     Imports Microsoft.Scripting.Hosting
Imports IronPython.Hosting
      dynamic rFile = new ReadOnlyFile(@"..\..\TextFile1.txt");
foreach (string line in rFile.Customer)
{
    Console.WriteLine(line);
}
Console.WriteLine("----------------------------");
foreach (string line in rFile.Customer(StringSearchOption.Contains, true))
{
    Console.WriteLine(line);
}
  Microsoft.Scripting.Hosting.ScriptRuntime
  ScriptRuntime
 
   random.py を読み込みます。
    // Set the current directory to the IronPython libraries.
System.IO.Directory.SetCurrentDirectory(
   Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) +
   @"\IronPython 2.6 for .NET 4.0\Lib");
// Create an instance of the random.py IronPython library.
Console.WriteLine("Loading random.py");
ScriptRuntime py = Python.CreateRuntime();
dynamic random = py.UseFile("random.py");
Console.WriteLine("random.py loaded.");
     ' Set the current directory to the IronPython libraries.
My.Computer.FileSystem.CurrentDirectory =
   My.Computer.FileSystem.SpecialDirectories.ProgramFiles &
   "\IronPython 2.6 for .NET 4.0\Lib"
' Create an instance of the random.py IronPython library.
Console.WriteLine("Loading random.py")
Dim py = Python.CreateRuntime()
Dim random As Object = py.UseFile("random.py")
Console.WriteLine("random.py loaded.")
 8. Random.py モジュールを読み込むコードの後に、整数の配列を作成する次のコードを追加します。 配列は random.pyモジュールの shuffle メソッドに渡されます。このメソッドは、配列内の値をランダムに並べ替えします。
     // Initialize an enumerable set of integers.
int[] items = Enumerable.Range(1, 7).ToArray();
// Randomly shuffle the array of integers by using IronPython.
for (int i = 0; i < 5; i++)
{
    random.shuffle(items);
    foreach (int item in items)
    {
        Console.WriteLine(item);
    }
    Console.WriteLine("-------------------");
}
     ' Initialize an enumerable set of integers.
Dim items = Enumerable.Range(1, 7).ToArray()
' Randomly shuffle the array of integers by using IronPython.
For i = 0 To 4
    random.shuffle(items)
    For Each item In items
        Console.WriteLine(item)
    Next
    Console.WriteLine("-------------------")
Next
 9. ファイルを保存し、Ctrl キーを押しながら F5 キーを押してアプリケーションをビルドし、実行します。 関連項目
System.Dynamic System.Dynamic.DynamicObject

     dynamic 型の使用
事前バインディングと遅延バインディング
dynamic
動的なインターフェイスの実装 (Microsoft TechNet からダウンロードできる PDF)

     クラスと構造体は、.NET の共通型システムの 2 つの基本構成です。 クラスと構造体は、どちらも基本的にはデータと動作の セットを 1 つの論理単位としてカプセル化するデータ構造です。 データと動作はクラスまたは構造体の "メンバー" です。このト ピックで後述するように、メソッド、プロパティ、イベントなどが含まれます。
クラスまたは構造体の宣言は、実行時にインスタンスやオブジェクトを作成するために使用する設計図のようなものです。 Person というクラスまたは構造体を定義すると、 Person は型の名前になります。 型 p の変数 Person を宣言して初期
化すると、 p は Person のオブジェクトまたはインスタンスになります。 同じ Person 型のインスタンスを複数作成し、各インス タンスのプロパティとフィールドに異なる値を設定することができます。
クラスは参照型です。 クラスのオブジェクトが作成されると、オブジェクトが割り当てられている変数にはそのメモリへの参照だけが 設定されます。 オブジェクト参照が新しい変数に割り当てられると、新しい変数は元のオブジェクトを参照します。 いずれの変 数も同じデータを参照しているため、1 つの変数に加えられた変更は他の変数にも反映されます。
構造体は値の型です。 構造体が作成されると、構造体が割り当てられている変数にはその構造体の実際のデータが設定さ れます。 構造体が新しい変数に割り当てられると、そのデータがコピーされます。 したがって、新しい変数と元の変数には、同じ データのコピーが別個に含まれることになります。 一方のコピーに対して行われた変更は、もう一方のコピーには影響しません。
一般に、クラスは、より複雑な動作、つまりクラス オブジェクトの作成後に変更されることを意図されたデータをモデル化するため に使用されます。 構造体は、主として構造体の作成後に変更されることを意図しないデータを含む、小規模なデータ構造に 最適です。 C# 9 以降では、主としてオブジェクトの作成後に変更されることを意図していないデータを含むより大規模なデータ 構造で、レコードの種類を使用できるようになりました。
詳細については、クラス、オブジェクト、構造体型、レコードに関する記事をご覧ください。 例
次の例では、 名前空間の CustomClass に3つのメンバー(インスタンスコンストラクター、 という 名前のプロパティ、 という名前のメソッド)があります。 Program クラスの Main メソッドによって のイ ンスタンス (オブジェクト) が作成され、オブジェクトのメソッドとプロパティにはドット表記を使用してアクセスします。
        ProgrammingGuide
Number
   Multiply
CustomClass
クラスと構造体 (C# プログラミング ガイド) 2021/03/09 • • Edit Online
 
      カプセル化
"カプセル化" は、オブジェクト指向プログラミングの原理と言われることもあります。 カプセル化の原理に基づくと、クラスまたは構 造体は、クラスや構造体の外部のコードに対してメンバーがアクセスする方法を指定できます。 クラスやアセンブリの外部からの 使用を意図されていないメソッドや変数は非表示にして、コーディング エラーや悪意のある攻略が生じる潜在性を軽減できま す。
クラスの詳細については、「クラス」および「オブジェクト」を参照してください。 メンバー
すべてのメソッド、フィールド、定数、プロパティ、およびイベントは型で宣言する必要があります。これらは、型の メンバー と呼ば れます。 C# にはグローバル変数やグローバル メソッドはありません (言語によっては、グローバル変数やグローバル メソッドが存 在する場合もあります)。プログラムのエントリポイントである Main メソッドでも、クラスまたは構造体で宣言する必要がありま す。 クラスまたは構造体で宣言できるすべてのメンバーを次に示します。
フィールド
  using System;
namespace ProgrammingGuide
{
   // Class definition.
   public class CustomClass
   {
      // Class members.
      //
      // Property.
      public int Number { get; set; }
      // Method.
      public int Multiply(int num)
      {
          return num * Number;
      }
      // Instance Constructor.
      public CustomClass()
      {
Number = 0; }
}
   // Another class definition that contains Main, the program entry point.
   class Program
   {
      static void Main(string[] args)
      {
         // Create an object of type CustomClass.
         CustomClass custClass = new CustomClass();
         // Set the value of the public property.
         custClass.Number = 27;
         // Call the public method.
         int result = custClass.Multiply(4);
         Console.WriteLine($"The result is {result}.");
} }
}
// The example displays the following output:
//      The result is 108.

                   定数
プロパティ
メソッド コンストラクター イベント ファイナライザー インデクサー 演算子 入れ子にされた型
ユーザー補助
メソッドやプロパティの中には、クラスまたは構造体の外部にあるコード ("クライアント コード" と呼ばれます) から呼び出されたりア クセスされたりするように用意されているものがあります。 その他のメソッドやプロパティは、クラスまたは構造体それ自体でのみ使 用されるようになっています。 意図したクライアント コードだけがアクセスできるように、コードのアクセシビリティを制限することが重 要です。 型やメンバーがクライアント コードにアクセスする方法を指定するには、アクセス修飾子 public、protected、internal、protected internal、private、および private protected を使用します。 既定のアクセシビリ ティは private です。詳細については、「アクセス修飾子」を参照してください。
継承
クラスでは、継承の概念がサポートされます (構造体ではサポートされません)。 他のクラス (基底クラス) から派生するクラスに は、コンストラクターとファイナライザーを除く基底クラスのすべてのパブリック メンバー、プロテクト メンバー、および内部メンバーが 自動的に含まれます。 詳細については、「継承」および「ポリモーフィズム」を参照してください。
クラスは、abstract として宣言することもできます。このようなクラスは、1 つ以上のメソッドの実装を持っていないことを意味しま す。 抽象クラスを直接インスタンス化することはできませんが、他のクラスの基底クラスとして抽象クラスを使用し、不足している 実装を提供することができます。 また、クラスを sealed として宣言して、他のクラスがそのクラスを継承しないようにすることもで きます。 詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。
インターフェイス
クラスと構造体は、複数のインターフェイスを継承できます。 インターフェイスの継承は、そのインターフェイスで定義されたすべて
のメソッドを型が実装することを意味します。 詳細については、「インターフェイス」を参照してください。 ジェネリック型
クラスと構造体は、1 つ以上の型パラメーターを指定して定義できます。 クライアント コードでは、型のインスタンスの作成時に 型を指定します。 たとえば、List<T> 名前空間の System.Collections.Generic クラスは、1 つの型パラメーターを指定して定 義されています。 クライアント コードでは、 List<string> または List<int> のインスタンスを作成して、リストに保持する型を 指定します。 詳細については、「ジェネリック」を参照してください。
静的な型
クラス (構造体ではありません) は、static として宣言できます。 静的クラスには含めることができるのは静的メンバーだけであり、 静的クラスを new キーワードでインスタンス化することはできません。 プログラムが読み込まれると、クラスの 1 つのコピーがメモリ に読み込まれます。そのメンバーには、クラス名を使用してアクセスします。 クラスと構造体は、いずれも静的メンバーを含むこと ができます。 詳細については、「静的クラスと静的クラス メンバー」を参照してください。
   
      入れ子にされた型
クラスまたは構造体は、他のクラスまたは構造体内で入れ子にすることができます。 詳細については、「入れ子にされた型」を 参照してください。
部分型
あるコード ファイルにクラス、構造体、またはメソッドの一部を定義して、別のコード ファイルに他の部分を定義することができま
す。 詳細については、「部分クラスと部分メソッド」を参照してください。 オブジェクト初期化子
明示的にコンストラクターを呼び出さずに、クラス オブジェクトまたは構造体オブジェクト、およびオブジェクトのコレクションのインス タンス化と初期化を行うことができます。 詳細については、「オブジェクト初期化子とコレクション初期化子」を参照してください。
匿名型 永続的に保持したり他のメソッドに渡したりする必要のないデータ構造体のリストを作成する場合など、名前付きクラスを作成
することが適さない状況または不要な状況では、匿名型を使用します。 詳細については、「匿名型」を参照してください。 拡張メソッド
別の型を作成し、元の型に属しているかのようにそのメソッドを呼び出せるようにすることで、派生クラスを作成せずにクラスを "拡張" できます。 詳細については、「拡張メソッド」を参照してください。
暗黙的に型指定されるローカル変数
クラス メソッドや構造体メソッド内では、暗黙の型指定を使用して、コンパイル時に適切な型を判断するようにコンパイラに指
示できます。 詳細については、「暗黙的に型指定されるローカル変数」を参照してください。 レコード
C#9では、クラスまたは構造体の代わりに作成できる参照型である record 型が導入されています。レコードは、不変の型 でデータをカプセル化するための組み込みのビヘイビアーを持つクラスです。 レコードには次の機能があります。
不変プロパティを持つ参照型を作成するための簡潔な構文。 値の等価性。
レコード型の 2 つの変数は、レコード型の定義が同じで、すべてのフィールドについて、両方のレコードの値が等しい場 合、等しいと見なされます。 これは、参照の等価性を使用するクラスとは異なります。クラス型の 2 つの変数が同じオブ ジェクトを参照している場合、これらは等しくなります。
非破壊変異の簡潔な構文。
with 式を使用すると、新しいレコードインスタンスを作成できます。これは既存のインスタンスのコピーですが、指定し たプロパティ値が変更されています。
表示用の組み込みの書式設定。
ToString メソッドを使用すると、レコードの種類名と、パブリックプロパティの名前と値が出力されます。
継承階層のサポート。
レコードは構造体ではなく、内部のクラスであるため、継承がサポートされます。 詳細は、レコードに関するページ参照してください。
  
   C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。
関連項目
C# プログラミング ガイド

     参照型
class として定義された型は、参照型 です。 実行時には、参照型の変数を宣言すると、new 演算子を使用してクラスのイン スタンスを明示的に作成するまで、変数には値 null が格納されています。または、次の例に示すように、別の場所で作成され た可能性がある、互換性のある型のオブジェクトを代入することもできます。
オブジェクトが作成されると、その特定のオブジェクトに対してマネージド ヒープ上で十分なメモリが割り当てられ、変数にはそのオ ブジェクトの場所への参照のみが格納されます。 マネージド ヒープを使用する型では、メモリの割り当て時と、CLR の自動メモリ 管理機能 ("ガベージ コレクション") による再要求時の両方についてオーバーヘッドが発生します。 しかし、ガベージ コレクション も高度に最適化されるため、ほとんどのシナリオでは、パフォーマンス上の問題が発生することはありません。 ガベージ コレクショ ンの詳細については、「自動メモリ管理とガベージ コレクション」を参照してください。
クラスの宣言
クラスは、次の例に示すように、class キーワードと、その後に続ける一意の識別子を使用して宣言します。
class キーワードは、アクセスレベルの後に配置します。この例では、publicが使用されているため、誰でもこのクラスのインス タンスを作成できます。 class キーワードの後にクラスの名前を記述します。クラスの名前を、有効なC#の識別子名にする 必要があります。 定義の残りの部分がクラス本体で、そこで動作とデータを定義します。 クラスのフィールド、プロパティ、メソッ ド、およびイベントは クラス メンバー と総称されます。
オブジェクトの作成
クラスとオブジェクトは、同義的に使用されることがありますが、これらは異なるものです。 クラスはオブジェクトの型を定義します が、オブジェクト自体ではありません。 オブジェクトは、クラスに基づく具体的なエンティティであり、クラスのインスタンスと呼ばれる こともあります。
オブジェクトを作成するには、次のように、new キーワードの後にオブジェクトの基になるクラスの名前を指定します。
クラスのインスタンスを作成すると、そのオブジェクトへの参照が返されます。 前の例の object1 は、 Customer に基づくオブ ジェクトへの参照です。 この参照は、新しいオブジェクトを参照しますが、オブジェクト データ自体を含みません。 実際、オブジェ クト参照は、オブジェクトを作成しなくても作成できます。
    //Declaring an object of type MyClass.
MyClass mc = new MyClass();
//Declaring another object of the same type, assigning it the value of the first object.
MyClass mc2 = mc;
     //[access modifier] - [class] - [identifier]
public class Customer
{
   // Fields, properties, methods and events go here...
}
   Customer object1 = new Customer();
   クラス (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
         上のような、オブジェクトを参照しないオブジェクト参照を作成するのはお勧めしません。実行時にこのような参照を通じてオブ ジェクトへのアクセスを試みると失敗するからです。 ただし、新しいオブジェクトを作成するか、既存のオブジェクトを割り当てると、 このような参照でオブジェクトを参照できるようになります。次に例を示します。
上のコードでは、同じオブジェクトを参照する2つのオブジェクト参照が作成されます。そのため、object3 を通じて行われたオ ブジェクトの変更は、後で object4 を使用するときに反映されます。これは、クラスに基づくオブジェクトが参照によって参照さ れるからです。このためクラスは参照型と呼ばれています。
クラスの継承
クラスは、オブジェクト指向プログラミングの基本的な特性である "継承" を完全にサポートします。 クラスを作成するとき は、sealed として定義されているものを除く、他のすべてのクラスから継承できます。また、作成したクラスから他のクラスを継承 し、クラスの仮想メソッドをオーバーライドすることもできます。 さらに、1 つまたは複数のインターフェイスを実装できます。
継承は、派生 を使用して行われます。派生とは、データの動作の継承元である 基底クラス を使用してクラスを宣言することを 意味します。 基底クラスは、派生クラス名の後に、コロンと基底クラス名を追加して指定します。次に例を示します。
クラスで基底クラスを宣言している場合、基底クラスのすべてのメンバー (コンストラクター以外) が継承されます。 詳細について は、「継承」を参照してください。
C++ と異なり、C# のクラスは 1 つの基底クラスから直接継承することしかできません。 ただし、基底クラス自体が別のクラスを 継承している場合があるため、1 つのクラスに複数の基底クラスが間接的に継承されることもあります。 さらに、クラスは 1 つまた は複数のインターフェイスを直接実装できます。 詳細については、「インターフェイス」を参照してください。
クラスは抽象としても宣言できます。 抽象クラスには、シグネチャ定義が存在し、実装は存在しない抽象メソッドが含まれてい ます。 抽象クラスはインスタンス化できません。 抽象クラスを使用するには、抽象メソッドを実装する派生クラスを介する必要が あります。 これとは対照的に、シール クラスは、他のクラスに派生させることはできません。 詳細については、「抽象クラスとシー ル クラス、およびクラス メンバー」を参照してください。
クラス定義は、別々のソース ファイルに分割できます。 詳細については、「部分クラスと部分メソッド」を参照してください。 例
次の例では、自動実装プロパティ、メソッド、およびコンストラクターという特殊なメソッドをそれぞれ 1 つずつ含むパブリック クラス を定義しています。 詳しくは、プロパティ、メソッド、およびコンス トラクターに関するトピックを参照してください。 このクラスのイン スタンスは、 new キーワードによってインスタンス化されます。
    Customer object3 = new Customer();
Customer object4 = object3;
       public class Manager : Employee
{
    // Employee fields, properties, methods and events are inherited
    // New Manager fields, properties, methods and events go here...
}
  Customer object2;
 
          C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミング ガイド オブジェクト指向プログラミング ポリモーフィズム
識別子名
メンバー メソッド
  using System;
public class Person
{
    // Constructor that takes no arguments:
    public Person()
    {
        Name = "unknown";
    }
    // Constructor that takes one argument:
    public Person(string name)
    {
Name = name; }
    // Auto-implemented readonly property:
    public string Name { get; }
    // Method that overrides the base class (System.Object) implementation.
    public override string ToString()
    {
        return Name;
    }
}
class TestPerson
{
    static void Main()
    {
        // Call the constructor that has no parameters.
        var person1 = new Person();
        Console.WriteLine(person1.Name);
        // Call the constructor that has one parameter.
        var person2 = new Person("Sarah Jones");
        Console.WriteLine(person2.Name);
        // Get the string representation of the person2 instance.
        Console.WriteLine(person2);
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
// Output:
// unknown
// Sarah Jones
// Sarah Jones

    コンストラクター ファイナライザー オブジェクト

               レコードとは、データ モデルを操作するための特殊な構文と動作を提供するクラスです。 クラスについては、「クラス (C# プログラ ミング ガイド)」を参照してください。
レコードを使用する場面 次のシナリオでは、クラスの代わりにレコードを使用することを検討してください。
オブジェクトが不変となる参照型を定義する。 値の等価性に依存するデータ モデルを定義する。
不変性
不変型とは、オブジェクトがインスタンス化された後にそのプロパティまたはフィールドの値を変更できないようにするためのもので す。 不変性は、型をスレッドセーフにする必要がある場合またはハッシュ テーブル内で変化のないハッシュ コードに依存してい る場合に役立ちます。 レコードには、不変型を作成および操作するための簡潔な構文が用意されています。
不変性は、すべてのデータ シナリオに適しているわけではありません。 たとえば、Entity Framework Core では、不変のエン ティティ型を使用した更新がサポートされていません。
値の等価性
レコードにおける値の等価性とは、型が一致し、かつプロパティおよびフィールドの値がすべて一致する場合にレコード型の 2 つ の変数が等しいことを意味します。 クラスなどの他の参照型における等価性とは、参照の等価性を意味します。 つまり、クラス 型の 2 つの変数は、同じオブジェクトを参照する場合、等しいことになります。 2 つのレコード インスタンスが等しいかどうかを判 断するメソッドと演算子では、値の等価性が使用されます。
すべてのデータ モデルが値の等価性に適しているわけではありません。 たとえば、Entity Framework Core では、概念的に 1 つのエンティティであるものに対して、エンティティ型の 1 つのインスタンスだけが確実に使用されるようにするために、参照の等価 性に依存します。 このため、レコード型は Entity Framework Core でエンティティ型として使用するのに適していません。
レコードとクラスの相違点
クラスを宣言およびインスタンス化するのと同じ構文がレコードでも使用できます。キーワード class をキーワード record に 置き換えるだけです。 同様に、継承関係を表す場合も同じ構文がレコードによってサポートされています。 レコードは次の点が クラスとは異なります。
位置指定パラメーターを使用して、不変プロパティを持つ型を作成してインスタンス化することができます。 クラスで参照の等価性または非等価性を示すメソッドと演算子(Object.Equals(Object)や == など)は、レコードでは値 の等価性または非等価性を示します。
with 式を使用すれば、選択したプロパティに新しい値を指定して、不変オブジェクトのコピーを作成することができます。 レコードの ToString メソッドを使用すると、オブジェクトの型名とそのすべてのパブリックプロパティの名前および値を示す書 式設定された文字列が作成されます。
レコードは、別のレコードから継承できます。 レコードはクラスから継承できません。また、クラスはレコードから継承できませ ん。
例
次の例では、位置指定パラメーターを使用してレコードを宣言およびインスタンス化するパブリック レコードを定義します。 次に、 型名とプロパティ値を出力します。
  レコード (C# プログラミング ガイド) 2021/03/16 • • Edit Online
 
    次の例では、レコードでの値の等価性を示します。
    public record Person(string FirstName, string LastName, string[] PhoneNumbers);
public static void Main()
{
    var phoneNumbers = new string[2];
    Person person1 = new("Nancy", "Davolio", phoneNumbers);
    Person person2 = new("Nancy", "Davolio", phoneNumbers);
    Console.WriteLine(person1 == person2); // output: True
    person1.PhoneNumbers[0] = "555-1234";
    Console.WriteLine(person1 == person2); // output: True
    Console.WriteLine(ReferenceEquals(person1, person2)); // output: False
}
 次の例では、with 式を使用して、不変オブジェクトをコピーし、プロパティの1つを変更する方法を示します。
    public record Person(string FirstName, string LastName)
{
    public string[] PhoneNumbers { get; init; }
}
public static void Main()
{
    Person person1 = new("Nancy", "Davolio") { PhoneNumbers = new string[1] };
    Console.WriteLine(person1);
    // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }
    Person person2 = person1 with { FirstName = "John" };
    Console.WriteLine(person2);
    // output: Person { FirstName = John, LastName = Davolio, PhoneNumbers = System.String[] }
    Console.WriteLine(person1 == person2); // output: False
    person2 = person1 with { PhoneNumbers = new string[1] };
    Console.WriteLine(person2);
    // output: Person { FirstName = Nancy, LastName = Davolio, PhoneNumbers = System.String[] }
    Console.WriteLine(person1 == person2); // output: False
    person2 = person1 with { };
    Console.WriteLine(person1 == person2); // output: True
}
 詳細については、「レコード (C# リファレンス)」を参照してください。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
   public record Person(string FirstName, string LastName);
public static void Main()
{
    Person person = new("Nancy", "Davolio");
    Console.WriteLine(person);
    // output: Person { FirstName = Nancy, LastName = Davolio }
}
 
           関連項目
クラス (C# プログラミング ガイド) レコード (C# リファレンス)
C# プログラミング ガイド オブジェクト指向プログラミング ポリモーフィズム
識別子名 メンバー メソッド コンストラクター ファイナライザー オブジェクト

     クラスまたは構造体の定義は、型の動作を指定する設計図に似ています。 オブジェクトは基本的に、設計図に従って割り当 てられて構成されたメモリのブロックです。 プログラムでは、同じクラスのオブジェクトを多数作成できます。 オブジェクトはインスタ ンスとも呼ばれ、名前付きの変数または配列やコレクションに格納できます。 クライアント コードとは、これらの変数を使ってメ ソッドを呼び出し、オブジェクトのパブリック プロパティにアクセスするコードです。 C# などのオブジェクト指向言語では、一般的な プログラムは動的に対話する複数のオブジェクトで構成されています。
構造体インスタンスとクラス インスタンス
クラスは参照型であるため、クラスのオブジェクトの変数は、マネージド ヒープ上のオブジェクトのアドレスへの参照を保持します。 同じ型の 2 番目のオブジェクトが最初のオブジェクトに割り当てられた場合、両方の変数がそのアドレスにあるオブジェクトを参 照します。 この点については、後で詳しく説明します。
クラスのインスタンスは、new 演算子を使って作成されます。 次の例では、 Person が型で、 person1 と person2 がその型 のインスタンスつまりオブジェクトです。
    NOTE
静的な型の動作方法は、ここで説明する動作方法とは異なります。 詳細については、「静的クラスと静的クラス メンバー」を参照してくださ い。
    オブジェクト (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
    構造体は値型であるため、構造体オブジェクトの変数はオブジェクト全体のコピーを保持します。構造体のインスタンスも new 演算子を使って作成できますが、次の例で示すように、これは必要ではありません。
  public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Person(string name, int age)
    {
Name = name;
Age = age; }
    // Other properties, methods, events...
}
class Program
{
    static void Main()
    {
} }
Person person1 = new Person("Leopold", 6);
Console.WriteLine("person1 Name = {0} Age = {1}", person1.Name, person1.Age);
// Declare new person, assign person1 to it.
Person person2 = person1;
// Change the name of person2, and person1 also changes.
person2.Name = "Molly";
person2.Age = 16;
Console.WriteLine("person2 Name = {0} Age = {1}", person2.Name, person2.Age);
Console.WriteLine("person1 Name = {0} Age = {1}", person1.Name, person1.Age);
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/*
Output:
    person1 Name = Leopold Age = 6
    person2 Name = Molly Age = 16
    person1 Name = Molly Age = 16
*/

     p1 と p2 のメモリはどちらも、スレッドのスタックに割り当てられます。そのメモリは、それが宣言されている型またはメソッドと共 に解放されます。 これは、割り当て時に構造体がコピーされる理由の 1 です。 これに対し、クラスのインスタンスに割り当てられ たメモリは、そのオブジェクトに対するすべての参照がスコープ外になると、共通言語ランタイムによって自動的に解放 (ガベージ コレクション) されます。 C++ のようにクラスのオブジェクトを確定的に破棄することはできません。 .NET のガベージ コレクションの 詳細については、「ガベージ コレクション」を参照してください。
オブジェクト ID と値の等価性
2 つのオブジェクトが等しいかどうかを比較するときは、最初に、2 つの変数がメモリ内の同じオブジェクトを表しているかどうかを 知りたいのか、それともオブジェクトの 1 つ以上のフィールドの値が等しいかどうかを知りたいのかを、区別する必要があります。 値を比較する場合は、オブジェクトが値型 (構造体) のインスタンスか、または参照型 (クラス、デリゲート、配列) のインスタンス かを、検討する必要があります。
    NOTE
マネージド ヒープ上のメモリの割り当てと解放は、共通言語ランタイムにおいて高度に最適化されています。 ほとんどの場合、ヒープへのクラ ス インスタンスの割り当てと、スタックへの構造体インスタンスの割り当てに、パフォーマンス コストの点で大きな違いはありません。
   public struct Person
{
    public string Name;
    public int Age;
    public Person(string name, int age)
    {
Name = name;
Age = age; }
}
public class Application
{
    static void Main()
    {
} }
// Create  struct instance and initialize by using "new".
// Memory is allocated on thread stack.
Person p1 = new Person("Alex", 9);
Console.WriteLine("p1 Name = {0} Age = {1}", p1.Name, p1.Age);
// Create  new struct object. Note that  struct can be initialized
// without using "new".
Person p2 = p1;
// Assign values to p2 members.
p2.Name = "Spencer";
p2.Age = 7;
Console.WriteLine("p2 Name = {0} Age = {1}", p2.Name, p2.Age);
// p1 values remain unchanged because p2 is  copy.
Console.WriteLine("p1 Name = {0} Age = {1}", p1.Name, p1.Age);
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    p1 Name = Alex Age = 9
    p2 Name = Spencer Age = 7
    p1 Name = Alex Age = 9
*/

               クラスの 2 つのインスタンスがメモリ内の同じ場所を参照しているかどうか (つまり、同じ ID か) を調べるには、静的な Equals メソッドを使います (System.Object は、ユーザー定義の構造体やクラスを含む、すべての値型と参照型の暗 黙の基底クラスです)。
2 つの構造体インスタンスのインスタンス フィールドが同じ値を持つかどうかを調べるには、ValueType.Equals メソッドを 使います。 すべての構造体は System.ValueType を暗黙的に継承するので、次の例で示すように、オブジェクトで直 接メソッドを呼び出します。
    // Person is defined in the previous example.
//public struct Person
//{
//    public string Name;
//    public int Age;
//    public Person(string name, int age)
//    {
//        Name = name;
//        Age = age;
//    }
//}
Person p1 = new Person("Wallace", 75);
Person p2;
p2.Name = "Wallace";
p2.Age = 75;
if (p2.Equals(p1))
    Console.WriteLine("p2 and p1 have the same values.");
// Output: p2 and p1 have the same values.
  Equals によるSystem.ValueTypeの実装では、ボックス化とリフレクションが使用される場合があります。型に固有の効率的 な等価性アルゴリズムを提供する方法の詳細については、「型の値の等価性を定義する方法」を参照してください
クラスの 2 つのインスタンスのフィールドの値が等しいかどうかを調べるには、Equals メソッドまたは == 演算子を使用できる 場合があります。 ただし、この方法を使用できるのは、その型のオブジェクトにおける "等値" の意味のカスタム定義が、クラ スのオーバーライドまたはオーバーロードによって提供されている場合だけです。 クラスは、IEquatable<T> インターフェイスま たは IEqualityComparer<T> インターフェイスを実装することもできます。 どちらのインターフェイスも、値の等価性をテスト するために使うことができるメソッドを提供します。 Equals をオーバーライドする独自のクラスを設計するときは、「型の値の 等価性を定義する方法」および「Object.Equals(Object)」に記載されているガイドラインに従ってください。
関連項目 詳細情報
クラス コンストラクター ファイナライザー イベント
関連項目
C# プログラミング ガイド object
継承
class
 
    構造体型
new 演算子 共通型システム

       継承は、カプセル化およびポリモーフィズムと共に、オブジェクト指向プログラミングの主要な 3 つの特性の 1 つです。 継承を使 用すると、他のクラスで定義されている動作を再利用、拡張、変更して新しいクラスを作成できます。 メンバーが継承される側 のクラスを "基底クラス" と呼び、メンバーを継承する側のクラスを "派生クラス" と呼びます。 派生クラスは、直接の基底クラスを 1 つだけ持つことができます。 ただし、継承は推移的です。 ClassC が ClassB から派生し、 ClassB が ClassA から派生 している場合、 ClassC では、 ClassB と ClassA で宣言されているメンバーが継承されます。
概念的には、派生クラスは基底クラスから特化したクラスです。 たとえば、基底クラス がある場合、 という名 前の派生クラスと、 Reptile という名前の別の派生クラスを持つことができます。 は であり、 も
Animal ですが、各派生クラスは、基底クラスから別々の特殊化を表します。
インターフェイス宣言では、そのメンバーの既定の実装を定義できます。 そのような実装は、派生インターフェイスと派生インター フェイスを実装するクラスによって継承されます。 既定のインターフェイス メソッドの詳細については、インターフェイスに関する記 事の言語リファレンスのセクションをご覧ください。
クラスを別のクラスから派生するように定義すると、派生クラスには、コンストラクターとファイナライザーを除く、基底クラスのすべて のメンバーが暗黙的に引き継がれます。 派生クラスでは、基底クラスのコードを再実装することなく再利用します。 派生クラス では、メンバーを追加できます。 派生クラスでは、基底クラスの機能が拡張されます。
次の図は、あるビジネスプロセスの作業項目を表す WorkItem クラスを示しています。他のすべてのクラスと同様 に、System.Objectから派生し、そのすべてのメソッドを継承します。 WorkItem には、独自のメンバーが5つ追加されていま す。そのようなメンバーにはコンストラクターが含まれます。コンストラクターは継承されないためです。 WorkItem から継承される
ChangeRequest クラスは、特定の種類の作業項目を表します。 ChangeRequest には、 とObjectから継承したメ ンバーに2つのメンバーが追加されます。独自のコンストラクターを追加する必要があるほか、さらに originalItemID も追加 されます。 originalItemID プロパティを使用すると、 ChangeRequest インスタンスは、変更要求が適用される元の
と関連付けることができます。
次の例は、前の図に示したクラスの関係がC#でどのように表現されるかを示しています。また、WorkItem が仮想メソッド Object.ToStringをオーバーライドする方法と、 ChangeRequest クラスが WorkItem によるメソッドの実装を継承する方法も示
           NOTE
構造体では、継承がサポートされていませんが、インターフェイスを実装することはできます。 詳細については、「インターフェイス」を参照してく ださい。
   Animal
 Animal
Mammal
   Mammal
Reptile
       WorkItem
    WorkItem
    継承 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 しています。 最初のブロックでクラスが定義されます。
    // WorkItem implicitly inherits from the Object class.
public class WorkItem
{
    // Static field currentID stores the job ID of the last WorkItem that
    // has been created.
    private static int currentID;
    //Properties.
    protected int ID { get; set; }
    protected string Title { get; set; }
    protected string Description { get; set; }
    protected TimeSpan jobLength { get; set; }
    // Default constructor. If a derived class does not invoke a base-
    // class constructor explicitly, the default constructor is called
    // implicitly.
    public WorkItem()
{
ID = 0;
        Title = "Default title";
        Description = "Default description.";
        jobLength = new TimeSpan();
}
    // Instance constructor that has three parameters.
    public WorkItem(string title, string desc, TimeSpan joblen)
    {
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = joblen;
}
    // Static constructor to initialize the static member, currentID. This
    // constructor is called one time, automatically, before any instance
    // of WorkItem or ChangeRequest is created, or currentID is referenced.
    static WorkItem() => currentID = 0;
    // currentID is a static field. It is incremented each time a new
    // instance of WorkItem is created.
    protected int GetNextID() => ++currentID;
    // Method Update enables you to update the title and job length of an
    // existing WorkItem object.
    public void Update(string title, TimeSpan joblen)
    {
        this.Title = title;
        this.jobLength = joblen;
    }
    // Virtual method override of the ToString method that is inherited
    // from System.Object.
    public override string ToString() =>
        $"{this.ID} - {this.Title}";
}
// ChangeRequest derives from WorkItem and adds a property (originalItemID)
// and two constructors.
public class ChangeRequest : WorkItem
{
    protected int originalItemID { get; set; }
    // Constructors. Because neither constructor calls a base-class
    // constructor explicitly, the default constructor in the base class
    // is called implicitly. The base class must contain a default
    // constructor.

     // constructor.
 この次のブロックでは、基底クラスと派生クラスの使用方法が示されます。
    // Create an instance of WorkItem by using the constructor in the
// base class that takes three arguments.
WorkItem item = new WorkItem("Fix Bugs",
                            "Fix all bugs in my code branch",
                            new TimeSpan(3, 4, 0, 0));
// Create an instance of ChangeRequest by using the constructor in
// the derived class that takes four arguments.
ChangeRequest change = new ChangeRequest("Change Base Class Design",
                                        "Add members to the class",
                                        new TimeSpan(4, 0, 0),
                                        1);
// Use the ToString method defined in WorkItem.
Console.WriteLine(item.ToString());
// Use the inherited Update method to change the title of the
// ChangeRequest object.
change.Update("Change the Design of the Base Class",
    new TimeSpan(4, 0, 0));
// ChangeRequest inherits WorkItem's override of ToString.
Console.WriteLine(change.ToString());
/* Output:
1 - Fix Bugs
    2 - Change the Design of the Base Class
*/
 抽象メソッドと仮想メソッド
基底クラスによってメソッドが として宣言されるとき、派生クラスでは、その独自の実装でそのメソッドを override でき ます。 基底クラスによってメンバーが として宣言される場合、そのクラスから直接継承されるあらゆる非抽象クラスで そのメソッドをオーバーライドする必要があります。 派生クラス自体が抽象クラスである場合は、抽象メンバーを実装することなく 継承します。 抽象メンバーと仮想メンバーは、オブジェクト指向プログラミングの重要な特性の 2 つ目であるポリモーフィズムの 基礎です。 詳細については、「ポリモーフィズム」を参照してください。
抽象基底クラス
new 演算子を使用して直接インスタンス化されないようにする場合は、クラスを abstract として宣言できます。 抽象クラスは、
  virtual
 abstract
   } }
// Default constructor for the derived class.
public ChangeRequest() { }
// Instance constructor that has four parameters.
public ChangeRequest(string title, string desc, TimeSpan jobLen,
                     int originalID)
{
    // The following properties and the GetNexID method are inherited
    // from WorkItem.
    this.ID = GetNextID();
    this.Title = title;
    this.Description = desc;
    this.jobLength = jobLen;
// Property originalItemId is a member of ChangeRequest, but not
// of WorkItem.
this.originalItemID = originalID;
 
            新しいクラスがそれから誘導される場合にのみ利用できます。 抽象クラスには、それ自体が abstract として宣言された 1 つ以 上のメソッド シグネチャを含めることができます。 これらのシグネチャは、パラメーターと戻り値を指定しますが、実装 (メソッドの本 体) は持ちません。 抽象クラスには抽象メンバーを含める必要がありません。ただし、クラスに抽象メンバーが含まれる場合、そ のクラス自体を抽象として宣言する必要があります。 それ自体が抽象ではない派生クラスの場合、抽象基底クラスから抽象メ ソッドを実装する必要があります。 詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。
インターフェイス
"インターフェイス" は、一連のメンバーを定義する参照型です。 そのインターフェイスを実装するすべてのクラスと構造体で、その 一連のメンバーを実装する必要があります。 インターフェイスでは、それらのメンバーの一部または全部に対して既定の実装を 定義できます。 クラスは、直接的には 1 つの基底クラスからしか派生できませんが、複数のインターフェイスを実装できます。
インターフェイスは、"is a" 関係を必ずしも持たないクラスに特定の機能を定義する目的で使用されます。 たとえ ば、System.IEquatable<T> インターフェイスをクラスまたは構造体によって実装し、特定の型の 2 つのオブジェクトが等しいか どうかを判断できます (もっとも等価性は型で定義されます)。 IEquatable<T> では、基底クラスと派生クラスの間に存在する 同じ種類の"isa"関係(たとえば、Mammal は Animal である)を意味しません。詳細については、「インターフェイス」を参照 してください。
後続の派生を禁止する
クラスでは、それ自体かメンバーを sealed として宣言することで、他のクラスがそのクラスまたはそのメンバーから継承することを
禁止できます。 詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。 派生クラスで基底クラス メンバーを隠ぺいする
派生クラスは、同じ名前とシグネチャでメンバーを宣言することで、基底クラスのメンバーを隠ぺいすることができます。 new 修 飾子を利用すると、メンバーが基底メンバーのオーバーライドではないことを明示的に示すことができます。 new の使用は必須 ではありませんが、new が使用されていない場合、コンパイラの警告が生成されます。詳細については、「Overrideキーワー ドと New キーワードによるバージョン管理」および「Override キーワードと New キーワードを使用する場合について」を参照し てください。
関連項目
C# プログラミング ガイド クラスと構造体
class
   
    ポリモーフィズムは、カプセル化と継承に次ぐ、オブジェクト指向プログラミングの第 3 の柱と言われることがよくあります。 ポリモー フィズムは、ギリシャ語で "多形" を意味し、次の 2 つの側面を持っています。
メソッド パラメーター、コレクション、配列などに渡された派生クラスのオブジェクトは、実行時に基底クラスのオブジェクトとして 扱われることがあります。 このポリモーフィズムが発生すると、オブジェクトの宣言された型はその実行時の型と同じではなくな ります。
基底クラスでは、"virtual メソッド" を定義して実行できます。派生クラスでそれをオーバーライドすると、独自の定義と実装 を提供できます。 実行時には、クライアント コードがメソッドを呼び出したとき、CLR によってオブジェクトの実行時の型が検 索され、仮想メソッドのオーバーライドが呼び出されます。 ソース コード内で、基底クラスでメソッドを呼び出し、そのメソッド の派生クラス版を実行することができます。
仮想メソッドを使用すると、関連するオブジェクトのグループを同一の方法で扱うことができます。 たとえば、描画サーフェイスにさ まざまな種類の図形を作成できる描画アプリケーションがあるとします。 コンパイル時には、ユーザーがどのような種類の図形を 作成するかわかりません。 しかし、アプリケーションでは、作成されたさまざまな種類の図形を追跡し、ユーザーのマウス操作に 応じて更新する必要があります。 ポリモーフィズムを使用すると、2 つの基本的な手順でこの問題を解決できます。
1. 各図形クラスが共通の基底クラスから派生するようなクラス階層を作成します。
2. 仮想メソッドを使用して、基底クラスの 1 つのメソッドを呼び出すことで、派生クラスの適切なメソッドが呼び出されるようにし
ます。
まず、 Shape という基底クラスと、 Rectangle 、 Circle 、 Triangle などの派生クラスを作成します。 Shape クラスで Draw という仮想メソッドを定義し、各派生クラスでそれをオーバーライドして、そのクラスが表す特定の図形を描画します。
List<Shape> オブジェクトを作成し、 Circle 、 Triangle 、 Rectangle をそれに追加します。
       ポリモーフィズム (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     描画サーフェイスを更新するには、foreachループを使用してリストを反復処理し、リスト内の各 Shape オブジェクトの Draw メソッドを呼び出します。リスト内の各オブジェクトの宣言された型は Shape ですが、呼び出されるのは実行時の型(それぞれ の派生クラスでオーバーライドされたメソッド) になります。
  public class Shape
{
    // A few example members
    public int X { get; private set; }
    public int Y { get; private set; }
    public int Height { get; set; }
    public int Width { get; set; }
    // Virtual method
    public virtual void Draw()
    {
        Console.WriteLine("Performing base class drawing tasks");
    }
}
public class Circle : Shape
{
    public override void Draw()
    {
        // Code to draw a circle...
        Console.WriteLine("Drawing a circle");
        base.Draw();
} }
public class Rectangle : Shape
{
    public override void Draw()
    {
        // Code to draw a rectangle...
        Console.WriteLine("Drawing a rectangle");
        base.Draw();
} }
public class Triangle : Shape
{
    public override void Draw()
    {
} }
// Code to draw a triangle...
Console.WriteLine("Drawing a triangle");
base.Draw();

    C# では、すべての型がポリモーフィックです。これは、ユーザー定義型を含むすべての型が Object から派生するためです。 ポリモーフィズムの概要
仮想メンバー
基底クラスから派生クラスを継承すると、派生クラスでは、基底クラスのすべてのメソッド、フィールド、プロパティ、イベントが継承 されます。 派生クラスを設計するとき、仮想メソッドの動作についてはさまざまな選択肢があります。
派生クラスでは基底クラスの仮想メンバーがオーバーライドされ、新しい動作を定義できます。 派生クラスでは最も近い基底クラス メソッドがオーバーライドされることなく継承され、既存の動作が維持されますが、さらに 派生したクラスではメソッドをオーバーライドできるようになります。 派生クラスでは、基底クラスの実装を隠ぺいするメンバーの非仮想実装を新しく定義できます。
派生クラスが基底クラスのメンバーをオーバーライドできるのは、基底クラスのメンバーが virtual または abstract として宣言され ている場合だけです。 派生メンバーでは、override キーワードを使用して、そのメソッドが仮想呼び出しに加わることを明示的 に示す必要があります。 次にコード例を示します。
    public class BaseClass
{
    public virtual void DoWork() { }
    public virtual int WorkProperty
    {
        get { return 0; }
    }
}
public class DerivedClass : BaseClass
{
    public override void DoWork() { }
    public override int WorkProperty
    {
        get { return 0; }
    }
}
 フィールドは仮想にできません。仮想にできるのは、メソッド、プロパティ、イベント、インデクサーに限られます。 派生クラスが仮想
   // Polymorphism at work #1: a Rectangle, Triangle and Circle
// can all be used whereever a Shape is expected. No cast is
// required because an implicit conversion exists from a derived
// class to its base class.
var shapes = new List<Shape>
{
    new Rectangle(),
    new Triangle(),
    new Circle()
};
// Polymorphism at work #2: the virtual method Draw is
// invoked on each of the derived classes, not the base class.
foreach (var shape in shapes)
{
    shape.Draw();
}
/* Output:
    Drawing a rectangle
    Performing base class drawing tasks
    Drawing a triangle
    Performing base class drawing tasks
    Drawing a circle
    Performing base class drawing tasks
*/
 
   メンバーをオーバーライドすると、派生クラスのメンバーは、そのクラスのインスタンスが基底クラスのインスタンスとしてアクセスされ るときでも呼び出されます。 次にコード例を示します。
仮想メソッドとプロパティを使用すると、派生クラスは、基底クラスのメソッドの実装を使用せずに基底クラスを拡張できます。 詳 細については、「Override キーワードと New キーワードによるバージョン管理」を参照してください。 1 つまたは一連のメソッドを 定義し、その実装を派生クラスに任せるもう 1 つの方法として、インターフェイスがあります。 詳細については、「インターフェイ ス」を参照してください。
新しいメンバーで基底クラス メンバーを隠ぺいする
基底クラスのメンバーと同じ名前を持つメンバーを派生クラスに与える場合、new キーワードを使用し、基底クラス メンバーを 隠ぺいできます。 new キーワードは、置き換えられるクラスメンバーの戻り値の型の前に配置します。次にコード例を示しま す。
    DerivedClass B = new DerivedClass();
B.DoWork();  // Calls the new method.
BaseClass A = (BaseClass)B;
A.DoWork();  // Also calls the new method.
     public class BaseClass
{
    public void DoWork() { WorkField++; }
    public int WorkField;
    public int WorkProperty
    {
        get { return 0; }
    }
}
public class DerivedClass : BaseClass
{
    public new void DoWork() { WorkField++; }
    public new int WorkField;
    public new int WorkProperty
    {
        get { return 0; }
    }
}
 基底クラスのメンバーが隠ぺいされても、派生クラスのインスタンスを基底クラスのインスタンスに型変換することで、クライアント コードからアクセスできます。 次に例を示します。
派生クラスで仮想メンバーのオーバーライドを禁止する
仮想メンバーとそれを最初に宣言したクラスの間で宣言されているクラスの数に関係なく、仮想メンバーは仮想のままになりま す。 クラス A で仮想メンバーが宣言され、クラス B が A から派生し、クラス C が B から派生した場合、クラス C では仮 想メンバーが継承され、そのメンバーのオーバーライドがクラス B で宣言されたかどうかに関係なく、仮想メンバーをオーバーライ ドできます。 次にコード例を示します。
    DerivedClass B = new DerivedClass();
B.DoWork();  // Calls the new method.
BaseClass A = (BaseClass)B;
A.DoWork();  // Calls the old method.
 
  派生クラスでは、オーバーライドを sealed として宣言することで仮想継承を中止できます。 継承を止めるには、クラス メンバー の宣言で、 override キーワードの前に sealed キーワードを指定する必要があります。 次にコード例を示します。
上の例では、メソッド DoWork は C から派生したあらゆるクラスに対して仮想になりません。 C のインスタンスの場合、型 B や型 A に型変換されたとしてでも、依然として仮想となります。 シール メソッドは、次のコード例に示すように、 new キーワー ドを使用して派生クラスに置き換えることができます。
この場合、型 D の変数を利用して D で DoWork が呼び出されたとき、新しい DoWork が呼び出されます。 型 C 、 B 、 A の変数が D のインスタンスにアクセスする目的で使用される場合、 DoWork の呼び出しは仮想継承の規則に準拠し、ク
ラス C での DoWork の実装に呼び出しが転送されます。 派生クラスから基底クラスの仮想メンバーにアクセスする
メソッドやプロパティを置き換えたり、オーバーライドしたりした派生クラスでは、 base キーワードを使用して、基底クラスのメソッ ドやプロパティに引き続きアクセスできます。 次にコード例を示します。
      public class C : B
{
    public sealed override void DoWork() { }
}
      public class D : C
{
    public new void DoWork() { }
}
         public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
} }
//Perform Derived's work here
//...
// Call DoWork on base class
base.DoWork();
 詳細については、「base」を参照してください。
    public class A
{
    public virtual void DoWork() { }
}
public class B : A
{
    public override void DoWork() { }
}
    NOTE
仮想メンバーの場合、その固有の実装で base を使用して、その仮想メンバーの基底クラス実装を呼び出すことをお勧めします。 基底ク ラスの動作を実行できるようにすることで、派生クラスは、派生クラスに固有の動作を実装することに集中できます。 基底クラス実装を呼び 出さない場合は、基底クラスの動作と互換性のある動作を派生クラスで実現する必要があります。
 
        このセクションの内容
Override キーワードと New キーワードによるバージョン管理 Override キーワードと New キーワードを使用する場合について ToString メソッドをオーバーライドする方法
関連項目
C# プログラミング ガイド
継承
抽象クラスとシール クラス、およびクラス メンバー メソッド
イベント
プロパティ
インデクサー
型

    C# 言語は、異なるライブラリ内の基底クラスと派生クラス間でのバージョン管理を進化させると同時に、下位互換性も維持さ れるよう設計されています。 そのため、たとえば、派生クラスのメンバーと同じ名前を使用して基底クラスの新規メンバーが導入 されても、C# では完全にサポートされ、予期しない動作は発生しません。 ただしこのことは、メソッドが派生メソッドをオーバーラ イドするためのものなのか、それとも同じ名前の派生メソッドを非表示にする新規メソッドなのかを、クラスで明示的に記述しな ければならないということでもあります。
C# では、派生クラスに基底クラスと同じ名前のメソッドを含めることができます。 派生クラスのメソッドの前にnewまたはoverrideキーワードがない場合、コンパイラは警告を発し、メソッドは new
キーワードが存在する場合と同様に動作します。
派生クラスのメソッドの前に new キーワードがある場合、そのメソッドは基底クラスのメソッドに依存しないメソッドとして 定義されます。
派生クラスのメソッドの前に override キーワードがある場合、派生クラスのオブジェクトは、基底クラスのメソッドの代わ りにそのメソッドを呼び出します。
派生クラスのメソッドに override キーワードを適用するには、基底クラスのメソッドを仮想に定義する必要があります。 基底クラスのメソッドは、 base キーワードを使用して派生クラス内から呼び出すことができます。
override 、 virtual 、および new キーワードは、プロパティ、インデクサー、およびイベントにも適用できます。
既定では、C# のメソッドは仮想ではありません。 メソッドが仮想として宣言されている場合、そのメソッドを継承しているすべて のクラスは、独自のバージョンを実装できます。仮想メソッドを仮想にするには、基底クラスのメソッド宣言で virtual 修飾子 を使用します。その後、派生クラスは override キーワードを使用して基底の仮想メソッドをオーバーライドするか、または
new キーワードを使用して基底クラスの仮想メソッドを非表示にできます。 override と new のいずれのキーワードも指定さ れていない場合、コンパイラは警告を発し、派生クラスのメソッドは基底クラスのメソッドを非表示にします。
実演的な例として、会社Aが GraphicsClass というクラスを作成し、プログラムで使用する場合について説明します。次の コードは GraphicsClass です。
この会社では、このクラスを使用して独自のクラスを派生させ、新しいメソッドを追加しました。
このアプリケーションは、会社Aが GraphicsClass の新しいバージョン(次のようなコード)をリリースするまでは、問題なく使用 できていました。
             class GraphicsClass
{
    public virtual void DrawLine() { }
    public virtual void DrawPoint() { }
}
     class YourDerivedGraphicsClass : GraphicsClass
{
    public void DrawRectangle() { }
}
  Override キーワードと New キーワードによる
バージョン管理 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     GraphicsClass の新バージョンに、 DrawRectangle というメソッドが含まれていますが、 当初は何も起こりませんでした。 新 バージョンでは、旧バージョンとのバイナリ互換性が維持されています。 配置したソフトウェアは、それらのコンピューター システム に新しいクラスがインストールされても、機能し続けます。 DrawRectangle メソッドへの既存の呼び出しは、派生クラス内のバー ジョンを引き続き参照します。
しかし、GraphicsClass の新バージョンを使用してアプリケーションを再コンパイルした途端、コンパイラから警告(CS0108)が 発せられます。この警告は、アプリケーション内での DrawRectangle メソッドの動作方法を検討する必要があることを示してい ます。
このメソッドで新しい基底クラスをオーバーライドする場合は、 override キーワードを使用します。
        class YourDerivedGraphicsClass : GraphicsClass
{
    public override void DrawRectangle() { }
}
   キーワードを使用すると、
の を使用するようになります。 使用することで基底クラス バージョンの
から派生したすべてのオブジェクトは、派生クラス バージョン から派生したオブジェクトは、base キーワードを
にもアクセスできます。
override
 DrawRectangle
YourDerivedGraphicsClass
 YourDerivedGraphicsClass
 DrawRectangle
  base.DrawRectangle();
 このメソッドで新しい基底クラス メソッドをオーバーライドしない場合には、次の考慮事項が適用されます。 2 つのメソッド間の 混乱を避けるために、メソッドの名前を変更できます。 これは時間がかかるうえにエラーが起こりやすいため、場合によっては実 用的でない可能性があります。 ただし、プロジェクトが比較的小さい場合は、Visual Studio のリファクタリング オプションを使用 して、メソッドの名前を変更することができます。 詳しくは、「クラスおよび型のリファクタリング (クラス デザイナー)」をご覧ください。
なお、派生クラスの定義内で new キーワードを使用することで、警告を回避することもできます。
new キーワードを使用すると、その定義によって基底クラス内の定義が非表示にされることがコンパイラに伝えられます。これが 既定の動作です。
オーバーライドとメソッド選択
クラスでメソッドを指定したときに、その呼び出しと互換性のあるメソッドが 2 つ以上ある場合、C# コンパイラはどのメソッドを呼 び出すのが最適かを選択します (たとえば、同じ名前のメソッドが 2 つあり、そのパラメーターと、渡されたパラメーターとの間に互 換性がある場合)。 たとえば、次の各メソッドには互換性があります。
    class YourDerivedGraphicsClass : GraphicsClass
{
    public new void DrawRectangle() { }
}
    class GraphicsClass
{
    public virtual void DrawLine() { }
    public virtual void DrawPoint() { }
    public virtual void DrawRectangle() { }
}
 
         Derived のインスタンスで DoWork が呼び出されると、C#コンパイラはまず、 Derived で最初に宣言された DoWork のバー ジョンと互換性がある呼び出しを実行しようとします。 オーバーライド メソッドは、クラスで宣言されたものとは見なされません。こ れらは、基底クラスで宣言されたメソッドの新しい実装です。C#コンパイラは、メソッドの呼び出しを Derived にある元のメソッ ドと対応付けできない場合にのみ、その呼び出しを、同じ名前と互換パラメーターを持つオーバーライド メソッドに対応付けま す。 次に例を示します。
変数 val はdouble型に暗黙的に変換できるので、C#コンパイラは DoWork(int) の代わりに DoWork(double) を呼び出 します。 この問題を回避する方法は 2 つあります。 1 つ目は、仮想メソッドと同じ名前の新しいメソッドを宣言しないようにする ことです。2つ目は、Derived のインスタンスを Base にキャストすることで、C#コンパイラに基底クラスメソッドのリストを検索 させ、仮想メソッドを呼び出すようにすることです。 メソッドが仮想なので、 Derived にある DoWork(int) の実装が呼び出され ます。 次に例を示します。
new と override の例について詳しくは、「OverrideキーワードとNewキーワードを使用する場合について」をご覧ください。 関連項目
C# プログラミング ガイド クラスと構造体
メソッド
継承
     int val = 5;
Derived d = new Derived();
d.DoWork(val);  // Calls DoWork(double).
        ((Base)d).DoWork(val);  // Calls DoWork(int) on Derived.
     public class Derived : Base
{
    public override void DoWork(int param) { }
    public void DoWork(double param) { }
}
 
    C# では、派生クラスのメソッドを基底クラスのメソッドと同じ名前にすることができます。 new および override キーワードを使っ て、メソッドでの処理を指定できます。 override 修飾子は基底クラスの virtual メソッドを "拡張" し、 new 修飾子はアク セス可能な基底クラスのメソッドを "非表示" にします。 このトピックの例ではその違いを示します。
コンソールアプリケーションで、次の2つのクラス BaseClass と DerivedClass を宣言します。 DerivedClass は BaseClass を継承します。
          class BaseClass
{
    public void Method1()
    {
        Console.WriteLine("Base - Method1");
    }
}
class DerivedClass : BaseClass
{
    public void Method2()
    {
        Console.WriteLine("Derived - Method2");
    }
}
 Main メソッドで、変数 bc 、 dc 、 bcdc を宣言します。
bc は BaseClass 型であり、その値は BaseClass です。
dc は DerivedClass 型であり、その値は DerivedClass です。
bcdc は BaseClass 型であり、その値は DerivedClass です。この変数には注意する必要があります。
bc と bcdc は 型なので、キャストを使わない限り、直接アクセスできるのは Method1 だけです。 変数 dc は、 Method1 と の両方にアクセスできます。 これらの関係を次のコードに示します。
        BaseClass
  Method2
Override キーワードと New キーワードを使用す
る場合について (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      次に、以下の Method2 メソッドを BaseClass に追加します。 このメソッドのシグネチャは、 DerivedClass の Method2 メソッ ドのシグネチャと一致します。
BaseClass に Method2 メソッドを追加したので、次のコードに示すように、 BaseClass の変数 bc および bcdc に 2 つめ の呼び出しステートメントを追加できます。
    public void Method2()
{
    Console.WriteLine("Base - Method2");
}
        bc.Method1();
bc.Method2();
dc.Method1();
dc.Method2();
bcdc.Method1();
bcdc.Method2();
   プロジェクトをビルドすると、
は、 DerivedClass の
結果である場合は、 前を変更して警告を解決することもできますが、実用的ではない場合があります。
に メソッドを追加したことで警告が発生するようになります。 警告の内容 メソッドが の Method2 メソッドを隠ぺいしているというものです。 それが意図する の定義で new キーワードを使うことをお勧めします。または、どちらかの Method2 メソッドの名
BaseClass
Method2
    Method2
BaseClass
  Method2
new を追加する前に、プログラムを実行して、追加した呼び出しステートメントによって生成される出力を確認します。次のよ うな結果が表示されます。
new キーワードは、その出力を生成する関係を維持しますが、警告を抑制します。 型の変数は引き続き のメンバーにアクセスし、 DerivedClass 型の変数は引き続き最初に のメンバーにアクセスした
    // Output:
// Base - Method1
// Base - Method2
// Base - Method1
// Derived - Method2
// Base - Method1
// Base - Method2
  BaseClass
   BaseClass
後、 から継承されたメンバーを考慮します。
DerivedClass
 BaseClass
   class Program
{
    static void Main(string[] args)
    {
        BaseClass bc = new BaseClass();
        DerivedClass dc = new DerivedClass();
        BaseClass bcdc = new DerivedClass();
        bc.Method1();
        dc.Method1();
        dc.Method2();
        bcdc.Method1();
    }
    // Output:
    // Base - Method1
    // Base - Method1
    // Derived - Method2
    // Base - Method1
}
 
     警告を抑制するには、次のコードで示すように、 での   の定義に new 修飾子を追加します。修飾 子を追加する位置は、 public の前でも後でもかまいません。
もう一度プログラムを実行し、出力が変わらないことを確認します。また、警告が表示されなくなったことを確認します。 new を使うことにより、それによって修飾されるメンバーが基底クラスから継承されたメンバーを隠ぺいすることを了解していることを明 示します。 継承による名前の非表示について詳しくは、「new 修飾子」をご覧ください。
この動作を を使ったときの効果と比較するため、次のメソッドを DerivedClass に追加します。 override 修飾子 を追加する位置は、 の前でも後でもかまいません。
BaseClass での Method1 の定義に virtual 修飾子を追加します。 virtual 修飾子を追加する位置は、 public の前 でも後でもかまいません。
プロジェクトを再度実行します。 次の出力の最後の 2 行に特に注意してください。
override 修飾子を使うことで、 bcdc は、 DerivedClass で定義されている Method1 メソッドにアクセスできます。 通常、こ れは継承階層での必要な動作です。 派生クラスから作成される値を持つオブジェクトには、派生クラスで定義されているメソッ ドを使うことが必要とされます。 そのような動作は、 override を使って基底クラスのメソッドを拡張することで実現できます。
ここまでの例をすべて含んだコードを次に示します。
DerivedClass
Method2
       public new void Method2()
{
    Console.WriteLine("Derived - Method2");
}
    override
 public
    public override void Method1()
{
    Console.WriteLine("Derived - Method1");
}
          public virtual void Method1()
{
    Console.WriteLine("Base - Method1");
}
     // Output:
// Base - Method1
// Base - Method2
// Derived - Method1
// Derived - Method2
// Derived - Method1
// Base - Method2
     
   using System;
using System.Text;
namespace OverrideAndNew
{
    class Program
    {
        static void Main(string[] args)
        {
} }
} }
BaseClass bc = new BaseClass();
DerivedClass dc = new DerivedClass();
BaseClass bcdc = new DerivedClass();
// The following two calls do what you would expect. They call
// the methods that are defined in BaseClass.
bc.Method1();
bc.Method2();
// Output:
// Base - Method1
// Base - Method2
// The following two calls do what you would expect. They call
// the methods that are defined in DerivedClass.
dc.Method1();
dc.Method2();
// Output:
// Derived - Method1
// Derived - Method2
// The following two calls produce different results, depending
// on whether override (Method1) or new (Method2) is used.
bcdc.Method1();
bcdc.Method2();
// Output:
// Derived - Method1
// Base - Method2
class BaseClass
{
    public virtual void Method1()
    {
        Console.WriteLine("Base - Method1");
    }
    public virtual void Method2()
    {
        Console.WriteLine("Base - Method2");
    }
}
class DerivedClass : BaseClass
{
public override void Method1()
{
    Console.WriteLine("Derived - Method1");
}
public new void Method2()
{
    Console.WriteLine("Derived - Method2");
}
   
 次の例では、異なるコンテキストでの同様の動作を示します。この例では、3つのクラスが定義されています。基底クラス Car と、それから派生される 2 つのクラス ConvertibleCar と です。 基底クラスには、 DescribeCar メソッドが含まれま す。 このメソッドは、車の基本的な説明を表示した後、 を呼び出して追加情報を提供します。 これら 3 つのク ラスのそれぞれで、 ShowDetails メソッドが定義されています。 new 修飾子は、 クラスで ShowDetails を 定義するために使われています。 override 修飾子は、 Minivan クラスで を定義するために使われていま す。
   Minivan
 ShowDetails
   ConvertibleCar
       // Define the base class, Car. The class defines two methods,
// DescribeCar and ShowDetails. DescribeCar calls ShowDetails, and each derived
// class also defines a ShowDetails method. The example tests which version of
// ShowDetails is selected, the base class method or the derived class method.
class Car
{
    public void DescribeCar()
    {
        System.Console.WriteLine("Four wheels and an engine.");
        ShowDetails();
    }
    public virtual void ShowDetails()
    {
        System.Console.WriteLine("Standard transportation.");
    }
}
// Define the derived classes.
// Class ConvertibleCar uses the new modifier to acknowledge that ShowDetails
// hides the base class method.
class ConvertibleCar : Car
{
    public new void ShowDetails()
    {
        System.Console.WriteLine("A roof that opens up.");
    }
}
// Class Minivan uses the override modifier to specify that ShowDetails
// extends the base class method.
class Minivan : Car
{
    public override void ShowDetails()
    {
        System.Console.WriteLine("Carries seven people.");
    }
}
  この例では、どちらのバージョンの が呼び出されるかをテストします。次の TestCars1 メソッドでは、各クラスのイ ンスタンスを宣言した後、各インスタンスの を呼び出します。
ShowDetails
ShowDetails
  DescribeCar

   TestCars1 で生成される出力は次のとおりです。 car2 の結果に特に注目してください。予測していた内容と違っている可 能性があります。オブジェクトの型は ConvertibleCar ですが、 は クラスで定義されている バージョンの ShowDetails にアクセスしていません。これは、このメソッドが、 修飾子ではなく new 修飾子を使って 宣言されているためです。 結果として、 ConvertibleCar オブジェクトでは Car オブジェクトと同じ説明が表示されます。
Minivan オブジェクトである car3 の結果と比べてみてください。 この場合は、 Minivan で宣言されている ShowDetails メ ソッドは、 Car クラスで宣言されている ShowDetails メソッドをオーバーライドし、表示されるのはミニバンの説明です。
   DescribeCar
ConvertibleCar
  override
         // TestCars1
// ----------
// Four wheels and an engine.
// Standard transportation.
// ----------
// Four wheels and an engine.
// Standard transportation.
// ----------
// Four wheels and an engine.
// Carries seven people.
// ----------
    TestCars2 は、 Car 型のオブジェクトのリストを作成します。 オブジェクトの値は、 Car 、 ConvertibleCar 、 の各ク ラスからインスタンス化されます。 DescribeCar は、リストの各要素に対して呼び出されます。次のコードは、 の定 義です。
Minivan
  TestCars2
    public static void TestCars2()
{
    System.Console.WriteLine("\nTestCars2");
    System.Console.WriteLine("----------");
    var cars = new List<Car> { new Car(), new ConvertibleCar(),
        new Minivan() };
    foreach (var car in cars)
    {
        car.DescribeCar();
        System.Console.WriteLine("----------");
    }
}
    public static void TestCars1()
{
    System.Console.WriteLine("\nTestCars1");
    System.Console.WriteLine("----------");
    Car car1 = new Car();
    car1.DescribeCar();
    System.Console.WriteLine("----------");
    // Notice the output from this test case. The new modifier is
    // used in the definition of ShowDetails in the ConvertibleCar
    // class.
    ConvertibleCar car2 = new ConvertibleCar();
    car2.DescribeCar();
    System.Console.WriteLine("----------");
    Minivan car3 = new Minivan();
    car3.DescribeCar();
    System.Console.WriteLine("----------");
}
 
 次のような出力が表示されます。   によって表示される出力と同じであることに注意してください。 オブジェクトの型が
   であるか(   の場合)、Car であるか( の場合)にかかわらず、 スの メソッドは呼び出されません。 逆に、 car3 は、型が でも Car でも、
を呼び出します。
クラ クラスの
ConvertibleCar
ShowDetails
ConvertibleCar
   Minivan
Minivan
 ShowDetails
    // TestCars2
// ----------
// Four wheels and an engine.
// Standard transportation.
// ----------
// Four wheels and an engine.
// Standard transportation.
// ----------
// Four wheels and an engine.
// Carries seven people.
// ----------
     メソッド TestCars3 と TestCars4 でこの例は終わりです。これらのメソッドは、最初は型 として宣言されているオブジェクトから ( TestCars3 )、次に型 Car として宣言されているオブジェクトから (
ShowDetails を直接呼び出します。次のコードは、これら2つのメソッドの定義です。
および
)、
ConvertibleCar
Minivan
  TestCars4
     public static void TestCars3()
{
    System.Console.WriteLine("\nTestCars3");
    System.Console.WriteLine("----------");
    ConvertibleCar car2 = new ConvertibleCar();
    Minivan car3 = new Minivan();
    car2.ShowDetails();
    car3.ShowDetails();
}
public static void TestCars4()
{
    System.Console.WriteLine("\nTestCars4");
    System.Console.WriteLine("----------");
    Car car2 = new ConvertibleCar();
    Car car3 = new Minivan();
    car2.ShowDetails();
    car3.ShowDetails();
}
 これらのメソッドからは次のような出力が生成され、これはこのトピックの最初の例からの結果に対応します。
    // TestCars3
// ----------
// A roof that opens up.
// Carries seven people.
// TestCars4
// ----------
// Standard transportation.
// Carries seven people.
 完全なプロジェクトとその出力を次に示します。
TestCars2
 TestCars1
  TestCars1
     using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace OverrideAndNew2

 namespace OverrideAndNew2
{
    class Program
    {
        static void Main(string[] args)
        {
            // Declare objects of the derived classes and test which version
            // of ShowDetails is run, base or derived.
            TestCars1();
            // Declare objects of the base class, instantiated with the
            // derived classes, and repeat the tests.
            TestCars2();
            // Declare objects of the derived classes and call ShowDetails
            // directly.
            TestCars3();
            // Declare objects of the base class, instantiated with the
            // derived classes, and repeat the tests.
            TestCars4();
}
        public static void TestCars1()
        {
            System.Console.WriteLine("\nTestCars1");
            System.Console.WriteLine("----------");
            Car car1 = new Car();
            car1.DescribeCar();
            System.Console.WriteLine("----------");
            // Notice the output from this test case. The new modifier is
            // used in the definition of ShowDetails in the ConvertibleCar
            // class.
            ConvertibleCar car2 = new ConvertibleCar();
            car2.DescribeCar();
            System.Console.WriteLine("----------");
            Minivan car3 = new Minivan();
            car3.DescribeCar();
            System.Console.WriteLine("----------");
        }
        // Output:
        // TestCars1
        // ----------
        // Four wheels and an engine.
        // Standard transportation.
        // ----------
        // Four wheels and an engine.
        // Standard transportation.
        // ----------
        // Four wheels and an engine.
        // Carries seven people.
        // ----------
        public static void TestCars2()
        {
            System.Console.WriteLine("\nTestCars2");
            System.Console.WriteLine("----------");
            var cars = new List<Car> { new Car(), new ConvertibleCar(),
                new Minivan() };
            foreach (var car in cars)
            {
                car.DescribeCar();
                System.Console.WriteLine("----------");
            }
   }

     }
    // Output:
    // TestCars2
    // ----------
    // Four wheels and an engine.
    // Standard transportation.
    // ----------
    // Four wheels and an engine.
    // Standard transportation.
    // ----------
    // Four wheels and an engine.
    // Carries seven people.
    // ----------
    public static void TestCars3()
    {
        System.Console.WriteLine("\nTestCars3");
        System.Console.WriteLine("----------");
        ConvertibleCar car2 = new ConvertibleCar();
        Minivan car3 = new Minivan();
        car2.ShowDetails();
        car3.ShowDetails();
    }
    // Output:
    // TestCars3
    // ----------
    // A roof that opens up.
    // Carries seven people.
    public static void TestCars4()
    {
        System.Console.WriteLine("\nTestCars4");
        System.Console.WriteLine("----------");
        Car car2 = new ConvertibleCar();
        Car car3 = new Minivan();
        car2.ShowDetails();
        car3.ShowDetails();
    }
    // Output:
    // TestCars4
    // ----------
    // Standard transportation.
    // Carries seven people.
}
// Define the base class, Car. The class defines two virtual methods,
// DescribeCar and ShowDetails. DescribeCar calls ShowDetails, and each derived
// class also defines a ShowDetails method. The example tests which version of
// ShowDetails is used, the base class method or the derived class method.
class Car
{
    public virtual void DescribeCar()
    {
        System.Console.WriteLine("Four wheels and an engine.");
        ShowDetails();
    }
    public virtual void ShowDetails()
    {
        System.Console.WriteLine("Standard transportation.");
    }
}
// Define the derived classes.
// Class ConvertibleCar uses the new modifier to acknowledge that ShowDetails
// hides the base class method.
class ConvertibleCar : Car
{
   
     関連項目
C# プログラミング ガイド
クラスと構造体
Override キーワードと New キーワードによるバージョン管理 base
abstract
   } }
    public new void ShowDetails()
    {
        System.Console.WriteLine("A roof that opens up.");
    }
// Class Minivan uses the override modifier to specify that ShowDetails
// extends the base class method.
class Minivan : Car
{
}
public override void ShowDetails()
{
    System.Console.WriteLine("Carries seven people.");
}
 
      C# では、すべてのクラスまたは構造体が、暗黙的に Object クラスを継承します。 そのため、C# のすべてのオブジェクトが ToStringメソッドを取得し、そのオブジェクトの文字列表現を返します。たとえば、int 型の変数はすべて ToString メソッド を持ち、次のようにその変数の内容を文字列として返すことができます。
カスタムのクラスまたは構造体を作成するときは、クライアント コードにカスタム型の情報を提供するため、ToString メソッドを オーバーライドする必要があります。
ToString メソッドで書式設定文字列やその他のカスタム形式を使用する方法については、「型の書式設定」を参照してくだ さい。
クラスまたは構造体内の ToString メソッドをオーバーライドする手順
1. 次の修飾子および戻り値の値を指定して、 ToString メソッドを宣言します。
2. 文字列を返すように、メソッドを実装します。
次の例では、特定のクラス インスタンスに固有のデータに加えて、クラス名も返されます。
     int x = 42;
string strx = x.ToString();
Console.WriteLine(strx);
// Output:
// 42
      IMPORTANT
このメソッドを使用して提供する情報を決定するときは、作成したクラスまたは構造体が信頼関係のないコードによって使用されるかどうかを 考慮します。 悪意があるコードで利用される可能性がある情報を提供しないように注意してください。
     public override string ToString(){}
     class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public override string ToString()
    {
        return "Person: " + Name + " " + Age;
    }
}
  ToString メソッドをテストする方法を次のコード例に示します。
ToString メソッドをオーバーライドする方法 (C#
プログラミング ガイド) 2021/03/06 • • Edit Online
 
       関連項目
IFormattable
C# プログラミング ガイド クラスと構造体
文字列
string
override virtual 型の書式設定
   Person person = new Person { Name = "John", Age = 12 };
Console.WriteLine(person);
// Output:
// Person: John 12
 
         クラスと構造体には、そのデータおよび動作を表すメンバーがあります。 クラスのメンバーには、クラスで宣言されているすべてのメ ンバーと、継承の階層構造のすべてのクラスで宣言されているメンバー (コンストラクターとファイナライザーを除く) が含まれます。 基底クラスのプライベート メンバーは継承されますが、派生クラスからはアクセスできません。
クラスまたは構造体に含まれるメンバーの種類を次の表に示します。
定数 定数とは、コンパイル時に値が設定され、設定された値を変更できな いフィールドです。
   フィールド
   フィールドとは、クラス スコープで宣言される変数です。 フィールドは、 組み込みの数値型であったり、別のクラスのインスタンスであったりしま す。 たとえば、Calendar クラスには、現在の日付を格納するフィール ドがあります。
    プロパティ
   プロパティはクラスのメソッドで、そのクラスのフィールドのようにアクセスさ れます。 プロパティは、クラスのフィールドを保護し、オブジェクトが認識 することなくフィールドが変更されるのを防止できます。
   メソッド
 メソッドは、クラスが実行できるアクションを定義します。 メソッドは、入 力データを提供するパラメーターを受け取り、パラメーターを通じて出 力データを返すことができます。 メソッドは、パラメーターを使用せずに 値を直接返すこともできます。
   イベント
   イベントは、ボタンのクリックやメソッドの正常な終了などの発生に関す る通知を他のオブジェクトに提供します。 イベントを定義し、トリガー するには、デリゲートを使用します。
   演算子
  オーバーロードされた演算子は、型のメンバーと見なされます。 演算 子をオーバーロードする場合は、演算子をパブリックな静的メソッドと して型に定義します。 詳細については、「演算子のオーバーロード」を 参照してください。
 インデクサー インデクサーを使用すると、配列と同じようにオブジェクトにインデックス を付けることができます。
   コンストラクター
   コンストラクターは、オブジェクトを初めて作成するときに呼び出される メソッドです。 コンストラクターは、一般にオブジェクトのデータを初期 化するために使用します。
   ファイナライザー
 ファイナライザーが C# で使用されることはほとんどありません。 デストラ クターは、オブジェクトがメモリから削除されるときに、ランタイム実行エ ンジンによって呼び出されるメソッドです。 デストラクターは、通常、解 放する必要があるリソースが適切に処理されるようにするために使用 します。
    入れ子にされた型
  入れ子にされた型は、別の型で宣言された型です。 入れ子にされた 型は、通常、それを格納している型だけで使用されるオブジェクトを表 すために使用します。
 メンバー (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
  関連項目
C# プログラミング ガイド クラス

    abstract キーワードを使用すると、派生クラスで実装する必要のある不完全なクラス メンバーを作成できます。
また、sealed キーワードを使用すると、既に virtual とマークされているクラスや特定のクラス メンバーを継承しないようにできま
す。
抽象クラスと抽象クラス メンバー
クラス定義の前にキーワード abstract を指定することで、クラスを抽象として宣言できます。次に例を示します。
抽象クラスはインスタンス化できません。 抽象クラスの目的は、複数の派生クラスで共有できる基底クラスの共通の定義を提供 することです。 たとえば、クラス ライブラリでは、その多くの関数のパラメーターとして使用される抽象クラスを定義できます。このラ イブラリを使用する場合は、派生クラスを作成してクラスの独自の実装を提供する必要があります。
抽象クラスでは、抽象メソッドも定義できます。抽象メソッドを定義するには、メソッドの戻り値の型の前に abstract キーワー ドを記述します。 次に例を示します。
抽象メソッドには実装がないので、メソッド定義の後に、通常のメソッド ブロックの代わりにセミコロン (;) を配置します。 抽象クラ スの派生クラスでは、すべての抽象メソッドを実装する必要があります。 抽象クラスが基底クラスから仮想メソッドを継承した場 合は、この抽象クラスでは抽象メソッドで仮想メソッドをオーバーライドできます。 次に例を示します。
     public abstract class A
{
    // Class members here.
}
      public abstract class A
{
    public abstract void DoWork(int i);
}
 抽象クラスとシール クラス、およびクラス メン
バー (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
        virtual メソッドが abstract として宣言されている場合、そのメソッドは、その抽象クラスを継承するどのクラスでも仮想にな ります。抽象メソッドを継承するクラスでは、そのメソッドの元の実装にアクセスできません。上の例では、クラスFの DoWork は、クラスDの DoWork を呼び出すことができません。このようにして抽象クラスは、派生クラスに対し、仮想メソッドの新しいメ ソッド実装を強制的に提供させることができます。
シール クラスとシール クラス メンバー
クラス定義の前にキーワード sealed を指定することで、クラスをsealedとして宣言できます。次に例を示します。
シール クラスは、基底クラスとして使用できません。 このため、シール クラスは抽象クラスになることもできません。 シール クラスに より、派生が防止されます。 シール クラスは基底クラスとして使用できないので、実行時の最適化で、シール クラス メンバーを 多少高速に呼び出すことができる場合があります。
基底クラスの仮想メンバーをオーバーライドしている派生クラスのメソッド、インデクサー、プロパティ、またはイベントでは、そのメン バーをシールとして宣言できます。 これにより、その後の派生クラスでは、メンバーの仮想性が無効になります。 このように宣言 するには、クラスメンバー宣言でoverrideキーワードの前に sealed キーワードを配置します。次に例を示します。
関連項目
C# プログラミング ガイド クラスと構造体
継承
メソッド
フィールド
       public sealed class D
{
    // Class members here.
}
      public class D : C
{
    public sealed override void DoWork() { }
}
    // compile with: -target:library
public class D
{
    public virtual void DoWork(int i)
    {
        // Original implementation.
    }
}
public abstract class E : D
{
    public abstract override void DoWork(int i);
}
public class F : E
{
    public override void DoWork(int i)
    {
        // New implementation.
    }
}
 
  抽象プロパティを定義する方法

      静的クラスは基本的には非静的クラスと同じですが、静的クラスはインスタンス化できないという点が異なります。 つまり、new 演算子を使用して、そのクラス型の変数を作成することはできません。 インスタンス変数がないため、静的クラスのメンバーにア クセスするには、クラス名自体を使用します。 たとえば、 UtilityClass という静的クラスがあり、 MethodA というパブリック静的 メソッドが定義されている場合、このメソッドを呼び出すには次の例のようにします。
静的クラスは、入力パラメーターに対してのみ処理を行い、内部のインスタンス フィールドを取得したり設定したりする必要のな い一連のメソッドを格納する、便利なコンテナーとして使用できます。 たとえば、.NET クラス ライブラリでは、静的クラス System.Math に、数値演算を実行するメソッドが含まれており、Math クラスの特定のインスタンスに固有のデータを格納また は取得する必要はありません。 つまり、次の例に示すように、クラス名とメソッド名を指定して、クラスのメンバーを適用します。
    UtilityClass.MethodA();
     double dub = -3.14;
Console.WriteLine(Math.Abs(dub));
Console.WriteLine(Math.Floor(dub));
Console.WriteLine(Math.Round(Math.Abs(dub)));
// Output:
// 3.14
// -4
// 3
 すべてのクラス型の場合と同様に、静的クラスの型情報は、.NET ランタイムによって、そのクラスを参照しているプログラムが読み 込まれるときに読み込まれます。 プログラムでは、クラスが読み込まれるタイミングを正確に指定することはできません。 ただし、 クラスがプログラム内で最初に参照される前に、そのクラスが読み込まれ、そのフィールドが初期化され、その静的コンストラクター が呼び出されることが保証されます。 静的コンストラクターは一度だけ呼び出され、静的クラスは、プログラムが存在するアプリ ケーション ドメインの有効期間にわたってメモリに保持されます。
静的クラスの主な特徴を以下に示します。 静的メンバーだけが含まれます。 インスタンス化できません。 シールされています。
インスタンス コンストラクターを含めることはできません。
したがって、静的クラスを作成することと、静的メンバーとプライベート コンストラクターのみを含むクラスを作成することは、基本 的に同じです。 プライベート コンストラクターは、クラスのインスタンス化を防ぎます。 静的クラスを使用する利点は、インスタンス メンバーが誤って追加されないことをコンパイラで確認できるという点です。 コンパイラによって、このクラスのインスタンスを作成で きないことが保証されます。
    NOTE
インスタンスの作成を 1 つしか許可しない非静的クラスを作成する場合は、「C# でのシングルトンの実装」を参照してください。
 静的クラスと静的クラス メンバー (C# プログラ
ミング ガイド) 2021/03/06 • • Edit Online
 
  静的クラスはシールされるため、継承できません。 Object 以外のクラスから継承することはできません。 静的クラスには、インス タンス コンストラクターを含めることができません。 ただし、静的コンストラクターを含めることができます。 特別な初期化を必要と する静的メンバーがクラスに含まれている場合は、非静的クラスであっても静的コンストラクターを定義する必要があります。 詳 細については、「静的コンストラクター」を参照してください。
例
次に、摂氏と華氏の間で温度を変換する 2 つのメソッドを含む静的クラスの例を示します。
    public static class TemperatureConverter
{
    public static double CelsiusToFahrenheit(string temperatureCelsius)
    {
        // Convert argument to double for calculations.
        double celsius = Double.Parse(temperatureCelsius);
        // Convert Celsius to Fahrenheit.
        double fahrenheit = (celsius * 9 / 5) + 32;
        return fahrenheit;
    }
    public static double FahrenheitToCelsius(string temperatureFahrenheit)
    {
        // Convert argument to double for calculations.
        double fahrenheit = Double.Parse(temperatureFahrenheit);
        // Convert Fahrenheit to Celsius.
        double celsius = (fahrenheit - 32) * 5 / 9;
        return celsius;
    }
}
class TestTemperatureConverter
{
    static void Main()
    {
        Console.WriteLine("Please select the convertor direction");
        Console.WriteLine("1. From Celsius to Fahrenheit.");
        Console.WriteLine("2. From Fahrenheit to Celsius.");
        Console.Write(":");
        string selection = Console.ReadLine();
        double F, C = 0;
        switch (selection)
        {
            case "1":
                Console.Write("Please enter the Celsius temperature: ");
                F = TemperatureConverter.CelsiusToFahrenheit(Console.ReadLine());
                Console.WriteLine("Temperature in Fahrenheit: {0:F2}", F);
                break;
            case "2":
                Console.Write("Please enter the Fahrenheit temperature: ");
                C = TemperatureConverter.FahrenheitToCelsius(Console.ReadLine());
                Console.WriteLine("Temperature in Celsius: {0:F2}", C);
                break;
            default:
                Console.WriteLine("Please select a convertor.");
                break;
        }
        // Keep the console window open in debug mode.

// Keep the console window open in debug mode.
 静的メンバー
非静的クラスには、静的メソッド、フィールド、プロパティ、またはイベントを含めることができます。 静的メンバーは、クラスのインス タンスが作成されていない場合でも、クラスで呼び出すことです。 静的メンバーには、必ずインスタンス名ではなくクラス名でアク セスします。 クラスのインスタンスの作成数に関係なく、静的メンバーのコピーは 1 つしか存在しません。 静的メソッドと静的プロ パティは、それを含んでいる型の非静的フィールドや非静的イベントにはアクセスできません。また、メソッド パラメーターに明示 的に渡されない限り、どのオブジェクトのインスタンス変数にもアクセスできません。
クラス全体を静的として宣言するよりも、非静的クラスを宣言して、いくつかの静的メンバーを含める方が一般的です。 静的 フィールドの一般的な用途として、インスタンス化されたオブジェクトの数を保持することと、すべてのインスタンスで共有する必要 のある値を格納することの 2 つがあります。
静的メソッドのオーバーロードはできますが、オーバーライドはできません。これは、静的メソッドがクラスのインスタンスではなくクラ スに属しているためです。
フィールドを static const として宣言することはできませんが、const フィールドは、その動作において本質的に静的です。 こ れは、型のインスタンスではなく、型に属します。 そのため、 const フィールドにアクセスするには、静的フィールドに対して使用 するのと同じ ClassName.MemberName 表記法を使用します。オブジェクトインスタンスは必要ありません。
C# では、静的なローカル変数 (つまり、メソッドのスコープで宣言された変数) はサポートされません。 静的クラスのメンバーを宣言するには、次の例に示すように、メンバーの戻り値の型の前で static キーワードを使用します。
       public class Automobile
{
    public static int NumberOfWheels = 4;
    public static int SizeOfGasTank
    {
get {
return 15; }
}
    public static void Drive() { }
    public static event EventType RunOutOfGas;
    // Other non-static fields and properties...
}
 静的メンバーは初めてアクセスされる前に初期化されます。また、静的コンストラクターがある場合は、それが呼び出される前に 初期化されます。 静的クラスのメンバーにアクセスするには、次の例に示すように、変数名の代わりにクラス名を使用してメン バーの位置を指定します。
           Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
/* Example Output:
    Please select the convertor direction
    1. From Celsius to Fahrenheit.
    2. From Fahrenheit to Celsius.
    :2
    Please enter the Fahrenheit temperature: 20
    Temperature in Celsius: -6.67
    Press any key to exit.
*/
 
        クラスに静的フィールドが含まれている場合は、クラスが読み込まれたときに静的フィールドを初期化する静的コンストラクターを 用意します。
静的メソッドの呼び出しでは、Microsoft Intermediate Language (MSIL) の call 命令が生成されます。これに対して、イン スタンスメソッドの呼び出しでは callvirt 命令が生成され、nullオブジェクト参照もチェックされます。ただし、ほとんどの場 合、2 つの間にパフォーマンス上の違いはそれほどありません。
C# 言語仕様
詳細については、「C# 言語仕様」の静的クラスと静的およびインスタンス メンバーに関するセクションを参照してください。 言語
仕様は、C# の構文と使用法に関する信頼性のある情報源です。 関連項目
C# プログラミング ガイド static
クラス
class
静的コンストラクター インスタンス コンストラクター
    Automobile.Drive();
int i = Automobile.NumberOfWheels;
 
        すべての型と型メンバーにアクセシビリティ レベルがあります。 同じアセンブリまたは他のアセンブリに他のコードからそれらの型やそ のメンバーを利用できるかどうかは、アクセシビリティ レベルによって制御されます。 型またはメンバーにはその宣言時に、以下の アクセス修飾子を使ってアクセシビリティを指定します。
public:この型またはメンバーには、同じアセンブリ内の他のコードや、そのアセンブリを参照する別のアセンブリ内の任意の コードからアクセスできます。
private:この型またはメンバーには、同じ class 内または同じ struct 内のコードからのみアクセスできます。 protected:この型またはメンバーには、同じ class 内のコードか、その class から派生した class 内のコードからのみア クセスできます。 internal:この型またはメンバーには、同じアセンブリ内の任意のコードからアクセスできますが、別のアセンブリからはアクセスで きません。
protected internal:この型またはメンバーには、それが宣言されているアセンブリ内の任意のコードからアクセスできるほか、 別のアセンブリの派生 class 内からアクセスすることができます。
privateprotected:この型またはメンバーには、同じ class のコードか、その class から派生した型のコードによって、そ の宣言アセンブリ内でのみ、アクセスできます。
次の例は、型とメンバーにアクセス修飾子を指定する方法を示しています。
一部のコンテキスト、型、メンバーでは、アクセス修飾子が無効になります。 場合によっては、ある型のメンバーのアクセシビリティ が、それが含まれる型のアクセシビリティによって制約されることがあります。
クラス、レコード、および構造体のアクセシビリティ
名前空間に直接宣言されている (つまり、他のクラスや構造体の入れ子にされていない) クラス、レコード、構造体には、 public または internal を指定できます。アクセス修飾子が指定されなかった場合は、既定で internal が適用されま
     public class Bicycle
{
    public void Pedal() { }
}
    す。
構造体のメンバー (入れ子にされているクラスや構造体も含む) は 、 ます。 クラスのメンバー (入れ子にされているクラスや構造体も含む) は
、 のいずれかとして宣言でき 、 protected 、
   public
internal
private
   、
internal 、 private protected 、 のいずれかになります。 クラスのメンバーと構造体のメンバー (入れ子にされてい
public
protected internal
   private
 るクラスや構造体も含む) には、既定で のアクセスが与えられます。 入れ子にされた型のうち、private が指定されて いるものには、それを含んでいる型の外部からはアクセスできません。
派生クラスと派生レコードは、それらの基本データ型よりも優れたアクセシビリティにすることはできません。内部クラス A から派 生した public クラス B を宣言することはできません。 許可される場合は、 A を public にする効果が与えられるでしょう。 A のすべての protected または internal メンバーに派生クラスからアクセスできるためです。
InternalsVisibleToAttribute を使用すると、internal型へのアクセスを他の特定のアセンブリに許可できます。詳細につい ては、Friend アセンブリに関するページを参照してください。
private
   クラス、レコード、および構造体メンバーのアクセシビリティ
アクセス修飾子 (C# プログラミング ガイド) 2021/03/16 • • Edit Online
 
    クラスおよびレコード メンバー (入れ子にされているクラス、レコード、構造体も含む) は、6 種類あるアクセス修飾子をどれでも 使って宣言できます。 構造体のメンバーを protected 、 protected internal 、 private protected として宣言することはで きません。構造体は継承をサポートしていないためです。
通常、メンバーのアクセシビリティが、それを含んでいる型のアクセシビリティを超えることはありません。 ただし、internal クラスの public メンバーには、そのアセンブリの外部からアクセスできる場合もあります。そのメンバーがインターフェイスのメソッドを実装
している場合や public な基本クラスに定義されている仮想メソッドをオーバーライドしている場合がそれに該当します。
あらゆるメンバー フィールド、プロパティ、イベントの型には、メンバー自体と同じかそれ以上のアクセシビリティが必要です。 同様 に、あらゆるメソッド、インデクサー、デリゲートの戻り値の型とパラメーターの型には、メンバー自体と同じかそれ以上のアクセシビ リティが必要です。 たとえば、 public メソッド M でクラス C を返すには、 C が にもなっている必要があります。 同 様に、 A が private として宣言されている場合、 A 型のプロパティを にすることはできません。
ユーザー定義の演算子は、必ず public と static として宣言する必要があります。詳細については、「演算子のオーバー ロード」を参照してください。
アクセシビリティ修飾子をファイナライザーに割り当てることはできません。
class 、 record 、または struct のメンバーにアクセス レベルを設定するには、該当するキーワードをメンバーの宣言に追加 します。その例を次に示します。
      public
  protected
        // public class:
public class Tricycle
{
    // protected method:
    protected void Pedal() { }
    // private field:
    private int wheels = 3;
    // protected internal property:
    protected internal int Wheels
    {
        get { return wheels; }
    }
}
 その他の型
名前空間内に直接宣言されたインターフェイスは、 または internal にすることができます。クラスや構造体と同様、 インターフェイスの既定のアクセスレベルは になります。インターフェイスのメンバーは既定で public です。他の型 がクラスや構造体にアクセスできるようにすることがインターフェイスの目的であるためです。 インターフェイス メンバー宣言には、 あらゆるアクセス修飾子を含めることができます。 そのことは、クラスを実装するあらゆるもので必要になる共通実装を静的メソッ ドから与えるときに最も役に立ちます。
列挙型のメンバーは常に public となり、アクセス修飾子を適用することはできません。 デリゲートの振る舞いは、クラスおよび構造体と似ています。 既定では、名前空間内に直接宣言されているときには
internal アクセスが、入れ子にされているときは private アクセスが適用されます。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
  public
  internal
   C# プログラミング ガイド

        クラスと構造体 インターフェイス private
public
internal protected protected internal private protected class
struct interface

      フィールド とは、クラスまたは 構造体で直接宣言される任意の型の変数です。 フィールドは、それを含んでいる型の メンバー で す。
クラスまたは構造体には、インスタンス フィールドと静的フィールドのいずれか、またはその両方が含まれる場合があります。 イン スタンス フィールドは、型のインスタンスに固有です。 たとえば、クラス T と、そのクラスのインスタンス フィールド F があるとします。 型 T のオブジェクトを 2 つ作成した場合、他方のオブジェクトの値に影響を与えることなく、各オブジェクトの F の値を変更できま す。 これとは対照的に、クラス自体に属する静的フィールドは、そのクラスのすべてのインスタンスで共有されます。 静的フィール ドにアクセスするには、クラス名を使用する必要があります。 インスタンス名を使用して静的フィールドにアクセスすると、CS0176 コンパイル時エラーが発生します。
通常、フィールドは、プライベートまたは保護されたアクセシビリティを持つ変数に対してのみ使用します。 クラスからクライアント コードに公開するデータは、メソッド、プロパティ、およびインデクサーを使用して提供する必要があります。 これらの構成要素を 使用して、内部フィールドに間接的にアクセスすることで、無効な値が入力されることを防止できます。 パブリック プロパティに よって公開されるデータを格納するプライベート フィールドは、バッキング ストア または バッキング フィールド と呼ばれます。
一般に、フィールドは、複数のクラス メソッドからアクセスできるようにする必要があり、かつ 1 つのメソッドの有効期間より長く保 持する必要があるデータを格納します。 たとえば、暦の日付を表すクラスには、月、日、年を表す 3 つの整数フィールドが存在 します。 1 つのメソッドのスコープ外で使用されることのない変数は、メソッド本体内で ローカル変数 として宣言する必要があり ます。
フィールドは、フィールドのアクセス レベル、フィールドの型、フィールドの名前の順に指定して、クラス ブロック内で宣言します。 次に例を示します。
フィールド (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
     オブジェクト内のフィールドにアクセスするには、 objectname._fieldName のように、オブジェクト名の後にピリオドを追加し、その 後にフィールド名を続けます。 次に例を示します。
  public class CalendarEntry
{
    // private field (Located near wrapping "Date" property).
    private DateTime _date;
    // Public property exposes _date field safely.
    public DateTime Date
    {
get {
            return _date;
        }
set {
else {
                throw new ArgumentOutOfRangeException();
            }
} }
} }
// Set some reasonable boundaries for likely birth dates.
if (value.Year > 1900 && value.Year <= DateTime.Today.Year)
{
    _date = value;
}
// public field (Generally not recommended).
public string Day;
// Public method also exposes _date field safely.
// Example call: birthday.SetDate("1975, 6, 30");
public void SetDate(string dateString)
{
    DateTime dt = Convert.ToDateTime(dateString);
    // Set some reasonable boundaries for likely birth dates.
    if (dt.Year > 1900 && dt.Year <= DateTime.Today.Year)
    {
_date = dt; }
else {
        throw new ArgumentOutOfRangeException();
    }
}
public TimeSpan GetTimeSpan(string dateString)
{
    DateTime dt = Convert.ToDateTime(dateString);
    if (dt.Ticks < _date.Ticks)
    {
        return _date - dt;
    }
else {
        throw new ArgumentOutOfRangeException();
    }

                フィールドには、フィールドの宣言時に代入演算子を使用して初期値を指定できます。 たとえば、 Day フィールドに "Monday" を自動的に代入するには、次の例のように Day を宣言します。
フィールドは、オブジェクト インスタンスのコンストラクターが呼び出される直前に初期化されます。 コンストラクターがフィールドの 値を代入すると、フィールドの宣言時に指定された値はすべて上書きされます。 詳細については、「コンストラクターの使用」を 参照してください。
フィールドは、public、private、protected、internal、protected internal、または private protected としてマークできます。 これらのアクセス修飾子により、クラスのユーザーがフィールドにアクセスする方法が定義されます。 詳細については、「アクセス修 飾子」を参照してください。
必要に応じて、フィールドを静的に宣言することもできます。 その場合、クラスのインスタンスが存在しなくても、呼び出し元がい つでもフィールドを使用できるようになります。 詳細については、「静的クラスと静的クラス メンバー」を参照してください。
フィールドを readonly として宣言することもできます。 読み取り専用フィールドには、初期化時またはコンストラクターによる以 外は、値を代入できません。 static readonly フィールドは基本的に定数と同じですが、C#コンパイラが静的な読み取り専 用フィールドの値にアクセスできるのは実行時のみで、コンパイル時はアクセスできない点が異なります。 詳細については、「定 数」を参照してください。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミング ガイド クラスと構造体 コンストラクターの使用 継承
アクセス修飾子
抽象クラスとシール クラス、およびクラス メンバー
     public class CalendarDateWithInitialization
{
    public string Day = "Monday";
//... }
     NOTE
フィールドの初期化子は、他のインスタンス フィールドを参照できません。
     CalendarEntry birthday = new CalendarEntry();
birthday.Day = "Saturday";
 
           定数とは、コンパイル時に既知であり、プログラムの実行期間を通じて変更されない値です。 定数を宣言するには、const 修 飾子を使用します。 const として宣言できるのは、C#組み込み型(System.Objectを除く)のみです。クラス、構造体、配 列などのユーザー定義型を const にすることはできません。実行時に(コンストラクターなどで)一度だけ初期化され、その後 は変更できないクラス、構造体、または配列を作成するには、readonly 修飾子を使用します。
C#では、 const のメソッド、プロパティ、またはイベントはサポートされません。
enum 型を使用すると、組み込みの整数型 ( int 、 uint 、 long など) の名前付き定数を定義できます。 詳細について
は、「enum」を参照してください。 定数は、宣言するときに初期化する必要があります。 次に例を示します。
この例では、定数 は常に 12 になり、クラス自体によっても変更できません。 実際、コンパイラが C# ソース コードで定 数の識別子 (この場合は ) を検出すると、コンパイラが生成する中間言語 (IL) コードには、識別子の代わりにリテラル 値が直接出力されます。 実行時に定数に関連付けられる変数アドレスが存在しないため、 const フィールドは、参照渡しす ることも、式の左辺値として指定することもできません。
同じ型の複数の定数を、次のように同時に宣言できます。
定数の初期化に使用する式は、循環参照を形成しない限り別の定数を参照できます。 次に例を示します。
    class Calendar1
{
    public const int Months = 12;
}
  Months
 Months
    NOTE
DLL などの他のコードに定義されている定数値を参照するときは、注意が必要です。 新しいバージョンの DLL で定数の新しい値を定義し ても、その新バージョンを対象にプログラムを再コンパイルするまで、プログラムには古いリテラル値が保持されたままになります。
     class Calendar2
{
    public const int Months = 12, Weeks = 52, Days = 365;
}
     class Calendar3
{
    public const int Months = 12;
    public const int Weeks = 52;
    public const int Days = 365;
    public const double DaysPerWeek = (double) Days / (double) Weeks;
    public const double DaysPerMonth = (double) Days / (double) Months;
}
 定数は、public、private、protected、internal、protected internal または private protected としてマークできます。 これら のアクセス修飾子により、クラスのユーザーが定数にアクセスする方法が定義されます。 詳細については、「アクセス修飾子」を 参照してください。
定数 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
       定数の値は型のすべてのインスタンスで同じであるため、定数は静的フィールドのようにアクセスされます。 定数の宣言に static キーワードは使用しません。定数を定義しているクラスに含まれていない式で定数を使用する場合は、クラス名、ピリ
オド、定数の名前を使用する必要があります。 次に例を示します。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# プログラミング ガイド クラスと構造体 プロパティ
型
readonly
C# の不変性パート 1: 不変性の種類
   int birthstones = Calendar.Months;
 
   次の例では、抽象プロパティを定義する方法を示します。 抽象プロパティの宣言では、プロパティ アクセサーは実装されません。 クラスがプロパティをサポートしていることは宣言しますが、アクセサーの実装は派生クラスに委ねます。 基本クラスから継承され た抽象プロパティを実装する方法を次の例に示します。
このサンプルは 3 つのファイルで構成され、それぞれ個別にコンパイルされ、生成されたアセンブリが次のコンパイルで参照されま す。
abstractshape.cs:抽象 Shape プロパティを含む Area クラス。
shapes.cs:Shape クラスのサブクラス。
shapetest.cs:Shape から派生したいくつかのオブジェクトの面積を表示するテストプログラム。
この例をコンパイルするには、次のコマンドを使用します。
 csc abstractshape.cs shapes.cs shapetest.cs
これで、実行可能ファイル shapetest.exe が作成されます。
例
このファイルは、 double 型の Shape プロパティを含む Area クラスを宣言します。
  抽象プロパティを定義する方法 (C# プログラミ
ング ガイド) 2021/03/06 • • Edit Online
 
  プロパティの修飾子は、プロパティ宣言自体に設定されます。 次に例を示します。
抽象プロパティ(この例では Area など)を宣言する場合は、使用可能なアクセサーを示すだけで、実装はしません。 この例では、get アクセサーのみが使用可能であるため、プロパティは読み取り専用となります。
例
次のコードは、Shape の3つのサブクラスと、それらがどのように Area プロパティをオーバーライドして独自の実装を提供する かを示しています。
  public abstract double Area
    // compile with: csc -target:library abstractshape.cs
public abstract class Shape
{
    private string name;
    public Shape(string s)
    {
        // calling the set accessor of the Id property.
Id = s; }
    public string Id
    {
get {
            return name;
        }
set {
            name = value;
        }
}
    // Area is a read-only property - only a get accessor is needed:
    public abstract double Area
    {
get; }
    public override string ToString()
    {
        return $"{Id} Area = {Area:F2}";
    }
}
 
    例
  // compile with: csc -target:library -reference:abstractshape.dll shapes.cs
public class Square : Shape
{
    private int side;
    public Square(int side, string id)
        : base(id)
    {
        this.side = side;
}
    public override double Area
    {
get {
            return side * side;
        }
} }
// Given the side, return the area of a square:
public class Circle : Shape
{
    private int radius;
    public Circle(int radius, string id)
        : base(id)
    {
        this.radius = radius;
}
    public override double Area
    {
get {
            return radius * radius * System.Math.PI;
        }
} }
// Given the radius, return the area of a circle:
public class Rectangle : Shape
{
    private int width;
    private int height;
    public Rectangle(int width, int height, string id)
        : base(id)
    {
        this.width = width;
        this.height = height;
}
    public override double Area
    {
get {
            return width * height;
        }
} }
// Given the width and height, return the area of a rectangle:

     次のコードは、 Shape から派生するオブジェクトをいくつか作成し、それらの面積を出力するテスト プログラムを示しています。
    // compile with: csc -reference:abstractshape.dll;shapes.dll shapetest.cs
class TestClass
{
    static void Main()
    {
        Shape[] shapes =
        {
            new Square(5, "Square #1"),
            new Circle(3, "Circle #1"),
            new Rectangle( 4, 5, "Rectangle #1")
};
        System.Console.WriteLine("Shapes Collection");
        foreach (Shape s in shapes)
        {
            System.Console.WriteLine(s);
        }
} }
/* Output:
    Shapes Collection
    Square #1 Area = 25.00
    Circle #1 Area = 28.27
    Rectangle #1 Area = 20.00
*/
 関連項目
C# プログラミング ガイド
クラスと構造体
抽象クラスとシール クラス、およびクラス メンバー プロパティ

    定数とは、値がコンパイル時に設定され、変更できないフィールドです。 定数を使用して、特殊な値の数値リテラル ("マジック ナンバー") の代わりにわかりやすい名前を提供します。
整数型 ( int 、 byte など) の定数値を定義するには、列挙型を使用します。 詳細については、「enum」を参照してくださ い。
整数型以外の定数を定義する1つの方法は、Constants という名前の1つの静的クラスにそれらをグループ化することです。 これを行うには、次の例に示すように、クラス名の前に定数へのすべての参照を付ける必要があります。
例
    NOTE
C# では、C と C++ で通常使用される方法で、#define プリプロセッサ ディレクティブを使用して定数を定義することはできません。
      using System;
static class Constants
{
    public const double Pi = 3.14159;
    public const int SpeedOfLight = 300000; // km per sec.
}
class Program
{
    static void Main()
    {
} }
double radius = 5.3;
double area = Constants.Pi * (radius * radius);
int secsFromSun = 149476000 / Constants.SpeedOfLight; // in km
Console.WriteLine(secsFromSun);
 クラス名修飾子を使用すると、定数を使用するユーザーは、それが定数であり、変更できないことがわかります。
関連項目
クラスと構造体
C# で定数を定義する方法 2021/03/06 • • Edit Online
 
       プロパティは、プライベート フィールドの値の読み取り、書き込み、または計算を行う、柔軟な機構が用意されたメンバーです。 プロパティは、パブリック データのメンバーと同様に使用できますが、実際はアクセサーという特殊なメソッドです。 メソッドの安全 性と柔軟性を高めながら、簡単にデータにアクセスできます。
プロパティの概要
プロパティを使えば、実装や検査コードを隠したままで、値の取得と設定についてパブリックな方法をクラスが公開できま す。
get プロパティ アクセサーはプロパティ値を取得するために使用し、set プロパティ アクセサーは新しい値を割り当てるため に使用します。 これらのアクセサーには異なるアクセス レベルを指定できます。 詳細については、「アクセサーのアクセシ ビリティの制限」を参照してください。
set アクセサーで割り当てる値はvalueキーワードを使用して定義します。
プロパティの種類には、読み取り/書き込み(get アクセサーと set アクセサーの両方を備える)、読み取り専用(get アクセサーのみで set アクセサーはない)、書き込み専用(set アクセサーのみで get アクセサーはない)があります。 書き込み専用のプロパティの使用頻度は低く、ほとんどの場合、機密データへのアクセスを制限するために使用されま す。
カスタムのアクセサー コードを必要としない単純なプロパティは、式本体の定義として、または自動実装プロパティとして 実装できます。
バッキング フィールドを持つプロパティ
プロパティを実装する基本的な手法の 1 つとして、プロパティ値の設定と取得にプライベート バッキング フィールドを使用する方 法があります。 この方法では、 get アクセサーはプライベート フィールドの値を返します。 set アクセサーはプライベート フィール ドに値を割り当てる前にデータ検証を実行できます。 また、どちらのアクセサーも、データの変換や計算を行ってから、データを 格納したり返したりすることができます。
このパターンを説明する例を下に示します。 この例では、 TimePeriod クラスは時間間隔を表しています。 クラスの内部では、 _seconds という名前のプライベートフィールドに時間間隔が秒単位で格納されます。 Hours という読み取り/書き込みプロパ ティでは、ユーザーが時間間隔を時間単位で指定できます。 get アクセサーと set アクセサーの両方で、必要に応じて時間
と秒の変換が実行されます。 また、 set アクセサーは、データを検証し、時間数が無効である場合に ArgumentOutOfRangeException をスローします。
  プロパティ (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
  式本体の定義
プロパティ アクセサーは、通常、式の結果を割り当てるか返すだけの 1 行のステートメントで構成されます。 プロパティは、本体 が式形式のメンバーとして実装できます。 式本体の定義は、 => 記号の後に、プロパティに割り当てるかプロパティから取得す るための式を続けて構成します。
C#6以降では、読み取り専用プロパティに get アクセサーを式形式のメンバーとして実装できます。この場合、get アクセ サーキーワードと return キーワードはどちらも使用しません。次の例では、読み取り専用 Name プロパティを式形式のメン バーとして実装しています。
    using System;
class TimePeriod
{
   private double _seconds;
   public double Hours
   {
       get { return _seconds / 3600; }
       set {
          if (value < 0 || value > 24)
             throw new ArgumentOutOfRangeException(
                   $"{nameof(value)} must be between 0 and 24.");
          _seconds = value * 3600;
       }
} }
class Program
{
   static void Main()
   {
       TimePeriod t = new TimePeriod();
       // The property assignment causes the 'set' accessor to be called.
       t.Hours = 24;
       // Retrieving the property causes the 'get' accessor to be called.
       Console.WriteLine($"Time in hours: {t.Hours}");
   }
}
// The example displays the following output:
//    Time in hours: 24
 
  C# 7.0 以降では、 get アクセサーと set アクセサーのどちらも、式形式のメンバーとして実装できます。 この場合、 get キー ワードと set キーワードを使用する必要があります。両方のアクセサーに式本体の定義を使用する例を次に示します。 get アクセサーで return キーワードが使用されていない点に注意してください。
    using System;
public class Person
{
   private string _firstName;
   private string _lastName;
   public Person(string first, string last)
   {
      _firstName = first;
      _lastName = last;
   }
   public string Name => $"{_firstName} {_lastName}";
}
public class Example
{
   public static void Main()
   {
      var person = new Person("Magnus", "Hedlund");
      Console.WriteLine(person.Name);
   }
}
// The example displays the following output:
//      Magnus Hedlund
 
   自動実装プロパティ
ロジックを追加しなくても、プロパティの get アクセサーと set アクセサーはバッキングフィールドに値を割り当てたりバッキング フィールドから取得したりすることができます。 この自動実装プロパティを使用すると、C# コンパイラによってバッキング フィールド が透過的に提供されるため、コードを簡略化できます。
プロパティが get アクセサーと set アクセサーの両方を備えている場合は、両方を自動実装する必要があります。 自動実装 プロパティを定義するには、実装を省略して get キーワードと set キーワードを使用します。次の例は前の例と似ています が、 Name と Price が自動実装プロパティである点が異なります。 この例では、パラメーター化されたコンストラクターも削除さ れているため、 SaleItem オブジェクトがパラメーターなしのコンストラクターの呼び出しとオブジェクト初期化子を使用して初期 化されています。
    using System;
public class SaleItem
{
   string _name;
   decimal _cost;
   public SaleItem(string name, decimal cost)
   {
_name = name;
      _cost = cost;
   }
   public string Name
   {
get => _name;
      set => _name = value;
   }
   public decimal Price
   {
get => _cost;
      set => _cost = value;
   }
}
class Program
{
   static void Main(string[] args)
   {
      var item = new SaleItem("Shoes", 19.95m);
      Console.WriteLine($"{item.Name}: sells for {item.Price:C2}");
   }
}
// The example displays output like the following:
//       Shoes: sells for $19.95
 
              関連項目
プロパティの使用 インターフェイスのプロパティ プロパティとインデクサーの比較 アクセサーのアクセシビリティの制限 自動実装プロパティ
C# 言語仕様
詳細については、「C# 言語の仕様」のプロパティに関するセクションを参照してください。 言語仕様は、C# の構文と使用法に
関する信頼性のある情報源です。 関連項目
C# プログラミング ガイド プロパティの使用 インデクサー
get キーワード
set キーワード
   using System;
public class SaleItem
{
   public string Name
   { get; set; }
   public decimal Price
{ get; set; } }
class Program
{
   static void Main(string[] args)
   {
      var item = new SaleItem{ Name = "Shoes", Price = 19.95m };
      Console.WriteLine($"{item.Name}: sells for {item.Price:C2}");
   }
}
// The example displays output like the following:
//       Shoes: sells for $19.95
 
     プロパティは、フィールドとメソッドの両方の側面を結合します。 オブジェクトのユーザーにとってプロパティは、プロパティへのアクセ スに同じ構文を必要とするフィールドのように見えます。 クラスの実装者にとってプロパティは、get アクセサーと set アクセサーの 両方またはいずれかを表す1つまたは2つのコードブロックです。 get アクセサーのコードブロックはプロパティが読み取られる 時に実行され、 set アクセサーのコード ブロックはプロパティに新しい値が割り当てられるときに実行されます。 set アクセサー のないプロパティは読み取り専用と見なされます。 get アクセサーのないプロパティは書き込み専用と見なされます。両方のア クセサーを持つプロパティは、読み取り/書き込みです。
フィールドとは異なり、プロパティは変数には分類されません。 そのため、プロパティを ref または out パラメーターとして渡すこと はできません。
プロパティには次のようなさまざまな用途があります。変更を許可する前にデータを検証したり、データをそのデータが実際に他の ソース (データベースなど) から取得されるクラスで透過的に公開したり、イベントの発生や他のフィールドの値を変更するなど、 データが変更されたときに、アクションを実行したりすることができます。
プロパティはクラスブロックで宣言できます。フィールドのアクセスレベル、プロパティの型、プロパティの名前、get アクセサーと set アクセサーの両方またはいずれかを宣言するコードブロックの順で指定します。次に例を示します。
    public class Date
{
    private int _month = 7;  // Backing store
    public int Month
    {
        get => _month;
        set
        {
} }
}
if ((value > 0) && (value < 13))
{
    _month = value;
}
 この例では、 set アクセサーが Month が 1 から 12 までの値に設定されていることを確認できるように、 Month がプロパティと して宣言されています。 Month プロパティは、プライベートフィールドを使用して実際の値を追跡します。プロパティのデータの 実際の場所は、プロパティの "バッキング ストア" と呼ばれることがよくあります。 プロパティがプライベート フィールドをバッキング ス トアとして使用するのは一般的なことです。 フィールドは、プロパティを呼び出すことでのみ変更できるようにするため、プライベー トとマークされます。 パブリックおよびプライベートのアクセス制限の詳細については、「アクセス修飾子」を参照してください。
自動実装プロパティは、単純なプロパティ宣言の簡単な構文を提供します。 詳細については、「自動実装プロパティ」を参照し てください。
get アクセサー
get アクセサーの本体は、メソッドの本体と似ています。プロパティの型の値を返す必要があります。 get アクセサーの実行 は、フィールドの値を読み取ることに相当します。 たとえば、 get アクセサーからプライベート変数を返し、最適化が有効になっ ている場合、 get アクセサー メソッドへの呼び出しはコンパイラによってインライン化されるため、メソッド呼び出しのオーバーヘッ ドはありません。ただし、仮想 get アクセサーメソッドはインライン化できません。これは、コンパイラがコンパイル時にどのメソッ ドが実際に実行時に呼び出されるかを認識しないからです。次に、プライベートフィールド _name の値を返す get アクセ
プロパティの使用 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 サーを示します。
    class Person
{
    private string _name;  // the name field
    public string Name => _name;     // the Name property
}
 プロパティを参照するとき、割り当ての対象を除き、 get アクセサーがプロパティの値を読み取るために呼び出されます。 次に 例を示します。
get アクセサーはreturnまたはthrowステートメントで終わる必要があります。コントロールはアクセサー本体をフローオフする ことはできません。
get アクセサーを使用してオブジェクトの状態を変更するのは、悪いプログラミングスタイルです。たとえば、次のアクセサーで は、 _number フィールドにアクセスされるたびにオブジェクトの状態が変更される副作用が発生します。
get アクセサーは、フィールド値を返すまたは計算してから返すために使用できます。次に例を示します。
前のコードセグメントで Name プロパティに値を割り当てない場合、値 NA が返されます。 set アクセサー
set アクセサーは、戻り値の型がvoidのメソッドと似ています。型がプロパティの型の value と呼ばれる暗黙のパラメーターを 使用します。 次の例では、 set アクセサーが Name プロパティに追加されます。
    Person person = new Person();
//...
System.Console.Write(person.Name);  // the get accessor is invoked here
      private int _number;
public int Number => _number++; // Don't do this
     class Employee
{
    private string _name;
    public string Name => _name != null ? _name : "NA";
}
     class Person
{
    private string _name;  // the name field
    public string Name    // the Name property
    {
get => _name;
        set => _name = value;
    }
}
 プロパティに値を割り当てるときに、新しい値を提供する引数を使用して set アクセサーが呼び出されます。次に例を示しま す。

       set アクセサーでローカル変数の宣言に暗黙のパラメーター名 value を使用すると、エラーになります。 Remarks
プロパティは public 、 private 、 protected 、 internal 、 protected internal 、 private protected のいずれかでマー クできます。 これらのアクセス修飾子により、クラスのユーザーがプロパティにアクセスできる方法が定義されます。 同じプロパティ の get と set アクセサーは、異なるアクセス修飾子を持つことができます。 たとえば、 get を public にして、型の外部か らの読み取り専用アクセスを許可して、 set を private または protected にすることができます。 詳細については、「アクセ ス修飾子」を参照してください。
static キーワードを使用して、プロパティを静的プロパティとして宣言できます。その場合、クラスのインスタンスが存在しなくて も、呼び出し元がいつでもプロパティを使用できるようになります。 詳細については、「静的クラスと静的クラス メンバー」を参照 してください。
プロパティは、virtual キーワードを使用して仮想プロパティとしてマークできます。 その場合、派生クラスでは、override キー ワードを使用してプロパティの動作をオーバーライドできます。 これらのオプションの詳細については、「継承」を参照してください。
仮想プロパティをオーバーライドするプロパティは、sealed にすることもできます。その場合、派生クラスでは、プロパティが仮想で なくなります。 最後に、プロパティは抽象として宣言できます。 つまり、クラスに実装はなく、派生クラスが独自の実装を記述す る必要があります。 これらのオプションの詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してくださ い。
例
この例では、インスタンス、静的、および読み取り専用のプロパティを示します。 キーボードから従業員の名前を受け取り、 NumberOfEmployees を1だけインクリメントし、従業員の名前と番号を表示します。
              NOTE
静的プロパティのアクセサーでvirtual、abstract、または override 修飾子を使用すると、エラーになります。
     Person person = new Person();
person.Name = "Joe";  // the set accessor is invoked here
System.Console.Write(person.Name);  // the get accessor is invoked here
 
  例
この例では、派生クラスで同じ名前を持つ別のプロパティによって非表示にされている基底クラスのプロパティにアクセスする方法 を示します。
   public class Employee
{
    public static int NumberOfEmployees;
    private static int _counter;
    private string _name;
    // A read-write instance property:
    public string Name
    {
get => _name;
        set => _name = value;
    }
    // A read-only static property:
    public static int Counter => _counter;
    // A Constructor:
    public Employee() => _counter = ++NumberOfEmployees; // Calculate the employee's number:
}
class TestEmployee
{
    static void Main()
    {
        Employee.NumberOfEmployees = 107;
        Employee e1 = new Employee();
        e1.Name = "Claude Vige";
        System.Console.WriteLine("Employee number: {0}", Employee.Counter);
        System.Console.WriteLine("Employee name: {0}", e1.Name);
    }
}
/* Output:
    Employee number: 108
    Employee name: Claude Vige
*/
 
      前の例で重要な点を次に示します。
派生クラスのプロパティ Name により基底クラス内のプロパティ Name が非表示になっています。 このような場合、 new 修飾子は派生クラスのプロパティの宣言で使用されます。
キャスト (Employee) は基底クラスで非表示のプロパティにアクセスするために使用されます。
メンバーを非表示にする詳細については、「new 修飾子」を参照してください。 例
この例では、 Cube と Square の 2 つのクラスが抽象クラス Shape を実装し、その抽象 Area プロパティをオーバーライドしま す。 プロパティでの override 修飾子の使用に注意してください。 プログラムは、入力として辺を受け入れ、四角形と立方体の 面積を計算します。 プログラムはまた、入力として面積を受け入れ、四角形と立方体の対応する辺を計算します。
  public new string Name
    ((Employee)m1).Name = "Mary";
    public class Employee
{
    private string _name;
    public string Name
    {
get => _name;
        set => _name = value;
    }
}
public class Manager : Employee
{
    private string _name;
    // Notice the use of the new modifier:
    public new string Name
    {
get => _name;
        set => _name = value + ", Manager";
    }
}
class TestHiding
{
    static void Main()
    {
        Manager m1 = new Manager();
        // Derived class property.
        m1.Name = "John";
        // Base class property.
        ((Employee)m1).Name = "Mary";
        System.Console.WriteLine("Name in the derived class is: {0}", m1.Name);
        System.Console.WriteLine("Name in the base class is: {0}", ((Employee)m1).Name);
    }
}
/* Output:
    Name in the derived class is: John, Manager
    Name in the base class is: Mary
*/

   abstract class Shape
{
    public abstract double Area
    {
get;
set; }
}
class Square : Shape
{
    public double side;
    //constructor
    public Square(double s) => side = s;
    public override double Area
    {
        get => side * side;
        set => side = System.Math.Sqrt(value);
    }
}
class Cube : Shape
{
    public double side;
    //constructor
    public Cube(double s) => side = s;
    public override double Area
    {
        get => 6 * side * side;
        set => side = System.Math.Sqrt(value / 6);
    }
}
class TestShapes
{
    static void Main()
    {
} }
// Input the side:
System.Console.Write("Enter the side: ");
double side = double.Parse(System.Console.ReadLine());
// Compute the areas:
Square s = new Square(side);
Cube c = new Cube(side);
// Display the results:
System.Console.WriteLine("Area of the square = {0:F2}", s.Area);
System.Console.WriteLine("Area of the cube = {0:F2}", c.Area);
System.Console.WriteLine();
// Input the area:
System.Console.Write("Enter the area: ");
double area = double.Parse(System.Console.ReadLine());
// Compute the sides:
s.Area = area;
c.Area = area;
// Display the results:
System.Console.WriteLine("Side of the square = {0:F2}", s.side);
System.Console.WriteLine("Side of the cube = {0:F2}", c.side);
/* Example Output:
  
    /* Example Output:
 関連項目
C# プログラミング ガイド プロパティ インターフェイスのプロパティ 自動実装プロパティ
       Enter the side: 4
    Area of the square = 16.00
    Area of the cube = 96.00
    Enter the area: 24
    Side of the square = 4.90
    Side of the cube = 2.00
*/
 
      interface でプロパティを宣言することができます。 次の例では、インターフェイス プロパティ アクセサーが宣言されます。
    public interface ISampleInterface
{
    // Property declaration:
    string Name
    {
get;
set; }
}
 インターフェイス プロパティには通常、本体がありません。 プロパティが読み取り/書き込み、読み取り専用、書き込み専用のうち のどれであるかは、アクセサーによって示されます。 クラスや構造体の場合とは異なり、本体なしでアクセサーを宣言した場 合、自動実装プロパティは宣言されません。 C# 8.0 以降では、インターフェイスによって、プロパティを含む、メンバーの既定の 実装を定義できます。 インターフェイスでプロパティの既定の実装を定義することはまれです。インターフェイスでは、インスタンス データ フィールドが定義されないことがあるためです。
例
この例では、インターフェイス に読み取り/書き込み専用のプロパティ Name および読み取り専用のプロパティ Counter があります。クラス は IEmployee インターフェイスを実装し、これら2つのプロパティを使用します。プロ
グラムは、新しい従業員の名前と現在の従業員の数を読み込んで、従業員の名前と計算した従業員番号を表示します。 メンバーが宣言されているインターフェイスを参照するプロパティの完全修飾名を使用することができます。 次に例を示します。
前の例では、明示的なインターフェイス実装を確認できます。 たとえば、 Employee クラスが 2 つのインターフェイス ICitizen と IEmployee を実装し、両方のインターフェイスが同じ Name プロパティを持っている場合、明示的なインターフェイスメンバー の実装が必要です。 つまり、次のプロパティの宣言があります。
これは、 IEmployee インターフェイスで Name プロパティを実装します。次の宣言があります。
 IEmployee
  Employee
      string IEmployee.Name
{
    get { return "Employee Name"; }
set { } }
        string IEmployee.Name
{
    get { return "Employee Name"; }
set { } }
  インターフェイスのプロパティ (C# プログラミ
ング ガイド) 2020/11/02 • • Edit Online
 
   これは、 ICitizen インターフェイスで Name プロパティを実装します。
    interface IEmployee
{
string Name {
get;
set; }
int Counter {
get; }
}
public class Employee : IEmployee
{
    public static int numberOfEmployees;
    private string _name;
    public string Name  // read-write instance property
    {
get => _name;
        set => _name = value;
    }
    private int _counter;
    public int Counter  // read-only instance property
    {
        get => _counter;
    }
    // constructor
    public Employee() => _counter = ++numberOfEmployees;
}
     System.Console.Write("Enter number of employees: ");
Employee.numberOfEmployees = int.Parse(System.Console.ReadLine());
Employee e1 = new Employee();
System.Console.Write("Enter the name of the new employee: ");
e1.Name = System.Console.ReadLine();
System.Console.WriteLine("The employee information:");
System.Console.WriteLine("Employee number: {0}", e1.Counter);
System.Console.WriteLine("Employee name: {0}", e1.Name);
   210 Hazem Abolrous
サンプル出力
   string ICitizen.Name
{
    get { return "Citizen Name"; }
set { } }
 
        関連項目
C# プログラミング ガイド プロパティ
プロパティの使用 プロパティとインデクサーの比較 インデクサー
インターフェイス
   Enter number of employees: 210
Enter the name of the new employee: Hazem Abolrous
The employee information:
Employee number: 211
Employee name: Hazem Abolrous
 
       プロパティまたはインデクサーの get および set 部分は、アクセサーと呼ばれます。 既定では、これらのアクセサーは、それらが属 するプロパティまたはインデクサーと同じ可視性またはアクセス レベルを持っています。 詳細については、「アクセシビリティ レベル」 を参照してください。 ただし、これらのアクセサーのいずれかにアクセスを制限すると便利な場合があります。 通常、これには、
set アクセサーのアクセシビリティを制限しながら、 get アクセサーのパブリック アクセスを維持する操作が含まれます。 次に例 を示します。
    private string _name = "Hello";
public string Name
{
get {
        return _name;
    }
    protected set
    {
        _name = value;
    }
}
 この例では、 Name というプロパティが get および set アクセサーを定義します。 get アクセサーは、プロパティ自体のアクセ シビリティレベル(この場合は public)を受け取り、同時に set アクセサーは、protectedアクセサー修飾子をアクセサー自 体に適用することによって明示的に制限されます。
アクセサーのアクセス修飾子の制限 プロパティまたはインデクサーでのアクセサー修飾子の使用は、以下の条件の対象になります。
インターフェイスまたは明示的な interface メンバーの実装でアクセサー修飾子を使用することはできません。 アクセサー修飾子は、プロパティまたはインデクサーに set と get アクセサーの両方がある場合にのみ使用できます。
この場合、修飾子は、2 つのアクセサーのいずれかでのみ許可されます。
プロパティまたはインデクサーに override 修飾子がある場合は、アクセサー修飾子はオーバーライドされるアクセサーのア
クセサー (存在する場合) と一致する必要があります。
アクセサーのアクセシビリティ レベルは、プロパティまたはインデクサー自体のアクセシビリティ レベルよりも制限されていなけ
ればなりません
オーバーライドするアクセサーのアクセス修飾子
プロパティまたはインデクサーをオーバーライドする場合は、オーバーライドされたアクセサーがオーバーライドするコードにアクセス できなければなりません。 プロパティ/インデクサーとそのアクセサー両方のアクセシビリティが、対応するオーバーライドされるプロパ ティ/インデクサーおよびアクセサーと一致している必要があります。 次に例を示します。
 アクセサーのアクセシビリティの制限 (C# プロ
グラミング ガイド) 2020/11/02 • • Edit Online
 
   インターフェイスの実装
アクセサーを使用してインターフェイスを実装する場合、アクセサーがアクセス修飾子を持つことはできません。 ただし、 get など の 1 つのアクセサーを使用してインターフェイスを実装する場合、他のアクセサーは、次の例のように、アクセス修飾子を持つこと ができます。
    public interface ISomeInterface
{
    int TestProperty
    {
        // No access modifier allowed here
        // because this is an interface.
        get;
} }
public class TestClass : ISomeInterface
{
    public int TestProperty
    {
} }
// Cannot use access modifier here because
// this is an interface implementation.
get { return 10; }
// Interface property does not have set accessor,
// so access modifier is allowed.
protected set { }
 アクセサー アクセシビリティ ドメイン アクセサーでアクセス修飾子を使用する場合、アクセサーのアクセシビリティ ドメインはこの修飾子によって決まります。
アクセサーでアクセス修飾子を使用しなかった場合、アクセサーのアクセシビリティ ドメインは、プロパティまたはインデクサーのアク セシビリティ レベルによって決まります。
   public class Parent
{
    public virtual int TestProperty
    {
        // Notice the accessor accessibility level.
        protected set { }
        // No access modifier is used here.
        get { return 0; }
    }
}
public class Kid : Parent
{
    public override int TestProperty
    {
        // Use the same accessibility level as in the overridden accessor.
        protected set { }
        // Cannot use access modifier here.
        get { return 0; }
    }
}
 
  例
次の例は、 BaseClass 、 DerivedClass 、および MainClass という 3 つのクラスを含んでいます。 すべてのクラスの 、Name、Id に2つのプロパティがあります。この例は、protectedやprivateなどの制限アクセス修飾子を使用
するときに、 BaseClass のプロパティ Id によって のプロパティ Id を非表示にする方法を示しています。 そ
    BaseClass
  のため、このプロパティに値を割り当てるときには、代わりに クセス修飾子を置き換えると、プロパティがアクセス可能になります。
クラスのプロパティが呼び出されます。 public によってア
DerivedClass
 BaseClass
   この例はまた、 DerivedClass の Name プロパティの set アクセサー上の private や protected などの制限されるアクセ ス修飾子が、アクセサーへのアクセスを防ぎ、アクセサーに割り当てたときにエラーが生成されることも示しています。
    public class BaseClass
{
    private string _name = "Name-BaseClass";
    private string _id = "ID-BaseClass";
    public string Name
    {
        get { return _name; }
set { } }
    public string Id
    {
        get { return _id; }
set { } }
}
public class DerivedClass : BaseClass
{
    private string _name = "Name-DerivedClass";
    private string _id = "ID-DerivedClass";
    new public string Name
    {
get {
            return _name;
        }
        // Using "protected" would make the set accessor not accessible.
        set
        {
            _name = value;
        }
}
    // Using private on the following property hides it in the Main Class.
    // Any assignment to the property will use Id in BaseClass.
    new private string Id
    {
get {
return _id; }
set {
_id = value; }
} }
class MainClass
{
static void Main()

     コメント
宣言 new private string Id を new public string Id によって置き換えた場合、次の出力を取得します。
 Name and ID in the base class: Name-BaseClass, ID-BaseClass
 Name and ID in the derived class: John, John123
関連項目
C# プログラミング ガイド プロパティ
インデクサー アクセス修飾子
    } }
static void Main()
{
   BaseClass b1 = new BaseClass();
DerivedClass d1 = new DerivedClass();
b1.Name = "Mary";
d1.Name = "John";
b1.Id = "Mary123";
d1.Id = "John123";  // The BaseClass.Id property is called.
System.Console.WriteLine("Base: {0}, {1}", b1.Name, b1.Id);
System.Console.WriteLine("Derived: {0}, {1}", d1.Name, d1.Id);
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
/* Output:
    Base: Name-BaseClass, ID-BaseClass
    Derived: John, ID-BaseClass
*/
 
   プロパティは、オブジェクトのデータへの保護されていない、制御されず未確認のアクセスに伴うリスクなしにパブリック データ メン バーの利便性を提供します。 これは アクセサー を通じて行われます。アクセサーは、基になるデータ メンバーの値を割り当てた り、取得したりする特殊なメソッドです。 set アクセサーはデータ メンバーの割り当てを可能にし、get アクセサーはデータ メン バーの値を取得します。
このサンプルでは、Name (string)および Age (int)という2つのプロパティを持つ Person クラスを示します。両方のプロパ ティは get および set アクセサーを提供するため、読み取り/書き込みプロパティと見なされます。
例
    読み取り/書き込みプロパティを宣言および使用
する方法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
  class Person
{
    private string _name = "N/A";
    private int _age = 0;
    // Declare a Name property of type string:
    public string Name
    {
get {
            return _name;
        }
set {
            _name = value;
        }
}
    // Declare an Age property of type int:
    public int Age
    {
get {
            return _age;
        }
set {
            _age = value;
        }
}
    public override string ToString()
    {
        return "Name = " + Name + ", Age = " + Age;
    }
}
class TestPerson
{
    static void Main()
    {
        // Create a new Person object:
        Person person = new Person();

   信頼性の高いプログラミング
前述の例では、 Name および Age プロパティはパブリックであり、 get および set アクセサーの両方が含まれます。 そのた め、任意のオブジェクトがこれらのプロパティを読み書きできます。 ただし、アクセサーのいずれかを除外することが望ましい場合も あります。たとえば、次のように set アクセサーを省略すると、プロパティが読み取り専用になります。
    public string Name
{
get {
        return _name;
    }
set {
        _name = value;
    }
}
 また、一方のアクセサーをパブリックに公開し、もう一方を private または protected にすることもできます。 詳細については、 「アクセサーのアクセシビリティの制限 (C# プログラミング ガイド)」を参照してください。
プロパティを宣言すると、プロパティをクラスのフィールドのように使用できます。 そのため、プロパティ値の取得と設定の両方で、 次のように自然な構文を使用できます。
プロパティの set メソッドでは、特殊な value 変数を使用できることに注意してください。この変数には、ユーザーが指定した 値が含まれます。たとえば、次のように指定します。
    person.Name = "Joe";
person.Age = 99;
   _name = value;
  Person オブジェクトの Age プロパティの値を増分する場合は、次のような簡潔な構文を使用します。
   } }
// Print out the name and the age associated with the person:
Console.WriteLine("Person details - {0}", person);
// Set some values on the person object:
person.Name = "Joe";
person.Age = 99;
Console.WriteLine("Person details - {0}", person);
// Increment the Age property:
person.Age += 1;
Console.WriteLine("Person details - {0}", person);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    Person details - Name = N/A, Age = 0
    Person details - Name = Joe, Age = 99
    Person details - Name = Joe, Age = 100
*/
 
     set メソッドと get メソッドがそれぞれ使用されてプロパティがモデル化されている場合、上記と同じ内容のコードは次のように なります。
この例では、 ToString メソッドが次のようにオーバーライドされます。
プログラムでは ToString が明示的に使用されないことに注意してください。 既定では、 WriteLine 呼び出しによって呼び出 されます。
関連項目
C# プログラミング ガイド プロパティ クラスと構造体
  person.SetAge(person.GetAge() + 1);
      public override string ToString()
{
    return "Name = " + Name + ", Age = " + Age;
}
    person.Age += 1;
 
   C# 3.0 以降では、自動実装プロパティを使用することで、プロパティ アクセサーに追加のロジックが必要ない場合は、プロパティ をより簡潔に宣言できます。 これにより、クライアント コードでオブジェクトを作成することも可能になります。 次の例に示すように プロパティを宣言する場合、コンパイラによって、プロパティの get および set アクセサーを介してのみアクセスできる、プライ ベートの匿名バッキング フィールドが作成されます。
例 次の例に、自動実装プロパティを持つ簡単なクラスを示します。
    // This class is mutable. Its data can be modified from
// outside the class.
class Customer
{
    // Auto-implemented properties for trivial get and set
    public double TotalPurchases { get; set; }
    public string Name { get; set; }
    public int CustomerId { get; set; }
    // Constructor
    public Customer(double purchases, string name, int id)
    {
        TotalPurchases = purchases;
        Name = name;
        CustomerId = id;
}
    // Methods
    public string GetContactInfo() { return "ContactInfo"; }
    public string GetTransactionHistory() { return "History"; }
    // .. Additional methods, events, etc.
}
class Program
{
    static void Main()
    {
        // Intialize a new object.
        Customer cust1 = new Customer(4987.63, "Northwind", 90108);
        // Modify a property.
        cust1.TotalPurchases += 499.99;
    }
}
 インターフェイスで自動実装プロパティを宣言することはできません。 自動実装プロパティでは、プライベートのインスタンス バッキ ング フィールドが宣言されます。インターフェイスでは、インスタンス フィールドを宣言できません。 本文を定義せずにインターフェ イスでプロパティを宣言すると、アクセサーを利用してプロパティが宣言されますが、そのアクセサーは、そのインターフェイスを実装 する型ごとに実装する必要があります。
C# 6 以降では、フィールドと同様に自動実装プロパティを初期化することができます。
自動実装するプロパティ (C# プログラミング ガ
イド)
2020/11/02 • • Edit Online
 
     前の例に示したクラスは、変更可能です。 クライアント コードでは、作成後、オブジェクト内の値を変更できます。 データだけで なく、重要な動作 (メソッド) も含まれる複雑なクラスでは、多くの場合、パブリック プロパティが必要です。 ただし、値 (データ) の セットをカプセル化しているだけで、動作をほとんど、またはまったく含まない小さなクラスや構造体の場合は、set アクセサーを private (コンシューマーからは変更できない) として宣言するか、または get アクセサー (コンストラクターを除くすべての場所で変 更できない) のみを宣言することで、オブジェクトを変更不可能にする必要があります。 詳細については、「自動実装するプロパ ティを使用して簡易クラスを実装する方法」を参照してください。
関連項目
プロパティ 修飾子
 public string FirstName { get; set; } = "Jane";
 
   この例では、一連の自動実装プロパティのカプセル化のみを行う、変更できない簡易クラスの作成方法を示します。 参照型の セマンティクスを使用する必要がある場合は、構造体ではなく次のようなコンストラクトを使用します。
変更できないプロパティの作成方法は 2 つあります。
set アクセサーは、private として宣言することができます。 プロパティは型の中のみで設定可能で、コンシューマーは変更
できません。
set アクセサーをprivateで宣言した場合、オブジェクト初期化子を使用してプロパティを初期化することはできませ ん。 コンストラクターまたはファクトリ メソッドを使用する必要があります。
get アクセサーのみを宣言し、その型のコンストラクターを除くすべての場所でプロパティを変更できないようにすることがで きます。
次の例では、get アクセサーのみを持つプロパティが、get と private set を持つプロパティとどのように異なるかを示しています。
    class Contact
{
    public string Name { get; }
    public string Address { get; private set; }
    public Contact(string contactName, string contactAddress)
    {
        // Both properties are accessible in the constructor.
        Name = contactName;
        Address = contactAddress;
}
    // Name isn't assignable here. This will generate a compile error.
    //public void ChangeName(string newName) => Name = newName;
    // Address is assignable here.
    public void ChangeAddress(string newAddress) => Address = newAddress
}
 例
次の例は、自動実装プロパティを持つ変更できないクラスを実装する 2 つの方法を示します。 それぞれの方法では、プロパティ の 1 つを private set で、1 つを get のみで宣言します。 最初のクラスはプロパティの初期化にコンストラクターのみを使用し ますが、2 番目のクラスは、コンストラクターを呼び出す静的ファクトリ メソッドを使用します。
自動実装するプロパティを使用して簡易クラスを
実装する方法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
     // This class is immutable. After an object is created,
// it cannot be modified from outside the class. It uses a
// constructor to initialize its properties.
class Contact
{
    // Read-only property.
    public string Name { get; }
    // Read-write property with a private set accessor.
    public string Address { get; private set; }

      // Public constructor.
    public Contact(string contactName, string contactAddress)
    {
        Name = contactName;
        Address = contactAddress;
    }
}
// This class is immutable. After an object is created,
// it cannot be modified from outside the class. It uses a
// static method and private constructor to initialize its properties.
public class Contact2
{
    // Read-write property with a private set accessor.
    public string Name { get; private set; }
    // Read-only property.
    public string Address { get; }
    // Private constructor.
    private Contact2(string contactName, string contactAddress)
    {
        Name = contactName;
        Address = contactAddress;
    }
    // Public factory method.
    public static Contact2 CreateContact(string name, string address)
    {
        return new Contact2(name, address);
    }
}
public class Program
{
    static void Main()
    {
        // Some simple data sources.
        string[] names = {"Terry Adams","Fadi Fakhouri", "Hanying Feng",
                            "Cesar Garcia", "Debra Garcia"};
        string[] addresses = {"123 Main St.", "345 Cypress Ave.", "678 1st Ave",
                                "12 108th St.", "89 E. 42nd St."};
        // Simple query to demonstrate object creation in select clause.
        // Create Contact objects by using a constructor.
        var query1 = from i in Enumerable.Range(0, 5)
                    select new Contact(names[i], addresses[i]);
        // List elements cannot be modified by client code.
        var list = query1.ToList();
        foreach (var contact in list)
        {
            Console.WriteLine("{0}, {1}", contact.Name, contact.Address);
        }
        // Create Contact2 objects by using a static factory method.
        var query2 = from i in Enumerable.Range(0, 5)
                        select Contact2.CreateContact(names[i], addresses[i]);
        // Console output is identical to query1.
        var list2 = query2.ToList();
        // List elements cannot be modified by client code.
        // CS0272:
        // list2[0].Name = "Eugene Zabokritski";
        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
  Console.ReadKey();

   コンパイラによって、各自動実装プロパティにバッキング フィールドが作成されます。 このフィールドは、ソース コードから直接アク セスできません。
関連項目
プロパティ
struct
オブジェクト初期化子とコレクション初期化子
        Console.ReadKey();
    }
/* Output:
    Terry Adams, 123 Main St.
    Fadi Fakhouri, 345 Cypress Ave.
    Hanying Feng, 678 1st Ave
    Cesar Garcia, 12 108th St.
    Debra Garcia, 89 E. 42nd St.
*/
   }
 
     メソッドは、一連のステートメントが含まれているコード ブロックです。 必要なメソッド引数を指定してプログラムからメソッドを呼び 出すと、メソッド内のステートメントが実行されます。 C# では、実行されるすべての命令がメソッドのコンテキストで実行されま す。 Main メソッドは、すべてのC#アプリケーションのエントリポイントです。プログラムが開始されると、このメソッドが共通言語 ランタイム (CLR) によって呼び出されます。
メソッド シグネチャ
メソッドは、クラス、構造体、またはインターフェイス内で、アクセスレベル(public や private など)、オプションの修飾子( abstract や sealed など)、戻り値、メソッドの名前、およびメソッドパラメーターを指定して宣言されます。これらのまとまりが
メソッドのシグネチャとなります。
メソッド パラメーターはかっこで囲み、各パラメーターをコンマで区切ります。 かっこ内を空にすると、メソッドでパラメーターが不要 なことを意味します。 このクラスには次の 4 つのメソッドが含まれています。
    NOTE
この記事では、名前付きメソッドについて説明します。 匿名関数については、「匿名関数」を参照してください。
         IMPORTANT
メソッドのオーバーロードを可能にするために、メソッドの戻り値の型はメソッドのシグネチャには含まれません。 ただし、デリゲートとそれが指す メソッドの互換性を決定する場合には、メソッドのシグネチャの一部となります。
     abstract class Motorcycle
{
    // Anyone can call this.
    public void StartEngine() {/* Method statements here */ }
    // Only derived classes can call this.
    protected void AddGas(int gallons) { /* Method statements here */ }
    // Derived classes can override the base class implementation.
    public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }
    // Derived classes must implement this.
    public abstract double GetTopSpeed();
}
 メソッド アクセス
オブジェクトでメソッドを呼び出すのは、フィールドにアクセスするのと似ています。 オブジェクト名の後に、ピリオド、メソッド名、かっ こを追加します。引数はかっこの中に記述し、コンマで区切ります。 Motorcycle クラスのメソッドの呼び出し例を次に示しま す。
 メソッド (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
   メソッドのパラメーターと引数
メソッド定義には、必要なパラメーターの名前と型を指定します。 呼び出し元のコードからメソッドを呼び出すときに、各パラメー ターに引数と呼ばれる具体的な値を指定します。 引数にはパラメーター型との互換性が必要ですが、呼び出し元のコードで引 数名を使用する場合、引数名がメソッドで定義されるパラメーター名と同じである必要はありません。 次に例を示します。
    public void Caller()
{
    int numA = 4;
    // Call with an int variable.
    int productA = Square(numA);
    int numB = 32;
    // Call with another int variable.
    int productB = Square(numB);
    // Call with an integer literal.
    int productC = Square(12);
    // Call with an expression that evaulates to int.
    productC = Square(productA * 3);
}
int Square(int i)
{
    // Store input argument in a local variable.
    int input = i;
    return input * input;
}
 参照渡しと値渡し
既定では、値の型のインスタンスがメソッドに渡されるときは、インスタンス自体ではなく、そのコピーが渡されます。 したがって、 引数に加えた変更は、呼び出し元のメソッドにある元のインスタンスには影響しません。 値の型インスタンスを参照で渡すに は、 ref キーワードを使用します。 詳細については、「値型パラメーターの引き渡し」を参照してください。
参照型のオブジェクトがメソッドに渡されると、オブジェクトへの参照が渡されます。 つまり、メソッドは、オブジェクト自体ではなく、 オブジェクトの場所を示す引数を受け取ります。 この参照を使用してオブジェクトのメンバーを変更した場合は、オブジェクトを 値で渡しても、呼び出し元のメソッドの引数に変更が反映されます。
   class TestMotorcycle : Motorcycle
{
    public override double GetTopSpeed()
    {
        return 108.4;
    }
    static void Main()
    {
} }
TestMotorcycle moto = new TestMotorcycle();
moto.StartEngine();
moto.AddGas(15);
moto.Drive(5, 20);
double speed = moto.GetTopSpeed();
Console.WriteLine("My top speed is {0}", speed);
 
  class キーワードを使用して参照型を作成する例を次に示します。
    public class SampleRefType
{
    public int value;
}
  この型に基づくオブジェクトをメソッドに渡す場合は、オブジェクトへの参照が渡されます。 次の例では、 SampleRefType 型のオ ブジェクトをメソッド ModifyObject に渡します。
     public static void TestRefType()
{
    SampleRefType rt = new SampleRefType();
    rt.value = 44;
    ModifyObject(rt);
    Console.WriteLine(rt.value);
}
static void ModifyObject(SampleRefType obj)
{
    obj.value = 33;
}
 この例は、基本的に前の例と同様に、引数を値でメソッドに渡しています。 しかし、参照型を使用しているため、結果は異なり ます。 のパラメーター value の obj フィールドで行われた変更によって、 value メソッドの引数 rt の
フィールドも変更されます。 TestRefType メソッドは出力として33を表示します。 参照型を参照渡しまたは値渡しで渡す方法の詳細については、「参照型パラメーターの引き渡し」と「参照型」を参照してくだ
さい。 戻り値
メソッドは、呼び出し元に値を返すことができます。 戻り値の型 (メソッド名の前に記述されている型) が void でない場合、メ ソッドは、 return キーワードを使用して値を返すことができます。 return キーワードに続いて戻り値の型に一致する値が記 述されたステートメントは、その値をメソッドの呼び出し元に返します。
値を呼び出し元に返す方法には、値によって返す方法と、C# 7.0 以降の参照によって返す方法があります。 値が参照によっ て呼び出し元に返されるのは、 ref キーワードがメソッド シグネチャで使用されていて、そのキーワードが各 キーワード の後に続いている場合です。 たとえば、次のメソッド シグネチャと return ステートメントは、メソッドが変数名 を 参照によって呼び出し元に返すことを示しています。
また、 return キーワードは、メソッドの実行を中止します。 戻り値の型が void の場合、値を持たない return ステートメン トは、メソッドの実行を中止するときに役立ちます。 return キーワードを使用しない場合、メソッドは、コードブロックの最後に 到達したときに実行を中止します。戻り値の型がvoid以外のメソッドで値を返すには、 return キーワードを使用する必要 があります。たとえば、次の2つのメソッドは、 return キーワードを使用して整数を返します。
 ModifyObject
  TestRefType
   return
 estDistance
    public ref double GetEstimatedDistance()
{
    return ref estDistance;
}
      
    メソッドから返された値を使用する場合、呼び出し元のメソッド内で同じ型の値を使用している場所では、メソッド呼び出し自 体を値として使用できます。 戻り値は、変数に代入することもできます。 たとえば、次の 2 つのコードでは、同様の結果が得ら れます。
    int result = obj.AddTwoNumbers(1, 2);
result = obj.SquareANumber(result);
// The result is 9.
Console.WriteLine(result);
     result = obj.SquareANumber(obj.AddTwoNumbers(1, 2));
// The result is 9.
Console.WriteLine(result);
  この場合、ローカル変数 result を使用して値を格納する手順はオプションです。 このローカル変数によってコードの読みやす さが向上することがあります。また、引数の元の値をメソッドのスコープ全体で保持する場合に必要になることがあります。
メソッドから参照によって返された値を使用する場合、値を変更するには、ref ローカル変数を宣言する必要があります。 たとえ ば、Planet.GetEstimatedDistance メソッドがDoubleの値を参照によって返す場合は、次のようなコードを使用して、その値 を ref ローカル変数として定義できます。
呼び出し元の関数から、配列の内容を変更するメソッド M に配列が渡された場合、 M から多次元配列を返す必要はあり ません。値の適切なスタイルまたは機能フローのために M から結果の配列を返すことはできますが、必須ではありません。変 更された配列を返す必要がないのは、C# ではすべての参照型が値で渡され、配列参照の値がその配列へのポインターになる ためです。メソッド M では、次の例に示すように、配列の内容に対する変更は、配列への参照を含むコードによって監視でき ます。
   ref int distance = plant
    class SimpleMath
{
    public int AddTwoNumbers(int number1, int number2)
    {
        return number1 + number2;
    }
    public int SquareANumber(int number)
    {
        return number * number;
    }
}
 
    詳細については、「 return」を参照してください。 非同期メソッド
非同期機能を使用することによって、明示的なコールバックを使用せずに、または複数のメソッドやラムダ式にわたって手動で コードを分割することなく、非同期メソッドを呼び出すことができます。
メソッドに async 修飾子を付けると、そのメソッドで await 演算子を使用できます。 コントロールが非同期メソッドの await 式に 到達すると、コントロールは呼び出し元に戻り、待機中のタスクが完了するまでメソッドの進行状況は中断されます。 タスクが完 了すると、メソッドで実行を再開できます。
非同期メソッドの戻り値の型としては、 Task<TResult>、 Task、または void を指定できます。 戻り値の型 void は主として、 void の戻り値の型が必要なイベント ハンドラーの定義に使用されます。 void を返す非同期メソッドは待機できません。void を返すメソッドの呼び出し元は、このメソッドがスローする例外をキャッチできません。
    NOTE
非同期メソッドは、まだ完了していない待機中の最初のオブジェクトに達するか、または非同期メソッドの最後に達すると、呼び出し元に戻 ります。
   次の例で、 DelayAsync は戻り値の型がTask<TResult>である非同期メソッドです。 return ステートメントがあります。そのため、メソッド宣言 DelayAsync では、戻り値の型を
す。 戻り値の型が であるため、ステートメント await に示すように、 式を評価すると整数が生成されます。
Main メソッドは、戻り値の型がTaskの非同期メソッドの例です。これは 現されるため、キーワードの async と await を省略できます。
DoSomethingAsync を呼び出すタスクは、ステートメント
int result = await delayTask
には、整数を返す とする必要がありま
内の
メソッドに進みます。1行で表 が非同期メソッドであるため、
に示すように待機する必要があります。
DelayAsync
   Task<int>
  Task<int>
DoSomethingAsync
  DoSomethingAsync
 DoSomethingAsync
  await DoSomethingAsync();
   static void Main(string[] args)
{
    int[,] matrix = new int[2, 2];
    FillMatrix(matrix);
    // matrix is now full of -1
}
public static void FillMatrix(int[,] matrix)
{
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
} }
for (int j = 0; j < matrix.GetLength(1); j++)
{
    matrix[i, j] = -1;
}
 
           非同期メソッドで ref パラメーターまたは out パラメーターを宣言することはできませんが、これらのパラメーターを持つメソッドを呼 び出すことはできます。
非同期メソッドの詳細については、「async および await を使用した非同期プログラミング」と非同期の戻り値の型に関する ページを参照してください。
式本体の定義
メソッドの定義としては、式の結果を即座に返すか、またはメソッドの本文として 1 つのステートメントを含むものが一般的です。
=> を使用してこのようなメソッドを定義するための構文ショートカットがあります。
メソッドが void を返すか、非同期メソッドである場合は、メソッドの本文を(ラムダの場合と同様に)ステートメント式にする必 要があります。プロパティとインデクサーは読み取り専用にする必要があるため、 get アクセサーキーワードは使用しないでくだ さい。
Iterators
反復子は、リストや配列など、コレクションに対するカスタム イテレーションを実行します。 反復子は、 yield return ステートメン トを使用して、各要素を 1 回に1 つ返します。 yield return ステートメントに達すると、コードの現在の場所が記憶されます。 反復子が次回呼び出されたとき、この場所から実行が再開されます。
foreach ステートメントを使用して、クライアント コードから反復子を呼び出します。 反復子の戻り値の型には、IEnumerable、IEnumerable<T>、IEnumerator、または IEnumerator<T> を指定できます。
    public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
    using System;
using System.Threading.Tasks;
class Program
{
    static Task Main() => DoSomethingAsync();
    static async Task DoSomethingAsync()
    {
        Task<int> delayTask = DelayAsync();
        int result = await delayTask;
        // The previous two statements may be combined into
        // the following statement.
        //int result = await DelayAsync();
        Console.WriteLine($"Result: {result}");
    }
    static async Task<int> DelayAsync()
    {
        await Task.Delay(100);
return 5; }
}
// Example output:
//   Result: 5
 
         詳細については、「 反復子」を参照してください。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
C# プログラミング ガイド クラスと構造体
アクセス修飾子 静的クラスと静的クラス メンバー 継承
抽象クラスとシール クラス、およびクラス メンバー
params
return
out
ref パラメーターの引き渡し

       C# 7.0 以降、C# では ローカル関数 がサポートされています。 ローカル関数は、別のメンバーの入れ子になっているタイプのプラ イベート メソッドです。 親メンバーからのみ呼び出すことができます。 ローカル関数は次の要素で宣言し、呼び出すことができま す。
メソッド (特に反復子メソッドと非同期メソッド) コンストラクター
プロパティ アクセサー
イベント アクセサー
匿名メソッド
ラムダ式 ファイナライザー その他のローカル関数
ただし、ローカル関数は、式形式のメンバーの内部では宣言できません。
ローカル関数を使用すると、コードの意図が明確になります。 コードを見た人は、メソッドが親メソッドによってのみ呼び出し可能 であることがわかります。 また、チーム プロジェクトの場合は、別の開発者がクラスや構造体の別の場所から誤ってメソッドを直 接呼び出すことができなくなります。
ローカル関数の構文
ローカル関数は、親メンバーの内側に、入れ子になったメソッドとして定義されます。 その定義の構文は次のとおりです。
ローカル関数と共に次の修飾子を使用できます。
async
メソッドのパラメーターを含め、親メンバー内で定義されているすべてのローカル変数は、非静的ローカル関数からアクセス可能 です。
メソッド定義とは異なり、ローカル関数の定義にメンバー アクセス修飾子を含めることはできません。 すべてのローカル関数はプ ライベートであるため、private キーワードなどのアクセス修飾子が含まれていると、コンパイラエラーCS0106"修飾子 'private' がこの項目に対して有効ではありません" が生成されます。
    NOTE
場合によっては、ラムダ式を使用して、ローカル関数でもサポートされている機能を実装できます。 比較については、「ローカル関数とラムダ式 の比較」を参照してください。
   <modifiers> <return-type> <method-name> <parameter-list>
  unsafe
  static
  extern
(C# 8.0 以降)。 静的なローカル関数では、ローカル変数やインスタンスの状態をキャプチャすることはできません。 (C#9.0以降)。外部ローカル関数は static である必要があります。
    次の例は、 GetText というメソッドに対してプライベートな AppendPathSeparator というローカル関数を定義しています。
ローカル関数 (C# プログラミング ガイド) 2021/03/08 • • Edit Online
 
    C# 9.0 以降、次の例に示すように、ローカル関数およびそのパラメーターと型パラメーターに属性を適用できます。
    #nullable enable
private static void Process(string?[] lines, string mark)
{
    foreach (var line in lines)
    {
        if (IsValid(line))
        {
            // Processing logic...
        }
}
    bool IsValid([NotNullWhen(true)] string? line)
    {
        return !string.IsNullOrEmpty(line) && line.Length >= mark.Length;
    }
}
 上の例では、特殊な属性を使用して、Null 許容コンテキストでの静的分析に関してコンパイラをサポートしています。 ローカル関数と例外
ローカル関数の便利な機能の 1 つは、例外を直ちに検出できることです。 メソッド反復子の場合、例外は返されたシーケンス を列挙する時点でしか検出されず、反復子を取得した時点では検出されません。 非同期メソッドの場合、非同期メソッドでス ローされた例外は、タスクの戻りを待機中に検出されます。
次の例は、指定した範囲にある奇数を列挙する OddSequence メソッドを定義しています。100より大きい数値を OddSequence 列挙子メソッドに渡しているため、メソッドはArgumentOutOfRangeExceptionをスローします。この例の出
力が示すように、例外は列挙子を取得したときではなく、数値を反復処理した時点でのみ検出されます。
     private static string GetText(string path, string filename)
{
     var reader = File.OpenText($"{AppendPathSeparator(path)}{filename}");
     var text = reader.ReadToEnd();
     return text;
     string AppendPathSeparator(string filepath)
     {
        return filepath.EndsWith(@"\") ? filepath : filepath + @"\";
     }
}
 
    反復子ロジックをローカル関数に追加した場合、次の例に示すように、列挙子を取得すると引数の検証例外がスローされま す。
  using System;
using System.Collections.Generic;
public class IteratorWithoutLocalExample
{
   public static void Main()
   {
      IEnumerable<int> xs = OddSequence(50, 110);
      Console.WriteLine("Retrieved enumerator...");
      foreach (var x in xs)  // line 11
      {
         Console.Write($"{x} ");
      }
}
   public static IEnumerable<int> OddSequence(int start, int end)
   {
      if (start < 0 || start > 99)
         throw new ArgumentOutOfRangeException(nameof(start), "start must be between 0 and 99.");
      if (end > 100)
         throw new ArgumentOutOfRangeException(nameof(end), "end must be less than or equal to 100.");
      if (start >= end)
         throw new ArgumentException("start must be less than end.");
      for (int i = start; i <= end; i++)
      {
         if (i % 2 == 1)
            yield return i;
} }
}
// The example displays the output like this:
//
//    Retrieved enumerator...
//    Unhandled exception. System.ArgumentOutOfRangeException: end must be less than or equal to 100.
(Parameter 'end')
//    at IteratorWithoutLocalExample.OddSequence(Int32 start, Int32 end)+MoveNext() in
IteratorWithoutLocal.cs:line 22
//    at IteratorWithoutLocalExample.Main() in IteratorWithoutLocal.cs:line 11

     ローカル関数とラムダ式の比較
一見したところ、ローカル関数とラムダ式は、非常に似ています。 多くの場合、ラムダ式とローカル関数の使用のどちらを選択す るかは、スタイルと個人的な好みの問題です。 ただし、どちらか一方を使用できる場合、認識しておくべき実質的な違いがあり ます。
階乗アルゴリズムのローカル関数とラムダ式の実装の違いについて見てみましょう。 ローカル関数を使用するバージョンを次に示 します。
    public static int LocalFunctionFactorial(int n)
{
    return nthFactorial(n);
int nthFactorial(int number) => number < 2 ?1
}
: number * nthFactorial(number - 1);
 このバージョンでは、ラムダ式が使用されます。
  using System;
using System.Collections.Generic;
public class IteratorWithLocalExample
{
   public static void Main()
   {
      IEnumerable<int> xs = OddSequence(50, 110);  // line 8
      Console.WriteLine("Retrieved enumerator...");
      foreach (var x in xs)
      {
         Console.Write($"{x} ");
      }
}
   public static IEnumerable<int> OddSequence(int start, int end)
   {
      if (start < 0 || start > 99)
         throw new ArgumentOutOfRangeException(nameof(start), "start must be between 0 and 99.");
      if (end > 100)
         throw new ArgumentOutOfRangeException(nameof(end), "end must be less than or equal to 100.");
      if (start >= end)
         throw new ArgumentException("start must be less than end.");
      return GetOddSequenceEnumerator();
      IEnumerable<int> GetOddSequenceEnumerator()
      {
         for (int i = start; i <= end; i++)
         {
            if (i % 2 == 1)
               yield return i;
} }
} }
// The example displays the output like this:
//
//    Unhandled exception. System.ArgumentOutOfRangeException: end must be less than or equal to 100.
(Parameter 'end')
//    at IteratorWithLocalExample.OddSequence(Int32 start, Int32 end) in IteratorWithLocal.cs:line 22
//    at IteratorWithLocalExample.Main() in IteratorWithLocal.cs:line 8

      public static int LambdaFactorial(int n)
{
    Func<int, int> nthFactorial = default(Func<int, int>);
nthFactorial = number => number < 2 ?1
        : number * nthFactorial(number - 1);
    return nthFactorial(n);
}
 名前を付ける
ローカル関数には、メソッドと同様に明示的に名前が付けられます。 ラムダ式は匿名メソッドであり、 delegate 型の変数 (通 常は Action 型または Func 型)に割り当てる必要があります。ローカル関数を宣言する場合、プロセスは通常のメソッドを 記述するのと似ています。戻り値の型と関数シグネチャを宣言します。
関数シグネチャとラムダ式の型
ラムダ式は、引数と戻り値の型を決定するために割り当てられている Action / Func 変数の型に依存します。 ローカル関数 では、構文は通常のメソッドの記述とよく似ているため、引数の型と戻り値の型は既に関数宣言の一部になっています。
確実な代入
ラムダ式は、実行時に宣言されて割り当てられるオブジェクトです。 ラムダ式を使用するには、その式を確実に代入する必要が あります。代入先の Action / Func 変数と、代入するラムダ式を宣言する必要があります。 LambdaFactorial では、ラムダ 式 を定義する前に、宣言と初期化を行う必要があることにご注意ください。 その手順を踏まないと、
の割り当て前に参照することによるコンパイル時エラーが発生します。
ローカル関数は、コンパイル時に定義されます。 これらは変数に割り当てられないため、スコープ内の どのコードの場所からでも 参照できます。最初の LocalFunctionFactorial の例では、 return ステートメントの上または下でローカル関数を宣言し て、コンパイラ エラーが発生しないようにすることができます。
これらの違いは、再帰的なアルゴリズムの作成はローカル関数を使用する方が簡単であることを意味します。 自身を呼び出す ローカル関数を宣言して定義することができます。 ラムダ式は宣言して、既定値を割り当てないと、同じラムダ式を参照する本 体に再割り当てできません。
デリゲートとしての実装
ラムダ式は、宣言時にデリゲートに変換されます。 ローカル関数は、従来のメソッド "または" デリゲートと同様に記述できるの
で、より柔軟性があります。 ローカル関数は、デリゲートとして "使用される" 場合にのみ、デリゲートに変換されます。
ローカル関数を宣言し、メソッドのように呼び出して参照のみを行う場合は、デリゲートに変換されません。
変数のキャプチャ
確実な代入のルールは、ローカル関数またはラムダ式でキャプチャされる変数にも影響を与えます。 コンパイラによって静的分 析を実行できます。これにより、ローカル関数で外側のスコープ内のキャプチャされた変数を確実に割り当てることができます。 次の例について考えます。
      nthFactorial
 nthFactorial
      int M() {
    int y;
    LocalFunction();
    return y;
    void LocalFunction() => y = 0;
}
   コンパイラは、呼び出し時に LocalFunction が y を確実に割り当てるかどうかを確認できます。 return ステートメントの前

   に   が呼び出されるため、 y は   ステートメントで確実に割り当てられます。 ローカル関数によって外側のスコープ内の変数をキャプチャする場合、ローカル関数はデリゲート型として実装されることにご注
意ください。
ヒープの割り当て
ローカル関数では、その使用に応じて、ラムダ式では常に必要なヒープの割り当てを回避できます。 ローカル関数がデリゲートに 変換されておらず、ローカル関数でキャプチャされたいずれの変数も、デリゲートに変換された他のラムダやローカル関数でキャプ チャされていない場合は、コンパイラによってヒープの割り当てを回避できます。
次の非同期の例について考えます。
LocalFunction
return
      public async Task<string> PerformLongRunningWorkLambda(string address, int index, string name)
{
    if (string.IsNullOrWhiteSpace(address))
        throw new ArgumentException(message: "An address is required", paramName: nameof(address));
    if (index < 0)
        throw new ArgumentOutOfRangeException(paramName: nameof(index), message: "The index must be non-
negative");
    if (string.IsNullOrWhiteSpace(name))
        throw new ArgumentException(message: "You must supply a name", paramName: nameof(name));
    Func<Task<string>> longRunningWorkImplementation = async () =>
    {
        var interimResult = await FirstWork(address);
        var secondResult = await SecondStep(index, name);
        return $"The results are {interimResult} and {secondResult}. Enjoy.";
};
    return await longRunningWorkImplementation();
}
  このラムダ式のクロージャに含まれるのは、 address 、 index 、および name 変数です。 ローカル関数の場合、クロージャを実 装するオブジェクトが struct になる場合があります。 その構造体型はローカル関数に参照によって渡されます。 この実装の 違いにより、割り当てが少なくなります。
ラムダ式に必要なインスタンス化では、余分なメモリの割り当てが必要となり、タイム クリティカルなコード パスに影響を与えるパ フォーマンス因子となる可能性があります。 ローカル関数では、このオーバーヘッドは発生しません。 上記の例では、ローカル関 数のバージョンは、ラムダ式のバージョンよりも割り当てが 2 つ少なくなっています。
ローカル関数がデリゲートに変換されず、それによってキャプチャされた変数が、デリゲートに変換された他のラムダまたはローカル 関数によってキャプチャされないことがわかっている場合は、ローカル関数を static ローカル関数として宣言することで、ヒープ に割り当てられないようにすることができます。 この機能は C# 8.0 以降で使用可能であることにご注意ください。
      NOTE
このメソッドのローカル関数と同等のものも、同じクロージャのクラスを使用します。 ローカル関数のクロージャが class として実装される場 合でも、実装の詳細が struct である場合でも同様です。 ローカル関数は struct を使用する場合がありますが、ラムダは常に
class を使用します。
   
   yield キーワードの使用法
この例では説明しませんが、最後の 1 つの利点は値のシーケンスを生成するために yield return 構文を使用して、ローカル
関数を反復子として実装できることです。
     public IEnumerable<string> SequenceToLowercase(IEnumerable<string> input)
{
    if (!input.Any())
    {
        throw new ArgumentException("There are no items to convert to lowercase.");
    }
    return LowercaseIterator();
    IEnumerable<string> LowercaseIterator()
    {
} }
foreach (var output in input.Select(item => item.ToLower()))
{
    yield return output;
}
  yield return ステートメントは、ラムダ式では許可されていません。コンパイラ エラー CS1621 を参照してください。 ローカル関数はラムダ式より冗長に思えるかもしれませんが、実際にはさまざまな目的に役立ち、用途もさまざまです。 ローカル
関数は、別のメソッドのコンテキストからのみ呼び出される関数を記述する場合に、より効率が高くなります。
関連項目
メソッド
   public async Task<string> PerformLongRunningWork(string address, int index, string name)
{
    if (string.IsNullOrWhiteSpace(address))
        throw new ArgumentException(message: "An address is required", paramName: nameof(address));
    if (index < 0)
        throw new ArgumentOutOfRangeException(paramName: nameof(index), message: "The index must be non-
negative");
    if (string.IsNullOrWhiteSpace(name))
        throw new ArgumentException(message: "You must supply a name", paramName: nameof(name));
    return await longRunningWorkImplementation();
    async Task<string> longRunningWorkImplementation()
    {
} }
var interimResult = await FirstWork(address);
var secondResult = await SecondStep(index, name);
return $"The results are {interimResult} and {secondResult}. Enjoy.";
 
    C# 7.0 以降の C# は参照戻り値 (ref 戻り値) に対応しています。 参照戻り値を使用すると、メソッドから呼び出し元に、値で はなく、変数への参照を返すことができます。 呼び出し元は、返された変数を値渡しとして処理するか、参照渡しとして処理 するかを選択できます。 呼び出し元は、それ自体が、返された値の参照である新しい変数を作成できます。これは ref ローカ ルと呼ばれています。
参照戻り値とは
呼び出されたメソッドに参照によって引数を渡す参照渡しは、ほとんどの開発者によく知られています。 呼び出されたメソッドの 引数リストには、参照によって渡された変数が含まれています。 呼び出されたメソッドがその値に対して行った変更は、呼び出 し元によって観察されます。 "参照戻り値" とは、メソッドが何らかの変数への "参照" (または別名) を返すことを意味します。 その変数のスコープには、メソッドが含まれている必要があります。 その変数の有効期間は、メソッドから戻った後まで継続して いる必要があります。 呼び出し元によるメソッドの戻り値の変更は、メソッドによって返される変数に対して行われます。
メソッドが参照戻り値を返すという宣言があれば、それはそのメソッドが変数にエイリアスを返すことを示します。 この設計の意図 は、多くの場合、呼び出し元のコードが変数の変更などを行うとき、そのコードにはエイリアス経由でその変数にアクセスさせると いうものです。参照で返すメソッドには戻り値の型 void を与えることができません。
メソッドが参照戻り値として返すことができる式には、いくつかの制限があります。 次のような制約があります。
戻り値の有効期間は、メソッドの実行より長くならないようにする必要があります。 言い換えると、値を返すメソッドに含 まれているローカル変数にすることはできません。 クラスのインスタンスまたは静的フィールドを戻り値にすることができま す。または、メソッドに渡される引数を戻り値にすることもできます。 ローカル変数を返そうとすると、コンパイラ エラー CS8168 "ローカル変数 'obj' は ref ローカル変数ではないため、参照渡しで返すことはできません" が生成されます。
戻り値はリテラル null にすることができません。 null を返すと、コンパイラエラーCS8156"参照渡しで返すことがで きないため、このコンテキストで使用できない式があります" が生成されます。
ref 戻り値があるメソッドは、現在の値が null (インスタンス化されていない) 値か、値の型が null 許容値型の変数にエ イリアスを返すことができます。
戻り値は、定数、列挙型のメンバー、プロパティの値渡し戻り値、 class または struct のメソッドにすることができま せん。 この規則に違反すると、コンパイラ エラー CS8156 "参照渡しで返すことができないため、このコンテキストで使用 できない式があります" が生成されます。
さらに、参照戻り値は非同期メソッドでは許可されません。 非同期メソッドは実行が終了する前に戻る可能性があり、戻り値 はまだ不明です。
ref 戻り値の定義
"参照戻り値" を返すメソッドは、次の 2 つの条件を満たす必要があります。
メソッドのシグネチャで、戻り値の型の前にキーワード ref が含まれること。
メソッド本体の各 return ステートメントで、返されるインスタンスの名前の前に ref キーワードが含まれること。
これらの条件を満たし、 p という名前の Person オブジェクトへの参照を返すメソッドを、次の例に示します。
  ref 戻り値と ref ローカル変数 2020/05/20 • • Edit Online
 
   ref 戻り値の使用
ref 戻り値は、呼び出されるメソッドの範囲で、別の変数のエイリアスになります。 ref 戻り値の使用は、それが別名を与える変
数の使用として解釈できます。
その値を割り当てるとき、それが別名を与える変数に値を割り当てることになります。 その値を読み取るとき、それが別名を与える変数の値を読み取ることになります。
"参照渡し" で値を返す場合、その同じ変数の別名を返すことになります。
"参照渡し" で別のメソッドに値を渡す場合、それが別名を与える変数への参照を渡すことになります。 ref ローカルをエイリアスにすると、同じ変数に新しいエイリアスが作られます。
ref ローカル変数
GetContactInformation メソッドがref戻り値として宣言されているとします。
値渡し代入によって、変数の値が読み取られ、それが新しい変数に渡されます。
先の代入では、ローカル変数として p が宣言されています。その初期値は、 読み取りからコピーされます。 今後、 p に値が代入されることで、 ることはありません。変数 p は、返された変数のエイリアスではなくなります。
によって返された値の によって返された変数の値が変わ
   public ref Person GetContactInformation(string fname, string lname)
   Person p = contacts.GetContactInformation("Brandie", "Best");
  GetContactInformation
 GetContactInformation
 ref ローカル変数を宣言し、元の値にエイリアスをコピーします。 次の代入では、 p は、 GetContactInformation から返された 変数のエイリアスになります。
この後 p を使用することは、 によって返された変数を使用することと同じです。 p はその変数のエ イリアスであるためです。 p を変更すると、 から返される変数も変更されます。
ref キーワードは、ローカル変数宣言の前"および"メソッド呼び出しの前の両方で使用します。
同じ方法で、参照渡しの値にアクセスできます。 場合によっては、参照渡しの値へのアクセスによって負荷がかかる可能性があ るコピー操作が回避され、パフォーマンスが向上します。 たとえば、次のステートメントは、値の参照に使用される ref ローカル値 をどのように定義できるかを示しています。
ref キーワードは、ローカル変数宣言の前"および"2番目の例の値の前で使用します。両方の例の、変数宣言と代入の両 方の ref キーワードを含めないと、コンパイラエラーCS8172"値を使用して参照渡し変数を初期化することはできません"が 生成されます。
  ref Person p = ref contacts.GetContactInformation("Brandie", "Best");
  GetContactInformation
 GetContactInformation
  ref VeryLargeStruct reflocal = ref veryLargeStruct;
 C# 7.3 より前は、初期化後に別の記憶域を参照するように ref ローカル変数を割り当て直すことはできませんでした。 この制
   public ref Person GetContactInformation(string fname, string lname)
{
    // ...method implementation...
    return ref p;
}
 
 限はなくなりました。 再割り当ての例を次に示します。
    ref VeryLargeStruct reflocal = ref veryLargeStruct; // initialization
refLocal = ref anotherVeryLargeStruct; // reassigned, refLocal refers to different storage.
 ref ローカル変数は、宣言時にやはり初期化する必要があります。 ref 戻り値と ref ローカル変数: 使用例
次の例では、整数値の配列を格納する NumberStore クラスを定義しています。 FindNumber メソッドは、引数として渡され た数値に等しいかそれより大きい最初の数値を参照渡しで返します。 引数に等しいかそれより大きい数値がない場合、メソッ ドはインデックス 0 の数値を返します。
      using System;
class NumberStore
{
    int[] numbers = { 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023 };
    public ref int FindNumber(int target)
    {
        for (int ctr = 0; ctr < numbers.Length; ctr++)
        {
            if (numbers[ctr] >= target)
                return ref numbers[ctr];
}
        return ref numbers[0];
    }
    public override string ToString() => string.Join(" ", numbers);
}
  次の例では、NumberStore.FindNumber メソッドを呼び出して、16に等しいかそれより大きい最初の値を取得します。呼び出 し元は、メソッドによって返された値を2倍にします。次の例の出力では、NumberStore インスタンスの配列要素の値に変更 が反映されたことが示されています。
     var store = new NumberStore();
Console.WriteLine($"Original sequence: {store.ToString()}");
int number = 16;
ref var value = ref store.FindNumber(number);
value *= 2;
Console.WriteLine($"New sequence:      {store.ToString()}");
// The example displays the following output:
//       Original sequence: 1 3 7 15 31 63 127 255 511 1023
//       New sequence:      1 3 7 15 62 63 127 255 511 1023
 参照戻り値がサポートされていない場合、このような操作は、配列要素のインデックスと値を返すことによって実行されます。 呼 び出し元はこのインデックスを使用して、別のメソッド呼び出しで値を変更できます。 一方、インデックスを変更して配列の他の 値にアクセスし、変更することも可能です。
次の例では、C#7.3以降でrefローカル変数の再割り当てを使用するように FindNumber メソッドを書き直す方法を示しま す。
 
    この 2 番目のバージョンは、シークされる値が配列の末尾近くにあるようなシナリオのシーケンスが長い場合に、より効率的で す。
参照
ref キーワード 安全で効率的なコードを記述する
   using System;
class NumberStore
{
    int[] numbers = { 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023 };
    public ref int FindNumber(int target)
    {
        ref int returnVal = ref numbers[0];
        var ctr = numbers.Length - 1;
        while ((ctr >= 0) && numbers[ctr] >= target)
        {
            returnVal = ref numbers[ctr];
ctr--; }
        return ref returnVal;
    }
    public override string ToString() => string.Join(" ", numbers);
}
 
       C# では、引数を値または参照によってパラメーターに渡すことができます。 参照渡しでは、関数メンバー、メソッド、プロパティ、 インデクサー、演算子、およびコンストラクターは、パラメーターの値を変更でき、その変更を呼び出し元の環境で永続化できま す。 値を変更する目的でパラメーターを参照で渡すには、 ref または out キーワードを使用します。 値を変更せずにコピー を回避する目的で参照で渡すには、 in 修飾子を使用します。 ここでは、説明を簡単にするために、例に ref キーワードだ けを使用しています。 in 、 ref 、 out の違いの詳細については、in、ref、outに関するページを参照してください。
次の例は、値パラメーターと参照パラメーターの違いを示しています。
    class Program
{
    static void Main(string[] args)
    {
int arg;
        // Passing by value.
        // The value of arg in Main is not changed.
        arg = 4;
        squareVal(arg);
        Console.WriteLine(arg);
        // Output: 4
        // Passing by reference.
        // The value of arg in Main is changed.
        arg = 4;
        squareRef(ref arg);
        Console.WriteLine(arg);
        // Output: 16
}
    static void squareVal(int valParameter)
    {
        valParameter *= valParameter;
    }
    // Passing by reference
    static void squareRef(ref int refParameter)
    {
        refParameter *= refParameter;
    }
}
 詳細については、次のトピックを参照してください。
値型パラメーターの引き渡し 参照型パラメーターの引き渡し
C# 言語仕様
詳細については、C# 言語の仕様に関する記事の引数リストを参照してください。 言語仕様は、C# の構文と使用法に関する 信頼性のある情報源です。
パラメーターの引き渡し (C# プログラミング ガ
イド)
2020/11/02 • • Edit Online
 
  関連項目
C# プログラミング ガイド メソッド

   データへの参照を含む参照型変数とは対照的に、値型変数にはデータが直接含まれます。 値型変数を値渡しでメソッドに渡 すと、変数のコピーがメソッドに渡されます。 メソッド内部で生じるパラメーターに対する変更の影響は、引数の変数に格納され ている元のデータには及びません。 呼び出したメソッドで引数の値を変更する場合は、ref キーワードまたは out キーワードを 使用して、参照によって渡す必要があります。 また、in キーワードを使用し、参照で値パラメーターを渡してコピーを回避し、同 時に値が変更されないようにすることができます。わかりやすくするために、次の例では ref を使用しています。
値渡しによる値型の引き渡し
次の例では、値型のパラメーターを値渡しで渡す方法について説明します。変数 n を、値渡しでメソッド SquareIt に渡し ます。 メソッド内で生じた変更が、変数の元の値に影響することはありません。
     class PassingValByVal
{
    static void SquareIt(int x)
    // The parameter x is passed by value.
    // Changes to x will not affect the original value of x.
    {
x *= x;
        System.Console.WriteLine("The value inside the method: {0}", x);
    }
    static void Main()
    {
} }
int n = 5;
System.Console.WriteLine("The value before calling the method: {0}", n);
SquareIt(n);  // Passing the variable by value.
System.Console.WriteLine("The value after calling the method: {0}", n);
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
/* Output:
    The value before calling the method: 5
    The value inside the method: 25
    The value after calling the method: 5
*/
  変数 n は値型です。 この変数には、そのデータである値 5 が含まれます。 SquareIt を呼び出すと、 n の内容がパラメー ター x にコピーされ、このパラメーターがメソッド内で 2 乗されます。 ただし、 Main 内の n の値は、 SquareIt メソッドを呼 び出した後でも以前の値と同じままです。メソッド内で生じた変更の影響は、ローカル変数 x にのみ及びます。
参照渡しによる値型の引き渡し
次の例は、 ref パラメーターとして引数を渡す点を除いて上記の例と同じです。 基になる引数 n の値は、メソッド内で x が変更されると変わります。
 値型パラメーターの引き渡し (C# プログラミン
グ ガイド) 2020/11/02 • • Edit Online
 
  この例では、 n の値が渡されるのではなく、 n への参照が渡されています。 つまり、パラメーター x は int ではなく、 int へ の参照(この場合は n への参照)となります。したがって、メソッド内で x が2乗された場合、x の参照先である n が実 際に2乗されます。
値型のスワップ
引数の値を変更する一般的な例としてスワップ メソッドがあります。この方法では、2 つの変数をメソッドに渡してから、メソッド により変数の中身を交換します。 スワップ メソッドへの引数の引き渡しは、参照渡しで行う必要があります。 このようにしない と、メソッド内でパラメーターのローカル コピーどうしが交換され、呼び出し元のメソッドでは変更が行われません。 次の例では、 整数値が入れ替えられます。
SwapByRef メソッドを呼び出す場合は、次の例に示すように呼び出しで ref キーワードを使用します。
    static void SwapByRef(ref int x, ref int y)
{
    int temp = x;
    x = y;
    y = temp;
}
     class PassingValByRef
{
    static void SquareIt(ref int x)
    // The parameter x is passed by reference.
    // Changes to x will affect the original value of x.
    {
x *= x;
        System.Console.WriteLine("The value inside the method: {0}", x);
    }
    static void Main()
    {
} }
int n = 5;
System.Console.WriteLine("The value before calling the method: {0}", n);
SquareIt(ref n);  // Passing the variable by reference.
System.Console.WriteLine("The value after calling the method: {0}", n);
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
/* Output:
    The value before calling the method: 5
    The value inside the method: 25
    The value after calling the method: 25
*/
 
     関連項目
C# プログラミング ガイド パラメーターの引き渡し 参照型パラメーターの引き渡し
   static void Main()
{
    int i = 2, j = 3;
    System.Console.WriteLine("i = {0}  j = {1}" , i, j);
    SwapByRef (ref i, ref j);
    System.Console.WriteLine("i = {0}  j = {1}" , i, j);
    // Keep the console window open in debug mode.
    System.Console.WriteLine("Press any key to exit.");
    System.Console.ReadKey();
}
/* Output:
i=2 j=3
i=3 j=2 */
 
   型参照の変数には、そのデータは直接含まれず、そのデータへの参照が含まれます。 値で参照型パラメーターを渡す場合、ク ラス メンバーの値など、参照先オブジェクトに属するデータを変更することができます。 ただし、参照自体の値を変更することは できません。たとえば、同じ参照を使用して、新しいオブジェクトのメモリを割り当て、ブロックの外側で永続化させることはできま せん。 これを行うには、ref または out キーワードを使用してパラメーターを渡します。 わかりやすくするために、次の例では
ref を使用しています。 値渡しによる参照型の引き渡し
次の例では、参照型のパラメーター arr を値渡しで Change メソッドに渡す方法について説明します。このパラメーターは arr への参照であるため、配列要素の値を変更できます。ただし、別のメモリ位置へのパラメーターの再割り当ては、メソッド
の内部でのみ機能し、元の変数 arr には影響しません。
     class PassingRefByVal
{
    static void Change(int[] pArray)
    {
        pArray[0] = 888;  // This change affects the original element.
        pArray = new int[5] {-3, -1, -2, -3, -4};   // This change is local.
        System.Console.WriteLine("Inside the method, the first element is: {0}", pArray[0]);
}
    static void Main()
    {
[0]);
[0]); }
int[] arr = {1, 4, 5};
System.Console.WriteLine("Inside Main, before calling the method, the first element is: {0}", arr
Change(arr);
System.Console.WriteLine("Inside Main, after calling the method, the first element is: {0}", arr
}
/* Output:
    Inside Main, before calling the method, the first element is: 1
    Inside the method, the first element is: -3
    Inside Main, after calling the method, the first element is: 888
*/
 前の例では、 ref パラメーターなしで参照型の配列 arr がメソッドに渡されています。 このような場合は、 arr を指す参照 のコピーがメソッドに渡されます。出力は、メソッドが配列要素のコンテンツを変更できることを示しています。この場合は 1 か ら 888 に変更します。 ただし、 Change メソッド内で new 演算子を使用して新しいメモリ領域を割り当てると、変数
pArray が新しい配列を参照します。 このため、この後のすべての変更が、 Main の内部で作成される元の配列 arr に影 響しません。実際、この例では、2つの配列が作成されます。1つは Main の内部で、もう1つは Change メソッド内で作成 されます。
参照渡しによる参照型の引き渡し
次の例は、前の例と同じですが、 ref キーワードがメソッド ヘッダーと呼び出しに追加されている点が異なります。 メソッドで行 われるすべての変更が、呼び出し元のプログラム内の元の変数に影響します。
   参照型パラメーターの引き渡し (C# プログラミ
ング ガイド) 2020/11/02 • • Edit Online
 
  メソッド内で行われるすべての変更は、 Main の元の配列に影響します。 実際、元の配列は new 演算子を使用して再割り 当てされます。 したがって、 Change メソッドを呼び出した後、 arr へのすべての参照が、 Change メソッドで作成された 5 つ の要素を持つ配列を指します。
2 つの文字列のスワップ
文字列のスワップは、参照渡しで参照型パラメーターを渡す良い例です。例では、2つの文字列 str1 と str2 が Main で 初期化され、 ref キーワードで変更されたパラメーターとして SwapStrings メソッドに渡されます。 2 つの文字列は、メソッド 内と Main 内でスワップされます。
      class PassingRefByRef
{
    static void Change(ref int[] pArray)
    {
        // Both of the following changes will affect the original variables:
        pArray[0] = 888;
        pArray = new int[5] {-3, -1, -2, -3, -4};
        System.Console.WriteLine("Inside the method, the first element is: {0}", pArray[0]);
}
    static void Main()
    {
        int[] arr = {1, 4, 5};
        System.Console.WriteLine("Inside Main, before calling the method, the first element is: {0}",
arr[0]);
        Change(ref arr);
        System.Console.WriteLine("Inside Main, after calling the method, the first element is: {0}",
arr[0]);
} }
/* Output:
    Inside Main, before calling the method, the first element is: 1
    Inside the method, the first element is: -3
    Inside Main, after calling the method, the first element is: -3
*/
 
    この例では、呼び出し元のプログラム内の変数に影響を与えるため、参照渡しでパラメーターを渡す必要があります。 メソッド ヘッダーと、メソッドの呼び出しの両方から ref キーワードを削除すると、呼び出し元プログラムで変更は行われません。
文字列の詳細については、「文字列」を参照してください。 関連項目
C# プログラミング ガイド パラメーターの引き渡し ref
in
out
参照型
    class SwappingStrings
 {
     static void SwapStrings(ref string s1, ref string s2)
     // The string parameter is passed by reference.
     // Any changes on parameters will affect the original variables.
     {
         string temp = s1;
         s1 = s2;
         s2 = temp;
         System.Console.WriteLine("Inside the method: {0} {1}", s1, s2);
}
     static void Main()
     {
         string str1 = "John";
         string str2 = "Smith";
         System.Console.WriteLine("Inside Main, before swapping: {0} {1}", str1, str2);
         SwapStrings(ref str1, ref str2);   // Passing strings by reference
         System.Console.WriteLine("Inside Main, after swapping: {0} {1}", str1, str2);
     }
}
/* Output:
     Inside Main, before swapping: John Smith
     Inside the method: Smith John
     Inside Main, after swapping: Smith John
*/
 
     次の例では、メソッドに構造体を渡すこととクラス インスタンスを渡すことの違いを示します。 この例では、両方の引数 (構造体 とクラス インスタンス) が値によって渡され、両方のメソッドが引数の 1 つのフィールドの値を変更します。 ただし、2 つのメソッド の結果は同じではありません。構造体を渡した場合に渡される内容と、クラスのインスタンスを渡した場合に渡される内容が異 なるためです。
構造体は値型であるため、メソッドに構造体が値によって渡されると、メソッドは構造体引数のコピーを受け取って操作します。 メソッドは、呼び出し側メソッドの元の構造体にはアクセスできないため、どのような場合でもこの構造体を変更することはできま せん。 メソッドで変更できるのはコピーのみです。
クラス インスタンスは、値型ではなく、参照型です。 メソッドに参照型が値によって渡されると、メソッドはクラス インスタンスへの 参照のコピーを受け取ります。 つまり、呼び出されたメソッドは、インスタンスのアドレスのコピーを受け取り、呼び出し元のメソッ ドはインスタンスの元のアドレスを保持します。 呼び出し側メソッドのクラス インスタンスにはアドレスがあり、呼び出されたメソッド のパラメータにはそのアドレスのコピーがあり、両方のアドレスが同じオブジェクトを参照します。 パラメーターにはアドレスのコピー のみが含まれるため、呼び出されたメソッドは呼び出し側メソッドのクラス インスタンスのアドレスを変更できません。 ただし、呼び 出されたメソッドはアドレスのコピーを使用して、元のアドレスとアドレスのコピーの両方が参照するクラス メンバーにアクセスできま す。 呼び出されたメソッドがクラス メンバーを変更すると、呼び出し側メソッドの元のクラス インスタンスも変更されます。
次の例の出力はこの違いを示しています。クラスインスタンスの willIChange フィールドの値はメソッド ClassTaker の呼び 出しによって変更されます。これは、メソッドがパラメーターのアドレスを使用して、クラス インスタンスの指定されたフィールドを検 索するためです。呼び出し側メソッドの構造体の willIChange フィールドはメソッド StructTaker の呼び出しによって変更さ れません。これは、引数の値が、そのアドレスのコピーではなく、構造体自体のコピーであるためです。 StructTaker はコピーを 変更し、そのコピーは、 StructTaker の呼び出しが完了したときに失われます。
例
      メソッドに構造体を渡すこととクラス参照を渡す ことの違いを理解する方法 (C# プログラミング
ガイド) 2021/03/06 • • Edit Online
 
       関連項目
C# プログラミング ガイド クラス
構造体型 パラメーターの引き渡し
  using System;
class TheClass
{
    public string willIChange;
}
struct TheStruct
{
    public string willIChange;
}
class TestClassAndStruct
{
    static void ClassTaker(TheClass c)
    {
        c.willIChange = "Changed";
    }
    static void StructTaker(TheStruct s)
    {
        s.willIChange = "Changed";
    }
    static void Main()
    {
} }
TheClass testClass = new TheClass();
TheStruct testStruct = new TheStruct();
testClass.willIChange = "Not Changed";
testStruct.willIChange = "Not Changed";
ClassTaker(testClass);
StructTaker(testStruct);
Console.WriteLine("Class field = {0}", testClass.willIChange);
Console.WriteLine("Struct field = {0}", testStruct.willIChange);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    Class field = Changed
    Struct field = Not Changed
*/

      ローカル変数は、明示的な型を指定しないで宣言できます。 var キーワードは、初期化ステートメントの右辺にある式から変 数の型を推論するようにコンパイラに指示します。 推論される型は、組み込み型、匿名型、ユーザー定義型、または .NET クラ スライブラリで定義されている型である可能性があります。 var で配列を初期化する方法の詳細については、「暗黙的に型 指定される配列」を参照してください。
ローカル変数を var で宣言するさまざまな方法を次の例に示します。
    // i is compiled as an int
var i = 5;
// s is compiled as a string
var s = "Hello";
// a is compiled as int[]
var a = new[] { 0, 1, 2 };
// expr is compiled as IEnumerable<Customer>
// or perhaps IQueryable<Customer>
var expr =
    from c in customers
    where c.City == "London"
    select c;
// anon is compiled as an anonymous type
var anon = new { Name = "Terry", Age = 34 };
// list is compiled as List<int>
var list = new List<int>();
 var キーワードは"バリアント"を意味するのではなく、変数の厳密でない型指定や遅延バインディングを示すものでもないこと を理解することが重要です。 単に、最も適切な型をコンパイラが決定して割り当てることを意味します。
var キーワードは、次のコンテキストで使用される場合があります。 前の例で示したようなローカル変数 (メソッドのスコープで宣言された変数)。 for 初期化ステートメント。
foreach 初期化ステートメント。
using ステートメント。
  for (var x = 1; x < 10; x++)
   foreach (var item in list) {...}
   using (var file = new StreamReader("C:\\myfile.txt")) {...}
 暗黙的に型指定されるローカル変数 (C# プログ
ラミング ガイド) 2020/11/02 • • Edit Online
 
  詳細については、「「クエリ式で暗黙的に型指定されるローカル変数および配列を使用する方法」を参照してください。 var と匿名型
多くの場合、 var の使用は任意であり、構文上便利なだけです。 ただし、変数が匿名型で初期化される場合、後でオブ ジェクトのプロパティへのアクセスが必要になったら、変数を var として宣言する必要があります。これは、LINQクエリ式では一 般的なシナリオです。 詳細については、「匿名型」を参照してください。
ソースコードの観点から見ると、匿名型には名前がありません。そのため、クエリ変数が var で初期化された場合、返された オブジェクトのシーケンスのプロパティにアクセスするための唯一の方法は、 foreach ステートメント内の繰り返し変数の型として
var を使用することです。
     class ImplicitlyTypedLocals2
{
    static void Main()
    {
} }
string[] words = { "aPPLE", "BlUeBeRrY", "cHeRry" };
// If a query produces a sequence of anonymous types,
// then use var in the foreach statement to access the properties.
var upperLowerWords =
     from w in words
     select new { Upper = w.ToUpper(), Lower = w.ToLower() };
// Execute the query
foreach (var ul in upperLowerWords)
{
    Console.WriteLine("Uppercase: {0}, Lowercase: {1}", ul.Upper, ul.Lower);
}
/* Outputs:
    Uppercase: APPLE, Lowercase: apple
    Uppercase: BLUEBERRY, Lowercase: blueberry
    Uppercase: CHERRY, Lowercase: cherry
*/
 Remarks
暗黙的に型指定される変数の宣言には、次の制限が適用されます。
var を使用できるのは、同じステートメント内でローカル変数の宣言と初期化が行われる場合のみです。この変数は、
null、メソッド グループ、または匿名関数に初期化することはできません。
var は、クラススコープのフィールドで使用できません。
var を使用して宣言された変数は、初期化式では使用できません。 つまり、 int i = (i = 20); という式は有効で すが、 var i = (i = 20); という式はコンパイル時エラーが生成されます。
暗黙的に型指定された複数の変数を同じステートメント内で初期化することはできません。
var という名前の型がスコープ内にある場合、 var キーワードはその型名に解決され、暗黙的に型指定されたローカ ル変数の宣言の一部とは見なされません。
var キーワードによる暗黙の型指定は、ローカルメソッドスコープの変数にのみ適用できます。暗黙の型指定はクラスフィー ルドには使用できません。C# コンパイラでコードを処理するときに論理的パラドックスにぶつかるためです。コンパイラはフィールド の型を認識する必要がありますが、代入式が分析されるまで型を判断できません。そして、型を認識していなければ、式を評 価できません。 次のコードがあるとします。
  
              bookTitles は、型が var のクラスフィールドです。このフィールドには評価する式がないため、コンパイラでは bookTitles の型を推定できません。 さらに、(ローカル変数の場合と同様に) フィールドに式を追加するだけでは不十分です。
コードのコンパイル中にコンパイラでフィールドが検出されると、それに関連付けられている式を処理する前に各フィールドの型が 記録されます。コンパイラでの bookTitles の解析時に同じパラドックスにぶつかります。フィールドの型を認識する必要があり ますが、通常、コンパイラは式を解析して var の型を判断します。これには、事前に型を認識している必要があります。
var は、クエリ式と使用する場合に便利なこともあります。クエリ変数の構築された型を厳密に判別することが難しい場合で す。 このような状況は、グループ化と並べ替えの処理で発生することがあります。
var キーワードは、変数の特定の型をキーボードで入力するのが面倒な場合、その型が明白な場合、型によってコードが読 みやすくならない場合にも役立ちます。このような理由で var が有用な例の1つとして、グループ化処理で使用されるような 入れ子にされたジェネリック型があります。 次のクエリでは、クエリ変数の型は IEnumerable<IGrouping<string, Student>> で す。 コードの作成者とそのコードを保守する担当者がこの点を理解している限り、簡略化するために暗黙的な型指定を使用 しても問題はありません。
var を使用すると、コードを簡単にすることができますが、必要な場合、またはコードを読みやすくする場合にのみ使用するよ うにします。 var 使用するのが適切な場合の詳細については、C#コーディングガイドラインの記事の「暗黙的に型指定され るローカル変数」セクションを参照してください。
関連項目
C# リファレンス
暗黙的に型指定される配列 クエリ式で暗黙的に型指定されるローカル変数および配列を使用する方法 匿名型
オブジェクト初期化子とコレクション初期化子
var
C# での LINQ
統合言語クエリ (LINQ)
for
foreach、in
using ステートメント
  private var bookTitles = new List<string>();
       // Same as previous example except we use the entire last name as a key.
// Query variable is an IEnumerable<IGrouping<string, Student>>
var studentQuery3 =
    from student in students
    group student by student.Last;
  private var bookTitles;
 
      コンパイラによってローカル変数の型が決定されるようにする場合は、暗黙的に型指定されたローカル変数を使用できます。 ク エリ式でよく使用する匿名型を格納するには、暗黙的に型指定されたローカル変数を使用する必要があります。 以下の例で は、クエリで暗黙的に型指定されたローカル変数を省略できる場合と、使用しなければならない場合の両方を示します。
暗黙的に型指定されたローカル変数は、var コンテキスト キーワードを使用して宣言します。 詳細については、「暗黙的に型 指定されるローカル変数」と「暗黙的に型指定される配列」を参照してください。
例
次の例は、var キーワードが必須である一般的なシナリオ(匿名型のシーケンスを生成するクエリ)を示しています。このシナリ オでは、匿名型の型名にアクセスできないため、 var を使用して foreach ステートメントのクエリ変数と反復変数の両方を暗 黙的に型指定する必要があります。 匿名型の詳細については、「匿名型」を参照してください。
     private static void QueryNames(char firstLetter)
{
    // Create the query. Use of var is required because
    // the query produces a sequence of anonymous types:
    // System.Collections.Generic.IEnumerable<????>.
    var studentQuery =
        from student in students
        where student.FirstName[0] == firstLetter
        select new { student.FirstName, student.LastName };
    // Execute the query and display the results.
    foreach (var anonType in studentQuery)
    {
        Console.WriteLine("First = {0}, Last = {1}", anonType.FirstName, anonType.LastName);
    }
}
 例
次の例では、同様の状況で var キーワードを使用しています。ただし、この場合、 var の使用はオプションです。 は文字列であるため、クエリを実行すると文字列のシーケンスが返されます。 したがって、 queryID の型
は、 var ではなく として宣言できます。 var キーワードは利便性のた めに使用されます。 この例では、 ステートメントの反復変数は文字列として明示的に型指定されていますが、代わり に var を使用して宣言することができます。 反復変数の型は匿名型ではないため、 var の使用はオプションであり、必須で はありません。 var 自体は型ではなく、型を推論して割り当てるようコンパイラに指示する命令です。
  student.LastName
 System.Collections.Generic.IEnumerable<string>
 foreach
クエリ式で暗黙的に型指定されるローカル変数お よび配列を使用する方法 (C# プログラミング ガ
イド)
2021/03/06 • • Edit Online
 
      関連項目
C# プログラミング ガイド 拡張メソッド 統合言語クエリ (LINQ) var
C# での LINQ
   // Variable queryId could be declared by using
// System.Collections.Generic.IEnumerable<string>
// instead of var.
var queryId =
    from student in students
    where student.Id > 111
    select student.LastName;
// Variable str could be declared by using var instead of string.
foreach (string str in queryId)
{
    Console.WriteLine("Last name: {0}", str);
}
 
             拡張メソッドを使用すると、新規の派生型の作成、再コンパイル、または元の型の変更を行うことなく既存の型にメソッドを "追 加" できます。 拡張メソッドは静的メソッドですが、拡張された型のインスタンス メソッドのように呼び出します。 C#、F#、Visual Basic で作成されたクライアント コードの場合は、拡張メソッドの呼び出しと、型で定義されているメソッドの呼び出しに明確な 違いはありません。
最も一般的な拡張メソッドは、既存の System.Collections.IEnumerable 型および System.Collections.Generic.IEnumerable<T> 型にクエリ機能を追加する LINQ 標準クエリ演算子です。 この標準クエリ演 算子を使用するには、まず using System.Linq ディレクティブを使用して、スコープに含めます。 IEnumerable<T> を実装す るすべての型は、GroupBy、OrderBy、Average などのインスタンス メソッドを持っていると考えられます。 List<T>、Array な どの IEnumerable<T> 型のインスタンスの後に "ドット" を入力すると、IntelliSense により、ステートメントの入力候補としてこ れらの追加メソッドが表示されます。
OrderBy の例
整数の配列において、標準クエリ演算子の OrderBy メソッドを呼び出す方法を次の例に示します。かっこ内の式はラムダ式 です。 標準クエリ演算子の多くはパラメーターとしてラムダ式を受け取りますが、拡張メソッドでは、これは必須ではありません。 詳細については、「ラムダ式」を参照してください。
      class ExtensionMethods2
{
    static void Main()
    {
} }
int[] ints = { 10, 45, 15, 39, 21, 26 };
var result = ints.OrderBy(g => g);
foreach (var i in result)
{
    System.Console.Write(i + " ");
}
//Output: 10 15 21 26 39 45
 拡張メソッドは、静的メソッドとして定義しますが、インスタンス メソッドの構文を使用して呼び出します。 最初のパラメーターで は、メソッドによって操作される型を指定します。このパラメーターの前にはthis修飾子を付けます。 using ディレクティブを使 用して名前空間をソース コードに明示的にインポートした場合、拡張メソッドはそのスコープでのみ有効です。
System.String クラスに対して拡張メソッドを定義する例を次に示します。 入れ子になっていない、非ジェネリックの静的クラス 内で定義されています。
    namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this String str)
        {
}
} }
return str.Split(new char[] { ' ', '.', '?' },
                 StringSplitOptions.RemoveEmptyEntries).Length;
 拡張メソッド (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   この   ディレクティブを使用することで、 using 拡張メソッドをスコープに取り込むことができます。
  using ExtensionMethods;
 また、この構文を使用することで、アプリケーションから呼び出すことができます。
コードでは、インスタンス メソッドの構文を使用して、拡張メソッドを呼び出します。 コンパイラによって生成される中間言語 (IL) により、コードは静的メソッドの呼び出しに変換されます。 カプセル化の原則には実質的に違反していません。 拡張メソッドで は、それが拡張している型のプライベート変数にはアクセスできません。
詳細については、「カスタム拡張メソッドを実装して呼び出す方法」を参照してください。
一般に、独自に実装するより、拡張メソッドを呼び出す方がはるかに多くなると思われます。 拡張メソッドは、インスタンス メソッ ドの構文を使用して呼び出すので、特別な知識がなくてもクライアント コードからそれらを使用できます。 メソッドが定義されて いる名前空間に関する using ディレクティブを追加するだけで、特定の型の拡張メソッドを使用できるようになります。たとえ ば、標準クエリ演算子を使用するには、次の using ディレクティブをコードに追加します。
場合によっては、System.Core.dll への参照も追加する必要があります。ほとんどの IEnumerable<T> 型で利用できる追加 メソッドとして、標準クエリ演算子が IntelliSense に表示されるようになりました。
コンパイル時の拡張メソッドのバインディング
拡張メソッドを使用してクラスまたはインターフェイスを拡張することはできますが、これらをオーバーライドすることはできません。 インターフェイス メソッドまたはクラス メソッドと同じ名前およびシグネチャを持つ拡張メソッドは決して呼び出されません。 コンパ イル時に、型自体で定義されているインスタンス メソッドよりも低い優先順位が拡張メソッドには必ず設定されます。 つまり、型 に Process(int i) という名前のメソッドがあり、これと同じシグネチャの拡張メソッドがある場合、コンパイラは必ずインスタンス メソッドにバインドします。 コンパイラは、メソッド呼び出しを検出すると、最初に型のインスタンス メソッドから一致するものを探 します。 一致するものが見つからない場合、型に対して定義されている拡張メソッドを検索し、見つかった最初の拡張メソッド にバインドします。 次の例は、コンパイラが拡張メソッドとインスタンス メソッドのどちらにバインドするかを決定する方法を示して います。
例
次の例は、C# のコンパイラがメソッド呼び出しを型のインスタンス メソッドにバインドするか、拡張メソッドにバインドするかを決定 するときに従う規則を示しています。 Extensions 静的クラスには、 IMyInterface を実装する型に対して定義された拡張メ ソッドが含まれています。 A 、 B 、および C の各クラスはすべてこのインターフェイスを実装しています。
MethodB 拡張メソッドは、その名前とシグネチャがクラスにより既に実装されているメソッドと完全に一致しているため、呼び出さ れることはありません。
コンパイラは、一致するシグネチャを持つインスタンス メソッドを検出できない場合、一致する拡張メソッドが存在する場合はそ れにバインドします。
    string s = "Hello Extension Methods";
int i = s.WordCount();
   using System.Linq;
      WordCount
     // Define an interface named IMyInterface.
namespace DefineIMyInterface
{
    using System;
    public interface IMyInterface
{

     {
        // Any class that implements IMyInterface must define a method
        // that matches the following signature.
        void MethodB();
} }
// Define extension methods for IMyInterface.
namespace Extensions
{
    using System;
    using DefineIMyInterface;
    // The following extension methods can be accessed by instances of any
    // class that implements IMyInterface.
    public static class Extension
    {
        public static void MethodA(this IMyInterface myInterface, int i)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, int i)");
}
        public static void MethodA(this IMyInterface myInterface, string s)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, string s)");
}
        // This method is never called in ExtensionMethodsDemo1, because each
        // of the three classes A, B, and C implements a method named MethodB
        // that has a matching signature.
        public static void MethodB(this IMyInterface myInterface)
        {
            Console.WriteLine
 } }
}
("Extension.MethodB(this IMyInterface myInterface)");
// Define three classes that implement IMyInterface, and then use them to test
// the extension methods.
namespace ExtensionMethodsDemo1
{
    using System;
    using Extensions;
    using DefineIMyInterface;
    class A : IMyInterface
    {
        public void MethodB() { Console.WriteLine("A.MethodB()"); }
    }
    class B : IMyInterface
    {
        public void MethodB() { Console.WriteLine("B.MethodB()"); }
        public void MethodA(int i) { Console.WriteLine("B.MethodA(int i)"); }
    }
    class C : IMyInterface
    {
        public void MethodB() { Console.WriteLine("C.MethodB()"); }
        public void MethodA(object obj)
        {
            Console.WriteLine("C.MethodA(object obj)");
        }
    }
    class ExtMethodDemo
  {

          一般的な使用パターン コレクションの機能
これまでは、特定の型の System.Collections.Generic.IEnumerable<T> インターフェイスが実装され、その型のコレクションに 対して動作する機能が含まれている、"コレクション クラス" を作成するのが一般的でした。 この種類のコレクション オブジェクトを 作成しても問題はありませんが、System.Collections.Generic.IEnumerable<T> の拡張機能を使用して同じ機能を実現で きます。 拡張機能には、その型の System.Collections.Generic.IEnumerable<T> が実装されている System.Array や System.Collections.Generic.List<T> などの任意のコレクションから機能を呼び出すことができるという利点があります。 Int32 の配列のこの使用例については、この記事で既に示されています。
レイヤー固有の機能
オニオン アーキテクチャまたは他のレイヤー化アプリケーション設計を使用する場合は、アプリケーションの境界を越えて通信する
{
    static void Main(string[] args)
    {
 } }
}
/* Output:
// Declare an instance of class A, class B, and class C.
A a = new A();
B b = new B();
C c = new C();
// For a, b, and c, call the following methods:
//      -- MethodA with an int argument
//      -- MethodA with a string argument
//      -- MethodB with no argument.
// A contains no MethodA, so each call to MethodA resolves to
// the extension method that has a matching signature.
a.MethodA(1);           // Extension.MethodA(IMyInterface, int)
a.MethodA("hello");     // Extension.MethodA(IMyInterface, string)
// A has a method that matches the signature of the following call
// to MethodB.
a.MethodB();            // A.MethodB()
// B has methods that match the signatures of the following
// method calls.
b.MethodA(1);           // B.MethodA(int)
b.MethodB();            // B.MethodB()
// B has no matching method for the following call, but
// class Extension does.
b.MethodA("hello");     // Extension.MethodA(IMyInterface, string)
// C contains an instance method that matches each of the following
// method calls.
c.MethodA(1);
c.MethodA("hello");
c.MethodB();
// C.MethodA(object)
// C.MethodA(object)
// C.MethodB()
   Extension.MethodA(this IMyInterface myInterface, int i)
   Extension.MethodA(this IMyInterface myInterface, string s)
   A.MethodB()
   B.MethodA(int i)
   B.MethodB()
   Extension.MethodA(this IMyInterface myInterface, string s)
   C.MethodA(object obj)
   C.MethodA(object obj)
   C.MethodB()
*/

       ために使用できるドメイン エンティティまたはデータ転送オブジェクトのセットを使用するのが一般的です。 これらのオブジェクトに は、通常、機能が含まれていないか、またはアプリケーションのすべてのレイヤーに適用される最小限の機能のみが含まれていま す。 他のレイヤーで必要のないメソッドや望ましくないメソッドを使用してオブジェクトを読み込むことなしに、拡張メソッドを使用 して、各アプリケーション レイヤーに固有の機能を追加することができます。
    public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
 定義済みの型の拡張
再利用可能な機能を作成する必要があるときに、新しいオブジェクトを作成するのではなく、多くの場合、.NET や CLR 型など の既存の型を拡張できます。 たとえば、拡張メソッドを使用しない場合は、コード内の複数の場所から呼び出すことができる
Engine または Query クラスを作成して、SQLサーバーに対するクエリの実行を処理することが考えられます。一方、代わり に拡張メソッドを使用して System.Data.SqlClient.SqlConnection クラスを拡張すると、SQL サーバーに接続している任意の 場所からそのクエリを実行することができます。 他の例としては、System.String クラスへの共通機能の追加、System.IO.File および System.IO.Stream オブジェクトのデータ処理機能の拡張、特定のエラー処理機能のための System.Exception オブ ジェクトなどがあります。 この種のユース ケースは、開発者の想像力と良識によってのみ制限されます。
struct 型は、メソッドに値で渡されるため、定義済みの型を拡張するのが難かしい場合があります。これは、構造体への変 更が構造体のコピーに対して行われることを意味します。 そのような変更は、拡張メソッドが終了した後では認識できません。 C#7.2以降では、拡張メソッドの最初の引数に ref 修飾子を追加できます。 ref 修飾子を追加すると、最初の引数が 参照によって渡されます。 これにより、拡張されている構造体の状態を変更する拡張メソッドを記述できます。
一般的なガイドライン
オブジェクトのコードを変更したり新しい型を派生させたりすることによって機能を追加することが妥当かつ可能である場合は、そ のようにすることがやはり推奨されますが、.NET エコシステムの全体で、拡張メソッドが再利用可能な機能を作成するための重 要なオプションになってきています。 元のソースを制御できない場合、派生オブジェクトが不適切または不可能な場合、または 該当するスコープを超えて機能を公開してはならない場合は、拡張メソッドが優れた選択肢になります。
派生型について詳しくは、「継承」をご覧ください。
ソース コードを制御できない型を、拡張メソッドを使用して拡張すると、型の実装の変更により拡張メソッドが破損するというリ
スクを負うことになります。 所定の型の拡張メソッドを実装する場合、次の点に注意してください。
拡張メソッドが型で定義されているメソッドと同じシグネチャを持つ場合、その拡張メソッドは呼び出されません。 拡張メソッドは名前空間レベルでスコープ内に取り込まれます。 たとえば、 Extensions という名前の単一の名前空間に、 拡張メソッドを含む複数の静的クラスがある場合、 using Extensions; ディレクティブによって、それらのすべての拡張メソッ ドがスコープ内に取り込まれます。
実装したクラス ライブラリでは、アセンブリのバージョン番号のインクリメントを避けるために、拡張メソッドは使用しないでください。 ソース コードを所有するライブラリに重要な機能を追加する場合は、アセンブリのバージョン管理について、.NET ガイドラインに 従う必要があります。 詳細については、「アセンブリのバージョン管理」を参照してください。
    関連項目

         C# プログラミング ガイド
並列プログラミングのサンプル (拡張メソッドの例が多数掲載されています) ラムダ式
標準クエリ演算子の概要
インスタンス パラメーターの変換規則とその影響 拡張メソッドの言語間での相互運用性
拡張メソッドとカリー化デリゲート バインディングとエラー報告に関する拡張メソッド

     このトピックでは、あらゆる .NET 型を対象に独自の拡張メソッドを実装する方法について説明します。 クライアント コードで拡 張メソッドを使用するには、拡張メソッドが格納されている DLL への参照を追加し、拡張メソッドが定義されている名前空間を 指定する using ディレクティブを追加します。
拡張メソッドを定義して呼び出すには
1. 拡張メソッドを格納するための静的クラスを定義します。
このクラスは、クライアント コードから参照できる必要があります。 アクセシビリティの規則の詳細については、「アクセス修 飾子」を参照してください。
2. 拡張メソッドを静的メソッドとして実装します。メソッドの可視性は、包含クラスと同レベル以上を指定します。
3. メソッドの最初のパラメーターでは、メソッドが操作する型を指定します。型名の前には this 修飾子を付加します。
4. 呼び出し元のコードで、 using ディレクティブを追加して、拡張メソッドのクラスを含む名前空間を指定します。
5. 型のインスタンス メソッドと同じようにメソッドを呼び出します。
呼び出し元のコードでは最初のパラメーターを指定しません。これは演算子を適用する型を表すものであり、コンパイラ はオブジェクトの型を既に認識しているためです。指定する必要があるのは、2番目から n 番目のパラメーターの引数 だけです。
例
次の例では、 CustomExtensions.StringExtension クラスの WordCount という名前の拡張メソッドを実装します。 このメソッド は、最初のメソッドパラメーターとして指定されたStringクラスを操作します。 CustomExtensions 名前空間は、アプリケーショ ン名前空間にインポートされ、メソッドは Main メソッド内で呼び出されます。
   カスタム拡張メソッドを実装して呼び出す方法
(C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
         .NET セキュリティ
拡張メソッドには、固有のセキュリティ上の脆弱性はありません。 名前の衝突の解決では、型自体で定義されているインスタン ス メソッドまたは静的メソッドが常に優先されるため、型の既存のメソッドを偽装するために拡張メソッドが使用されることはあり ません。 拡張メソッドは、拡張されたクラスのプライベート データにはアクセスできません。
関連項目
C# プログラミング ガイド 拡張メソッド
統合言語クエリ (LINQ) 静的クラスと静的クラス メンバー protected
internal public
this namespace
   using System.Linq;
using System.Text;
using System;
namespace CustomExtensions
{
    // Extension methods must be defined in a static class.
    public static class StringExtension
    {
} }
// This is the extension method.
// The first parameter takes the "this" modifier
// and specifies the type for which the method is defined.
public static int WordCount(this String str)
{
    return str.Split(new char[] {' ', '.','?'}, StringSplitOptions.RemoveEmptyEntries).Length;
}
namespace Extension_Methods_Simple
{
    // Import the extension method namespace.
    using CustomExtensions;
    class Program
    {
} }
static void Main(string[] args)
{
    string s = "The quick brown fox jumped over the lazy dog.";
    // Call the method as if it were an
    // instance method on the type. Note that the first
    // parameter is not specified by the calling code.
    int i = s.WordCount();
    System.Console.WriteLine("Word count of s is {0}", i);
}
 
   拡張メソッドを使用して、特定の列挙型に固有の機能を追加することができます。 例
次の例では、 Grades 列挙型は学生が授業で受け取る成績評価を表わしています。 Passing という名前の拡張機能メソッ ドが 型に追加されていて、この型の各インスタンスが合格点を表しているかどうかを自ら "認識" できるようになっていま す。
   Grades
    using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
namespace EnumExtension
{
    // Define an extension method in a non-nested static class.
    public static class Extensions
    {
        public static Grades minPassing = Grades.D;
        public static bool Passing(this Grades grade)
        {
            return grade >= minPassing;
        }
}
    public enum Grades { F = 0, D=1, C=2, B=3, A=4 };
    class Program
    {
        static void Main(string[] args)
        {
} }
}
/* Output:
Grades g1 = Grades.D;
Grades g2 = Grades.F;
Console.WriteLine("First {0} a passing grade.", g1.Passing() ? "is" : "is not");
Console.WriteLine("Second {0} a passing grade.", g2.Passing() ? "is" : "is not");
Extensions.minPassing = Grades.C;
Console.WriteLine("\r\nRaising the bar!\r\n");
Console.WriteLine("First {0} a passing grade.", g1.Passing() ? "is" : "is not");
Console.WriteLine("Second {0} a passing grade.", g2.Passing() ? "is" : "is not");
   First is a passing grade.
   Second is not a passing grade.
   Raising the bar!
   First is not a passing grade.
   Second is not a passing grade.
*/
  Extensions クラスには動的に更新される静的変数も含まれていて、拡張メソッドの戻り値はその変数の現在の値を反映して
列挙型対応の新しいメソッドを作成する方法 (C#
プログラミング ガイド) 2021/03/06 • • Edit Online
 
   いることに注意してください。 背後では、拡張メソッドが自分が定義されている静的クラスに直接呼び出されることを、この例は 示しています。
関連項目
C# プログラミング ガイド 拡張メソッド

   C# 4 では、名前付き引数と省略可能な引数が導入されています。 "名前付き引数" を使用すると、引数をそのパラメーター リスト内の位置ではなく名前で照合することで、パラメーターの引数を指定できます。 省略可能な引数 を使用すると、一部の パラメーターの引数を省略できます。 両方の手法をメソッド、インデクサー、コンストラクター、デリゲートで使用できます。
名前付き引数と省略可能な引数を使用すると、引数は、パラメーター リストではなく、引数リストに記述されている順に評価さ れます。
名前付きパラメーターと省略可能なパラメーターを使用すると、選択したパラメーターの引数を指定できます。 この機能により、 Microsoft Office オートメーション API などの COM インターフェイスの呼び出しが大幅に簡素化されます。
名前付き引数
名前付き引数を使用すると、呼び出されたメソッドのパラメーター リスト内のパラメーターの順序を一致させる必要がなくなりま す。 各引数のパラメーターはパラメーター名で指定できます。 たとえば、注文の詳細 (販売者の名前、注文番号、製品名な ど) を出力する関数は、引数を位置によって、その関数で定義されている順序に従って渡すことで呼び出せます。
パラメーターの順序を覚えていなくても、それらの名前がわかっていれば、任意の順序で引数を渡すことができます。
また、名前付き引数を使用すると、各引数が表すものが識別しやすくなり、コードが読みやすくなります。 次のメソッド例では、 sellerName はnullにしたり、空白にしたりできません。 sellerName と productName はいずれも文字列型であり、引数を 位置によって渡すより、名前付き引数を使用するほうが合理的です。2 つのあいまいさが取り除かれ、コードを読む人の混乱が
少なくなります。 名前付き引数は、位置引数と共に使用するとき、次の場合において有効となります
後ろに位置引数が続かない。
C#7.2以降。正しい位置で使用されます。下の例では、パラメーター orderNum は正しい位置にありますが、明示的 に名前が付けられていません。
後に位置引数が続く場合、順序が正しくない名前付き引数は無効になります。
  PrintOrderDetails("Gift Shop", 31, "Red Mug");
     PrintOrderDetails(orderNum: 31, productName: "Red Mug", sellerName: "Gift Shop");
PrintOrderDetails(productName: "Red Mug", sellerName: "Gift Shop", orderNum: 31);
      PrintOrderDetails("Gift Shop", 31, productName: "Red Mug");
    PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
 名前付き引数と省略可能な引数 (C# プログラミ
ング ガイド) 2021/03/06 • • Edit Online
 
   例 次のコードでは、このセクションの例の実装し、さらにいくつかのプログラミングを追加しています。
    class NamedExample
{
    static void Main(string[] args)
    {
        // The method can be called in the normal way, by using positional arguments.
        PrintOrderDetails("Gift Shop", 31, "Red Mug");
        // Named arguments can be supplied for the parameters in any order.
        PrintOrderDetails(orderNum: 31, productName: "Red Mug", sellerName: "Gift Shop");
        PrintOrderDetails(productName: "Red Mug", sellerName: "Gift Shop", orderNum: 31);
    // Named arguments mixed with positional arguments are valid
    // as long as they are used in their correct position.
    PrintOrderDetails("Gift Shop", 31, productName: "Red Mug");
    PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");
    PrintOrderDetails("Gift Shop", orderNum: 31, "Red Mug");
    // However, mixed arguments are invalid if used out-of-order.
    // The following statements will cause a compiler error.
    // PrintOrderDetails(productName: "Red Mug", 31, "Gift Shop");
    // PrintOrderDetails(31, sellerName: "Gift Shop", "Red Mug");
    // PrintOrderDetails(31, "Red Mug", sellerName: "Gift Shop");
}
// C# 7.2 onwards
// C# 7.2 onwards
    static void PrintOrderDetails(string sellerName, int orderNum, string productName)
    {
        if (string.IsNullOrWhiteSpace(sellerName))
        {
            throw new ArgumentException(message: "Seller name cannot be null or empty.", paramName:
nameof(sellerName));
}
        Console.WriteLine($"Seller: {sellerName}, Order #: {orderNum}, Product: {productName}");
    }
}
 省略可能な引数
メソッド、コンストラクター、インデクサー、デリゲートの定義では、そのパラメーターが必須であるか、省略可能であるかを指定でき ます。 どの呼び出しでも、すべての必須パラメーターに対して引数を指定する必要があります。ただし、省略可能なパラメー ターの引数は省略できます。
省略可能な各パラメーターには、パラメーターの定義に既定値が含まれています。 そのパラメーターの引数を渡さない場合、既 定値が使用されます。 既定値には、次のいずれかの種類の式を指定できます。
定数式
new ValType() 形式の式です。 は、enum や struct のような値型になります。
default(ValType) 形式の式です。 は値型です。
省略可能なパラメーターは、パラメーター リストの末尾で必須パラメーターの後に定義されます。 呼び出し元は、連続する省略 可能なパラメーターのいずれか 1 つに対して引数を指定する場合、先行するすべての省略可能なパラメーターに引数を指定 する必要があります。 引数リストでコンマで区切られたスペースを使用することはできません。 たとえば、次のコードでは、1 つの
  ValType
 ValType
   // This generates CS1738: Named argument specifications must appear after all fixed arguments have been
specified.
PrintOrderDetails(productName: "Red Mug", 31, "Gift Shop");
 
  必須パラメーターと 2 つの省略可能パラメーターでインスタンス メソッド   が定義されます。
    public void ExampleMethod(int required, string optionalstr = "default string",
    int optionalint = 10)
  次に示す ExampleMethod の呼び出しでは、3つ目のパラメーターに引数が指定されていますが、2つ目のパラメーターには指 定されていないため、コンパイル エラーが発生します。
ただし、3 つ目のパラメーターの名前がわかっている場合、名前付き引数を使用してタスクを実行できます。
次の例に示すように、IntelliSense では、省略可能なパラメーターを角かっこで示します。
例
次の例では、 のコンストラクターに省略可能なパラメーターが1つあります。 ExampleMethod インスタンスメソッ ドには、 という1つの必須パラメーターと、optionalstr と optionalint という2つの省略可能なパラメーターがあ ります。 Main のコードに示すように、いくつかの異なる方法でコンストラクターとメソッドを呼び出すことができます。
  //anExample.ExampleMethod(3, ,4);
   anExample.ExampleMethod(3, optionalint: 4);
      NOTE
また、.NET OptionalAttribute クラスを使用して省略可能なパラメーターを宣言することもできます。 OptionalAttribute パラメー ターに既定値は必要ありません。
    ExampleClass
   required
 ExampleMethod
     namespace OptionalNamespace
{
    class OptionalExample
    {
        static void Main(string[] args)
        {
            // Instance anExample does not send an argument for the constructor's
            // optional parameter.
            ExampleClass anExample = new ExampleClass();
            anExample.ExampleMethod(1, "One", 1);
            anExample.ExampleMethod(2, "Two");
            anExample.ExampleMethod(3);
            // Instance anotherExample sends an argument for the constructor's
            // optional parameter.
            ExampleClass anotherExample = new ExampleClass("Provided name");
            anotherExample.ExampleMethod(1, "One", 1);
            anotherExample.ExampleMethod(2, "Two");
            anotherExample.ExampleMethod(3);
            // The following statements produce compiler errors.
            // An argument must be supplied for the first parameter, and it
            // must be an integer.
            //anExample.ExampleMethod("One", 1);
            //anExample.ExampleMethod();

 //anExample.ExampleMethod();
    上記のコードでは、省略可能なパラメーターが正しく適用されていない例がいくつか示されています。 最初の例は、必須である 1 番目のパラメーターに引数を指定する必要があることを示しています。
COM インターフェイス
名前付き引数と省略可能な引数を動的オブジェクトのサポートと併用すると、Office オートメーション API などの COM API と
の相互運用性が大幅に向上します。
たとえば、Microsoft Office Excel Range インターフェイスの AutoFormat メソッドには 7 つのパラメーターがあります。それらは すべて省略可能です。 これらのパラメーターを次の例に示します。
C# 3.0 以前のバージョンの C# では、次の例に示すように、各パラメーターの引数が必要です。
  } }
// You cannot leave a gap in the provided arguments.
//anExample.ExampleMethod(3, ,4);
//anExample.ExampleMethod(3, 4);
// You can use a named parameter to make the previous
// statement work.
anExample.ExampleMethod(3, optionalint: 4);
    class ExampleClass
    {
        private string _name;
        // Because the parameter for the constructor, name, has a default
        // value assigned to it, it is optional.
        public ExampleClass(string name = "Default name")
        {
            _name = name;
        }
        // The first parameter, required, has no default value assigned
        // to it. Therefore, it is not optional. Both optionalstr and
        // optionalint have default values assigned to them. They are optional.
        public void ExampleMethod(int required, string optionalstr = "default string",
            int optionalint = 10)
        {
            Console.WriteLine(
                $"{_name}: {required}, {optionalstr}, and {optionalint}.");
} }
    // The output from this example is the following:
    // Default name: 1, One, and 1.
    // Default name: 2, Two, and 10.
    // Default name: 3, default string, and 10.
    // Provided name: 1, One, and 1.
    // Provided name: 2, Two, and 10.
    // Provided name: 3, default string, and 10.
    // Default name: 3, default string, and 4.
}

       ただし、C#4.0の導入により、名前付き引数と省略可能な引数を使用すると、AutoFormat の呼び出しを大幅に簡略化で きます。 名前付き引数と省略可能な引数を使用すると、パラメーターの既定値を変更する必要がない場合に、省略可能な パラメーターの引数を省略できます。 次の呼び出しでは、7 つのパラメーターのうちの 1 つのパラメーターのみに値を指定していま す。
詳細と例については、「Office プログラミングで名前付き引数と省略可能な引数を使用する方法」と「C# の機能を使用して Office 相互運用オブジェクトにアクセスする方法」を参照してください。
Overload Resolution
名前付き引数と省略可能な引数を使用すると、オーバーロードの解決に次のように影響します。
メソッド、インデクサー、コンストラクターのパラメーターのそれぞれが任意であるか、名前か位置により、呼び出しステートメント の 1 つの引数に対応するとき、その引数がパラメーターの型に変換できる場合、メソッド、インデクサー、コンストラクターが実 行の候補になります。 複数の候補が見つかった場合、明示的に指定される引数には、優先変換に関するオーバーロード解決の規則が適用され ます。 任意のパラメーターの省略された引数は無視されます。
2 つの候補が等しく良好であると判断された場合、呼び出しで引数が省略された省略可能なパラメーターのない候補が優 先されます。 オーバーロードの解決では、一般的にパラメーターの少ない候補が優先されます。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
    // The following code shows the same call to AutoFormat in C# 4.0. Only
// the argument for which you want to provide a specific value is listed.
excelApp.Range["A1", "B4"].AutoFormat( Format: myFormat );
    // In C# 3.0 and earlier versions, you need to supply an argument for
// every parameter. The following call specifies a value for the first
// parameter, and sends a placeholder value for the other six. The
// default values are used for those parameters.
var excelApp = new Microsoft.Office.Interop.Excel.Application();
excelApp.Workbooks.Add();
excelApp.Visible = true;
var myFormat =
    Microsoft.Office.Interop.Excel.XlRangeAutoFormat.xlRangeAutoFormatAccounting1;
excelApp.get_Range("A1", "B4").AutoFormat(myFormat, Type.Missing,
    Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing);
 
     C# 4 で導入された名前付き引数と省略可能な引数を使うと、C# プログラミングの便利さ、柔軟性、読みやすさが向上しま す。 さらに、Microsoft Office オートメーション API などの COM インターフェイスへのアクセスが大幅に楽になります。
次の例の ConvertToTable メソッドには、列と行の数、書式設定、罫線、フォント、色など、テーブルの特性を表す 16 個のパ ラメーターがあります。 ほとんどの場合はこれらすべての特性に具体的な値を指定することはないので、16 個のパラメーターは すべて省略可能です。 しかし、名前付きの省略可能な引数を使わないと、各パラメーターに値またはプレースホルダー値を指 定する必要があります。 名前付きの省略可能な引数を使うと、プロジェクトに必要なパラメーターの値だけを指定できます。
以下の手順を行うには、Microsoft Office Word がコンピューターにインストールされている必要があります。
新しいコンソール アプリケーションを作成するには
1. Visual Studio を起動します。
2. [ファイル] メニューの [新規作成] をポイントし、 [プロジェクト] をクリックします。
3. [Templates Categories (テンプレート カテゴリ)] ウィンドウで、 [Visual C#] を展開し、 [Windows] をクリック します。
4. [テンプレート] ウィンドウの上部で、 [ターゲット フレームワーク] ボックスに [.NET Framework 4] が表示されている ことを確認します。
5. [テンプレート] ウィンドウで [コンソール アプリケーション] をクリックします。
6. [名前] フィールドに、プロジェクトの名前を入力します。
7. [OK] をクリックします。
ソリューション エクスプローラー に新しいプロジェクトが表示されます。
参照を追加するには
1. ソリューション エクスプローラー で、プロジェクトの名前を右クリックし、 [参照の追加] をクリックします。 [参照の追加] ダイアログ ボックスが表示されます。
2. [.NET] ページの [コンポーネント名] の一覧で、Microsoft.Office.Interop.Word を選びます。
3. [OK] をクリックします。
    NOTE
次の手順で参照している Visual Studio ユーザー インターフェイス要素の一部は、お使いのコンピューターでは名前や場所が異なる場合が あります。 これらの要素は、使用している Visual Studio のエディションや独自の設定によって決まります。 詳細については、「IDE をカスタマ イズする」をご覧ください。
 ディレクティブを使用して必要なものを追加するには
Office プログラミングで名前付き引数と省略可能 な引数を使用する方法 (C# プログラミング ガイ
ド)
2021/03/06 • • Edit Online
 
 1. ソリューション エクスプローラー で、Program.cs ファイルを右クリックし、 [コードの表示] をクリックします。 2. 次の using ディレクティブをコード ファイルの先頭に追加します。
Word 文書にテキストを表示するには
1.Program.csの Program クラスに、WordアプリケーションとWord文書を作成する次のメソッドを追加します。Add メソッドには、4 つの省略可能なパラメーターがあります。 この例では、それらの既定値を使います。 そのため、呼び出し ステートメントに引数は必要ありません。
  using Word = Microsoft.Office.Interop.Word;
      static void DisplayInWord()
{
    var wordApp = new Word.Application();
    wordApp.Visible = true;
    // docs is a collection of all the Document objects currently
    // open in Word.
    Word.Documents docs = wordApp.Documents;
    // Add a document to the collection and name it doc.
    Word.Document doc = docs.Add();
}
 2. 文書内でテキストを表示する場所と表示するテキストを定義する次のコードを、メソッドの最後に追加します。
    // Define a range, a contiguous area in the document, by specifying
// a starting and ending character position. Currently, the document
// is empty.
Word.Range range = doc.Range(0, 0);
// Use the InsertAfter method to insert a string at the end of the
// current range.
range.InsertAfter("Testing, testing, testing. . .");
 アプリケーションを実行するには 1. 次のステートメントを Main に追加します。
2. CTRL+F5 を押してプロジェクトを実行します。 指定したテキストを含む Word 文書が表示されます。 テキストをテーブルに変更するには
1. ConvertToTable メソッドを使って、テーブル内のテキストを囲みます。 このメソッドには、16 個の省略可能なパラメー ターがあります。 次の例に示すように、IntelliSense では省略可能なパラメーターは角かっこで囲まれています。
  DisplayInWord();
   
  名前付きの省略可能な引数を使うと、変更するパラメーターの値だけを指定できます。 簡単なテーブルを作成するに は、 DisplayInWord メソッドの最後に次のコードを追加します。 この引数は、 range 内のテキスト文字列のコンマが テーブルのセルを区切ることを指定します。
以前のバージョンのC#で ConvertToTable を呼び出すには、次のコードで示すように、パラメーターごとに参照引数が 必要です。
     // Convert to a simple table. The table will have a single row with
// three columns.
range.ConvertToTable(Separator: ",");
      // Call to ConvertToTable in Visual C# 2008 or earlier. This code
// is not part of the solution.
var missing = Type.Missing;
object separator = ",";
range.ConvertToTable(ref separator, ref missing, ref missing,
    ref missing, ref missing, ref missing, ref missing,
    ref missing, ref missing, ref missing, ref missing,
    ref missing, ref missing, ref missing, ref missing,
    ref missing);
 2. CTRL+F5 を押してプロジェクトを実行します。 他のパラメーターを調べるには
1.テーブルを1列3行に変更するには、DisplayInWord の最後の行を次のステートメントに置き換えてから、CTRL+F5 キーを押します。
2. テーブルに対して定義済みの書式を指定するには、 DisplayInWord の最後の行を次のステートメントに置き換えてか ら、CTRL+F5 キーを押します。 書式には、WdTableFormat 定数のどれでも指定できます。
例 ここまでの例をすべて含んだコードを次に示します。
   range.ConvertToTable(Separator: ",", AutoFit: true, NumColumns: 1);
      range.ConvertToTable(Separator: ",", AutoFit: true, NumColumns: 1,
    Format: Word.WdTableFormat.wdTableFormatElegant);
 
     関連項目
名前付き引数と省略可能な引数
  using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Word = Microsoft.Office.Interop.Word;
namespace OfficeHowTo
{
    class WordProgram
    {
        static void Main(string[] args)
        {
            DisplayInWord();
        }
        static void DisplayInWord()
        {
} }
}
var wordApp = new Word.Application();
wordApp.Visible = true;
// docs is a collection of all the Document objects currently
// open in Word.
Word.Documents docs = wordApp.Documents;
// Add a document to the collection and name it doc.
Word.Document doc = docs.Add();
// Define a range, a contiguous area in the document, by specifying
// a starting and ending character position. Currently, the document
// is empty.
Word.Range range = doc.Range(0, 0);
// Use the InsertAfter method to insert a string at the end of the
// current range.
range.InsertAfter("Testing, testing, testing. . .");
// You can comment out any or all of the following statements to
// see the effect of each one in the Word document.
// Next, use the ConvertToTable method to put the text into a table.
// The method has 16 optional parameters. You only have to specify
// values for those you want to change.
// Convert to a simple table. The table will have a single row with
// three columns.
range.ConvertToTable(Separator: ",");
// Change to a single column with three rows..
range.ConvertToTable(Separator: ",", AutoFit: true, NumColumns: 1);
// Format the table.
range.ConvertToTable(Separator: ",", AutoFit: true, NumColumns: 1,
    Format: Word.WdTableFormat.wdTableFormatElegant);

        クラスまたは構造体を作成するたびに、コンストラクターが呼び出されます。 クラスまたは構造体には、異なる引数を取るコンス トラクターが複数含まれていることがあります。 プログラマーはコンストラクターを利用することで、既定値を設定したり、インスタン ス化を制限したり、柔軟で読みやすいコードを記述したりできます。 詳細と例については、「コンストラクターの使用」と「インスタ ンス コンストラクター」を参照してください。
パラメーターなしのコンストラクター
クラスにコンストラクターを指定しない場合、C# では既定でコンストラクターが 1 つ作成されます。そのコンストラクターによりオブ ジェクトがインスタンス化され、「C# の既定値」の記事にある既定値にメンバー変数が設定されます。 構造体にコンストラクター を指定しない場合、C# では、暗黙的なパラメーターなしのコンストラクターを利用し、各フィールドがその既定値に自動的に初 期化されます。 詳細と例については、「インスタンス コンストラクター」を参照してください。
コンストラクターの構文
コンストラクターは、名前がその型の名前と同じメソッドです。 メソッド シグネチャには、メソッド名とそのパラメーター リストだけが
含まれます。戻り値の型は含まれません。 次の例は、 Person という名前のクラスのコンストラクターを示しています。
     public class Person
{
   private string last;
   private string first;
   public Person(string lastName, string firstName)
   {
      last = lastName;
      first = firstName;
   }
   // Remaining implementation of Person class.
}
 コンストラクターを 1 つのステートメントとして実装できる場合、式の本体の定義を利用できます。 次の例では、コンストラクター にnameという名前の文字列パラメーターが1つある Location クラスが定義されています。式の本体の定義により
locationName フィールドに引数が割り当てられます。
      public class Location
{
   private string locationName;
   public Location(string name) => Name = name;
   public string Name
   {
      get => locationName;
      set => locationName = value;
   }
}
 静的コンストラクター
コンストラクター (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
            前の例には、表示されるすべてのインスタンス コンストラクターがあり、それが新しいオブジェクトを作成します。 クラスまたは構造 体には静的コンストラクターを与えることもできます。静的コンストラクターは型の静的メンバーを初期化します。 静的コンストラク ターにはパラメーターがありません。 静的コンストラクターを指定して静的フィールドを初期化しない場合、C# コンパイラは、「C# 型の既定値」の記事にある既定値に静的フィールドを初期化します。
次の例では、静的コンストラクターを使用して静的フィールドを初期化しています。
    public class Adult : Person
{
   private static int minimumAge;
public Adult(string lastName, string firstName) : base(lastName, firstName) {}
   static Adult()
   {
      minimumAge = 18;
   }
   // Remaining implementation of Adult class.
}
 式の本体の定義で静的コンストラクターを定義することもできます。次の例をご覧ください。
    public class Child : Person
{
   private static int maximumAge;
public Child(string lastName, string firstName) : base(lastName, firstName) {}
   static Child() => maximumAge = 18;
   // Remaining implementation of Child class.
}
 詳細と例については、「静的コンストラクター」を参照してください。
このセクションの内容
コンストラクターの使用 インスタンス コンストラクター プライベート コンストラクター 静的コンストラクター
コピー コンストラクターを記述する方法
関連項目
C# プログラミング ガイド
クラスと構造体
ファイナライザー
static 初期化子がコンストラクターとは反対の順序で実行される理由その 1

      クラスまたは構造体を作成する際には、コンストラクターが呼び出されます。 コンストラクターの名前はクラスまたは構造体と同じ で、通常は、このコンストラクターによって、新しいオブジェクトのデータ メンバーが初期化されます。
次の例では、Taxi というクラスが、簡単なコンストラクターを使用して定義された後、new演算子によってインスタンス化され ます。 Taxi コンストラクターは、新しいオブジェクトに対してメモリが割り当てられるとすぐに、 new 演算子によって呼び出され ます。
    public class Taxi
{
    public bool IsInitialized;
    public Taxi()
    {
        IsInitialized = true;
    }
}
class TestTaxi
{
    static void Main()
    {
        Taxi t = new Taxi();
        Console.WriteLine(t.IsInitialized);
    }
}
 パラメーターを取らないコンストラクターを"パラメーターなしのコンストラクター"と呼びます。 new 演算子を使ってオブジェクトをイ ンスタンス化する際に new に引数を渡さなかった場合、常にパラメーターなしのコンストラクターが呼び出されます。詳細につい ては、「インスタンス コンストラクター」を参照してください。
クラスが静的である場合を除き、コンストラクターが存在しないクラスには、クラスをインスタンス化できるように、パブリックなパラ メーターなしのコンストラクターが C# コンパイラによって割り当てられます。 詳細については、「静的クラスと静的クラス メンバー」 を参照してください。
次のようにコンストラクターをプライベートにすれば、クラスがインスタンス化されないようにできます。
詳細については、「プライベート コンストラクター」を参照してください。
struct型のコンストラクターはクラスコンストラクターに似ていますが、structs には、明示的なパラメーターなしのコンストラク ターを含めることができません。パラメーターなしのコンストラクターは、コンパイラによって自動的に提供されるためです。 このコン ストラクターは、 struct 内の各フィールドを既定値に初期化します。 ただし、このパラメーターなしのコンストラクターは、
    class NLog {
    // Private Constructor:
    private NLog() { }
    public static double e = Math.E;  //2.71828...
}
    が new によってインスタンス化される場合にのみ呼び出されます。たとえば、次のコードでは、Int32のパラメーターな
コンストラクターの使用 (C# プログラミング ガ
イド)
2021/03/06 • • Edit Online
  struct
 
 しのコンストラクターが使用されるため、整数が確実に初期化されます。
    int i = new int();
Console.WriteLine(i);
 ただし、次のコードでは new が使用されておらず、コードは初期化されていないオブジェクトの使用を試みるため、コンパイラエ ラーが発生します。
これに対して、structs をベースにしたオブジェクト(組み込みのすべての数値型など)は、次の例のように、初期化または代 入してから使用できます。
このため、値型のパラメーターなしのコンストラクターを呼び出す必要はありません。
クラスと structs のどちらも、パラメーターを受け取るコンストラクターを定義できます。パラメーターを受け取るコンストラクター は、 new ステートメントまたは base ステートメントを使用して呼び出す必要があります。 クラスと structs は複数のコンストラ クターを定義することもできます。また、どちらも、パラメーターなしのコンストラクターの定義には必要ありません。 次に例を示しま す。
    int i;
Console.WriteLine(i);
      int a = 44;  // Initialize the value type...
int b;
b = 33;      // Or assign it before using it.
Console.WriteLine("{0}, {1}", a, b);
       public class Employee
{
    public int Salary;
    public Employee() { }
    public Employee(int annualSalary)
    {
        Salary = annualSalary;
    }
    public Employee(int weeklySalary, int numberOfWeeks)
    {
        Salary = weeklySalary * numberOfWeeks;
    }
}
 このクラスは、次のいずれかのステートメントを使用して作成できます。
コンストラクターでは、 base キーワードを使用して、基底クラスのコンストラクターを呼び出すことができます。 次に例を示しま す。
    Employee e1 = new Employee(30000);
Employee e2 = new Employee(500, 52);
 
        この例では、コンストラクターのブロックを実行する前に、基底クラスのコンストラクターを呼び出しています。 base キーワード は、パラメーターの有無に関係なく使用できます。 コンストラクターのパラメーターは、 base のパラメーターまたは式の一部として 使用できます。 詳細については、「base」を参照してください。
派生クラスで基底クラスのコンストラクターが base キーワードを使用して明示的に呼び出されていない場合、パラメーターなし のコンストラクター (存在する場合) は暗黙的に呼び出されます。 つまり、次に示すコンストラクターの宣言は実質的に同じで す。
    public Manager(int initialData)
{
    //Add further instructions here.
}
     public Manager(int initialData)
    : base()
{
    //Add further instructions here.
}
 基底クラスがパラメーターなしのコンストラクターを提供しない場合、派生クラスでは、 base を使って基本コンストラクターを明示 的に呼び出す必要があります。
コンストラクターでthisキーワードを使用すると、同じオブジェクトで別のコンストラクターを呼び出すことができます。 base と同 様、 this もパラメーターの有無に関係なく使用でき、コンストラクターのパラメーターはいずれも this のパラメーターとしても、 式の一部としても使用できます。たとえば、上の例の2番目のコンストラクターは this を使用して次のように書き直すことが できます。
上の例で this キーワードを使用すると、このコンストラクターが呼び出されます。
コンストラクターは、public、private、protected、internal、protected internal または private protected としてマークできま す。 こうしたアクセス修飾子により、クラスのユーザーによるクラスの作成方法が定義されます。 詳細については、「アクセス修飾 子」を参照してください。
コンストラクターは、static キーワードを使用して静的として宣言できます。 静的コンストラクターは、静的フィールドがアクセスさ れる直前に自動的に呼び出され、通常は静的なクラス メンバーを初期化するために使用されます。 詳細については、「静的 コンストラクター」を参照してください。
    public Employee(int weeklySalary, int numberOfWeeks)
    : this(weeklySalary * numberOfWeeks)
{ }
     public Employee(int annualSalary)
{
    Salary = annualSalary;
}
    public class Manager : Employee
{
    public Manager(int annualSalary)
        : base(annualSalary)
    {
        //Add further instructions here.
} }
 
        C# 言語仕様
詳細については、「C# 言語仕様」のインスタンス コンストラクターと静的コンストラクターに関するセクションを参照してください。
言語仕様は、C# の構文と使用法に関する信頼性のある情報源です。 関連項目
C# プログラミング ガイド クラスと構造体 コンストラクター ファイナライザー

     インスタンス コンストラクターは、new 式を使ってクラスのオブジェクトを作成するときに、インスタンス メンバー変数を作成および 初期化するために使われます。 静的クラスを初期化する場合、または非静的クラスの静的変数を初期化する場合は、静的 コンストラクターを定義します。 詳細については、「静的コンストラクター」を参照してください。
次に示すのは、インスタンス コンストラクターの例です。
    class Coords
{
    public int x, y;
    // constructor
    public Coords()
    {
x = 0;
y = 0; }
}
     NOTE
わかりやすくするため、このクラスにはパブリック フィールドが含まれています。 パブリック フィールドを使うと、プログラム内の任意の場所にある 任意のメソッドが、制限も検証もなしにオブジェクトの内部動作にアクセスできるため、パブリック フィールドは推奨されるプログラミング手法で はありません。 データ メンバーは、一般にプライベートにする必要があり、クラスのメソッドとプロパティを介してのみアクセスする必要がありま す。
  このインスタンス コンストラクターは、 Coords クラスに基づくオブジェクトが作成されるたびに呼び出されます。 引数を受け取らな いこのようなコンストラクターは、パラメーターなしのコンストラクター と呼ばれます。 ただし、コンストラクターを追加すると便利な場 合がよくあります。たとえば、データメンバーの初期値を指定できるコンストラクターを Coords クラスに追加できます。
これにより、次のように、既定値または特定の初期値で Coords オブジェクトを作成できます。
クラスにコンストラクターがない場合は、パラメーターなしのコンストラクターが自動的に生成され、既定値を使ってオブジェクトの フィールドが初期化されます。 たとえば、int は 0 に初期化されます。 値の既定値の詳細については、「C# 型の既定値」を参 照してください。 したがって、 Coords クラスのパラメーターなしのコンストラクターは、すべてのデータ メンバーをゼロに初期化する ため、クラスの動作を変更することなくまとめて削除することができます。 複数のコンストラクターを使う完全な例は後の例 1 で、 自動的に生成されたコンストラクターの例は例 2 で示します。
     // A constructor with two arguments.
public Coords(int x, int y)
{
this.x = x;
this.y = y; }
      var p1 = new Coords();
var p2 = new Coords(5, 3);
  インスタンス コンストラクター (C# プログラミ
ング ガイド) 2021/03/06 • • Edit Online
 
 インスタンス コンストラクターを使って、基底クラスのインスタンス コンストラクターを呼び出すこともできます。 次のように、クラスの コンストラクターは、初期化子を使って基底クラスのコンストラクターを呼び出すことができます。
この例では、 Circle クラスは、半径と高さを表す値を、 Circle の派生元である Shape によって提供されるコンストラクター に渡しています。 Shape と Circle を使う完全な例は、例3をご覧ください。
例1
次の例で示すクラスには、引数を持たないクラス コンストラクターと、2 つの引数を持つクラス コンストラクターがあります。
    class Circle : Shape
{
    public Circle(double radius)
        : base(radius, 0)
{
} }
        class Coords
{
    public int x, y;
    // Default constructor.
    public Coords()
    {
x = 0;
y = 0; }
    // A constructor with two arguments.
    public Coords(int x, int y)
    {
this.x = x;
this.y = y; }
    // Override the ToString method.
    public override string ToString()
    {
        return $"({x},{y})";
    }
}
class MainClass
{
    static void Main()
    {
} }
var p1 = new Coords();
var p2 = new Coords(5, 3);
// Display the results using the overriden ToString method.
Console.WriteLine($"Coords #1 at {p1}");
Console.WriteLine($"Coords #2 at {p2}");
Console.ReadKey();
/* Output:
 Coords #1 at (0,0)
 Coords #2 at (5,3)
*/
 例2

 この例の   クラスにはコンストラクターがありません。このような場合は、パラメーターなしのコンストラクターが自動的に提 供され、フィールドは既定値に初期化されます。
    using System;
public class Person
{
    public int age;
    public string name;
}
class TestPerson
{
    static void Main()
    {
} }
var person = new Person();
Console.WriteLine($"Name: {person.name}, Age: {person.age}");
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
// Output:  Name: , Age: 0
 age の既定値は 0 、 name の既定値は null であることに注意してください。 例3
次の例では、基底クラスの初期化子の使い方を示します。 Circle クラスは汎用クラス Shape から派生し、 Cylinder クラ スは Circle クラスから派生しています。各派生クラスのコンストラクターでは、その基底クラスの初期化子が使われています。
    Person
 
   using System;
abstract class Shape
{
    public const double pi = Math.PI;
    protected double x, y;
    public Shape(double x, double y)
    {
this.x = x;
this.y = y; }
    public abstract double Area();
}
class Circle : Shape
{
    public Circle(double radius)
        : base(radius, 0)
{ }
    public override double Area()
    {
        return pi * x * x;
    }
}
class Cylinder : Circle
{
    public Cylinder(double radius, double height)
        : base(radius)
{
y = height;
}
    public override double Area()
    {
        return (2 * base.Area()) + (2 * pi * x * y);
    }
}
class TestShapes
{
    static void Main()
    {
} }
double radius = 2.5;
double height = 3.0;
Circle ring = new Circle(radius);
Cylinder tube = new Cylinder(radius, height);
Console.WriteLine("Area of the circle = {0:F2}", ring.Area());
Console.WriteLine("Area of the cylinder = {0:F2}", tube.Area());
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
    Area of the circle = 19.63
    Area of the cylinder = 86.39
*/
   
      基底クラスのコンストラクターの呼び出しに関する他の例については、「virtual」、「override」、「base」をご覧ください。 関連項目
C# プログラミング ガイド クラスと構造体 コンストラクター ファイナライザー
static

     プライベート コンストラクターは、特別なインスタンス コンストラクターです。 通常は、静的メンバーだけを含むクラスで使用されま す。 クラスに 1 つ以上のプライベート コンストラクターがあり、パブリック コンストラクターがない場合、他のクラス (入れ子になった クラスを除く) は、このクラスのインスタンスを作成できません。 次に例を示します。
空のコンストラクターを宣言すると、パラメーターなしのコンストラクターは自動生成されません。 コンストラクターにアクセス修飾子 を指定しない場合でも、コンストラクターは既定でプライベートになります。 しかし、通常は、プライベート修飾子を明示的に使 用して、クラスをインスタンス化できないことを明確に示します。
プライベート コンストラクターは、Math クラスなどのインスタンス フィールドやメソッドが存在しない場合や、クラスのインスタンスを 取得するためにメソッドが呼び出される場合に、クラスのインスタンスが作成されないようにするために使用します。 クラス内のす べてのメソッドが静的な場合は、クラス全体を静的にすることを検討してください。 詳細については、「静的クラスと静的クラス メ ンバー」を参照してください。
例
次に示すのは、プライベート コンストラクターを使用するクラスの例です。
    class NLog {
    // Private Constructor:
    private NLog() { }
    public static double e = Math.E;  //2.71828...
}
 プライベート コンストラクター (C# プログラミ
ング ガイド) 2021/03/06 • • Edit Online
 
        この例で、次のステートメントをコメント解除すると、保護レベルのためにコンストラクターにアクセスできなくなり、エラーが発生しま す。
C# 言語仕様
詳細については、「C# 言語仕様」のプライベート コンストラクターに関するセクションを参照してください。 言語仕様は、C# の構
文と使用法に関する信頼性のある情報源です。 関連項目
C# プログラミング ガイド クラスと構造体 コンストラクター ファイナライザー private
public
       public class Counter
{
    private Counter() { }
    public static int currentCount;
    public static int IncrementCount()
    {
        return ++currentCount;
    }
}
class TestCounter
{
    static void Main()
    {
} }
// If you uncomment the following statement, it will generate
// an error because the constructor is inaccessible:
// Counter aCounter = new Counter();   // Error
Counter.currentCount = 100;
Counter.IncrementCount();
Console.WriteLine("New count: {0}", Counter.currentCount);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
// Output: New count: 101
 
      静的コンストラクターは、任意の static データを初期化するため、または 1 回だけ実行する必要がある特定のアクションを実行 するために使います。 最初のインスタンスが作成され前、または静的メンバーが参照される前に、自動的に呼び出されます。
    class SimpleClass
{
    // Static variable that must be initialized at run time.
    static readonly long baseline;
    // Static constructor is called at most one time, before any
    // instance constructor is invoked or member is accessed.
    static SimpleClass()
    {
        baseline = DateTime.Now.Ticks;
    }
}
 Remarks
静的コンストラクターには、次の特徴があります。
静的コンストラクターはアクセス修飾子を取らず、パラメーターはありません。
クラスまたは構造体は、静的コンストラクターを 1 つだけ持つことができます。
静的コンストラクターを継承またはオーバーロードすることはできません。
静的コンストラクターは、直接呼び出すことはできず、共通言語ランタイム (CLR) によって呼び出されることだけが意図さ れています。 自動的に呼び出されます。
ユーザーは、プログラムで静的コンストラクターが実行されるタイミングを制御できません。
静的コンストラクターは、最初のインスタンスが作成され前、または静的メンバーが参照される前に、クラスを初期化する ために自動的に呼び出されます。 静的コンストラクターは、インスタンス コンストラクターの前に実行されます。 イベントま たはデリゲートに割り当てられている静的メソッドが呼び出されるときは型の静的コンストラクターが呼び出されますが、割 り当てられるときは呼び出されません。 静的フィールド変数初期化子が静的コンストラクターのクラスに存在する場合、 初期化子は、静的コンストラクターの実行の直前に、クラス宣言に出現するテキストの順序で実行されます。
静的フィールドを初期化するための静的コンストラクターを指定しないと、すべての静的フィールドは、「C# 型の既定値」 で示されている既定値に初期化されます。
静的コンストラクターが例外をスローした場合、ランタイムがその静的コンストラクターを再度呼び出すことはなく、その型 は、プログラムが実行しているアプリケーション ドメインの有効期間中、初期化されないままになります。 ほとんどの場 合、静的コンストラクターで型をインスタンス化できないとき、または静的コンストラクター内でハンドルされない例外が発 生したときは、TypeInitializationException 例外がスローされます。 ソース コードで明示的に定義されていない暗黙 的な静的コンストラクターでは、トラブルシューティングの際に中間言語 (IL) のコードを調べることが必要になる場合があ ります。
静的コンストラクターが存在すると、BeforeFieldInit 型属性を追加できません。 これにより、ランタイムの最適化が制限 されます。
静的コンストラクター (C# プログラミング ガイ
ド)
2021/03/06 • • Edit Online
 
  として宣言されているフィールドは、その宣言の一部として、または静的コンストラクター内でのみ、割 り当てることができます。 明示的な静的コンストラクターが必要ない場合は、ランタイムのより適切な最適化のため、静 的コンストラクターではなく、宣言時に静的フィールドを初期化します。
使用方法
静的コンストラクターの一般的な用途は、クラスがログ ファイルを使っていて、このファイルにエントリを書き込むためにコン ストラクターが使われる場合です。
コンストラクターが LoadLibrary メソッドを呼び出すことができる場合は、アンマネージコードのラッパークラスを作成する ときにも静的コンストラクターが役に立ちます。
静的コンストラクターは、制約 (型パラメーターの制約) によりコンパイル時にチェックできない型パラメーターに対して、実 行時にチェックを強制するのに適した場所でもあります。
例
この例では、 Bus クラスに静的コンストラクターがあります。 Bus の最初のインスタンスが作成されるとき ( bus1 )、静的コンス トラクターが呼び出されてクラスが初期化されます。サンプルの出力では、Bus のインスタンスが2つでも静的コンストラクターは 1 回だけ実行されること、およびインスタンス コンストラクターの実行前に静的コンストラクターが実行されることがわかります。
    NOTE
直接アクセスすることはできませんが、初期化の例外のトラブルシューティングを助けるため、明示的な静的コンストラクターが存在することを 文書化する必要があります。
   static readonly
     public class Bus
{
    // Static variable used by all Bus instances.
    // Represents the time the first bus of the day starts its route.
    protected static readonly DateTime globalStartTime;
    // Property for the number of each bus.
    protected int RouteNumber { get; set; }
    // Static constructor to initialize the static variable.
    // It is invoked before the first instance constructor is run.
    static Bus()
    {
        globalStartTime = DateTime.Now;
        // The following statement produces the first line of output,
        // and the line occurs only once.
        Console.WriteLine("Static constructor sets global start time to {0}",
            globalStartTime.ToLongTimeString());
}
    // Instance constructor.
    public Bus(int routeNum)
    {
        RouteNumber = routeNum;
        Console.WriteLine("Bus #{0} is created.", RouteNumber);
    }
    // Instance method.
    public void Drive()
    {
        TimeSpan elapsedTime = DateTime.Now - globalStartTime;
        // For demonstration purposes we treat milliseconds as minutes to simulate
        // actual bus times. Do not do this in your actual bus schedule program!
        Console.WriteLine("{0} is starting its route {1:N2} minutes after global start time {2}.",
this.RouteNumber,

          C# 言語仕様
詳しくは、C# 言語仕様の「Static constructors (静的コンストラクター)」セクションをご覧ください。
関連項目
C# プログラミング ガイド
クラスと構造体
コンストラクター
静的クラスと静的クラス メンバー
ファイナライザー
コンストラクターのデザインのガイドライン
セキュリティの警告 - CA2121: 静的コンストラクターはプライベートでなければなりません
} }
class TestBus
{
    static void Main()
    {
} }
this.RouteNumber,
elapsedTime.Milliseconds,
globalStartTime.ToShortTimeString());
   // The creation of this instance activates the static constructor.
Bus bus1 = new Bus(71);
// Create a second bus.
Bus bus2 = new Bus(72);
// Send bus1 on its way.
bus1.Drive();
// Wait for bus2 to warm up.
System.Threading.Thread.Sleep(25);
// Send bus2 on its way.
bus2.Drive();
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Sample output:
    Static constructor sets global start time to 3:57:08 PM.
    Bus #71 is created.
    Bus #72 is created.
    71 is starting its route 6.00 minutes after global start time 3:57 PM.
    72 is starting its route 31.00 minutes after global start time 3:57 PM.
*/
 
   オブジェクトには C# レコードによってコピー コンストラクターが提供されますが、クラスには自分でそれを記述する必要がありま す。
例
次の例の Person クラスでは、 Person のインスタンスを引数として受け取るコピー コンストラクターが定義されています。 引数 のプロパティの値は、 Person の新しいインスタンスのプロパティに割り当てられています。 このコードには、コピーするインスタンス の Name プロパティと Age プロパティをクラスのインスタンスコンストラクターに渡す代替のコピーコンストラクターが含まれていま す。
   コピー コンストラクターを記述する方法 (C# プ
ログラミング ガイド) 2021/03/16 • • Edit Online
 
    関連項目
  using System;
class Person
{
    // Copy constructor.
    public Person(Person previousPerson)
    {
        Name = previousPerson.Name;
        Age = previousPerson.Age;
    }
    //// Alternate copy constructor calls the instance constructor.
    //public Person(Person previousPerson)
    //    : this(previousPerson.Name, previousPerson.Age)
    //{
//}
    // Instance constructor.
    public Person(string name, int age)
    {
Name = name;
Age = age; }
    public int Age { get; set; }
    public string Name { get; set; }
    public string Details()
    {
        return Name + " is " + Age.ToString();
    }
}
class TestPerson
{
    static void Main()
    {
} }
// Output:
// George is 39
// Charles is 41
// Create a Person object by using the instance constructor.
Person person1 = new Person("George", 40);
// Create another Person object, copying person1.
Person person2 = new Person(person1);
// Change each person's age.
person1.Age = 39;
person2.Age = 41;
// Change person2's name.
person2.Name = "Charles";
// Show details to verify that the name and age fields are distinct.
Console.WriteLine(person1.Details());
Console.WriteLine(person2.Details());
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();

      ICloneable
レコード
C# プログラミング ガイド クラスと構造体 コンストラクター ファイナライザー

    ガベージ コレクターによってクラス インスタンスが収集されている場合は、ファイナライザー (デストラクター とも呼ばれます) を使 用して、最終的に必要なすべてのクリーンアップが実行されます。
Remarks
ファイナライザーは、構造体には定義できません。 クラスでだけ使用します。 クラスで使用できるファイナライザーは 1 つだけです。 ファイナライザーを継承またはオーバーロードすることはできません。 ファイナライザーを呼び出すことはできません。 デストラクターは自動的に起動されます。 ファイナライザーは修飾子を取らず、パラメーターはありません。
たとえば、次はクラス Car に対するファイナライザーの宣言です。
ファイナライザーは、式本体の定義として実行することもできます。次に例を示します。
    class Car {
    ~Car()  // finalizer
    {
        // cleanup statements...
    }
}
     using System;
public class Destroyer
{
   public override string ToString() => GetType().Name;
   ~Destroyer() => Console.WriteLine($"The {ToString()} destructor is executing.");
}
 ファイナライザーは、オブジェクトの基底クラスで Finalize を暗黙的に呼び出します。 そのため、ファイナライザーの呼び出しは、 暗黙的に次のコードに解釈されます。
    protected override void Finalize()
{
try {
        // Cleanup statements...
    }
finally {
        base.Finalize();
    }
}
 この設計が意味することは、派生が最も多いクラスから派生が最も少ないクラスまで、継承チェーンのすべてのインスタンスに対
ファイナライザー (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
     して、   メソッドが再帰的に呼び出されるということです。
    NOTE
空のファイナライザーは使用しないでください。 ファイナライザーがクラスに存在するときは、エントリが Finalize キューで作成されます。 ファ イナライザーを呼び出すと、ガベージ コレクターが呼び出され、このキューを処理します。 ファイナライザーが空の場合、パフォーマンスを不必 要に低下させるだけです。
  ファイナライザーがいつ呼び出されるかは、プログラマは制御できません。それはガベージ コレクターによって決定されます。 ガベー ジ コレクターは、アプリケーションが使用していないオブジェクトをチェックします。 終了処理が可能なオブジェクトと考えられる場 合、ファイナライザー (存在する場合) を呼び出し、オブジェクトの格納に使用されているメモリを解放します。
(.NET Core アプリケーションではなく) .NET Framework アプリケーションでは、プログラムが存在する場合、ファイナライザーも呼 び出されます。
Collect を呼び出すことによって、ガベージ コレクションを強制的に行うことができます。ただし、パフォーマンスに問題が発生する 可能性があるため、通常はこの呼び出しを避けます。
ファイナライザーを使ったリソースの解放
一般に C# の場合、ガベージ コレクションでランタイムをターゲットにしない言語のような大量のメモリ管理は開発者側で必要に なりません。 .NET のガベージ コレクターが、オブジェクトに対するメモリの割り当てと解放を暗黙的に管理するからです。 ただ し、ウィンドウ、ファイル、ネットワーク接続などのアンマネージ リソースをアプリケーションでカプセル化する場合は、ファイナライザー を使ってこれらのリソースを解放する必要があります。 終了処理が可能なオブジェクトの場合、ガベージ コレクターはそのオブジェ クトの Finalize メソッドを実行します。
リソースの明示的な解放
アプリケーションで高額な外部リソースを使用している場合、ガベージ コレクターがオブジェクトを解放する前にリソースを明示的 に解放する手段を用意することが推奨されます。 リソースを解放するには、オブジェクトに必要なクリーンアップを実行する IDisposableインターフェイスから Dispose メソッドを実装します。これによって、アプリケーションのパフォーマンスを大幅に向上 させることができます。 このようにリソースを明示的に制御する場合でも、ファイナライザーは、 Dispose メソッドの呼び出しが失 敗したときにリソースをクリーンアップするための安全装置になります。
リソースのクリーンアップの詳細については、次の記事を参照してください。
アンマネージ リソースのクリーンアップ Dispose メソッドの実装
using ステートメント
例
次の例では、継承チェーンを形成する3つのクラスを作成します。 First が基底クラスであり、Second は First から派生 し、 Third は Second から派生します。 3 つのクラスのいずれにもファイナライザーがあります。 Main では、派生が最も多い クラスのインスタンスが作成されます。 プログラムを実行すると、3 つのクラスのファイナライザーが派生が最も多いクラスから派生 が最も少ないクラスの順に自動的に呼び出されます。
      Finalize
 
        C# 言語仕様
詳細については、「C# 言語仕様」の デストラクタ―に関するセクションを参照してください。
関連項目
IDisposable
C# プログラミング ガイド コンストラクター ガベージ コレクション
   class First {
~First() {
        System.Diagnostics.Trace.WriteLine("First's finalizer is called.");
    }
}
class Second : First
{
~Second() {
        System.Diagnostics.Trace.WriteLine("Second's finalizer is called.");
    }
}
class Third : Second
{
~Third() {
        System.Diagnostics.Trace.WriteLine("Third's finalizer is called.");
    }
}
class TestDestructors
{
    static void Main()
    {
        Third t = new Third();
    }
}
/* Output (to VS Output Window):
    Third's finalizer is called.
    Second's finalizer is called.
    First's finalizer is called.
*/
 
    C# では、1 つの命令文でオブジェクトまたはコレクションをインスタンス化し、1 つのステートメントでメンバーを割り当てることがで きます。
オブジェクト初期化子
オブジェクト初期化子を使用すると、オブジェクトの作成時にアクセスできるフィールドまたはプロパティに、コンストラクターを呼び 出して代入ステートメントを使用しなくても、値を割り当てることができます。 オブジェクト初期化子の構文では、コンストラクター の引数を指定することも、引数(およびかっこ構文)を省略することもできます。以下の例では、名前付きの型である Cat でオ ブジェクト初期化子を使用する方法と、パラメーターなしのコンストラクターを呼び出す方法を示します。 Cat クラス内で自動 実装プロパティが使用されています。 詳細については、「自動実装プロパティ」を参照してください。
    public class Cat
{
    // Auto-implemented properties.
    public int Age { get; set; }
    public string Name { get; set; }
    public Cat()
    {
    }
    public Cat(string name)
    {
        this.Name = name;
    }
}
     Cat cat = new Cat { Age = 10, Name = "Fluffy" };
Cat sameCat = new Cat("Fluffy"){ Age = 10 };
 オブジェクト初期化子の構文では、インスタンスを作成できます。その後、新規作成されたオブジェクトは、割り当てられたプロパ ティと共に、割り当ての変数に代入されます。
C# 6 より、オブジェクト初期化子では、フィールドとプロパティを割り当てることに加え、インデクサーを設定できます。 次の基底 Matrix クラスをご覧ください。
     public class Matrix
{
    private double[,] storage = new double[3, 3];
    public double this[int row, int column]
    {
} }
// The embedded array will throw out of range exceptions as appropriate.
get { return storage[row, column]; }
set { storage[row, column] = value; }
 オブジェクト初期化子とコレクション初期化子
(C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 次のコードで単位行列を初期化できます。
    var identity = new Matrix
{
    [0, 0] = 1.0,
    [0, 1] = 0.0,
    [0, 2] = 0.0,
    [1, 0] = 0.0,
    [1, 1] = 1.0,
    [1, 2] = 0.0,
    [2, 0] = 0.0,
    [2, 1] = 0.0,
    [2, 2] = 1.0,
};
 アクセス可能なセッターが含まれるアクセス可能なインデクサーを、引数の数や種類と関係なく、オブジェクト初期化子で式の 1 つとして使用できます。 インデックス引数は代入の左側となり、値は式の右側となります。 たとえば、 IndexersExample に適切 なインデクサーが指定されている場合、以下はすべて有効になります。
     var thing = new IndexersExample {
    name = "object one",
    [1] = '1',
    [2] = '4',
    [3] = '9',
    Size = Math.PI,
    ['C',4] = "Middle C"
}
  上記のコードをコンパイルするには、 IndexersExample 型に次のメンバーを指定する必要があります。
オブジェクト初期化子と匿名型
オブジェクト初期化子は、どのような場合にも使うことができますが、LINQ クエリ式で使うと特に有用です。 クエリ式では、次の
宣言に示すように、オブジェクト初期化子を使うことによってのみ初期化できる匿名型が頻繁に使われます。
匿名型を使うと、LINQクエリ式の select 句によって元のシーケンスのオブジェクトを値と形状が元とは異なるオブジェクトに変 換できます。 この方法は、シーケンス内の各オブジェクトの情報の一部のみを保存する場合に便利です。 次の例は、製品オブ ジェクト ( p ) に多くのフィールドおよびメソッドが含まれており、製品名および単価を含むオブジェクトのシーケンスを作成すること にのみ関心があることを想定しています。
このクエリが実行されると、 productInfos 変数には、次の例に示す foreach ステートメントでアクセスできるオブジェクトのシー ケンスが格納されます。
    public string name;
public double Size { set { ... }; }
public char this[int i] { set { ... }; }
public string this[char c, int i] {  set { ... }; }
   var pet = new { Age = 10, Name = "Fluffy" };
      var productInfos =
    from p in products
    select new { p.ProductName, p.UnitPrice };
   
    作成される匿名型内の各オブジェクトには、2 つのパブリック プロパティがあります。これらのプロパティには、元のオブジェクトのプ ロパティまたはフィールドと同じ名前が付けられます。 匿名型を作成するときにフィールドの名前を変更することもできます。次の 例では、フィールド UnitPrice の名前が Price に変更されます。
コレクション初期化子
コレクション初期化子を使うと、IEnumerable を実装するコレクション型を初期化するときに 1 つ以上の要素の初期化子を指 定でき、適切なシグネチャの Add をインスタンスメソッドまたは拡張メソッドとして使用できます。要素の初期化子は、単純な 値、式またはオブジェクト初期化子です。 コレクション初期化子を使用すると、呼び出しを複数回指定する必要がなくなりま す。コンパイラによって呼び出しが自動的に追加されるためです。
2 つの単純なコレクション初期化子を次の例に示します。
次のコレクション初期化子は、前の例で定義されている Cat クラスのオブジェクトをオブジェクト初期化子を使用して初期化し ます。 個々のオブジェクト初期化子は、かっこで囲まれ、コンマで区切られています。
コレクションの Add メソッドで許容されている場合、コレクション初期化子の要素としてnullを指定できます。
コレクションがインデックスを読み取り/書き込みできる場合は、インデックス付きの要素を指定できます。
上記のサンプルの場合、Item[TKey] を呼び出して値を設定するコードが生成されます。 C# 6 以前は、次の構文を使用し て、ディクショナリやその他の連想コンテナーを初期化できます。 インデクサー構文の代わりに、括弧と代入によって 1 つのオブ ジェクトと複数の値が処理されていることにご注目ください。
   select new {p.ProductName, Price = p.UnitPrice};
     List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
List<int> digits2 = new List<int> { 0 + 1, 12 % 3, MakeInt() };
     List<Cat> cats = new List<Cat>
{
    new Cat{ Name = "Sylvester", Age=8 },
    new Cat{ Name = "Whiskers", Age=2 },
    new Cat{ Name = "Sasha", Age=14 }
};
     List<Cat> moreCats = new List<Cat>
{
    new Cat{ Name = "Furrytail", Age=5 },
    new Cat{ Name = "Peaches", Age=4 },
    null
};
     var numbers = new Dictionary<int, string>
{
    [7] = "seven",
    [9] = "nine",
    [13] = "thirteen"
};
  foreach(var p in productInfos){...}
 
   この初期化子の例では、Add(TKey, TValue) を呼び出し、3 つの項目をディクショナリに追加しています。 連想コレクションを初 期化するこれら 2 つの異なる方法には、コンパイラによって生成されるメソッド呼び出しにより、動作にわずかな違いがあります。 いずれの場合も Dictionary クラスが使用されます。他の型の場合、パブリックAPIに基づいて、いずれかのみサポートされる ことがあります。
使用例 次の例では、オブジェクトの概念とコレクション初期化子の概念が組み合わさっています。
    var moreNumbers = new Dictionary<int, string>
{
    {19, "nineteen" },
    {23, "twenty-three" },
    {42, "forty-two" }
};
 
     次の例のオブジェクトはIEnumerableを実装します。このオブジェクトには Add メソッドと複数のパラメーターが含まれ、Add メ ソッドのシグネチャに対応するリスト項目ごとにコレクション初期化子と複数の要素を使用します。
  public class InitializationSample
{
    public class Cat
    {
        // Auto-implemented properties.
        public int Age { get; set; }
        public string Name { get; set; }
        public Cat() { }
        public Cat(string name)
        {
Name = name; }
}
    public static void Main()
    {
        Cat cat = new Cat { Age = 10, Name = "Fluffy" };
        Cat sameCat = new Cat("Fluffy"){ Age = 10 };
        List<Cat> cats = new List<Cat>
        {
            new Cat { Name = "Sylvester", Age = 8 },
            new Cat { Name = "Whiskers", Age = 2 },
            new Cat { Name = "Sasha", Age = 14 }
};
        List<Cat> moreCats = new List<Cat>
        {
            new Cat { Name = "Furrytail", Age = 5 },
            new Cat { Name = "Peaches", Age = 4 },
            null
};
        // Display results.
        System.Console.WriteLine(cat.Name);
        foreach (Cat c in cats)
            System.Console.WriteLine(c.Name);
        foreach (Cat c in moreCats)
            if (c != null)
                System.Console.WriteLine(c.Name);
            else
                System.Console.WriteLine("List element has null value.");
    }
    // Output:
    //Fluffy
    //Sylvester
    //Whiskers
    //Sasha
    //Furrytail
    //Peaches
    //List element has null value.
}

     Add メソッドでは、次の例で示すように、 params キーワードを使用して可変数個の引数を受け取ることができます。 この例で は、インデクサーのカスタム実装と、インデクサーを使用したコレクションの初期化を示しています。
         public class FullExample
    {
        class FormattedAddresses : IEnumerable<string>
        {
            private List<string> internalList = new List<string>();
            public IEnumerator<string> GetEnumerator() => internalList.GetEnumerator();
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() =>
internalList.GetEnumerator();
            public void Add(string firstname, string lastname,
                string street, string city,
                string state, string zipcode) => internalList.Add(
                $@"{firstname} {lastname}
{street}
{city}, {state} {zipcode}"
); }
        public static void Main()
        {
            FormattedAddresses addresses = new FormattedAddresses()
            {
                {"John", "Doe", "123 Street", "Topeka", "KS", "00000" },
                {"Jane", "Smith", "456 Street", "Topeka", "KS", "00000" }
            };
            Console.WriteLine("Address Entries:");
            foreach (string addressEntry in addresses)
            {
                Console.WriteLine("\r\n" + addressEntry);
            }
}
/*
* Prints:
            Address Entries:
            John Doe
            123 Street
            Topeka, KS 00000
            Jane Smith
            456 Street
            Topeka, KS 00000
*/ }
 public class DictionaryExample
{
class RudimentaryMultiValuedDictionary<TKey, TValue> : IEnumerable<KeyValuePair<TKey, List<TValue>>> {
        private Dictionary<TKey, List<TValue>> internalDictionary = new Dictionary<TKey, List<TValue>>();
        public IEnumerator<KeyValuePair<TKey, List<TValue>>> GetEnumerator() =>
internalDictionary.GetEnumerator();
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() =>
internalDictionary.GetEnumerator();
public List<TValue> this[TKey key]

public List<TValue> this[TKey key]
          {
            get => internalDictionary[key];
            set => Add(key, value);
        }
        public void Add(TKey key, params TValue[] values) => Add(key, (IEnumerable<TValue>)values);
        public void Add(TKey key, IEnumerable<TValue> values)
        {
            if (!internalDictionary.TryGetValue(key, out List<TValue> storedValues))
                internalDictionary.Add(key, storedValues = new List<TValue>());
            storedValues.AddRange(values);
        }
}
    public static void Main()
    {
        RudimentaryMultiValuedDictionary<string, string> rudimentaryMultiValuedDictionary1
            = new RudimentaryMultiValuedDictionary<string, string>()
            {
                {"Group1", "Bob", "John", "Mary" },
                {"Group2", "Eric", "Emily", "Debbie", "Jesse" }
            };
        RudimentaryMultiValuedDictionary<string, string> rudimentaryMultiValuedDictionary2
            = new RudimentaryMultiValuedDictionary<string, string>()
            {
                ["Group1"] = new List<string>() { "Bob", "John", "Mary" },
                ["Group2"] = new List<string>() { "Eric", "Emily", "Debbie", "Jesse" }
            };
        RudimentaryMultiValuedDictionary<string, string> rudimentaryMultiValuedDictionary3
            = new RudimentaryMultiValuedDictionary<string, string>()
            {
                {"Group1", new string []{ "Bob", "John", "Mary" } },
                { "Group2", new string[]{ "Eric", "Emily", "Debbie", "Jesse" } }
            };
        Console.WriteLine("Using first multi-valued dictionary created with a collection initializer:");
        foreach (KeyValuePair<string, List<string>> group in rudimentaryMultiValuedDictionary1)
        {
            Console.WriteLine($"\r\nMembers of group {group.Key}: ");
            foreach (string member in group.Value)
            {
                Console.WriteLine(member);
            }
}
        Console.WriteLine("\r\nUsing second multi-valued dictionary created with a collection initializer
using indexing:");
        foreach (KeyValuePair<string, List<string>> group in rudimentaryMultiValuedDictionary2)
        {
            Console.WriteLine($"\r\nMembers of group {group.Key}: ");
            foreach (string member in group.Value)
            {
                Console.WriteLine(member);
            }
}
        Console.WriteLine("\r\nUsing third multi-valued dictionary created with a collection initializer
using indexing:");
        foreach (KeyValuePair<string, List<string>> group in rudimentaryMultiValuedDictionary3)
        {
Console.WriteLine($"\r\nMembers of group {group.Key}: ");
  foreach (string member in group.Value)

      関連項目
C# プログラミング ガイド C# での LINQ
匿名型
} }
foreach (string member in group.Value)
{
    Console.WriteLine(member);
}
 /*
* Prints:
        Using first multi-valued dictionary created with a collection initializer:
        Members of group Group1:
        Bob
        John
        Mary
        Members of group Group2:
        Eric
        Emily
        Debbie
        Jesse
        Using second multi-valued dictionary created with a collection initializer using indexing:
        Members of group Group1:
        Bob
        John
        Mary
        Members of group Group2:
        Eric
        Emily
        Debbie
        Jesse
        Using third multi-valued dictionary created with a collection initializer using indexing:
        Members of group Group1:
        Bob
        John
        Mary
        Members of group Group2:
        Eric
        Emily
        Debbie
Jesse */
}

     オブジェクト初期化子を使用すると、型のコンストラクターを明示的に呼び出さずに、宣言的な方法で型オブジェクトを初期化 できます。
次の例は、指定したオブジェクトでオブジェクト初期化子を使用する方法を示しています。 コンパイラでは、最初にパラメーター なしのインスタンス コンストラクターにアクセスし、メンバーの初期化を処理することで、オブジェクト初期化子が処理されます。 そ のため、クラスでパラメーターなしのコンストラクターが private として宣言されている場合、パブリックアクセスを必要とするオブ ジェクト初期化子は失敗します。
匿名型を定義する場合は、オブジェクト初期化子を使用する必要があります。 詳細については、「クエリで要素のプロパティの サブセットを返す方法」を参照してください。
例
次の例は、オブジェクト初期化子を使用して、新しい StudentName 型を初期化する方法を示しています。この例では StudentName 型でプロパティが設定されます。
      オブジェクト初期化子を使用してオブジェクトを
初期化する方法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
  public class HowToObjectInitializers
{
    public static void Main()
    {
        // Declare a StudentName by using the constructor that has two parameters.
        StudentName student1 = new StudentName("Craig", "Playstead");
        // Make the same declaration by using an object initializer and sending
        // arguments for the first and last names. The parameterless constructor is
        // invoked in processing this declaration, not the constructor that has
        // two parameters.
        StudentName student2 = new StudentName
        {
            FirstName = "Craig",
            LastName = "Playstead"
        };
        // Declare a StudentName by using an object initializer and sending
        // an argument for only the ID property. No corresponding constructor is
        // necessary. Only the parameterless constructor is used to process object
        // initializers.
        StudentName student3 = new StudentName
        {
ID = 183 };
        // Declare a StudentName by using an object initializer and sending
        // arguments for all three properties. No corresponding constructor is
        // defined in the class.
        StudentName student4 = new StudentName
        {
            FirstName = "Craig",
            LastName = "Playstead",
            ID = 116
};
        Console.WriteLine(student1.ToString());
        Console.WriteLine(student2.ToString());

Console.WriteLine(student2.ToString());
 オブジェクト初期化子を使用し、オブジェクトにインデクサーを設定できます。 次の例では、インデクサーを使用する BaseballTeam クラスを定義し、選手を取得し、さまざまなポジションに据えます。初期化子によって、ポジションの省略形(野
球のスコアカードに使用される各ポジションの番号) に基づき、選手を割り当てることができます。
            Console.WriteLine(student3.ToString());
        Console.WriteLine(student4.ToString());
    }
    // Output:
    // Craig  0
    // Craig  0
    //   183
// Craig 116
    public class StudentName
    {
        // This constructor has no parameters. The parameterless constructor
        // is invoked in the processing of object initializers.
        // You can test this by changing the access modifier from public to
        // private. The declarations in Main that use object initializers will
        // fail.
        public StudentName() { }
        // The following constructor has parameters for two of the three
        // properties.
        public StudentName(string first, string last)
        {
            FirstName = first;
            LastName = last;
        }
        // Properties.
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int ID { get; set; }
        public override string ToString() => FirstName + "  " + ID;
    }
}
 
    関連項目
C# プログラミング ガイド オブジェクト初期化子とコレクション初期化子
   public class HowToIndexInitializer
{
    public class BaseballTeam
    {
        private string[] players = new string[9];
        private readonly List<string> positionAbbreviations = new List<string>
        {
            "P", "C", "1B", "2B", "3B", "SS", "LF", "CF", "RF"
        };
        public string this[int position]
        {
            // Baseball positions are 1 - 9.
            get { return players[position-1]; }
            set { players[position-1] = value; }
        }
        public string this[string position]
        {
            get { return players[positionAbbreviations.IndexOf(position)]; }
            set { players[positionAbbreviations.IndexOf(position)] = value; }
        }
}
    public static void Main()
    {
        var team = new BaseballTeam
        {
            ["RF"] = "Mookie Betts",
            [4] = "Jose Altuve",
            ["CF"] = "Mike Trout"
};
        Console.WriteLine(team["2B"]);
    }
}
 
      Dictionary<TKey,TValue> にはキーと値のペアのコレクションが含まれています。 その Add メソッドは、それぞれキーと値に対 する2つのパラメーターを受け取ります。 Add メソッドが複数のパラメーターを受け取るDictionary<TKey,TValue>またはコレ クションを初期化する 1 つの方法は、次の例に示すように、各パラメーターのセットを中かっこで囲むことです。 もう 1 つのオプショ ンは、インデックス初期化子を使用することです。これも次の例に示されています。
例
次のコード例では、Dictionary<TKey,TValue>が型 StudentName のインスタンスで初期化されています。最初の初期化で は、 Add メソッドを 2 つの引数と共に使用します。 コンパイラにより、 int キーと StudentName 値の各ペアに対して、 Add への呼び出しが生成されます。2回目の初期化では、Dictionary クラスのパブリック読み取り/書き込みインデクサーメソッド を使用します。
       public class HowToDictionaryInitializer
{
    class StudentName
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int ID { get; set; }
}
    public static void Main()
    {
        var students = new Dictionary<int, StudentName>()
        {
            { 111, new StudentName { FirstName="Sachin", LastName="Karnik", ID=211 } },
            { 112, new StudentName { FirstName="Dina", LastName="Salimzianova", ID=317 } },
            { 113, new StudentName { FirstName="Andy", LastName="Ruth", ID=198 } }
};
        foreach(var index in Enumerable.Range(111, 3))
        {
            Console.WriteLine($"Student {index} is {students[index].FirstName} {students[index].LastName}");
        }
        Console.WriteLine();
        var students2 = new Dictionary<int, StudentName>()
        {
            [111] = new StudentName { FirstName="Sachin", LastName="Karnik", ID=211 },
            [112] = new StudentName { FirstName="Dina", LastName="Salimzianova", ID=317 } ,
            [113] = new StudentName { FirstName="Andy", LastName="Ruth", ID=198 }
};
        foreach (var index in Enumerable.Range(111, 3))
        {
            Console.WriteLine($"Student {index} is {students2[index].FirstName}
{students2[index].LastName}");
} }
}
  最初の宣言のコレクションの各要素の中かっこの2つのペアに注目してください。最も内側の中かっこは StudentName のオブ
コレクション初期化子を使用してディクショナリ
を初期化する方法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
    ジェクト初期化子を囲み、最も外側の中かっこは、   Dictionary<TKey,TValue> に追加されるキーと値のペアの初 期化子を囲んでいます。 最後に、ディクショナリのコレクション初期化子全体が中かっこで囲まれています。 2 回目の初期化で は、代入の左辺はキーで、右辺は StudentName のオブジェクトの初期化子を使用する値です。
関連項目
C# プログラミング ガイド オブジェクト初期化子とコレクション初期化子
  students
 
             クラス、構造体、デリゲートまたはインターフェイスの中で定義された型は、入れ子にされた型と呼ばれます。 次に例を示しま す。
外側の型がクラス、構造体、入れ子にされた型のいずれであっても、入れ子にされた型は既定で private になり、それが含まれ る型からのみアクセスできます。 前の例では、 Nested クラスは外部の型にアクセスできません。
次のように、アクセス修飾子を指定して、入れ子にされた型のアクセシビリティを定義することもできます。
クラス の入れ子にされた型は、public、protected、internal、protected internal、private、private protected にな
ります。
ただし、シール クラス内で protected 、 protected internal 、 private protected の入れ子にされたクラスを定義
すると、コンパイラの警告 CS0628、"新規のプロテクト メンバーがシール クラスで宣言されました" が生成されます。
構造体 の入れ子にされた型は、は、public、internal、または private のいずれかが可能です。 次の例では、Nested クラスをpublicにします。
入れ子にされた型 (内側の型) は、包含する型 (外側の型) にアクセスできます。 包含する型にアクセスするには、その型を引 数として入れ子にされた型のコンストラクターに渡します。 次に例を示します。
    public class Container
{
    class Nested
    {
Nested() { } }
}
          public class Container
{
    public class Nested
    {
Nested() { } }
}
     public class Container
{
    public class Nested
    {
} }
private Container parent;
public Nested()
{
}
public Nested(Container parent)
{
    this.parent = parent;
}
 入れ子にされた型 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
     入れ子にされた型は、包含する型にアクセス可能なすべてのメンバーにアクセスできます。 入れ子にされた型は、継承されたプ ロテクト メンバーを含む、包含する型のプライベート メンバーとプロテクト メンバーにアクセスできます。
上記の宣言では、クラス Nested の完全名は Container.Nested です。これは、次のように入れ子になったクラスの新しいイ ンスタンスを作成するときに使用される名前です。
関連項目
C# プログラミング ガイド クラスと構造体 アクセス修飾子 コンストラクター
    Container.Nested nest = new Container.Nested();
 
    クラス、構造体、インターフェイスやメソッドの定義を複数のソース ファイルに分割できます。 各ソース ファイルには型やメソッドの 定義のセクションが含まれ、分割されたすべての部分はアプリケーションのコンパイル時に結合されます。
部分クラス クラス定義を分割するのが望ましいのは、次のような場合です。
大型プロジェクトを開発する際にクラスを別個のファイルに分割すると、複数のプログラマーが同時にそのクラスの作業を 行うことができます。
自動的に生成されたソースを使用する場合、ソース ファイルを再作成することなく、コードをクラスに追加できます。 Visual Studio では、Windows フォームや Web サービス ラッパー コードなどを作成するときにこのアプローチを使用しま す。 Visual Studio によって作成されたファイルを変更せずに、これらのクラスを使用するコードを作成できます。
クラス定義を分割するには、次のように partial キーワード修飾子を使用します。
    public partial class Employee
{
    public void DoWork()
    {
    }
}
public partial class Employee
{
    public void GoToLunch()
    {
    }
}
  partial
  partial
キーワードは、クラス、構造体、またはインターフェイスの他の部分を名前空間内で定義できることを示します。
キーワードは、すべての部分で使用する必要があります。 最終的な型を形成するためには、コンパイル時にすべての 部分が利用可能である必要があります。また、すべての部分で同じアクセシビリティ(public や private など)を使用する 必要があります。
abstract と宣言された部分がある場合、型全体が抽象と見なされます。 sealed と宣言された部分がある場合、型全体が sealed と見なされます。 また、基本データ型を宣言する部分がある場合は、型全体が該当するクラスを継承します。
基底クラスを指定する部分はすべて一致する必要がありますが、基底クラスを省略する部分も基本データ型を継承します。 部分は別の基本インターフェイスを指定でき、すべての部分宣言で示されたすべてのインターフェイスが最終的な型によって実 装されます。 部分定義で宣言されたクラス、構造体、インターフェイスの各メンバーは、他のすべての部分で利用できます。 最 終的な型は、コンパイル時にすべての部分を結合して形成されます。
      NOTE
partial 識別子は、デリゲートや列挙宣言では使用できません。
  次の例は、入れ子にされた型は、それを包含する型自体が partial でない場合でも、partial にできることを示しています。
部分クラスと部分メソッド (C# プログラミング
ガイド) 2021/03/06 • • Edit Online
 
  部分型定義の属性は、コンパイル時に結合されます。 たとえば、次のような宣言があるとします。
これらは、次の宣言と等価です。
各部分型定義に含まれる次の要素は、すべて結合されます。 XML コメント
インターフェイス ジェネリック型パラメーター属性 クラス属性
メンバー
たとえば、次のような宣言があるとします。
これらは、次の宣言と等価です。
制約 部分クラス定義を使用する場合は、いくつかの規則に従う必要があります。
同じ型の部分である部分型定義はすべて partial で修飾する必要があります。たとえば、次のクラス宣言はエラー になります。
    [SerializableAttribute]
partial class Moon { }
[ObsoleteAttribute]
partial class Moon { }
     [SerializableAttribute]
[ObsoleteAttribute]
class Moon { }
     partial class Earth : Planet, IRotate { }
partial class Earth : IRevolve { }
   class Earth : Planet, IRotate, IRevolve { }
      class Container
{
    partial class Nested
    {
        void Test() { }
    }
    partial class Nested
    {
        void Test2() { }
    }
}
    public partial class A { }
//public class A { }  // Error, must also be marked partial
 
         修飾子は、 class 、   、または   キーワードの直前にのみ配置できます。 入れ子にされた部分型は、次の例に示すように、部分型定義で宣言できます。
partial
struct
interface
       partial class ClassWithNestedClass
{
    partial class NestedClass { }
}
partial class ClassWithNestedClass
{
    partial class NestedClass { }
}
 同じ型の部分である部分型定義は、すべて同じアセンブリおよび同じモジュール (.exe ファイルまたは .dll ファイル) 内で 定義する必要があります。 部分定義は、複数のモジュールにまたがることができません。
クラス名とジェネリック型パラメーターはすべての部分型定義で一致する必要があります。 ジェネリック型は partial にでき ます。 それぞれの部分宣言では、同じパラメーター名を同じ順序で使用する必要があります。
以下のキーワードは、部分型定義では省略できますが、ある 1 つの部分型定義に存在する場合は、同じ型の別の部 分定義で指定されているキーワードと競合できません。
public
private
protected
internal
abstract
sealed
基本クラス
new 修飾子 (入れ子にされた部分) ジェネリック制約
詳細については、「型パラメーターの制約」を参照してください。 例1
説明
次の例では、クラス Coords のフィールドとコンストラクターを1つの部分クラス定義で宣言し、メンバー PrintCoords を別の 部分クラス定義で宣言しています。
コード
  
  例2 説明
次の例は、部分構造体と部分インターフェイスも開発できることを示しています。 コード
    partial interface ITest
{
    void Interface_Test();
}
partial interface ITest
{
    void Interface_Test2();
}
partial struct S1
{
    void Struct_Test() { }
}
partial struct S1
{
    void Struct_Test2() { }
}
 部分メソッド
   public partial class Coords
{
    private int x;
    private int y;
    public Coords(int x, int y)
    {
this.x = x;
this.y = y; }
}
public partial class Coords
{
    public void PrintCoords()
    {
        Console.WriteLine("Coords: {0},{1}", x, y);
    }
}
class TestCoords
{
    static void Main()
    {
} }
Coords myCoords = new Coords(10, 15);
myCoords.PrintCoords();
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
// Output: Coords: 10,15
 
       部分クラスまたは構造体には部分メソッドを含めることができます。 クラスのある部分に、メソッドのシグネチャが含まれます。 同 じ部分または別の部分に、オプションの実装を定義できます。 実装が指定されていない場合、メソッドとメソッドに対するすべて の呼び出しは、コンパイル時に削除されます。
部分メソッドを使用すると、イベントと同様に、クラスのある部分の実装者がメソッドを定義できます。 クラスの別の部分の実装 者は、メソッドを実装するかどうかを決定できます。 メソッドが実装されない場合、コンパイラは、メソッド シグネチャとメソッドに対 するすべての呼び出しを削除します。 このメソッドの呼び出しは、呼び出しの引数の評価から発生するすべての結果を含め、 実行時に影響を及ぼしません。 そのため、実装が指定されていない場合でも、部分クラス内のすべてのコードで部分メソッドを 自由に使用できます。 実装されていないメソッドが呼び出された場合、コンパイル時エラーまたは実行時エラーにはなりません。
部分メソッドは、生成されるコードをカスタマイズする方法として特に便利です。 メソッドの名前とシグネチャを予約できるため、 生成されるコードでメソッドを呼び出すことができます。ただし、メソッドを実装するかどうかは開発者が決定できます。 部分クラ スと同様に、部分メソッドでも、コード ジェネレーターによって作成されたコードと人間である開発者によって作成されたコードを 実行時コストなしで連携させることができます。
部分メソッドの宣言は、定義と実装の 2 つの部分から成ります。 これらは部分クラスの別々の部分にあっても同じ部分にあって もかまいません。 実装宣言がない場合は、定義宣言とメソッドに対するすべての呼び出しの両方が、コンパイラによる最適化に よって除外されます。
    // Definition in file1.cs
partial void onNameChanged();
// Implementation in file2.cs
partial void onNameChanged()
{
  // method body
}
 部分メソッドの宣言はコンテキスト キーワード partial で始まる必要があり、メソッドは void を返す必要があります。
部分メソッドには、in や ref パラメーターを使用できますが、out パラメーターは使用できません。
部分メソッドは暗黙的に private です。したがって部分メソッドを virtual にすることはできません。
部分メソッドを extern にすることはできません。部分メソッドの定義なのか実装なのかは、本体の存在で決まるためで す。
部分メソッドには static 修飾子と unsafe 修飾子を使用できます。
部分メソッドはジェネリックにできます。 制約は部分メソッドの定義宣言に置き、必要に応じて実装宣言で繰り返すこと
ができます。 パラメーター名と型パラメーター名は、定義宣言と実装宣言で同じである必要はありません。
delegate は、定義および実装されている部分メソッドには使用できますが、定義されているのみの部分メソッドには使 用できません。
C# 言語仕様
詳細については、「C# 言語仕様」の部分型に関するセクションを参照してください。 言語仕様は、C# の構文と使用法に関す
る信頼性のある情報源です。 関連項目
C# プログラミング ガイド クラス
構造体型 インターフェイス
partial (型)

      匿名型を使用すると、あらかじめ明示的に型を定義することなく、一連の読み取り専用プロパティを単一のオブジェクトにカプセ ル化できるので便利です。 型の名前はコンパイラにより生成され、ソース コード レベルでは使用できません。 各プロパティの型 はコンパイラにより推測されます。
匿名型を作成するには、new 演算子をオブジェクト初期化子と一緒に使用します。 オブジェクト初期化子の詳細について は、「オブジェクト初期化子とコレクション初期化子」を参照してください。
次の例では、 Amount および Message という名前の 2 つのプロパティがある、初期化される匿名型を示します。
通常、匿名型はクエリ式の select 句で使用され、ソース シーケンスの各オブジェクトからプロパティのサブセットを返します。 クエ リの詳細については、「C# での LINQ」を参照してください。
匿名型には、読み取り専用パブリック プロパティが 1 つ以上含まれます。 それ以外のクラス メンバー (メソッドやイベントなど) は 無効です。 プロパティの初期化に使用される式に、 null 、匿名関数、ポインター型を指定することはできません。
最も一般的な用例は、別の型のプロパティを使用して匿名型を初期化することです。 次の例では、 Product という名前のク
      var v = new { Amount = 108, Message = "Hello" };
// Rest the mouse pointer over v.Amount and v.Message in the following
// statement to verify that their inferred types are int and string.
Console.WriteLine(v.Amount + v.Message);
   ラスが存在すると仮定します。 Price プロパティです。 変数 始まります。 この宣言により、
されるデータの量が少なくなります。
クラスには、さまざまなプロパティが含まれますが、ここで注目するのは Color と
は、 Product オブジェクトのコレクションです。 匿名型の宣言は、 new キーワードで の 2 つのプロパティだけを使用する新しい型が初期化されます。 この結果、クエリに返
Product
   products
  Product
匿名型のメンバー名を指定しない場合、コンパイラは初期化に使用されるプロパティと同じ名前を匿名型メンバーに付けます。 前の例で示されているように、式を使用して初期化されるプロパティの名前を指定する必要があります。 次の例では、 Color と Price が匿名型のプロパティの名前になっています。
    var productQuery =
    from prod in products
    select new { prod.Color, prod.Price };
foreach (var v in productQuery)
{
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
}
 通常、変数の初期化に匿名型を使用する場合は、var を使用することにより、変数を暗黙的に型指定したローカル変数とし て宣言します。 コンパイラだけが匿名型の基になる名前にアクセスできるため、変数宣言では型の名前を指定できません。
var の詳細については、「暗黙的に型指定されたローカル変数」を参照してください。
次の例に示すように、暗黙的に型指定されたローカル変数と暗黙的に型指定された配列を組み合わせることにより、匿名型 の要素の配列を作成できます。
  var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};
 匿名型 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      Remarks
匿名型は object から直接派生した class 型であり、object 以外の型にキャストできません。 コンパイラは各匿名型に名前を 付けますが、この名前にアプリケーションはアクセスできません。 共通言語ランタイムから見た場合、匿名型と他の参照型に違 いはありません。
アセンブリ内の複数の匿名オブジェクト初期化子が、同じ順序で同じ名前や型を持つプロパティのシーケンスを指定する場合、 コンパイラはそれらのオブジェクトを同じ型のインスタンスとして処理します。 これらのオブジェクトは、コンパイラで生成された同一 の型情報を共有します。
フィールド、プロパティ、イベント、またはメソッドの戻り値の型は、匿名型を持つものとして宣言できません。 同様に、メソッドの 仮パラメーター、プロパティ、コンストラクター、またはインデクサーも、匿名型を持つものとして宣言できません。 メソッドの引数と して匿名型または匿名型を含むコレクションを渡すために、パラメーターを型オブジェクトとして宣言できます。 ただし、これにより 厳密な型指定が無効になります。 クエリ結果をメソッドの境界を越えて格納したり渡したりする必要がある場合、匿名型の代 わりに、通常の名前の構造体またはクラスの使用を検討してください。
匿名型のEqualsメソッドとGetHashCodeメソッドは、プロパティの Equals メソッドと GetHashCode メソッドとして定義されて います。このため、同じ匿名型の 2 つのインスタンスは、すべてのプロパティが等しい場合のみ等しいとみなされます。
関連項目
C# プログラミング ガイド オブジェクト初期化子とコレクション初期化子 C# の LINQ の概要
C# での LINQ
  
   次の両方の条件に当てはまる場合は、クエリ式に匿名型を使用します。 各ソース要素のプロパティの一部のみを返したい。 クエリを実行したメソッドのスコープ外のクエリ結果を保存する必要がない。
各ソース要素の1つのプロパティまたはフィールドのみを返す場合は、select 句でドット演算子(.)を使用します。たとえば、 各 student の ID のみを返すには、次のように select 句を記述します。
例 次に、匿名型を使用して、各ソース要素のプロパティのうち、指定した条件に一致するプロパティのみを返す例を示します。
     select student.ID;
     private static void QueryByScore()
{
    // Create the query. var is required because
    // the query produces a sequence of anonymous types.
    var queryHighScores =
        from student in students
        where student.ExamScores[0] > 95
        select new { student.FirstName, student.LastName };
    // Execute the query.
    foreach (var obj in queryHighScores)
    {
        // The anonymous type's properties were not named. Therefore
        // they have the same names as the Student properties.
        Console.WriteLine(obj.FirstName + ", " + obj.LastName);
} }
/* Output:
Adams, Terry
Fakhouri, Fadi
Garcia, Cesar
Omelchenko, Svetlana
Zabokritski, Eugene
*/
 名前を指定しない場合、匿名型にはプロパティのソース要素名が使用されます。 匿名型のプロパティに新しい名前を付けるに は、次のように select ステートメントを記述します。
前の例でこの方法を試すには、 Console.WriteLine ステートメントも次のように変更する必要があります。
   select new { First = student.FirstName, Last = student.LastName };
   クエリで要素のプロパティのサブセットを返す方
法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
  Console.WriteLine(student.First + " " + student.Last);
 
   コードのコンパイル
このコードを実行するには、クラスをコピーし、System.Linqに using ディレクティブを使用したC#コンソールアプリケーションに 貼り付けます。
関連項目
C# プログラミング ガイド 匿名型
C# での LINQ

         インターフェイスには、非抽象クラスまたは構造体で実装する必要がある、関連する機能のグループに対する定義が含まれま す。インターフェイスを使用すると、実装が必要な static メソッドを定義することができます。C#8.0以降では、インターフェ イスによってメンバーの既定の実装を定義できます。 インターフェイスでは、フィールド、自動実装プロパティ、プロパティに似たイ ベントなどのインスタンス データを宣言できません。
インターフェイスを使用すると、たとえば、クラス内の複数のソースからの動作を含めることができます。 C# ではクラスの複数の継 承がサポートされないため、この機能は重要です。 また、構造体の継承をシミュレートする場合はインターフェイスを使用する必 要があります。これは、実際に別の構造体またはクラスから継承することができないためです。
インターフェイスを定義するには、次の例に示すように、interface キーワードを使用します。
インターフェイスの名前を、有効なC#の識別子名にする必要があります。慣例により、インターフェイス名は大文字の I で 始めます。
IEquatable<T> インターフェイスを実装するすべてのクラスまたは構造体は、インターフェイスで指定されたシグネチャに一致す る Equals メソッドの定義を含む必要があります。 したがって、 IEquatable<T> を実装するクラスが Equals メソッドを含むと想 定したうえで、これを使用してクラスの 1 つのインスタンスが同じクラスの別のインスタンスと等しいかどうかを判定できます。
IEquatable<T> の定義は Equals の実装を提供しません。クラスまたは構造体には複数のインターフェイスを実装できます。 ただし、クラスは 1 つのクラスからのみ継承できます。
抽象クラスの詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。
インターフェイスには、instance メソッド、プロパティ、イベント、インデクサー、またはこれらの 4 種類のメンバーの任意の組み合 わせを含めることができます。 インターフェイスには、静的コンストラクター、フィールド、定数、または演算子を含めることができま す。 例へのリンクについては、「関連項目」を参照してください。 インターフェイスには、インスタンス フィールド、インスタンス コンス トラクター、またはファイナライザーを含めることができません。 インターフェイス メンバーは、既定ではパブリックであり、 public 、
protected 、 private 、 protected internal 、 private protected などのアクセシビリティ修飾子を明示的に 指定できます。 メンバーには既定の実装が必要です。
インターフェイスのメンバーを実装するには、実装するクラスの対応するメンバーがパブリックかつ非静的であり、インターフェイスの メンバーと同じ名前およびシグネチャを持つ必要があります。
クラスまたは構造体でインターフェイスを実装する場合、インターフェイスによって宣言され、既定の実装が提供されないすべて のメンバーについて、クラスまたは構造体で実装を提供する必要があります。 ただし、基本クラスでインターフェイスが実装される 場合、その基本クラスから派生するすべてのクラスはその実装を継承します。
IEquatable<T>インターフェイスを実装する例を次に示します。実装するクラスの Car は、Equalsメソッドの実装を提供する 必要があります。
     interface IEquatable<T>
{
    bool Equals(T obj);
}
           internal 、
 private
インターフェイス (C# プログラミング ガイド) 2021/03/15 • • Edit Online
 
         クラスのプロパティとインデクサーでは、インターフェイスに定義されているプロパティまたはインデクサーの追加のアクセサーを定義 できます。 たとえば、インターフェイスで get アクセサーを持つプロパティを宣言するとします。 このインターフェイスを実装するクラ スでは、get アクセサーとsetアクセサーの両方を持つ同じプロパティを宣言できます。ただし、プロパティまたはインデクサーで 明示的な実装を使用する場合は、これらのアクセサーが一致する必要があります。 明示的な実装の詳細については、「明示 的なインターフェイス実装」および「インターフェイスのプロパティ」を参照してください。
インターフェイスは、1 つ以上のインターフェイスから継承できます。 派生インターフェイスは、その基本インターフェイスからメン バーを継承します。 派生インターフェイスを実装するクラスでは、派生インターフェイスの基底インターフェイスのすべてのメンバー を含め、派生インターフェイスのすべてのメンバーを実装する必要があります。 そのクラスは、暗黙的に派生インターフェイスまた はその基底インターフェイスのいずれかに変換されます。 クラスは、継承する基底クラス、または他のインターフェイスが継承する インターフェイスを介して、インターフェイスを複数回含めることができます。 ただし、クラスでインターフェイスの実装を提供できる のは 1 回のみであり、それもクラスでクラスの定義の一部としてインターフェイスを宣言する場合 (
class ClassName : InterfaceName ) に限られます。 インターフェイスを実装する基本クラスを継承することによってインターフェ イスを継承する場合、基本クラスは、そのインターフェイスのメンバーの実装を提供します。 ただし、派生クラスでは、継承された 実装を使用する代わりに、任意の仮想インターフェイスのメンバーを再実装できます。 インターフェイスでメソッドの既定の実装 を宣言すると、そのインターフェイスを実装したクラスにはその実装が継承されます。 インターフェイスで定義された実装は仮想で あり、実装クラスを使ってその実装をオーバーライドできます。
また、基本クラスでは、仮想メンバーを使用して、インターフェイスのメンバーを実装することもできます。 その場合、派生クラスで は、仮想メンバーをオーバーライドすることでインターフェイスの動作を変更できます。 仮想メンバーの詳細については、「ポリモー フィズム」を参照してください。
インターフェイスの概要 インターフェイスは、次の特性を持ちます。
通常、インターフェイスは抽象メンバーのみを含む抽象基底クラスに似ています。 インターフェイスを実装するすべてのクラス または構造体では、そのすべてのメンバーを実装する必要があります。 必要に応じて、そのメンバーの一部またはすべての 既定の実装をインターフェイスで定義できます。 詳細については、既定のインターフェイス メソッドに関する記事をご覧くださ い。
インターフェイスを直接インスタンス化することはできません。 そのメンバーは、インターフェイスを実装する任意のクラスまたは 構造体によって実装されます。
クラスまたは構造体は、複数のインターフェイスを実装できます。 クラスは、基本クラスを継承する一方で、1 つまたは複数 のインターフェイスを実装できます。
関連セクション
インターフェイスのプロパティ インターフェイスのインデクサー インターフェイス イベントを実装する方法 クラスと構造体
    public class Car : IEquatable<Car>
{
    public string Make {get; set;}
    public string Model { get; set; }
    public string Year { get; set; }
    // Implementation of IEquatable<T> interface
    public bool Equals(Car car)
    {
} }
return (this.Make, this.Model, this.Year) ==
    (car.Make, car.Model, car.Year);
 
        継承
インターフェイス
メソッド
ポリモーフィズム
抽象クラスとシール クラス、およびクラス メンバー プロパティ
イベント
インデクサー
関連項目
C# プログラミング ガイド 継承
識別子名

   シグネチャが同じメンバーが含まれる 2 つのインターフェイスをあるクラスが実装する場合、そのクラスでそのメンバーを実装するこ とで、実装としてそのメンバーが両方のインターフェイスで使用されます。 次の例では、 Paint のすべての呼び出しで同じメソッ ドが呼び出されます。 この最初のサンプルでは、型が定義されます。
    public interface IControl
{
    void Paint();
}
public interface ISurface
{
    void Paint();
}
public class SampleClass : IControl, ISurface
{
    // Both ISurface.Paint and IControl.Paint call this method.
    public void Paint()
    {
        Console.WriteLine("Paint method in SampleClass");
    }
}
 次のサンプルでは、メソッドが呼び出されます。
    SampleClass sample = new SampleClass();
IControl control = sample;
ISurface surface = sample;
// The following lines all call the same method.
sample.Paint();
control.Paint();
surface.Paint();
// Output:
// Paint method in SampleClass
// Paint method in SampleClass
// Paint method in SampleClass
 2 つのインターフェイス メンバーで同じ関数を実行しない場合、一方または両方のインターフェイスが正しく実装されません。 イ ンターフェイス メンバーは明示的に実装できます。そのインターフェイス経由でのみ呼び出され、そのインターフェイスに固有となる クラス メンバーが作成されます。 インターフェイスの名前とピリオドを利用してクラス メンバーに名前を付けます。 次に例を示しま す。
明示的なインターフェイスの実装 (C# プログラ
ミング ガイド) 2020/11/02 • • Edit Online
 
      クラス メンバー IControl.Paint は IControl インターフェイス経由でのみ利用できます。 ISurface.Paint は ISurface 経 由でのみ利用できます。 いずれのメソッド実装も個別であり、どちらもクラスで直接利用できません。 次に例を示します。
    // Call the Paint methods from Main.
SampleClass obj = new SampleClass();
//obj.Paint();  // Compiler error.
IControl c = obj;
c.Paint();  // Calls IControl.Paint on SampleClass.
ISurface s = obj;
s.Paint(); // Calls ISurface.Paint on SampleClass.
// Output:
// IControl.Paint
// ISurface.Paint
 2 つのインターフェイスで、それぞれが同じ名前の別のメンバー (プロパティやメソッドなど) を宣言するような場合の解決には、明 示的な実装も利用されます。 両方のインターフェイスを実装するには、コンパイラ エラーを回避するために、クラスはプロパティ
P 、メソッド P 、または両方に明示的な実装を利用する必要があります。 次に例を示します。
    interface ILeft
{
int P { get;} }
interface IRight
{
int P(); }
class Middle : ILeft, IRight
{
    public int P() { return 0; }
    int ILeft.P { get { return 0; } }
}
 C# 8.0 以降では、インターフェイスで宣言されたメンバーの実装を定義できます。 クラスでインターフェイスからメソッド実装が継 承される場合、そのメソッドにはインターフェイス型の参照を利用する方法でのみアクセスできます。 継承したメンバーは、パブ リック インターフェイスの一部として表示されません。 次のサンプルでは、インターフェイス メソッドの既定の実装が定義されます。
   public class SampleClass : IControl, ISurface
{
    void IControl.Paint()
    {
        System.Console.WriteLine("IControl.Paint");
    }
    void ISurface.Paint()
    {
        System.Console.WriteLine("ISurface.Paint");
    }
}
 
     次のサンプルでは、既定の実装が呼び出されます。
IControl インターフェイスを実装するあらゆるクラスによって、既定の Paint メソッドをパブリックメソッドか明示的なインター フェイス実装としてオーバーライドできます。
関連項目
C# プログラミング ガイド クラスと構造体 インターフェイス
継承
    var sample = new SampleClass();
//sample.Paint();// "Paint" isn't accessible.
var control = sample as IControl;
control.Paint();
     public interface IControl
{
    void Paint() => Console.WriteLine("Default Paint method");
}
public class SampleClass : IControl
{
    // Paint() is inherited from IControl.
}
 
      この例ではインターフェイス、 IDimensions 、およびクラス Box を宣言します。これは、インターフェイス メンバーの GetLength と GetWidth を明示的に実装します。メンバーには、インターフェイスインスタンス dimensions を介してアクセスします。
例
  インターフェイス メンバーを明示的に実装する
方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    信頼性の高いプログラミング
Main メソッドでは、次の行はコメントアウトされます。これらの行でコンパイルエラーが発生するためです。明示的に実
装されるインターフェイス メンバーに、クラス インスタンスからアクセスすることはできません。
Main メソッドの以下の行では、メソッドがインターフェイスのインスタンスから呼び出されるため、ボックスのサイズを正常 に出力できます。
    //System.Console.WriteLine("Length: {0}", box1.GetLength());
//System.Console.WriteLine("Width: {0}", box1.GetWidth());
   interface IDimensions
{
    float GetLength();
    float GetWidth();
}
class Box : IDimensions
{
    float lengthInches;
    float widthInches;
    Box(float length, float width)
    {
        lengthInches = length;
        widthInches = width;
    }
    // Explicit interface member implementation:
    float IDimensions.GetLength()
    {
        return lengthInches;
    }
    // Explicit interface member implementation:
    float IDimensions.GetWidth()
    {
        return widthInches;
    }
    static void Main()
    {
} }
/* Output:
    Length: 30
Width: 20 */
// Declare a class instance box1:
Box box1 = new Box(30.0f, 20.0f);
// Declare an interface instance dimensions:
IDimensions dimensions = box1;
// The following commented lines would produce compilation
// errors because they try to access an explicitly implemented
// interface member from a class instance:
//System.Console.WriteLine("Length: {0}", box1.GetLength());
//System.Console.WriteLine("Width: {0}", box1.GetWidth());
// Print out the dimensions of the box by calling the methods
// from an instance of the interface:
System.Console.WriteLine("Length: {0}", dimensions.GetLength());
System.Console.WriteLine("Width: {0}", dimensions.GetWidth());

      関連項目
C# プログラミング ガイド
クラスと構造体
インターフェイス
2 つのインターフェイスのメンバーを明示的に実装する方法
   System.Console.WriteLine("Length: {0}", dimensions.GetLength());
System.Console.WriteLine("Width: {0}", dimensions.GetWidth());
 
    明示的なインターフェイス実装では、プログラマは、メンバー名が同じ 2 つのインターフェイスを実装し、各インターフェイス メン バーに別の実装を与えることもできます。 この例では、メートル法とヤード ポンド法の両方の単位で、ボックスのサイズを表示し ます。 Box クラスでは、異なる測定システムを表す IEnglishDimensions および IMetricDimensions という 2 つのインターフェ イスを実装します。 両方のインターフェイスは Length および Width という同じメンバー名を持ちます。
例
2 つのインターフェイスのメンバーを明示的に実
装する方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    信頼性の高いプログラミング
  // Declare the English units interface:
interface IEnglishDimensions
{
    float Length();
    float Width();
}
// Declare the metric units interface:
interface IMetricDimensions
{
    float Length();
    float Width();
}
// Declare the Box class that implements the two interfaces:
// IEnglishDimensions and IMetricDimensions:
class Box : IEnglishDimensions, IMetricDimensions
{
    float lengthInches;
    float widthInches;
    public Box(float lengthInches, float widthInches)
    {
        this.lengthInches = lengthInches;
        this.widthInches = widthInches;
    }
    // Explicitly implement the members of IEnglishDimensions:
    float IEnglishDimensions.Length() => lengthInches;
    float IEnglishDimensions.Width() => widthInches;
    // Explicitly implement the members of IMetricDimensions:
    float IMetricDimensions.Length() => lengthInches * 2.54f;
    float IMetricDimensions.Width() => widthInches * 2.54f;
    static void Main()
    {
} }
// Declare a class instance box1:
Box box1 = new Box(30.0f, 20.0f);
// Declare an instance of the English units interface:
IEnglishDimensions eDimensions = box1;
// Declare an instance of the metric units interface:
IMetricDimensions mDimensions = box1;
// Print dimensions in English units:
System.Console.WriteLine("Length(in): {0}", eDimensions.Length());
System.Console.WriteLine("Width (in): {0}", eDimensions.Width());
// Print dimensions in metric units:
System.Console.WriteLine("Length(cm): {0}", mDimensions.Length());
System.Console.WriteLine("Width (cm): {0}", mDimensions.Width());
/* Output:
    Length(in): 30
    Width (in): 20
    Length(cm): 76.2
    Width (cm): 50.8
*/

     ヤード ポンド単位で既定の測定を行う場合は、通常どおり Length と Width のメソッドを実装し、IMetricDimensions イン ターフェイスから Length と Width のメソッドを明示的に実装します。
この場合、ヤード ポンド単位にはクラス インスタンスからアクセスでき、メートル単位にはインターフェイス インスタンスからアクセス できます。
    // Normal implementation:
public float Length() => lengthInches;
public float Width() => widthInches;
// Explicit implementation:
float IMetricDimensions.Length() => lengthInches * 2.54f;
float IMetricDimensions.Width() => widthInches * 2.54f;
     public static void Test()
{
    Box box1 = new Box(30.0f, 20.0f);
    IMetricDimensions mDimensions = box1;
    System.Console.WriteLine("Length(in): {0}", box1.Length());
    System.Console.WriteLine("Width (in): {0}", box1.Width());
    System.Console.WriteLine("Length(cm): {0}", mDimensions.Length());
    System.Console.WriteLine("Width (cm): {0}", mDimensions.Width());
}
 関連項目
C# プログラミング ガイド
クラスと構造体
インターフェイス
インターフェイス メンバーを明示的に実装する方法

          デリゲートは、特定のパラメーター リストおよび戻り値の型を使用して、メソッドへの参照を表す型です。 デリゲートをインスタンス 化するときは、互換性のあるシグネチャと戻り値の型を持つ任意のメソッドにそのインスタンスを関連付けることができます。 メソッ ドは、デリゲート インスタンスを使用して起動する (呼び出す) ことができます。
デリゲートは、他のメソッドへの引数としてメソッドを渡すために使用されます。 イベント ハンドラーは、デリゲートを介して呼び出 されるメソッドにすぎません。 カスタム メソッドを作成して、特定のイベントの発生時に、作成したメソッドが Windows コントロー ルなどのクラスから呼び出されるようにできます。 次の例にデリゲート宣言を示します。
デリゲート型と一致するアクセス可能なクラスまたは構造体のメソッドはすべて、デリゲートに代入できます。 メソッドは、静的メ ソッドとインスタンス メソッドのいずれかにできます。 この柔軟性により、メソッド呼び出しをプログラムによって変更したり、新しい コードを既存のクラスに接続したりできます。
このようにメソッドをパラメーターとして参照できるため、デリゲートはコールバック メソッドを定義するのに最適です。 アプリケーショ ン内の 2 つのオブジェクトを比較するメソッドを記述できます。 このメソッドは、並べ替えアルゴリズムのデリゲートで使用できま す。 比較コードはライブラリとは別であるため、並べ替えメソッドの方が一般的です。
同様のシナリオで、呼び出し規則をより細かく制御する必要がある場合のために、関数ポインターが C# 9 に追加されました。 デリゲートに関連付けられたコードは、デリゲート型に追加された仮想メソッドを使用して呼び出されます。 関数ポインターを使 用して、さまざまな規則を指定できます。
デリゲートの概要 デリゲートには、次の特徴があります。
デリゲートは C++ 関数ポインターと似ていますが、デリゲートは完全なオブジェクト指向です。また、メンバー関数への C++ ポインターとは異なり、デリゲートではオブジェクト インスタンスとメソッドの両方をカプセル化します。 デリゲートを使用すると、メソッドをパラメーターとして渡すことができます。
デリゲートは、コールバック メソッドを定義するのに使用できます。
デリゲートは連結でき、たとえば、複数のメソッドを 1 つのイベントで呼び出すことができます。 メソッドは、デリゲート型に正確に一致する必要がありません。 詳細については、「デリゲートの分散の使用」を参照してくだ さい。
ラムダ式は、インライン コード ブロックをより簡潔に記述する方法です。 (特定のコンテキストにおける) ラムダ式は、デリゲート 型にコンパイルされます。 ラムダ式について詳しくは、「ラムダ式」をご覧ください。
このセクションの内容
デリゲートの使用
インターフェイス (c# プログラミング ガイド) ではなくデリゲートを使用する場合 名前付きメソッドを使用したデリゲートと匿名メソッドを使用したデリゲート
  public delegate int PerformCalculation(int x, int y);
     NOTE
メソッドのオーバーロードのコンテキストでは、メソッドのシグネチャに戻り値は含まれません。 しかしデリゲートのコンテキストでは、シグネチャに戻 り値が含まれます。 つまり、メソッドにはデリゲートと同じ戻り値の型が必要です。
 デリゲート (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
              デリゲートの変性の使用
デリゲートを結合する方法 (マルチキャスト デリゲート) デリゲートを宣言し、インスタンス化して、使用する方法
C# 言語仕様
詳細については、「C# 言語の仕様」の「デリゲート」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性の
ある情報源です。 参考書籍の該当する章
「Delegates, Events, and Lambda Expressions (デリゲート、イベント、およびラムダ式)」(『C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers (C# 3.0 クックブック (第 3 版): C# 3.0 プログラマ向けの 250 以上のソリューション)』)
「デリゲートとイベント」(『Learning C# 3.0: Master the fundamentals of C# 3.0 (C# 3.0 の学習: C# 3.0 の基礎を習 得)』)
関連項目
Delegate
C# プログラミング ガイド イベント

       デリゲートは、C および C++ の関数ポインターのようなメソッドを安全にカプセル化する型です。 ただし、C 関数ポインターとは 異なり、デリゲートはオブジェクト指向で、タイプ セーフで、安全です。 デリゲートの型は、デリゲートの名前によって定義されま す。次の例では、引数として文字列を受け取り、voidを返すメソッドをカプセル化できる Del という名前のデリゲートを宣言し ています。
デリゲート オブジェクトは、通常、デリゲートがラップするメソッドの名前を指定して構成されるか、匿名関数を使用して構成され ます。 デリゲートがインスタンス化されると、デリゲートに対するメソッドの呼び出しが、デリゲートからメソッドに渡されます。 呼び 出し元によってデリゲートに渡されるパラメーターはメソッドに渡され、戻り値がある場合は、デリゲートによってメソッドから呼び出 し元に返されます。 これは、デリゲートの呼び出しと呼ばれます。 インスタンス化されたデリゲートは、ラップされたメソッドそのもの であるかのように呼び出すことができます。 次に例を示します。
  public delegate void Del(string message);
     // Create a method for a delegate.
public static void DelegateMethod(string message)
{
    Console.WriteLine(message);
}
     // Instantiate the delegate.
Del handler = DelegateMethod;
// Call the delegate.
handler("Hello World");
 デリゲート型は、.NET の Delegate クラスから派生しています。 デリゲート型は sealed (派生できません) であり、Delegate から カスタム クラスを派生することはできません。 インスタンス化されたデリゲートはオブジェクトであるため、パラメーターとして渡した り、プロパティに割り当てたりすることができます。 これにより、メソッドは、パラメーターとしてデリゲートを受け入れ、後でデリゲート を呼び出すことができます。 これは非同期のコールバックと呼ばれ、長いプロセスの完了時に呼び出し元に通知する一般的な 方法です。 デリゲートをこの方法で使用する場合、デリゲートを使用するコードは、使用されるメソッドの実装について認識して いる必要はありません。 機能は、カプセル化インターフェイスが提供する機能に似ています。
コールバックの別の一般的な使用方法は、カスタム比較メソッドの定義およびそのデリゲートの並べ替えメソッドへの引き渡しで す。これにより、呼び出し元のコードを並べ替えアルゴリズムの一部にすることができます。次の例のメソッドは Del 型をパラ メーターとして使用しています。
上記で作成したデリゲートをメソッドに渡すことができます。
    public static void MethodWithCallback(int param1, int param2, Del callback)
{
    callback("The number is: " + (param1 + param2).ToString());
}
   MethodWithCallback(1, 2, handler);
 次の出力がコンソールに表示されます。
デリゲートの使用 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     The number is: 3
  抽象化としてデリゲートを使用する場合、 がコンソールを直接呼び出す必要はありません。コンソールに 留意して設計する必要はありません。 は文字列を準備し、文字列を別のメソッドに渡すだけです。 こ れは、デリゲート メソッドが任意の数のパラメーターを使用できるため、特に強力です。
インスタンス メソッドをラップするようにデリゲートが構築された場合、デリゲートはインスタンスとメソッドの両方を参照します。 デリ ゲートはラップするメソッド以外のインスタンス型を認識しないため、デリゲート シグネチャと一致するオブジェクトにメソッドがある 限り、どの型のオブジェクトでも参照できます。 静的メソッドをラップするようにデリゲートが構築された場合、デリゲートはそのメ ソッドのみを参照します。 次に宣言の例を示します。
以前に示した静的な DelegateMethod と共に、Del インスタンスによってラップできるメソッドが3つあります。
デリゲートは、呼び出されたときに複数のメソッドを呼び出すことができます。 これはマルチキャスティングと呼ばれます。 デリゲート のメソッドの一覧 (呼び出しリスト) に追加のメソッドを追加するには、加算演算子または加算代入演算子 ('+' または '+=') を使用して 2 つのデリゲートを追加する必要があります。 次に例を示します。
MethodWithCallback
 MethodWithCallback
    public class MethodClass
{
    public void Method1(string message) { }
    public void Method2(string message) { }
}
      var obj = new MethodClass();
Del d1 = obj.Method1;
Del d2 = obj.Method2;
Del d3 = DelegateMethod;
//Both types of assignment are valid.
Del allMethodsDelegate = d1 + d2;
allMethodsDelegate += d3;
     この時点で、allMethodsDelegate には、呼び出しリスト内の3つのメソッド(Method1、 、 )が含 まれています。 元の 3 つのデリゲートである d1 、 d2 、および d3 は変更されません。 が呼び出される と、すべての 3 つのメソッドが順に呼び出されます。 デリゲートで参照パラメーターを使用する場合、参照は、3 つのメソッドに順 番に渡され、1 つのメソッドによって行われた変更は、次のメソッドに示されます。 いずれかのメソッドがメソッド内でキャッチされ ない例外をスローした場合、デリゲートの呼び出し元に例外が渡され、呼び出しリスト内の後続のメソッドは呼び出されません。 デリゲートに戻り値や out パラメーターがある場合、デリゲートは戻り値と最後に呼び出されたメソッドのパラメーターを返します。 呼び出しリストからメソッドを削除するには、減算演算子または減算代入演算子(- または -=)を使います。次に例を示し ます。
デリゲート型が System.Delegate から派生しているため、そのクラスで定義されるメソッドとプロパティはデリゲートで呼び出すこと ができます。 たとえば、デリゲートの呼び出しリスト内のメソッドの数を検索するには、次のように記述します。
呼び出しリストに複数のメソッドがあるデリゲートは、MulticastDelegateのサブクラスである System.Delegate から派生しま す。 上記のコードでは、両方のクラスが   をサポートしているため、いずれの場合も機能します。
Method2
DelegateMethod
     //remove Method1
allMethodsDelegate -= d1;
// copy AllMethodsDelegate while removing d2
Del oneMethodDelegate = allMethodsDelegate - d2;
  int invocationCount = d1.GetInvocationList().GetLength(0);
allMethodsDelegate
     GetInvocationList
 
       マルチキャスト デリゲートは、イベント処理で広く使用されます。 イベント ソース オブジェクトはイベントを受け取るように登録され ている受信者オブジェクトにイベント通知を送信します。 イベントを登録するには、受信者は、イベントを処理するようにデザイ ンされたメソッドを作成し、そのメソッドのデリゲートを作成してイベント ソースにデリゲートを渡します。 イベントが発生すると、 ソースがデリゲートを呼び出します。 デリゲートは、受信者のイベント処理メソッドを呼び出し、イベント データを配信します。 特 定のイベントのデリゲート型は、イベント ソースによって定義されます。 詳細については、「イベント (C# プログラミング ガイド)」を 参照してください。
コンパイル時に割り当てられた 2 つの異なる型のデリゲートを比較すると、コンパイル エラーが発生します。 デリゲート インスタン スが静的な System.Delegate 型の場合は、比較できますが、実行時にfalseが返されます。次に例を示します。
     delegate void Delegate1();
delegate void Delegate2();
static void method(Delegate1 d, Delegate2 e, System.Delegate f)
{
    // Compile-time error.
    //Console.WriteLine(d == e);
    // OK at compile-time. False if the run-time type of f
    // is not the same as that of d.
    Console.WriteLine(d == f);
}
 関連項目
C# プログラミング ガイド デリゲート デリゲートの変性の使用 デリゲートの変性
Func および Action 汎用デリゲートでの変性の使用 イベント

     デリゲートは、名前付きメソッドに関連付けることができます。 名前付きメソッドを使用してデリゲートをインスタンス化するとき は、次のように、そのメソッドをパラメーターとして渡します。
    // Declare a delegate.
delegate void Del(int x);
// Define a named method.
void DoWork(int k) { /* ... */ }
// Instantiate the delegate using the method as a parameter.
Del d = obj.DoWork;
 これを名前付きメソッドの使用といいます。 名前付きメソッドで作成されたデリゲートは、静的メソッドまたはインスタンス メソッド のいずれかでカプセル化できます。 旧バージョンの C# では、デリゲートをインスタンス化するには、名前付きメソッドを使用するし かありませんが、 新しいメソッドを作成するのが、オーバーヘッドの点で望ましくない場合は、C# でデリゲートをインスタンス化し、 そのデリゲートが呼び出されたときに処理するコード ブロックを直接指定できます。 ブロックには、ラムダ式または匿名メソッドのい ずれかを含めることができます。 詳細については、匿名関数に関するページをご覧ください。
Remarks
デリゲート パラメーターとして渡すメソッドには、デリゲート宣言と同じシグネチャが必要です。
デリゲート インスタンスがカプセル化できるのは、静的メソッドまたはインスタンス メソッドのいずれかです。
デリゲートは out パラメーターを使用できますが、マルチキャスト イベント デリゲートでこのパラメーターを使用することはお勧めしま せん。どのデリゲートが呼び出されるかわからないためです。
例1
次のシンプルな例では、デリゲートを宣言して使用します。 デリゲート Del とそれに関連付けられているメソッド MultiplyNumbers の両方に同じシグネチャが含まれることに注意してください。
 名前付きメソッドを使用したデリゲートと匿名メ
ソッド (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
  例2
次の例では、1 つのデリゲートを静的メソッドとインスタンス メソッドの両方に割り当て、各メソッドから特定の情報を戻します。
   // Declare a delegate
delegate void Del(int i, double j);
class MathClass
{
    static void Main()
    {
        MathClass m = new MathClass();
        // Delegate instantiation using "MultiplyNumbers"
        Del d = m.MultiplyNumbers;
        // Invoke the delegate object.
        Console.WriteLine("Invoking the delegate using 'MultiplyNumbers':");
        for (int i = 1; i <= 5; i++)
        {
d(i, 2); }
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
}
    // Declare the associated method.
    void MultiplyNumbers(int m, double n)
    {
        Console.Write(m * n + " ");
    }
}
/* Output:
    Invoking the delegate using 'MultiplyNumbers':
2 4 6 8 10 */
 
     関連項目
C# プログラミング ガイド
デリゲート
デリゲートを結合する方法 (マルチキャスト デリゲート) イベント
   // Declare a delegate
delegate void Del();
class SampleClass
{
    public void InstanceMethod()
    {
        Console.WriteLine("A message from the instance method.");
    }
    static public void StaticMethod()
    {
        Console.WriteLine("A message from the static method.");
    }
}
class TestSampleClass
{
    static void Main()
    {
} }
var sc = new SampleClass();
// Map the delegate to the instance method:
Del d = sc.InstanceMethod;
d();
// Map to the static method:
d = SampleClass.StaticMethod;
d();
/* Output:
    A message from the instance method.
    A message from the static method.
*/
 
    ここでは、マルチキャストデリゲートを作成する例について説明します。デリゲートオブジェクトの便利な性質の1つは、+ 演 算子を使用して、複数のオブジェクトを 1 つのデリゲート インスタンスに割り当てられることです。 マルチキャスト デリゲートには、 割り当てられたデリゲートの一覧が含まれています。 マルチキャスト デリゲートを呼び出すと、一覧内のデリゲートが順に呼び出 されます。 結合できるのは、同じ型のデリゲートのみです。
- 演算子を使用して、マルチキャストデリゲートからコンポーネントデリゲートを削除することができます。 例
デリゲートを結合する方法 (マルチキャスト デリ
ゲート) (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   using System;
// Define a custom delegate that has a string parameter and returns void.
delegate void CustomDel(string s);
class TestClass
{
    // Define two methods that have the same signature as CustomDel.
    static void Hello(string s)
    {
        Console.WriteLine($"  Hello, {s}!");
    }
    static void Goodbye(string s)
    {
        Console.WriteLine($"  Goodbye, {s}!");
    }
    static void Main()
    {
} }
// Declare instances of the custom delegate.
CustomDel hiDel, byeDel, multiDel, multiMinusHiDel;
// In this example, you can omit the custom delegate if you
// want to and use Action<string> instead.
//Action<string> hiDel, byeDel, multiDel, multiMinusHiDel;
// Create the delegate object hiDel that references the
// method Hello.
hiDel = Hello;
// Create the delegate object byeDel that references the
// method Goodbye.
byeDel = Goodbye;
// The two delegates, hiDel and byeDel, are combined to
// form multiDel.
multiDel = hiDel + byeDel;
// Remove hiDel from the multicast delegate, leaving byeDel,
// which calls only the method Goodbye.
multiMinusHiDel = multiDel - hiDel;
Console.WriteLine("Invoking delegate hiDel:");
hiDel("A");
Console.WriteLine("Invoking delegate byeDel:");
byeDel("B");
Console.WriteLine("Invoking delegate multiDel:");
multiDel("C");
Console.WriteLine("Invoking delegate multiMinusHiDel:");
multiMinusHiDel("D");
/* Output:
Invoking delegate hiDel:
  Hello, A!
Invoking delegate byeDel:
  Goodbye, B!
Invoking delegate multiDel:
Hello, C!
  Goodbye, C!
Invoking delegate multiMinusHiDel:
  Goodbye, D!
*/
   
   関連項目
MulticastDelegate
C# プログラミング ガイド イベント

     C# 1.0 以降では、次の例に示すようにデリゲートを宣言できます。
    // Declare a delegate.
delegate void Del(string str);
// Declare a method with the same signature as the delegate.
static void Notify(string name)
{
    Console.WriteLine($"Notification received for: {name}");
}
     // Create an instance of the delegate.
Del del1 = new Del(Notify);
 C# 2.0 では、次の例に示すように、上記の宣言をより簡単に記述できます。
C# 2.0 以降では、次の例に示すように、匿名メソッドを使用してデリゲートの宣言と初期化を行うこともできます。
C# 3.0 以降では、次の例に示すように、ラムダ式を使用してデリゲートの宣言とインスタンス化を行うこともできます。
詳細については、「ラムダ式」を参照してください。
次の例で、デリゲートの宣言、インスタンス化、および使用の方法について説明します。 BookDB クラスにより、書籍のデータ ベースを保持する書店データベースをカプセル化します。 これは、データベース内にあるすべてのペーパーバックを検索し、各ペー パーバックに対してデリゲートを呼び出す ProcessPaperbackBooks メソッドを公開します。使用する delegate 型には
ProcessBookCallback という名前を付けます。 Test クラスでは、このクラスを使用してペーパーバックのタイトルと平均価格を 出力します。
デリゲートを使用することで、書店データベースとクライアント コードの機能を適切に分離しやすくなります。 クライアント コードか らは、書籍の格納方法や書店コードでのペーパーバックの検索方法はわかりません。 書店コードからは、検索後にペーパーバッ クに対して行われる処理はわかりません。
    // C# 2.0 provides a simpler way to declare an instance of Del.
Del del2 = Notify;
     // Instantiate Del by using an anonymous method.
Del del3 = delegate(string name)
    { Console.WriteLine($"Notification received for: {name}"); };
     // Instantiate Del by using a lambda expression.
Del del4 = name =>  { Console.WriteLine($"Notification received for: {name}"); };
     例
デリゲートを宣言し、インスタンス化して使用す
る方法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
     // A set of classes for handling a bookstore:

 // A set of classes for handling a bookstore:
  namespace Bookstore
{
    using System.Collections;
    // Describes a book in the book list:
    public struct Book
    {
public string Title;
public string Author;
public decimal Price;
public bool Paperback;
// Title of the book.
// Author of the book.
// Price of the book.
// Is it paperback?
        public Book(string title, string author, decimal price, bool paperBack)
        {
            Title = title;
            Author = author;
            Price = price;
            Paperback = paperBack;
} }
    // Declare a delegate type for processing a book:
    public delegate void ProcessBookCallback(Book book);
    // Maintains a book database.
    public class BookDB
    {
        // List of all books in the database:
        ArrayList list = new ArrayList();
        // Add a book to the database:
        public void AddBook(string title, string author, decimal price, bool paperBack)
        {
            list.Add(new Book(title, author, price, paperBack));
        }
        // Call a passed-in delegate on each paperback book to process it:
        public void ProcessPaperbackBooks(ProcessBookCallback processBook)
        {
            foreach (Book b in list)
            {
                if (b.Paperback)
                    // Calling the delegate:
                    processBook(b);
} }
// Using the Bookstore classes:
namespace BookTestClient
{
    using Bookstore;
    // Class to total and average prices of books:
    class PriceTotaller
    {
        int countBooks = 0;
        decimal priceBooks = 0.0m;
        internal void AddBookToTotal(Book book)
        {
            countBooks += 1;
            priceBooks += book.Price;
        }
        internal decimal AveragePrice()
        {
} }
return priceBooks / countBooks;
  
return priceBooks / countBooks;
    信頼性の高いプログラミング デリゲートを宣言する。 次のステートメントで、新しいデリゲート型を宣言します。
 } }
// Class to test the book database:
class Test
{
    // Print the title of the book.
    static void PrintTitle(Book b)
    {
true);
} }
bookDB.AddBook("The C Programming Language", "Brian W. Kernighan and Dennis M. Ritchie", 19.95m,
bookDB.AddBook("The Unicode Standard 2.0", "The Unicode Consortium", 39.95m, true);
bookDB.AddBook("The MS-DOS Encyclopedia", "Ray Duncan", 129.95m, false);
bookDB.AddBook("Dogbert's Clues for the Clueless", "Scott Adams", 12.00m, true);
    Console.WriteLine($"
// Execution starts here.
static void Main()
{
{b.Title}");
}
    BookDB bookDB = new BookDB();
    // Initialize the database with some books:
    AddBooks(bookDB);
    // Print all the titles of paperbacks:
    Console.WriteLine("Paperback Book Titles:");
    // Create a new delegate object associated with the static
    // method Test.PrintTitle:
    bookDB.ProcessPaperbackBooks(PrintTitle);
    // Get the average price of a paperback by using
    // a PriceTotaller object:
    PriceTotaller totaller = new PriceTotaller();
    // Create a new delegate object associated with the nonstatic
    // method AddBookToTotal on the object totaller:
    bookDB.ProcessPaperbackBooks(totaller.AddBookToTotal);
    Console.WriteLine("Average Paperback Book Price: ${0:#.##}",
            totaller.AveragePrice());
}
// Initialize the book database with some test books:
static void AddBooks(BookDB bookDB)
{
}
/* Output:
Paperback Book Titles:
   The C Programming Language
   The Unicode Standard 2.0
   Dogbert's Clues for the Clueless
Average Paperback Book Price: $23.97
*/

    各デリゲート型は、引数の数と型、およびデリゲートでカプセル化可能なメソッドの戻り値の型を示します。 引数型また は戻り値型のセットが新しく必要になった場合は、常に新しいデリゲート型を宣言する必要があります。
デリゲートをインスタンス化する。
デリゲート型の宣言後、デリゲート オブジェクトを作成して特定のメソッドに関連付ける必要があります。 先の例では、
次の例に示すように PrintTitle メソッドを ProcessPaperbackBooks メソッドに渡すことでこの操作を行っています。
これにより、静的 メソッド に関連付けられた新しいデリゲート オブジェクトが作成されます。 同様に、 次の例で示すようにオブジェクト の非静的メソッド AddBookToTotal も渡しています。
どちらの場合でも、新しいデリゲートオブジェクトが ProcessPaperbackBooks メソッドに渡されます。
デリゲート オブジェクトは不変であるため、関連付けられているメソッドを、デリゲートの作成後に変更することはできませ
ん。
デリゲートを呼び出す。
デリゲート オブジェクトを作成したら、通常は、そのデリゲートを呼び出す別のコードにデリゲート オブジェクトを渡します。 デリゲート オブジェクトを呼び出すときには、デリゲートに渡す引数を、デリゲート オブジェクト名の後ろにかっこで囲んで付 けます。 デリゲートの呼び出しの例を次に示します。
デリゲートは、この例に示すように同期的に呼び出すことも、 BeginInvoke メソッドおよび EndInvoke メソッドを使用し て非同期的に呼び出すこともできます。
関連項目
C# プログラミング ガイド イベント
デリゲート
    bookDB.ProcessPaperbackBooks(PrintTitle);
  Test.PrintTitle
  totaller
  bookDB.ProcessPaperbackBooks(totaller.AddBookToTotal);
    processBook(b);
    public delegate void ProcessBookCallback(Book book);
 
     配列データ構造体には、同じ型の複数の変数を格納できます。 配列は、要素の型を指定することで宣言します。 配列に任 意の型の要素を格納する場合は、その型として object を指定できます。C#の統一型システムでは、すべての型(定義済 み、ユーザー定義、参照型、および値の型) が、直接または間接的に Object を継承します。
例
次の例では、1 次元配列、多次元配列、およびジャグ配列を作成しています。
   type[] arrayName;
     class TestArraysClass
{
    static void Main()
    {
        // Declare a single-dimensional array of 5 integers.
        int[] array1 = new int[5];
        // Declare and set array element values.
        int[] array2 = new int[] { 1, 3, 5, 7, 9 };
        // Alternative syntax.
        int[] array3 = { 1, 2, 3, 4, 5, 6 };
        // Declare a two dimensional array.
        int[,] multiDimensionalArray1 = new int[2, 3];
        // Declare and set array element values.
        int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };
        // Declare a jagged array.
        int[][] jaggedArray = new int[6][];
        // Set the values of the first array in the jagged array structure.
        jaggedArray[0] = new int[4] { 1, 2, 3, 4 };
    }
}
 配列の概要 配列には、次の特徴があります。
配列は、1 次元、多次元、またはジャグのいずれかになります。 次元数と各次元の長さは、配列インスタンスの作成時に設定されます。 インスタンスの有効期間中にこれらの値を変更す ることはできません。
数値配列要素の既定値はゼロに設定され、参照要素は null に設定されます。 ジャグ配列は配列の配列です。そのため、配列要素は参照型で、 null に初期化されます。
配列には、ゼロから始まるインデックスが付けられます。 n 個の要素を含む配列には、 0 から n-1 までのインデックスが付 けられます。
配列の要素および配列型は、どのような型でもかまいません。
配列型は、抽象基本型 Array から派生した参照型です。 この型は IEnumerable と IEnumerable<T> を実装するの
配列 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
           で、C# のすべての配列で foreach 反復処理を使用できます。 オブジェクトとしての配列
C# の配列は、実際はオブジェクトです。C や C++ の場合のように、単なるアドレス指定可能な連続メモリ領域ではありませ ん。 Array はすべての配列型の抽象基本データ型で、 Array のプロパティとその他のクラス メンバーを使用できます。 この例と しては、Lengthプロパティを使用して、配列の長さを取得します。 numbers 配列の長さ 5 を lengthOfNumbers という変数 に代入するコードは、次のようになります。
Array クラスには、配列の並べ替え、検索、コピーを行うための便利なメソッドやプロパティが他にも多数用意されています。 次 の例では、Rank プロパティを使用して、配列の次元数を表示します。
      int[] numbers = { 1, 2, 3, 4, 5 };
int lengthOfNumbers = numbers.Length;
     class TestArraysClass
{
    static void Main()
    {
        // Declare and initialize an array.
        int[,] theArray = new int[5, 10];
        System.Console.WriteLine("The array has {0} dimensions.", theArray.Rank);
} }
// Output: The array has 2 dimensions.
 関連項目
1 次元配列の使用方法 多次元配列の使用方法 ジャグ配列の使用方法 配列での foreach の使用 引数としての配列の受け渡し 暗黙的に型指定される配列 C# プログラミング ガイド コレクション
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。

     配列要素の型と要素の数を指定する new 演算子を使用して、1 次元配列を作成します。 次の例では、5 つの整数の配列 を宣言しています。
この配列は、 array[0] から array[4] の要素を含んでいます。 配列の要素は、要素型の既定値である整数 0 に初期化 されます。
配列には、次の例のように、文字列の配列を宣言する、指定した要素型を格納できます。
配列の初期化
配列を宣言するときに、配列の要素を初期化することができます。 長さ指定子は、初期化リスト内の要素の数から推論される ため、必要ではありません。 次に例を示します。
次のコードは、配列の各要素が曜日の名前で初期化される文字列配列の宣言を示しています。
次のコードに示すように、宣言時に配列を初期化するときに、 new 式と配列型を回避することができます。 これは、暗黙的に 型指定される配列と呼ばれます。
配列変数は作成しなくても宣言できますが、この変数の新しい配列を割り当てるときは new 演算子を使用する必要がありま す。 次に例を示します。
値の型と参照型の配列 次の配列の宣言を検討してみます。
  int[] array = new int[5];
     string[] stringArray = new string[6];
   int[] array1 = new int[] { 1, 3, 5, 7, 9 };
   string[] weekDays = new string[] { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
     int[] array2 = { 1, 3, 5, 7, 9 };
string[] weekDays2 = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
     int[] array3;
array3 = new int[] { 1, 3, 5, 7, 9 };   // OK
//array3 = {1, 3, 5, 7, 9};   // Error
   SomeType[] array4 = new SomeType[10];
  このステートメントの結果は、 SomeType が値型か参照型かによって決まります。 値型の場合、ステートメントでは、それぞれに
1 次元配列 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      型が含まれる 10 個の要素の配列が作成されます。   が参照型の場合、ステートメントは、それぞれが null 参照に初期化される 10 個の要素の配列を作成します。 両方のインスタンスで、要素は要素型の既定値に初期化され ます。 値の型と参照型の詳細については、値の型と参照型に関するページをご覧ください。
関連項目
Array
配列 多次元配列 ジャグ配列
SomeType
SomeType
  
   配列は 1 つ以上の配列を持つことができます。 たとえば、次の宣言は、4 行と 2 列の 2 次元の配列を作成します。
次の宣言は、4、2、3 の 3 次元配列を作成します。
配列の初期化 次の例に示すように、宣言時に配列を初期化することができます。
  int[,] array = new int[4, 2];
   int[,,] array1 = new int[4, 2, 3];
 多次元配列 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    また、順位を指定せずに配列を初期化することもできます。
初期化せずに配列変数を宣言する場合、 new 演算子を使用して配列を変数に代入する必要があります。 new の使用を 次の例に示します。
次の例では、特定の配列要素に値を代入します。
  int[,] array4 = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
     int[,] array5;
array5 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };   // OK
//array5 = {{1,2}, {3,4}, {5,6}, {7,8}};   // Error
   array5[2, 1] = 25;
 同様に、次の例では、特定の配列要素の値を取得して、それを変数   に代入します。
  // Two-dimensional array.
int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
// The same array with dimensions specified.
int[,] array2Da = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
// A similar array with string elements.
string[,] array2Db = new string[3, 2] { { "one", "two" }, { "three", "four" },
                                        { "five", "six" } };
// Three-dimensional array.
int[,,] array3D = new int[,,] { { { 1, 2, 3 }, { 4, 5, 6 } },
                                 { { 7, 8, 9 }, { 10, 11, 12 } } };
// The same array with dimensions specified.
int[,,] array3Da = new int[2, 2, 3] { { { 1, 2, 3 }, { 4, 5, 6 } },
                                       { { 7, 8, 9 }, { 10, 11, 12 } } };
// Accessing array elements.
System.Console.WriteLine(array2D[0, 0]);
System.Console.WriteLine(array2D[0, 1]);
System.Console.WriteLine(array2D[1, 0]);
System.Console.WriteLine(array2D[1, 1]);
System.Console.WriteLine(array2D[3, 0]);
System.Console.WriteLine(array2Db[1, 0]);
System.Console.WriteLine(array3Da[1, 0, 1]);
System.Console.WriteLine(array3D[1, 1, 2]);
// Getting the total count of elements or the length of a given dimension.
var allLength = array3D.Length;
var total = 1;
for (int i = 0; i < array3D.Rank; i++)
{
    total *= array3D.GetLength(i);
}
System.Console.WriteLine("{0} equals {1}", allLength, total);
// Output:
// 1
// 2
// 3
// 4
// 7
// three
// 8
// 12
// 12 equals 12
 elementValue
 
     次のコード例では、配列要素を既定値に初期化します (ジャグ配列を除く)。
  int[,] array6 = new int[10, 10];
 関連項目
C# プログラミング ガイド 配列
1 次元配列 ジャグ配列
 int elementValue = array5[2, 1];
 
   ジャグ配列は、その要素がサイズが異なる場合がある配列からなる配列です。 ジャグ配列は、"配列の配列" と呼ばれることが あります。 次の例では、ジャグ配列の宣言、初期化、およびアクセスの方法について説明します。
次の 3 つの要素を持つ 1 次元配列の宣言では、それぞれが整数の 1 次元配列になっています。
jaggedArray を使用する前に、その要素を初期化する必要があります。次のように要素を初期化することができます。
各要素は、整数の 1 次元配列です。 最初の要素は 5 つの整数の配列で、2 番目の要素は 4 つの整数の配列であり、3 番目の要素は 2 つの整数の配列です。
初期化子を使って配列の要素に値を格納することもできます。この場合、配列のサイズは不要です。 次に例を示します。
次のように宣言時に配列を初期化することもできます。
次の短い形式を使用できます。 要素の既定の初期化はないので、 new 演算子を要素の初期化から省略することはできませ ん。
ジャグ配列は配列の配列です。そのため、配列要素は参照型で、 null に初期化されます。 これらの例のように配列の各要素にアクセスできます。
  int[][] jaggedArray = new int[3][];
      jaggedArray[0] = new int[5];
jaggedArray[1] = new int[4];
jaggedArray[2] = new int[2];
     jaggedArray[0] = new int[] { 1, 3, 5, 7, 9 };
jaggedArray[1] = new int[] { 0, 2, 4, 6 };
jaggedArray[2] = new int[] { 11, 22 };
     int[][] jaggedArray2 = new int[][]
{
new int[] { 1, 3, 5, 7, 9 },
new int[] { 0, 2, 4, 6 },
new int[] { 11, 22 }
};
     int[][] jaggedArray3 =
{
    new int[] { 1, 3, 5, 7, 9 },
    new int[] { 0, 2, 4, 6 },
    new int[] { 11, 22 }
};
 ジャグ配列 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
   ジャグ配列と多次元配列を混在させることができます。 異なるサイズの 3 つの 2 次元の配列要素を含む 1 次元のジャグ配列 の宣言と初期化を次に示します。 詳細については、「多次元配列」を参照してください。
この例に示すように個々の要素にアクセスすることができます。この場合、最初の配列の要素 [1,0] の値(値 5)が表示さ れます。
メソッド Length は、ジャグ配列に含まれる配列の数を返します。たとえば、前の配列を宣言し、次のコマンドラインを実行し たとします。
この場合は値 3 が返されます。
例
この例では、要素自体が配列である配列を構築します。 配列の要素のそれぞれのサイズが異なります。
    int[][,] jaggedArray4 = new int[3][,]
{
    new int[,] { {1,3}, {5,7} },
    new int[,] { {0,2}, {4,6}, {8,10} },
    new int[,] { {11,22}, {99,88}, {0,9} }
};
   System.Console.Write("{0}", jaggedArray4[0][1, 0]);
    System.Console.WriteLine(jaggedArray4.Length);
    // Assign 77 to the second element ([1]) of the first array ([0]):
jaggedArray3[0][1] = 77;
// Assign 88 to the second element ([1]) of the third array ([2]):
jaggedArray3[2][1] = 88;
 
     関連項目
Array
C# プログラミング ガイド 配列
1 次元配列 多次元配列
   class ArrayTest
{
    static void Main()
    {
} }
// Declare the array of two elements.
int[][] arr = new int[2][];
// Initialize the elements.
arr[0] = new int[5] { 1, 3, 5, 7, 9 };
arr[1] = new int[4] { 2, 4, 6, 8 };
// Display the array elements.
for (int i = 0; i < arr.Length; i++)
{
    System.Console.Write("Element({0}): ", i);
    for (int j = 0; j < arr[i].Length; j++)
    {
        System.Console.Write("{0}{1}", arr[i][j], j == (arr[i].Length - 1) ? "" : " ");
    }
    System.Console.WriteLine();
}
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
/* Output:
    Element(0): 1 3 5 7 9
    Element(1): 2 4 6 8
*/
 
        foreach ステートメントでは、配列の要素の反復処理を、簡単かつ安全に行うことができます。
1 次元配列の場合、 foreach ステートメントは、インデックス 0 から始まりインデックス Length - 1 で終わるインデックスの昇
順で要素を処理します。
多次元配列の場合、右端の次元のインデックスが最初に加算されていき、次にその左の次元、またその左、というような方法 で各要素がトラバースされます。
      int[] numbers = { 4, 5, 6, 1, 2, 3, -2, -1, 0 };
foreach (int i in numbers)
{
    System.Console.Write("{0} ", i);
}
// Output: 4 5 6 1 2 3 -2 -1 0
     int[,] numbers2D = new int[3, 2] { { 9, 99 }, { 3, 33 }, { 5, 55 } };
// Or use the short form:
// int[,] numbers2D = { { 9, 99 }, { 3, 33 }, { 5, 55 } };
foreach (int i in numbers2D)
{
    System.Console.Write("{0} ", i);
}
// Output: 9 99 3 33 5 55
 ただし、多次元配列では、入れ子になった for ループを使用した方が、配列要素を処理する順序をより厳密に制御できま す。
関連項目
Array
C# プログラミング ガイド 配列
1 次元配列 多次元配列 ジャグ配列
配列での foreach の使用 (C# プログラミング ガ
イド)
2020/11/02 • • Edit Online
 
   配列は、引数としてメソッド パラメーターに渡すことができます。 配列は参照型であるため、メソッドは要素の値を変更できま す。
1 次元配列を引数として渡す
初期化された 1 次元配列をメソッドに渡すことができます。 たとえば、次のステートメントは、配列を print メソッドに送信しま
す。
次のコードは、print メソッドの実装の一部を示しています。
次の例に示すように、一度に新しい配列を初期化して渡すことができます。
例
次の例では、文字列の配列が初期化され、引数として文字列の DisplayArray メソッドに渡されます。このメソッドは、配列 の要素を表示します。 次に、 ChangeArray メソッドで配列の要素を反転させた後、 ChangeArrayElements メソッドで配列の 最初の3つの要素を変更します。各メソッドから戻った後、DisplayArray メソッドで、配列を値で渡すと配列要素の変更が 禁止されないことを示します。
    int[] theArray = { 1, 3, 5, 7, 9 };
PrintArray(theArray);
     void PrintArray(int[] arr)
{
    // Method code.
}
   PrintArray(new int[] { 1, 3, 5, 7, 9 });
     引数としての配列の受け渡し (C# プログラミン
グ ガイド) 2020/11/02 • • Edit Online
 
    多次元配列を引数として渡す
1 次元配列を渡すのと同じ方法で、初期化された多次元配列をメソッドに渡します。
次のコードに、2 次元配列を引数として受け取る print メソッドの宣言の一部を示します。
    int[,] theArray = { { 1, 2 }, { 2, 3 }, { 3, 4 } };
Print2DArray(theArray);
     void Print2DArray(int[,] arr)
{
    // Method code.
}
   using System;
class ArrayExample
{
    static void DisplayArray(string[] arr) => Console.WriteLine(string.Join(" ", arr));
    // Change the array by reversing its elements.
    static void ChangeArray(string[] arr) => Array.Reverse(arr);
    static void ChangeArrayElements(string[] arr)
    {
        // Change the value of the first three array elements.
        arr[0] = "Mon";
        arr[1] = "Wed";
        arr[2] = "Fri";
}
    static void Main()
    {
} }
// Declare and initialize an array.
string[] weekDays = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
// Display the array elements.
DisplayArray(weekDays);
Console.WriteLine();
// Reverse the array.
ChangeArray(weekDays);
// Display the array again to verify that it stays reversed.
Console.WriteLine("Array weekDays after the call to ChangeArray:");
DisplayArray(weekDays);
Console.WriteLine();
// Assign new values to individual array elements.
ChangeArrayElements(weekDays);
// Display the array again to verify that it has changed.
Console.WriteLine("Array weekDays after the call to ChangeArrayElements:");
DisplayArray(weekDays);
// The example displays the following output:
//         Sun Mon Tue Wed Thu Fri Sat
//
//        Array weekDays after the call to ChangeArray:
//        Sat Fri Thu Wed Tue Mon Sun
//
//        Array weekDays after the call to ChangeArrayElements:
//        Mon Wed Fri Wed Tue Mon Sun

     次の例に示すように、一度に新しい配列を初期化して渡すことができます。
  Print2DArray(new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } });
 例
次の例では、整数の2次元配列が初期化され、Print2DArray メソッドに渡されます。このメソッドは、配列の要素を表示し ます。
     class ArrayClass2D
{
    static void Print2DArray(int[,] arr)
    {
        // Display the array elements.
        for (int i = 0; i < arr.GetLength(0); i++)
        {
} }
} }
for (int j = 0; j < arr.GetLength(1); j++)
{
    System.Console.WriteLine("Element({0},{1})={2}", i, j, arr[i, j]);
}
static void Main()
{
// Pass the array as an argument.
Print2DArray(new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } });
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
/* Output:
    Element(0,0)=1
    Element(0,1)=2
    Element(1,0)=3
    Element(1,1)=4
    Element(2,0)=5
    Element(2,1)=6
    Element(3,0)=7
    Element(3,1)=8
*/
 関連項目
C# プログラミング ガイド 配列
1 次元配列 多次元配列 ジャグ配列

     配列インスタンスの型が、配列初期化子で指定された要素から推論される暗黙的に型指定された配列を作成できます。 暗 黙的に型指定された変数の規則は、暗黙的に型指定された配列にも適用されます。 詳細については、「暗黙的に型指定さ れるローカル変数」を参照してください。
暗黙的に型指定された配列は通常、匿名型、オブジェクト、コレクション初期化子と共にクエリ式で使用されます。 次の例では、暗黙的に型指定された配列を作成する方法を示します。
    class ImplicitlyTypedArraySample
{
    static void Main()
    {
} }
var a = new[] { 1, 10, 100, 1000 }; // int[]
var b = new[] { "hello", null, "world" }; // string[]
// single-dimension jagged array
var c = new[]
{
    new[]{1,2,3,4},
    new[]{5,6,7,8}
};
// jagged array of strings
var d = new[]
{
    new[]{"Luca", "Mads", "Luke", "Dinesh"},
    new[]{"Karen", "Suma", "Frances"}
};
 前の例で、暗黙的に型指定された配列では、初期化ステートメントの左側では角かっこが使用されていないことに注意してくだ さい。 また、ジャグ配列は、1 次元の配列と同じように new [] を使用して初期化されます。
オブジェクト初期化子で暗黙的に型指定された配列
配列を含む匿名型を作成するときには、型のオブジェクトの初期化子で配列を暗黙的に型指定する必要があります。 次の例 では、 contacts は、匿名型の暗黙的に型指定された配列で、それぞれが PhoneNumbers という名前の配列を含んでいま す。 var キーワードは、オブジェクト初期化子内で使用されないことに注意してください。
    暗黙的に型指定される配列 (C# プログラミング
ガイド) 2020/11/02 • • Edit Online
    var contacts = new[]
{
    new {
        Name = " Eugene Zabokritski",
        PhoneNumbers = new[] { "206-555-0108", "425-555-0001" }
}, new {
        Name = " Hanying Feng",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
 
     関連項目
C# プログラミング ガイド 暗黙的に型指定されるローカル変数
配列
匿名型 オブジェクト初期化子とコレクション初期化子 var
C# での LINQ

    文字列は、値がテキストの String 型のオブジェクトです。 内部では、テキストは Char オブジェクトの順次読み取り専用コレク ションとして格納されます。 C# の文字列の末尾には null 終端文字はありません。したがって、C# の文字列には任意の数の null 文字 ('\0') を埋め込むことができます。 文字列の Length プロパティは、Unicode 文字の数ではなく、文字列に含まれて いる Char オブジェクトの数を表します。文字列内の個別のUnicodeコードポイントにアクセスするには、StringInfoオブジェ クトを使用します。
文字列と System.String
C# では、 string キーワードは String のエイリアスです。 したがって、 String と string は等価であり、どちらの名前付け 規則を使用してもかまいません。 String クラスは、文字列を安全に作成、操作、比較するためのさまざまなメソッドを提供し ます。 また、C# 言語は、一般的な文字列操作を簡略化するためにいくつかの演算子をオーバーロードします。 キーワードの 詳細については、「string」を参照してください。 型およびメソッドの詳細については、「String」を参照してください。
文字列の宣言と初期化 次の例に示すように、文字列はさまざまな方法で宣言および初期化できます。
        // Declare without initializing.
string message1;
// Initialize to null.
string message2 = null;
// Initialize as an empty string.
// Use the Empty constant instead of the literal "".
string message3 = System.String.Empty;
// Initialize with a regular string literal.
string oldPath = "c:\\Program Files\\Microsoft Visual Studio 8.0";
// Initialize with a verbatim string literal.
string newPath = @"c:\Program Files\Microsoft Visual Studio 9.0";
// Use System.String if you prefer.
System.String greeting = "Hello World!";
// In local variables (i.e. within a method body)
// you can use implicit typing.
var temp = "I'm still a strongly-typed System.String!";
// Use a const string to prevent 'message4' from
// being used to store another string value.
const string message4 = "You can't get rid of me!";
// Use the String constructor only when creating
// a string from a char*, char[], or sbyte*. See
// System.String documentation for details.
char[] letters = { 'A', 'B', 'C' };
string alphabet = new string(letters);
 文字列を文字の配列で初期化する場合を除き、文字列オブジェクトの作成に new 演算子を使用しないでください。 文字列の長さが 0 の新しい String オブジェクトを作成するには、Empty 定数値で文字列を初期化します。 長さ 0 の文字列
文字列 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     のリテラル文字列表現は "" です。 null の代わりに Empty 値を使用して文字列を初期化すると、NullReferenceException が発生する可能性を減らすことができます。 静的な IsNullOrEmpty(String) メソッドを使用すると、アクセスを試行する前に 文字列の値を検証できます。
文字列オブジェクトの不変性
文字列オブジェクトは変更不可です。つまり、作成した文字列オブジェクトは変更できません。 文字列を変更するように見える StringメソッドとC#演算子はすべて、実際には新しい文字列オブジェクトで結果を返します。次の例では、s1 と s2 の内 容を連結して1つの文字列を形成するときに、2つの元の文字列は変更されません。 += 演算子で、連結した内容を含む 新しい文字列が作成されます。 新しいオブジェクトは変数 s1 に代入され、 s1 に代入された元のオブジェクトはガベージ コレ クションに対して解放されます。これは、他の変数がこのオブジェクトへの参照を保持していないためです。
    string s1 = "A string is more ";
string s2 = "than the sum of its chars.";
// Concatenate s1 and s2. This actually creates a new
// string object and stores it in s1, releasing the
// reference to the original object.
s1 += s2;
System.Console.WriteLine(s1);
// Output: A string is more than the sum of its chars.
 文字列の "変更" では、実際には文字列が新しく作成されるため、文字列への参照を作成するときには注意が必要です。 文 字列の参照を作成し、元の文字列を "変更" する場合、参照は文字列が変更されたときに作成された新しいオブジェクトでは なく、元のオブジェクトを指したままになります。 この動作を表すコードの例を次に示します。
元の文字列での検索操作や置換操作などの変更に基づく新しい文字列を作成する方法の詳細については、文字列の内容 を変更する方法に関する記事をご覧ください。
標準リテラル文字列と逐語的リテラル文字列
次の例に示すように、C# で提供されるエスケープ文字を埋め込む必要がある場合は、標準リテラル文字列を使用します。
    string s1 = "Hello ";
string s2 = s1;
s1 += "World";
System.Console.WriteLine(s2);
//Output: Hello
     string columns = "Column 1\tColumn 2\tColumn 3";
//Output: Column 1        Column 2        Column 3
string rows = "Row 1\r\nRow 2\r\nRow 3";
/* Output:
  Row 1
  Row 2
  Row 3
*/
string title = "\"The \u00C6olean Harp\", by Samuel Taylor Coleridge";
//Output: "The Æolean Harp", by Samuel Taylor Coleridge
 文字列テキストに円記号が含まれる場合 (ファイル パスなど) は、使いやすさと読みやすさを考慮して、逐語的文字列を使用 します。 逐語的文字列は、文字列テキストの一部として改行文字を保持するため、複数行文字列の初期化に使用できま す。 引用符を逐語的文字列に埋め込むには、二重引用符を使用します。 逐語的文字列の一般的な使用方法の例を次

 に示します。
    string filePath = @"C:\Users\scoleridge\Documents\";
//Output: C:\Users\scoleridge\Documents\
string text = @"My pensive SARA ! thy soft cheek reclined
    Thus on mine arm, most soothing sweet it is
    To sit beside our Cot,...";
/* Output:
My pensive SARA ! thy soft cheek reclined
   Thus on mine arm, most soothing sweet it is
   To sit beside our Cot,...
*/
string quote = @"Her name was ""Sara.""";
//Output: Her name was "Sara."
 文字列のエスケープ シーケンス
\' 単一引用符 \" 二重引用符 \\ 円記号
\0 Null
\a 警告
\b バックスペース
\f フォーム フィード \n 改行
\r キャリッジ リターン \t 水平タブ
\v 垂直タブ
UNICODE
0x0027 0x0022 0x005C 0x0000 0x0007 0x0008 0x000C 0x000A 0x000D 0x0009 0x000B
                                                                    \u
  Unicode エスケープ シーケンス (UTF-16)
    \uHHHH
  \u00E7
 (範囲:0000 - FFFF; 例: = "ç")
   \U
  Unicode エスケープ シーケンス (UTF-32)
   (範囲:000000 - 10FFFF; 例: = "􏰀")
\U00HHHHHH
 \U0001F47D
    \x
   可変長である点を除き "\u" に類似した Unicode エスケープ シーケンス
    \xH[H][H][H]
(範囲:0 - FFFF; 例:
、 \x0E7 、または \xE7 = "ç")
 \x00E7
 
          NOTE
コンパイル時に、逐語的文字列はエスケープ シーケンスと同様に通常の文字列に変換されます。 したがって、逐語的文字列をデバッガーの ウォッチ ウィンドウで表示すると、ソース コードの逐語的バージョンではなく、コンパイラが追加したエスケープ文字が表示されます。 たとえば、 逐語的文字列 @"C:\files.txt" は、ウォッチ ウィンドウでは "C:\\files.txt" と表示されます。
  書式指定文字列
書式指定文字列は、その内容が実行時に動的に決定される文字列です。 書式指定文字列を作成するには、文字列内の 中かっこの内側に "挿入式" かプレースホルダーを埋め込みます。 中かっこ ( {...} ) 内にあるものはすべて値に解決され、実 行時に書式設定された文字列として出力されます。 書式指定文字列を作成するには、文字列補間と複合書式設定の 2 つの方法があります。
文字列補間
C#6.0以降で使用できる"補間文字列"は、特殊文字 $ によって識別され、中かっこ内に挿入式を含みます。文字列補
間を初めて使用する場合は、簡単な概要として「文字列補間 - C# の対話形式チュートリアル」をご覧ください。 文字列補間を使ってコードの読みやすさと保守性を向上させます。文字列補間がもたらす結果は String.Format メソッドと
同じですが、使いやすさとインラインのわかりやすさが向上します。
     var jh = (firstName: "Jupiter", lastName: "Hammon", born: 1711, published: 1761);
Console.WriteLine($"{jh.firstName} {jh.lastName} was an African American poet born in {jh.born}.");
Console.WriteLine($"He was first published in {jh.published} at the age of {jh.published - jh.born}.");
Console.WriteLine($"He'd be over {Math.Round((2018d - jh.born) / 100d) * 100d} years old today.");
// Output:
// Jupiter Hammon was an African American poet born in 1711.
// He was first published in 1761 at the age of 50.
// He'd be over 300 years old today.
 複合書式指定
String.Format では、中かっこ内のプレースホルダーを使って書式指定文字列を作成します。 この例では、上で使用した文字 列補間の方法と同様の出力が生じます。
    var pw = (firstName: "Phillis", lastName: "Wheatley", born: 1753, published: 1773);
Console.WriteLine("{0} {1} was an African American poet born in {2}.", pw.firstName, pw.lastName, pw.born);
Console.WriteLine("She was first published in {0} at the age of {1}.", pw.published, pw.published -
pw.born);
Console.WriteLine("She'd be over {0} years old today.", Math.Round((2018d - pw.born) / 100d) * 100d);
// Output:
// Phillis Wheatley was an African American poet born in 1753.
// She was first published in 1773 at the age of 20.
// She'd be over 300 years old today.
 .NET 型の書式設定について詳しくは、「.NET での型の書式設定」をご覧ください。
   WARNING
\x のエスケープ シーケンスを使用していて、指定している 16 進数が 4 桁未満である場合に、エスケープ シーケンスの直後の文字が有 効な 16 進数 (0-9、A-F、a-f) であると、それらはエスケープ シーケンスの一部として解釈されます。 たとえば、 \xA1 はコード ポイント U+00A1 の "¡" を生成します。 ただし、次の文字が "A" または "a" である場合、エスケープ シーケンスは代わりに \xA1A であると解釈さ れ、コード ポイント U+0A1A の " " を生成します。 そのような場合、4 桁の 16 進数すべてを指定する (例: \x00A1 ) と、誤って解釈さ れる可能性がすべて排除されます。
  
            部分文字列
部分文字列は、1 つの文字列に含まれる一連の文字です。 元の文字列の一部から新しい文字列を作成するに は、Substring メソッドを使用します。 IndexOf メソッドを使用して、1 つまたは複数の部分文字列を検索できます。 指定さ れたすべての部分文字列を新しい文字列に置換するには、Replace メソッドを使用します。 Substring メソッドと同様 に、Replace は実際に新しい文字列を返し、元の文字列は変更しません。 詳細については、「文字列を検索する方法」と文 字列の内容を変更する方法に関する記事をご覧ください。
    string s3 = "Visual C# Express";
System.Console.WriteLine(s3.Substring(7, 2));
// Output: "C#"
System.Console.WriteLine(s3.Replace("C#", "Basic"));
// Output: "Visual Basic Express"
// Index values are zero-based
int index = s3.IndexOf("C");
// index = 7
 各文字へのアクセス 次の例に示すように、配列表記とインデックス値を使用すると、それぞれの文字への読み取り専用アクセスが可能になります。
String メソッドが、文字列内の個別の文字を変更する必要がある機能を提供していない場合は、StringBuilder オブジェクト を使用して個別の文字の "埋め込み先" を変更し、StringBuilder メソッドを使用することで、結果を格納する新しい文字列 を作成できます。 次の例では、特定の方法で元の文字列を変更し、将来使用するためにその結果を保存する必要があるとし ます。
    string s5 = "Printing backwards";
for (int i = 0; i < s5.Length; i++)
{
    System.Console.Write(s5[s5.Length - i - 1]);
}
// Output: "sdrawkcab gnitnirP"
     string question = "hOW DOES mICROSOFT wORD DEAL WITH THE cAPS lOCK KEY?";
System.Text.StringBuilder sb = new System.Text.StringBuilder(question);
for (int j = 0; j < sb.Length; j++)
{
    if (System.Char.IsLower(sb[j]) == true)
        sb[j] = System.Char.ToUpper(sb[j]);
    else if (System.Char.IsUpper(sb[j]) == true)
        sb[j] = System.Char.ToLower(sb[j]);
}
// Store the new string.
string corrected = sb.ToString();
System.Console.WriteLine(corrected);
// Output: How does Microsoft Word deal with the Caps Lock key?
 null 文字列と空の文字列
空の文字列はゼロ文字を含む System.String オブジェクトのインスタンスです。 空の文字列は、空のテキスト フィールドを表す ため、さまざまなプログラミング シナリオでよく使用されます。 有効な System.String オブジェクトであるため、空の文字列でメ ソッドを呼び出すことができます。 空の文字列は、次のように初期化されます。

       これに対し、null 文字列は System.String オブジェクトのインスタンスを参照しないので、null 文字列でメソッドを呼び出そうと すると NullReferenceException が発生します。 しかし、null 文字列を他の文字列に連結したり、他の文字列と比較するこ とは可能です。 次に、null 文字列の参照によって例外がスローされる場合とされない場合の例を示します。
    static void Main()
{
    string str = "hello";
    string nullStr = null;
    string emptyStr = String.Empty;
    string tempStr = str + nullStr;
    // Output of the following line: hello
    Console.WriteLine(tempStr);
    bool b = (emptyStr == nullStr);
    // Output of the following line: False
    Console.WriteLine(b);
    // The following line creates a new empty string.
    string newStr = emptyStr + nullStr;
    // Null strings and empty strings behave differently. The following
    // two lines display 0.
    Console.WriteLine(emptyStr.Length);
    Console.WriteLine(newStr.Length);
    // The following line raises a NullReferenceException.
    //Console.WriteLine(nullStr.Length);
    // The null character can be displayed and counted, like other chars.
    string s1 = "\x0" + "abc";
    string s2 = "abc" + "\x0";
    // Output of the following line: * abc*
    Console.WriteLine("*" + s1 + "*");
    // Output of the following line: *abc *
    Console.WriteLine("*" + s2 + "*");
    // Output of the following line: 4
    Console.WriteLine(s2.Length);
}
 文字列を迅速に作成するための StringBuilder の使用
.NET での文字列操作は高度に最適化されており、ほとんどの場合パフォーマンスに大きく影響することはありません。 ただし、 短いループが数百回または数千回実行されている場合など、シナリオによっては文字列操作がパフォーマンスに影響する可能 性があります。 StringBuilder クラスが作成する文字列バッファーにより、プログラムで大量の文字列操作を実行する場合のパ フォーマンスが向上します。 StringBuilder 文字列を使用すると、組み込み文字列データ型ではサポートされていない個別の 文字を再割り当てできます。 たとえば、このコードでは、新しい文字列を作成せずに、文字列の内容を変更します。
    System.Text.StringBuilder sb = new System.Text.StringBuilder("Rat: the ideal pet");
sb[0] = 'C';
System.Console.WriteLine(sb.ToString());
System.Console.ReadLine();
//Outputs Cat: the ideal pet
 この例では、StringBuilder オブジェクトを使用して、複数の数値型から 1 つの文字列を作成します。
 string s = String.Empty;
 
               文字列、拡張メソッド、LINQ
String 型は、IEnumerable<T> を実装するので、文字列には Enumerable クラスで定義した拡張メソッドを使用できます。 見やすさを考慮して、これらのメソッドは String 型の IntelliSense からは除外されていますが、使用できます。 文字列で LINQ クエリ式を使用することもできます。 詳細については、「LINQ と文字列」を参照してください。
関連トピック
文字列の内容を変更する方法 文字列を比較する方法 複数の文字列を連結する方法
文字列を検索する方法
文字列が数値を表しているかどうかを確認する方法
文字列補間
基本的な文字列操作
文字列の変換および文字列の内容を変更する手法を示します。 文字列の序数とカルチャ固有の比較を実行する方法を示します。 複数の文字列を 1 つに結合するさまざまな方法を示します。
特定のテキストまたは文字列のパターンの検索を使用する方法につ いて説明します。
文字列を安全に解析して、有効な数値があるかどうかを確認する方 法を示します。
書式指定文字列に便利な構文を提供する文字列補間機能につい て説明します。
System.String メソッドおよび System.Text.StringBuilder メソッドを 使用し文字列の基本操作を実行する、トピックへのリンクがあります。
               String.Split を使用して文字列を解析する方法
    String.Split メソッドを使用して文字列を解析するコード例を 紹介します。
                  using System;
using System.Text;
namespace CSRefStrings
{
    class TestStringBuilder
    {
} }
static void Main()
{
    var sb = new StringBuilder();
    // Create a string composed of numbers 0 - 9
    for (int i = 0; i < 10; i++)
    {
        sb.Append(i.ToString());
    }
    Console.WriteLine(sb);  // displays 0123456789
    // Copy one character of the string (not possible with a System.String)
    sb[0] = sb[9];
    Console.WriteLine(sb);  // displays 9123456789
    Console.WriteLine();
}
 
             文字列の解析
.NET での日付と時刻文字列の解析
文字列の比較
StringBuilder クラスの使用
LINQ と文字列
C# プログラミング ガイド
.NET の基本データ型の文字列形式を対応する型のインスタンスに変 換する方法について説明します。
"01/24/2008" などの文字列を、System.DateTime オブジェクトに 変換する方法を示します。
文字列を比較する方法について説明し、C# および Visual Basic で の例を示します。
StringBuilder クラスの動的な文字列オブジェクトを作成および変更 する方法について説明します。
LINQ クエリを使用してさまざまな文字列操作を実行する方法につ いて説明します。
C# のプログラミング要素について説明するトピックへのリンクを示しま す。
                      
      文字列が指定された数値型の有効な表現であるかどうかを確認するには、静的 TryParse メソッドを使用します。このメソッ ドには、すべてのプリミティブ数値型が実装されており、また DateTime、IPAddress などの型も実装されています。 次の例で は、"108" が有効な int かどうかを確認する方法を示します。
文字列が数値以外の文字、または指定した型で表すには大きすぎる(または小さすぎる)数値の場合、TryParse はfalse を返し、out パラメーターを 0 に設定します。 それ以外の場合は true を返し、out パラメーターを文字列の数値に設定しま す。
例
次の例では、 long 値、 byte 値、および decimal 値の文字列表現を指定して TryParse を使用する方法を示します。
    int i = 0;
string s = "108";
bool result = int.TryParse(s, out i); //i now = 108
      NOTE
文字列が数値文字列だけを含んでいても、使用する TryParse メソッドの型として有効ではない場合があります。 たとえば、"256" は byte の有効値ではありませんが、 int としては有効です。 " 98.6" は int の有効値ではありませんが、有効な decimal です。
         string numString = "1287543"; //"1287543.0" will return false for a long
long number1 = 0;
bool canConvert = long.TryParse(numString, out number1);
if (canConvert == true)
  Console.WriteLine("number1 now = {0}", number1);
else
  Console.WriteLine("numString is not a valid long");
byte number2 = 0;
numString = "255"; // A value of 256 will return false
canConvert = byte.TryParse(numString, out number2);
if (canConvert == true)
  Console.WriteLine("number2 now = {0}", number2);
else
  Console.WriteLine("numString is not a valid byte");
decimal number3 = 0;
numString = "27.3"; //"27" is also a valid decimal
canConvert = decimal.TryParse(numString, out number3);
if (canConvert == true)
  Console.WriteLine("number3 now = {0}", number3);
else
  Console.WriteLine("number3 is not a valid decimal");
 信頼性の高いプログラミング
文字列が数値を表しているかどうかを確認する方
法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      プリミティブ数値型は、 Parse 静的メソッドも実装します。このメソッドは、文字列が有効な数値でない場合は例外をスローし ます。一般に、数値が有効でない場合は単にfalseを返す TryParse の方が効率的です。
.NET セキュリティ
テキストボックス、コンボボックスなどのコントロールからのユーザー入力を検証するには、常に TryParse メソッドまたは Parse
メソッドを使用してください。 関連項目
バイト配列を int に変換する方法 文字列を数値に変換する方法
16 進文字列と数値型の間で変換する方法 数値文字列の解析
型の書式設定
  
     インデクサーを使用すると、配列と同じようにクラスまたは構造体のインスタンスにインデックスを作成することができます。 インデッ クス値は、型またはインスタンス メンバーの明示的な指定なしで設定または取得できます。 インデクサーはプロパティと似ていま すが、そのアクセサーがパラメーターを取る点が異なります。
次の例は、値の割り当てと取得を行う単純な get アクセサー メソッドと set アクセサー メソッドを持つジェネリック クラスを定義し ます。 Program クラスは、文字列の格納用にこのクラスのインスタンスを作成します。
     using System;
class SampleCollection<T>
{
   // Declare an array to store the data elements.
   private T[] arr = new T[100];
   // Define the indexer to allow client code to use [] notation.
   public T this[int i]
   {
      get { return arr[i]; }
      set { arr[i] = value; }
   }
}
class Program
{
   static void Main()
   {
      var stringCollection = new SampleCollection<string>();
      stringCollection[0] = "Hello, World";
      Console.WriteLine(stringCollection[0]);
} }
// The example displays the following output:
//       Hello, World.
     NOTE
その他の例については、「関連セクション」を参照してください。
 式の本文の定義
通常は、インデクサーの get または set アクセサーは、値を返すか値を設定する単一のステートメントで構成します。 式の本文 のメンバーは、このシナリオをサポートする簡略化された構文を提供します。 C# 6 以降、読み取り専用インデクサーは、次の例 のように、式の本文のメンバーとして実装することができます。
インデクサー (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
  式の本文は => で導入され、 get キーワードは使用されないことに注意してください。
C#7.0以降、getアクセサーとsetアクセサーのどちらも、式の本文のメンバーとして実装できます。この場合、get キーワード と set キーワードの両方を使用する必要があります。次に例を示します。
    using System;
class SampleCollection<T>
{
   // Declare an array to store the data elements.
   private T[] arr = new T[100];
   // Define the indexer to allow client code to use [] notation.
   public T this[int i]
   {
      get => arr[i];
      set => arr[i] = value;
   }
}
class Program
{
   static void Main()
   {
      var stringCollection = new SampleCollection<string>();
      stringCollection[0] = "Hello, World.";
      Console.WriteLine(stringCollection[0]);
} }
// The example displays the following output:
//       Hello, World.
    using System;
class SampleCollection<T>
{
   // Declare an array to store the data elements.
   private T[] arr = new T[100];
   int nextIndex = 0;
   // Define the indexer to allow client code to use [] notation.
   public T this[int i] => arr[i];
   public void Add(T value)
   {
      if (nextIndex >= arr.Length)
         throw new IndexOutOfRangeException($"The collection can hold only {arr.Length} elements.");
      arr[nextIndex++] = value;
   }
}
class Program
{
   static void Main()
   {
      var stringCollection = new SampleCollection<string>();
      stringCollection.Add("Hello, World");
      System.Console.WriteLine(stringCollection[0]);
} }
// The example displays the following output:
//       Hello, World.
 
         インデクサーの概要 インデクサーを使用すると、配列と同じようにオブジェクトにインデックスを作成することができます。
get アクセサーは値を返します。 set アクセサーは値を割り当てます。 this キーワードは、インデクサーの定義に使用されます。
set アクセサーで割り当てる値はvalueキーワードを使用して定義します。 インデクサーは、整数値でインデックスを指定する必要はありません。個々の検索メカニズムの定義方法によります。 インデクサーはオーバーロードすることができます。
インデクサーには、2 次元配列にアクセスする場合など、複数の仮パラメーターを指定できます。
関連セクション
インデクサーの使用 インターフェイスのインデクサー プロパティとインデクサーの比較 アクセサーのアクセシビリティの制限
C# 言語仕様
詳細については、「C# 言語の仕様」の「インデクサー」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性
のある情報源です。 関連項目
C# プログラミング ガイド プロパティ

           インデクサーによって構文上の利便性がもたらされます。これを使用すると、クラス、構造体、またはインターフェイスを作成でき、 クライアントアプリケーションから配列と同じようにアクセスできます。コンパイラによって、Item プロパティ(また は、IndexerNameAttribute が存在する場合は別の名前が付けられたプロパティ) と、適切なアクセサー メソッドが生成されま す。 インデクサーは、内部コレクションまたは配列をカプセル化することが主な目的である型で最も多く実装されます。 たとえば、 24時間のうちの異なる10回の時刻で記録した温度を華氏で表す TempRecord クラスがあるとします。このクラスには、温度 値を格納する 型の配列 temps が含まれています。このクラスにインデクサーを実装することで、クライアントは、
ではなく float temp = tempRecord[4] として TempRecord インスタンスの温度にアク セスできます。 インデクサー表記を使用すると、クライアント アプリケーションの構文が簡略化されるだけでなく、クラスとその目的
が、他の開発者たちにとってわかりやすい、より直感的なものとなります。 クラスまたは構造体でインデクサーを宣言するには、次の例のように this キーワードを使用します。
  float[]
   float temp = tempRecord.temps[4]
    // Indexer declaration
public int this[int index]
{
    // get and set accessors
}
     IMPORTANT
インデクサーを宣言すると、オブジェクト上に Item という名前のプロパティが自動的に生成されます。 Item プロパティは、インスタンス のメンバー アクセス式から直接アクセスすることはできません。 また、インデクサーを使用して独自の Item プロパティをオブジェクトに追加 すると、CS0102 コンパイラエラーが発生します。 このエラーを回避するには、以下で説明するように、IndexerNameAttribute を使用して インデクサーの名前を変更します。
 Remarks
インデクサーの型とそのパラメーターの型は、少なくとも、インデクサー自体と同程度にアクセス可能である必要があります。 アクセ シビリティ レベルの詳細については、「アクセス修飾子 (C# リファレンス)」を参照してください。
インターフェイスでインデクサーを使用する方法の詳細については、「インターフェイスのインデクサー (C# プログラミング ガイド)」を 参照してください。
インデクサーのシグネチャは、その仮パラメーターの数と型で構成されます。 これには、インデクサーの型や仮パラメーターの名前 は含まれません。 同じクラス内に複数のインデクサーを宣言する場合は、異なるシグネチャが必要です。
インデクサーの値は変数として分類されないため、インデクサーの値を ref や out パラメーターとして渡すことはできません。
他の言語が使用できる名前をインデクサーに指定するには、次の例のように System.Runtime.CompilerServices.IndexerNameAttribute を使用します。
    // Indexer declaration
[System.Runtime.CompilerServices.IndexerName("TheItem")]
public int this[int index]
{
    // get and set accessors
}
 インデクサーの使用 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 インデクサー名属性によってオーバーライドされるため、このインデクサーの名前は   になります。 既定では、インデク サーの名前は Item です。
例1
次の例は、プライベートな配列フィールド temps とインデクサーの宣言方法を示しています。インデクサーを使用すれば、イン スタンス に直接アクセスできます。 インデクサーを使用しない場合は、配列を public メンバーとして宣言し、 そのメンバー に直接アクセスします。
 tempRecord[i]
 tempRecord.temps[i]
    public class TempRecord
{
    // Array of temperature values
    float[] temps = new float[10]
    {
        56.2F, 56.7F, 56.5F, 56.9F, 58.8F,
        61.3F, 65.9F, 62.1F, 59.2F, 57.5F
    };
    // To enable client code to validate input
    // when accessing your indexer.
    public int Length => temps.Length;
    // Indexer declaration.
    // If index is out of range, the temps array will throw the exception.
    public float this[int index]
    {
        get => temps[index];
        set => temps[index] = value;
    }
}
  Console.Write ステートメントなどでインデクサーのアクセスが評価されると、getアクセサーが呼び出されることに注意してくださ い。 したがって、 get アクセサーが存在しない場合は、コンパイル時エラーが発生します。
 TheItem
 
  他の値を使用したインデックス作成
C# では、インデクサー パラメーター型は整数に制限されません。 たとえば、文字列をインデクサーで使用すると有効な場合が あります。 このようなインデクサーは、コレクション内の文字列を検索し、適切な値を返すことによって実装される場合がありま す。 アクセサーはオーバーロードできるため、文字列と整数のバージョンは共存できます。
例2
次の例では、曜日を格納するクラスを宣言しています。 get アクセサーは、曜日を示す文字列を受け取り、対応する整数を 返します。 たとえば、"Sunday" は 0、"Monday" は 1 などと値を返します。
   using System;
class Program
{
    static void Main()
    {
        var tempRecord = new TempRecord();
        // Use the indexer's set accessor
        tempRecord[3] = 58.3F;
        tempRecord[5] = 60.1F;
        // Use the indexer's get accessor
        for (int i = 0; i < 10; i++)
        {
            Console.WriteLine($"Element #{i} = {tempRecord[i]}");
        }
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
}
/* Output:
        Element #0 = 56.2
        Element #1 = 56.7
        Element #2 = 56.5
        Element #3 = 58.3
        Element #4 = 58.8
        Element #5 = 60.1
        Element #6 = 65.9
        Element #7 = 62.1
        Element #8 = 59.2
        Element #9 = 57.5
*/ }
 
   使用例 2
    using System;
class Program
{
    static void Main(string[] args)
    {
        var week = new DayCollection();
        Console.WriteLine(week["Fri"]);
try {
            Console.WriteLine(week["Made-up day"]);
        }
        catch (ArgumentOutOfRangeException e)
        {
            Console.WriteLine($"Not supported input: {e.Message}");
        }
    }
    // Output:
    // 5
    // Not supported input: Day Made-up day is not supported.
    // Day input must be in the form "Sun", "Mon", etc (Parameter 'day')
}
 例3
次の例では、System.DayOfWeek 列挙型の使用により、曜日を格納するクラスが宣言されています。 曜日を示す
が get アクセサーにより受け取られ、対応する整数が返されます。 たとえば、 DayOfWeek.Sunday の場合は 0 が
返される、 の場合は 1 が返されるなどです。
  DayOfWeek
 DayOfWeek.Monday
   using System;
// Using a string as an indexer value
class DayCollection
{
    string[] days = { "Sun", "Mon", "Tues", "Wed", "Thurs", "Fri", "Sat" };
    // Indexer with only a get accessor with the expression-bodied definition:
    public int this[string day] => FindDayIndex(day);
    private int FindDayIndex(string day)
    {
        for (int j = 0; j < days.Length; j++)
        {
            if (days[j] == day)
            {
return j; }
}
        throw new ArgumentOutOfRangeException(
            nameof(day),
            $"Day {day} is not supported.\nDay input must be in the form \"Sun\", \"Mon\", etc");
} }
 
  使用例 3
    using System;
class Program
{
    static void Main()
    {
        var week = new DayOfWeekCollection();
        Console.WriteLine(week[DayOfWeek.Friday]);
try {
            Console.WriteLine(week[(DayOfWeek)43]);
        }
        catch (ArgumentOutOfRangeException e)
        {
            Console.WriteLine($"Not supported input: {e.Message}");
        }
    }
    // Output:
    // 5
    // Not supported input: Day 43 is not supported.
    // Day input must be a defined System.DayOfWeek value. (Parameter 'day')
}
 信頼性の高いプログラミング インデクサーのセキュリティと信頼性を改善するには、主に次の 2 つの方法があります。
クライアント コードが無効なインデックス値を渡しても、それを処理できるように必ずエラー処理戦略を組み込んでくださ い。 このトピックの最初の例の TempRecord クラスには Length プロパティが用意されており、入力がインデクサーに渡さ れる前にクライアント コードで検証できるようになっています。 インデクサー自体にエラー処理コードを配置することもでき ます。 インデクサーのアクセサー内部でスローされる例外はすべて、ユーザーのために文書化してください。
   using System;
using Day = System.DayOfWeek;
class DayOfWeekCollection
{
Day[] days = {
        Day.Sunday, Day.Monday, Day.Tuesday, Day.Wednesday,
        Day.Thursday, Day.Friday, Day.Saturday
    };
    // Indexer with only a get accessor with the expression-bodied definition:
    public int this[Day day] => FindDayIndex(day);
    private int FindDayIndex(Day day)
    {
} }
for (int j = 0; j < days.Length; j++)
{
    if (days[j] == day)
    {
return j; }
}
throw new ArgumentOutOfRangeException(
    nameof(day),
    $"Day {day} is not supported.\nDay input must be a defined System.DayOfWeek value.");
 
     getおよびsetアクセサーのアクセシビリティを設定し、適切な制限を指定します。これは、set アクセサーの場合、特 に重要です。 詳細については、「アクセサーのアクセシビリティの制限」を参照してください。
関連項目
C# プログラミング ガイド インデクサー
プロパティ

    interface でインデクサーを宣言することができます。 インターフェイスのインデクサーのアクセサーは、クラスのインデクサーのアクセ サーと次の点で異なります。
インターフェイスのアクセサーは、修飾子は使用しません。 インターフェイスのアクセサーには通常、本文がありません。
アクセサーの目的は、インデクサーが読み取り/書き込み、読み取り専用、書き込み専用のどれかを示すことです。 インデクサー の実装をインターフェイスに定義できますが、めったに行われません。 インデクサーでは通常、データ フィールドにアクセスするため の API が定義されます。データ フィールドはインターフェイスで定義できません。
インターフェイスのインデクサー アクセサーの例を次に示します。
    public interface ISomeInterface
{
//...
    // Indexer declaration:
    string this[int index]
    {
get;
set; }
}
 インデクサーのシグネチャは、同じインターフェイスで宣言されている他のすべてのインデクサーの署名とは異なる必要があります。
例 次の例では、インターフェイスのインデクサーを実装する方法について説明します。
インターフェイスのインデクサー (C# プログラ
ミング ガイド) 2020/11/02 • • Edit Online
 
      IndexerClass test = new IndexerClass();
System.Random rand = new System.Random();
// Call the indexer to initialize its elements.
for (int i = 0; i < 10; i++)
{
    test[i] = rand.Next();
}
for (int i = 0; i < 10; i++)
{
    System.Console.WriteLine($"Element #{i} = {test[i]}");
}
/* Sample output:
    Element #0 = 360877544
    Element #1 = 327058047
    Element #2 = 1913480832
    Element #3 = 1519039937
    Element #4 = 601472233
    Element #5 = 323352310
    Element #6 = 1422639981
    Element #7 = 1797892494
    Element #8 = 875761049
    Element #9 = 393083859
*/
 前の例では、インターフェイス メンバーの完全修飾名を使用して明示的なインターフェイス メンバーの実装を使用することができ ます。 次に例を示します。
ただし、完全修飾名は、クラスが同じインデクサーの署名を持つ 2 つ以上のインターフェイスを実装するときにあいまいさを避け るためにのみ必要です。 たとえば、 Employee クラスが 2 つのインターフェイス ICitizen と IEmployee を実装し、両方のイン ターフェイスが同じインデクサーの署名を持っている場合、明示的なインターフェイス メンバーの実装が必要です。 つまり、次の インデクサーの宣言があります。
    string IIndexInterface.this[int index]
{
}
       // Indexer on an interface:
public interface IIndexInterface
{
    // Indexer declaration:
    int this[int index]
    {
get;
set; }
}
// Implementing the interface.
class IndexerClass : IIndexInterface
{
    private int[] arr = new int[100];
    public int this[int index]   // indexer declaration
    {
} }
// The arr object will throw IndexOutOfRange exception.
get => arr[index];
set => arr[index] = value;
 
       これは、 IEmployee インターフェイス上でインデクサーを実装します。次の宣言があります。
これは、 ICitizen インターフェイスでインデクサーを実装します。 関連項目
C# プログラミング ガイド インデクサー
プロパティ インターフェイス
    string ICitizen.this[int index]
{
}
     string IEmployee.this[int index]
{
}
 
       インデクサーはプロパティと似ています。 次の表で示す相違点を除けば、プロパティのアクセサーに対して定義されているすべて の規則が、インデクサーのアクセサーにも適用されます。
    パブリック データ メンバーのように、メソッドを呼び出せるようにします。
シンプルな名前でアクセスされます。 静的メンバーまたはインスタンス メンバーとして使用できます。
自動実装プロパティを持つ簡略化された構文がサポートされます。
関連項目
C# プログラミング ガイド インデクサー
プロパティ
オブジェクト自体で配列表記を使用して、オブジェクトの内部コレク ションの要素にアクセスできるようにします。
インデックスでアクセスされます。
インスタンス メンバーである必要があります。
インデクサーのみを取得するための式形式メンバーがサポートされま す。
           プロパティの get アクセサーにはパラメーターがありません。
  インデクサーの get アクセサーには、インデクサーと同じ仮パラメー ター リストがあります。
   プロパティの set アクセサーには、暗黙の value パラメーターがあり ます。
   インデクサーの set アクセサーには、インデクサーと同じ仮パラメー ター リストのほか、value パラメーターがあります。
   プロパティとインデクサーの比較 (C# プログラ
ミング ガイド) 2020/11/02 • • Edit Online
 
             クラス やオブジェクトは、何か重要なことが起こった場合に、イベントを使用して他のクラスまたはオブジェクトに通知を送ります。 イベントを送信する ( 発生させる) クラスを パブリッシャー 、イベントを受信する ( 処理する) クラスを サブスクライバーと呼びま す。
一般的な C# Windows フォームまたは Web アプリケーションでは、ボタンやリスト ボックスなどのコントロールによって発生したイ ベントを定期受信します。 Visual C# 統合開発環境 (IDE) を使用して、コントロールによって発行されるイベントを参照し、処 理するイベントを選択できます。 IDE は、空のイベント ハンドラー メソッドとイベントを定期受信するためのコードを自動的に追 加する方法を提供します。 詳細については、「イベントのサブスクリプションとサブスクリプション解除を行う方法」を参照してくださ い。
イベントの概要 イベントには次のようなプロパティがあります。
パブリッシャーがイベントが発生するタイミングを判断し、サブスクライバーがイベントに対応して実行するアクションを決定 します。
イベントには複数のサブスクライバーを指定できます。 サブスクライバーは、複数のパブリッシャーからの複数のイベントを 処理できます。
サブスクライバーがないイベントは発生しません。
イベントは一般的に、グラフィカル ユーザー インターフェイスでのボタンのクリックやメニューの選択などのユーザーの操作を 知らせるために使用されます。
イベントに複数のサブスクライバーがある場合は、イベントが発生したときに複数のイベント ハンドラーが同時に呼び出さ れます。 イベントを非同期に呼び出すには、同期メソッドの非同期呼び出しを参照してください。
.NET クラス ライブラリでは、イベントは EventHandler デリゲートおよび EventArgs 基底クラスに基づきます。
関連項目 詳細については次を参照してください:
イベントのサブスクリプションとサブスクリプション解除を行う方法 .NET ガイドラインに準拠したイベントを発行する方法 派生クラスから基本クラス イベントを発生させる方法 インターフェイス イベントを実装する方法
カスタム イベント アクセサーを実装する方法
C# 言語仕様
詳細については、「C# 言語の仕様」の「イベント」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のあ
る情報源です。 参考書籍の該当する章
イベント (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
           「Delegates, Events, and Lambda Expressions (デリゲート、イベント、およびラムダ式)」(『C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers (C# 3.0 クックブック (第 3 版): C# 3.0 プログラマ向けの 250 以上のソリューション)』)
「デリゲートとイベント」(『Learning C# 3.0: Master the fundamentals of C# 3.0 (C# 3.0 の学習: C# 3.0 の基礎を習得)』) 関連項目
EventHandler
C# プログラミング ガイド
デリゲート
Windows フォーム内でのイベント ハンドラーの作成

    別のクラスによってパブリッシュされるイベントが発生したときに呼び出されるカスタム コードを作成するときは、そのイベントをサブ スクライブします。たとえば、ユーザーがボタンをクリックしたらアプリケーションで何かを行うには、ボタンの click イベントをサブス クライブします。
Visual Studio IDE を使ってイベントをサブスクライブするには
1. デザイン ビューに [プロパティ] ウィンドウが表示されない場合は、イベント ハンドラーを作成するフォームまたはコント
ロールを右クリックして、 [プロパティ] を選びます。
2. [プロパティ] ウィンドウの [イベント] ボタンをクリックします。
3. 作成するイベントをダブルクリックします ( Load イベントなど)。
Visual C# によって空のイベント ハンドラー メソッドを作成され、コードに追加されます。 または、コード ビューを使って 手動でコードを追加することもできます。 たとえば、次のコード行では、 Form クラスで Load イベントが発生すると呼び 出されるイベント ハンドラー メソッドを宣言しています。
イベントをサブスクライブするために必要なコード行も、プロジェクトの Form1.Designer.cs ファイルの InitializeComponent メソッドに自動的に生成されます。次のようなコードです。
プログラムでイベントをサブスクライブするには
1. シグネチャがイベントのデリゲート シグネチャと一致するイベント ハンドラー メソッドを定義します。 たとえば、イベントが
EventHandler デリゲート型に基づいている場合は、次のコードがメソッド スタブを表します。
2. 加算代入演算子 ( += ) を使って、イベントにイベント ハンドラーをアタッチします。 次の例では、 publisher オブジェク トに RaiseCustomEvent という名前のイベントがあるものとします。イベントをサブスクライブするには、サブスクライバーク ラスがそのパブリッシャー クラスを参照する必要があることに注意してください。
上の構文は、C#2.0で新しく追加されたものです。これは、new キーワードを使ってカプセル化するデリゲートを明示 的に作成する必要がある C# 1.0 の構文と完全に同等です。
    private void Form1_Load(object sender, System.EventArgs e)
{
    // Add your form load event handling code here.
}
    this.Load += new System.EventHandler(this.Form1_Load);
     void HandleCustomEvent(object sender, CustomEventArgs a)
{
   // Do something useful here.
}
     publisher.RaiseCustomEvent += HandleCustomEvent;
 イベントのサブスクリプションとサブスクリプ ション解除を行う方法 (C# プログラミング ガイ
ド)
2020/11/02 • • Edit Online
 
      また、ラムダ式を使用してイベント ハンドラーを指定することもできます。
    public Form1()
{
    InitializeComponent();
    this.Click += (s,e) =>
        {
            MessageBox.Show(((MouseEventArgs)e).Location.ToString());
}; }
 匿名メソッドを使ってイベントをサブスクライブするには
後でイベントのサブスクリプションを解除する必要がない場合は、加算代入演算子 ( += ) を使って匿名メソッドをイベン トにアタッチできます。 次の例では、 publisher オブジェクトに RaiseCustomEvent という名前のイベントがあり、
CustomEventArgs クラスもある種の特別なイベント情報を保持するように定義されているものとします。イベントをサブ スクライブするには、サブスクライバークラスがその publisher クラスを参照する必要があることに注意してください。
匿名関数を使ってイベントをサブスクライブした場合、簡単にはイベントのサブスクリプションを解除できないことに注意す ることが重要です。 このシナリオでサブスクリプションを解除するには、イベントをサブスクライブするコードに戻り、匿名メ ソッドをデリゲート変数に格納して、イベントにデリゲートを追加する必要があります。 一般に、後のコードでイベントのサ ブスクリプションを解除する必要がある場合は、イベントのサブスクライブに匿名関数を使わないことをお勧めします。 匿 名関数について詳しくは、「匿名関数」をご覧ください。
サブスクリプションの解除
イベントが発生したときにイベント ハンドラーが呼び出されないようにするには、イベントからサブスクリプションを解除します。 リ ソースのリークを防ぐには、サブスクライバー オブジェクトを破棄する前に、イベントのサブスクリプションを解除する必要がありま す。 イベントのサブスクリプションを解除するまで、パブリッシュ側オブジェクトでイベントの基盤になっているマルチキャスト デリゲー トは、サブスクライバーのイベント ハンドラーをカプセル化するデリゲートへの参照を保持しています。 パブリッシュ側オブジェクトが その参照を保持している限り、ガベージ コレクションはサブスクライバー オブジェクトを削除しません。
イベントのサブスクリプションを解除するには イベントのサブスクリプションを解除するには、減算代入演算子 ( -= ) を使います。
すべてのサブスクライバーがイベントのサブスクリプションを解除すると、パブリッシャー クラスのイベント インスタンスは null に設定されます。
関連項目
イベント
event
.NET ガイドラインに準拠したイベントを発行する方法 - および -= 演算子
        publisher.RaiseCustomEvent += delegate(object o, CustomEventArgs e)
{
  string s = o.ToString() + " " + e.ToString();
  Console.WriteLine(s);
};
   publisher.RaiseCustomEvent -= HandleCustomEvent;
  publisher.RaiseCustomEvent += new CustomEventHandler(HandleCustomEvent);
 
  + および += 演算子

          ここでは、.NET の標準のパターンに従うイベントをクラスおよび構造体に追加する方法について説明します。 .NET クラス ライブ ラリ内のすべてのイベントは、次のように定義されている EventHandler デリゲートに基づいています。
  public delegate void EventHandler(object sender, EventArgs e);
     NOTE
.NET Framework 2.0 には、このデリゲートのジェネリック バージョンである EventHandler<TEventArgs> が導入されています。 次の例 は、両方のバージョンの使用方法を示しています。
 ユーザー定義のクラス内のイベントは、値を返すデリゲートを含む、あらゆる有効なデリゲート型に基づいて発行できますが、一 般的には、次の例のように EventHandler を使用して、.NET のパターンに基づいて発行することをお勧めします。
名前 EventHandler は、実際にはイベントを処理しないため、混乱を招く可能性があります。EventHandler、およびジェネ リックの EventHandler<TEventArgs> はデリゲート型です。 シグネチャがデリゲート定義と一致するメソッドまたはラムダ式は、 "イベント ハンドラー" で、イベントが発生したときに呼び出されます。
EventHandler パターンに基づいてイベントを発行する
1. (イベントと共にカスタム データを送信する必要がない場合は、この手順を省略して手順 3a. に進んでください。)パブリッ シャー クラスとサブスクライバー クラスの両方から参照できるスコープで、カスタム データのクラスを宣言します。 次に、カス タム イベント データを保持する必須メンバーを追加します。 この例では、単純な文字列が 1 つ返されます。
     public class CustomEventArgs : EventArgs
{
    public CustomEventArgs(string message)
    {
        Message = message;
    }
    public string Message { get; set; }
}
 2. (ジェネリック バージョンの EventHandler<TEventArgs> を使用する場合、この手順は省略します。)パブリッシャー クラ スでデリゲートを宣言します。 EventHandler で終わる名前を指定します。2番目のパラメーターで、カスタムの
EventArgs 型を指定します。
3. 次のいずれかの手順を使用して、パブリッシャー クラスでイベントを宣言します。
a. カスタムの EventArgs クラスがない場合、Event 型は非ジェネリック バージョンの EventHandler デリゲートにな ります。 このデリゲートは、C# プロジェクトを作成したときに含まれている System 名前空間で既に宣言されて いるため、ここで宣言する必要はありません。 パブリッシャー クラスに次のコードを追加します。
    public delegate void CustomEventHandler(object sender, CustomEventArgs args);
 .NET ガイドラインに準拠したイベントを発行す
る方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     b. 非ジェネリック バージョンの EventHandler を使用し、EventArgs から派生したカスタム クラスがある場合は、パ ブリッシャー クラス内でイベントを宣言し、手順 2 のデリゲートを型として使用します。
c. ジェネリック バージョンを使用する場合、カスタム デリゲートは不要です。 代わりに、パブリッシャー クラスでイベン トの種類として EventHandler<CustomEventArgs> を指定します。山かっこの部分は、実際のクラス名で置き換 えます。
例
次の例は、前の手順を具体的に示しています。ここでは、カスタムの EventArgs クラスを使用し、イベントの種類として EventHandler<TEventArgs> を使用しています。
  public event CustomEventHandler RaiseCustomEvent;
    public event EventHandler<CustomEventArgs> RaiseCustomEvent;
     public event EventHandler RaiseCustomEvent;
  using System;
namespace DotNetEvents
{
    // Define a class to hold custom event info
    public class CustomEventArgs : EventArgs
    {
        public CustomEventArgs(string message)
        {
            Message = message;
        }
        public string Message { get; set; }
    }
    // Class that publishes an event
    class Publisher
    {
        // Declare the event using EventHandler<T>
        public event EventHandler<CustomEventArgs> RaiseCustomEvent;
        public void DoSomething()
        {
            // Write some code that does something useful here
            // then raise the event. You can also raise an event
            // before you execute a block of code.
            OnRaiseCustomEvent(new CustomEventArgs("Event triggered"));
}
        // Wrap event invocations inside a protected virtual method
        // to allow derived classes to override the event invocation behavior
        protected virtual void OnRaiseCustomEvent(CustomEventArgs e)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<CustomEventArgs> raiseEvent = RaiseCustomEvent;
            // Event will be null if there are no subscribers
            if (raiseEvent != null)
            {
// Format the string to send inside the CustomEventArgs parameter

       関連項目
Delegate
C# プログラミング ガイド イベント
デリゲート
 } }
e.Message += $" at {DateTime.Now}";
    // Call to raise the event.
    raiseEvent(this, e);
}
//Class that subscribes to an event
class Subscriber
{
    private readonly string _id;
    public Subscriber(string id, Publisher pub)
    {
_id = id;
        // Subscribe to the event
        pub.RaiseCustomEvent += HandleCustomEvent;
    }
    // Define what actions to take when the event is raised.
    void HandleCustomEvent(object sender, CustomEventArgs e)
    {
        Console.WriteLine($"{_id} received this message: {e.Message}");
    }
}
class Program
{
    static void Main()
    {
} }
}
var pub = new Publisher();
var sub1 = new Subscriber("sub1", pub);
var sub2 = new Subscriber("sub2", pub);
// Call the method that raises the event.
pub.DoSomething();
// Keep the console window open
Console.WriteLine("Press any key to continue...");
Console.ReadLine();

   ここでは単純な例を使用し、派生クラスからも発生させることができるように基底クラスでイベントを宣言する標準的な方法につ いて説明します。 このパターンは、.NET クラス ライブラリの Windows フォーム クラスで広く使用されています。
他のクラスの基底クラスとして使用できるクラスを作成するときは、イベントは宣言元のクラス内からしか呼び出せない特別な種 類のデリゲートであることを考慮する必要があります。 派生クラスは、基底クラスの中で宣言されたイベントを直接呼び出せませ ん。 常に基底クラスからイベントを発生させるようにすると便利な場合もありますが、ほとんどの場合、派生クラスで基底クラス イベントを呼び出せるようにするべきです。 そのために、イベントをラップする基底クラスで、保護された呼び出しメソッドを作成で きます。 この呼び出しメソッドを呼び出すかオーバーライドすることによって、派生クラスから間接的にイベントを呼び出すことがで きます。
例
    NOTE
基底クラスで仮想イベントを宣言したり、派生クラスでそれらをオーバーライドしたりしないでください。 C# コンパイラはこれらを正しく処理でき ず、派生イベントに対するサブスクライバーが基底クラスのイベントを実際に受信登録するかどうかは予測できません。
    派生クラスから基底クラス イベントを発生させ
る方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
  namespace BaseClassEvents
{
    // Special EventArgs class to hold info about Shapes.
    public class ShapeEventArgs : EventArgs
    {
        public ShapeEventArgs(double area)
        {
            NewArea = area;
        }
        public double NewArea { get; }
    }
    // Base class event publisher
    public abstract class Shape
    {
        protected double _area;
        public double Area
        {
get => _area;
            set => _area = value;
        }
        // The event. Note that by using the generic EventHandler<T> event type
        // we do not need to declare a separate delegate type.
        public event EventHandler<ShapeEventArgs> ShapeChanged;
        public abstract void Draw();
        //The event-invoking method that derived classes can override.
        protected virtual void OnShapeChanged(ShapeEventArgs e)
        {
// Safely raise the event for all subscribers

// Safely raise the event for all subscribers
          ShapeChanged?.Invoke(this, e);
    }
public class Circle : Shape
{
    private double _radius;
    public Circle(double radius)
    {
        _radius = radius;
        _area = 3.14 * _radius * _radius;
    }
    public void Update(double d)
    {
        _radius = d;
        _area = 3.14 * _radius * _radius;
        OnShapeChanged(new ShapeEventArgs(_area));
}
    protected override void OnShapeChanged(ShapeEventArgs e)
    {
        // Do any circle-specific processing here.
        // Call the base class event invocation method.
        base.OnShapeChanged(e);
    }
    public override void Draw()
    {
        Console.WriteLine("Drawing a circle");
    }
}
public class Rectangle : Shape
{
    private double _length;
    private double _width;
    public Rectangle(double length, double width)
    {
        _length = length;
        _width = width;
        _area = _length * _width;
}
    public void Update(double length, double width)
    {
        _length = length;
        _width = width;
        _area = _length * _width;
        OnShapeChanged(new ShapeEventArgs(_area));
}
    protected override void OnShapeChanged(ShapeEventArgs e)
    {
        // Do any rectangle-specific processing here.
        // Call the base class event invocation method.
        base.OnShapeChanged(e);
    }
    public override void Draw()
    {
        Console.WriteLine("Drawing a rectangle");
    }
}
}
  
    関連項目
 // Represents the surface on which the shapes are drawn
// Subscribes to shape events so that it knows
// when to redraw a shape.
public class ShapeContainer
{
    private readonly List<Shape> _list;
    public ShapeContainer()
    {
        _list = new List<Shape>();
    }
    public void AddShape(Shape shape)
    {
        _list.Add(shape);
        // Subscribe to the base class event.
        shape.ShapeChanged += HandleShapeChanged;
    }
    // ...Other methods to draw, resize, etc.
    private void HandleShapeChanged(object sender, ShapeEventArgs e)
    {
} }
if (sender is Shape shape)
{
    // Diagnostic message for demonstration purposes.
    Console.WriteLine($"Received event. Shape area is now {e.NewArea}");
    // Redraw the shape here.
    shape.Draw();
}
class Test {
    static void Main()
    {
} }
}
/* Output:
*/
//Create the event publishers and subscriber
var circle = new Circle(54);
var rectangle = new Rectangle(12, 9);
var container = new ShapeContainer();
// Add the shapes to the container.
container.AddShape(circle);
container.AddShape(rectangle);
// Cause some events to be raised.
circle.Update(57);
rectangle.Update(7, 7);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to continue...");
Console.ReadKey();
Received event. Shape area is now 10201.86
Drawing a circle
Received event. Shape area is now 49
Drawing a rectangle

     C# プログラミング ガイド
イベント
デリゲート
アクセス修飾子
Windows フォーム内でのイベント ハンドラーの作成

    インターフェイスではイベントを宣言できます。 次の例では、クラス内にインターフェイス イベントを実装する方法について説明し ます。 基本的な原則は、インターフェイスのメソッドやプロパティを実装する場合と同じです。
クラス内でインターフェイス イベントを実装するには クラス内でイベントを宣言してから、適切な領域でそのイベントを呼び出します。
    namespace ImplementInterfaceEvents
{
    public interface IDrawingObject
    {
        event EventHandler ShapeChanged;
    }
    public class MyEventArgs : EventArgs
    {
        // class members
    }
    public class Shape : IDrawingObject
    {
} }
public event EventHandler ShapeChanged;
void ChangeShape()
{
    // Do something here before the event...
    OnShapeChanged(new MyEventArgs(/*arguments*/));
    // or do something here after the event.
}
protected virtual void OnShapeChanged(MyEventArgs e)
{
    ShapeChanged?.Invoke(this, e);
}
 例
次の例では、同じ名前のイベント名がある 2 つ以上のインターフェイスからクラスを継承するという、あまり一般的でない状況の 対処方法を示します。 このような場合は、1 つ以上のイベントに対して明示的なインターフェイスの実装を指定する必要があり ます。 イベントに対する明示的なインターフェイスの実装を記述する場合、 add および remove の各イベント アクセサーも記 述する必要があります。 通常ではこれらのアクセサーはコンパイラで指定しますが、この例ではコンパイラで指定することはできま せん。
独自のアクセサーを指定することで、2 つのイベントがクラス内の同一イベントと別々のイベントのどちらによって表されるかを指定 できます。 たとえば、インターフェイスの仕様上、イベントを複数回発生させる必要がある場合は、各イベントをクラス内の別々 の実装に関連付けます。次の例では、サブスクライバーで IShape または IDrawingObject のいずれかに図形参照をキャス トして、どちらの OnDraw イベントを受信するかを決定しています。
    インターフェイス イベントを実装する方法 (C#
プログラミング ガイド) 2020/11/02 • • Edit Online
     namespace WrapTwoInterfaceEvents
{

   {
    using System;
    public interface IDrawingObject
    {
        // Raise this event before drawing
        // the object.
        event EventHandler OnDraw;
    }
    public interface IShape
    {
        // Raise this event after drawing
        // the shape.
        event EventHandler OnDraw;
}
    // Base class event publisher inherits two
    // interfaces, each with an OnDraw event
    public class Shape : IDrawingObject, IShape
    {
        // Create an event for each interface event
        event EventHandler PreDrawEvent;
        event EventHandler PostDrawEvent;
        object objectLock = new Object();
        // Explicit interface implementation required.
        // Associate IDrawingObject's event with
        // PreDrawEvent
        #region IDrawingObjectOnDraw
        event EventHandler IDrawingObject.OnDraw
        {
add {
} remove {
} }
lock (objectLock)
{
    PreDrawEvent += value;
}
lock (objectLock)
{
    PreDrawEvent -= value;
}
#endregion
// Explicit interface implementation required.
// Associate IShape's event with
// PostDrawEvent
event EventHandler IShape.OnDraw
{
add {
} remove {
} }
lock (objectLock)
{
    PostDrawEvent += value;
}
lock (objectLock)
{
    PostDrawEvent -= value;
}
  
     関連項目
C# プログラミング ガイド
     // For the sake of simplicity this one method
    // implements both interfaces.
    public void Draw()
    {
        // Raise IDrawingObject's event before the object is drawn.
        PreDrawEvent?.Invoke(this, EventArgs.Empty);
        Console.WriteLine("Drawing a shape.");
        // Raise IShape's event after the object is drawn.
        PostDrawEvent?.Invoke(this, EventArgs.Empty);
    }
}
public class Subscriber1
{
    // References the shape object as an IDrawingObject
    public Subscriber1(Shape shape)
    {
        IDrawingObject d = (IDrawingObject)shape;
        d.OnDraw += d_OnDraw;
    }
    void d_OnDraw(object sender, EventArgs e)
    {
        Console.WriteLine("Sub1 receives the IDrawingObject event.");
    }
}
// References the shape object as an IShape
public class Subscriber2
{
    public Subscriber2(Shape shape)
    {
        IShape d = (IShape)shape;
        d.OnDraw += d_OnDraw;
    }
    void d_OnDraw(object sender, EventArgs e)
    {
        Console.WriteLine("Sub2 receives the IShape event.");
    }
}
public class Program
{
    static void Main(string[] args)
    {
} }
}
/* Output:
Shape shape = new Shape();
Subscriber1 sub = new Subscriber1(shape);
Subscriber2 sub2 = new Subscriber2(shape);
shape.Draw();
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
    Sub1 receives the IDrawingObject event.
    Drawing a shape.
    Sub2 receives the IShape event.
*/

    イベント
デリゲート
明示的なインターフェイスの実装 派生クラスから基本クラス イベントを発生させる方法

    イベントは、宣言元のクラス内でしか呼び出せない特殊なマルチキャスト デリゲートです。 クライアント コードは、イベント発生時 に呼び出されるメソッドへの参照を提供することにより、イベントにサブスクライブします。 これらのメソッドは、イベント アクセサーを 使用してデリゲートの呼び出しリストに追加されます。イベント アクセサーはプロパティ アクセサーに似ていますが、イベント アクセ サーには add および remove という名前が付いている点が異なります。ほとんどの場合、カスタムイベントアクセサーを指定 する必要はありません。 コードでカスタム イベント アクセサーを指定していない場合は、コンパイラによって自動的に追加されま す。 ただし、カスタム動作の指定が必要な場合もあります。 「インターフェイス イベントを実装する方法」トピックは、そのような 場合の一例を示しています。
例
次の例は、カスタム イベント アクセサーの add と remove を実装する方法を示しています。 アクセサー内で任意のコードに置き 換えることができますが、新しいイベント ハンドラー メソッドを追加または削除する前に、イベントをロックすることをお勧めしま す。
     event EventHandler IDrawingObject.OnDraw
{
add {
} remove {
} }
lock (objectLock)
{
    PreDrawEvent += value;
}
lock (objectLock)
{
    PreDrawEvent -= value;
}
 関連項目
イベント
event
カスタム イベント アクセサーを実装する方法
(C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
       ジェネリックにより、.NET に型パラメーターという概念が導入されます。これを使用すると、クラスやメソッドがクライアント コードに よって宣言され、インスタンス化されるまで、1 つ以上の型の指定を遅延させるクラスやメソッドを設計することができます。 たとえ ば、ジェネリック型パラメーター T を使用すると、次に示すように、ランタイムキャストやボックス化操作を使うコストやリスクを発 生させることなく他のクライアント コードで使用できる、単一のクラスを記述できます。
    // Declare the generic class.
public class GenericList<T>
{
    public void Add(T input) { }
}
class TestGenericList
{
    private class ExampleClass { }
    static void Main()
    {
} }
// Declare a list of type int.
GenericList<int> list1 = new GenericList<int>();
list1.Add(1);
// Declare a list of type string.
GenericList<string> list2 = new GenericList<string>();
list2.Add("");
// Declare a list of type ExampleClass.
GenericList<ExampleClass> list3 = new GenericList<ExampleClass>();
list3.Add(new ExampleClass());
 ジェネリックのクラスとメソッドにより、非ジェネリックの場合には不可能な方法で、再利用性、タイプ セーフ、効率性が同時に実 現されます。 ジェネリックは、コレクションとそれを操作するメソッドとともに使用されるのが通常です。 System.Collections.Generic 名前空間には、ジェネリック ベースのコレクション クラスがいくつか含まれています。 ArrayList な どの非ジェネリック コレクションは推奨されません。これらは互換性のために保持されています。 詳細については、「.NET のジェネ リック」を参照してください。
もちろん、カスタムのジェネリック型やジェネリック メソッドを作成して、タイプ セーフで効率的な独自の汎用ソリューションや設計パ ターンを実現することもできます。 次のコード例では、デモンストレーション用の簡単なジェネリックのリンク リスト クラスを示しま す。 (通常は、独自のクラスを作成するのではなく、.NET で用意されている List<T> クラスを使用してください。)この例では、 通常、具体的な型を使用して、リストに格納する項目の型を示す場面で、型パラメーター T を使用しています。このパラメー ターは、次のように使用されています。
AddHead メソッドのメソッドパラメーターの型として使用。
入れ子になった Node クラスの Data プロパティの戻り値の型として使用。 入れ子になったクラスのプライベートメンバー data の型として使用。
入れ子になった Node クラスで T を使用できることに注意してください。 GenericList<T> が GenericList<int> のような具 象型でインスタンス化されると、 T の部分はそれぞれ int に置き換えられます。
   ジェネリック (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     次のコード例では、クライアントコードでジェネリックの GenericList<T> クラスを使用して、整数のリストを作成する方法を示し ています。 このコードの型引数を変更するだけで、文字列やその他の任意のカスタム型のリストを作成するように簡単に修正で きます。
  // type parameter T in angle brackets
public class GenericList<T>
{
    // The nested class is also generic on T.
    private class Node
    {
        // T used in non-generic constructor.
        public Node(T t)
        {
next = null;
data = t; }
        private Node next;
        public Node Next
        {
            get { return next; }
            set { next = value; }
        }
        // T as private member data type.
        private T data;
        // T as return type of property.
        public T Data
        {
            get { return data; }
            set { data = value; }
        }
    }
    private Node head;
    // constructor
    public GenericList()
    {
head = null; }
    // T as method parameter type:
    public void AddHead(T t)
    {
        Node n = new Node(t);
        n.Next = head;
        head = n;
}
    public IEnumerator<T> GetEnumerator()
    {
} }
Node current = head;
while (current != null)
{
    yield return current.Data;
    current = current.Next;
}

                   ジェネリックの概要
ジェネリック型は、コードの再利用、タイプ セーフ、およびパフォーマンスを最大化するために使用します。 ジェネリックの最も一般的な用途は、コレクション クラスの作成です。
.NET クラス ライブラリには、複数のジェネリック コレクション クラスが System.Collections.Generic 名前空間に含まれていま す。 System.Collections 名前空間の ArrayList などのクラスの代わりとして、できる限りこれらを使用してください。 独自のジェネリック インターフェイス、クラス、メソッド、イベント、およびデリゲートを作成できます。
ジェネリック クラスは、特定のデータ型のメソッドへのアクセスを有効にするように制限できます。
ジェネリック データ型で使用される型に関する情報は、実行時にリフレクションを使用して取得できます。 関連項目
ジェネリック型パラメーター 型パラメーターの制約 ジェネリック クラス ジェネリック インターフェイス ジェネリック メソッド 汎用デリゲート
C++ テンプレートと C# ジェネリックの違い ジェネリックとリフレクション ランタイムのジェネリック
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。
関連項目
System.Collections.Generic
C# プログラミング ガイド 型
<typeparam> <typeparamref>
   class TestGenericList
{
    static void Main()
    {
        // int is the type argument
        GenericList<int> list = new GenericList<int>();
        for (int x = 0; x < 10; x++)
        {
            list.AddHead(x);
        }
        foreach (int i in list)
        {
            System.Console.Write(i + " ");
        }
        System.Console.WriteLine("\nDone");
    }
}
 
  .NET のジェネリック

       ジェネリック型またはメソッド定義で、型パラメーターは、ジェネリック型のインスタンスを作成するときにクライアントが指定する特定 の型のためのプレースホルダーになります。 「ジェネリックの概要」に記載されている などのジェネリック クラス は、実際は型でないため、そのままでは使用できません。これは型の設計図のようなものです。 を使用する には、クライアント コードで構築された型を宣言し、インスタンス化する必要があります。山かっこ内に型引数を指定します。 こ の特定のクラスの型引数は、コンパイラで認識されるあらゆる型にすることができます。 構築された型インスタンスは、次のように さまざまな型引数を利用し、いくつでも作成できます。
GenericList<T> の各インスタンスでは、クラス内のすべての T は実行時に型引数に置換されます。この置換を使用し、単 一クラス定義を使用してタイプ セーフで効率的なオブジェクトを 3 つ作成しました。 この置換が CLR で実行されるしくみについ ては、「ランタイムのジェネリック」を参照してください。
型パラメーターの名前付けガイドライン
1 文字の名前でも完全に説明され、説明的な名前を付けることに意味がない場合を除き、ジェネリック型パラメーター には説明的な名前を付けてください。
1 文字の型パラメーターを持つ型の型パラメーター名として T を利用することを検討してください。
型パラメーターの説明的な名前には "T" という接頭辞を付けてください。
型パラメーターに与えられた制約をパラメーターの名前で示唆することを検討してください。 たとえば、 ISession に制 約されているパラメーターの名前を TSession にします。
コード分析規則 CA1715 を使用して、型パラメーターの名前が適切に付けられていることを確認できます。
関連項目
 GenericList<T>
 GenericList<T>
    GenericList<float> list1 = new GenericList<float>();
GenericList<ExampleClass> list2 = new GenericList<ExampleClass>();
GenericList<ExampleStruct> list3 = new GenericList<ExampleStruct>();
      public interface ISessionChannel<TSession> { /*...*/ }
public delegate TOutput Converter<TInput, TOutput>(TInput from);
public class List<T> { /*...*/ }
     public int IComparer<T>() { return 0; }
public delegate bool Predicate<T>(T item);
public struct Nullable<T> where T : struct { /*...*/ }
     public interface ISessionChannel<TSession>
{
    TSession Session { get; }
}
   System.Collections.Generic
ジェネリック型の型パラメーター (C# プログラ
ミング ガイド) 2020/11/02 • • Edit Online
 
    C# プログラミング ガイド
ジェネリック
C++ テンプレートと C# ジェネリックの違い

       制約では、型引数に必要な機能をコンパイラに通知します。 制約のない型引数は、任意の型にすることができます。 コンパイ ラは、.NET 型の最終的な基底クラスになる、System.Object のメンバーを見なすことができるだけです。 詳細については、「制 約を使用する理由」を参照してください。 クライアント コードが制約を満たさない型を使用している場合、コンパイラではエラー が発行されます。制約を指定するには、where コンテキストキーワードを使用します。次の表は、さまざまな制約の種類の一 覧です。
    where T : struct
  この型引数は null 非許容値型である必要があります。 null 許容値 型の詳細については、「null 許容値型」を参照してください。 すべての 値の型にはアクセス可能なパラメーターなしのコンストラクターがあるた め、 struct 制約は new() 制約を意味し、 new() 制約と組 み合わせることはできません。 struct 制約を unmanaged 制約 と組み合わせることはできません。
       where T : class
  この型引数は参照型である必要があります。 この制約は、任意のク ラス、インターフェイス、デリゲート、または配列型にも適用されます。 C# 8.0 以降の null 許容コンテキストでは、 T は null 非許容の参 照型である必要があります。
    where T : class?
  型の引数は、null 許容または null 非許容の参照型である必要があ ります。 この制約は、任意のクラス、インターフェイス、デリゲート、また は配列型にも適用されます。
    where T : notnull
   この型引数は null 非許容型である必要があります。 引数は、C# 8.0 以降の null 非許容参照型、または null 非許容値型にできま す。
    where T : unmanaged
  この型引数は null 非許容でアンマネージド型である必要がありま す。 unmanaged 制約は struct 制約を意味し、 struct 制 約とも new() 制約とも組み合わせることはできません。
       where T : new()
 この型引数には、パラメーターなしのパブリック コンストラクターが必要 です。 new() 制約を別の制約と併用する場合、この制約を最後 に指定する必要があります。 new() 制約は、 struct や
unmanaged 制約と組み合わせることはできません。
      where T : <base class name>
  この型引数は、指定された基底クラスであるか、そのクラスから派生し ている必要があります。 C# 8.0 以降の null 許容コンテキストでは、 T は指定の基底クラスから派生した null 非許容の参照型である
必要があります。
    where T : <base class name>?
   この型引数は、指定された基底クラスであるか、そのクラスから派生し ている必要があります。 C# 8.0 以降の null 許容コンテキストでは、
T は指定の基底クラスから派生した null 許容または非許容のいず れかの参照型である場合があります。
 型パラメーターの制約 (C# プログラミング ガイ
ド)
2021/03/06 • • Edit Online
 
       where T : <interface name>
   この型引数は、指定されたインターフェイスであるか、そのインターフェイ スを実装している必要があります。 複数のインターフェイス制約を指 定することができます。 制約のインターフェイスを汎用的にすることもで きます。 C# 8.0 以降の null 許容コンテキストでは、 T は指定した インターフェイスを実装する null 非許容型である必要があります。
    where T : <interface name>?
 この型引数は、指定されたインターフェイスであるか、そのインターフェイ スを実装している必要があります。 複数のインターフェイス制約を指 定することができます。 制約のインターフェイスを汎用的にすることもで きます。 C# 8.0 の null 許容コンテキストでは、 T は null 許容参 照型、null 非許容参照型、または値型である場合があります。 T は null 許容値型ではない可能性があります。
     where T : U
  T に指定する型引数は、 U に指定された引数であるか、その引 数から派生している必要があります。 null 許容コンテキストでは、 U が null 非許容参照型である場合、 T は null 非許容参照型であ る必要があります。 U が null 許容参照型である場合、 T は null 許容または null 非許容のいずれかになります。
 制約を使用する理由
制約では、型パラメーターの能力と期待を指定します。 これらの制約を宣言することで、制約型の操作とメソッドの呼び出しを 使用できるようになります。 お使いのジェネリック クラスまたはメソッドが、単純な割り当てや、System.Object でサポートされて いない任意のメソッド呼び出しでジェネリック メンバーに対して任意の操作を使用する場合、型パラメーターに制約を適用する 必要があります。 たとえば、この基底クラスの制約は、この型のオブジェクト、またはこの型から派生したオブジェクトのみを型引 数として使用することをコンパイラに指示しています。 コンパイラがこの保証を獲得したら、その型のメソッドをジェネリック クラスで 呼び出すことができるようになります。基底クラスの制約を適用して GenericList<T> クラス(「ジェネリックの概要」を参照)に 追加できる機能を説明するコード例を次に示します。
 
     この制約ではジェネリッククラスで プロパティを使用できるようにします。制約では、型 T のすべての項目が、 Employee オブジェクトまたは から継承するオブジェクトのいずれかになることが保証されることを指定します。
同じ型パラメーターに複数の制約を適用できます。また、制約自体をジェネリック型にすることもできます。次に例を示します。
Employee.Name
  Employee
  public class Employee
{
    public Employee(string name, int id) => (Name, ID) = (name, id);
    public string Name { get; set; }
    public int ID { get; set; }
}
public class GenericList<T> where T : Employee
{
    private class Node
    {
        public Node(T t) => (Next, Data) = (null, t);
        public Node Next { get; set; }
        public T Data { get; set; }
    }
    private Node head;
    public void AddHead(T t)
    {
        Node n = new Node(t) { Next = head };
head = n; }
    public IEnumerator<T> GetEnumerator()
    {
        Node current = head;
        while (current != null)
        {
            yield return current.Data;
            current = current.Next;
        }
}
    public T FindFirstOccurrence(string s)
    {
        Node current = head;
        T t = null;
        while (current != null)
        {
            //The constraint enables access to the Name property.
            if (current.Data.Name == s)
            {
                t = current.Data;
break; }
else {
                current = current.Next;
            }
}
return t; }
}

   where T : class 制約を適用する場合は、型パラメーターに == および != 演算子を使用しないでください。これらの演算 子でテストされるのは、値の等価性ではなく、参照 ID についてのみです。 これらの演算子が、引数として使用されている型内 でオーバーロードされている場合でも、この動作が発生します。この点を説明するコードを次に示します。Stringクラスが == 演算子をオーバーロードしている場合でも、出力は false です。
    public static void OpEqualsTest<T>(T s, T t) where T : class
{
    System.Console.WriteLine(s == t);
}
private static void TestStringEquality()
{
    string s1 = "target";
    System.Text.StringBuilder sb = new System.Text.StringBuilder("target");
    string s2 = sb.ToString();
    OpEqualsTest<string>(s1, s2);
}
 コンパイラは T がコンパイル時に参照型であることしか認識しておらず、すべての参照型で有効な既定の演算子を使用する 必要があります。 値の等価性をテストする必要がある場合は、 where T : IEquatable<T> または
where T : IComparable<T> 制約も適用し、ジェネリック クラスの制約に使用されるすべてのクラスでそのインターフェイスを実装 することをお勧めします。
複数のパラメーターを制約する
複数のパラメーターに制約を適用できます。また、複数の制約を 1 つのパラメーターに適用することができます。次に例を示しま す。
非バインド型パラメーター
パブリッククラス SampleClass<T>{} のTなど、制約がない型パラメーターは、非バインド型パラメーターと呼ばれます。非バイ ンド型パラメーターには次の規則があります。
!= および == 演算子は使用できません。これは、具象型引数によってこれらの演算子がサポートされるという保証がない ためです。
これらの演算子は System.Object との間で相互に変換できます。また、任意のインターフェイス型に明示的に変換できま す。
これらはnullと比較することができます。非バインド型パラメーターと null を比較し、その型引数が値の型の場合、比較 結果として常に false が返されます。
制約としての型パラメーター
制約としてジェネリック型パラメーターを使用する方法は、独自の型パラメーターがあるメンバー関数が、含まれる型の型パラメー ターにそのパラメーターを制約する必要がある場合に便利です。次に例を示します。
      class Base { }
class Test<T, U>
    where U : struct
where T : Base, new() {}
      class EmployeeList<T> where T : Employee, IEmployee, System.IComparable<T>, new()
{
// ... }
 
      public class List<T>
{
    public void Add<U>(List<U> items) where U : T {/*...*/}
}
 前の例の T は、 Add メソッドのコンテキストでは型の制約ですが、 List クラスのコンテキストでは非バインド型パラメーターで す。
型パラメーターは、ジェネリック クラス定義の制約としても使用できます。 型パラメーターは、他の型パラメーターと共に山かっこ内 で宣言する必要があります。
ジェネリック クラスで制約として型パラメーターを使用する方法が便利なのは、限られた場合のみです。コンパイラでは、 System.Object から派生したことを除き、型パラメーターに関して何も仮定できないためです。2つの型パラメーター間に継承
関係を適用するシナリオには、ジェネリック クラスの制約として型パラメーターを使用してください。 NotNull 制約
C# 8.0 以降の null 許容コンテキストでは、 制約を使用して、型引数が null 非許容値型または null 非許容参照 型である必要があることを指定できます。 制約は、 nullable enable コンテキストでのみ使用できます。 null 許容 が未指定のコンテキストに notnull 制約を追加すると、コンパイラにより警告が生成されます。
他の制約とは異なり、型引数が notnull 制約に違反すると、そのコードが nullable enable コンテキストでコンパイルされる ときにコンパイラにより警告が生成されます。 null 許容が未指定のコンテキストでコードがコンパイルされた場合、コンパイラに よって警告やエラーは生成されません。
C#8.0以降のnull許容コンテキストでは、class 制約を使用して、型引数がnull非許容型である必要があることを指定 できます。 null 許容コンテキストでは、型パラメーターが null 許容参照型である場合、コンパイラによって警告が生成されま す。
アンマネージド制約
C# 7.3 以降、 制約を指定して、型パラメーターが null 非許容でアンマネージド型である必要があることを指定で きます。 制約では、次の例のように、メモリのブロックとして操作できる型を処理する再利用可能なルーチンを記述 できます。
    //Type parameter V is used as a type constraint.
public class SampleClass<T, U, V> where T : V { }
   notnull
  notnull
    unmanaged
 unmanaged
    unsafe public static byte[] ToByteArray<T>(this T argument) where T : unmanaged
{
    var size = sizeof(T);
    var result = new Byte[size];
    Byte* p = (byte*)&argument;
    for (var i = 0; i < size; i++)
        result[i] = *p++;
    return result;
}
   ビルトイン型ではない型で sizeof 演算子を使用するため、先行するメソッドは unsafe コンテキストでコンパイルされる必要 があります。 unmanaged 制約なしで、 sizeof 演算子を使用することはできません。
unmanaged 制約は 制約を意味するため、これと組み合わせることはできません。 struct 制約は new() 制約を 意味するため、 制約を new() 制約と組み合わせることもできません。
     struct
 unmanaged

    制約をデリゲートする
また、C# 7.3 以降、基底クラスの制約として System.Delegate または System.MulticastDelegate を使用することもできま す。CLRでは常にこの制約を許可していますが、C#言語では許可されていません。 System.Delegate 制約では、タイプ セーフな方法でデリゲートを処理するコードを記述できます。 次のコードでは、2 つのデリゲートが同じ型である場合にそれらを 組み合わせる拡張メソッドを定義します。
上述のメソッドを使用して、同じ型のデリゲートを組み合わせることができます。
     public static TDelegate TypeSafeCombine<TDelegate>(this TDelegate source, TDelegate target)
    where TDelegate : System.Delegate
    => Delegate.Combine(source, target) as TDelegate;
     Action first = () => Console.WriteLine("this");
Action second = () => Console.WriteLine("that");
var combined = first.TypeSafeCombine(second);
combined();
Func<bool> test = () => true;
// Combine signature ensures combined delegates must
// have the same type.
//var badCombined = first.TypeSafeCombine(test);
 最後の行のコメントを解除した場合、コンパイルされません。 first と test は両方ともデリゲート型ですが、これらは異なる デリゲート型です。
列挙の制約
C# 7.3 以降、基底クラスの制約として System.Enum 型を指定することもできます。 CLR では常にこの制約を許可していま すが、C#言語では許可されていません。 System.Enum を使用するジェネリックは、 System.Enum の静的メソッドの使用から 結果をキャッシュするために、タイプ セーフのプログラミングを提供します。 次の例では、列挙型の有効な値をすべて見つけて、 それらの値をその文字列表記にマップするディクショナリをビルドします。
      public static Dictionary<int, string> EnumNamedValues<T>() where T : System.Enum
{
    var result = new Dictionary<int, string>();
    var values = Enum.GetValues(typeof(T));
    foreach (int item in values)
        result.Add(item, Enum.GetName(typeof(T), item));
    return result;
}
   Enum.GetValues と Enum.GetName ではリフレクションが使用されます。これは、パフォーマンスに影響を与えます。リフレクション を必要とする呼び出しを繰り返すのではなく、 EnumNamedValues を呼び出してキャッシュおよび再利用されるコレクションを作成 できます。
次の例で示すように、このメソッドを使用して、列挙を作成し、その値と名前のディクショナリをビルドできます。
 
           var map = EnumNamedValues<Rainbow>();
foreach (var pair in map)
    Console.WriteLine($"{pair.Key}:\t{pair.Value}");
 関連項目
System.Collections.Generic
C# プログラミング ガイド ジェネリックの概要 ジェネリック クラス
new 制約
   enum Rainbow
{
    Red,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet
}
 
       ジェネリック クラスは、特定のデータ型に固有ではない操作をカプセル化します。 ジェネリック クラスは最も一般的に、リンク リス ト、ハッシュ テーブル、スタック、キュー、ツリーなどのコレクションと共に使用されます。 コレクションの項目を追加または削除する などの操作は、保存されているデータの型に関係なく、基本的に同じように実行されます。
コレクション クラスを必要とするほとんどのシナリオで、.NET クラス ライブラリで提供されているものを使用するという方法が推奨さ れます。 これらのクラスの使用の詳細については、「.NET のジェネリック コレクション」を参照してください。
通常、ジェネリック クラスを作成するには、既存の具象クラスから始め、汎用性と使いやすさの間で最適なバランスが取れるま で、一度に 1 つずつ型を型パラメーターに変更します。 独自のジェネリック クラスを作成するときの重要な考慮事項は次のとお りです。
型パラメーターに汎用化する型。
通例、パラメーター化できる型が多ければ多いほど、コードの柔軟性が上がり、再利用しやすくなります。 ただし、汎用 化が多すぎると、他の開発者にとって読みにくい、理解しにくいコードが生成されます。
型パラメーターに適用する制約 (制約がある場合) (「型パラメーターの制約」を参照)。
処理しなければならない型を処理できる範囲で最大の制約を適用することが推奨されます。 たとえば、ジェネリック クラ スが参照型でのみ使用される場合、クラス制約を適用します。 それにより、意図しない、値型でのクラスの使用が回避 され、 T で as 演算子を使用したり、null 値を確認したりできます。
基底クラスやサブクラスの要因としてジェネリック動作を考慮するかどうか。
ジェネリック クラスは基底クラスとして機能できるので、非ジェネリック クラスと同様の設計考慮事項がここで適用されま す。 ジェネリック基底クラスからの継承ルールについて、このトピックの後半で確認してください。
1 つまたは複数のジェネリック インターフェイスを実装するかどうか。 たとえば、ジェネリック基盤のコレクションで項目を作成するために使用されるクラスを設計するとき、場合によって
は、IComparable<T>のようなインターフェイスを実装する必要があります。ここで T はクラスの型です。 単純なジェネリック クラスの例については、「ジェネリックの概要」を参照してください。 型パラメーターや制約のルールは、特に継承とメンバーのアクセシビリティに関して、ジェネリック クラスの動作と密接な関係があり
 ます。 続行する前に、いくつかの用語を理解してください。 ジェネリック クラス ライアント コードはクラスを参照し、構築されたクローズ型を作成できます ( 定するときなど、型パラメーターを指定せず、構築されたオープン型を作成できます ( 構築されたクローズ型、または構築されたオープン型の基底クラスから継承できます。
の場合、型引数を指定することで、ク )。 あるいは、ジェネリック基底クラスを指
)。 ジェネリック クラスは、具象、
Node<T>,
 Node<int>
 Node<T>
    class BaseNode { }
class BaseNodeGeneric<T> { }
// concrete type
class NodeConcrete<T> : BaseNode { }
//closed constructed type
class NodeClosed<T> : BaseNodeGeneric<int> { }
//open constructed type
class NodeOpen<T> : BaseNodeGeneric<T> { }
 ジェネリック クラス (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 非ジェネリック クラス、言い換えれば、具象クラスは、構築されたクローズ型の基底クラスから継承できますが、構築されたオープ ン型のクラスや型パラメーターからは継承できません。ランタイム時、基底クラスのインスタンス化に必要な型引数をクライアント コードが提供できないためです。
    //No error
class Node1 : BaseNodeGeneric<int> { }
//Generates an error
//class Node2 : BaseNodeGeneric<T> {}
//Generates an error
//class Node3 : T {}
 構築されたオープン型から継承するジェネリック クラスは、継承クラスで共有されない基底クラスの型パラメーターに対して型引 数を提供する必要があります。次のコードをご覧ください。
    class BaseNodeMultiple<T, U> { }
//No error
class Node4<T> : BaseNodeMultiple<T, int> { }
//No error
class Node5<T, U> : BaseNodeMultiple<T, U> { }
//Generates an error
//class Node6<T> : BaseNodeMultiple<T, U> {}
 構築されたオープン型から継承するジェネリック クラスは、基底クラスの制約のスーパーセットである (基底クラスの制約を暗黙に 定義する) 制約を指定する必要があります。
ジェネリック型では、次のように、複数の型パラメーターと制約を使用できます。
構築されたオープン型と構築されたクローズ型をメソッド パラメーターとして使用できます。
    class NodeItem<T> where T : System.IComparable<T>, new() { }
class SpecialNodeItem<T> : NodeItem<T> where T : System.IComparable<T>, new() { }
     class SuperKeyType<K, V, U>
    where U : System.IComparable<U>
    where V : new()
{}
     void Swap<T>(List<T> list1, List<T> list2)
{
    //code to swap items
}
void Swap(List<int> list1, List<int> list2)
{
    //code to swap items
}
 ジェネリック クラスでインターフェイスを実装する場合、そのクラスのすべてのインスタンスをそのインターフェイスにキャストできます。
ジェネリッククラスは変化しません。言い換えると、入力パラメーターが List<BaseClass> を指定するとき、 List<DerivedClass> を指定するとコンパイル時エラーが表示されます。
  
      関連項目
System.Collections.Generic
C# プログラミング ガイド ジェネリック 列挙子の状態を保存する 継承パズル、パート 1

        ジェネリック コレクション クラスのインターフェイスか、コレクション内の項目を表すジェネリック クラスのインターフェイスを定義すると、 多くの場合、便利です。 ジェネリック クラスの優先設定の意図は、値型に対するボックス化とボックス化解除を回避する目的 で、IComparable ではなく IComparable<T> など、ジェネリック インターフェイスを利用することにあります。 .NET クラス ライブ ラリにより、System.Collections.Generic 名前空間のコレクション クラスと共に利用するためのジェネリック インターフェイスがいく つか定義されます。
インターフェイスが型パラメーターの制約として指定される場合、インターフェイスを実装する型のみを利用できます。 GenericList<T> クラスから派生する クラスを示したのが次のコードサンプルです。詳細については、「ジェネ
   リックの概要」を参照してください。 SortedList<T> の
要素は単純なクラスである
により制約 where T : IComparable<T> が追加されます。 これにより、 メソッドは、一覧要素でジェネリックCompareToメソッドを利用できます。この例では、一覧
です。これは IComparable<Person> を実装します。
 BubbleSort
SortedList<T>
 SortedList<T>
   Person
   ジェネリック インターフェイス (C# プログラミ
ング ガイド) 2021/03/16 • • Edit Online
  //Type parameter T in angle brackets.
public class GenericList<T> : System.Collections.Generic.IEnumerable<T>
{
    protected Node head;
    protected Node current = null;
    // Nested class is also generic on T
    protected class Node
    {
        public Node next;
        private T data;  //T as private member datatype
        public Node(T t)  //T used in non-generic constructor
        {
next = null;
data = t; }
        public Node Next
        {
            get { return next; }
            set { next = value; }
        }
        public T Data  //T as return type of property
        {
            get { return data; }
            set { data = value; }
        }
}
    public GenericList()  //constructor
    {
head = null; }
    public void AddHead(T t)  //T as method parameter type
    {
        Node n = new Node(t);
        n.Next = head;
        head = n;
}

      // Implementation of the iterator
    public System.Collections.Generic.IEnumerator<T> GetEnumerator()
    {
        Node current = head;
        while (current != null)
        {
            yield return current.Data;
            current = current.Next;
        }
}
    // IEnumerable<T> inherits from IEnumerable, therefore this class
    // must implement both the generic and non-generic versions of
    // GetEnumerator. In most cases, the non-generic method can
    // simply call the generic method.
    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
public class SortedList<T> : GenericList<T> where T : System.IComparable<T>
{
    // A simple, unoptimized sort algorithm that
    // orders list elements from lowest to highest:
    public void BubbleSort()
    {
        if (null == head || null == head.Next)
        {
return; }
        bool swapped;
do {
Node previous = null;
Node current = head;
swapped = false;
while (current.next != null)
{
    //  Because we need to call this method, the SortedList
    //  class is constrained on IComparable<T>
    if (current.Data.CompareTo(current.next.Data) > 0)
    {
        Node tmp = current.next;
        current.next = current.next.next;
        tmp.next = current;
        if (previous == null)
        {
head = tmp; }
else {
            previous.next = tmp;
        }
        previous = tmp;
        swapped = true;
    }
else {
        current = current.next;
    }
    }
} while (swapped);
previous = current;
  
} while (swapped);
  } }
// A simple class that implements IComparable<T> using itself as the
// type argument. This is a common design pattern in objects that
// are stored in generic lists.
public class Person : System.IComparable<Person>
{
    string name;
int age;
    public Person(string s, int i)
    {
name = s;
age = i; }
    // This will cause list elements to be sorted on age values.
    public int CompareTo(Person p)
    {
        return age - p.age;
    }
    public override string ToString()
    {
        return name + ":" + age;
    }
    // Must implement Equals.
    public bool Equals(Person p)
    {
        return (this.age == p.age);
    }
}
public class Program
{
    public static void Main()
    {
        //Declare and instantiate a new generic SortedList class.
        //Person is the type argument.
        SortedList<Person> list = new SortedList<Person>();
        //Create name and age values to initialize Person objects.
        string[] names = new string[]
        {
            "Franscoise",
            "Bill",
            "Li",
            "Sandra",
            "Gunnar",
            "Alok",
            "Hiroyuki",
            "Maria",
            "Alessandro",
            "Raul"
        };
        int[] ages = new int[] { 45, 19, 28, 23, 18, 9, 108, 72, 30, 35 };
        //Populate the list.
        for (int x = 0; x < 10; x++)
        {
            list.AddHead(new Person(names[x], ages[x]));
        }
        //Print out unsorted list.
        foreach (Person p in list)
        {
  
     {
 次のように、複数のインターフェイスを単一の型で制約として指定できます。
1 つのインターフェイスで、次のように、複数の型パラメーターを定義できます。
クラスに適用される継承規則は、インターフェイスにも適用されます。
ジェネリック インターフェイスが共変の場合、つまり、その型パラメーターを戻り値としてのみ利用する場合、ジェネリック インター フェイスは非ジェネリック インターフェイスから継承できます。 .NET クラス ライブラリでは、IEnumerable<T> は IEnumerable か ら継承します。これは、IEnumerable<T>がGetEnumeratorの戻り値とCurrentプロパティゲッターの T のみを利用するた めです。
具象クラスは、次のように、構築されたクローズ型インターフェイスを実装できます。
ジェネリック クラスは、クラス パラメーターの一覧からインターフェイスが必要とするすべての引数が提供される限り、ジェネリック イ ンターフェイスや構築されたクローズ型インターフェイスを実装できます。
    class Stack<T> where T : System.IComparable<T>, IEnumerable<T>
{
}
     interface IDictionary<K, V>
{
}
     interface IMonth<T> { }
interface IJanuary     : IMonth<int> { }  //No error
interface IFebruary<T> : IMonth<int> { }  //No error
interface IMarch<T>    : IMonth<T> { }    //No error
//interface IApril<T>  : IMonth<T, U> {}  //Error
     interface IBaseInterface<T> { }
class SampleClass : IBaseInterface<string> { }
     interface IBaseInterface1<T> { }
interface IBaseInterface2<T, U> { }
class SampleClass1<T> : IBaseInterface1<T> { }          //No error
class SampleClass2<T> : IBaseInterface2<T, string> { }  //No error
                System.Console.WriteLine(p.ToString());
        }
        System.Console.WriteLine("Done with unsorted list");
        //Sort the list.
        list.BubbleSort();
        //Print out sorted list.
        foreach (Person p in list)
        {
            System.Console.WriteLine(p.ToString());
        }
        System.Console.WriteLine("Done with sorted list");
    }
}
 
      メソッドのオーバーロードを制御する規則は、ジェネリック クラス、ジェネリック構造体、ジェネリック インターフェイス内のメソッドの規 則と同じです。 詳細については、「ジェネリック メソッド」を参照してください。
関連項目
C# プログラミング ガイド ジェネリックの概要 interface
ジェネリック

    ジェネリック メソッドは、次のように型パラメーターで宣言されるメソッドです。
メソッドの呼び出し方法の1つを示しているのが次のコードサンプルです。型引数に int を利用します。
    static void Swap<T>(ref T lhs, ref T rhs)
{
    T temp;
    temp = lhs;
    lhs = rhs;
    rhs = temp;
}
     public static void TestSwap()
{
    int a = 1;
    int b = 2;
    Swap<int>(ref a, ref b);
    System.Console.WriteLine(a + " " + b);
}
 型引数は省略することもできます。コンパイラが推定します。次は、前の呼び出しと同じように Swap を呼び出します。
型推定の同じ規則が静的メソッドとインスタンス メソッドに適用されます。 コンパイラは、渡されたメソッド引数に基づいて型パラ メーターを推定できます。制約や戻り値だけでは型パラメーターを推定できません。 そのため、パラメーターのないメソッドでは型 を推定できません。 型はコンパイル時に、コンパイラがオーバーロードされたメソッド シグネチャを解決する前に推定されます。 コ ンパイラは、同じ名前を共有するすべてのジェネリック メソッドに型の推定ロジックを適用します。 オーバーロード解決手順で は、型を推定できたジェネリック メソッドのみがコンパイラに含まれます。
ジェネリック クラス内では、非ジェネリック メソッドは、次のように、クラスレベルの型パラメーターにアクセスできます。
包含クラスと同じ型パラメーターを受け取るジェネリック メソッドを定義すると、コンパイラでは警告 CS0693 が生成されます。こ れは、メソッド範囲内で、内側の T に与えられた引数により外側の T に与えられた引数が隠されるためです。クラスがインス タンス化されたときに与えらたれ型パラメーター以外の型パラメーターでジェネリック クラス メソッドを呼び出すという柔軟性が必要 な場合、メソッドの型パラメーターに別の識別子を指定することを検討してください。次の例の GenericList2<T> をご覧くださ い。
  Swap(ref a, ref b);
     class SampleClass<T>
{
    void Swap(ref T lhs, ref T rhs) { }
}
  ジェネリック メソッド (C# プログラミング ガイ
ド)
2020/11/02 • • Edit Online
 
        メソッドの型パラメーターでさらに多くの特殊操作を可能にするために、制約を使用します。 SwapIfGreater<T> という名前が 付けられた Swap<T> のこのバージョンは、IComparable<T>を実装する型引数との併用でのみ利用できます。
     void SwapIfGreater<T>(ref T lhs, ref T rhs) where T : System.IComparable<T>
{
    T temp;
    if (lhs.CompareTo(rhs) > 0)
    {
} }
temp = lhs;
lhs = rhs;
rhs = temp;
 ジェネリック メソッドは、いくつかの型パラメーターでオーバーロードできます。 たとえば、次のメソッドはすべて同じクラスに配置でき ます。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。
関連項目
System.Collections.Generic
C# プログラミング ガイド ジェネリックの概要 メソッド
    void DoWork() { }
void DoWork<T>() { }
void DoWork<T, U>() { }
    class GenericList<T>
{
// CS0693
    void SampleMethod<T>() { }
}
class GenericList2<T>
{
//No warning
    void SampleMethod<U>() { }
}
 
            C# 2.0 以降、下限が 0 の一次元配列は自動的に IList<T> を実装します。 これにより、同じコードで配列や他のコレクション 型を反復処理できるジェネリック メソッドを作成できます。 この手法は主に、コレクションのデータを読み込むときに便利です。 IList<T> インターフェイスを使用して配列の要素を追加したり、削除したりすることはできません。 このコンテキストの配列 で、RemoveAt のような、IList<T> メソッドを呼び出そうとすると、例外がスローされます。
次のコード例からは、IList<T> 入力パラメーターを受け取る単一のジェネリック メソッドがリストと配列 (この例では、整数の配 列) の両方を反復処理できることがわかります。
    class Program
{
    static void Main()
    {
        int[] arr = { 0, 1, 2, 3, 4 };
        List<int> list = new List<int>();
        for (int x = 5; x < 10; x++)
        {
            list.Add(x);
        }
        ProcessItems<int>(arr);
        ProcessItems<int>(list);
    }
    static void ProcessItems<T>(IList<T> coll)
    {
        // IsReadOnly returns True for the array and False for the List.
        System.Console.WriteLine
            ("IsReadOnly returns {0} for this collection.",
            coll.IsReadOnly);
        // The following statement causes a run-time exception for the
        // array, but not for the List.
        //coll.RemoveAt(4);
        foreach (T item in coll)
        {
            System.Console.Write(item.ToString() + " ");
        }
        System.Console.WriteLine();
    }
}
 関連項目
System.Collections.Generic
C# プログラミング ガイド ジェネリック
配列
ジェネリック
ジェネリックと配列 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    デリゲートはその独自の型パラメーターを定義できます。 ジェネリック デリゲートを参照するコードは、次の例に示すように、ジェネ リック クラスをインスタンス化したり、ジェネリック メソッドを呼び出したりするときのように、型引数を指定し、構築されたクローズ型 を作成できます。
C# バージョン 2.0 には、メソッド グループ変換という新しい機能があります。これはジェネリック デリゲート型だけでなく具象型に も適用され、前の行を次のような簡素化された構文で記述できます。
ジェネリック クラス内で定義されたデリゲートは、クラス メソッドと同様の方法でジェネリック クラスの型パラメーターを利用できま す。
デリゲートを参照するコードで、次のように、包含クラスの型引数を指定する必要があります。
ジェネリック デリゲートは、典型的な設計パターンに基づいてイベントを定義する場合に特に便利です。sender 引数は厳密に 型指定できること、Object との間でキャストが必要ないことがその理由です。
    public delegate void Del<T>(T item);
public static void Notify(int i) { }
Del<int> m1 = new Del<int>(Notify);
   Del<int> m2 = Notify;
     class Stack<T>
{
    T[] items;
    int index;
    public delegate void StackDelegate(T[] items);
}
     private static void DoWork(float[] items) { }
public static void TestStack()
{
    Stack<float> s = new Stack<float>();
    Stack<float>.StackDelegate d = DoWork;
}
 汎用デリゲート (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
          関連項目
System.Collections.Generic
C# プログラミング ガイド ジェネリックの概要 ジェネリック メソッド ジェネリック クラス ジェネリック インターフェイス デリゲート
ジェネリック
   delegate void StackEventHandler<T, U>(T sender, U eventArgs);
class Stack<T>
{
    public class StackEventArgs : System.EventArgs { }
    public event StackEventHandler<Stack<T>, StackEventArgs> stackEvent;
    protected virtual void OnStackChanged(StackEventArgs a)
    {
        stackEvent(this, a);
    }
}
class SampleClass
{
    public void HandleStackChange<T>(Stack<T> stack, Stack<T>.StackEventArgs args) { }
}
public static void Test()
{
    Stack<double> s = new Stack<double>();
    SampleClass o = new SampleClass();
    s.stackEvent += o.HandleStackChange;
}
 
       C# ジェネリックと C++ テンプレートのいずれも、パラメーター化された型のサポートを提供する言語機能です。 ただし、これら 2 つにはさまざまな違いがあります。 構文レベルでは、C# ジェネリックの場合、パラメーター化された型の取り扱いが単純であり、 C++ テンプレートのような複雑さがありません。 さらに、C++ テンプレートで提供されるすべての機能が、C# でも提供されるわ けではありません。 実装レベルでは、C# ジェネリック型の代入は実行時に行われ、その結果、インスタンス化されたオブジェクト のジェネリック型情報が保存されるという点が最も大きな違いです。 詳細については、「ランタイムのジェネリック」を参照してくださ い。
C# ジェネリックと C++ テンプレートの主な違いを以下に示します。
C# ジェネリックは、C++ テンプレートほど柔軟ではありません。 たとえば、C# ジェネリック クラスでは、ユーザー定義演算
子は呼び出すことができますが、算術演算子を呼び出すことはできません。
C# では、 template C<int i> {} などの非型テンプレート パラメーターを使用できません。
C# は、明示的な特殊化 (特定の型のテンプレートのカスタム実装) をサポートしません。
C# は、部分的な特殊化 (型引数のサブセットのカスタム実装) をサポートしません。
C# では、型パラメーターをジェネリック型の基底クラスとして使用できません。
C# では、型パラメーターに既定の型を割り当てることができません。
C# では、構築された型はジェネリックとして使用できますが、ジェネリック型パラメーター自体はジェネリックにできません。 C++ では、テンプレート パラメーターを使用できます。
C++ では、テンプレート内のすべての型パラメーターに対して有効でない可能性のあるコードを使用できます。このよう なコードは、型パラメーターとして使用されている特定の型に対してチェックされます。 C# では、制約を満たすすべての 型で正常に動作するようにクラスのコードを記述する必要があります。 たとえば、C++ では、型パラメーターのオブジェク トで算術演算子 + および - を使用し、これらの演算子をサポートしない型を使ってテンプレートをインスタンス化する とエラーを生成する関数を記述できます。 C# では、このような関数は許可されません。許可される言語構成要素は、 制約から推定できるものだけに限られます。
関連項目
C# プログラミング ガイド ジェネリックの概要 テンプレート
 C++ テンプレートと C# ジェネリックの違い (C#
プログラミング ガイド) 2020/11/02 • • Edit Online
 
         ジェネリック型またはメソッドが Microsoft 中間言語 (MSIL) にコンパイルされるとき、型パラメーターありとして識別するメタデータ が追加されます。 ジェネリック型の MSIL の使われ方は、指定した型パラメーターの種類 (値型または参照型) によって異なりま す。
ジェネリック型が値型をパラメーターとして最初に構築されるとき、ランタイムにより、特殊なジェネリック型が作成されます。このと き、MSIL の適切な場所で指定のパラメーターが代わりに使用されます。 特殊なジェネリック型は、パラメーターとして使用される 一意の値型ごとに 1 回作成されます。
たとえば、プログラム コードで、整数で構成されるスタックを宣言したとします。
この時点で、整数がそのパラメーターに合わせて置き換えられた Stack<T> クラスの特殊なバージョンがランタイムにより生成さ れます。 プログラム コードで整数のスタックを使用するたびに、ランタイムは、生成された特殊な Stack<T> クラスを再利用しま す。次の例では、整数のスタックの2つのインスタンスが作成され、Stack<int> コードの単一インスタンスを共有します。
ただし、long のような異なる値型を持つか、パラメーターとしてユーザー定義構造を持つ別のStack<T>クラスがコード内の 別のポイントで作成されると想定します。 結果として、ランタイムによりジェネリック型の別バージョンが生成され、MSIL 内の適 切な場所で long を代わりに使います。特殊なジェネリッククラスにはそれぞれ、ネイティブで値型が含まれているため、変換 は必要ありません。
参照型の場合、ジェネリックの動作は少し異なります。 何らかの参照型でジェネリック型を初めて構築するとき、ランタイムは、 MSIL のパラメーターの代わりに使用されているオブジェクト参照を利用して特殊なジェネリック型を作成します。 その後、構築さ れた型が参照型をそのパラメーターとしてインスタンス化されるたびに、型に関係なく、ランタイムは、以前に利用した特殊なバー ジョンのジェネリック型を再利用します。 すべての参照のサイズが同じであるため、これが可能になります。
たとえば、 Customer クラスと Order クラスという 2 つの参照型があるとき、 Customer 型のスタックを作成したとします。
この時点で、オブジェクト参照を格納する Stack<T> クラスの特殊なバージョンがランタイムにより生成されます。データを保存し なくても、後にオブジェクト参照にデータが入力されます。次のコード行により、Order という名前のもう1つの参照型のスタック が作成されるとします。
  Stack<int> stack;
      Stack<int> stackOne = new Stack<int>();
Stack<int> stackTwo = new Stack<int>();
       class Customer { }
class Order { }
   Stack<Customer> customers;
   Stack<Order> orders = new Stack<Order>();
 値型とは異なり、Stack<T>クラスのもう1つの特殊なバージョンは Order 型に対して作成されません。代わりに、Stack<T>
ランタイムのジェネリック (C# プログラミング
ガイド) 2020/11/02 • • Edit Online
 
          クラスの特殊なバージョンのインスタンスが作成され、それを参照するように   変数が設定されます。 その後、 型のスタックを作成するコード行が見つかったとします。
Order 型を利用して作成されたStack<T>クラスの前の使用と同様に、特殊なStack<T>クラスのもう1つのインスタンスが 作成されます。 そこに含まれるポインターは、 Customer 型のサイズのメモリ領域を参照するように設定されています。 参照型 はプログラムによって大きく異なることがあるため、ジェネリックの C# 実装では、コードの量が大幅に、参照型のジェネリック クラス のコンパイラにより作成された特殊なクラスの数まで減ります。
また、ジェネリック C# クラスが値型または参照型パラメーターの利用によりインスタンス化されるとき、ランタイム時にリフレクション がクエリを実行し、その型パラメーターを確かめることができます。
関連項目
System.Collections.Generic
C# プログラミング ガイド ジェネリックの概要 ジェネリック
  customers = new Stack<Customer>();
orders
Customer
    
                  共通言語ランタイム (CLR) は実行時にジェネリック型の情報にアクセスできるため、非ジェネリック型の場合と同じように、リフレク ションを使用してジェネリック型の情報を取得できます。 詳細については、「ランタイムのジェネリック」を参照してください。
.NET Framework 2.0 では、ジェネリック型の実行時の情報を有効にする新しいメンバーが Type クラスにいくつか追加されてい ました。 それらのメソッドとプロパティの使用方法の詳細については、そのクラスのドキュメントを参照してください。 System.Reflection.Emit 名前空間にも、ジェネリックをサポートする新しいメンバーが追加されています。 「方法:リフレクション 出力を使用してジェネリック型を定義する」をご覧ください。
ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、IsGenericType プロパティの解説を参照して ください。
SYSTEM.TYPE
IsGenericType 型がジェネリックである場合に true を返します。
GetGenericTypeDefinition 現在構築されている型の基になるジェネリック型定義を返します。
       GetGenericArguments
   構築された型に対して指定された型引数、またはジェネリック型定義 の型パラメーターを表す Type オブジェクトの配列を返します。
    GetGenericParameterConstraints
   現在のジェネリック型パラメーターの制約を表す Type オブジェクトの 配列を返します。
   ContainsGenericParameters
  型 (またはそこに含まれているいずれかの型またはメソッド) に、具体的 な型の指定されていない型パラメーターが含まれている場合に true を返します。
   GenericParameterAttributes
 現在のジェネリック型パラメーターの特殊な制約を説明する GenericParameterAttributes フラグの組み合わせを取得しま
す。
    GenericParameterPosition
  型パラメーターを表す Type オブジェクトの場合、その型パラメーター が宣言されたジェネリック型定義またはジェネリック メソッド定義の型パ ラメーター リストにおけるその位置を取得します。
   IsGenericParameter
   現在の Type が、ジェネリック型定義またはジェネリック メソッド定義 の型パラメーターを表すかどうかを示す値を取得します。
   IsGenericTypeDefinition
 現在の Type が、他のジェネリック型を構築できるジェネリック型の定 義を表しているかどうかを示す値を取得します。 その型がジェネリック 型の定義を表している場合に true を返します。
   DeclaringMethod
   現在のジェネリック型パラメーターを定義したジェネリック メソッドを返し ます。その型パラメーターがジェネリック メソッドによって定義されたもの ではない場合は null を返します。
 ジェネリックとリフレクション (C# プログラミ
ング ガイド) 2020/11/02 • • Edit Online
 
                SYSTEM.TYPE
    MakeGenericType 型の配列の要素を現在のジェネリック型定義の型パラメーターで置き 換え、結果の構築型を表す Type オブジェクトを返します。
さらに、MethodInfo クラスのメンバーは、ジェネリック メソッドの実行時の情報を有効にします。 ジェネリック メソッドのリフレクショ ンで使用する用語に関する一定の条件の一覧については、IsGenericMethod プロパティの解説を参照してください。
  SYSTEM.REFLECTION.MEMBERINFO
IsGenericMethod GetGenericArguments
GetGenericMethodDefinition
IsGenericMethodDefinition
関連項目
C# プログラミング ガイド ジェネリック リフレクションとジェネリック型 ジェネリック
メソッドがジェネリックである場合に true を返します。 構築されたジェネリック メソッドの型引数、またはジェネリック メソッド定
義の型パラメーターを表す Type オブジェクトの配列を返します。 現在構築されているメソッドの基になるジェネリック メソッド定義を返し
ます。
現在の MethodInfo がジェネリック メソッドの定義を表している場合 に true を返します。
               ContainsGenericParameters
   メソッド (またはそこに含まれているいずれかの型) に、具体的な型の 指定されていない型パラメーターが含まれている場合に true を返し ます。
     MakeGenericMethod
  現在のジェネリック メソッド定義の型パラメーターを型の配列要素に 置き換え、その結果構築されるメソッドを表す MethodInfo オブジェ クトを返します。
 
      属性は、非ジェネリック型の場合と同様に、ジェネリック型に適用できます。 属性の適用については、「属性」を参照してくださ い。
カスタム属性は、型引数が与えられないオープン ジェネリック型と、すべての型パラメーターに引数が与えられる、構築クローズ ジェネリック型のみ参照が許可されます。
次の例では、このカスタム属性が使用されています。
属性は、オープン ジェネリック型を参照できます。
適切な数のコンマを利用し、複数の型パラメーターを指定します。この例では、GenericClass2 には2つの型パラメーターが あります。
属性は、構築クローズ ジェネリック型を参照できます。
ジェネリック型パラメーターを参照する属性は、コンパイル時エラーを引き起こします。
ジェネリック型は Attribute から継承できません。
実行時にジェネリック型または型パラメーターに関する情報を取得するには、System.Reflection のメソッドを利用できます。 詳 細については、「ジェネリックとリフレクション」を参照してください。
    class CustomAttribute : System.Attribute
{
    public System.Object info;
}
     public class GenericClass1<T> { }
[CustomAttribute(info = typeof(GenericClass1<>))]
class ClassA { }
      public class GenericClass2<T, U> { }
[CustomAttribute(info = typeof(GenericClass2<,>))]
class ClassB { }
     public class GenericClass3<T, U, V> { }
[CustomAttribute(info = typeof(GenericClass3<int, double, string>))]
class ClassC { }
     //[CustomAttribute(info = typeof(GenericClass3<int, T, string>))]  //Error
class ClassD<T> { }
   //public class CustomAtt<T> : System.Attribute {}  //Error
 ジェネリックと属性 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   関連項目
C# プログラミング ガイド ジェネリック
属性

            C# プログラミングでは、名前空間が 2 つの方法でよく使用されます。 最初の方法では、次のように .NET で名前空間を使用 して、その多くのクラスを整理します。
Systemは名前空間で、Consoleはその名前空間内のクラスです。以下の例のように、using キーワードを使用できるた め、完全な名前は必要ありません。
詳細については、「using ディレクティブ」をご覧ください。
2 つ目の方法では、独自の名前空間を宣言します。これは、より大きなプログラミング プロジェクトでクラス名とメソッド名のス
コープを制御するのに役立ちます。 名前空間を宣言するには、以下の例のように、namespace キーワードを使用します。
  System.Console.WriteLine("Hello World!");
   using System;
   Console.WriteLine("Hello World!");
     namespace SampleNamespace
{
    class SampleClass
    {
        public void SampleMethod()
        {
} }
}
System.Console.WriteLine(
  "SampleMethod inside SampleNamespace");
 名前空間の名前を、有効な C# の識別子名にする必要があります。
名前空間の概要 名前空間には次の特徴があります。
大きなコード プロジェクトを整理します。
. 演算子を使用して、区切られます。
using ディレクティブを使用すると、クラスごとに名前空間の名前を指定する必要がなくなります。
global 名前空間は"ルート"名前空間です。global::System は常に.NET名前空間のSystemを参照します。
C# 言語仕様
詳細については、C# 言語仕様に関する記事の「名前空間」に関するセクションを参照してください。
関連項目
  C# プログラミング ガイド
名前空間 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
      名前空間の使用
My 名前空間を使用する方法 識別子名
using ディレクティブ
::演算子

     C# プログラム内では名前空間が 2 つの方法でよく使用されます。 最初の方法では、.NET クラスで名前空間を使用して、その 多くのクラスを整理します。 2 つ目の方法では、独自の名前空間を宣言します。これは、より大きなプログラミング プロジェクト でクラス名とメソッド名のスコープを制御するのに役立ちます。
名前空間へのアクセス
ほとんどのC#アプリケーションは using ディレクティブのセクションから始まります。このセクションには、アプリケーションが頻繁に 使用する名前空間がリストされ、包含されているメソッドが使用されるたびにプログラマが完全修飾名を指定しなくても済むよう にします。
たとえば、次の行を記述したとします。
この場合、プログラムの開始位置で、以下のコードを使用できます。
これは次のコードの代わりに使用します。
名前空間エイリアス
using ディレクティブを使って、名前空間のエイリアスを作成することもできます。エイリアス化された名前空間のメンバーにアク セスするには、名前空間エイリアス修飾子 :: を使います。次の例では、名前空間エイリアスを作成して使用する方法を示 します。
  using System;
   Console.WriteLine("Hello, World!");
   System.Console.WriteLine("Hello, World!");
 名前空間の使用 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   名前空間を用いたスコープの制御
namespace キーワードを使用して、スコープを宣言します。プロジェクト内でスコープを作成すると、コードの編成が容易にな り、グローバルに一意の型を作成できます。次の例では、入れ子関係にある2つの名前空間で SampleClass というクラスを 定義します。 . トークンを使用して、呼び出されるメソッドを区別します。
     using generics = System.Collections.Generic;
namespace AliasExample
{
    class TestClass
    {
        static void Main()
        {
            generics::Dictionary<string, int> dict = new generics::Dictionary<string, int>()
            {
                ["A"] = 1,
                ["B"] = 2,
                ["C"] = 3
};
            foreach (string name in dict.Keys)
            {
                System.Console.WriteLine($"{name} {dict[name]}");
            }
            // Output:
            // A 1
            // B 2
            // C 3
} }
}
 
    完全修飾名 名前空間と型には、論理階層を示す完全修飾名で表された一意のタイトルが割り当てられています。 たとえば、ステートメン
ト A.B は、 A が名前空間または型の名前であり、 B はその内部で入れ子になっていることを意味します。
入れ子になっているクラスと名前空間を次の例に示します。 完全修飾名は、各エンティティの後のコメントとして示されていま す。
  namespace SampleNamespace
{
    class SampleClass
    {
        public void SampleMethod()
        {
            System.Console.WriteLine(
              "SampleMethod inside SampleNamespace");
} }
    // Create a nested namespace, and define another class.
    namespace NestedNamespace
    {
        class SampleClass
        {
            public void SampleMethod()
            {
} }
}
System.Console.WriteLine(
  "SampleMethod inside NestedNamespace");
class Program
{
    static void Main(string[] args)
    {
} }
}
// Displays "SampleMethod inside SampleNamespace."
SampleClass outer = new SampleClass();
outer.SampleMethod();
// Displays "SampleMethod inside SampleNamespace."
SampleNamespace.SampleClass outer2 = new SampleNamespace.SampleClass();
outer2.SampleMethod();
// Displays "SampleMethod inside NestedNamespace."
NestedNamespace.SampleClass inner = new NestedNamespace.SampleClass();
inner.SampleMethod();

   上のコード セグメントの各要素の意味は次のとおりです。
名前空間 N1 はグローバル名前空間のメンバーです。その完全修飾名は N1 です。 名前空間 N2 は N1 のメンバーです。その完全修飾名は N1.N2 です。
クラス C1 は N1 のメンバーです。 その完全修飾名は N1.C1 です。
クラス名 C2 は、このコードでは2回使用されています。ただし、完全修飾名は異なります。 C2 の最初のインスタン スは C1 内で宣言されているため、その完全修飾名は となります。 C2 の2つ目のインスタンスは名前空 間 N2 内で宣言されているため、その完全修飾名は となります。
上のコードセグメントを使用して、次のように新しいクラスメンバー C3 を名前空間 N1.N2 に追加することができます。
通常、名前空間エイリアス修飾子 :: は名前空間エイリアスを参照するために使い、 global:: はグローバル名前空間を参 照するために使います。 . は型またはメンバーを修飾するために使います。
名前空間ではなく型を参照するエイリアスで :: を使用するのは誤りです。次に例を示します。
 N1.C1.C2
 N1.N2.C2
    namespace N1.N2
{
class C3 {
}
}
// N1.N2.C3
    using Alias = System.Console;
     class TestClass
{
    static void Main()
    {
        // Error
        //Alias::WriteLine("Hi");
// OK
        Alias.WriteLine("Hi");
    }
}
   global という語は定義済みのエイリアスではないため、 global.X には特別な意味がないことに注意してください。 :: と共 に使用したときにのみ特別な意味が与えられます。
   namespace N1
{
class C1 {
class C2 {
}
// N1
// N1.C1
// N1.C1.C2
} }
}
namespace N2  // N1.N2
{
class C2 {
}
// N1.N2.C2
 
       は常にグローバル名前空間を参照し、エイリアスを参照しないので、global という名前のエイリアスを定義すると、コ ンパイラ警告 CS0440 が生成されます。 たとえば、次のコード行では警告が生成されます。
エイリアスで :: を使用することをお勧めします。そうすれば、追加の型が予想外に導入されることを防ぐことができます。たとえ ば、次の例について考えてみます。
  using global = System.Collections;   // Warning
   using Alias = System;
     namespace Library
{
    public class C : Alias::Exception { }
}
  このコードは動作しますが、 Alias という名前の型が後で導入された場合、 Alias. は代わりにその型にバインドされます。 Alias::Exception を使用すれば、 Alias は名前空間エイリアスとして扱われ、型と間違われることがなくなります。
関連項目
C# プログラミング ガイド 名前空間
メンバー アクセス式
:: 演算子
extern エイリアス
  global::
 
     Microsoft.VisualBasic.MyServices名前空間(VisualBasicでは My)を使用すると、いくつもの.NETクラスに簡単かつ直 感的にアクセスでき、コンピューター、アプリケーション、設定、リソースなどと対話するコードを記述できます。 MyServices 名前 空間は、もともとは Visual Basic で使用するものとして設計されましたが、C# アプリケーションでも使用できます。
VisualBasicで MyServices 名前空間を使用する方法の詳細については、Myを使用した開発に関するページを参照して ください。
参照を追加する
MyServices クラスをソリューションで使用する前に、VisualBasicライブラリへの参照を追加する必要があります。
Visual Basic ライブラリへの参照を追加する
1. ソリューション エクスプローラーで、 [参照設定] ノードを右クリックし、 [参照の追加] をクリックします。
2. [参照設定] ダイアログ ボックスが表示されたら、一覧を下にスクロールし、Microsoft.VisualBasic.dll を選択します。 プログラムの先頭の using セクションに次の行を追加することもできます。
例
次の例では、 MyServices 名前空間に含まれているさまざまな静的メソッドを呼び出します。 このコードをコンパイルするには、 Microsoft.VisualBasic.DLL への参照をプロジェクトに追加する必要があります。
     using Microsoft.VisualBasic.Devices;
  My 名前空間を使用する方法 (C# プログラミング
ガイド) 2020/11/02 • • Edit Online
 
        MyServices 名前空間のクラスの中にはC#アプリケーションから呼び出すことができないクラスもあります。たとえ ば、FileSystemProxy クラスは、C# と互換性がありません。 そのような場合は、同様に VisualBasic.dll に含まれている FileSystem を構成する静的メソッドを代わりに使用できます。 このようなメソッドを使用してディレクトリを複製する方法を次に 示します。
関連項目
C# プログラミング ガイド 名前空間 名前空間の使用
    // Duplicate a directory
Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(
    @"C:\original_directory",
    @"C:\copy_of_original_directory");
    using System;
using Microsoft.VisualBasic.Devices;
class TestMyServices
{
    static void Main()
    {
        // Play a sound with the Audio class:
        Audio myAudio = new Audio();
        Console.WriteLine("Playing sound...");
        myAudio.Play(@"c:\WINDOWS\Media\chimes.wav");
        // Display time information with the Clock class:
        Clock myClock = new Clock();
        Console.Write("Current day of the week: ");
        Console.WriteLine(myClock.LocalTime.DayOfWeek);
        Console.Write("Current date and time: ");
        Console.WriteLine(myClock.LocalTime);
        // Display machine information with the Computer class:
        Computer myComputer = new Computer();
        Console.WriteLine("Computer name: " + myComputer.Name);
        if (myComputer.Network.IsAvailable)
        {
            Console.WriteLine("Computer is connected to network.");
        }
else {
            Console.WriteLine("Computer is not connected to network.");
        }
} }
 
          タイプ セーフとセキュリティを維持するために、既定では C# はポインター演算をサポートしません。 ただし、unsafe キーワードを 使用すれば、ポインターを使用できる unsafe コンテキストを定義できます。 ポインターについて詳しくは、ポインター型に関する ページをご覧ください。
    NOTE
共通言語ランタイム (CLR) では、アンセーフ コードは検査できないコードと呼ばれます。 C# のアンセーフ コードは、必ずしも危険ではありま せん。ただ、CLR で安全性を検査できないコードであるというだけです。 そのため CLR は、完全に信頼できるアセンブリ内にある場合にのみ、 アンセーフ コードを実行します。 アンセーフ コードを使用する場合は、セキュリティ上のリスクやポインター エラーが発生しないように注意してく ださい。
 アンセーフ コードの概要 アンセーフ コードには次の特徴があります。
メソッド、型、およびコード ブロックをアンセーフとして定義できます。
アンセーフ コードでアプリケーションのパフォーマンスが向上することがあります。これは、配列のバインド チェックが削除さ れるためです。
アンセーフ コードは、ポインターを必要とするネイティブ関数を呼び出すときに必要です。
アンセーフ コードを使用すると、セキュリティと安定性の面でリスクが生じます。
unsafe ブロックを含むコードは、-unsafe コンパイラ オプションを使ってコンパイルする必要があります。
関連項目 詳細については次を参照してください:
ポインター型 固定サイズ バッファー
C# 言語仕様
詳細については、C# 言語仕様のアンセーフ コードに関するトピックを参照してください。
関連項目
C# プログラミングガイド unsafe
アンセーフ コードとポインター (C# プログラミ
ング ガイド) 2021/03/06 • • Edit Online
 
   C# では、fixed ステートメントを使って、データの構造体に固定サイズの配列を持ったバッファーを作成することができます。 固 定サイズのバッファーは、他の言語またはプラットフォームのデータ ソースと相互運用するメソッドを作成するときに便利です。 こ の固定配列には、標準的な構造体メンバーで許容されている属性または修飾子であれば、何でも適用することができます。 ただし配列の型は bool 、 byte 、 char 、 short 、 int 、 long 、 sbyte 、 ushort 、 uint 、 ulong 、 float 、 double のいずれかに該当する必要があり、それが唯一の制限となります。
Remarks
セーフ コードでは、配列を含む C# 構造体に配列要素が含まれません。 この場合、構造体には、配列の要素ではなく、その
参照が格納されます。 unsafe のコード ブロックで使われている struct に、固定サイズの配列を埋め込むことができます。 struct が参照であるため、次の pathName のサイズは配列内の要素の数に依存しません。
アンセーフ コードでは、 struct に埋め込み配列を含めることができます。 以下の例の fixedBuffer 配列は固定サイズで す。 fixed ステートメントを使用して、先頭要素へのポインターを確立します。このポインターを使用して配列の要素にアクセ スします。 fixed ステートメントによって、 fixedBuffer インスタンス フィールドがメモリ内の特定の位置に固定されます。
    private fixed char name[30];
       public struct PathArray
{
    public char[] pathName;
    private int reserved;
}
    固定サイズ バッファー (C# プログラミング ガイ
ド)
2020/11/02 • • Edit Online
 
     要素数128の char 配列のサイズは256バイトです。固定サイズのchar型バッファーは、エンコーディングに関係なく常に、 1 文字あたり 2 バイトを消費します。 これは、char 型のバッファーが、 CharSet = CharSet.Auto または
CharSet = CharSet.Ansi で API メソッドや構造体にマーシャリングされたときにも当てはまります。 詳細については、 「CharSet」を参照してください。
上記の例は、固定せずに fixed フィールドにアクセスする方法を示しています。この方法はC#7.3以降から使用できます。 一般的な固定サイズの配列としては、他にもbool配列があります。 bool 配列内の要素のサイズは常に1バイトです。
bool 配列は、ビット配列やバッファーの作成には適していません。
固定サイズ バッファーは System.Runtime.CompilerServices.UnsafeValueTypeAttributeを使用してコンパイルされます。こ れにより、オーバーフローする可能性があるアンマネージド配列が型に含まれていることが共通言語ランタイム (CLR) に指示され ます。 これは stackalloc を使用して作成されたメモリに似ています。これにより、CLR 内でバッファー オーバーラン検出機能が 自動的に有効になります。 前の例では、 unsafe struct に固定サイズ バッファーがどのようにして存在できるかを示していま す。
Buffer 用にコンパイラで生成されたC#は、次のように属性が付けられます。
       internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
     internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
internal unsafe class Example
{
    public Buffer buffer = default;
}
private static void AccessEmbeddedArray()
{
    var example = new Example();
unsafe {
} }
// Pin the buffer to a fixed location in memory.
fixed (char* charPtr = example.buffer.fixedBuffer)
{
    *charPtr = 'A';
}
// Access safely through the index:
char c = example.buffer.fixedBuffer[0];
Console.WriteLine(c);
// Modify through the index:
example.buffer.fixedBuffer[0] = 'B';
Console.WriteLine(example.buffer.fixedBuffer[0]);
 
      固定サイズ バッファーは、次の点で通常の配列とは異なります。
unsafe のコンテキストでのみ使用できます。
構造体のインスタンス フィールドのみを指定できます。
これらは常にベクター (1 次元配列) です。
宣言には、 fixed char id[8] などの長さを含める必要があります。 fixed char id[] は使用できません。
関連項目
C# プログラミング ガイド アンセーフ コードとポインター fixed ステートメント 相互運用性
     internal struct Buffer
{
    [StructLayout(LayoutKind.Sequential, Size = 256)]
    [CompilerGenerated]
    [UnsafeValueType]
    public struct <fixedBuffer>e__FixedBuffer
    {
        public char FixedElementField;
}
    [FixedBuffer(typeof(char), 128)]
    public <fixedBuffer>e__FixedBuffer fixedBuffer;
}
 
       unsafe コンテキストの型には、ポインター型、値型、または参照型を設定できます。 ポインター型の宣言は、次のいずれかの形 式になります。
ポインター型の * の前に指定された型は、参照型と呼ばれます。参照型にできるのはアンマネージド型だけです。
ポインター型はobjectを継承せず、ポインター型と object の間で変換を行う方法はありません。また、ボックス化とボックス 化解除もポインターをサポートしません。 ただし、異なるポインター型の間で変換したり、ポインター型と整数型の間で変換した りすることはできます。
同じ 1 つの宣言で複数のポインターを宣言する場合、アスタリスク (*) は基底の型だけに記述します。各ポインター名のプレ フィックスとしては使用しません。 次に例を示します。
オブジェクト参照は、それを指すポインターがあってもガベージ コレクションされる可能性があるため、ポインターによって参照や参 照を含む構造体を指すことはできません。 ガベージ コレクターは、オブジェクトを指すポインター型があるかどうかを追跡しませ ん。
myType* 型のポインター変数の値は、 myType 型の変数のアドレスです。 ポインター型の宣言の例を次に示します。
    type* identifier;
void* identifier; //allowed but not recommended
      int* p1, p2, p3;   // Ok
int *p1, *p2, *p3;   // Invalid in C#
        int* p
int** p
int*[] p
char* p
void* p
p は、整数へのポインターです。
p は、整数へのポインターのポインターです。
p は、整数へのポインターの 1 次元配列です。 p は、char へのポインターです。
p は、未知の型へのポインターです。
                      ポインター間接演算子 * を使用すると、ポインター変数が指す位置にあるコンテンツにアクセスできます。 たとえば、次のような 宣言があるとします。
この例の式 *myVariable は、 int に含まれているアドレスの位置にある myVariable 変数を示しています。
トピック「fixed ステートメント」および「ポインター変換」に、ポインターの例がいくつか記載されています。 次の例は、 unsafe キーワードと fixed ステートメントの使用例と、内部ポインターのインクリメント方法を示しています。このコードは、コンソールア プリケーションの Main 関数に貼り付けて実行することができます これらの例は、-unsafe コンパイラ オプションを設定してコンパ
  int* myVariable;
    ポインター型 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 イルする必要があります。
    // Normal pointer to an object.
int[] a = new int[5] { 10, 20, 30, 40, 50 };
// Must be in unsafe code to use interior pointers.
unsafe
{
    // Must pin object on heap so that it doesn't move while using interior pointers.
    fixed (int* p = &a[0])
    {
} }
// p is pinned as well as object, so create another pointer to show incrementing it.
int* p2 = p;
Console.WriteLine(*p2);
// Incrementing p2 bumps the pointer by four bytes due to its type ...
p2 += 1;
Console.WriteLine(*p2);
p2 += 1;
Console.WriteLine(*p2);
Console.WriteLine("--------");
Console.WriteLine(*p);
// Dereferencing p and incrementing changes the value of a[0] ...
*p += 1;
Console.WriteLine(*p);
*p += 1;
Console.WriteLine(*p);
Console.WriteLine("--------");
Console.WriteLine(a[0]);
/*
Output:
10
20
30
--------
10
11
12
--------
12
*/
 間接演算子は、void* 型のポインターに適用できません。ただし、voidポインターと他のポインター型はキャストを使用して 相互に変換できます。
ポインターは、null にできます。nullポインターに間接演算子を適用すると、実装で定義されている動作が発生します。
ポインターをメソッド間で引き渡すと、未定義の動作が発生する可能性があります。 たとえば、 in 、 out または ref パラ メーターを介してポインターをローカル変数に返したり、関数の結果として返したりするメソッドがあるとします。 ポインターが固定 ブロックに設定されていた場合は、そのポインターが指す変数が既に固定されていない可能性があります。
次の表は、unsafe コンテキストでポインターに使用できる演算子とステートメントの一覧を示しています。 /
* ポインターの間接参照を実行します。
-> ポインター経由で構造体のメンバーにアクセスします。 [] ポインターにインデックスを付けます。
              
         /
    &
++ および --
+ および -
== 、 != 、 < 、 > 、 <= 、 >= stackalloc
fixed ステートメント
変数のアドレスを取得します。 ポインターをインクリメントおよびデクリメントします。 ポインター演算を実行します。
ポインターを比較します。
スタックにメモリを割り当てます。 変数を一時的に固定して、そのアドレスを取得できるようにします。
                       ポインター関連の演算子について詳しくは、「ポインターに関連する演算子」をご覧ください。 C# 言語仕様
詳しくは、「C# 言語仕様」の「ポインター型」をご覧ください。 関連項目
C# プログラミング ガイド アンセーフ コードとポインター ポインター変換
参照型
値型
unsafe

   定義済みの暗黙的なポインター変換を次の表に示します。 暗黙的な変換は、メソッドの呼び出しや代入ステートメントなど、 多くの状況で発生することがあります。
暗黙的なポインター変換
FROM
任意のポインター型 void*
null 任意のポインター型 明示的なポインター変換は、暗黙的な変換がない場合に、キャスト式を使用して、変換を実行するために使用します。 次の
          表はこの変換についてまとめたものです。 明示的なポインター変換
FROM
任意のポインター型 sbyte、byte、short、ushort、int、uint、long または ulong 任意のポインター型
例
その他のポインター型
任意のポインター型 sbyte、byte、short、ushort、int、uint、long または ulong
              次の例では、 int へのポインターは byte へのポインターに変換されます。 ポインターは、変数の最下位バイト アドレスを指 すことに注意してください。 int のサイズ(4バイト)まで結果を連続してインクリメントする場合、変数の残りのバイトを表示す ることができます。
  // compile with: -unsafe
 ポインター変換 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      関連項目
C# プログラミング ガイド ポインター型
参照型
値型
unsafe
fixed ステートメント stackalloc
   class ClassConvert
{
    static void Main()
    {
        int number = 1024;
unsafe {
} }
// Convert to byte:
byte* p = (byte*)&number;
System.Console.Write("The 4 bytes of the integer:");
// Display the 4 bytes of the int variable:
for (int i = 0 ; i < sizeof(int) ; ++i)
{
    System.Console.Write(" {0:X2}", *p);
    // Increment the pointer:
    p++;
}
System.Console.WriteLine();
System.Console.WriteLine("The value of the integer: {0}", number);
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
}
/* Output:
        The 4 bytes of the integer: 00 04 00 00
        The value of the integer: 1024
    */
 
   次の例では、ポインターを使って 1 つの配列から別の配列にバイトをコピーします。
この例では、unsafeキーワードを使います。このキーワードは、Copy メソッドでのポインターの使用を可能にします。fixedス テートメントを使って、コピー元とコピー先の配列へのポインターを宣言します。 fixed ステートメントを使って、コピー元配列とコ ピー先配列のメモリ内での位置を"固定"し、ガベージコレクションによって移動されないようにします。 fixed ブロックが完了 すると、これらの配列のメモリブロックは固定解除されます。この例の Copy メソッドは unsafe キーワードを使っているので、- unsafe コンパイラ オプションを指定してコンパイルする必要があります。
この例では、2番目のアンマネージドポインターではなくインデックスを使って、両方の配列の要素にアクセスします。 pSource と pTarget のポインターの宣言を使って配列を固定します。この機能は、C#7.3以降から使用できます。
例
      ポインターを使用してバイトの配列をコピーする
方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
  static unsafe void Copy(byte[] source, int sourceOffset, byte[] target,
    int targetOffset, int count)
{
    // If either array is not instantiated, you cannot complete the copy.
    if ((source == null) || (target == null))
    {
        throw new System.ArgumentException();
    }
    // If either offset, or the number of bytes to copy, is negative, you
    // cannot complete the copy.
    if ((sourceOffset < 0) || (targetOffset < 0) || (count < 0))
    {
        throw new System.ArgumentException();
    }
    // If the number of bytes from the offset to the end of the array is
    // less than the number of bytes you want to copy, you cannot complete
    // the copy.
    if ((source.Length - sourceOffset < count) ||
        (target.Length - targetOffset < count))
    {
        throw new System.ArgumentException();
    }
    // The following fixed statement pins the location of the source and
    // target objects in memory so that they will not be moved by garbage
    // collection.
    fixed (byte* pSource = source, pTarget = target)
    {
        // Copy the specified number of bytes from source to target.
        for (int i = 0; i < count; i++)
        {
            pTarget[targetOffset + i] = pSource[sourceOffset + i];
        }
} }
static void UnsafeCopyArrays()
{
// Create two arrays of the same length.

    // Create two arrays of the same length.
    関連項目
C# プログラミング ガイド アンセーフ コードとポインター -unsafe (C# コンパイラ オプション) ガベージ コレクション
     int length = 100;
    byte[] byteArray1 = new byte[length];
    byte[] byteArray2 = new byte[length];
    // Fill byteArray1 with 0 - 99.
    for (int i = 0; i < length; ++i)
    {
        byteArray1[i] = (byte)i;
    }
    // Display the first 10 elements in byteArray1.
    System.Console.WriteLine("The first 10 elements of the original are:");
    for (int i = 0; i < 10; ++i)
    {
        System.Console.Write(byteArray1[i] + " ");
    }
    System.Console.WriteLine("\n");
    // Copy the contents of byteArray1 to byteArray2.
    Copy(byteArray1, 0, byteArray2, 0, length);
    // Display the first 10 elements in the copy, byteArray2.
    System.Console.WriteLine("The first 10 elements of the copy are:");
    for (int i = 0; i < 10; ++i)
    {
        System.Console.Write(byteArray2[i] + " ");
    }
    System.Console.WriteLine("\n");
    // Copy the contents of the last 10 elements of byteArray1 to the
    // beginning of byteArray2.
    // The offset specifies where the copying begins in the source array.
    int offset = length - 10;
    Copy(byteArray1, offset, byteArray2, 0, length - offset);
    // Display the first 10 elements in the copy, byteArray2.
    System.Console.WriteLine("The first 10 elements of the copy are:");
    for (int i = 0; i < 10; ++i)
    {
        System.Console.Write(byteArray2[i] + " ");
    }
    System.Console.WriteLine("\n");
    /* Output:
The first 10 elements of the original are: 0123456789
The first 10 elements of the copy are: 0123456789
        The first 10 elements of the copy are:
        90 91 92 93 94 95 96 97 98 99
    */
}

           C# では、ソース コード内で、コメントの対象となるコード ブロック直前の特別なコメント フィールド (トリプル スラッシュで示す) に XML 要素を配置することで、コード用のドキュメントを作成できます。例を次に示します。
-doc オプションを使用してコンパイルすると、コンパイラは、ソース コード内のすべての XML タグを検索して、XML ドキュメント ファイルを作成します。 コンパイラによって生成されたファイルに基づいて最終的なドキュメントを作成するには、カスタム ツールを 作成するか、DocFX や Sandcastle などのツールを使用します。
XML 要素を参照するには (たとえば、XML ドキュメント コメントに記述する特定の XML 要素を関数で処理する場合)、標準 の引用のしくみを使用できます ( < と > )。 コード参照 ( cref ) 要素でジェネリック識別子を参照するには、エスケープ文字 (たとえば、 cref="List&lt;T&gt;" ) または中かっこ ( cref="List{T}" ) を使用できます。 特殊なケースとして、コンパイラは中 かっこを山かっことして解析し、ジェネリック識別子を参照するときにドキュメント コメントの編集があまり面倒にならないようにして います。
このセクションの内容
ドキュメント コメント用の推奨タグ
XML ファイルの処理
ドキュメント タグの区切り記号
XML ドキュメント機能を使用する方法
関連項目 詳細については次を参照してください:
-doc (ドキュメント コメントの処理) C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
    /// <summary>
///  This class performs an important function.
/// </summary>
public class MyClass {}
       NOTE
XML ドキュメント コメントはメタデータではなく、コンパイルされたアセンブリに含まれないため、リフレクションでアクセスできません。
 C# プログラミング ガイド
XML ドキュメント コメント (C# プログラミング
ガイド) 2020/11/02 • • Edit Online
 
                     コード内のドキュメント コメントは、C# コンパイラによって処理され、 /doc コマンド ライン オプションで指定した名前のファイルに XML 形式で出力されます。 コンパイラによって生成されたファイルに基づいて最終的なドキュメントを作成するには、カスタム ツールを作成するか、DocFX や Sandcastle などのツールを使用します。
タグは、型や型メンバーなどのコード コンストラクターに対して処理されます。
コンパイラは、有効な XML のタグをすべて処理します。 ユーザー ドキュメントで一般的に使用される機能を提供するタグを次 の表に示します。
    NOTE
ドキュメント コメントは、名前空間に適用できません。
 Tags
<c>
<code> <example> <exception>* <include>* <list>
<para> <param>* <paramref> <permission>* <remarks> <inheritdoc>
<see>* <value> <seealso>*
<summar y>
<typeparam>*
<typeparamref> <returns>
                                                    (* は、コンパイラによって構文が検証されることを示します。) ドキュメントコメントのテキストに山かっこを表示する場合は、< と > のHTMLエンコードを使用します。これはそれぞれ、
&lt; と &gt; になります。このエンコードは次の例に示されています。
関連項目
C# プログラミング ガイド
-doc (C# コンパイラ オプション) XML ドキュメント コメント
    /// <summary>
/// This property always returns a value &lt; 1.
/// </summary>
 ドキュメント コメント用の推奨タグ (C# プログ
ラミング ガイド) 2020/11/02 • • Edit Online
 
    コンパイラは、ドキュメントを生成するためにタグ付けされたコードのコンストラクトごとに、ID 文字列を生成します。 (コードをタグ 付けする方法については、ドキュメント コメント用の推奨タグに関するページを参照してください。)ID 文字列によって、コンストラ クトは一意に識別されます。 XML ファイルを処理するプログラムは、ID 文字列を使用して、対応する .NET のメタデータまたは ドキュメントを適用するリフレクション項目を識別できます。
ID 文字列
.xml ファイルは、コードの階層表現ではなく、 要素ごとに生成された ID を持つフラット リストです。 コンパイラは、次の規則に基づいて ID 文字列を生成します。
文字列に空白文字は含まれません。
この文字列の最初の部分は、単一の文字とそれに続くコロンで識別されるメンバーの種類を示します。 使用されるメン バー型は次のとおりです。
   N
   名前空間
   ドキュメント コメントを名前空間に追加す ることはできませんが、名前空間への cref 参照を行うことはできます (サポートされて いる場合)。
 T 型
F フィールド P proper ty
M メソッド
E イベント
クラス、インターフェイス、構造体、列挙 型、またはデリゲートの型です。
インデクサーまたはその他のインデックス付 きプロパティが含まれます。
コンストラクターや演算子などの特殊なメ ソッドが含まれます。
                            !
    エラー文字列
   あとに続く文字列で、エラーの情報を示し ます。 C# コンパイラは、解決できないリン クのエラー情報を生成します。
 文字列の 2 番目の部分は、項目の完全修飾名で、名前空間のルートから始まります。 項目の名前、それを囲む型、 名前空間は、ピリオドで区切られます。 項目の名前自体にピリオドがある場合、名前のピリオドはハッシュ記号 ('#') に 置き換えられます。 項目の名前には、ハッシュ記号がないことが前提です。 たとえば、String コンストラクターの完全修 飾名は "System.String.#ctor" です。
プロパティおよびメソッドについては、パラメーターのリストをかっこで囲み、プロパティとメソッドに続けて指定します。 パラ メーターがない場合、かっこはありません。 パラメーターはコンマで区切ります。 各パラメーターのエンコードは、.NET のシ グネチャでのエンコード方法にそのまま従います。
基本データ型。 通常の型 (ELEMENT_TYPE_CLASS または ELEMENT_TYPE_VALUETYPE) は、型の完全
XML ファイルの処理 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 修飾名で表されます。
(ELEMENT_TYPE_I4、ELEMENT_TYPE_OBJECT、ELEMENT_TYPE_STRING、 ELEMENT_TYPE_TYPEDBYREF、および ELEMENT_TYPE_VOID などの) 組み込み型は、対応する完全な型 の完全修飾名で表されます。 たとえば、System.Int32 や System.TypedReference です。
ELEMENT_TYPE_PTR は、修飾される型に続けて '*' と表されます。 ELEMENT_TYPE_BYREF は、修飾される型に続けて '@' と表されます。
ELEMENT_TYPE_PINNED は、修飾される型に続けて '^' と表されます。 これは C# コンパイラでは生成されま せん。
ELEMENT_TYPE_CMOD_REQ は、修飾される型に続けて "|" と修飾子クラスの完全修飾名で表されます。 これは C# コンパイラでは生成されません。
ELEMENT_TYPE_CMOD_OPT は、修飾される型に続けて "!" と修飾子クラスの完全修飾名で表されます。 ELEMENT_TYPE_SZARRAY は、配列の要素型に続けて "[]" と表されます。
ELEMENT_TYPE_GENERICARRAY は、配列の要素型に続けて "[?]" と表されます。 これは C# コンパイラで は生成されません。
ELEMENT_TYPE_ARRAY は、[lowerbound: size ,lowerbound: size ] の形式で表されます。ここで、コンマ の個数はランク -1 個であり、各次元の下限とサイズは明らかな場合は、10 進数で表されます。 下限またはサ イズの指定がない場合は省略されます。 特定の次元で下限およびサイズが省略されている場合は、':' も省略 されます。 たとえば、ある 2 次元配列の下限が 1 で、サイズの指定がない場合は、[1:,1:] と表されます。
ELEMENT_TYPE_FNPTRは、"=FUNC:type(signature)"と表されます。ここで、type は戻り値の型であ り、signature はメソッドの引数です。 引数がない場合、かっこは省略されます。 これは C# コンパイラでは生成 されません。
次に示すシグネチャ コンポーネントは、オーバーロードされるメソッドの区別には使用されないため、表されません。 呼び出し規則
戻り値の型
ELEMENT_TYPE_SENTINEL
変換演算子(op_Implicit および op_Explicit)の場合のみ、メソッドの戻り値が"~"としてエンコードされ、それに 続けて戻り値の型が表されます。
ジェネリック型では、型の名前の後に、バックチック、ジェネリック型パラメーターの数を示す数値が順に続きます。 次に例 を示します。
<member name="T:SampleClass`2"> は、 public class SampleClass<T, U> として定義されている型のタグです。 パラメーターとしてジェネリック型を受け取るメソッドでは、ジェネリック型パラメーターは、バックチック付きの数値 (`0、`1 な
ど) として指定されます。 各数値は、型のジェネリック パラメーターに対する、0 から始まる配列表記を表しています。
使用例
次の例は、クラスおよびそのメンバーの ID 文字列を生成する方法を示します。
        namespace N {
    /// <summary>
    /// Enter description here for class X.
    /// ID string generated is "T:N.X".
    /// </summary>
public unsafe class X

public unsafe class X
  {
    /// <summary>
    /// Enter description here for the first constructor.
    /// ID string generated is "M:N.X.#ctor".
    /// </summary>
    public X() { }
    /// <summary>
    /// Enter description here for the second constructor.
    /// ID string generated is "M:N.X.#ctor(System.Int32)".
    /// </summary>
    /// <param name="i">Describe parameter.</param>
    public X(int i) { }
    /// <summary>
    /// Enter description here for field q.
    /// ID string generated is "F:N.X.q".
    /// </summary>
    public string q;
    /// <summary>
    /// Enter description for constant PI.
    /// ID string generated is "F:N.X.PI".
    /// </summary>
    public const double PI = 3.14;
    /// <summary>
    /// Enter description for method f.
    /// ID string generated is "M:N.X.f".
    /// </summary>
    /// <returns>Describe return value.</returns>
    public int f() { return 1; }
    /// <summary>
    /// Enter description for method bb.
    /// ID string generated is "M:N.X.bb(System.String,System.Int32@,System.Void*)".
    /// </summary>
    /// <param name="s">Describe parameter.</param>
    /// <param name="y">Describe parameter.</param>
    /// <param name="z">Describe parameter.</param>
    /// <returns>Describe return value.</returns>
    public int bb(string s, ref int y, void* z) { return 1; }
    /// <summary>
    /// Enter description for method gg.
    /// ID string generated is "M:N.X.gg(System.Int16[],System.Int32[0:,0:])".
    /// </summary>
    /// <param name="array1">Describe parameter.</param>
    /// <param name="array">Describe parameter.</param>
    /// <returns>Describe return value.</returns>
    public int gg(short[] array1, int[,] array) { return 0; }
    /// <summary>
    /// Enter description for operator.
    /// ID string generated is "M:N.X.op_Addition(N.X,N.X)".
    /// </summary>
    /// <param name="x">Describe parameter.</param>
    /// <param name="xx">Describe parameter.</param>
    /// <returns>Describe return value.</returns>
    public static X operator +(X x, X xx) { return x; }
    /// <summary>
    /// Enter description for property.
    /// ID string generated is "P:N.X.prop".
    /// </summary>
    public int prop { get { return 1; } set { } }
/// <summary>
  /// Enter description for event.

    関連項目
C# プログラミング ガイド
-doc (C# コンパイラ オプション) XML ドキュメント コメント
   } }
/// Enter description for event.
/// ID string generated is "E:N.X.d".
/// </summary>
public event D d;
/// <summary>
/// Enter description for property.
/// ID string generated is "P:N.X.Item(System.String)".
/// </summary>
/// <param name="s">Describe parameter.</param>
/// <returns></returns>
public int this[string s] { get { return 1; } }
/// <summary>
/// Enter description for class Nested.
/// ID string generated is "T:N.X.Nested".
/// </summary>
public class Nested { }
/// <summary>
/// Enter description for delegate.
/// ID string generated is "T:N.X.D".
/// </summary>
/// <param name="i">Describe parameter.</param>
public delegate void D(int i);
/// <summary>
/// Enter description for operator.
/// ID string generated is "M:N.X.op_Explicit(N.X)~System.Int32".
/// </summary>
/// <param name="x">Describe parameter.</param>
/// <returns>Describe return value.</returns>
public static explicit operator int(X x) { return 1; }
 
    XML ドキュメント コメントでは区切り記号を使用し、ドキュメント コメントの開始位置と終了位置をコンパイラに示す必要があり ます。 XML ドキュメント タグでは、次の種類の区切り記号を使用できます。
///
単一行の区切り記号。 これは、ドキュメント例に示されている形式であり、C# プロジェクト テンプレートで使用されま す。 区切り記号の直後に空白文字が続く場合、その文字は XML 出力に含まれません。
/** */
複数行の区切り記号。
/** */ 区切り記号を使用する場合は、次のいくつかの書式設定規則に従う必要があります。
/** 区切り記号がある行で、行の残りの部分が空白の場合、その行はコメントとして処理されません。 /** 区切り記号の後の最初の文字が空白の場合、その空白文字は無視され、行の残りの部分が処理されます。 それ以外の場合、 /** 区切り記号の後にある行のテキスト全体が、コメントの一部として処理されます。
*/ 区切り記号がある行で、 */ 区切り記号までの部分がすべて空白の場合、その行は無視されます。 それ 以外の場合、その行の */ 区切り記号までのテキストが、コメントの一部として処理されます。
/** 区切り記号で始まる行の後に来る行については、コンパイラは各行の先頭で共通のパターンを検索しま す。このパターンは、空白(省略可能)+アスタリスク(*)+空白(省略可能)で構成されます。 /** 区切り 記号または */ 区切り記号で始まらない各行の先頭でコンパイラが共通のパターンを見つけた場合、各行のそ のパターンは無視されます。
これらの規則について、次の例で説明します。
次のコメントでは、<summary> で始まる行だけがコメントの一部として処理されます。次の3つのタグ形式は、 いずれも同じコメントを生成します。
    NOTE
Visual Studio IDE (統合開発環境) では、コード エディターで /// 区切り記号を入力すると、 <summary> タグと </summary> タグが自動的に挿入され、これらのタグの内側にカーソルが移動します。 [オプション] ダイアログ ボックスで、この機
能をオンまたはオフにできます。
          /** <summary>text</summary> */
/**
<summary>text</summary>
*/
/**
* <summary>text</summary>
*/
 コンパイラによって、2 行目と 3 行目の先頭で共通のパターン " * " が識別されます。 このパターンは出力に含ま れません。
ドキュメント タグの区切り記号 (C# プログラミ
ング ガイド) 2020/11/02 • • Edit Online
 
        /**
* <summary>
* text </summary>*/
 次のコメントでは、3 行目の 2 番目の文字がアスタリスクではないため、コンパイラは共通のパターンを検索しま せん。 このため、2 行目と 3 行目のすべてのテキストがコメントの一部として処理されます。
次のコメントでは、2 つの原因によりコンパイラはパターンを検出しません。 まず、アスタリスクの前の空白の数が 一致していません。 次に、5 行目がタブで始まっています。空白とタブは一致しません。 このため、2 行目から 5 行目のすべてのテキストがコメントの一部として処理されます。
関連項目
C# プログラミング ガイド
XML ドキュメント コメント -doc (C# コンパイラ オプション)
    /**
* <summary>
   text </summary>
*/
     /**
  * <summary>
  * text
*  text2
    *  </summary>
*/
 
   次の例では、ドキュメント化された型の基本的な概要について説明します。 例
   XML ドキュメント機能を使用する方法 2020/11/02 • • Edit Online
  // If compiling from the command line, compile with: -doc:YourFileName.xml
/// <summary>
/// Class level summary documentation goes here.
/// </summary>
/// <remarks>
/// Longer comments can be associated with a type or member through
/// the remarks tag.
/// </remarks>
public class TestClass : TestInterface
{
    /// <summary>
    /// Store for the Name property.
    /// </summary>
    private string _name = null;
    /// <summary>
    /// The class constructor.
    /// </summary>
    public TestClass()
    {
        // TODO: Add Constructor Logic here.
    }
    /// <summary>
    /// Name property.
    /// </summary>
    /// <value>
    /// A value tag is used to describe the property value.
    /// </value>
    public string Name
    {
get {
            return _name;
        }
}
    /// <summary>
    /// Description for SomeMethod.
    /// </summary>
    /// <param name="s"> Parameter description for s goes here.</param>
    /// <seealso cref="System.String">
    /// You can use the cref attribute on any tag to reference a type or member
    /// and the compiler will check that the reference exists.
    /// </seealso>
    public void SomeMethod(string s)
    {
    }
if (_name == null)
{
    throw new System.Exception("Name is null");
}
/// <summary>

    この例では、次の内容を含む .xml ファイルが生成されます。
        /// <summary>
    /// Some other method.
    /// </summary>
    /// <returns>
    /// Return values are described through the returns tag.
    /// </returns>
    /// <seealso cref="SomeMethod(string)">
    /// Notice the use of the cref attribute to reference a specific method.
    /// </seealso>
    public int SomeOtherMethod()
    {
return 0; }
    public int InterfaceMethod(int n)
    {
return n * n; }
    /// <summary>
    /// The entry point for the application.
    /// </summary>
    /// <param name="args"> A list of command line arguments.</param>
    static int Main(System.String[] args)
    {
        // TODO: Add code to start application here.
return 0; }
}
/// <summary>
/// Documentation that describes the interface goes here.
/// </summary>
/// <remarks>
/// Details about the interface go here.
/// </remarks>
interface TestInterface
{
    /// <summary>
    /// Documentation that describes the method goes here.
    /// </summary>
    /// <param name="n">
    /// Parameter n requires an integer argument.
    /// </param>
    /// <returns>
    /// The method returns an integer.
    /// </returns>
    int InterfaceMethod(int n);
}
 <?xml version="1.0"?>
<doc>
    <assembly>
        <name>xmlsample</name>
    </assembly>
    <members>
        <member name="T:TestClass">
            <summary>
            Class level summary documentation goes here.
            </summary>
            <remarks>
            Longer comments can be associated with a type or member through
            the remarks tag.
            </remarks>
        </member>
<member name="F:TestClass._name">

    <member name="F:TestClass._name">
        <summary>
        Store for the Name property.
        </summary>
    </member>
    <member name="M:TestClass.#ctor">
        <summary>
        The class constructor.
        </summary>
    </member>
    <member name="P:TestClass.Name">
        <summary>
        Name property.
        </summary>
        <value>
        A value tag is used to describe the property value.
        </value>
    </member>
    <member name="M:TestClass.SomeMethod(System.String)">
        <summary>
        Description for SomeMethod.
        </summary>
        <param name="s"> Parameter description for s goes here.</param>
        <seealso cref="T:System.String">
        You can use the cref attribute on any tag to reference a type or member
        and the compiler will check that the reference exists.
        </seealso>
    </member>
    <member name="M:TestClass.SomeOtherMethod">
        <summary>
        Some other method.
        </summary>
        <returns>
        Return values are described through the returns tag.
        </returns>
        <seealso cref="M:TestClass.SomeMethod(System.String)">
        Notice the use of the cref attribute to reference a specific method.
        </seealso>
    </member>
    <member name="M:TestClass.Main(System.String[])">
        <summary>
        The entry point for the application.
        </summary>
        <param name="args"> A list of command line arguments.</param>
    </member>
    <member name="T:TestInterface">
        <summary>
        Documentation that describes the interface goes here.
        </summary>
        <remarks>
        Details about the interface go here.
        </remarks>
    </member>
    <member name="M:TestInterface.InterfaceMethod(System.Int32)">
        <summary>
        Documentation that describes the method goes here.
        </summary>
        <param name="n">
        Parameter n requires an integer argument.
        </param>
        <returns>
        The method returns an integer.
        </returns>
    </member>
</members>
 </doc>
    
       コードのコンパイル この例をコンパイルするには、次のコマンドを入力します。
 csc XMLsample.cs /doc:XMLsample.xml
このコマンドによって作成されるXMLファイルXMLsample.xmlは、ブラウザーで、または TYPE コマンドを使って、表示できま す。
信頼性の高いプログラミング
XML ドキュメントは、 /// で始まります。 新しいプロジェクトを作成すると、開始の /// 行がいくつか自動的に挿入されま す。 これらのコメントの処理にはいくつか制限があります。
ドキュメントは整形式の XML である必要があります。 XML が整形式ではない場合は、警告が生成され、エラーが発 生したことを示すコメントがドキュメント ファイルに追加されます。
開発者は、独自のタグ セットを自由に作成できます。 推奨されるタグのセットがあります。 推奨されるタグの一部には特 別な意味があります。
<param> タグは、パラメーターの記述に使用します。このタグがあると、コンパイラは、パラメーターが存在するこ と、およびすべてのパラメーターがドキュメントで記述されていることを確認します。 検証が失敗する場合は、コン パイラが警告を生成します。
cref 属性は任意のタグにアタッチされて、コード要素を参照することができます。コンパイラは、このコード要素 が存在することを確認します。 検証が失敗する場合は、コンパイラが警告を生成します。 コンパイラは、 cref 属性で記述されている型を探すとき、 using ステートメントに従います。
<summary> タグは、型またはメンバーに関する追加情報を表示するために、VisualStudio内のIntelliSense によって使用されます。
関連項目
C# プログラミング ガイド
-doc (C# コンパイラ オプション) XML ドキュメント コメント
DocFX ドキュメント プロセッサ Sandcastle ドキュメント プロセッサ
       NOTE
XML ファイルでは、型とメンバーに関する完全な情報は提供されません (たとえば、型の情報は含まれません)。 型またはメ ンバーに関する完全な情報を取得するには、ドキュメント ファイルと併せて、実際の型またはメンバーでリフレクションを使う 必要があります。
 
      構文
パラメーター
text
コードとして指定するテキストです。
Remarks
<c> タグを使用すると、説明内のテキストをコードとしてマークする必要があることを指定できます。複数行をコードとして示す 場合は、<code> を使用します。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
  <c>text</c>
     // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    /// <summary><c>DoWork</c> is a method in the <c>TestClass</c> class.
    /// </summary>
    public static void DoWork(int Int1)
    {
}
    /// text for Main
    static void Main()
    {
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<c> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      構文
パラメーター
content
コードとしてマークするテキストです。
Remarks
<code> タグを使用して、複数行をコードとして指定します。説明内の単一行テキストをコードとしてマークすることを示すに は、<c> を使用します。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
<code> タグの使用例については、<example>の記事を参照してください。 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
  <code>content</code>
    <code> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    XMLドキュメントタグの cref 属性は"コード参照"を意味します。タグの内部テキストが、型、メソッド、プロパティなど、コー ド要素であることを指定します。DocFXやSandcastleのようなドキュメントツールでは cref 属性が使用されて、型やメン バーが文書化されるページのハイパーリンクが自動的に生成されます。
例
次の例は、<see>タグで使用される cref 属性を示しています。
   cref 属性 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
  // Save this file as CRefTest.cs
// Compile with: csc CRefTest.cs -doc:Results.xml
namespace TestNamespace
{
    /// <summary>
    /// TestClass contains several cref examples.
    /// </summary>
    public class TestClass
    {
/// <summary>
/// This sample shows how to specify the <see cref="TestClass"/> constructor as a cref attribute. /// </summary>
public TestClass()
{}
        /// <summary>
        /// This sample shows how to specify the <see cref="TestClass(int)"/> constructor as a cref
attribute.
/// </summary>
public TestClass(int value) {}
        /// <summary>
        /// The GetZero method.
        /// </summary>
        /// <example>
        /// This sample shows how to call the <see cref="GetZero"/> method.
        /// <code>
        /// class TestClass
        /// {
        ///     static int Main()
/// {
        ///         return GetZero();
        ///     }
        /// }
        /// </code>
        /// </example>
        public static int GetZero()
        {
return 0; }
        /// <summary>
        /// The GetGenericValue method.
        /// </summary>
        /// <remarks>
        /// This sample shows how to specify the <see cref="GetGenericValue"/> method as a cref attribute.
        /// </remarks>

   コンパイルすると、このプログラムの XML 出力は次のようになります。 たとえば、 GetZero メソッドの cref 属性がコンパイラに より "M:TestNamespace.TestClass.GetZero" に変換されていることに注意してください。"M:"プレフィックスは"method"とい う意味であり、DocFX や Sandcastle のようなドキュメント ツールで認識される規約です。 プレフィックスの完全一覧について は、「XML ファイルの処理」を参照してください。
    } }
    public static T GetGenericValue<T>(T para)
    {
        return para;
    }
}
/// <summary>
/// GenericClass.
/// </summary>
/// <remarks>
/// This example shows how to specify the <see cref="GenericClass{T}"/> type as a cref attribute.
/// </remarks>
class GenericClass<T>
{
    // Fields and members.
}
class Program
{
static int Main()
{
    return TestClass.GetZero();
}
 
      関連項目
XML ドキュメント コメント ドキュメント コメント用の推奨タグ
  <?xml version="1.0"?>
<doc>
    <assembly>
        <name>CRefTest</name>
    </assembly>
    <members>
        <member name="T:TestNamespace.TestClass">
            <summary>
            TestClass contains several cref examples.
            </summary>
        </member>
        <member name="M:TestNamespace.TestClass.#ctor">
            <summary>
            This sample shows how to specify the <see cref="T:TestNamespace.TestClass"/> constructor as a
cref attribute.
            </summary>
        </member>
        <member name="M:TestNamespace.TestClass.#ctor(System.Int32)">
            <summary>
            This sample shows how to specify the <see cref="M:TestNamespace.TestClass.#ctor(System.Int32)"/>
constructor as a cref attribute.
            </summary>
        </member>
        <member name="M:TestNamespace.TestClass.GetZero">
            <summary>
            The GetZero method.
            </summary>
            <example>
            This sample shows how to call the <see cref="M:TestNamespace.TestClass.GetZero"/> method.
            <code>
            class TestClass
            {
                static int Main()
                {
                    return GetZero();
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TestNamespace.TestClass.GetGenericValue``1(``0)">
            <summary>
            The GetGenericValue method.
            </summary>
            <remarks>
            This sample shows how to specify the <see
cref="M:TestNamespace.TestClass.GetGenericValue``1(``0)"/> method as a cref attribute.
            </remarks>
        </member>
        <member name="T:TestNamespace.GenericClass`1">
            <summary>
            GenericClass.
            </summary>
            <remarks>
            This example shows how to specify the <see cref="T:TestNamespace.GenericClass`1"/> type as a
cref attribute.
            </remarks>
        </member>
    </members>
</doc>

    構文
パラメーター
description
コード例の説明です。
Remarks
<example> タグを使用すると、メソッドまたは他のライブラリメンバーの使用例を指定できます。一般的に、<code>タグが使 用されます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
  <example>description</example>
      <example> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
  // Save this file as CRefTest.cs
// Compile with: csc CRefTest.cs -doc:Results.xml
namespace TestNamespace
{
    /// <summary>
    /// TestClass contains several cref examples.
    /// </summary>
    public class TestClass
    {
/// <summary>
/// This sample shows how to specify the <see cref="TestClass"/> constructor as a cref attribute. /// </summary>
public TestClass()
{}
        /// <summary>
        /// This sample shows how to specify the <see cref="TestClass(int)"/> constructor as a cref
attribute.
/// </summary>
public TestClass(int value) {}
/// <summary>
/// The GetZero method.
/// </summary>
/// <example>
/// This sample shows how to call the <see cref="GetZero"/> method.
/// <code>
/// class TestClass
/// {
///
///
///
static int Main()
{
return GetZero();
/// }

      関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
} }
    ///     }
    /// }
    /// </code>
    /// </example>
    public static int GetZero()
    {
return 0; }
    /// <summary>
    /// The GetGenericValue method.
    /// </summary>
    /// <remarks>
    /// This sample shows how to specify the <see cref="GetGenericValue"/> method as a cref attribute.
    /// </remarks>
    public static T GetGenericValue<T>(T para)
    {
        return para;
    }
}
/// <summary>
/// GenericClass.
/// </summary>
/// <remarks>
/// This example shows how to specify the <see cref="GenericClass{T}"/> type as a cref attribute.
/// </remarks>
class GenericClass<T>
{
    // Fields and members.
}
class Program
{
 static int Main()
{
    return TestClass.GetZero();
}

     構文
パラメーター
cref = " member "
現在のコンパイル環境から使用できる例外の参照。 コンパイラは、指定された例外が存在し、出力の XML で
member が正規要素名に変換されることを確認します。 member は、二重引用符("")で囲む必要があります。 ジェネリック型を参照するよう member を書式設定する方法について詳しくは、XMLファイルの処理に関するページをご
覧ください。
description
例外の説明。
Remarks
<exception> タグを使用すると、スローできる例外を指定できます。このタブは、メソッド、プロパティ、イベント、インデクサーの 定義に適用できます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例外処理の詳細については、「例外と例外処理」を参照してください。
例
  <exception cref="member">description</exception>
           // compile with: -doc:DocFileName.xml
/// Comment for class
public class EClass : System.Exception
{
    // class definition...
}
/// Comment for class
class TestClass
{
    /// <exception cref="System.Exception">Thrown when...</exception>
    public void DoSomething()
    {
        try
        {
        }
        catch (EClass)
        {
} }
}
 <exception> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ

   構文
パラメーター
filename
文書を含む XML ファイルの名前。 ファイル名は、ソース コード ファイルの相対パスを使用して修飾することができます。 filename を単一引用符('')で囲みます。
tagpath
タグ name につながる filename 内のタグのパス。パスを単一引用符('')で囲みます。
name
コメントの前に配置するタグの名前指定子。 name には id が指定されます。
id
コメントの前に配置するタグの ID。 ID は二重引用符 (" ") で囲みます。 Remarks
<include> タグを使用すると、ソースコード内の型とメンバーを記述する別のファイル内のコメントを参照することができます。こ れは文書化のコメントをソース コード ファイル内に直接配置する方法の代替です。 別のファイルにドキュメントを配置すること で、ソース コードから分離して、ソースの制御をドキュメントに適用できます。 1 人のユーザーがソース コード ファイルをチェックア ウトし、他のユーザーがドキュメント ファイルをチェックアウトすることができます。
<include> タグはXMLXPath構文を使用します。 <include> の使用をカスタマイズする方法については、XPathに関する ドキュメントを参照してください。
例
これは、複数ファイルの例です。 <include> を使用する最初のファイルを、次に示します。
  <include file='filename' path='tagpath[@name="id"]' />
         <include> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   2 番目のファイル xml_include_tag.doc には、次のドキュメント コメントが含まれています。
    <MyDocs>
<MyMembers name="test">
<summary>
The summary for this type.
</summary>
</MyMembers>
<MyMembers name="test2">
<summary>
The summary for this other type.
</summary>
</MyMembers>
</MyDocs>
 プログラムの出力
TestおよびTest2クラスをコンパイルするときにコマンドライン -doc:DocFileName.xml. を使うと、以下の出力が生成されます。 Visual Studio では、プロジェクト デザイナーの [ビルド] ウィンドウで、XML ドキュメント コメントのオプションを指定します。 C# コ ンパイラが <include> タグを認識すると、現在のソースファイルではなくxml_include_tag.docでドキュメントのコメントを検索 します。 次に、コンパイラによって DocFileName.xml が生成されます。これは、最終的なドキュメントを生成するため に、Sandcastle などのドキュメント ツールによって使用されるファイルです。
     // compile with: -doc:DocFileName.xml
/// <include file='xml_include_tag.doc' path='MyDocs/MyMembers[@name="test"]/*' />
class Test
{
    static void Main()
    {
    }
}
/// <include file='xml_include_tag.doc' path='MyDocs/MyMembers[@name="test2"]/*' />
class Test2
{
    public void Test()
    {
    }
}
 
    関連項目
C# プログラミング ガイド
ドキュメント コメントとして推奨されるタグ
   <?xml version="1.0"?>
<doc>
    <assembly>
        <name>xml_include_tag</name>
    </assembly>
    <members>
        <member name="T:Test">
            <summary>
The summary for this type.
</summary>
        </member>
        <member name="T:Test2">
            <summary>
The summary for this other type.
</summary>
        </member>
    </members>
</doc>
 
   構文
InheritDoc
基底クラス、インターフェイス、および同様のメソッドから、XML コメントを継承します。 これにより、重複する XML コメントの不
要なコピーと貼り付けを行う必要がなくなり、XML コメントが自動的に同期されたままになります。 解説
基底クラスまたはインターフェイスに XML コメントを追加し、InheritDoc によってそのコメントが実装するクラスにコピーされるよう にします。
同期メソッドに XML コメントを追加し、InheritDoc によってそのコメントが同じメソッドの非同期バージョンにコピーされるようにし ます。
特定のメンバーからコメントをコピーしたい場合は、 cref 属性を使用してそのメンバーを指定できます。 例
  <inheritdoc/>
     // compile with: -doc:DocFileName.xml
/// <summary>
/// You may have some primary information about this class.
/// </summary>
public class MainClass
{
}
///<inheritdoc/>
public class TestClass: MainClass
{
}
     // compile with: -doc:DocFileName.xml
/// <summary>
/// You may have some primary information about this interface.
/// </summary>
public interface ITestInterface
{
}
///<inheritdoc cref="ITestInterface"/>
public class TestClass : ITestInterface
{
}
 <inheritdoc> (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
   関連項目
C# プログラミング ガイド
ドキュメント コメントとして推奨されるタグ

   構文
    <list type="bullet|number|table">
    <listheader>
        <term>term</term>
        <description>description</description>
    </listheader>
    <item>
        <term>term</term>
        <description>description</description>
    </item>
</list>
 パラメーター
term
定義される用語であり、 description で定義されます。 description
行頭文字または番号付きリストの項目、または term の定義です。 Remarks
<listheader> ブロックを使用して、テーブルまたは定義リストの見出し行を定義します。テーブルを定義するときにのみ、見出 しの用語のエントリを指定する必要があります。
     リストの各項目は、 <item> ブロックで指定されます。 定義リストを作成する場合は、 term と する必要があります。 ただし、テーブル、箇条書きリスト、または番号付きリストの場合は、 だけで済みます。
リストまたはテーブルでは、必要な数の <item> ブロックを使用できます。 コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。
例
の両方を指定 のエントリを指定する
description
 description
 <list> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
   // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    /// <summary>Here is an example of a bulleted list:
    /// <list type="bullet">
    /// <item>
    /// <description>Item 1.</description>
    /// </item>
    /// <item>
    /// <description>Item 2.</description>
    /// </item>
    /// </list>
    /// </summary>
    static void Main()
    {
    }
}
 
         構文
パラメーター
content
段落のテキストです。
Remarks
<para> タグは、<summary>、<remarks>、または<returns>などのタグ内で使用します。このタグを使用すると、テキスト に構造を追加することができます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
<para> の使用例については、<summary>を参照してください。 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
  <para>content</para>
    <para> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   構文
パラメーター
name
メソッド パラメーターの名前です。 名前は二重引用符 (" ") で囲みます。 description
パラメーターの説明です。
Remarks
<param> タグは、メソッドのいずれかのパラメーターを記述するために、メソッド宣言のコメントで使用する必要があります。複数 のパラメーターをドキュメント化するには、複数の <param> タグを使用します。
<param> タグのテキストは、IntelliSense、オブジェクトブラウザー、コードコメントWebレポートに表示されます。 コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。
例
  <param name="name">description</param>
         // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    // Single parameter.
    /// <param name="Int1">Used to indicate status.</param>
    public static void DoWork(int Int1)
    {
    }
    // Multiple parameters.
    /// <param name="Int1">Used to indicate status.</param>
    /// <param name="Float1">Used to specify context.</param>
    public static void DoWork(int Int1, float Float1)
    {
    }
    /// text for Main
    static void Main()
    {
    }
}
 関連項目
<param> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   C# プログラミング ガイド ドキュメント コメント用の推奨タグ

     構文
パラメーター
name
参照されるパラメーターの名前です。 名前は二重引用符 (" ") で囲みます。 Remarks
<paramref> タグを使用すると、 <summary> または <remarks> ブロックなどのコード コメント内の単語がパラメーターを参照す ることを示すことができます。 この単語を、太字や斜体のフォントを使うなど、何らかの独自の方法で書式設定するために XML ファイルを処理できます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
  <paramref name="name"/>
        // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    /// <summary>DoWork is a method in the TestClass class.
    /// The <paramref name="int1"/> parameter takes a number.
    /// </summary>
    public static void DoWork(int int1)
    {
    }
    /// text for Main
    static void Main()
    {
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<paramref> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
       構文
パラメーター
cref = " member "
現在のコンパイル環境からの呼び出しに利用できる、メンバーまたはフィールドへの参照。 コンパイラは、指定されたコー ド要素が存在し、出力のXMLで member が正規要素名に変換されることを確認します。memberは、二重引用 符 (" ") で囲む必要があります。
ジェネリック型への cref 参照を作成する方法については、cref 属性に関するページを参照してください。 description
メンバーへのアクセスの説明です。
Remarks
<permission> タグを使用すると、メンバーのアクセスをドキュメント化できます。PermissionSetクラスを使用すると、メンバー へのアクセスを指定できます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
  <permission cref="member">description</permission>
         // compile with: -doc:DocFileName.xml
class TestClass
{
    /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
    public static void Test()
    {
    }
    static void Main()
    {
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<permission> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      構文
パラメーター
Description
メンバーの説明。
Remarks
<remarks> タグを使用して、型の情報を追加し、<summary>で指定された情報を補足します。この情報はオブジェクトブ ラウザー ウィンドウに表示されます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
  <remarks>description</remarks>
       // compile with: -doc:DocFileName.xml
/// <summary>
/// You may have some primary information about this class.
/// </summary>
/// <remarks>
/// You may have some additional information about this class.
/// </remarks>
public class TestClass
{
    /// text for Main
    static void Main()
    {
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<remarks> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
     構文
パラメーター
description
戻り値の説明。
Remarks
<returns> タグは、戻り値を説明するためにメソッドの宣言のコメントで使用する必要があります。 コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。
例
  <returns>description</returns>
       // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    /// <returns>Returns zero.</returns>
    public static int GetZero()
    {
return 0; }
    /// text for Main
    static void Main()
    {
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<returns> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
       構文
パラメーター
cref = " member "
現在のコンパイル環境からの呼び出しに利用できる、メンバーまたはフィールドへの参照。 コンパイラは、指定されたコー ド要素が存在するかどうかを確認し、member を出力XML内の要素名に渡します。メンバーは二重引用符("")で 囲む必要があります。
Remarks
<see> タグを使用すると、テキスト内からリンクを指定できます。テキストが「関連項目」セクションに配置されていることを示す には、<seealso> を使用します。 コード要素のドキュメント ページへの内部ハイパーリンクを作成するには、cref 属性を使用し ます。 また、 href はハイパーリンクとして機能する有効な属性です。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 次の例では、「概要」セクション内の <see> タグを示しています。
  <see cref="member"/>
       // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    /// <summary>DoWork is a method in the TestClass class.
    /// <para>Here's how you could make a second paragraph in a description. <see
cref="System.Console.WriteLine(System.String)"/> for information about output statements.</para>
    /// <seealso cref="TestClass.Main"/>
    /// </summary>
    public static void DoWork(int Int1)
    {
}
    /// text for Main
    static void Main()
    {
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<see> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
       構文
パラメーター
cref = " member "
現在のコンパイル環境からの呼び出しに利用できる、メンバーまたはフィールドへの参照。 コンパイラは、指定されたコー ド要素が存在するかどうかを確認し、member を出力XML内の要素名に渡します。member は二重引用符("")で 囲む必要があります。
ジェネリック型への cref 参照を作成する方法については、cref 属性に関するページを参照してください。 Remarks
<seealso> タグを使用して、「関連項目」セクションに表示するテキストを指定することができます。<see>を使用すると、テキ スト内からリンクを指定できます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
<seealso> の使用例については、<summary> を参照してください。 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
  <seealso cref="member"/>
     <seealso> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
       構文
パラメーター
description
オブジェクトの概要。
Remarks
<summary> タグは、型または型メンバーの説明に使用します。型の説明に補足情報を追加するには、<remarks>を使用 します。 DocFX や Sandcastle などのドキュメント ツールでコード要素のドキュメント ページへの内部ハイパーリンクを作成でき るようにするには、cref 属性を使用します。
<summary> タグのテキストは、IntelliSenseの型に関する情報の唯一のソースで、[オブジェクトブラウザー]ウィンドウにも表示 されます。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 コンパイラによって生成されたファイルに基づいて 最終的なドキュメントを作成するには、カスタム ツールを作成するか、DocFX や Sandcastle などのツールを使用します。
例
  <summary>description</summary>
        // compile with: -doc:DocFileName.xml
/// text for class TestClass
public class TestClass
{
    /// <summary>DoWork is a method in the TestClass class.
    /// <para>Here's how you could make a second paragraph in a description. <see
cref="System.Console.WriteLine(System.String)"/> for information about output statements.</para>
    /// <seealso cref="TestClass.Main"/>
    /// </summary>
    public static void DoWork(int Int1)
    {
}
    /// text for Main
    static void Main()
    {
    }
}
 前の例では、次の XML ファイルが生成されます。
<summary> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
  例
ジェネリック型への cref 参照を作成する方法を次の例に示します。
    // compile with: -doc:DocFileName.xml
// the following cref shows how to specify the reference, such that,
// the compiler will resolve the reference
/// <summary cref="C{T}">
/// </summary>
class A { }
// the following cref shows another way to specify the reference,
// such that, the compiler will resolve the reference
// <summary cref="C &lt; T &gt;">
// the following cref shows how to hard-code the reference
/// <summary cref="T:C`1">
/// </summary>
class B { }
/// <summary cref="A">
/// </summary>
/// <typeparam name="T"></typeparam>
class C<T> { }
class Program
{
    static void Main() { }
}
 前の例では、次の XML ファイルが生成されます。
   <?xml version="1.0"?>
<doc>
    <assembly>
        <name>YourNamespace</name>
    </assembly>
    <members>
        <member name="T:TestClass">
            text for class TestClass
        </member>
        <member name="M:TestClass.DoWork(System.Int32)">
            <summary>DoWork is a method in the TestClass class.
            <para>Here's how you could make a second paragraph in a description. <see
cref="M:System.Console.WriteLine(System.String)"/> for information about output statements.</para>
</summary>
            <seealso cref="M:TestClass.Main"/>
        </member>
        <member name="M:TestClass.Main">
            text for Main
        </member>
    </members>
</doc>
 
    関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
   <?xml version="1.0"?>
<doc>
    <assembly>
        <name>CRefTest</name>
    </assembly>
    <members>
        <member name="T:A">
            <summary cref="T:C`1">
            </summary>
        </member>
        <member name="T:B">
            <summary cref="T:C`1">
            </summary>
        </member>
        <member name="T:C`1">
            <summary cref="T:A">
            </summary>
            <typeparam name="T"></typeparam>
        </member>
    </members>
</doc>
 
        構文
パラメーター
name
型パラメーターの名前。 名前は二重引用符 (" ") で囲みます。 description
型パラメーターの説明。
Remarks
<typeparam> タグは、型パラメーターを説明するためにジェネリック型またはメソッドの宣言のコメントで使用する必要がありま す。 ジェネリック型またはメソッドの型パラメーターごとにタグを追加します。
詳細については、「ジェネリック」を参照してください。
<typeparam> タグのテキストは、IntelliSense、オブジェクトブラウザーウィンドウ、コードコメントWebレポートに表示されま
す。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。
例
  <typeparam name="name">description</typeparam>
        // compile with: -doc:DocFileName.xml
/// comment for class
public class TestClass
{
    /// <summary>
    /// Creates a new array of arbitrary type <typeparamref name="T"/>
    /// </summary>
    /// <typeparam name="T">The element type of the array</typeparam>
    public static T[] mkArray<T>(int n)
    {
        return new T[n];
    }
}
 関連項目
C# リファレンス
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<typeparam> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
      構文
パラメーター
name
型パラメーターの名前。 名前は二重引用符 (" ") で囲みます。
Remarks
ジェネリック型およびメソッドの型パラメーターの詳細については、「ジェネリック (C# プログラミング ガイド)」を参照してください。 ドキュメント ファイルを使用するときに何らかの方法で単語の書式 (斜体など) を指定するには、このタグを使用します。 コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。
例
  <typeparamref name="name"/>
     // compile with: -doc:DocFileName.xml
/// comment for class
public class TestClass
{
    /// <summary>
    /// Creates a new array of arbitrary type <typeparamref name="T"/>
    /// </summary>
    /// <typeparam name="T">The element type of the array</typeparam>
    public static T[] mkArray<T>(int n)
    {
        return new T[n];
    }
}
 関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ
<typeparamref> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    構文
パラメーター
    property-description
プロパティの説明。
Remarks
<value> タグを使用して、プロパティが表す値を記述することができます。VisualStudio.NET開発環境では、コードウィザー ドを使用してプロパティを追加するときに、新しいプロパティの<summary>タグが追加されます。その後、手動で <value> タ グを追加してプロパティが表す値を記述する必要があります。
コンパイル時に -doc を指定して、ドキュメント コメントをファイルに出力します。 例
  <value>property-description</value>
        // compile with: -doc:DocFileName.xml
/// text for class Employee
public class Employee
{
    private string _name;
    /// <summary>The Name property represents the employee's name.</summary>
    /// <value>The Name property gets/sets the value of the string field, _name.</value>
    public string Name
    {
get {
            return _name;
        }
set {
            _name = value;
        }
} }
/// text for class MainClass
public class MainClass
{
    /// text for Main
    static void Main()
    {
    }
}
 <value> (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
   関連項目
C# プログラミング ガイド ドキュメント コメント用の推奨タグ

   C# 言語の例外処理機能は、プログラムの実行時に発生する予期しない状況や例外的な状況を扱うのに役立ちます。 例外 処理では、キーワード try 、 catch 、および finally を使用して、成功しない可能性があるアクションを試行し、適切な場 合はエラーを処理して、後からリソースをクリーンアップします。 例外の発生元は、共通言語ランタイム (CLR)、.NET、サード パーティライブラリ、またはアプリケーションコードなどさまざまです。例外は、throw キーワードを使用して作成されます。
コードが直接呼び出したメソッドではなく、呼び出し履歴の下の方にある別のメソッドによって例外がスローされることも多くありま す。例外がスローされた場合、CLRによってスタックがアンワインドされ、catch ブロックを持つメソッドを探して特定の例外の種 類がないかを調べ、もしあれば最初に見つかった catch ブロックを実行します。適切な catch ブロックが呼び出し履歴にな い場合は、プロセスが終了し、ユーザーにメッセージが表示されます。
この例では、メソッドが 0 による除算をテストしてエラーをキャッチします。 例外処理せずにプログラムは終了し、 "DivideByZeroException はハンドルされませんでした。 " というエラーが表示されます。
     public class ExceptionTest
{
    static double SafeDivision(double x, double y)
    {
        if (y == 0)
            throw new DivideByZeroException();
return x / y; }
    public static void Main()
    {
        // Input for test purposes. Change the values to see
        // exception handling behavior.
        double a = 98, b = 0;
        double result;
try {
            Console.WriteLine("{0} divided by {1} = {2}", a, b, result);
        }
        catch (DivideByZeroException)
        {
            Console.WriteLine("Attempted divide by zero.");
        }
} }
result = SafeDivision(a, b);
 例外の概要 例外には、次の特徴があります。
例外はすべて最終的に System.Exception から派生した種類になります。 例外をスローする可能性のあるステートメントの周囲で try ブロックを使用します。
try ブロックで例外が発生すると、コントロールのフローが、呼び出し履歴内の関連付けられている最初の例外ハンドラー にジャンプします。C#では、catch キーワードは例外ハンドラーの定義に使用されます。 特定の例外の例外ハンドラーが存在しない場合、プログラムは実行を停止し、エラー メッセージを表示します。 処理できない例外はキャッチしないようにして、アプリケーションを既知の状態に保ちます。 System.Exception をキャッチし
  例外と例外処理 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
           た場合は、 catch ブロックの最後で throw キーワードを使用して、それを再スローします。
catch ブロックで例外変数を定義した場合、それを使用して、発生した例外の種類に関する詳細を入手することができま
す。
例外は、 throw キーワードを使用してプログラムで明示的に生成することができます。 例外オブジェクトには、呼び出し履歴の状態やエラーの説明など、エラーに関する詳細情報が含まれています。
finally ブロック内のコードは、例外がスローされた場合でも実行されます。 finally ブロックを使用してリソースを解放
します。たとえば、 try ブロックで開かれたストリームまたはファイルを閉じます。
.NET のマネージド例外は、Win32 構造化例外処理メカニズムの上に実装されます。 詳細については、「構造化例外処 理 (C/C++)」と「A Crash Course on the Depths of Win32 Structured Exception Handling (Win32 構造化例外処 理に関する短期集中コース)」を参照してください。
C# 言語仕様
詳細については、「C# 言語の仕様」の「例外」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある
情報源です。 関連項目
SystemException
C# のキーワード throw
try-catch try-finally try-catch-finally 例外
  
    C# では、例外と呼ばれるメカニズムを使用して、プログラムの実行時に発生したエラーがプログラムに伝えられます。 例外は、 エラーが発生したコードによってスローされ、エラーを修正できるコードによってキャッチされます。 例外をスローできるのは、.NET ランタイム、またはプログラム内のコードです。スローされた例外は、例外の catch ステートメントが見つかるまで呼び出し履歴 をさかのぼります。 キャッチされない例外は、システムが提供する汎用の例外ハンドラーによって処理されます。このとき、ダイア ログ ボックスが表示されます。
例外は、Exception から派生したクラスによって表されます。 このクラスは例外の型を識別し、例外に関する詳細情報が含ま れたプロパティを保持します。 例外をスローするには、例外の派生クラスのインスタンスを作成し、必要に応じて例外のプロパ ティを設定してから、 throw キーワードを使用してオブジェクトをスローする必要があります。 次に例を示します。
    class CustomException : Exception
{
    public CustomException(string message)
    {
    }
}
private static void TestThrow()
{
    throw new CustomException("Custom exception in TestThrow()");
}
 例外がスローされると、ランタイムは、現在のステートメントが try ブロック内に存在するかどうかを確認します。 存在する場合 は、 try ブロックに関連付けられている catch ブロックをチェックして、例外をキャッチできるかどうかを確認します。 通常は、こ の Catch ブロックによって例外の型が指定されます。 catch ブロックの型が、例外または例外の基底クラスの型と一致する場 合、 catch ブロックはメソッドを処理できます。 次に例を示します。
    try {
    TestThrow();
}
catch (CustomException ex)
{
    System.Console.WriteLine(ex.ToString());
}
 例外をスローするステートメントが try ブロック内にない場合、または try ブロックにそれが含まれていても、対応する catch ブロックが存在しない場合は、ランタイムによって呼び出し側のメソッドで try ステートメントと catch ブロックが確認されます。 続けて、呼び出し履歴で、対応する catch ブロックを探します。 catch ブロックが見つかり実行されると、その catch ブロッ クの後にある次のステートメントに制御が渡されます。
try ステートメントには、複数の catch ブロックを含めることができます。例外を処理できる最初の catch ステートメントが 実行され、その後の catch ステートメントは、対応していても無視されます。catchブロックは、常に最も具体的なもの(また は最も派生したもの) から最も具体的でないものの順序にする必要があります。 次に例を示します。
例外の使用 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
    catch ブロックが実行される前に、ランタイムにより finally ブロックがチェックされます。 Finally ブロックを使用すると、中 止された try ブロックによって残ることがある、あいまいな状態をクリーンアップできます。また、ランタイムのガベージコレクターに よってオブジェクトが終了されるのを待たずに外部リソース (グラフィック ハンドル、データベース接続、ファイル ストリームなど) を解 放することもできます。 次に例を示します。
   using System;
using System.IO;
namespace Exceptions
{
    public class CatchOrder
    {
} }
public static void Main()
{
try {
    }
    // Put the more specific exceptions first.
    catch (DirectoryNotFoundException ex)
    {
        Console.WriteLine(ex);
    }
    catch (FileNotFoundException ex)
    {
        Console.WriteLine(ex);
    }
    // Put the least specific exception last.
    catch (IOException ex)
    {
        Console.WriteLine(ex);
    }
    Console.WriteLine("Done");
}
using (var sw = new StreamWriter("./test.txt"))
{
    sw.WriteLine("Hello");
}
 
      WriteByte() から例外がスローされた場合、file.Close() が呼び出されなければ、ファイルを再度開こうとする2番目の
try ブロックのコードが失敗し、ファイルはロックされたままになります。例外がスローされても finally ブロックは実行されるた め、上の例の finally ブロックではファイルを適切に閉じて、エラーを回避できます。
例外がスローされた後、対応する catch ブロックが呼び出し履歴に見つからない場合は、次のいずれかが発生します。
例外がファイナライザーの内部で発生した場合、ファイナライザーは中止され、基本ファイナライザー (存在する場合) が呼び 出されます。 呼び出し履歴に静的コンストラクターまたは静的フィールド初期化子が含まれている場合は、TypeInitializationException がスローされ、新しい例外の InnerException プロパティに元の例外が割り当てられます。 スレッドの開始位置に到達すると、スレッドは終了します。
     static void TestFinally()
{
    FileStream? file = null;
    //Change the path to something that works on your machine.
    FileInfo fileInfo = new System.IO.FileInfo("./file.txt");
try {
        file.WriteByte(0xF);
    }
finally {
        // Closing the file allows you to reopen it immediately - otherwise IOException is thrown.
        file?.Close();
    }
try {
        Console.WriteLine("OpenWrite() succeeded");
    }
    catch (IOException)
    {
        Console.WriteLine("OpenWrite() failed");
    }
}
file = fileInfo.OpenWrite();
file = fileInfo.OpenWrite();
 
     try ブロックは、例外の影響を受ける可能性があるコードを区分化するために、 C# プログラマによって使用されます。 関連付け られたcatchブロックは、スローされた例外を処理するために使用されます。finallyブロックには、try ブロックで例外がスロー されたかどうかにかかわらず実行されるコードが含まれます(try ブロックに割り当てられたリソースの解放など)。 try ブロック には、1 つ以上の catch ブロック、 finally ブロック、またはその両方が関連付けられる必要があります。
次のコードは、 try-catch ステートメント、 try-finally ステートメント、および try-catch-finally ステートメントの例です。
        try {
    // Code to try goes here.
}
catch (SomeSpecificException ex)
{
    // Code to handle the exception goes here.
    // Only catch exceptions that you know how to handle.
    // Never catch base class System.Exception without
    // rethrowing it at the end of the catch block.
}
     try {
    // Code to try goes here.
}
finally {
    // Code to execute after the try block goes here.
}
     try {
    // Code to try goes here.
}
catch (SomeSpecificException ex)
{
    // Code to handle the exception goes here.
}
finally {
    // Code to execute after the try (and possibly catch) blocks
    // goes here.
}
  try ブロックに catch または finally ブロックがない場合は、コンパイルエラーが発生します。 catch ブロック
catch ブロックでは、キャッチする例外の種類を指定できます。この型指定は、例外フィルターと呼ばれます。例外の種類 は、Exceptionから派生している必要があります。一般に、try ブロックからスローされる可能性があるすべての例外の処理 方法を把握している場合や、catch ブロックの末尾にthrowステートメントが含まれている場合を除いては、例外フィルターと して Exception を指定しないでください。
例外処理 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
  複数の catch ブロックに異なる例外クラスが含まれている場合は、それらを連結することができます。 catch ブロックはコード 内で上から下に評価されますが、スローされた各例外に対して実行される catch ブロックは1つだけです。スローされた例外 の厳密な型か、その基底クラスを指定する最初の catch ブロックが実行されます。一致する例外クラスを指定した catch ブ ロックがない場合は、種類のない catch ブロックが選択されます(それがステートメント内に存在する場合)。最初に配置する
catch ブロックでは、最も具体的な(つまり、最も派生した)例外クラスを指定することが重要です。 次の条件に該当する場合は、例外をキャッチします。
例外がスローされる理由を十分に理解していて、かつ特定の回復手段を実装できる (FileNotFoundException オブジェク トをキャッチした場合に、ユーザーに新しいファイル名を入力するよう求めるなど)。 より具体的な例外を新規に作成し、スローできる。
    int GetInt(int[] array, int index)
{
try {
        return array[index];
    }
    catch (IndexOutOfRangeException e)
    {
} }
throw new ArgumentOutOfRangeException(
    "Parameter index is out of range.", e);
 例外を追加処理に渡す前に、その例外を部分的に処理する必要がある。 次の例では、例外を再スローする前に、エラー ログにエントリを追加する目的で catch ブロックが使用されています。
    try {
    // Try to access a resource.
}
catch (UnauthorizedAccessException e)
{
    // Call a custom error logging procedure.
    LogError(e);
    // Re-throw the error.
    throw;
}
 "例外フィルター" を指定して、catch 句にブール式を追加することもできます。 これは、特定の catch 句が、その条件が true の 場合にのみ一致することを示します。 次の例では、両方の catch 句で同じ例外クラスが使用されますが、追加の条件が確認 され、別のエラー メッセージが作成されます。

    常に false を返す例外フィルターを使用すると、すべての例外を検証できますが、処理は行われません。通常は、例外をロ グに記録するために使用します。
    public static void Main()
{
try {
        Console.WriteLine(s.Length);
    }
    catch (Exception e) when (LogException(e))
    {
    }
    Console.WriteLine("Exception must have been handled");
}
private static bool LogException(Exception e)
{
    Console.WriteLine($"\tIn the log routine. Caught {e.GetType()}");
    Console.WriteLine($"\tMessage: {e.Message}");
    return false;
}
string? s = null;
  LogException メソッドにより常に false が返され、この例外フィルターを使用する catch 句は一致しません。catch句は 一般的なもので (System.Exception を使用)、後の句によってより具体的な例外クラスを処理することができます。
Finally ブロック
finally ブロックでは、 try ブロックで実行されるアクションをクリーンアップすることができます。 finally ブロック (存在する場 合)は、最後(try ブロックおよび一致する catch ブロックの後)に実行されます。 ブロックは、例外がスローされた かどうか、または例外の種類に一致する catch ブロックが見つかったかどうかにかかわらず、常に実行されます。
finally ブロックは、ランタイム内のガベージコレクターによってオブジェクトがファイナライズされるのを待つことなく、ファイルスト リーム、データベース接続、グラフィックス ハンドルなどのリソースを解放するために使用できます。 詳細については、using ステー トメントに関するページを参照してください。
次の例では、 try ブロックで開かれたファイルを閉じるために finally ブロックが使用されています。 ファイルを閉じる前に、 ファイルハンドルの状態が確認されています。 try ブロックからファイルを開けなかった場合は、ファイルハンドルの値が null のままになり、 ブロックでファイルが閉じられることはありません。 代わりに、 try ブロックでファイルが正常に開かれた場 合は、 ブロックによって開かれたファイルが閉じられます。
   finally
   finally
 finally
   int GetInt(int[] array, int index)
{
try {
        return array[index];
    }
    catch (IndexOutOfRangeException e) when (index < 0)
    {
        throw new ArgumentOutOfRangeException(
            "Parameter index cannot be negative.", e);
    }
    catch (IndexOutOfRangeException e)
    {
} }
throw new ArgumentOutOfRangeException(
    "Parameter index cannot be greater than the array size.", e);
 
         C# 言語仕様
詳細については、「C# 言語仕様」の例外と try ステートメントに関するセクションを参照してください。 言語仕様は、C# の構文
と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス try-catch try-finally try-catch-finally using ステートメント
   FileStream? file = null;
FileInfo fileinfo = new System.IO.FileInfo("./file.txt");
try
{
    file = fileinfo.OpenWrite();
    file.WriteByte(0xF);
}
finally {
    // Check for null because OpenWrite might have failed.
    file?.Close();
}
 
         例外は、プログラムの実行中にエラーが発生したことを示すために使われます。 エラーを説明する例外オブジェクトが作成された 後、throw キーワードで "スロー" されます。 そのとき、ランタイムは最も互換性のある例外ハンドラーを検索します。
プログラマは、以下の条件が 1 つでも該当するときは、例外をスローする必要があります。 メソッドは、定義されている機能を完了できません。 たとえば、メソッドへのパラメーターに無効な値が設定されている場合な
どです。
オブジェクトの状態に基づくと、オブジェクトに対して行われた呼び出しが不適切です。 たとえば、読み取り専用ファイルに書 き込もうとしたような場合です。 オブジェクトの状態により操作が許可されない場合は、InvalidOperationException のイン スタンスまたはこのクラスの派生に基づくオブジェクトをスローします。 次のコードは、InvalidOperationException オブジェク トをスローするメソッドの例です。
    static void CopyObject(SampleClass original)
{
    _ = original ?? throw new ArgumentException("Parameter cannot be null", nameof(original));
}
     public class ProgramLog
{
    FileStream logFile = null!;
    public void OpenLog(FileInfo fileName, FileMode mode) { }
    public void WriteLog()
    {
        if (!logFile.CanWrite)
        {
            throw new InvalidOperationException("Logfile cannot be read-only");
        }
        // Else write data to the log and return.
    }
}
 メソッドへの引数が原因で例外が発生しました。 この場合は、元の例外をキャッチして、ArgumentException のインスタン スを作成する必要があります。 元の例外は、InnerException パラメーターとして ArgumentException のコンストラクターに 渡す必要があります。
    static int GetValueFromArray(int[] array, int index)
{
try {
        return array[index];
    }
    catch (IndexOutOfRangeException ex)
    {
        throw new ArgumentException("Index is out of range", nameof(index), ex);
    }
}
 例外には、StackTrace というプロパティが含まれています。 この文字列には、現在の呼び出し履歴でのメソッドの名前と、各メ ソッドの例外がスローされたファイル名と行番号が含まれます。 スタック トレースを開始するポイントから例外をスローする必要が
例外の作成とスロー (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
                 あるため、共通言語ランタイム(CLR)によって throw ステートメントのポイントからStackTraceオブジェクトが自動的に作成さ れます。
すべての例外には、Message というプロパティが含まれています。 例外の原因を説明するには、この文字列を設定する必要が あります。 機密性の高い情報はメッセージ テキストに入れないようにする必要があります。 ArgumentException に は、Message に加え、例外がスローされる原因となる引数の名前に設定される ParamName というプロパティが含まれていま す。プロパティセッターでは、ParamNameは value に設定する必要があります。
public と protected メソッドからは、意図された機能を完了できない場合、常に例外がスローされる必要があります。 スローさ れる例外クラスは、エラー状態に適合する使用可能な例外の中で最も具体的なものになります。 これらの例外はクラスの機能 の一部として文書化する必要があり、派生クラスまたは元のクラスの更新では、旧バージョンとの互換性のために同じ動作を維 持する必要があります。
例外をスローするときに避ける必要があること 次の一覧は、例外をスローするときに避ける必要があることです。
プログラムのフローを変更するために、通常の実行の一部として例外を使用しないでください。 例外はエラー状態の報告と 処理のために使用します。
スローする代わりに、戻り値またはパラメーターとして例外を返さないでください。
独自のソース コードからは、意図的に System.Exception、System.SystemException、System.NullReferenceException、または System.IndexOutOfRangeException をスローしないでください。
デバッグ モードではスローでき、リリース モードではスローできない例外は、作成しないでください。 開発フェーズ中に実行時 エラーを識別するには、代わりにデバッグ アサートを使ってください。
例外クラスの定義
プログラムでは、System 名前空間で事前定義された例外クラスをスローするか (上記の場合を除きます)、Exception から派 生することで独自の例外クラスを作成することができます。 派生クラスでは、少なくとも 4 つのコンストラクターを必ず定義しま す。パラメータ―なしのコンストラクター、メッセージ プロパティを設定するコンストラクター、Message プロパティと InnerException プロパティの両方を設定するコンストラクター、 そして 4 番目は例外のシリアル化に使われるコンストラクターです。 新しい例外ク ラスは、シリアル化可能にする必要があります。 次に例を示します。
    [Serializable]
public class InvalidDepartmentException : Exception
{
    public InvalidDepartmentException() : base() { }
    public InvalidDepartmentException(string message) : base(message) { }
    public InvalidDepartmentException(string message, Exception inner) : base(message, inner) { }
    // A constructor is needed for serialization when an
    // exception propagates from a remoting server to the client.
    protected InvalidDepartmentException(System.Runtime.Serialization.SerializationInfo info,
}
System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
 新しいプロパティによって提供されるデータが例外の解決に役立つ場合は、それを例外クラスに追加します。 派生例外クラスに 新しいプロパティを追加する場合は、 ToString() をオーバーライドして追加情報を返す必要があります。
C# 言語仕様
詳細については、「C# 言語仕様」の例外と throw ステートメントに関するセクションを参照してください。 言語仕様は、C# の 構文と使用法に関する信頼性のある情報源です。
 
  関連項目
例外階層

                  一部の例外は、基本操作が失敗した場合に .NET ランタイムによって自動的にスローされます。 次の表には、これらの例外と そのエラー条件が一覧で示されています。
   ArithmeticException
   算術演算中に発生する例外 (DivideByZeroException、OverflowException など) の基底クラス です。
 ArrayTypeMismatchException
DivideByZeroException
InvalidCastException
NullReferenceException
要素の実際の型が配列の実際の型に対応していないことが原因で、 指定された要素を配列に格納できない場合にスローされます。
整数値のゼロ除算が試行されたときにスローされます。
基本データ型からインターフェイスまたは派生型への明示的な変換が 実行時に失敗したときにスローされます。
値が null であるオブジェクトを参照しようとするとスローされます。
       IndexOutOfRangeException
   インデックスがゼロよりも小さい場合またはインデックスが配列の境界 外にある場合に、配列のインデックス作成が試行されたときにスローさ れます。
        OutOfMemor yException
  new 演算子を使用したメモリの割り当てに失敗するとスローされま す。 この例外は、共通言語ランタイムに使用できるメモリが足りなく なったことを示します。
   OverflowException
    checked コンテキストで算術演算がオーバーフローしたときにスロー されます。
   StackOverflowException
 保留中のメソッド呼び出しが多すぎることが原因で実行スタックが不 足したときにスローされます。通常は、非常に深い再帰か無限再帰が あることを示します。
    TypeInitializationException
   静的コンストラクターが例外をスローし、その例外をキャッチするための 対応する catch 句がない場合にスローされます。
 関連項目
try-catch try-finally try-catch-finally
コンパイラにより生成された例外 (C# プログラ
ミング ガイド) 2021/03/06 • • Edit Online
 
         try-catchブロックの目的は、作業コードによって生成された例外をキャッチし、処理することです。例外によっては、catch ブ ロックで処理され、例外を再スローせずに問題を解決できるものもありますが、多くの場合、適切な例外が確実にスローされる ようにする必要があります。
例
この例のIndexOutOfRangeExceptionは最も適切な例外というわけではありません。呼び出し元から index 引数が渡され
てエラーが発生しているため、より適切なメソッドは ArgumentOutOfRangeException になります。
    static int GetInt(int[] array, int index)
{
try {
        return array[index];
    }
    catch (IndexOutOfRangeException e)  // CS0168
    {
} }
Console.WriteLine(e.Message);
// Set IndexOutOfRangeException to the new exception's InnerException.
throw new ArgumentOutOfRangeException("index parameter is out of range.", e);
 コメント
例外を発生させるコードは try ブロックに囲まれています。 が発生した場合にこれを処理する ための catch ステートメントが、すぐ後に追加されています。 catch ブロックは を処理し、代わ りにより適切な ArgumentOutOfRangeException 例外をスローします。呼び出し元にできるだけ多くの情報を提供するため、元 の例外を新しい例外の InnerException として指定することを検討してください。 InnerException プロパティは読み取り専用で あるため、新しい例外のコンストラクターで割り当てる必要があります。
 IndexOutOfRangeException
 IndexOutOfRangeException
 try/catch を使用して例外を処理する方法 (C# プ
ログラミング ガイド) 2021/03/06 • • Edit Online
 
       finally ステートメントの目的は、例外がスローされた場合でも、オブジェクト(一般に外部リソースを保持しているオブジェクト) に対して必要なクリーンアップをすぐに実行できるようにすることです。 次のように、共通言語ランタイムによってオブジェクトがガ ベージ コレクションされるまで待機するのではなく、オブジェクトを使用した後すぐに FileStream で Close を呼び出すというのも、 このようなクリーンアップの一例です。
    static void CodeWithoutCleanup()
{
    FileStream? file = null;
    FileInfo fileInfo = new FileInfo("./file.txt");
    file = fileInfo.OpenWrite();
    file.WriteByte(0xF);
    file.Close();
}
 例
上のコードを try-catch-finally ステートメントに変えるには、次のようにクリーンアップコードを作業コードから切り離します。
     static void CodeWithCleanup()
{
    FileStream? file = null;
    FileInfo? fileInfo = null;
try {
        file.WriteByte(0xF);
    }
    catch (UnauthorizedAccessException e)
    {
        Console.WriteLine(e.Message);
    }
finally {
        file?.Close();
    }
}
fileInfo = new FileInfo("./file.txt");
file = fileInfo.OpenWrite();
   try ブロック内では OpenWrite() 呼び出しの前のどの時点でも例外が発生する可能性があり、また、 呼び出 し自体が失敗するおそれもあるため、ファイルを閉じようとしたときに、それが開いているという保証はありません。 ブ ロックによって、Closeメソッドを呼び出す前に、FileStreamオブジェクトが null でないことを確認するチェックが追加されま す。この null チェックがないと、finally ブロックからそのNullReferenceExceptionがスローされる可能性がありますが、
finally ブロックにおける例外のスローはできるだけ回避する必要があります。
データベース接続も、 finally ブロックで閉じられる対象になります。 データベース サーバーで許可される接続数は限られてい ることがあるため、データベース接続はできるだけ早く閉じる必要があります。 接続を閉じる前に例外がスローされる場合は、ガ
OpenWrite()
 finally
   finally を使用してクリーンアップ コードを実行す
る方法 (C# プログラミング ガイド) 2021/03/06 • • Edit Online
 
     ベージ コレクションを待機するより、   ブロックを使用することをお勧めします。 関連項目
using ステートメント try-catch try-finally try-catch-finally
 finally
 
         C++/CLI をはじめとする一部の .NET 言語では、Exception から派生していない例外をオブジェクトでスローすることができま す。 このような例外は "CLS 準拠でない例外" や "非例外" と呼ばれています。 C# では、CLS 準拠でない例外をスローするこ とはできませんが、それらをキャッチすることはできます。次の 2 とおりの方法があります。
catch (RuntimeWrappedException e) ブロック内で。
Visual C# アセンブリの既定の動作上、CLS 準拠でない例外はラップされた例外としてキャッチされます。 元の例外にア クセスする必要がある場合 (RuntimeWrappedException.WrappedException プロパティからアクセスできます)、この メソッドを利用します。 この方法で例外をキャッチする方法については、このトピックで後述します。
他のすべての catch ブロックの後に置いた汎用的なcatchブロック(例外の型が指定されていないcatchブロック)内 で。
この方法は、CLS 準拠でない例外への応答として何らかのアクション (ログ ファイルへの書き込みなど) を実行したい場 合で、なおかつ例外情報にアクセスする必要がない場合に使用します。 既定では、すべての例外が共通言語ランタイ ムによってラップされます。 この動作を無効にするには、
[assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)] というアセンブリ レベルの属性を (通常、AssemblyInfo.cs ファイル内の) コードに追加します。
CLS 準拠でない例外をキャッチするには
catch(RuntimeWrappedException e) ブロック内で、RuntimeWrappedException.WrappedExceptionプロパティから元の
例外にアクセスします。 例
次の例では、C++/CLI で記述されたクラス ライブラリからスローされた、CLS 準拠でない例外をキャッチする方法を示します。 この例で、C# クライアント コードは、スローされる例外の型が System.String であることを事前に把握しています。 その型に コードからアクセスできる限り、RuntimeWrappedException.WrappedException プロパティは元の型にキャストできます。
         // Class library written in C++/CLI.
var myClass = new ThrowNonCLS.Class1();
try {
}
catch (RuntimeWrappedException e)
{
    String s = e.WrappedException as String;
    if (s != null)
    {
        Console.WriteLine(s);
    }
}
// throws gcnew System::String(
// "I do not derive from System.Exception!");
myClass.TestThrow();
 関連項目
RuntimeWrappedException
CLS 準拠でない例外をキャッチする方法 2020/11/02 • • Edit Online
 
  例外と例外処理

                 次の記事では、C# と .NET を使用して、ファイル、フォルダー、レジストリに対するさまざまな基本操作を実行する方法を示しま す。
このセクションの内容
ディレクトリ ツリーを反復処理する方法 ファイル、フォルダー、およびドライブに関する情報を取得する方法
ファイルまたはフォルダーを作成する方法 ファイルおよびフォルダーのコピー、削除、および移動を行う方法 (C#
プログラミング ガイド)
ファイル操作の [進行状況] ダイアログ ボックスを表示する方法
テキスト ファイルに書き込む方法
テキスト ファイルから読み取る方法
テキスト ファイルを一度に 1 行読み取る方法 レジストリにキーを作成する方法
関連項目
ファイルおよびストリーム入出力
ディレクトリ ツリーを手動で反復処理する方法を示します。
作成時刻やサイズなど、ファイル、フォルダー、ドライブに関する情報を 取得する方法を示します。
新しいファイルまたはフォルダーを作成する方法を示します。 ファイルやフォルダーをコピー、削除、および移動する方法を示します。
特定のファイル操作について、Windows の標準的な進行状況ダイア ログを表示する方法を示します。
テキスト ファイルに書き込み方法を示します。
テキスト ファイルから読み取る方法を示します。 ファイルから一度に 1 行ずつテキストを取得する方法を示します。 キーをシステム レジストリに書き込む方法を示します。
                                      ファイルおよびフォルダーのコピー、削除、および移動を行う方法 (C# プログラミング ガイド) C# プログラミング ガイド
System.IO
ファイル システムとレジストリ (C# プログラミ
ング ガイド) 2020/11/02 • • Edit Online
 
         "ディレクトリ ツリーを反復処理する" とは、指定したルート フォルダー以下の入れ子になっている各サブディレクトリ内の各ファイ ルにアクセスすることです。 必ずしもファイルを 1 つ 1 つ開く必要はありません。 ファイルまたはサブディレクトリの名前だけを
string として取得することも、その他の情報をSystem.IO.FileInfoまたはSystem.IO.DirectoryInfoオブジェクトの形式で 取得することもできます。
最も容易なケース、つまり、指定したルート以下のすべてのディレクトリのアクセス許可があることが確実にわかっている場合は、 System.IO.SearchOption.AllDirectories フラグを使用できます。このフラグは、指定したパターンと一致する、入れ子にされ
たすべてのサブディレクトリを返します。 このフラグを使用する方法を次の例に示します。
この方法の弱点は、指定したルート以下のサブディレクトリの 1 つが DirectoryNotFoundException または UnauthorizedAccessException を発生させた場合、メソッド全体が失敗し、ディレクトリが返されないという点です。 GetFiles メソッドを使用する場合も同様です。 特定のサブフォルダーに関するこのような例外を処理する必要がある場合は、次の例の ように、ディレクトリ ツリーを手動で移動する必要があります。
ディレクトリ ツリーを手動で移動するときは、最初にサブディレクトリを処理 ("先行順走査") するか、最初にファイルを処理 ("後 順走査") できます。 先行順走査を実行する場合、現在のフォルダー以下のツリー全体を移動してから、そのフォルダー自体に 直接格納されているファイルを反復処理していきます。 このドキュメントで後述する例は、後順走査を実行しますが、先行順 走査を実行するように簡単に変更できます。
また、再帰とスタック ベース走査のどちらを使用するかを選択できます。 このドキュメント内の後の例では、両方の方法を示して います。
ファイルおよびフォルダーに対してさまざまな操作を実行する必要がある場合は、単一のデリゲートを使用して呼び出すことがで きる個別の関数に操作をリファクタリングすることで、これらの例をモジュール化できます。
     NOTE
Windows では、"ディレクトリ" と "フォルダー" という用語は同義です。 多くのドキュメントおよびユーザー インターフェイスのテキストでは、"フォ ルダー" という用語が使用されますが、.NET クラス ライブラリでは、"ディレクトリ" という用語が使用されます。
    root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);
     NOTE
NTFS ファイル システムには、"接合ポイント"、"シンボリック リンク"、および "ハード リンク" の形式で "リパース ポイント" を含めることができま す。 GetFiles や GetDirectories などの .NET メソッドは、リパース ポイント以下のサブディレクトリを返しません。 この動作により、リパース ポイントが相互参照している場合に、無限ループに入るのが回避されます。 通常、ファイルを誤って変更または削除しないようにリパース ポ イントを処理する場合は、十分な注意が必要です。 リパース ポイントを詳細に制御する必要がある場合は、プラットフォーム呼び出しまた はネイティブ コードを使用して、適切な Win32 ファイル システム メソッドを直接呼び出します。
 例
再帰を使用してディレクトリ ツリーを移動する方法を次の例に示します。 この再帰の方法は洗練されていますが、ディレクトリ ツ リーが大きく、入れ子の階層が深いと、スタック オーバーフロー例外が発生する可能性があります。
ディレクトリ ツリーを反復処理する方法 (C# プ
ログラミング ガイド) 2020/11/02 • • Edit Online
 
 ここで処理される例外や、各ファイルまたは各フォルダーに対して実行される操作は、あくまで例として用意したものです。 実際 の要件を満たす際には、このコードを修正する必要があります。 詳細については、コード内のコメントを参照してください。
    public class RecursiveFileSearch
{
    static System.Collections.Specialized.StringCollection log = new
System.Collections.Specialized.StringCollection();
    static void Main()
    {
        // Start with drives if you have to search the entire computer.
        string[] drives = System.Environment.GetLogicalDrives();
        foreach (string dr in drives)
        {
            System.IO.DriveInfo di = new System.IO.DriveInfo(dr);
            // Here we skip the drive if it is not ready to be read. This
            // is not necessarily the appropriate action in all scenarios.
            if (!di.IsReady)
            {
                Console.WriteLine("The drive {0} could not be read", di.Name);
continue; }
            System.IO.DirectoryInfo rootDir = di.RootDirectory;
            WalkDirectoryTree(rootDir);
        }
        // Write out all the files that could not be processed.
        Console.WriteLine("Files with restricted access:");
        foreach (string s in log)
        {
            Console.WriteLine(s);
        }
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key");
        Console.ReadKey();
}
    static void WalkDirectoryTree(System.IO.DirectoryInfo root)
    {
        System.IO.FileInfo[] files = null;
        System.IO.DirectoryInfo[] subDirs = null;
        // First, process all the files directly under this folder
        try
        {
            files = root.GetFiles("*.*");
        }
        // This is thrown if even one of the files requires permissions greater
        // than the application provides.
        catch (UnauthorizedAccessException e)
        {
            // This code just writes out the message and continues to recurse.
            // You may decide to do something different here. For example, you
            // can try to elevate your privileges and access the file again.
            log.Add(e.Message);
}
        catch (System.IO.DirectoryNotFoundException e)
        {
            Console.WriteLine(e.Message);
        }
        if (files != null)
        {
foreach (System.IO.FileInfo fi in files)
{

     例
再帰を使用せずにディレクトリ ツリー内のファイルおよびフォルダーを反復処理する方法を、次の例に示します。 この方法では、
後入れ先出し (LIFO) スタックである、一般的な Stack<T> コレクション型を使用します。
ここで処理される例外や、各ファイルまたは各フォルダーに対して実行される操作は、あくまで例として用意したものです。 実際 の要件を満たす際には、このコードを修正する必要があります。 詳細については、コード内のコメントを参照してください。
   {
    // In this example, we only access the existing FileInfo object. If we
    // want to open, delete or modify the file, then
    // a try-catch block is required here to handle the case
    // where the file has been deleted since the call to TraverseTree().
    Console.WriteLine(fi.FullName);
}
// Now find all the subdirectories under this directory.
subDirs = root.GetDirectories();
foreach (System.IO.DirectoryInfo dirInfo in subDirs)
{
    // Resursive call for each subdirectory.
    WalkDirectoryTree(dirInfo);
}
 } }
}
 public class StackBasedIteration
{
    static void Main(string[] args)
    {
        // Specify the starting folder on the command line, or in
        // Visual Studio in the Project > Properties > Debug pane.
        TraverseTree(args[0]);
        Console.WriteLine("Press any key");
        Console.ReadKey();
    }
    public static void TraverseTree(string root)
    {
        // Data structure to hold names of subfolders to be
        // examined for files.
        Stack<string> dirs = new Stack<string>(20);
        if (!System.IO.Directory.Exists(root))
        {
            throw new ArgumentException();
        }
        dirs.Push(root);
        while (dirs.Count > 0)
        {
            string currentDir = dirs.Pop();
            string[] subDirs;
            try
            {
                subDirs = System.IO.Directory.GetDirectories(currentDir);
            }
            // An UnauthorizedAccessException exception will be thrown if we do not have
            // discovery permission on a folder or file. It may or may not be acceptable
            // to ignore the exception and continue enumerating the remaining files and
            // folders. It is also possible (but unlikely) that a DirectoryNotFound exception
            // will be raised. This will happen if currentDir has been deleted by
            // another application or thread after our call to Directory.Exists. The

 // another application or thread after our call to Directory.Exists. The
    通常、すべてのフォルダーをテストして、アプリケーションにフォルダーを開くアクセス許可があるかどうかを確認する作業には時間 がかかります。 そのため、このコード例には、 try/catch ブロック内の操作の該当部分のみが含まれています。 フォルダーへのア クセスが拒否されたときにアクセス許可を昇格して再びアクセスを試行するように、 catch ブロックを修正できます。 原則とし て、アプリケーションが不明の状態にならずに処理できる例外のみをキャッチしてください。
  ディレクトリツリーの内容をメモリまたはディスクに格納する必要がある場合、各ファイルの(FullName型の) string プロパティ
 } }
}
// choice of which exceptions to catch depends entirely on the specific task
// you are intending to perform and also on how much you know with certainty
// about the systems on which this code will run.
catch (UnauthorizedAccessException e)
{
    Console.WriteLine(e.Message);
    continue;
}
catch (System.IO.DirectoryNotFoundException e)
{
    Console.WriteLine(e.Message);
continue; }
string[] files = null;
try
{
    files = System.IO.Directory.GetFiles(currentDir);
}
catch (UnauthorizedAccessException e)
{
    Console.WriteLine(e.Message);
continue; }
catch (System.IO.DirectoryNotFoundException e)
{
    Console.WriteLine(e.Message);
continue; }
// Perform the required action on each file here.
// Modify this block to perform your required task.
foreach (string file in files)
{
try {
    }
    catch (System.IO.FileNotFoundException e)
    {
        // If file was deleted by a separate application
        //  or thread since the call to TraverseTree()
        // then just continue.
        Console.WriteLine(e.Message);
continue; }
}
// Push the subdirectories onto the stack for traversal.
// This could also be done before handing the files.
foreach (string str in subDirs)
    dirs.Push(str);
// Perform whatever action is required in your scenario.
System.IO.FileInfo fi = new System.IO.FileInfo(file);
Console.WriteLine("{0}: {1}, {2}", fi.Name, fi.Length, fi.CreationTime);

       のみを格納するのが最適な選択肢です。 その後、必要に応じて、この文字列を使用して新しい FileInfo または DirectoryInfo オブジェクトを作成するか、追加処理が必要なファイルを開くことができます。
信頼性の高いプログラミング
堅牢性の高いファイル反復処理コードでは、ファイル システムの数多くの複雑な部分を考慮する必要があります。 Windows
ファイル システムの詳細については、「NTFS の概要」を参照してください。 関連項目
System.IO
LINQ とファイル ディレクトリ
ファイル システムとレジストリ (C# プログラミング ガイド)

               .NET では、次のクラスを使用して、ファイル システム情報にアクセスできます。 System.IO.FileInfo
System.IO.DirectoryInfo
System.IO.DriveInfo
System.IO.Directory
System.IO.File
FileInfo クラスと DirectoryInfo クラスはファイルまたはディレクトリを表し、NTFS ファイル システムでサポートされるファイル属性 の多くを公開するプロパティを含みます。 また、ファイルとフォルダーを開く、閉じる、移動する、および削除するためのメソッドも含 まれます。 コンストラクターに、ファイル、フォルダー、またはドライブの名前を表す文字列を渡すことで、クラスのインスタンスを作 成できます。
また、DirectoryInfo.GetDirectories、DirectoryInfo.GetFiles、および DriveInfo.RootDirectory の呼び出しを使用して、 ファイル、フォルダー、またはドライブの名前を取得することもできます。
System.IO.Directory クラスと System.IO.File クラスは、ディレクトリとファイルに関する情報を取得するための静的メソッドを提 供します。
例 次の例では、ファイルとフォルダーに関する情報にアクセスするさまざまな方法を示します。
  System.IO.DriveInfo di = new System.IO.DriveInfo(@"C:\");
 ファイル、フォルダー、およびドライブに関する
情報を取得する方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
     class FileSysInfo
{
    static void Main()
    {
        // You can also use System.Environment.GetLogicalDrives to
        // obtain names of all logical drives on the computer.
        System.IO.DriveInfo di = new System.IO.DriveInfo(@"C:\");
        Console.WriteLine(di.TotalFreeSpace);
        Console.WriteLine(di.VolumeLabel);
        // Get the root directory and print out some information about it.
        System.IO.DirectoryInfo dirInfo = di.RootDirectory;
        Console.WriteLine(dirInfo.Attributes.ToString());
        // Get the files in the directory and print out some information about them.
        System.IO.FileInfo[] fileNames = dirInfo.GetFiles("*.*");
        foreach (System.IO.FileInfo fi in fileNames)
        {
            Console.WriteLine("{0}: {1}: {2}", fi.Name, fi.LastAccessTime, fi.Length);
        }
// Get the subdirectories directly that is under the root.

    信頼性の高いプログラミング ユーザー指定のパス文字列を処理する場合、次の条件の例外も処理する必要があります。
 } }
// See "How to: Iterate Through a Directory Tree" for an example of how to
// iterate through an entire tree.
System.IO.DirectoryInfo[] dirInfos = dirInfo.GetDirectories("*.*");
foreach (System.IO.DirectoryInfo d in dirInfos)
{
    Console.WriteLine(d.Name);
}
// The Directory and File classes provide several static methods
// for accessing files and directories.
// Get the current application directory.
string currentDirName = System.IO.Directory.GetCurrentDirectory();
Console.WriteLine(currentDirName);
// Get an array of file names as strings rather than FileInfo objects.
// Use this method when storage space is an issue, and when you might
// hold on to the file name reference for a while before you try to access
// the file.
string[] files = System.IO.Directory.GetFiles(currentDirName, "*.txt");
foreach (string s in files)
{
    // Create the FileInfo object only when needed to ensure
    // the information is as current as possible.
    System.IO.FileInfo fi = null;
    try
    {
         fi = new System.IO.FileInfo(s);
    }
    catch (System.IO.FileNotFoundException e)
    {
        // To inform the user and continue is
        // sufficient for this demonstration.
        // Your application may require different behavior.
        Console.WriteLine(e.Message);
        continue;
}
    Console.WriteLine("{0} : {1}",fi.Name, fi.Directory);
}
// Change the directory. In this case, first check to see
// whether it already exists, and create it if it does not.
// If this is not appropriate for your application, you can
// handle the System.IO.IOException that will be raised if the
// directory cannot be found.
if (!System.IO.Directory.Exists(@"C:\Users\Public\TestFolder\"))
{
    System.IO.Directory.CreateDirectory(@"C:\Users\Public\TestFolder\");
}
System.IO.Directory.SetCurrentDirectory(@"C:\Users\Public\TestFolder\");
currentDirName = System.IO.Directory.GetCurrentDirectory();
Console.WriteLine(currentDirName);
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();

    ファイル名が不適切である。 たとえば、無効な文字が含まれている場合や、空白のみの場合です。 ファイル名が NULL である。
ファイル名の長さがシステムで定義された最大長を超えている。
ファイル名にコロン (:) が含まれている。
指定したファイルの読み取りに必要なアクセス許可がアプリケーションに与えられていない場合、 Exists メソッドは目的のパス が存在するかどうかに関係なく false を返します。ただし、例外はスローされません。
関連項目
System.IO
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド)
 
   プログラムによって、コンピューター上でのフォルダーの作成、サブフォルダーの作成、サブフォルダー内でのファイルの作成、および ファイルへのデータの記述を行うことができます。
例
   ファイルまたはフォルダーを作成する方法 (C#
プログラミング ガイド) 2020/11/02 • • Edit Online
  public class CreateFileOrFolder
{
    static void Main()
    {
        // Specify a name for your top-level folder.
        string folderName = @"c:\Top-Level Folder";
        // To create a string that specifies the path to a subfolder under your
        // top-level folder, add a name for the subfolder to folderName.
        string pathString = System.IO.Path.Combine(folderName, "SubFolder");
        // You can write out the path name directly instead of using the Combine
        // method. Combine just makes the process easier.
        string pathString2 = @"c:\Top-Level Folder\SubFolder2";
        // You can extend the depth of your path if you want to.
        //pathString = System.IO.Path.Combine(pathString, "SubSubFolder");
        // Create the subfolder. You can verify in File Explorer that you have this
        // structure in the C: drive.
//
//
//
System.IO.Directory.CreateDirectory(pathString);
// Create a file name for the file you want to create.
string fileName = System.IO.Path.GetRandomFileName();
// This example uses a random string for the name, but you also can specify
// a particular name.
//string fileName = "MyNewFile.txt";
// Use Combine again to add the file name to the path.
pathString = System.IO.Path.Combine(pathString, fileName);
// Verify the path that you have constructed.
Console.WriteLine("Path to my file: {0}\n", pathString);
// Check that the file doesn't already exist. If it doesn't exist, create
// the file and write integers 0 - 99 to it.
// DANGER: System.IO.File.Create will overwrite the file if it already exists.
// This could happen even with random file names, although it is unlikely.
if (!System.IO.File.Exists(pathString))
{
    using (System.IO.FileStream fs = System.IO.File.Create(pathString))
    {
        for (byte i = 0; i < 100; i++)
        {
            fs.WriteByte(i);
        }
Local Disk (C:)
    Top-Level Folder
SubFolder
}

  }
 フォルダーが既に存在していた場合、CreateDirectory は何も実行せず、例外はスローされません。 ただし File.Create は、 既存のファイルを新しいファイルに置き換えます。 この例では、 if - else ステートメントを使用して、既存のファイルが置き換え られないようにします。
この例に次の変更を加えることによって、特定の名前のファイルが既に存在するかどうかに基づいて異なる結果を指定できま す。 そのようなファイルが存在しない場合、コードによって作成されます。 このようなファイルがある場合、コードはそのファイルに データを追加します。
ランダムではないファイル名を指定します。
次のコードで、 if - else ステートメントを using に置き換えます。
    // Comment out the following line.
//string fileName = System.IO.Path.GetRandomFileName();
// Replace that line with the following assignment.
string fileName = "MyNewFile.txt";
     using (System.IO.FileStream fs = new System.IO.FileStream(pathString, FileMode.Append))
{
    for (byte i = 0; i < 100; i++)
    {
        fs.WriteByte(i);
    }
}
    } else {
return; }
        // Read and display the data from your file.
        try
        {
            byte[] readBuffer = System.IO.File.ReadAllBytes(pathString);
            foreach (byte b in readBuffer)
            {
                Console.Write(b + " ");
            }
            Console.WriteLine();
        }
        catch (System.IO.IOException e)
        {
            Console.WriteLine(e.Message);
        }
        // Keep the console window open in debug mode.
        System.Console.WriteLine("Press any key to exit.");
        System.Console.ReadKey();
    }
    // Sample output:
    // Path to my file: c:\Top-Level Folder\SubFolder\ttxvauxe.vv0
//0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 8 //3 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99
}
Console.WriteLine("File \"{0}\" already exists.", fileName);
 
            データがファイルに追加されたことを毎回確認するために、この例を数回実行します。 試用できるその他の FileMode 値については、FileModeを参照してください。 次の条件を満たす場合は、例外が発生する可能性があります。
フォルダー名が不適切である場合。 たとえば、不正な文字が含まれている場合や、空白だけの場合などがその例です (ArgumentException クラス)。 有効なパス名を作成するには、Path クラスを使用します。
作成するフォルダーの親フォルダーが読み取り専用である場合 (IOException クラス)。 フォルダー名が null である場合(ArgumentNullExceptionクラス)。 フォルダー名が長すぎる場合 (PathTooLongException クラス)。
フォルダー名がコロン (":") だけである場合 (PathTooLongException クラス)。
.NET セキュリティ
部分的に信頼された状況では、SecurityException クラスのインスタンスがスローされることがあります。
フォルダーの作成に必要なアクセス許可が与えられていない場合、この例では UnauthorizedAccessException クラスのインス タンスがスローされます。
関連項目
System.IO
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド)
 
           次の例では、System.IO 名前空間から System.IO.File、System.IO.Directory、System.IO.FileInfo、および System.IO.DirectoryInfo クラスを使用して、同期的な方法でファイルとフォルダーをコピー、移動および削除する方法を示しま す。 これらの例では、進行状況バーやその他のユーザー インターフェイスは表示されません。 標準の進行状況ダイアログ ボック スを表示する場合は、「ファイル操作の [進行状況] ダイアログ ボックスを表示する方法」を参照してください。
複数のファイルを操作するときに進行状況を計算できるイベントを提供するには、System.IO.FileSystemWatcher を使用しま す。 プラットフォーム呼び出しを使用して、Windows シェルで関連するファイル関連メソッドを呼び出す方法もあります。 これら のファイル操作を非同期に実行する方法については、「非同期ファイル I/O」を参照してください。
例 次の例では、ファイルとディレクトリをコピーする方法を示します。
ファイルおよびフォルダーをコピー、削除、およ
び移動する方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    例 次の例では、ファイルとディレクトリを移動する方法を示します。
  // Simple synchronous file copy operations with no user interface.
// To run this sample, first create the following directories and files:
// C:\Users\Public\TestFolder
// C:\Users\Public\TestFolder\test.txt
// C:\Users\Public\TestFolder\SubDir\test.txt
public class SimpleFileCopy
{
    static void Main()
    {
        string fileName = "test.txt";
        string sourcePath = @"C:\Users\Public\TestFolder";
        string targetPath =  @"C:\Users\Public\TestFolder\SubDir";
        // Use Path class to manipulate file and directory paths.
        string sourceFile = System.IO.Path.Combine(sourcePath, fileName);
        string destFile = System.IO.Path.Combine(targetPath, fileName);
        // To copy a folder's contents to a new location:
        // Create a new target folder.
        // If the directory already exists, this method does not create a new directory.
        System.IO.Directory.CreateDirectory(targetPath);
        // To copy a file to another location and
        // overwrite the destination file if it already exists.
        System.IO.File.Copy(sourceFile, destFile, true);
        // To copy all the files in one directory to another directory.
        // Get the files in the source folder. (To recursively iterate through
        // all subfolders under the current directory, see
        // "How to: Iterate Through a Directory Tree.")
        // Note: Check for target path was performed previously
        //       in this code example.
        if (System.IO.Directory.Exists(sourcePath))
        {
            string[] files = System.IO.Directory.GetFiles(sourcePath);
            // Copy the files and overwrite destination files if they already exist.
            foreach (string s in files)
            {
} }
} }
else {
// Use static Path methods to extract only the file name from the path.
fileName = System.IO.Path.GetFileName(s);
destFile = System.IO.Path.Combine(targetPath, fileName);
System.IO.File.Copy(s, destFile, true);
    Console.WriteLine("Source path does not exist!");
}
// Keep console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();

    例 次の例では、ファイルとディレクトリを削除する方法を示します。
     // Simple synchronous file move operations with no user interface.
public class SimpleFileMove
{
    static void Main()
    {
} }
string sourceFile = @"C:\Users\Public\public\test.txt";
string destinationFile = @"C:\Users\Public\private\test.txt";
// To move a file or folder to a new location:
System.IO.File.Move(sourceFile, destinationFile);
// To move an entire directory. To programmatically modify or combine
// path strings, use the System.IO.Path class.
System.IO.Directory.Move(@"C:\Users\Public\public\test\", @"C:\Users\Public\private");
 // Simple synchronous file deletion operations with no user interface.
// To run this sample, create the following files on your drive:
// C:\Users\Public\DeleteTest\test1.txt
// C:\Users\Public\DeleteTest\test2.txt
// C:\Users\Public\DeleteTest\SubDir\test2.txt
public class SimpleFileDelete
{
    static void Main()
    {
        // Delete a file by using File class static method...
        if(System.IO.File.Exists(@"C:\Users\Public\DeleteTest\test.txt"))
        {
            // Use a try block to catch IOExceptions, to
            // handle the case of the file already being
            // opened by another process.
            try
            {
                System.IO.File.Delete(@"C:\Users\Public\DeleteTest\test.txt");
            }
            catch (System.IO.IOException e)
            {
                Console.WriteLine(e.Message);
return; }
}
        // ...or by using FileInfo instance method.
        System.IO.FileInfo fi = new System.IO.FileInfo(@"C:\Users\Public\DeleteTest\test2.txt");
        try
        {
            fi.Delete();
        }
        catch (System.IO.IOException e)
        {
            Console.WriteLine(e.Message);
        }
        // Delete a directory. Must be writable or empty.
        try
        {
            System.IO.Directory.Delete(@"C:\Users\Public\DeleteTest");
        }
        catch (System.IO.IOException e)

       関連項目
System.IO
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド) ファイル操作の [進行状況] ダイアログ ボックスを表示する方法 ファイルおよびストリーム入出力
共通 I/O タスク
   } }
{
    Console.WriteLine(e.Message);
}
// Delete a directory and all subdirectories with Directory static method...
if(System.IO.Directory.Exists(@"C:\Users\Public\DeleteTest"))
{
try {
        System.IO.Directory.Delete(@"C:\Users\Public\DeleteTest", true);
    }
    catch (System.IO.IOException e)
    {
        Console.WriteLine(e.Message);
    }
}
// ...or with DirectoryInfo instance method.
System.IO.DirectoryInfo di = new System.IO.DirectoryInfo(@"C:\Users\Public\public");
// Delete this dir and all subdirs.
try
{
    di.Delete(true);
}
catch (System.IO.IOException e)
{
    Console.WriteLine(e.Message);
}
 
       CopyFile(String, String, UIOption) 名前空間の Microsoft.VisualBasic メソッドを使用すると、Windows でのファイル操作 に関する進行状況を示す標準ダイアログ ボックスを提供できます。
Visual Studio で参照を追加するには
1. メニュー バーで、 [プロジェクト] 、 [参照の追加] の順に選択します。
[参照マネージャー] ダイアログ ボックスが表示されます。
2. [アセンブリ] で、 [フレームワーク] を選択します (選択されていない場合)。
3. 名前の一覧で、 [Microsoft.VisualBasic] のチェック ボックスをオンにし、 [OK] をクリックしてダイアログ ボックスを閉 じます。
例
次のコードは、 sourcePath で指定されたディレクトリを destinationPath で指定されたディレクトリにコピーします。 また、操 作の完了までに必要な残りの予測時間を示す、標準的なダイアログ ボックスを表示します。
    NOTE
次の手順で参照している Visual Studio ユーザー インターフェイス要素の一部は、お使いのコンピューターでは名前や場所が異なる場合が あります。 これらの要素は、使用している Visual Studio のエディションや独自の設定によって決まります。 詳細については、「IDE をカスタマ イズする」をご覧ください。
       // The following using directive requires a project reference to Microsoft.VisualBasic.
using Microsoft.VisualBasic.FileIO;
class FileProgress
{
    static void Main()
    {
} }
// Specify the path to a folder that you want to copy. If the folder is small,
// you won't have time to see the progress dialog box.
string sourcePath = @"C:\Windows\symbols\";
// Choose a destination for the copied files.
string destinationPath = @"C:\TestFolder";
FileSystem.CopyDirectory(sourcePath, destinationPath,
    UIOption.AllDialogs);
 関連項目
ファイル システムとレジストリ (C# プログラミング ガイド)
ファイル操作の [進行状況] ダイアログ ボックス
を表示する方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
       この記事では、ファイルにテキストを書き込むさまざまな方法の例をいくつか示します。 最初の 2 つの例では、System.IO.File ク ラスの便利な静的メソッドを使用し、すべての IEnumerable<string> の各要素と string をテキストファイルに書き込みま す。 3 番目の例では、ファイルに書き込みながら各行を個別に処理する必要がある場合にテキストをファイルに追加する方法 を示します。 最初の 3 つの例では、ファイルの既存のコンテンツはすべて上書きします。 最後の例では、テキストを既存のファイ ルに追加する方法を示します。
これらの例はいずれもリテラル文字列をファイルに書き込みます。 ファイルに書き込まれるテキストの書式を設定する場合 は、Format メソッドまたは C# の文字列補間機能を使用します。
ファイルに文字列のコレクションを書き込む
      using System.IO;
using System.Threading.Tasks;
class WriteAllLines
{
    public static async Task ExampleAsync()
    {
        string[] lines =
        {
            "First line", "Second line", "Third line"
        };
        await File.WriteAllLinesAsync("WriteLines.txt", lines);
    }
}
 上記のソース コードの例では、次を行います。
3 つの値で文字列の配列をインスタンス化します。 次を行う、File.WriteAllLinesAsync に対する呼び出しを待機します。
非同期的に WriteLines.txt という名前のファイルを作成します。 既にある場合は、ファイルは上書きされます。 ファイルに指定した行を書き込みます。
必要に応じて、自動的にフラッシュおよび破棄し、ファイルを閉じます。
ファイルに文字列を 1 つ書き込む
テキスト ファイルに書き込む方法 (C# プログラ
ミング ガイド) 2021/03/06 • • Edit Online
 
      上記のソース コードの例では、次を行います。 割り当てられた文字列リテラルを指定して、文字列をインスタンス化します。 次を行う、File.WriteAllTextAsync に対する呼び出しを待機します。
非同期的に WriteText.txt という名前のファイルを作成します。 既にある場合は、ファイルは上書きされます。 指定したテキストをファイルに書き込みます。 必要に応じて、自動的にフラッシュおよび破棄し、ファイルを閉じます。
選択した文字列を配列からファイルに書き込む
    using System.IO;
using System.Threading.Tasks;
class StreamWriterOne
{
    public static async Task ExampleAsync()
    {
        string[] lines = { "First line", "Second line", "Third line" };
        using StreamWriter file = new("WriteLines2.txt");
        foreach (string line in lines)
        {
} }
}
if (!line.Contains("Second"))
{
    await file.WriteLineAsync(line);
}
 上記のソース コードの例では、次を行います。
3 つの値で文字列の配列をインスタンス化します。
using 宣言として WriteLines2.txt のファイル パスを使用して StreamWriter をインスタンス化します。 すべての行を反復処理します。
行に "Second" が含まれないときに、ファイルに行を書き込むStreamWriter.WriteLineAsync(String)に対する呼び出し を条件付きで待機します。
既存のファイルにテキストを追加する
    using System.IO;
using System.Threading.Tasks;
class WriteAllText
{
    public static async Task ExampleAsync()
    {
        string text =
            "A class is the most powerful data type in C#. Like a structure, " +
            "a class defines the data and behavior of the data type. ";
        await File.WriteAllTextAsync("WriteText.txt", text);
    }
}
 
           上記のソース コードの例では、次を行います。
3 つの値で文字列の配列をインスタンス化します。 using宣言としてWriteLines2.txtのファイルパスを使用し、追加するために true を渡してStreamWriterをインスタン ス化します。
文字列を追加された行としてファイルに書き込む、StreamWriter.WriteLineAsync(String) に対する呼び出しを待機しま す。
例外 次の条件を満たす場合は、例外が発生する可能性があります。
InvalidOperationException: ファイルは存在するが、読み取り専用である。 PathTooLongException: パス名が長すぎる。
IOException: ディスクがいっぱいになっている。
ファイル システムの操作時に例外が発生する可能性がある条件は他にもあるため、防御的なプログラムを書くことをお勧めしま す。
関連項目
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド) サンプル: コレクションをアプリケーション ストレージに保存する
   using System.IO;
using System.Threading.Tasks;
class StreamWriterTwo
{
    public static async Task ExampleAsync()
    {
        using StreamWriter file = new("WriteLines2.txt", append: true);
        await file.WriteLineAsync("Fourth line");
    }
}
 
          この例では、System.IO.File クラスの静的メソッド ReadAllText と ReadAllLines を使用してテキスト ファイルの内容を読み取り ます。
StreamReader の使用例については、「テキスト ファイルを 1 行ずつ読み取る方法」を参照してください。
例
    NOTE
この例では、「テキスト ファイルに書き込む方法」トピックで作成したファイルを使用しています。
     class ReadFromFile
{
    static void Main()
    {
} }
// The files used in this example are created in the topic
// How to: Write to a Text File. You can change the path and
// file name to substitute text files of your own.
// Example #1
// Read the file as one string.
string text = System.IO.File.ReadAllText(@"C:\Users\Public\TestFolder\WriteText.txt");
// Display the file contents to the console. Variable text is a string.
System.Console.WriteLine("Contents of WriteText.txt = {0}", text);
// Example #2
// Read each line of the file into a string array. Each element
// of the array is one line of the file.
string[] lines = System.IO.File.ReadAllLines(@"C:\Users\Public\TestFolder\WriteLines2.txt");
// Display the file contents by using a foreach loop.
System.Console.WriteLine("Contents of WriteLines2.txt = ");
foreach (string line in lines)
{
    // Use a tab to indent each line of the file.
    Console.WriteLine("\t" + line);
}
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
 コードのコンパイル
コードをコピーし、C# のコンソール アプリケーションに貼り付けます。
「テキスト ファイルに書き込む方法」のテキスト ファイルを使用せずに独自のテキスト ファイルを使用する場合は、 ReadAllText と   の引数を、ご使用のコンピューター上の該当するパスおよびファイル名に置き換えてください。
 テキスト ファイルから読み取る方法 (C# プログ
ラミング ガイド) 2020/11/02 • • Edit Online
  ReadAllLines
 
    信頼性の高いプログラミング 次の条件を満たす場合は、例外が発生する可能性があります。
ファイルが存在しない、または指定した場所に存在しない。 ファイル名のパスとスペルを確認してください。 .NET セキュリティ
ファイル名に基づいてファイルの内容を判断しないでください。たとえば、myFile.cs というファイルがC#のソースファイルではな い可能性もあります。
関連項目
System.IO
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド)
 
        次の例では、StreamReader クラスの ReadLine メソッドを使用して、テキストファイルの内容を一度に1行ずつ文字列に読 み込みます。各テキスト行は文字列 line に格納され、画面に表示されます。
例
    int counter = 0;
string line;
// Read the file and display it line by line.
System.IO.StreamReader file =
    new System.IO.StreamReader(@"c:\test.txt");
while((line = file.ReadLine()) != null)
{
    System.Console.WriteLine(line);
counter++; }
file.Close();
System.Console.WriteLine("There were {0} lines.", counter);
// Suspend the screen.
System.Console.ReadLine();
 コードのコンパイル
コードをコピーし、コンソールアプリケーションの Main メソッドに貼り付けます。
"c:\test.txt" を実際のファイル名に置き換えます。
信頼性の高いプログラミング 次の条件を満たす場合は、例外が発生する可能性があります。
ファイルが存在しない。 .NET セキュリティ
ファイル名からファイルの内容を判断しないでください。たとえば、myFile.cs ファイルがC#ソースファイルとは限りません。 関連項目
System.IO
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド)
  テキスト ファイルを 1 行ずつ読み取る方法 (C#
プログラミング ガイド) 2020/11/02 • • Edit Online
 
   現在のユーザーのレジストリに存在する "Names" というキーの下に "Name" と "Isabella" という値のペアを追加する例を次に 示します。
例
コードのコンパイル
コードをコピーし、コンソールアプリケーションの Main メソッドに貼り付けます。
Names パラメーターをレジストリのHKEY_CURRENT_USERノードの直下にあるキーの名前に置き換えます。 Name パラメーターをNamesノードの直下にある値の名前に置き換えます。
信頼性の高いプログラミング
レジストリの構造を調べて、キーの適切な場所を見つけることができます。 たとえば、現在のユーザーの Software キーを開き、 会社名のキーを作成できます。 その後で、会社名のキーにレジストリ値を追加します。
次の条件では例外が発生する可能性があります。
キーの名前が null である場合。
レジストリ キーを作成するためのアクセス許可がユーザーにない場合。 キー名が 255 文字の制限を超えている場合。 キーが閉じている場合。
レジストリ キーが読み取り専用の場合。
.NET セキュリティ
ローカル コンピューター ( ) よりもユーザー フォルダー (
) にデータを書き込む方が安全です。
レジストリの値を作成するときは、その値が既存の値である場合の処理を決めておく必要があります。 悪意のあるユーザーによっ て作成された別のプロセスが既に値を作成し、アクセス権を持っている可能性があります。 レジストリ値にデータを設定すると、 そのデータを他のプロセスから利用できるようになります。 これを回避するには、
Overload:Microsoft.Win32.RegistryKey.GetValue メソッドをオーバーライドします。このメソッドは、キーがまだ存在しない場 合、null を返します。
レジストリ キーがアクセス制御リスト (ACL: Access Control List) によって保護されていても、パスワードなど他人に知られたくな いデータをプレーン テキストでレジストリに格納するのは危険です。
    Microsoft.Win32.RegistryKey key;
key = Microsoft.Win32.Registry.CurrentUser.CreateSubKey("Names");
key.SetValue("Name", "Isabella");
key.Close();
  Microsoft.Win32.Registry.CurrentUser
 Microsoft.Win32.Registry.LocalMachine
 レジストリにキーを作成する方法 (C# プログラ
ミング ガイド) 2020/11/02 • • Edit Online
 
     関連項目
System.IO
C# プログラミング ガイド
ファイル システムとレジストリ (C# プログラミング ガイド)
C# によるレジストリからの読み取り、書き込み、および削除

                相互運用性は、アンマネージ コードへの既存の投資を保持して活用できるようにします。 共通言語ランタイム (CLR) の制御 下で実行されるコードはマネージド コードと呼ばれ、CLR の外部で実行されるコードはアンマネージド コードと呼ばれます。 アン マネージ コードの例は、COM、COM +、C++ コンポーネント、ActiveX コンポーネント、および Microsoft Windows API で す。
.NET では、プラットフォーム呼び出しサービス、System.Runtime.InteropServices 名前空間、C++ 相互運用性、および COM 相互運用性 (COM 相互運用機能) を通して、アンマネージド コードの相互運用を可能にしています。
このセクションの内容
相互運用性の概要
C# のマネージド コードとアンマネージド コードの間で相互運用する方法について説明します。 C# の機能を使用して Office 相互運用オブジェクトにアクセスする方法
Office のプログラミングを容易にするために Visual C# に導入されている機能について説明します。 COM 相互運用機能を使用したプログラミングでインデックス付きプロパティを使用する方法
インデックス付きプロパティを使用して、パラメーターを持つ COM プロパティにアクセスする方法について説明します。
プラットフォーム呼び出しを使用して WAV ファイルを再生する方法
プラットフォーム呼び出しサービスを使用して、Windows オペレーティング システム上の .wav サウンド ファイルを再生する方法 について説明します。
チュートリアル:Office プログラミング
Excel ブックと、ブックへのリンクを含む Word 文書を作成する方法を示します。
COM クラスの例
C# クラスを COM オブジェクトとして公開する方法を示します。
C# 言語仕様
詳細については、「C# 言語の仕様」の「基本概念」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性
のある情報源です。 関連項目
Marshal.ReleaseComObject
C# プログラミング ガイド アンマネージ コードとの相互運用 チュートリアル: Office プログラミング
相互運用性 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
         C# マネージド コードとアンマネージド コード間で相互運用を可能にする方法について説明します。 プラットフォーム呼び出し
"プラットフォーム呼び出し" とは、Microsoft Windows API にあるような、ダイナミックリンク ライブラリ (DLL) で実装されているア ンマネージド関数をマネージド コードで呼び出すことを可能にするサービスです。 これはエクスポートされた関数を見つけて呼び 出し、必要に応じて相互運用の境界を越えて、その引数 (整数、文字列、配列、構造体、その他) をマーシャリングします。
詳細については、「アンマネージ DLL 関数の処理」と「プラットフォーム呼び出しを使用して WAV ファイルを再生する方法」を参 照してください。
C++ Interop
It Just Works (IJW) とも呼ばれる C++ interop を使用してネイティブ C++ クラスをラップすると、このクラスを C# またはその他 の .NET 言語で作成されたコードで使用できるようになります。 これを行うには、C++ コードを記述して、ネイティブ DLL または COM コンポーネントをラップします。 他の .NET 言語とは異なり、Visual C++ には相互運用性サポートが備えられています。 これにより、マネージド コードとアンマネージド コードは同じアプリケーション内、また同じファイルでも共存できるようになります。 C++ コードは、マネージド アセンブリを生成する /clr コンパイラ スイッチを使用して構築できます。 最後に、C# プロジェクトの アセンブリへの参照を追加し、他のマネージド クラスを使用するときと同じように、ラップされたオブジェクトを使用します。
C# への COM コンポーネントの公開
C# プロジェクトから COM コンポーネントを使用することができます。 一般的な手順は次のとおりです。
1. 使用する COM コンポーネントを探して登録します。 regsvr32.exe を使用して、COM DLL の登録または登録解除を 行います。
2. プロジェクトに、COM コンポーネントまたはタイプ ライブラリへの参照を追加します。
参照を追加する際、Visual Studio は Tlbimp.exe (タイプ ライブラリ インポーター) を使用します。これにより、タイプ ラ イブラリを入力として取得し、.NET 相互運用アセンブリを出力します。 このアセンブリは、ランタイム呼び出し可能ラッ パー (RCW) とも呼ばれ、タイプ ライブラリ内の COM クラスとインターフェイスをラップする、マネージド クラスとインターフェ イスを含みます。 Visual Studio は、生成されたアセンブリへの参照をプロジェクトに追加します。
3. RCW で定義されているクラスのインスタンスを作成します。 これにより、COM オブジェクトのインスタンスが作成されま す。
4. 他のマネージド オブジェクトを使用するときと同様に、オブジェクトを使用します。 オブジェクトがガベージ コレクションに よって解放されるとき、COM オブジェクトのインスタンスもメモリから解放されます。
    NOTE
共通言語ランタイム (CLR) が、システム リソースへのアクセスを管理します。 CLR の外部のアンマネージ コードを呼び出すと、このセキュリ ティ メカニズムがバイパスされるため、セキュリティ リスクが生じます。 たとえば、アンマネージ コードがアンマネージ コード内のリソースを直接呼 び出した場合、CLR のセキュリティ機構がバイパスされます。 詳細については、「.NET でのセキュリティ」を参照してください。
 詳細については、「.NET Framework への COM コンポーネントの公開」を参照してください。
相互運用性の概要 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
           COM への C# の公開
COM クライアントは、適切に公開されている C# 型を使用できます。 C# 型を公開する基本的な手順は次のとおりです。 1. C#プロジェクトに相互運用属性を追加します。
アセンブリ COM は、Visual C# プロジェクト プロパティを変更することで参照できるようになります。 詳細については、 「[アセンブリ情報] ダイアログ ボックス」を参照してください。
2. COM タイプ ライブラリを生成し、COM の使用状況に登録します。
Visual C# プロジェクト プロパティを変更して、C# アセンブリが COM 相互運用に自動的に登録されるようにできます。 VisualStudioは /tlb コマンドラインスイッチを使用してRegasm.exe(アセンブリ登録ツール)を使用します。これに より、マネージド アセンブリが入力として取得され、タイプ ライブラリを生成できます。 タイプ ライブラリは、アセンブリ内の
public 型を記述し、レジストリエントリを追加することで、COMクライアントがマネージドクラスを作成できるようにしま す。
詳細については、「COM への .NET Framework コンポーネントの公開」と「COM クラスの例」を参照してください。 関連項目
相互運用パフォーマンスの向上
COM と .NET の相互運用性の概要
COM 相互運用の概要 (Visual Basic)
マネージド コードとアンマネージド コード間でのマーシャリング アンマネージ コードとの相互運用
C# プログラミング ガイド
 
     C# には、Office API オブジェクトへのアクセスを容易にする機能があります。 新機能は、名前付き引数と省略可能な引数、 dynamic と呼ばれる新しい型、値パラメーターの場合と同様にCOMメソッドの参照パラメーターに引数を渡す機能などです。
このトピックでは、新機能を使用して、Microsoft Office Excel ワークシートを作成および表示するコードを記述します。 その 後、Excel ワークシートにリンクされているアイコンを含む Office Word 文書を追加するコードを記述します。
このチュートリアルを実行するには、Microsoft Office Excel 2007 と Microsoft Office Word 2007 またはそれ以降のバー ジョンがコンピューターにインストールされている必要があります。
新しいコンソール アプリケーションを作成するには
1. Visual Studio を起動します。
2. [ファイル] メニューの [新規作成] をポイントし、 [プロジェクト] をクリックします。 [新しいプロジェクト] ダイアログ ボック スが表示されます。
3. [インストールされたテンプレート] ペインで、 [Visual C#] を展開し、 [Windows] をクリックします。
4. [新しいプロジェクト] ダイアログ ボックスの上部で、 .NET Framework 4 (またはそれ以降のバージョン) がターゲット
フレームワークとして選択されていることを確認します。
5. [テンプレート] ウィンドウで [コンソール アプリケーション] をクリックします。
6. [名前] フィールドに、プロジェクトの名前を入力します。
7. [OK] をクリックします。
ソリューション エクスプローラーに新しいプロジェクトが表示されます。
参照を追加するには
1. ソリューション エクスプローラーで、プロジェクトの名前を右クリックし、 [参照の追加] をクリックします。 [参照の追加] ダイアログ ボックスが表示されます。
2. [アセンブリ] ページの [コンポーネント名] 一覧で [Microsoft.Office.Interop.Word] を選択し、Ctrl キーを押し ながら [Microsoft.Office.Interop.Excel] を選択します。 アセンブリが表示されない場合は、アセンブリがインストー ルされ表示されることを確認する必要があります。 「方法:Office のプライマリ相互運用機能アセンブリをインストールす る」を参照してください。
3. [OK] をクリックします。
ディレクティブを使用して必要なものを追加するには
     NOTE
次の手順で参照している Visual Studio ユーザー インターフェイス要素の一部は、お使いのコンピューターでは名前や場所が異なる場合が あります。 これらの要素は、使用している Visual Studio のエディションや独自の設定によって決まります。 詳細については、「IDE をカスタマ イズする」をご覧ください。
 Office 相互運用オブジェクトにアクセスする方法
(C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
 1. ソリューション エクスプローラーで、Program.cs ファイルを右クリックし、 [コードの表示] をクリックします。 2. 次の using ディレクティブをコード ファイルの先頭に追加します。
銀行口座の一覧を作成するには
1. 次のクラス定義を Program.cs の Program クラスの下に貼り付けます。
2. 次のコードを Main メソッドに追加して、2 つの口座を含む bankAccounts 一覧を作成します。
    using Excel = Microsoft.Office.Interop.Excel;
using Word = Microsoft.Office.Interop.Word;
      public class Account
{
    public int ID { get; set; }
    public double Balance { get; set; }
}
      // Create a list of accounts.
var bankAccounts = new List<Account> {
new Account {
ID = 345678,
                  Balance = 541.27
                },
};
new Account {
ID = 1230221,
  Balance = -127.44
}
 口座情報を Excel にエクスポートするメソッドを宣言するには 1. 次のメソッドを Program クラスに追加して、Excel ワークシートを設定します。
Add メソッドには、特定のテンプレートを指定する省略可能なパラメーターがあります。 C# 4 の新機能であるオプション のパラメーターでは、パラメーターの既定値を使用する場合は、そのパラメーターの引数を省略することができます。 次の コードで引数が渡されないため、 Add は、既定のテンプレートを使用して、新しいブックを作成します。 以前のバージョ ンのC#では、同等のステートメントには、プレースホルダーの引数 ExcelApp.Workbooks.Add(Type.Missing) が必要 です。
      static void DisplayInExcel(IEnumerable<Account> accounts)
{
    var excelApp = new Excel.Application();
    // Make the object visible.
    excelApp.Visible = true;
    // Create a new, empty workbook and add it to the collection returned
    // by property Workbooks. The new workbook becomes the active workbook.
    // Add has an optional parameter for specifying a praticular template.
    // Because no argument is sent in this example, Add creates a new workbook.
    excelApp.Workbooks.Add();
    // This example uses a single workSheet. The explicit type casting is
    // removed in a later procedure.
    Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet;
}
 
  2. 次のコードを   の末尾に追加します。 このコードでは、ワークシートの最初の行の最初の 2 つの列に 値が挿入されます。
3. 次のコードを DisplayInExcel の末尾に追加します。 foreach ループでは、ワークシートの連続した行の最初の 2 つ の列に口座の一覧の情報が配置されます。
    // Establish column headings in cells A1 and B1.
workSheet.Cells[1, "A"] = "ID Number";
workSheet.Cells[1, "B"] = "Current Balance";
       var row = 1;
foreach (var acct in accounts)
{
    row++;
    workSheet.Cells[row, "A"] = acct.ID;
    workSheet.Cells[row, "B"] = acct.Balance;
}
  4. 次のコードを DisplayInExcel の末尾に追加して、コンテンツに合わせて列の幅を調整します。
C#の以前のバージョンでは、ExcelApp.Columns[1] が Object を返し、AutoFit がExcelRangeメソッドであるた め、これらの操作の明示的なキャストが必要です。 次の行にキャストを示します。
C# 4 以降のバージョンでは、アセンブリが -link コンパイラ オプションで参照される場合、または同等に、Excel の [相互 運用機能型の埋め込み]プロパティがtrueに設定されている場合は、返される Object が dynamic に自動的に 変換されます。 このプロパティの既定値は true です。
プロジェクトを実行するには 1. Main の末尾に次の行を追加します。
2. Ctrl キーを押しながら、F5 キーを押します。
2 つの口座からのデータを含む Excel ワークシートが表示されます。
Word 文書を追加するには
1. C# 4 およびそれ以降のバージョンで Office プログラミングを強化するその他の方法を説明するために、次のコードでは、
Word アプリケーションを開き、Excel ワークシートにリンクするアイコンを作成します。
この手順の後半で提供されている メソッドを クラスに貼り付けます。 Add メソッドと PasteSpecial メソッドの呼び出しに伴う複雑さが、 の名前付き引数と省略可能な引数によっ て軽減されます。 これらの呼び出しによって、C# 4 で導入された、参照パラメーターを持つ COM メソッドの呼び出しを 簡略化する 2 つの他の新しい機能が組み込まれます。 第一に、値パラメーターの場合と同様に参照パラメーターに引
    workSheet.Columns[1].AutoFit();
workSheet.Columns[2].AutoFit();
        ((Excel.Range)workSheet.Columns[1]).AutoFit();
((Excel.Range)workSheet.Columns[2]).AutoFit();
       // Display the list in an Excel spreadsheet.
DisplayInExcel(bankAccounts);
   CreateIconInWordDoc
Program
 CreateIconInWordDoc
 DisplayInExcel
 
 数を渡すことができます。 つまり、参照パラメーターごとに変数を作成することなく値を直接渡すことができます。 コンパイ ラは引数の値を保持する一時変数を生成し、呼び出しから戻るときに変数を破棄します。 第二に、引数リスト内の
ref キーワードを省略できます。
Add メソッドには4つの参照パラメーターがあり、これらはすべてオプションです。C#4.0およびそれ以降のバージョンで は、既定値を使用する場合は、任意またはすべてのパラメーターの引数を省略できます。 C# 3.0 およびそれ以前の バージョンでは、各パラメーターの引数を指定する必要があり、そのパラメーターが参照パラメーターであるため、引数は 変数である必要があります。
PasteSpecial メソッドは、クリップボードの内容を挿入します。このメソッドには7つの参照パラメーターがあり、これら はすべてオプションです。次のコードでは、クリップボードの内容のソースへのリンクを作成する Link とリンクをアイコンと して表示する DisplayAsIcon の2つの参照パラメーターの引数を指定します。C#4.0およびそれ以降のバージョンで は、これら2つに名前付き引数を使用して、その他を省略できます。これらは参照パラメーターですが、ref キーワー ドを使用したり、引数として渡す変数を作成したりする必要はありません。 値は直接渡すことができます。 C# 3.0 およ びそれ以前のバージョンでは、各参照パラメーターに変数引数を渡す必要があります。
      static void CreateIconInWordDoc()
{
    var wordApp = new Word.Application();
    wordApp.Visible = true;
    // The Add method has four reference parameters, all of which are
    // optional. Visual C# allows you to omit arguments for them if
    // the default values are what you want.
    wordApp.Documents.Add();
    // PasteSpecial has seven reference parameters, all of which are
    // optional. This example uses named arguments to specify values
    // for two of the parameters. Although these are reference
    // parameters, you do not need to use the ref keyword, or to create
    // variables to send in as arguments. You can send the values directly.
    wordApp.Selection.PasteSpecial( Link: true, DisplayAsIcon: true);
}
 C# 3.0 およびそれ以前のバージョンの言語では、次のより複雑なコードが必要です。

   2. 次のステートメントを Main の末尾に追加します。
3. 次のステートメントを DisplayInExcel の末尾に追加します。 Copy メソッドはクリップボードにワークシートを追加しま す。
4. Ctrl キーを押しながら、F5 キーを押します。
アイコンを含む Word 文書が表示されます。 ワークシートを前面に表示するアイコンをダブルクリックします。
[相互運用機能型の埋め込み] プロパティを設定するには
1. 実行時に、プライマリ相互運用機能アセンブリ (PIA) を必要としない COM 型を呼び出すときに、追加の拡張が可能で す。 PIA への依存関係を削除することによって、バージョンに依存しない、より簡単な展開が実現されます。 PIA を使 用しないプログラミングのメリットの詳細については、「チュートリアル: マネージド アセンブリからの型の埋め込み」をご覧くだ さい。
また、dynamic ではなく Object 型を使用して、COMメソッドに必要とされ、COMメソッドによって返される型を簡単 に表現できるため、プログラミングがより簡単になります。 型が   の変数は、明示的なキャストが不要になる実
    // Create a Word document that contains an icon that links to
// the spreadsheet.
CreateIconInWordDoc();
      // Put the spreadsheet contents on the clipboard. The Copy method has one
// optional parameter for specifying a destination. Because no argument
// is sent, the destination is the Clipboard.
workSheet.Range["A1:B3"].Copy();
      static void CreateIconInWordDoc2008()
{
    var wordApp = new Word.Application();
    wordApp.Visible = true;
    // The Add method has four parameters, all of which are optional.
    // In Visual C# 2008 and earlier versions, an argument has to be sent
    // for every parameter. Because the parameters are reference
    // parameters of type object, you have to create an object variable
    // for the arguments that represents 'no value'.
    object useDefaultValue = Type.Missing;
    wordApp.Documents.Add(ref useDefaultValue, ref useDefaultValue,
        ref useDefaultValue, ref useDefaultValue);
    // PasteSpecial has seven reference parameters, all of which are
    // optional. In this example, only two of the parameters require
    // specified values, but in Visual C# 2008 an argument must be sent
    // for each parameter. Because the parameters are reference parameters,
    // you have to contruct variables for the arguments.
    object link = true;
    object displayAsIcon = true;
    wordApp.Selection.PasteSpecial( ref useDefaultValue,
                                    ref link,
}
ref useDefaultValue,
ref displayAsIcon,
ref useDefaultValue,
ref useDefaultValue,
ref useDefaultValue);
  dynamic
 
     行時まで評価されません。 詳細については、「dynamic 型の使用」を参照してください。
C# 4 の既定の動作では、PIA を使用せずに型情報が埋め込まれます。 この既定のため、前の例のいくつかは、明示 的なキャストが必要ないために簡素化されます。 たとえば、 worksheet での DisplayInExcel の宣言は、
ています。
2. 既定値を変更し、型情報を埋め込むのではなく PIA を使用するには、ソリューション エクスプ ローラーで [参照設 定] ノードを展開し、 [Microsoft.Office.Interop.Excel] または [Microsoft.Office.Interop.Word] を選択 します。
3. [プロパティ] ウィンドウが表示されない場合は、F4 キーを押します。
4. プロパティの一覧で [相互運用機能型の埋め込み] を見つけて、値を [False] に変更します。 同様に、コマンド プロ
ンプトで -link の代わりに -reference コンパイラ オプションを使用してコンパイルすることができます。
テーブルに追加の書式設定を追加するには
   ではなく への呼び出しでも、既定値を使用せずに明示的なキャストが必要になります。これは、
  と記述されます。 同じメソッドの
が Object を返し、 AutoFit が Excel のメソッドであるためです。 次のコードはキャストを示し
Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet
  AutoFit
   ExcelApp.Columns[1]
    ((Excel.Range)workSheet.Columns[1]).AutoFit();
((Excel.Range)workSheet.Columns[2]).AutoFit();
   1.
AutoFit の DisplayInExcel への2つの呼び出しを次のステートメントに置き換えます。
AutoFormat メソッドには、7 つの値パラメーターがあり、これらはすべて省略可能です。 名前付き引数と省略可能な 引数を使用すると、一部またはすべてのパラメーターに引数を指定することができます。引数を指定しないこともできま す。前のステートメントでは、1つのパラメーター Format にのみ引数が指定されています。 Format はパラメーターリ ストの最初のパラメーターであるため、パラメーター名を指定する必要はありません。 ただし、次のコードに示すように、パ ラメーター名が含まれている場合、ステートメントがわかりやすい場合があります。
Ctrl + F5 キーを押して結果を表示します。 その他の形式は、XlRangeAutoFormat 列挙型のページに掲載されてい ます。
手順 1 のステートメントと、C# 3.0 およびそれ以前のバージョンで必要な引数が示されている次のコードを比較します。
    // Call to AutoFormat in Visual C# 2010.
workSheet.Range["A1", "B3"].AutoFormat(
    Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);
       // Call to AutoFormat in Visual C# 2010.
workSheet.Range["A1", "B3"].AutoFormat(Format:
    Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);
 2.
3.
Excel._Worksheet workSheet = excelApp.ActiveSheet
    // The AutoFormat method has seven optional value parameters. The
// following call specifies a value for the first parameter, and uses
// the default values for the other six.
// Call to AutoFormat in Visual C# 2008. This code is not part of the
// current solution.
excelApp.get_Range("A1", "B4").AutoFormat(Excel.XlRangeAutoFormat.xlRangeAutoFormatTable3,
    Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing,
    Type.Missing);
 
 例 コード例全体を次に示します。
    using System;
using System.Collections.Generic;
using System.Linq;
using Excel = Microsoft.Office.Interop.Excel;
using Word = Microsoft.Office.Interop.Word;
namespace OfficeProgramminWalkthruComplete
{
    class Walkthrough
    {
        static void Main(string[] args)
        {
            // Create a list of accounts.
            var bankAccounts = new List<Account>
            {
new Account {
ID = 345678,
                              Balance = 541.27
                            },
};
new Account {
ID = 1230221,
  Balance = -127.44
}
    // Display the list in an Excel spreadsheet.
    DisplayInExcel(bankAccounts);
    // Create a Word document that contains an icon that links to
    // the spreadsheet.
    CreateIconInWordDoc();
}
static void DisplayInExcel(IEnumerable<Account> accounts)
{
    var excelApp = new Excel.Application();
    // Make the object visible.
    excelApp.Visible = true;
    // Create a new, empty workbook and add it to the collection returned
    // by property Workbooks. The new workbook becomes the active workbook.
    // Add has an optional parameter for specifying a praticular template.
    // Because no argument is sent in this example, Add creates a new workbook.
    excelApp.Workbooks.Add();
    // This example uses a single workSheet.
    Excel._Worksheet workSheet = excelApp.ActiveSheet;
    // Earlier versions of C# require explicit casting.
    //Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet;
    // Establish column headings in cells A1 and B1.
    workSheet.Cells[1, "A"] = "ID Number";
    workSheet.Cells[1, "B"] = "Current Balance";
    var row = 1;
    foreach (var acct in accounts)
    {
        row++;
        workSheet.Cells[row, "A"] = acct.ID;
        workSheet.Cells[row, "B"] = acct.Balance;
}
workSheet.Columns[1].AutoFit();

         関連項目
Type.Missing
dynamic
dynamic 型の使用
名前付き引数と省略可能な引数
Office プログラミングで名前付き引数と省略可能な引数を使用する方法
} }
    workSheet.Columns[1].AutoFit();
    workSheet.Columns[2].AutoFit();
    // Call to AutoFormat in Visual C#. This statement replaces the
    // two calls to AutoFit.
    workSheet.Range["A1", "B3"].AutoFormat(
        Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);
    // Put the spreadsheet contents on the clipboard. The Copy method has one
    // optional parameter for specifying a destination. Because no argument
    // is sent, the destination is the Clipboard.
    workSheet.Range["A1:B3"].Copy();
}
static void CreateIconInWordDoc()
{
 var wordApp = new Word.Application();
wordApp.Visible = true;
// The Add method has four reference parameters, all of which are
// optional. Visual C# allows you to omit arguments for them if
// the default values are what you want.
wordApp.Documents.Add();
// PasteSpecial has seven reference parameters, all of which are
// optional. This example uses named arguments to specify values
// for two of the parameters. Although these are reference
// parameters, you do not need to use the ref keyword, or to create
// variables to send in as arguments. You can send the values directly.
wordApp.Selection.PasteSpecial(Link: true, DisplayAsIcon: true);
    public class Account
    {
        public int ID { get; set; }
        public double Balance { get; set; }
    }
}

        "インデックス付きプロパティ" により、パラメーターを持つ COM プロパティが C# プログラミングでいっそう使いやすくなります。 イン デックス付きプロパティは、名前付き引数と省略可能な引数、新しい型 (dynamic)、埋め込み型情報などの Visual C# の他 の機能と連携して、Microsoft Office プログラミングをいっそう強力なものにします。
以前のバージョンの C# では、プロパティとしてメソッドにアクセスできるのは、 get メソッドがパラメーターを持たず、 set メソッド が 1 つだけ値パラメーターを持つ場合に限られました。 しかし、すべての COM プロパティがこのような制限を満たしているわけで はありません。たとえば、ExcelのRange[]プロパティには、範囲の名前のパラメーターを必要とする get アクセサーがありま す。 これまでは、このような Range プロパティに直接アクセスすることはできず、次の例に示すように、 get_Range メソッドを代 わりに使う必要がありました。
インデックス付きプロパティを使うと、次のようなコードを記述できます。
     // Visual C# 2008 and earlier.
var excelApp = new Excel.Application();
// . . .
Excel.Range targetRange = excelApp.get_Range("A1", Type.Missing);
     // Visual C# 2010.
var excelApp = new Excel.Application();
// . . .
Excel.Range targetRange = excelApp.Range["A1"];
     NOTE
また、前の例では、省略可能な引数機能も使われており、 Type.Missing を省略できます。
  C#3.0以前でRangeオブジェクトの Value プロパティの値を設定する場合と同様に、2つの引数が必要です。1つのパラ メーターでは、範囲の値の型を指定する省略可能なパラメーターの引数を渡します。 そしてもう 1 つのパラメーターで、 Value プロパティの値を渡します。次の例は、これらの方法を示したものです。どちらも、セルA1の値を Name に設定しています。
インデックス付きプロパティを使うと、次のようなコードを記述できます。
独自のインデックス付きプロパティを作成することはできません。 この機能では、既存のインデックス付きプロパティの使用のみが サポートされます。
    // Visual C# 2008.
targetRange.set_Value(Type.Missing, "Name");
// Or
targetRange.Value2 = "Name";
     // Visual C# 2010.
targetRange.Value = "Name";
 COM 相互運用機能を使用したプログラミングで インデックス付きプロパティを使用する方法 (C#
プログラミング ガイド) 2020/11/02 • • Edit Online
 
         例
次に完全なコードの例を示します。 Office API にアクセスするプロジェクトを設定する方法の詳細については、「C# の機能を
使用して Office 相互運用オブジェクトにアクセスする方法」をご覧ください。
    // You must add a reference to Microsoft.Office.Interop.Excel to run
// this example.
using System;
using Excel = Microsoft.Office.Interop.Excel;
namespace IndexedProperties
{
    class Program
    {
        static void Main(string[] args)
        {
            CSharp2010();
            //CSharp2008();
        }
        static void CSharp2010()
        {
            var excelApp = new Excel.Application();
            excelApp.Workbooks.Add();
            excelApp.Visible = true;
            Excel.Range targetRange = excelApp.Range["A1"];
            targetRange.Value = "Name";
        }
        static void CSharp2008()
        {
} }
}
var excelApp = new Excel.Application();
excelApp.Workbooks.Add(Type.Missing);
excelApp.Visible = true;
Excel.Range targetRange = excelApp.get_Range("A1", Type.Missing);
targetRange.set_Value(Type.Missing, "Name");
// Or
//targetRange.Value2 = "Name";
 関連項目
名前付き引数と省略可能な引数
dynamic
dynamic 型の使用
Office プログラミングで名前付き引数と省略可能な引数を使用する方法 C# の機能を使用して Office 相互運用オブジェクトにアクセスする方法 チュートリアル: Office プログラミング

      以下の C# コードの例では、プラットフォーム呼び出しサービスを使用して、Windows オペレーティング システム上の WAV サウ ンド ファイルを再生する方法を示します。
例
このコード例では、DllImportAttributeを使って winmm.dll の PlaySound メソッドのエントリポイントを
Form1 PlaySound() としてインポートしています。 この例には、ボタンを含む簡単な Windows フォームがあります。 ボタンをク リックすると、Windows 標準の OpenFileDialog ダイアログ ボックスが開き、再生するファイルを開くことができます。 Wave ファ
イルを選ぶと、winmm.DLLライブラリの PlaySound() メソッドを使って再生されます。このメソッドの詳細については、「Using the PlaySound function with Waveform-Audio Files」(Waveform-Audio ファイルで PlaySound 関数を使用する) をご 覧ください。 .wav 拡張子を持つファイルを参照して選び、 [開く] をクリックすることで、プラットフォーム呼び出しを使って Wave ファイルを再生します。 テキスト ボックスに、選んだファイルの完全なパスが表示されます。
[ファイルを開く] ダイアログ ボックスは、次のフィルター設定によって拡張子 .wav を持つファイルのみを表示するようにフィルター 処理されます。
      dialog1.Filter = "Wav Files (*.wav)|*.wav";
 プラットフォーム呼び出しを使用して WAV ファ
イルを再生する方法 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    コードのコンパイル
1. Visual Studio で新しい C# Windows フォーム アプリケーション プロジェクトを作成し、WinSound という名前にしま す。
2. 上記のコードをコピーし、Form1.cs ファイルに貼り付けて内容を上書きします。
  using System.Windows.Forms;
using System.Runtime.InteropServices;
namespace WinSound
{
    public partial class Form1 : Form
    {
        private TextBox textBox1;
        private Button button1;
        public Form1()  // Constructor.
        {
            InitializeComponent();
        }
        [DllImport("winmm.DLL", EntryPoint = "PlaySound", SetLastError = true, CharSet = CharSet.Unicode,
ThrowOnUnmappableChar = true)]
        private static extern bool PlaySound(string szSound, System.IntPtr hMod, PlaySoundFlags flags);
        [System.Flags]
        public enum PlaySoundFlags : int
        {
            SND_SYNC = 0x0000,
            SND_ASYNC = 0x0001,
            SND_NODEFAULT = 0x0002,
            SND_LOOP = 0x0008,
            SND_NOSTOP = 0x0010,
            SND_NOWAIT = 0x00002000,
            SND_FILENAME = 0x00020000,
            SND_RESOURCE = 0x00040004
}
        private void button1_Click(object sender, System.EventArgs e)
        {
            var dialog1 = new OpenFileDialog();
            dialog1.Title = "Browse to find sound file to play";
            dialog1.InitialDirectory = @"c:\";
            dialog1.Filter = "Wav Files (*.wav)|*.wav";
            dialog1.FilterIndex = 2;
            dialog1.RestoreDirectory = true;
            if (dialog1.ShowDialog() == DialogResult.OK)
            {
                textBox1.Text = dialog1.FileName;
                PlaySound(dialog1.FileName, new System.IntPtr(), PlaySoundFlags.SND_SYNC);
            }
}
        private void Form1_Load(object sender, EventArgs e)
        {
} }
}
// Including this empty method in the sample because in the IDE,
// when users click on the form, generates code that looks for a default method
// with this name. We add it here to prevent confusion for those using the samples.

     3. 次のコードをコピーし、Form1.Designer.cs ファイルのすべての既存コードの後の   メソッドに貼 り付けます。
    this.button1 = new System.Windows.Forms.Button();
this.textBox1 = new System.Windows.Forms.TextBox();
this.SuspendLayout();
//
// button1
//
this.button1.Location = new System.Drawing.Point(192, 40);
this.button1.Name = "button1";
this.button1.Size = new System.Drawing.Size(88, 24);
this.button1.TabIndex = 0;
this.button1.Text = "Browse";
this.button1.Click += new System.EventHandler(this.button1_Click);
//
// textBox1
//
this.textBox1.Location = new System.Drawing.Point(8, 40);
this.textBox1.Name = "textBox1";
this.textBox1.Size = new System.Drawing.Size(168, 20);
this.textBox1.TabIndex = 1;
this.textBox1.Text = "FIle path";
//
// Form1
//
this.AutoScaleDimensions = new System.Drawing.SizeF(5, 13);
this.ClientSize = new System.Drawing.Size(292, 266);
this.Controls.Add(this.textBox1);
this.Controls.Add(this.button1);
this.Name = "Form1";
this.Text = "Platform Invoke WinSound C#";
this.ResumeLayout(false);
this.PerformLayout();
 4. コードをコンパイルして実行します。 関連項目
C# プログラミング ガイド
相互運用性の概要 プラットフォーム呼び出しの詳細 プラットフォーム呼び出しによるデータのマーシャリング
 InitializeComponent()
 
      Visual Studio には、Microsoft Office のプログラミングを改善する C# および Visual Basic の新機能が導入されています。 便利なC#の機能には、名前付き引数、省略可能な引数、型 dynamic の戻り値があります。COMプログラミングでは、
ref キーワードを省略し、インデックス付きプロパティにアクセスできます。VisualBasicの機能には、自動実装プロパティ、ラム ダ式内のステートメント、コレクション初期化子などがあります。
両方の言語で、ユーザーのコンピューターにプライマリ相互運用機能アセンブリ (PIA) を配置せずに COM コンポーネントとやり 取りするアセンブリを配置できる型情報を埋め込むことができます。 詳細については、「チュートリアル:マネージド アセンブリからの 型の埋め込み」をご覧ください。
このチュートリアルでは、Office プログラミングのコンテキストで機能を示しますが、これらの機能の多くは一般的なプログラミング にも便利です。 このチュートリアルでは、Excel ブックを作成する Excel アドイン アプリケーションを使用します。 次に、ブックへのリ ンクを含む Word 文書を作成します。 最後に、PIA 依存関係の有効/無効を切り替える方法を確認します。
必須コンポーネント
このチュートリアルを実行するには、Microsoft Office Excel と Microsoft Office Word をコンピューターにインストールしておく 必要があります。
Excel アドイン アプリケーションをセットアップするには
1. Visual Studio を起動します。
2. [ファイル] メニューの [新規作成] をポイントし、 [プロジェクト] をクリックします。
3. [インストールされたテンプレート] ペインで、 [Visual Basic] または [Visual C#] を展開し、 [Office] を展開し
て、Office 製品のバージョン年度をクリックします。
4. [テンプレート] ペインで、 [Excel <version> アドイン] をクリックします。
5. [テンプレート] ペインの上部で、 [ターゲット フレームワーク] ボックスに [.NET Framework 4] またはそれ以降の バージョンが表示されていることを確認します。
6. 必要に応じて、 [名前] ボックスにプロジェクトの名前を入力します。
7. [OK] をクリックします。
8. ソリューション エクスプローラーに新しいプロジェクトが表示されます。
参照を追加するには
1. ソリューション エクスプローラーで、プロジェクトの名前を右クリックし、 [参照の追加] をクリックします。 [参照の追加] ダイアログ ボックスが表示されます。
     NOTE
次の手順で参照している Visual Studio ユーザー インターフェイス要素の一部は、お使いのコンピューターでは名前や場所が異なる場合が あります。 これらの要素は、使用している Visual Studio のエディションや独自の設定によって決まります。 詳細については、「IDE をカスタマ イズする」をご覧ください。
  2.[アセンブリ]タブの[コンポーネント名]一覧で、Microsoft.Office.Interop.Excel、バージョン <version>.0.0.0
チュートリアル: Office のプログラミング (C# お
よび Visual Basic) 2020/11/02 • • Edit Online
 
      (Office 製品番号のキーについては、Microsoft バージョンに関するページを参照してください) を選択し、Ctrl キーを押 しながら Microsoft.Office.Interop.Word、 version <version>.0.0.0 を選択します。 アセンブリが表示されない 場合は、アセンブリがインストールされ、表示されることの確認が必要になることがあります (「方法: Office のプライマリ相 互運用機能アセンブリをインストールする」を参照)。
3. [OK] をクリックします。
必要な Imports ステートメントまたはディレクティブの使用を追加するには
1. ソリューション エクスプローラーで、 [ThisAddIn.vb] または [ThisAddIn.cs] ファイルを右クリックし、 [コードの表 示] をクリックします。
2.次の Imports ステートメント(VisualBasic)または using ディレクティブ(C#)が含まれていない場合は、コードファイ ルの先頭に追加します。
銀行口座の一覧を作成するには
      using System.Collections.Generic;
using Excel = Microsoft.Office.Interop.Excel;
using Word = Microsoft.Office.Interop.Word;
    1.
2.
ソリューション エクスプローラーで、プロジェクト名を右クリックし、 [追加] をクリックしてから [クラス] をクリックします。 Visual Basic を使用している場合は Account.vb、C# を使用している場合は Account.cs という名前をクラスに付けま す。 [追加] をクリックします。
Account クラスの定義を次のコードに置き換えます。このクラス定義では、自動実装プロパティが使用されます。詳細 については、「自動実装プロパティ」を参照してください。
     class Account
{
    public int ID { get; set; }
    public double Balance { get; set; }
}
     Public Class Account
    Property ID As Integer = -1
    Property Balance As Double
End Class
  3.
2 つの口座を含む 一覧を作成するには、次のコードを追加する、ThisAddIn.vb または ThisAddIn.cs の メソッドに追加します。 一覧の宣言では、コレクション初期化子が使用されます。 詳細につい ては、「コレクション初期化子」を参照してください。
Imports Microsoft.Office.Interop
bankAccounts
 ThisAddIn_Startup

      Dim bankAccounts As New List(Of Account) From {
    New Account With {
.ID = 345,
                          .Balance = 541.27
                     },
New Account With {
}
.ID = 123,
     .Balance = -127.44
}
 データを Excel にエクスポートするには
1. 同じファイル内で、次のメソッドを ThisAddIn クラスに追加します。 このメソッドは、Excel ブックを設定し、データを Excel ブックにエクスポートします。
     void DisplayInExcel(IEnumerable<Account> accounts,
           Action<Account, Excel.Range> DisplayFunc)
{
    var excelApp = this.Application;
    // Add a new Excel workbook.
    excelApp.Workbooks.Add();
    excelApp.Visible = true;
    excelApp.Range["A1"].Value = "ID";
    excelApp.Range["B1"].Value = "Balance";
    excelApp.Range["A2"].Select();
    foreach (var ac in accounts)
    {
        DisplayFunc(ac, excelApp.ActiveCell);
        excelApp.ActiveCell.Offset[1, 0].Select();
    }
    // Copy the results to the Clipboard.
    excelApp.Range["A1:B3"].Copy();
}
    var bankAccounts = new List<Account>
{
new Account {
ID = 345,
        Balance = 541.27
    },
new Account {
ID = 123,
        Balance = -127.44
    }
};
 
    C# の 2 つの新しい機能は、このメソッドで使用されます。 これら両方の機能は、Visual Basic で既に存在します。
Add メソッドには、特定のテンプレートを指定する省略可能なパラメーターがあります。 C# 4 の新機能であるオ プションのパラメーターでは、パラメーターの既定値を使用する場合は、そのパラメーターの引数を省略することが できます。 前の例では引数が渡されないため、 Add は、既定のテンプレートを使用して、新しいブックを作成し ます。 以前のバージョンの C# では、同等のステートメントには、プレースホルダーの引数
excelApp.Workbooks.Add(Type.Missing) が必要です。 詳細については、「名前付き引数と省略可能な引数」を参照してください。
Rangeオブジェクトの Range および Offset プロパティではインデックス付きプロパティ機能を使用します。この 機能では、次の一般的な C# 構文を使用して COM 型からこれらのプロパティを使用することができます。 ま た、インデックス付きプロパティを使用すると、 Value プロパティを使用せずに、 Range オブジェクトの Value2 プロパティを使用できます。 Value プロパティはインデックス付きですが、インデックスはオプションです。次の例で は、省略可能な引数とインデックス付きプロパティは連携しています。
以前のバージョンの言語では、次の特殊な構文が必要です。
独自のインデックス付きプロパティを作成することはできません。 この機能では、既存のインデックス付きプロパティ の使用のみがサポートされます。
詳細については、「COM 相互運用機能を使用したプログラミングでインデックス付きプロパティを使用する方法」 を参照してください。
2. 次のコードを DisplayInExcel の末尾に追加して、コンテンツに合わせて列の幅を調整します。
       // Visual C# 2010 provides indexed properties for COM programming.
excelApp.Range["A1"].Value = "ID";
excelApp.ActiveCell.Offset[1, 0].Select();
     // In Visual C# 2008, you cannot access the Range, Offset, and Value
// properties directly.
excelApp.get_Range("A1").Value2 = "ID";
excelApp.ActiveCell.get_Offset(1, 0).Select();
     Sub DisplayInExcel(ByVal accounts As IEnumerable(Of Account),
               ByVal DisplayAction As Action(Of Account, Excel.Range))
    With Me.Application
        ' Add a new Excel workbook.
        .Workbooks.Add()
        .Visible = True
        .Range("A1").Value = "ID"
        .Range("B1").Value = "Balance"
        .Range("A2").Select()
        For Each ac In accounts
            DisplayAction(ac, .ActiveCell)
            .ActiveCell.Offset(1, 0).Select()
Next
        ' Copy the results to the Clipboard.
        .Range("A1:B3").Copy()
    End With
End Sub
 
          ' Add the following two lines at the end of the With statement.
.Columns(1).AutoFit()
.Columns(2).AutoFit()
 これらの追加機能では、C# の別の機能である、dynamic 型がある場合と同様に Office などの COM ホストから返さ れる Object 値の処理を示します。これは、[相互運用機能型の埋め込み]が既定値の True に設定されている 場合、または同様に、アセンブリが-linkコンパイラオプションによって参照されている場合に発生します。 dynamic 型 では既に Visual Basic で使用できる遅延バインディングが可能であり、C# 3.0 以前のバージョンの言語で必要だった 明示的なキャストが回避されます。
たとえば、 は を返し、AutoFit はExcelのRangeメソッドであるとします。 がない場合、 のインスタンスとして、 Range によって返されたオブジェクトをキャストし
てから、 メソッドを呼び出す必要があります。
相互運用機能型の埋め込みの詳細については、このトピックの後半の「PIA 参照を検索するには」および「PIA の依存 関係を復元するには」の手順を参照してください。 dynamic の詳細については、「dynamic(C#リファレンス)」または 「dynamic 型の使用 (C# プログラミング ガイド)」を参照してください。
DisplayInExcel を起動するには
1. ThisAddIn_StartUp メソッドの末尾に、次のコードを追加します。 DisplayInExcel に対する呼び出しには、2 つの 引数が含まれています。 最初の引数は、処理する口座の一覧の名前です。 2 番目の引数は、データの処理方法を 定義する複数行のラムダ式です。各口座の ID 値と balance 値が隣接するセルに表示され、残高が0より少ない 場合、行が赤で表示されます。 詳細については、「ラムダ式」を参照してください。
     excelApp.Columns[1]
Object
 dynamic
 excelApp.Columns[1]
 AutoFit
    // Casting is required in Visual C# 2008.
((Excel.Range)excelApp.Columns[1]).AutoFit();
// Casting is not required in Visual C# 2010.
excelApp.Columns[1].AutoFit();
         DisplayInExcel(bankAccounts, (account, cell) =>
// This multiline lambda expression sets custom processing rules
// for the bankAccounts.
{
    cell.Value = account.ID;
    cell.Offset[0, 1].Value = account.Balance;
    if (account.Balance < 0)
    {
        cell.Interior.Color = 255;
        cell.Offset[0, 1].Interior.Color = 255;
    }
});
    excelApp.Columns[1].AutoFit();
excelApp.Columns[2].AutoFit();
 
   2. プログラムを実行するには、F5 キーを押します。 口座からのデータを含む Excel ワークシートが表示されます。 Word 文書を追加するには
 1.
ThisAddIn_StartUp メソッドの末尾に次のコードを追加して、Excelブックへのリンクを含むWord文書を作成します。
    var wordApp = new Word.Application();
wordApp.Visible = true;
wordApp.Documents.Add();
wordApp.Selection.PasteSpecial(Link: true, DisplayAsIcon: true);
     Dim wordApp As New Word.Application
wordApp.Visible = True
wordApp.Documents.Add()
wordApp.Selection.PasteSpecial(Link:=True, DisplayAsIcon:=True)
 このコードは、COMプログラミングで ref キーワードを省略する機能、名前付き引数、省略可能な引数など、C#の 新機能のいくつかを示します。 Visual Basic でこれらの機能は既に存在します。 PasteSpecial メソッドには 7 つのパラ メーターがあります。これらはすべて省略可能な参照パラメーターとして定義されます。 名前付き引数と省略可能な引 数を使用すると、アクセスするパラメーターを名前で指定し、これらのパラメーターにのみ引数を渡すことができます。 この 例では、引数は、クリップボードのブックへのリンクを作成する必要があること(Link パラメーター)、およびリンクがアイコン としてWord文書に表示されること(DisplayAsIcon パラメーター)を示すために渡されます。VisualC#では、これら の引数の ref キーワードを省略することもできます。
 アプリケーションを実行するには
1.F5キーを押してアプリケーションを実行します。Excelが起動し、bankAccounts の2つの口座からの情報が格納された
テーブルが表示されます。 Excel テーブルへのリンクを含む Word 文書が表示されます。 完成したプロジェクトをクリーンアップするには
1. Visual Studio で、 [ビルド] メニューの [ソリューションのクリーン] をクリックします。 それ以外の場合は、コンピューターで Excel を起動するたびにアドインが実行されます。
PIA 参照を検索するには
1. もう一度アプリケーションを実行しますが、 [ソリューションのクリーン] はクリックしません。
2. [開始] を選択します。 Microsoft Visual Studio <version> を見つけ、開発者コマンド プロンプトを開きます。
3. [Developer Command Prompt for Visual Studio](Visual Studio 用開発者コマンド プロンプト) ウィンドウに「
ildasm 」と入力し、Enter キーを押します。 [IL DASM] ウィンドウが表示されます。
4. [IL DASM] ウィンドウの [ファイル] メニューで [ファイル] > [開く] をクリックします。 Visual Studio <version> をダ ブルクリックしてから、 [プロジェクト] をダブルクリックします。 プロジェクトのフォルダーを開き、bin/Debug フォルダーでプ ロジェクト名.dll を見つけます。 プロジェクト名.dll をダブルクリックします。 新しいウィンドウに、他のモジュールおよびアセ ンブリへの参照に加えて、プロジェクトの属性が表示されます。名前空間 Microsoft.Office.Interop.Excel と
      DisplayInExcel(bankAccounts,
       Sub(account, cell)
           ' This multiline lambda expression sets custom
           ' processing rules for the bankAccounts.
           cell.Value = account.ID
           cell.Offset(0, 1).Value = account.Balance
           If account.Balance < 0 Then
               cell.Interior.Color = RGB(255, 0, 0)
               cell.Offset(0, 1).Interior.Color = RGB(255, 0, 0)
           End If
       End Sub)
 
          はアセンブリに含まれています。 Visual Studio の既定では、コンパイラは、参照 PIA からアセンブリに必要な型をインポートします。
詳細については、「方法:アセンブリの内容を表示する」を参照してください。
5. MANIFEST アイコンをダブルクリックします。 プロジェクトによって参照される項目を含んでいるアセンブリの一覧を含む ウィンドウが表示されます。 Microsoft.Office.Interop.Excel および Microsoft.Office.Interop.Word は一覧に 含まれていません。 プロジェクトに必要な型がアセンブリにインポートされているため、PIA への参照は必要ありません。 これにより、配置が容易になります。 PIA がユーザーのコンピューター上に存在している必要がなく、アプリケーションに特 定のバージョンの PIA を配置する必要がないので、すべてのバージョンに必要な API が存在している場合は、複数の バージョンの Office を使用するようにアプリケーションを設計できます。
PIA の配置が不要になったため、以前のバージョンを含む複数のバージョンの Office で動作する高度なシナリオで、ア プリケーションを作成できます。 ただし、これは、コードで、使用している Office のバージョンでは利用できない APIを使 用していない場合にのみ機能します。 特定の API が以前のバージョンで利用可能かどうかは常に明確ではないため、 以前のバージョンの Office の使用はお勧めできません。
6. マニフェスト ウィンドウとアセンブリ ウィンドウを閉じます。
PIA の依存関係を復元するには
1. ソリューション エクスプローラーで、 [すべてのファイルを表示] ボタンをクリックします。 [参照] フォルダーを展開し、 [Microsoft.Office.Interop.Excel] を選択します。 F4 キーを押して [プロパティ] ウィンドウを表示します。
2. [プロパティ] ウィンドウで、 [相互運用機能型の埋め込み] プロパティを [True] から [False] に変更します。
3. Microsoft.Office.Interop.Word について、この手順の手順1と2を繰り返します。
4. C# では、 Autofit メソッドの最後で DisplayInExcel への 2 つの呼び出しをコメント化します。
5. プロジェクトが正常に実行することを確認するには、F5 キーを押します。
6.アセンブリウィンドウを開くには、前の手順の手順1~3を繰り返します。 Microsoft.Office.Interop.Word と Microsoft.Office.Interop.Excel は、埋め込まれたアセンブリの一覧には表示されません。
7. MANIFEST アイコンをダブルクリックし、参照アセンブリのリストをスクロールします。 Microsoft.Office.Interop.Word と Microsoft.Office.Interop.Excel の両方が一覧に表示されています。アプリケーションがExcelとWordのPIAを 参照し、 [相互運用機能型の埋め込み] プロパティを [False] に設定しているため、両方のアセンブリがエンド ユー ザーのコンピューター上に存在する必要があります。
8. Visual Studio で、 [ビルド] メニューの [ソリューションのクリーン] をクリックして、完成したプロジェクトをクリーンアップし ます。
関連項目
自動実装プロパティ (Visual Basic) 自動実装するプロパティ (C#) コレクション初期化子 オブジェクト初期化子とコレクション初期化子 省略可能なパラメーター 位置と名前による引数渡し 名前付き引数と省略可能な引数
      NOTE
Office 2003 より前の Office では、PIA は発行されません。 そのため、Office 2002 以前のバージョンの相互運用機能アセンブリ を生成する唯一の方法は、COM 参照のインポートです。
         Microsoft.Office.Interop.Word
 
            事前バインディングと遅延バインディング
dynamic
dynamic 型の使用
ラムダ式 (Visual Basic)
ラムダ式 (C#)
COM 相互運用機能を使用したプログラミングでインデックス付きプロパティを使用する方法 チュートリアル: Visual Studio で Microsoft Office アセンブリからの型情報を埋め込む チュートリアル: マネージド アセンブリからの型の埋め込み
チュートリアル: 初めての Excel 用 VSTO アドインの作成
COM 相互運用
相互運用性

     ここでは、COM オブジェクトとして公開されるクラスの例を紹介します。 このコードを .cs ファイルに保存して、プロジェクトに追加 したあと、 [COM の相互運用機能に登録] プロパティを [True] に設定します。 詳細については、コンポーネントを COM 相 互運用機能に登録する」をご覧ください。
Visual C# オブジェクトを COM に公開するには、クラス インターフェイス、イベント インターフェイス (必要な場合)、クラス自体を 宣言する必要があります。 クラスのメンバーを COM で参照するには、次の規則に従う必要があります。
クラスはパブリックであること。 プロパティ、メソッド、およびイベントがパブリックであること。 プロパティとメソッドがクラス インターフェイスで宣言されていること。 イベントがイベント インターフェイスで宣言されていること。
これらのインターフェイスで宣言されていない、クラス内の他のパブリック メンバーは、COM から参照されませんが、他の .NET オ ブジェクトからは参照されます。
プロパティとメソッドをCOMに公開するには、それらをクラスインターフェイスで宣言し、DispId 属性でマークを付けて、クラス に実装する必要があります。 メンバーをインターフェイスで宣言する順序は、COM vtable で使用される順序になります。
クラスのイベントを公開するには、それらをイベント インターフェイスで宣言し、 DispId 属性でマークを付ける必要があります。 クラスでこのインターフェイスを実装しないでください。
クラスでは、クラス インターフェイスが実装されます。複数のインターフェイスを実装できますが、最初に実装されるのは、既定のク ラス インターフェイスです。 ここで、COM に対して公開するプロパティとメソッドを実装します。 プロパティとメソッドは、パブリックと してマークされており、クラス インターフェイスの宣言と一致する必要があります。 また、ここでクラスから発生するイベントを宣言 します。 イベントは、パブリックとしてマークされており、イベント インターフェイスの宣言と一致する必要があります。
例
      using System.Runtime.InteropServices;
namespace project_name
{
    [Guid("EAA4976A-45C3-4BC5-BC0B-E474F4C3C83F")]
    public interface ComClass1Interface
    {
    }
    [Guid("7BD20046-DF8C-44A6-8F6B-687FAA26FA71"),
        InterfaceType(ComInterfaceType.InterfaceIsIDispatch)]
    public interface ComClass1Events
    {
    }
    [Guid("0D53A3E8-E51A-49C7-944E-E72A2064F938"),
        ClassInterface(ClassInterfaceType.None),
        ComSourceInterfaces(typeof(ComClass1Events))]
    public class ComClass1 : ComClass1Interface
    {
    }
}
 COM クラスの例 (C# プログラミング ガイド) 2020/11/02 • • Edit Online
 
    関連項目
C# プログラミング ガイド
相互運用性
[ビルド] ページ (プロジェクト デザイナー) (C#)

                このセクションでは、C# のキーワード、演算子、特殊文字、プリプロセッサ ディレクティブ、コンパイラ オプション、およびコンパイラ のエラーと警告に関する参考資料を紹介します。
このセクションの内容
C# のキーワード
C# のキーワードと構文に関する情報へのリンクを示します。
C# 演算子
C# の演算子と構文に関する情報へのリンクを示します。
C# 特殊文字
C# のコンテキスト特殊文字とその使用方法に関する情報へのリンクを提供します。
C# プリプロセッサ ディレクティブ
C# ソース コード内に埋め込むためのコンパイラ コマンドに関する情報へのリンクを提供します。
C# コンパイラ オプション
コンパイラ オプションとその使用方法について取り上げます。
C# コンパイラ エラー
C# コンパイラのエラーや警告の原因と修正法を示すコード スニペットを示します。
C# 言語仕様
C# 6.0 の言語仕様です。 これは、C# 6.0 言語に関するドラフト提案です。 このドキュメントは、ECMA C# 標準委員会との 共同作業により改良されています。 バージョン 5.0 は、Standard ECMA-334 5th Edition ドキュメントとして 2017 年 12 月 にリリースされています。
C# 6.0 より後のバージョンで実装された機能は、言語仕様の提案に示されています。 これらのドキュメントでは、言語仕様に 加えた新機能の内容が説明されています。 これらはドラフト提案の形式です。 これらの仕様は、改良ののち、正式なレビュー を行うために ECMA 標準委員会に提出され、C# 標準の今後のバージョンに組み込まれる予定です。
C# 7.0 仕様の提案
C# 7.0 では多数の新機能が実装されます。 これには、パターン マッチング、ローカル関数、out 変数宣言、throw 式、バイナ リ リテラル、および桁区切り文字が含まれます。 このフォルダーには、これらの各機能に関する仕様が含まれています。
C# 7.1 仕様の提案
C#7.1には新しい機能が追加されています。まず、Task または Task<int> を返す Main メソッドを記述できます。これに より、 async 修飾子を Main に追加することができます。 型を推論できる場所では型なしで default 式を使用することが できます。 また、タプルのメンバー名を推論することができます。 最後に、ジェネリックにはパターン マッチングを使用できます。
C# 7.2 仕様の提案
C#7.2では小さな機能が複数追加されています。 in キーワードを使用してreadonly参照によって引数を渡すことができま す。 Span および関連する型についてコンパイル時の安全性をサポートするために低レベルの変更が複数加えられました。名 前付き引数を使用できます。この場合、状況によって、後の引数は位置指定引数となります。 private protected アクセス 修飾子を使用すると、呼び出し元が同じアセンブリ内で実装された派生型に限定されるように指定することができます。 ?: 演算子は変数への参照に解決される可能性があります。 先頭の桁区切り記号を使用して 16 進数と 2 進数の書式を設定 することもできます。
C# 7.3 仕様の提案
C#7.3 は、いくつかの小規模な更新プログラムを含む別個のポイント リリースです。 ジェネリック型パラメーターに対して新しい制 約を使用できます。 その他の変更により、 fixed フィールドの操作が簡単になります。これには、 stackalloc 割り当ての使 用も含まれます。 ref キーワードを使用して参照されるローカル変数は、新しいストレージを参照するように再割り当てされる 場合があります。 コンパイラによって生成されたバッキング フィールドを対象とする自動実装プロパティに属性を配置することがで
    C# リファレンス 2021/03/06 • • Edit Online
 
     きます。 初期化子内で式の変数を使用できます。 タプルは、等値 (または非等値) を確認するために比較することができま す。 オーバーロードの解決法に対してもいくつかの改良が行われました。
C# 8.0 仕様の提案
C# 8.0 は .NET Core 3.0 で使用できます。 null 許容参照型、再帰的なパターン マッチング、既定のインターフェイス メソッ ド、非同期ストリーム、範囲とインデックス、using および using 宣言に基づくパターン、null 合体演算子割り当て、読み取り 専用インスタンス メンバーなどの機能が含まれています。
C# 9.0 仕様の提案
C# 9.0 は .NET 5.0 で使用できます。 特徴としては、レコード、最上位のステートメント、パターン マッチングの拡張、初期化の みのセッター、ターゲット型の新しい式、モジュール初期化子、部分メソッドの拡張、静的匿名関数、型指定された条件式、共 変の戻り値の型、foreach ループでの拡張機能 GetEnumerator、ラムダ ディスカード パラメーター、ローカル関数の属性、ネイ ティブ サイズの整数、関数ポインター、localsinit フラグの出力の抑制、制約のない型パラメーターの注釈が含まれます。
関連項目
C# 用 Visual Studio 開発環境の使用
IDE およびエディターについて説明する概念トピックおよびタスク トピックへのリンクを提供します。
C# プログラミング ガイド
C# プログラミング言語の使用方法について説明します。

            最新の C# コンパイラでは、プロジェクトのターゲット フレームワーク (1 つまたは複数) に基づいて既定の言語バージョンが決定さ れます。 Visual Studio には値を変更するための UI がありませんが、それは csproj ファイルを編集することで変更できます。 既定値を選択すれば、ターゲット フレームワークと互換性がある最新の言語バージョンが使用されます。 プロジェクトのターゲット と互換性がある最新の言語機能にアクセスできるという利点があります。 また、このように既定値を選択すると、ターゲット フ レームワークで利用できない型や実行時動作を必要とする言語が使用されません。 既定値より新しい言語バージョンを選択 すると、コンパイル時間や実行時エラーの診断が困難になることがあります。
この記事の規則は、Visual Studio 2019 または .NET SDK に付属するコンパイラに適用されます。 Visual Studio 2017 イン ストールまたは以前の .NET Core SDK バージョンに含まれる C# コンパイラは、既定で C# 7.0 を対象とします。
C# 8.0 は、.NET Core 3.x 以降のバージョンでのみサポートされています。 最新機能の多くには、.NET Core 3.x で導入された ライブラリとランタイムの機能が必要になります。
既定のインターフェイスの実装では、.NET Core 3.0 CLR の新機能が必要です。 非同期ストリームには、新しい型
System.IAsyncDisposable、System.Collections.Generic.IAsyncEnumerable<T>、System.Collections.Generic.IAsyncEnumerat が必要です。
インデックスと範囲には、新しい型 System.Index と System.Range が必要です。
null 許容参照型では、より適切な警告を提供するためにいくつかの属性が利用されます。 その属性は .NET Core 3.0 で 追加されました。 他のターゲット フレームには、そのような属性に関する注釈が付けられていません。 つまり、null 許容警告 は潜在的な問題を正確に反映していない可能性があります。
C# 9.0 は、.NET 5 以降のバージョンでのみサポートされています。 [既定値]
コンパイラでは、以下の規則に基づいて既定値が決定されます。
      .NET
.NET Core
.NET Core
.NET Standard .NET Standard .NET Standard .NET Framework
VERSION C #
5.x C# 9.0 3.x C# 8.0 2.x C# 7.3 2.1 C# 8.0 2.0 C# 7.3 1.x C# 7.3 all C# 7.3
                                       ご自分のプロジェクトが、対応するプレビュー バージョンの言語を持つプレビュー フレームワークをターゲットにしている場合、使用 される言語バージョンはプレビュー バージョンの言語です。 環境を問わず、そのプレビューでは最新の機能が使用されます。リ リース済みの .NET Core バージョンをターゲットにするプロジェクトに影響はありません。
C# 言語のバージョン管理 2021/03/16 • • Edit Online
 or<T>

        既定値のオーバーライド
C# のバージョンを明示的に指定する必要がある場合は、いくつかの方法で実行できます。
プロジェクト ファイルを手動で編集する。 サブディレクトリ内の複数のプロジェクトに対して言語バージョンを設定する。
-langversion コンパイラオプションを構成する。
プロジェクト ファイルを編集する
プロジェクト ファイルで言語のバージョンを設定できます。 たとえば、プレビュー機能に明示的にアクセスしたい場合は、次のよう に要素を追加します。
値 preview では、コンパイラでサポートされている使用可能な最新のプレビューC#言語バージョンが使用されます。 複数のプロジェクトを構成する
複数のプロジェクトを構成するには、<LangVersion> 要素を含むDirectory.build.propsファイルを作成します。この操作 は通常、ソリューション ディレクトリで実行します。 ソリューション ディレクトリ内の Directory.Build.props ファイルに以下を追 加します。
そのファイルが含まれるディレクトリのすべてのサブディレクトリ内のビルドで、プレビュー C# バージョンが使用されます。 詳細につい ては、「ビルドのカスタマイズ」を参照してください。
C# 言語バージョン リファレンス
次の表では、現在のすべての C# 言語バージョンを示します。 コンパイラが古い場合、一部の値が正しく解釈されない可能性
があります。 最新の .NET SDK をインストールすると、一覧表示されているすべてにアクセスできます。 [ ]
preview コンパイラは、最新のプレビュー バージョンの有効な言語構文をすべて 受け入れます。
     TIP
現在使用している言語バージョンを確認するには、コードに #error version を入れます (大文字と小文字を区別します)。 このように すると、コンパイラによって、コンパイラ エラー CS8304 と、使用されているコンパイラのバージョンと現在選択されている言語バージョンが含ま れるメッセージが報告されます。 詳細については、「#error (C# リファレンス)」を参照してください。
      <PropertyGroup> <LangVersion>preview</LangVersion>
</PropertyGroup>
       <Project> <PropertyGroup>
<LangVersion>preview</LangVersion> </PropertyGroup>
</Project>
           IMPORTANT
Visual Studio 2017 では、作成されたすべてのプロジェクト ファイルに <LangVersion>latest</LangVersion> エントリが追加されまし た。 これは、追加されたときには C# 7.0 を意味しました。 しかし、Visual Studio 2019 にアップグレードすると、ターゲット フレームワークに 関係なく、それは最新リリース バージョンを意味します。 これらのプロジェクトでは既定の動作がオーバーライドされるようになります。 プロジェ クト ファイルを編集して、そのノードを削除する必要があります。 その後、プロジェクトでは、ターゲット フレームワークに対して推奨されるコンパ イラ バージョンが使用されます。
  
   [ ]
    latest
latestMajor ( default )
9.0
8.0
7.3
7.2
7.1
7
6
5
4
3
ISO-2 (または 2 )
ISO-1 (または 1 )
コンパイラは、最新リリース バージョンのコンパイラ (マイナー バージョン を含む) の構文を受け入れます。
コンパイラは、最新リリースのメジャー バージョンのコンパイラの構文を 受け入れます。
コンパイラは、C# 9.0 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 8.0 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 7.3 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 7.2 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 7.1 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 7.0 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 6.0 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 5.0 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 4.0 以下に含まれている構文のみを受け入れます。
コンパイラは、C# 3.0 以下に含まれている構文のみを受け入れます。
コンパイラは、ISO/IEC 23270:2006 C# (2.0) に含まれている構文 のみを受け入れます。
コンパイラは、ISO/IEC 23270:2003 C# (1.0/1.2) に含まれている 構文のみを受け入れます。
                                                            TIP
お使いのマシンで使用可能な言語バージョンの一覧を表示するには、開発者コマンドライン シェルを開き、次のコマンドを実行します。
このように -langversion コンパイル オプションをクエリすると、次のような内容が出力されます。
  csc -langversion:?
     Supported language versions: default
1
2
3
4
5
6
7.0
7.1
7.2
7.3
8.0
9.0 (default) latestmajor preview latest
  
   C# 型の 2 つの主なカテゴリは、値型 と 参照型です。 値型の変数には、その型のインスタンスが含まれます。 これは、その型の インスタンスへの参照を含む参照型の変数とは異なります。 既定では、代入時、引数がメソッドに渡され、メソッドの結果が返 され、変数値がコピーされます。 値型の変数の場合、対応する型のインスタンスがコピーされます。 次の例は、その動作を示し ます。
   前の例のとおり、値型変数に対する操作は、その変数に格納されている値型のインスタンスのみに影響します。
値型に参照型のデータ メンバーが含まれている場合は、値型のインスタンスがコピーされるとき、その参照型のインスタンスへの 参照のみがコピーされます。 コピーと元の値型のインスタンスの両方が、同じ参照型のインスタンスにアクセスできます。 次の例 は、その動作を示します。
値型 (C# リファレンス) 2021/03/06 • • Edit Online
   using System;
public struct MutablePoint
{
    public int X;
    public int Y;
    public MutablePoint(int x, int y) => (X, Y) = (x, y);
    public override string ToString() => $"({X}, {Y})";
}
public class Program
{
    public static void Main()
    {
        var p1 = new MutablePoint(1, 2);
        var p2 = p1;
        p2.Y = 200;
        Console.WriteLine($"{nameof(p1)} after {nameof(p2)} is modified: {p1}");
        Console.WriteLine($"{nameof(p2)}: {p2}");
        MutateAndDisplay(p2);
        Console.WriteLine($"{nameof(p2)} after passing to a method: {p2}");
    }
    private static void MutateAndDisplay(MutablePoint p)
    {
p.X = 100;
        Console.WriteLine($"Point mutated in a method: {p}");
    }
}
// Expected output:
// p1 after p2 is modified: (1, 2)
// p2: (1, 200)
// Point mutated in a method: (100, 200)
// p2 after passing to a method: (1, 200)

         値型と型制約の種類 値型には、次の 2 種類のいずれかを指定できます。
データと関連機能をカプセル化する構造体の型 名前付き定数のセットによって定義され、選択肢または選択肢の組み合わせを表す、列挙型
null許容値型 T? は、基になる値型のすべての値 T と、追加のnull値を表します。値型の変数には、Null許容値型で ない限り null を割り当てることはできません。
制約を使用して、型パラメーターが null 非許容値型であることを指定できます。 構造体と列挙型の型は、どちらも
制約を満たしています。C#7.3以降、基底クラス制約(列挙の制約と呼ばれます)で System.Enum を使用して、 型パラメーターが列挙型であることを指定できます。
組み込みの値型
C# には、単純型 とも呼ばれる次の組み込み値型が用意されています。
 struct
  struct
 整数数値型
   using System;
using System.Collections.Generic;
public struct TaggedInteger
{
    public int Number;
    private List<string> tags;
    public TaggedInteger(int n)
    {
Number = n;
        tags = new List<string>();
    }
    public void AddTag(string tag) => tags.Add(tag);
    public override string ToString() => $"{Number} [{string.Join(", ", tags)}]";
}
public class Program
{
    public static void Main()
    {
        var n1 = new TaggedInteger(0);
        n1.AddTag("A");
        Console.WriteLine(n1);  // output: 0 [A]
        var n2 = n1;
        n2.Number = 7;
        n2.AddTag("B");
        Console.WriteLine(n1);  // output: 0 [A, B]
        Console.WriteLine(n2);  // output: 7 [A, B]
    }
}
   NOTE
ご自分のコードをエラーがより発生しにくく、より堅牢にするには、変更できない値型を定義して使用します。 この記事では、デモンストレー ションの目的でのみ、変更可能な値型を使用します。
 
      浮動小数点数値型
ブール値を表す bool
Unicode UTF-16 文字を表す char
すべての単純型は構造体型で、それらには他の構造体型とは異なる特定の追加操作があります。
単純型の値の指定には、リテラルを使用できます。 たとえば、 'A' は char 型のリテラルで、 2001 は int 型のリテ ラルです。
単純型の定数は、const キーワードを使用して宣言できます。 他の構造体型の定数は使用できません。
オペランドがすべて単純型の定数の定数式は、コンパイル時に評価されます。
C# は C# 7.0 以降で、値のタプルをサポートしています。 値のタプルは単純型ではない値型です。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
値型 単純型 変数
関連項目
C# リファレンス System.ValueType 参照型

               整数数値型 (C# リファレンス) 2020/05/14 • • Edit Online
 "整数数値型" は、整数値を表します。 すべての整数数値型は、値の型です。 また、単純型でもあり、リテラルを使用して初 期化することができます。 すべての整数数値型では、算術、ビット論理、比較、等値演算子がサポートされています。
整数型の特性
C# では、次の定義済みの整数型がサポートされています。
C# /
sbyte -128 ~ 127
byte 0 ~ 255
short -32,768 ~ 32,767 ushort 0 ~ 65,535
int -2,147,483,648 ~ 2,147,483,647
uint 0 ~ 4,294,967,295
符号付き 8 ビット整数 符号なし 8 ビット整数 符号付き 16 ビット整数 符号なし 16 ビット整数 符号付き 32 ビット整数
符号なし 32 ビット整数
.NET
System.SByte System.Byte System.Int16 System.UInt16 System.Int32
System.UInt32
                                                       long
- 9,223,372,036,854,775,808 から 9,223,372,036,854,775,807
         ulong
0~ 18,446,744,073,709,551,61 5
上の表で、左端の列にある各 C# 型のキーワードは、対応する .NET 型の別名です。 これらは交換可能です。 たとえば、次の 宣言では同じ型の変数が宣言されています。
各整数型の既定値はゼロ ( 0 ) です。 各整数型には、その型の最小値と最大値を指定する MinValue および MaxValue 定数があります。
System.Numerics.BigInteger 構造体を使用して、上限や下限のない符号付き整数を表します。
整数リテラル 次の整数リテラルがあります。
"10 進": プレフィックスなし
"16 進": 0x または 0X プレフィックスを使用します
"バイナリ": 0b または 0B プレフィックスを使用します (C# 7.0 以降で使用できます)
次のコードは、それぞれの例を示しています。
符号付き 64 ビット整数
符号なし 64 ビット整数
System.Int64
 System.UInt64
     int a = 123; System.Int32 b = 123;
       var decimalLiteral = 42;
var hexLiteral = 0x2A;
var binaryLiteral = 0b_0010_1010;
 
          前述の例は、C#7.0以降でサポートされている"桁区切り記号"としての _ の使用法も示しています。数字区切り記号 は、あらゆる種類の数値リテラルで使用できます。
整数リテラルの型は、そのサフィックスによって次のように決まります。
サフィックスがないリテラルの型は、 int 、 uint 、 long 、 ulong の型のうちその値を表すことができる最初のものになり ます。
リテラルのサフィックスが U または u の場合、その型は、 uint 、 ulong の型のうちその値を表すことができる最初のも のになります。
リテラルのサフィックスが L または l の場合、その型は、 long 、 ulong の型のうちその値を表すことができる最初のも のになります。
リテラルのサフィックスが UL、Ul、uL、ul、LU、Lu、lU、または lu の場合、その型は ulong です。
整数リテラルで表される値が UInt64.MaxValue を超えると、コンパイル エラー CS1021 が発生します。
整数リテラルの決定された型が int で、リテラルで表される値が変換先の型の範囲内にある場合、値を暗黙的に sbyte 、 byte 、 short 、 ushort 、 uint 、または ulong に変換できます。
前の例で示したように、リテラルの値が変換先の型の範囲内にない場合、コンパイラ エラー CS0031 が発生します。 また、キャストを使用して、整数リテラルによって表される値を、指定された型のリテラル以外の型に変換することもできます。
変換
任意の整数数値型を他の整数数値型に変換することができます。 変換先の型に変換元の型のすべての値を格納できる場 合、変換は暗黙的に実行されます。 それ以外の場合は、キャスト式を使用して明示的な変換を実行する必要があります。 詳細については、「組み込みの数値変換」に関するページを参照してください。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
整数型 整数リテラル
関連項目
C# リファレンス
値型
浮動小数点型 標準の数値書式指定文字列 .NET における数値
    NOTE
小文字の l はサフィックスとして使用できます。ただし、文字の l は数字の 1 と混同しやすいため、コンパイラから警告が出 されます。 わかりやすくするために L を使用してください。
   byte a = 17;
byte b = 300; // CS0031: Constant value '300' cannot be converted to a 'byte'
   var signedByte = (sbyte)42; var longVariable = (long)42;
 
           "浮動小数点数値型" は実数を表します。 浮動小数点数値型は、値の型です。 また、単純型でもあり、リテラルを使用して 初期化することができます。 すべての浮動小数点数値型は、算術、比較、および等値演算子をサポートしています。
浮動小数点型の特性
C# では、次の定義済みの浮動小数点型がサポートされています。
C# /
float
double
decimal
±1.5 x 10−45 から ±3.4x1038
±5.0 × 10−324 - ±1.7 × 10308
±1.0 x 10-28 から ±7.9228 x 1028
~6 ~9 桁
~15-17 桁
28 から 29 桁の数字
4 バイト
8 バイト
16 バイト
.NET
System.Single
System.Double
System.Decimal
                                     上の表の左端の列にある各 C# 型/キーワードは、対応する .NET 型の別名です。 これらは交換可能です。 たとえば、次の宣 言では、同じ型の変数が宣言されています。
各浮動小数点型の既定値はゼロ 0 です。各浮動小数点型には、その型の最小および最大有限値を指定する
MinValue および 定数があります。 float および double 型では、数字ではない値や無限値を表す定数も提
供されています。 たとえば、 型では、定数 Double.NaN、Double.NegativeInfinity、Double.PositiveInfinity が提 供されています。
decimal 型は、必要な精度が小数点の右側の桁数によって決まる場合に適しています。このような数値は、財務アプリケー ションで金額 ($1.00 など) や金利 (2.625% など) などによく使用されます。 1 つの 10 進数字だけで表される数値でさえも、
decimal 型を使用するとより正確に処理されます。たとえば、0.1は decimal インスタンスでは正確に表すことができますが、 0.1が正確に表される double または float のインスタンスは存在しません。このような数値型の違いにより、10進データに
double または float を使用すると、算術計算で予期しない丸めエラーが発生する可能性があります。精度を保証するよ りパフォーマンスを最適化する方が重要な場合は、 decimal ではなく double を使用することができます。 ただし、大量の計 算処理が必要なアプリケーションでもない限り、パフォーマンスの違いに気付くことはありません。 decimal を避ける理由として もう 1 つ考えられるのは、必要な記憶域を最小限に抑えることです。 たとえば、データ セットが非常に大きい場合は 4 バイトと 16バイトの差が積み重なって意味を持つようになるため、ML.NETでは float が使用されています。詳細については、 「System.Decimal」を参照してください。
整数型と float および double 型を1つの式の中で混在させることができます。この場合、整数型は、浮動小数点型の1 つに暗黙的に変換されます。また、必要に応じて、 float 型は double に暗黙的に変換されます。 この式は、次のように評 価されます。
式に 型がある場合、リレーショナル比較と等価比較で、式は double 、または bool に評価されます。
式に 型がない場合、リレーショナル比較と等価比較で、式は float 、または bool に評価されます。
    double a = 12.3;
System.Double b = 12.3;
    MaxValue
 double
           double
  double
 浮動小数点数値型 (C# リファレンス) 2021/03/06 • • Edit Online
 
       また、整数型と   型を 1 つの式の中で混在させることもできます。 この場合、整数型は   型に暗黙的に変 換され、リレーショナル比較と等価比較で、式は decimal 、または bool に評価されます。
decimal 型と float および double 型を1つの式の中で混在させることはできません。この場合、算術演算、比較演算、 または等値演算を実行するには、次の例に示すように、 decimal 型との間でオペランドを明示的に変換する必要があります。
浮動小数点値の書式指定には、標準の数値書式指定文字列またはカスタムの数値書式指定文字列のいずれかを使用で きます。
実数リテラル 実数リテラルの型は、サフィックスによって次のように決まります。
サフィックスがない、または d または D のリテラルは double 型です サフィックスが f または F のリテラルは float 型です
サフィックスが m または M のリテラルは decimal 型です
次のコードは、それぞれの例を示しています。
decimal
decimal
          double a = 1.0;
decimal b = 2.1m;
Console.WriteLine(a + (double)b);
Console.WriteLine((decimal)a + b);
       double d = 3D;
d = 4d;
d = 3.934_001;
float f = 3_000.5F;
f = 5.4f;
decimal myMoney = 3_000.5m;
myMoney = 400.75M;
 前述の例は、C#7.0以降でサポートされている"桁区切り記号"としての _ の使用法も示しています。数字区切り記号 は、あらゆる種類の数値リテラルで使用できます。
次の例に示すように、指数表記を使用して、実数リテラルの指数部を指定することもできます。
    double d = 0.42e2;
Console.WriteLine(d);  // output 42
float f = 134.45E-2f;
Console.WriteLine(f);  // output: 1.3445
decimal m = 1.5E6m;
Console.WriteLine(m);  // output: 1500000
 変換
浮動小数点数値型の間には、float から double に対する暗黙的な変換が1つだけあります。ただし、明示的なキャス トを使用して、任意の浮動小数点型を他の浮動小数点型に変換することはできます。 詳細については、「組み込みの数値 変換」に関するページを参照してください。
 C# 言語仕様

         詳細については、「C# 言語仕様」の次のセクションを参照してください。
浮動小数点型 decimal 型 実数リテラル
関連項目
C# リファレンス
値型
整数型 標準の数値書式指定文字列 .NET における数値 System.Numerics.Complex

       C# では、整数数値型と浮動小数点数値型のセットを提供します。 任意の 2 つの数値型の間で、暗黙的または明示的のい ずれかの変換が存在します。 明示的な変換を実行するには、キャスト式を使用する必要があります。
暗黙の数値変換 組み込みの数値型間の定義済みの暗黙的な変換を次の表に示します。
FROM
sbyte
short
int uint long ulong float
short 、 int 、 long 、 float 、 double 、または decimal
int 、 long 、 float 、 double 、または decimal
long 、 float 、 double 、または decimal
long 、 ulong 、 float 、 double 、または decimal float 、 double 、または decimal
float 、 double 、または decimal
double
         byte
    short 、 、 int 、 uint 、 long 、 ulong 、 float 、 、または
ushort
  double
decimal
      ushor t
    int 、 uint 、 long 、 ulong 、 float 、 double 、または decimal
                                 NOTE
int 、 uint 、 long 、または ulong から float および long または ulong から double への暗黙的な変換では、精度が 失われる可能性がありますが、桁違いの損失は発生しません。 その他の暗黙的な数値変換では、情報が失われることはありません。
  次の点にも注意してください。 整数数値型はすべて、あらゆる浮動小数点数値型に暗黙的に変換できます。
byte および sbyte 型への暗黙的な変換はありません。 double および decimal 型からの暗黙的な変換はありま せん。
decimal 型と float 型または double 型の間に暗黙的な変換はありません。
型 int の定数式の値 (整数リテラルで表される値など) は、それが変換先の型の範囲内にある場合、 sbyte 、 byte 、 short 、 ushort 、 uint 、または ulong に暗黙的に変換できます。
     組み込みの数値変換 (C# リファレンス) 2020/11/02 • • Edit Online
 
       前の例で示したように、定数値が変換先の型の範囲内にない場合、コンパイラ エラー CS0031 が発生します。 明示的な数値変換
次の表では、暗黙的な変換がない組み込みの数値型間で事前定義されている明示的変換を示しています。 FROM
     sbyte byte short ushor t int uint
byte 、 ushort 、 uint 、または ulong sbyte
         sbyte
sbyte
sbyte
sbyte
、 byte 、 ushort 、 uint 、または ulong
、 byte 、または short
、 byte 、 short 、 ushort 、 uint 、または ulong 、 byte 、 short 、 ushort 、または int
                 long
   sbyte 、 byte 、 short 、 ushort 、 int 、 uint 、または ulong
   ulong
   sbyte 、 byte 、 short 、 ushort 、 int 、 uint 、または long
   float
   sbyte 、 byte 、 short 、 ushort 、 int 、 uint 、 long 、 ulong 、または
 decimal
   double
   sbyte 、 byte 、 short 、 、 int 、 uint 、 long 、 ulong 、 float 、または
ushort
 decimal
    decimal
    sbyte 、 byte 、 short 、 、 int 、 uint 、 long 、 ulong 、 float 、または
ushort
 double
     NOTE
明示的な数値変換によって、データが失われたり、例外がスローされたりすることがあります (通常は OverflowException)。
 次の点にも注意してください。
ある整数型の値を別の整数型に変換するとき、その結果は、オーバーフロー チェック コンテキストによって変わります。 checked コンテキストでは、変換元の値が変換先の型の範囲内にあるとき、変換に成功します。 それ以外の場合 は、OverflowException がスローされます。 unchecked コンテキストでは、変換は常に成功し、次のように続行されま す。
変換元の型が変換先の型より大きい場合、変換元の値はその "余分な" 最上位ビットを破棄することで切り詰 められます。 結果は変換先の型の値として扱われます。
変換元の型が変換先の型より小さい場合、変換元の値は変換先の型と同じサイズになるように、符号拡張ま
   byte a = 13;
byte b = 300;  // CS0031: Constant value '300' cannot be converted to a 'byte'
 
          たはゼロ拡張されます。 変換元の型に符号が付いている場合は符号拡張が利用され、符号が付いていない 場合はゼロ拡張が利用されます。 結果は変換先の型の値として扱われます。
変換元の型が変換先の型と同じサイズの場合、変換元の値は変換先の型の値として扱われます。
decimal 値を整数型に変換するとき、この値は0方向に最も近い整数値に丸められます。結果的に生成される整
数値が変換先の型の範囲外になった場合、OverflowException がスローされます。
double または float 値を整数型に変換するとき、この値は0方向に最も近い整数値に丸められます。結果的に 生成される整数値が変換先の型の範囲外になる場合、結果はオーバーフロー チェック コンテキストによって変わりま す。 チェック済みコンテキストの場合、OverflowException がスローされます。未チェック コンテキストの場合、結果は変 換先の型の不特定な値になります。
double を float に変換すると、 double 値は最も近い float 値に丸められます。 double 値が小さすぎるか、 大きすぎて float 型に合わない場合、結果は0か無限になります。
float または double を decimal に変換するとき、変換元の値は decimal 表現に変換され、必要であれば、28 番目の小数位の後に最も近い数字に丸められます。 変換元の値によっては、結果は次のいずれかになります。
変換元の値が小さすぎて decimal として表現できない場合、結果は0になります。 変換元の値がNaN(NotaNumber/数字ではない)か、無限か、大きすぎて decimal として表現できない
場合、OverflowException がスローされます。
decimal を float または double に変換すると、変換元の値はそれぞれ最も近い float または double 値に丸
められます。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
暗黙の数値変換 明示的な数値変換
関連項目
C# リファレンス キャストと型変換
             
                bool 型キーワードは、ブール値(true または false のいずれか)を表す.NETSystem.Boolean構造体型のエイリアスで す。
bool 型の値を使って論理演算を実行するには、ブール論理演算子を使用します。 bool 型は、比較および等値演算子の 結果の型です。 bool 式は、if、do、while、およびforステートメントおよび条件演算子 ?: で制御条件式にすることがで きます。
bool 型の既定値は false です。 リテラル
true および false リテラルを使用して、 bool 変数を初期化したり、 bool 値を渡したりすることができます。
3 値ブール型ロジック
3値ロジックをサポートする必要がある場合は、null許容型の bool? を使用します。たとえば、3値ブール型をサポートする データベースを操作する場合などです。 bool? オペランドの場合、定義済みの & 演算子と | 演算子は3値ロジックをサ ポートします。 詳細については、「Boolean logical operators (ブール論理演算子)」記事の「Nullable Boolean logical operators (null 許容論理演算子)」セクションを参照してください。
null 許容値型の詳細については、「null 許容値型」を参照してください。 コンバージョン
C#には、bool 型が関係する変換が2つのみ用意されています。対応するnull許容型の bool? への暗黙的な変換と、 bool? 型からの明示的な変換です。ただし、.NETには、bool 型との間の変換に使用できる追加のメソッドが用意されてい
ます。 詳細については、System.Boolean API リファレンス ページの「ブール値との間の変換」セクションを参照してください。 C# 言語仕様
詳細については、C# 言語仕様の「Bool 型」セクションを参照してください。 関連項目
C# リファレンス
値型
true および false 演算子
    bool check = true;
Console.WriteLine(check ? "Checked" : "Not checked");  // output: Checked
Console.WriteLine(false ? "Checked" : "Not checked");  // output: Not checked
 bool (C# リファレンス) 2020/11/02 • • Edit Online
 
          char 型のキーワードは、UnicodeUTF-16文字を表す.NETSystem.Char構造体型のエイリアスです。 .NET
char U+0000 ~ U+FFFF 16 ビット System.Char char 型の既定値は \0 (つまりU+0000)です。
char 型では、比較演算子、等値演算子、インクリメント演算子、およびデクリメント演算子がサポートされています。さらに、
char オペランドの場合、算術演算子およびビット論理演算子によって、対応する文字コードに対する演算が実行され、 int 型の結果が生成されます。
string型では、 char 値のシーケンスとしてテキストを表わします。 リテラル
char 値は以下で指定できます。
文字リテラル。
Unicodeエスケープシーケンス。これは \u の後に文字コードの16進数表現(4つの記号)を続けたものになります。 16進数エスケープシーケンス。これは \x の後に文字コードの16進数表現を続けたものになります。
                var chars = new[]
{
    'j',
    '\u006A',
    '\x006A',
    (char)106,
};
Console.WriteLine(string.Join(" ", chars));  // output: j j j j
 前の例に示したように、文字コードの値をそれに対応する char 値に型変換することもできます。
    NOTE
Unicode エスケープ シーケンスの場合、4 つの 16 進数をすべて指定する必要があります。 つまり、 \u006A は有効なエスケープ シーケン スであり、 \u06A と \u6A は有効ではありません。
16 進数エスケープ シーケンスの場合、先頭のゼロを省略できます。 つまり、エスケープ シーケンスの \x006A 、 \x06A 、 \x6A は有効 であり、同じ文字に対応します。
   変換
char 型は、整数型 ( 、 int 、 uint 、 long 、 ulong ) に暗黙的に変換できます。 また、組み込みの浮動小数 点数値型 ( float 、 、 ) に暗黙的に変換することもできます。 sbyte 、 byte 、 short 整数型に明示的 に変換できます。
 ushort
  double
decimal
他の型から char 型へと暗黙的に変換することはできません。 しかし、整数または浮動小数点の数値型は、 char に明示
char (C# リファレンス) 2020/11/02 • • Edit Online
 
     的に変換できます。 C# 言語仕様
詳細については、「C# 言語仕様」の整数型に関するセクションを参照してください。 関連項目
C# リファレンス
値型
文字列 System.Text.Rune .NET での文字エンコード

      "列挙型" は、基になる 整数値型の一連の名前付き定数によって定義された 値の型です。 列挙型を定義するには、 enum キーワードを使用して "列挙型メンバー" の名前を指定します。
既定では、列挙型メンバーの関連する定数値の型は int で、0から始まり、定義テキストの順序に従って1ずつ増加しま す。 他の任意の整数値型を、列挙型の基になる型として明示的に指定できます。 また、次の例に示すように、関連する定 数値を明示的に指定することもできます。
列挙型の定義内でメソッドを定義することはできません。 列挙型に機能を追加するには、拡張メソッドを作成します。 列挙型 E の既定値は、式 (E)0 によって生成される値です。この値は、ゼロに対応する列挙メンバーがなくても生成されま
す。
列挙型を使用して、相互に排他的な一連の値の選択肢、または選択肢の組み合わせを表します。 選択肢の組み合わせを 表すには、列挙型をビット フラグとして定義します。
ビット フラグとしての列挙型
列挙型で選択肢の組み合わせを表したいときは、個々の選択肢がビット フィールドになるように、列挙型メンバーをそれらの選 択肢に対して定義します。 つまり、これらの列挙型メンバーの関連する値は、2 の累乗である必要があります。 次に、ビットごと の論理演算子 | または & を使用し、選択肢を組み合わせたり、選択肢の組み合わせを交差させたりすることができます。 列挙型によってビット フィールドが宣言されていることを示すには、フラグ属性を適用します。 次の例に示すように、列挙型の定 義に一般的な組み合わせをいくつか含めることもできます。
  列挙型 (C# リファレンス) 2021/03/06 • • Edit Online
    enum Season {
    Spring,
    Summer,
    Autumn,
    Winter
}
    enum ErrorCode : ushort
{
    None = 0,
    Unknown = 1,
    ConnectionLost = 100,
    OutlierReading = 200
}
 
         詳細と例については、System.FlagsAttribute API リファレンス ページ、および System.Enum API リファレンス ページの「非排 他的メンバーと Flags 属性」セクションを参照してください。
System.Enum 型と列挙型定数
System.Enum 型は、すべての列挙型の抽象基底クラスです。 この型には、列挙型とその値に関する情報を取得するための
メソッドがいくつか用意されています。 詳細と例については、System.Enum API リファレンス ページを参照してください。
C#7.3以降、基底クラス制約(列挙の制約と呼ばれます)で System.Enum を使用して、型パラメーターが列挙型であることを 指定できます。また、任意の列挙型も struct 制約を満たしています。これは、型パラメーターがnull非許容値型であること を指定するために使用されます。
変換
列挙型については、列挙型とその基になる整数型との間に明示的な変換が存在します。 列挙値をその基になる型にキャス トすると、結果は列挙メンバーの関連する整数値になります。
     [Flags]
public enum Days
{
    None      = 0b_0000_0000,  // 0
    Monday    = 0b_0000_0001,  // 1
    Tuesday   = 0b_0000_0010,  // 2
    Wednesday = 0b_0000_0100,  // 4
    Thursday  = 0b_0000_1000,  // 8
    Friday    = 0b_0001_0000,  // 16
    Saturday  = 0b_0010_0000,  // 32
    Sunday    = 0b_0100_0000,  // 64
    Weekend   = Saturday | Sunday
}
public class FlagsEnumExample
{
    public static void Main()
    {
} }
Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday;
Console.WriteLine(meetingDays);
// Output:
// Monday, Wednesday, Friday
Days workingFromHomeDays = Days.Thursday | Days.Friday;
Console.WriteLine($"Join a meeting by phone on {meetingDays & workingFromHomeDays}");
// Output:
// Join a meeting by phone on Friday
bool isMeetingOnTuesday = (meetingDays & Days.Tuesday) == Days.Tuesday;
Console.WriteLine($"Is there a meeting on Tuesday: {isMeetingOnTuesday}");
// Output:
// Is there a meeting on Tuesday: False
var a = (Days)37;
Console.WriteLine(a);
// Output:
// Monday, Wednesday, Saturday

                Enum.IsDefined メソッドを使用して、列挙型に、関連する特定の値を持つ列挙型メンバーが含まれているかどうかを確認しま す。
列挙型については、System.Enum 型との間にボックス化とボックス化解除変換が存在します。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
列挙型 列挙型の値と演算子 列挙論理演算子 列挙型比較演算子 明示的な列挙変換 暗黙的な列挙変換
関連項目
C# リファレンス
列挙型書式指定文字列
設計ガイドライン - 列挙型の設計 設計ガイドライン - 列挙型の名前付け規則 switch ステートメント
   public enum Season
{
    Spring,
    Summer,
    Autumn,
    Winter
}
public class EnumConversionExample
{
    public static void Main()
    {
        Season a = Season.Autumn;
        Console.WriteLine($"Integral value of {a} is {(int)a}");  // output: Integral value of Autumn is 2
        var b = (Season)1;
        Console.WriteLine(b);  // output: Summer
        var c = (Season)4;
        Console.WriteLine(c);  // output: 4
    }
}
 
         "構造体型" (または "構造体型") とは、データおよび関連する機能をカプセル化できる 値の型です。 構造体型を定義するに は、 struct キーワードを使用します。
  構造体型には、"値のセマンティクス" があります。 つまり、構造体型の変数には、型のインスタンスが含まれます。 既定では、 変数値が代入時にコピーされ、引数がメソッドに渡され、メソッドの結果が返されます。 構造体型の変数の場合は、型のイン スタンスがコピーされます。 詳細については、値の型に関するページを参照してください。
通常は、構造体型を使用して、ほとんどまたはまったく動作を提供しない小さなデータ中心型を設計します。 たとえば、.NET では、構造体型を使用して数値 (整数と実数の両方)、ブール値、Unicode 文字、時刻インスタンスが表現されます。 型の動 作に重点を置いている場合は、class を定義することを検討してください。 クラス型には "参照セマンティクス" があります。 つま り、クラス型の変数には、インスタンス自体ではなく、型のインスタンスへの参照が含まれています。
構造体型には値セマンティクスがあるため、"変更不可" の構造体型を定義することをお勧めします。 readonly 構造体
C#7.2以降では、readonly 修飾子を使用して、構造体型が変更不可であることを宣言します。 readonly 構造体のすべ てのデータ メンバーを、次のように読み取り専用にする必要があります。
すべてのフィールド宣言には、 readonly 修飾子が必要です 自動的に実装されるものも含めて、すべてのプロパティは、読み取り専用である必要があります。 C# 9.0 以降では、プロパ
ティに init アクセサーが含まれる場合があります。
それにより、readonly 構造体のどのメンバーも構造体の状態を変更しないことが保証されます。C#8.0以降では、コンストラ
クターを除く他のインスタンスメンバーは、暗黙的に readonly になるということです。
次のコードでは、C#9.0以降で使用できる、init専用プロパティのsetterを持つ readonly 構造体を定義します。
        構造体型 (C# リファレンス) 2021/03/06 • • Edit Online
    public struct Coords {
public Coords(double x, double y) {
X = x;
Y = y; }
public double X { get; } public double Y { get; }
public override string ToString() => $"({X}, {Y})"; }
    NOTE
readonly 構造体でも、変更可能な参照型のデータ メンバーは、それ自身の状態を変更できます。 たとえば、List<T> インスタンスを置 き換えることはできませんが、新しい要素をそれに追加することはできます。
  
     readonly インスタンス メンバー
C# 8.0 以降では、 修飾子を使用して、インスタンス メンバーで構造体の状態を変更しないことを宣言することもで
 readonly
  きます。 構造体の型全体を ないインスタンス メンバーをマークします。
として宣言できない場合は、 readonly 修飾子を使用して、構造体の状態を変更し
readonly
  readonly インスタンスメンバー内では、構造体のインスタンスフィールドに割り当てることはできません。ただし、readonly メ ンバーから非 メンバーを呼び出すことができます。 その場合、コンパイラを使用して構造体インスタンスのコピーを作 成し、そのコピーで非 メンバーを呼び出します。 その結果、元の構造インスタンスは変更されません。
通常、 readonly 修飾子を次の種類のインスタンス メンバーに適用します。 メソッド:
System.Objectで宣言されたメソッドをオーバーライドするメソッドに readonly 修飾子を適用することもできます。
プロパティとインデクサー:
プロパティまたはインデクサーの両方のアクセサーに readonly 修飾子を適用する必要がある場合は、プロパティまたは インデクサーの宣言でそれを適用します。
C#9.0以降では、init アクセサーを持つプロパティまたはインデクサーに readonly 修飾子を適用することができま す。
 readonly
 readonly
     public readonly double Sum() {
return X + Y; }
    public readonly override string ToString() => $"({X}, {Y})";
     private int counter; public int Counter
{
readonly get => counter;
set => counter = value; }
      NOTE
プロパティの宣言に readonly 修飾子が存在するかどうかに関係なく、コンパイラによって自動実装プロパティの get アクセサー が readonly として宣言されます。
        public readonly struct Coords {
public Coords(double x, double y) {
X = x;
Y = y; }
public double X { get; init; } public double Y { get; init; }
public override string ToString() => $"({X}, {Y})"; }
  public readonly double X { get; init; }
 
           修飾子を構造体型の静的メンバーに適用することはできません。
パフォーマンスの最適化のためにコンパイラで readonly 修飾子を使用する場合があります。詳細については、「安全で効率
的な C# コードを記述する」をご覧ください。
構造体型の設計に関する制限事項 構造体型を設計する場合は、class 型と同じ機能を使用できますが、次の例外があります。
パラメーターなしのコンストラクターを宣言することはできません。 すべての構造体型には、型の既定値を生成する暗黙 的なパラメーターなしのコンストラクターが既に備わっています。
インスタンス フィールドまたはプロパティを、それらの宣言で初期化することはできません。 ただし、static または const フィールド、あるいは静的プロパティについては、それらの宣言で初期化することができます。
構造体型のコンストラクターでは、型のすべてのインスタンス フィールドを初期化する必要があります。 構造体型は、他のクラスまたは構造体型から継承することができないほか、クラスのベースとすることもできません。 ただ
し、構造体型では interfaces を実装することができます。 構造体型内でファイナライザーを宣言することはできません。
構造体型のインスタンス化
C# では、宣言された変数を使用するには、事前にこれを初期化する必要があります。 構造体型の変数は (null 許容値型の 変数でない限り) null とすることができないため、対応する型のインスタンスをインスタンス化する必要があります。 それにはい くつかの方法があります。
通常は、 new 演算子を使用して適切なコンストラクターを呼び出すことによって、構造体型をインスタンス化します。 すべての 構造体型に、少なくとも 1 つのコンストラクターがあります。 それは暗黙的なパラメーターなしのコンストラクターであり、型の既定 値を生成するものです。 また、既定の値式を使用して、型の既定値を生成することもできます。
構造体型のすべてのインスタンスフィールドにアクセスできる場合は、それを new 演算子なしでインスタンス化することもできま す。 その場合は、インスタンスを初めて使用する前に、すべてのインスタンス フィールドを初期化する必要があります。 その方法 を次の例に示します。
  組み込みの値型の場合は、対応するリテラルを使用して型の値を指定します。 構造体型の変数を参照渡しする
構造体型の変数を引数としてメソッドに渡す場合、またはメソッドから構造体型の値を返す場合は、構造体型のインスタンス 全体がコピーされます。 これは、大規模な構造体型を必要とするハイパフォーマンスのシナリオの場合、ご利用のコードのパ フォーマンスに影響を与える可能性があります。 値のコピーを回避するには、構造体型の変数を参照渡しします。 引数を参 照渡しする必要があることを示すには、 ref 、 out 、または in のメソッド パラメーター修飾子を使用します。 メソッドの結果 を参照渡しによって返すには、ref 戻り値を使用します。 詳細については、「安全で効率的な C# コードを記述する」をご覧く ださい。
 readonly
    public static class StructWithoutNew {
public struct Coords {
public double x;
public double y; }
public static void Main() {
} }
Coords p;
p.x = 3;
p.y = 4;
Console.WriteLine($"({p.x}, {p.y})"); // output: (3, 4)
 
              ref 構造体
C#7.2以降、ref 修飾子は、構造体型の宣言内で使用できます。 ref 構造体型のインスタンスはスタック上に割り当てら れます。マネージドヒープにエスケープすることはできません。これを確実にするために、コンパイラでは次のように ref 構造体 型の使用が制限されます。
ref 構造体を配列の要素型にすることはできません。
ref 構造体をクラスまたは非 ref 構造体のフィールドの宣言型にすることはできません。
ref 構造体ではインターフェイスを実装できません。
ref 構造体をSystem.ValueTypeまたはSystem.Objectにボックス化することはできません。
ref 構造体を型引数にすることはできません。
ref 構造体変数をラムダ式またはローカル関数でキャプチャすることはできません。
ref 構造体変数を async メソッド内で使用することはできません。ただし、TaskまたはTask<TResult>を返す場合な
ど、同期メソッドで ref 構造体変数を使用することはできます。 ref 構造体変数を反復子内で使用することはできません。
通常、 ref 構造体型のデータ メンバーも含む型が必要な場合は、 ref 構造体型を定義します。
ref 構造体を readonly として宣言するには、型宣言内で readonly 修飾子と ref 修飾子を組み合わせます ( readonly 修飾子は ref 修飾子よりも前にある必要があります)。
     .NETでは、ref 構造体の例としてSystem.Span<T>とSystem.ReadOnlySpan<T>があります。 struct 制約
また、struct 制約の キーワードを使用して、型パラメーターがnull非許容値型であることを指定します。構造体 と列挙型の型は、どちらも 制約を満たしています。
変換
どの構造体型にも(ref 構造体型を除く)、System.ValueType型とSystem.Object型の間にボックス化およびボックス化解 除の変換が存在します。 また、構造体型と、これによって実装されるインターフェイスとの間にも、ボックス化とボックス化解除の 変換が存在します。
C# 言語仕様
詳細については、C# 言語仕様の「構造体」セクションを参照してください。
C# 7.2 以降で導入された機能の詳細については、次の機能の提案に関するメモを参照してください。
  struct
 struct
   public ref struct CustomRef {
public bool IsValid; public Span<int> Inputs; public Span<int> Outputs;
}
    public readonly ref struct ConversionRequest {
public ConversionRequest(double rate, ReadOnlySpan<double> values) {
Rate = rate;
Values = values; }
public double Rate { get; }
public ReadOnlySpan<double> Values { get; } }
 
        Readonly 構造体
Readonly インスタンスのメンバー ref-like 型のコンパイル時の安全性
関連項目
C# リファレンス
デザインのガイドライン - クラスまたは構造体の選択 デザインのガイドライン - 構造体のデザイン クラスと構造体

          C# 7.0 以降で利用できる " タプル " 機能により、軽量データ構造に複数のデータ要素をグループ化するための簡潔な構文が 提供されています。 次の例は、タプル変数を宣言して初期化し、そのデータ メンバーにアクセスする方法を示しています。
    (double, int) t1 = (4.5, 3);
Console.WriteLine($"Tuple with elements {t1.Item1} and {t1.Item2}.");
// Output:
// Tuple with elements 4.5 and 3.
(double Sum, int Count) t2 = (4.5, 3);
Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}.");
// Output:
// Sum of 3 elements is 4.5.
 前の例で示したように、タプル型を定義するには、すべてのデータ メンバーの型と、必要に応じてフィールド名を指定します。 タ プル型でメソッドを定義することはできませんが、次の例に示すように、.NET によって提供されるメソッドを使用できます。
C#7.3以降では、タプル型で等値演算子 == と != がサポートされます。詳しくは、「タプルの等値性」セクションをご覧くださ い。
タプル型は値型であり、タプル要素はパブリック フィールドです。 そのため、タプルは " 変更可能な " 値の型になります。
任意の多数の要素を持つタプルを定義できます。
タプルのユース ケース
特に一般的なタプルのユースケースの1つが、メソッドの戻り値の型です。つまり、out メソッドパラメーターを定義するのでは なく、次の例のようにメソッドの結果をタプルの戻り値の型でグループ化できます。
    (double, int) t = (4.5, 3);
Console.WriteLine(t.ToString());
Console.WriteLine($"Hash code of {t} is {t.GetHashCode()}.");
// Output:
// (4.5, 3)
// Hash code of (4.5, 3) is 718460086.
     NOTE
タプルの機能には、System.ValueTuple 型と、.NET Core と .NET Framework 4.7 以降で使用できる、関連のジェネリック型 (たとえ ば、System.ValueTuple<T1,T2>) が必要です。 4.6.2 以前の .NET Framework を対象とするプロジェクトでタプルを使用するには、 NuGet パッケージ System.ValueTuple をプロジェクトに追加します。
      var t =
(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12, 13, 14, 15, 16, 17, 18,
19, 20, 21, 22, 23, 24, 25, 26);
Console.WriteLine(t.Item26);  // output: 26
 タプル型 (C# リファレンス) 2020/11/02 • • Edit Online
 
    前の例で示したように、返されたタプルのインスタンスを直接操作することも、別の変数に分解することもできます。 タプル型は匿名型の代わりに、たとえば LINQ クエリで使用することもできます。 詳細については、「匿名型またはタプル型の選
択」を参照してください。
通常、タプルは関連性の低いデータ要素をグループ化するために使用します。 これは通常、非公開および内部のユーティリティ
メソッド内で役に立ちます。 パブリック API の場合は、クラスまたは構造体型を定義することを検討してください。 タプルのフィールド名
次の例に示すように、タプルの初期化式またはタプルの型の定義でタプル フィールドの名前を明示的に指定できます。
C# 7.1 以降では、フィールド名を指定しない場合、次の例に示すように、タプルの初期化式で対応する変数の名前からそれ が推論される場合があります。
    var t = (Sum: 4.5, Count: 3);
Console.WriteLine($"Sum of {t.Count} elements is {t.Sum}.");
(double Sum, int Count) d = (4.5, 3);
Console.WriteLine($"Sum of {d.Count} elements is {d.Sum}.");
     var sum = 4.5;
var count = 3;
var t = (sum, count);
Console.WriteLine($"Sum of {t.count} elements is {t.sum}.");
    var xs = new[] { 4, 7, 9 };
var limits = FindMinMax(xs);
Console.WriteLine($"Limits of [{string.Join(" ", xs)}] are {limits.min} and {limits.max}");
// Output:
// Limits of [4 7 9] are 4 and 9
var ys = new[] { -9, 0, 67, 100 };
var (minimum, maximum) = FindMinMax(ys);
Console.WriteLine($"Limits of [{string.Join(" ", ys)}] are {minimum} and {maximum}");
// Output:
// Limits of [-9 0 67 100] are -9 and 100
(int min, int max) FindMinMax(int[] input)
{
    if (input is null || input.Length == 0)
    {
        throw new ArgumentException("Cannot find minimum and maximum of a null or empty array.");
    }
    var min = int.MaxValue;
    var max = int.MinValue;
    foreach (var i in input)
    {
if (i < min) {
min = i; }
if (i > max) {
max = i; }
}
    return (min, max);
}
 
   これはタプル プロジェクション初期化子と呼ばれます。 変数の名前は、次の場合、タプル フィールド名に投影されません。 候補名が Item3 、 ToString 、 Rest などのタプル型のメンバー名である。
候補名が、別のタプル フィールド名 (明示的または暗黙的のいずれか) の複製である。 このような場合は、フィールドの名前を明示的に指定するか、既定の名前でフィールドにアクセスします。
タプル フィールドの既定の名前は、 Item1 、 Item2 、 Item3 などです。 次の例に示すように、フィールド名が明示的に指定さ れていたり推論されていたりする場合でも、フィールドの既定の名前をいつでも使用できます。
     var a = 1;
var t = (a, b: 2, 3);
Console.WriteLine($"The 1st element is {t.Item1} (same as {t.a}).");
Console.WriteLine($"The 2nd element is {t.Item2} (same as {t.b}).");
Console.WriteLine($"The 3rd element is {t.Item3}.");
// Output:
// The 1st element is 1 (same as 1).
// The 2nd element is 2 (same as 2).
// The 3rd element is 3.
 タプルの代入とタプルの等価比較では、フィールド名が考慮されません。 コンパイル時に、コンパイラは既定以外のフィールド名を、対応する既定の名前に置き換えます。 このため、明示的に指定され
た、または推論されたフィールド名は実行時に使用できません。
タプルの代入と分解
C# では、次の両方の条件を満たすタプル型間の代入がサポートされます。
両方のタプル型に、同じ数の要素がある タプルのそれぞれの位置で、右側のタプル要素の型が対応する左側のタプル要素の型と同じか、暗黙的に変換可能である
タプル要素の値は、タプル要素の順序に従って代入されます。 次の例に示すように、タプル フィールドの名前は無視され、代 入されません。
    (int, double) t1 = (17, 3.14);
(double First, double Second) t2 = (0.0, 1.0);
t2 = t1;
Console.WriteLine($"{nameof(t2)}: {t2.First} and {t2.Second}");
// Output:
// t2: 17 and 3.14
(double A, double B) t3 = (2.0, 3.0);
t3 = t2;
Console.WriteLine($"{nameof(t3)}: {t3.A} and {t3.B}");
// Output:
// t3: 17 and 3.14
 また、代入演算子 = を使用して、別の変数でタプルインスタンスを"分解する"こともできます。これは、次の方法のいずれ かで実行できます。
かっこ内の各変数の型を明示的に宣言する。
    var t = ("post office", 3.6);
(string destination, double distance) = t;
Console.WriteLine($"Distance to {destination} is {distance} kilometers.");
// Output:
// Distance to post office is 3.6 kilometers.
 
  かっこの外にある var キーワードを使用して、暗黙的に型指定された変数を宣言し、コンパイラによってその型が推論 されるようにする。
既存の変数を使用する。
    var t = ("post office", 3.6);
var (destination, distance) = t;
Console.WriteLine($"Distance to {destination} is {distance} kilometers.");
// Output:
// Distance to post office is 3.6 kilometers.
     var destination = string.Empty;
var distance = 0.0;
var t = ("post office", 3.6);
(destination, distance) = t;
Console.WriteLine($"Distance to {destination} is {distance} kilometers.");
// Output:
// Distance to post office is 3.6 kilometers.
 タプルとその他の型の分解の詳細については、「タプルとその他の型の分解」を参照してください。 タプルの等値性
C#7.3以降では、タプル型で == および != 演算子がサポートされます。これらの演算子により、左側のオペランドのメン バーが、タプル要素の順序に従って、右側のオペランドの対応するメンバーと比較されます。
    (int a, byte b) left = (5, 10);
(long a, int b) right = (5, 10);
Console.WriteLine(left == right);  // output: True
Console.WriteLine(left != right);  // output: False
var t1 = (A: 5, B: 10);
var t2 = (B: 5, A: 10);
Console.WriteLine(t1 == t2);  // output: True
Console.WriteLine(t1 != t2);  // output: False
 前の例で示したように、 == と != の演算では、タプルのフィールド名は考慮されません。 2 つのタプルは、次の両方の条件が満たされている場合に比較できます。
両方のタプルが、同じ数の要素を保持している。 たとえば、 t1 と t2 の要素数が異なる場合、 t1 != t2 はコンパイル されません。
タプルの位置ごとに、左側と右側のタプルのオペランドの対応する要素が、 == と != の演算子と比較されます。 たとえ ば、 1 は (1, 2) と比較できないため、 (1, (2, 3)) == ((1, 2), 3) はコンパイルされません。
== と != の演算子によって、タプルがショートサーキット方式で比較されます。つまり、等しくない要素のペアか、タプルの端に 到達するとすぐに、演算が停止します。 ただし、比較の前には必ず、次の例に示すように、" すべての " タプル要素が評価され ます。
   
          out パラメーターとしてのタプル
通常は、 out パラメーターを持つメソッドを、タプルを返すメソッドにリファクタリングします。 ただし、 out パラメーターがタプル型
である場合もあります。 次の例に、 out パラメーターとしてタプルを操作する方法を示します。
    var limitsLookup = new Dictionary<int, (int Min, int Max)>()
{
    [2] = (4, 10),
    [4] = (10, 20),
    [6] = (0, 23)
};
if (limitsLookup.TryGetValue(4, out (int Min, int Max) limits))
{
    Console.WriteLine($"Found limits: min is {limits.Min}, max is {limits.Max}");
}
// Output:
// Found limits: min is 10, max is 20
  タプルと System.Tuple
System.ValueTuple 型によってサポートされる C# のタプルは、System.Tuple タプルで表されるタプルとは異なります。 主な相
違点は、次のとおりです。
型は値の型です。 Tuple 型は参照型です。
型は変更可能です。 Tuple 型は変更不可能です。 型のデータメンバーはフィールドです。 Tuple 型のデータメンバーはプロパティです。
C# 言語仕様 詳しくは、次の機能提案メモをご覧ください。
タプル名 (別名タプル プロジェクション初期化子) を推測する タプル型での == と != のサポート
関連項目
C# リファレンス
値型 匿名型またはタプル型の選択 System.ValueTuple
 ValueTuple
  ValueTuple
  ValueTuple
   Console.WriteLine((Display(1), Display(2)) == (Display(3), Display(4)));
int Display(int s)
{
    Console.WriteLine(s);
return s; }
// Output:
// 1
// 2
// 3
// 4
// False
 
       " null 許容値型 " T? は、基になる 値型 T のすべての値と、追加の null 値を表します。 たとえば、 bool? 変数には、 true 、 false 、 null の 3 つの値のいずれかを割り当てることができます。 基になる値型 T を null 許容値型にすることは
できません。
null許容値型は、ジェネリックSystem.Nullable<T>構造体のインスタンスです。 Nullable<T> または T? の代替可能な 形式のいずれかで基になる型 T を持つnull許容値型を参照できます。
null 許容値型は通常、基になる値型の未定義の値を表す必要があるときに使用します。 たとえば、ブール型 ( bool ) 変数 で可能なのは、 true または false のいずれかです。 ただし、一部のアプリケーションでは、変数の値が未定義または存在し ない場合があります。 たとえば、データベース フィールドに、 true または false が含まれている場合や、値がまったく含まれて いない場合 ( NULL ) があります。 このシナリオでは、 bool? 型を使用できます。
宣言と代入
値型は、対応する null 許容値型に暗黙的に変換できるため、基になる値型の場合と同様に、null 許容値型の変数に値を
割り当てることができます。 null 値を代入することもできます。次に例を示します。
    NOTE
C# 8.0 で、Null 許容参照型機能が導入されました。 詳細については、「null 許容参照型」を参照してください。 null 許容値型は、C# 2 から使用できます。
      double? pi = 3.14;
char? letter = 'a';
int m2 = 10;
int? m = m2;
bool? flag = null;
// An array of a nullable value type:
int?[] arr = new int?[10];
 null許容値型の既定値は null を表します。つまり、Nullable<T>.HasValueプロパティが false を返すインスタンスで す。
null 許容値型のインスタンスの検査
C#7.0以降では、型パターンで is 演算子を使用して、null のnull許容値型のインスタンスを調べ、基になる型の値を 取得することができます。
null 許容値型 (C# リファレンス) 2020/11/02 • • Edit Online
 
         null 許容値型の変数の値を確認して取得するには、常に次の読み取り専用プロパティを使用できます。 Nullable<T>.HasValue は、null 許容値型のインスタンスに、基になる型の値が含まれるかどうかを示します。
HasValueが true の場合、Nullable<T>.Valueは基になる型の値を取得します。HasValueが false の場 合、Value プロパティは InvalidOperationException をスローします。
次の例では、 HasValue プロパティを使用して、値を表示する前に変数に値が格納されているかどうかをテストします。
     int? b = 10;
if (b.HasValue)
{
    Console.WriteLine($"b is {b.Value}");
}
else {
    Console.WriteLine("b does not have a value");
}
// Output:
// b is 10
  次の例に示すように、 HasValue プロパティを使用する代わりに、null 許容値型の変数を null と比較することもできます。
    int? c = 7;
if (c != null)
{
    Console.WriteLine($"c is {c.Value}");
}
else {
    Console.WriteLine("c does not have a value");
}
// Output:
// c is 7
 null 許容値型から基になる型への変換
null許容値型の値をnull非許容値型の変数に割り当てる場合は、null の代わりに割り当てる値を指定する必要がある 場合があります。これを行うには、null合体演算子 ?? を使用します(Nullable<T>.GetValueOrDefault(T)メソッドも同じ 目的で使用することができます)。
   int? a = 42;
if (a is int valueOfA)
{
    Console.WriteLine($"a is {valueOfA}");
}
else {
    Console.WriteLine("a does not have a value");
}
// Output:
// a is 42
 
        null の代わりに基になる値の型の既定値を使用する場合は、Nullable<T>.GetValueOrDefault()メソッドを使用します。 次の例に示すように、null 許容値型を null 非許容型に明示的にキャストすることもできます。
実行時にnull許容値型の値が null の場合は、明示的なキャストによってInvalidOperationExceptionがスローされま す。
null非許容値型 T は、対応するnull許容値型 T? に暗黙的に変換されます。 リフト演算子
定義済みの単項演算子および2項演算子、または値型 T によってサポートされるオーバーロードされた任意の演算子は、 対応するnull許容値型 T? でもサポートされます。"リフト演算子"とも呼ばれるこれらの演算子では、一方または両方のオ ペランドが null の場合に null が生成されます。それ以外の場合は、そのオペランドに含まれている値を使用して結果が算 出されます。 次に例を示します。
    int? n = null;
//int m1 = n;    // Doesn't compile
int n2 = (int)n; // Compiles, but throws an exception if n is null
     int? a = 10;
int? b = null;
int? c = 10;
a++; // a is 11 a=a*c; //ais110 a=a+b; //aisnull
     NOTE
bool? 型の場合、定義済みの & および | 演算子は、このセクションで説明されている規則に従わないことに注意してください。オペラ ンドの 1 つが null の場合も、演算子の評価の結果は null 以外である可能性があります。 詳細については、「Boolean logical operators (ブール論理演算子)」記事の「Nullable Boolean logical operators (null 許容論理演算子)」セクションを参照してください。
 比較演算子 < 、 > 、 <= 、 >= では、一方または両方のオペランドが null の場合、結果は false になります。それ以外 の場合は、オペランドに含まれる値が比較されます。 ある比較 (たとえば、 <= ) から返される結果が false であっても、逆の 比較(>)から返される結果が true であるとは限りません。次の例は、10が
null 以上ではなく
null 未満でもないことを示します
   int? a = 28;
int b = a ?? -1;
Console.WriteLine($"b is {b}");  // output: b is 28
int? c = null;
int d = c ?? -1;
Console.WriteLine($"d is {d}");  // output: d is -1
 
           等値演算子 == では、両方のオペランドが null の場合、結果は true になります。一方のオペランドだけが null の場 合、結果は false です。それ以外の場合は、オペランドに含まれる値が比較されます。
非等値演算子 != では、両方のオペランドが null の場合、結果は false になります。一方のオペランドだけが null の 場合、結果は true です。それ以外の場合は、オペランドに含まれる値が比較されます。
2 つの値型の間にユーザー定義の変換が存在する場合は、それに対応する null 許容値型間でも同じ変換を使用することが できます。
ボックス化とボックス化解除 null許容値型のインスタンス T? は、次のようにボックス化されます。
HasValueが false を返した場合は、null参照が生成されます。
HasValueが trueを返した場合は、Nullable<T>のインスタンスではなく、基になる値型 T の対応する値がボックス化 されます。
次の例に示すように、値型 T のボックス化された値を、対応するnull許容値型 T? にボックス化解除できます。
    int a = 41;
object aBoxed = a;
int? aNullable = (int?)aBoxed;
Console.WriteLine($"Value of aNullable: {aNullable}");
object aNullableBoxed = aNullable;
if (aNullableBoxed is int valueOfA)
{
    Console.WriteLine($"aNullableBoxed is boxed int: {valueOfA}");
}
// Output:
// Value of aNullable: 41
// aNullableBoxed is boxed int: 41
 方法: null 許容値型を識別する
次の例は、System.Typeインスタンスが構築されたnull許容値型(つまり、指定された型パラメーター T を使用する System.Nullable<T> 型) を表すかどうかを判断する方法を示しています。
   int? a = 10;
Console.WriteLine($"{a} >= null is {a >= null}");
Console.WriteLine($"{a} < null is {a < null}");
Console.WriteLine($"{a} == null is {a == null}");
// Output:
// 10 >= null is False
// 10 < null is False
// 10 == null is False
int? b = null;
int? c = null;
Console.WriteLine($"null >= null is {b >= c}");
Console.WriteLine($"null == null is {b == c}");
// Output:
// null >= null is False
// null == null is True
 
        例で示されているとおり、System.Type インスタンスの作成には、typeof 演算子を使用します。
インスタンスが null 許容値型かどうかを判断したい場合は、Type インスタンスが前述のコードでテストされるよう に、Object.GetType メソッドは使用しないでください。 null 許容値型のインスタンスで Object.GetType メソッドを呼び出した 場合、そのインスタンスは Object にボクシングされます。 null 許容値型の null 以外のインスタンスのボックス化は、基になる型 の値のボックス化と等しいので、GetType は、null 許容値型の基になる型を表す Type インスタンスを返します。
また、インスタンスが null 許容値型であるかどうかを判断するために、is 演算子を使用しないでください。 次の例に示すよう に、is 演算子を使用してnull許容値型のインスタンスとその基になる型のインスタンスの型を区別することはできません。
    int? a = 17;
Type typeOfA = a.GetType();
Console.WriteLine(typeOfA.FullName);
// Output:
// System.Int32
     int? a = 14;
if (a is int)
{
    Console.WriteLine("int? instance is compatible with int");
}
int b = 17;
if (b is int?)
{
    Console.WriteLine("int instance is compatible with int?");
}
// Output:
// int? instance is compatible with int
// int instance is compatible with int?
 次の例のコードを使用すると、インスタンスが null 許容値型であるかどうかを判別することができます。
    int? a = 14;
Console.WriteLine(IsOfNullableType(a));  // output: True
int b = 17;
Console.WriteLine(IsOfNullableType(b));  // output: False
bool IsOfNullableType<T>(T o)
{
    var type = typeof(T);
    return Nullable.GetUnderlyingType(type) != null;
}
     NOTE
このセクションで説明されているメソッドは、null 許容参照型の場合には適用されません。
    Console.WriteLine($"int? is {(IsNullable(typeof(int?)) ? "nullable" : "non nullable")} value type");
Console.WriteLine($"int is {(IsNullable(typeof(int)) ? "nullable" : "non-nullable")} value type");
bool IsNullable(Type type) => Nullable.GetUnderlyingType(type) != null;
// Output:
// int? is nullable value type
// int is non-nullable value type
 
             C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
Null 許容型 リフト演算子
暗黙の null 許容変換 明示的な null 許容変換 リフト変換演算子
関連項目
C# リファレンス
What Exactly Does 'Lifted' mean? ('Lifted' の正確な意味) System.Nullable<T>
System.Nullable
Nullable.GetUnderlyingType
Null 許容参照型

         C# では、参照型と値型という 2 種類の型をサポートしています。 参照型の変数はデータ (オブジェクト) への参照を格納するの に対して、値型の変数はデータを直接格納します。 参照型の場合、2 つの変数が同じオブジェクトを参照できるため、ある変 数に対する演算によって、他の変数が参照しているオブジェクトが影響を受ける可能性があります。 値型の場合、各変数が独 自のデータ コピーを保持し、ある変数に対する操作が別の変数に影響を与えることはありません (ref および out パラメーター変 数の場合を除きます。in、ref、out パラメーター修飾子に関するページを参照してください)。
次のキーワードは、参照型を宣言するときに使用します。
class interface delegate record
C# では次の組み込みの参照型も使用できます。 dynamic
object string
関連項目
C# リファレンス C# のキーワード ポインター型 値型
参照型 (C# リファレンス) 2021/03/06 • • Edit Online
 
         C# には複数の組み込み参照型があります。 それらには、.NET ライブラリでの型に対するシノニムであるキーワードまたは演算 子があります。
オブジェクトの型
object 型は.NETでのSystem.Objectの別名です。C#の統一型システムでは、すべての型(定義済み、ユーザー定義、 参照型、および値の型)が、直接または間接的にSystem.Objectを継承します。 object 型の変数には、任意の型の値を 割り当てることができます。すべての object 変数には、リテラル null を使って既定値を割り当てることができます。値型の 変数がobjectに変換されることを、ボックス化されると言います。 object 型の変数が値型に変換されることを、ボックス化 解除 されると言います。 詳細については、「ボックス化とボックス化解除」を参照してください。
文字列型
string 型は、0個以上のUnicode文字のシーケンスを表します。 string は.NETのSystem.Stringの別名です。
string は参照型ですが、等値演算子 == および != は、 string オブジェクトの参照ではなく、値を比較するように定義 されています。 これにより、文字列が等しいかを直感的にテストできます。 次に例を示します。
文字列の内容が等しいので、"True"、"False"の順に表示されますが、 a および b は同じ文字列インスタンスを参照しませ ん。
+ 演算子では、文字列が連結されます。
これは、"good morning" を含む文字列オブジェクトを作成します。
文字列は " 変更不可 " です。文字列オブジェクトの作成後、そのコンテンツを変更することはできません。構文では変更可能 に見えても、変更不可です。 たとえば、このコードを作成すると、コンパイラによって新しい文字列オブジェクトを格納する新しい シーケンスオブジェクトが生成され、その新しいオブジェクトが b に割り当てられます。 b に割り当てられたメモリは(文字列 "h" が含まれている場合)、ガベージ コレクションの対象になります。
[] 演算子は、文字列の各文字への読み取り専用アクセスに使用できます。有効なインデックス値は 0 から始まり、文字 列の長さ未満である必要があります。
            同様に、 [] 演算子を使って文字列内の各文字を反復処理することもできます。
組み込みの参照型 (C# リファレンス) 2020/11/02 • • Edit Online
    string a = "hello";
string b = "h";
// Append to contents of 'b'
b += "ello";
Console.WriteLine(a == b); Console.WriteLine(object.ReferenceEquals(a, b));
  string a = "good " + "morning";
    string b = "h"; b += "ello";
    string str = "test"; charx=str[2]; //x='s';
 
    文字列リテラルは string 型であり、二重引用符で囲む形式と、@ 付きの二重引用符で囲む形式の2種類があります。 二重引用符で囲む場合は、リテラル文字列の前後に二重引用符 (") を付けます。
リテラル文字列には、任意の文字リテラルを含めることができます。 これにはエスケープ シーケンスが含まれます。 次の例では、 円記号にエスケープ シーケンス \\ 、文字 f に \u0066 、改行に \n を使用しています。
    verbatim文字列リテラルの場合は、先頭に @ を付け、さらに前後に二重引用符を付けます。次に例を示します。
verbatim 文字列の場合の利点は、エスケープ シーケンスが " 処理されない " ため、たとえば、完全修飾 Windows ファイル 名が書きやすくなることです。
@-quoted 文字列に二重引用符を含めるには、二重引用符を二重にします。
デリゲート型
デリゲート型の宣言は、メソッド シグネチャに似ています。 戻り値 1 つのほか、任意の型のパラメーターをいくつでも指定すること ができます。
.NETでは、 System.Action 型と System.Func 型により、多くの一般的なデリゲートに対するジェネリック定義が提供されま す。 おそらく、新しいカスタム デリゲート型を定義する必要はありません。 代わりに、提供されたジェネリック型のインスタンス化を 作成できます。
       delegate は、名前付きメソッドまたは匿名メソッドをカプセル化することができる参照型です。デリゲートはC++の関数ポイン
   string str = "test";
for (int i = 0; i < str.Length; i++) {
Console.Write(str[i] + " "); }
// Output: t e s t
  "good morning" // a string literal
    string a = "\\\u0066\n F"; Console.WriteLine(a);
// Output:
// \f
// F
    NOTE
エスケープ コード \udddd ( dddd は 4 桁の数字) は、Unicode 文字 U + dddd を表します。 8 桁の Unicode エスケープ コード \Udddddddd も認識できます。
    @"good morning" // a string literal
  @"c:\Docs\Source\a.txt" // rather than "c:\\Docs\\Source\\a.txt"
  @"""Ahoy!"" cried the captain." // "Ahoy!" cried the captain.
    public delegate void MessageDelegate(string message); public delegate int AnotherDelegate(MyType m, long num);
 
     ターに似ていますが、タイプ セーフであり安全です。 デリゲートの使い方については、デリゲートと汎用デリゲートに関するページを 参照してください。 デリゲートはイベントの土台となる働きをします。 デリゲートは名前付きメソッドまたは匿名メソッドに関連付 けることによって、インスタンス化することができます。
デリゲートは、適合する入力パラメーターと戻り値の型を持ったメソッドまたはラムダ式でインスタンス化する必要があります。 メ ソッドのシグネチャでどの程度の変性が許容されるかについて詳しくは、デリゲートの変性に関するページを参照してください。 匿 名メソッドで使用する場合は、デリゲートとそれに関連付けるコードとを一緒に宣言します。
dynamic 型
dynamic 型は、変数およびそのメンバーに対する参照の使用が、コンパイル時の型チェックをバイパスすることを示します。代 わりに、演算は実行時に解決されます。 dynamic 型により、OfficeオートメーションAPIなどのCOMAPI、IronPythonライ ブラリなどの動的 API、および HTML ドキュメント オブジェクト モデル (DOM: Document Object Model) へのアクセスが容易 になります。
ほとんどの環境で、 型は 型のように動作します。具体的には、null以外の任意の式を dynamic 型に変 換できます。 型は と異なり、 dynamic 型の式を含む演算はコンパイラによって解決または型チェックされま せん。 コンパイラは演算に関する情報をまとめてパッケージ化します。その情報が後で実行時に演算を評価するために使用さ れます。 このプロセスの過程で、 dynamic 型の変数は object 型の変数にコンパイルされます。 そのため、 dynamic 型はコ ンパイル時にのみ存在し、実行時には存在しません。
dynamic 型の変数と object 型の変数の違いを次に示します。 コンパイル時に各変数の型を確認するには、 WriteLine ステートメントの dyn または obj にマウスポインターを置きます。IntelliSenseが使用可能なエディターに、次のコードをコ ピーします。IntelliSense機能によって、dyn にはdynamic、obj にはobjectが表示されます。
     dynamic
object
   dynamic
object
       WriteLineステートメントは dyn および obj の実行時の型を表示します。その時点では、両方が同じ整数型を持ちます。 次の出力が生成されます。
コンパイル時の dyn と obj の違いを確認するには、前の例の宣言と WriteLine ステートメントの間に次の2行を追加しま す。
式 obj + 3 に整数およびオブジェクトを追加しようとしたことに対してコンパイル エラーが報告されます。 ただし、 に 関するエラーは報告されません。 dyn を含む式はコンパイル時にはチェックされません。これは、 dyn の型が である ためです。
さまざまな宣言で dynamic を使用する例を次に示します。 また、 Main メソッドで、コンパイル時の型チェックと実行時の型 チェックの違いを確認できます。
     dyn + 3
 dynamic
    class Program {
static void Main(string[] args) {
} }
dynamic dyn = 1; object obj = 1;
// Rest the mouse pointer over dyn and obj to see their // types at compile time. System.Console.WriteLine(dyn.GetType()); System.Console.WriteLine(obj.GetType());
    System.Int32 System.Int32
    dyn = dyn + 3; obj = obj + 3;
 
             関連項目
C# リファレンス
C# のキーワード
イベント
dynamic 型の使用 文字列を使用するためのベスト プラクティス 基本的な文字列操作 新しい文字列の作成 型テストとキャスト演算子
パターン マッチング、is 演算子、as 演算子を使用して安全にキャストする方法 チュートリアル: 動的オブジェクトの作成と使用
System.Object
   using System;
namespace DynamicExamples {
class Program {
static void Main(string[] args) {
} }
}
// Results:
// Local variable // 2
// Local variable
ExampleClass ec = new ExampleClass(); Console.WriteLine(ec.exampleMethod(10)); Console.WriteLine(ec.exampleMethod("value"));
// The following line causes a compiler error because exampleMethod // takes only one argument. //Console.WriteLine(ec.exampleMethod(10, 4));
dynamic dynamic_ec = new ExampleClass(); Console.WriteLine(dynamic_ec.exampleMethod(10));
// Because dynamic_ec is dynamic, the following call to exampleMethod // with two arguments does not produce an error at compile time.
// However, it does cause a run-time error. //Console.WriteLine(dynamic_ec.exampleMethod(10, 4));
} }
class ExampleClass {
static dynamic dynamic prop {
public dynamic {
field;
get; set; }
exampleMethod(dynamic d)
dynamic local = "Local variable"; int two = 2;
if (d is int) {
return local; }
else {
return two; }

   System.String System.Dynamic.DynamicObject

              クラスは、次の例に示すように、キーワード class を使用して宣言します。
注釈
C# では、単一継承のみを使用できます。 つまり、クラスは 1 つの基底クラスの実装だけを継承できます。 ただし、クラスは複数 のインターフェイスを実装できます。 クラスの継承とインターフェイスの実装の例を次の表に示します。
なし class ClassA { }
単一 class DerivedClass : BaseClass { } なし。2つのインターフェイスを実装 class ImplClass : IFace1, IFace2 { } 1つ。1つのインターフェイスを実装 class ImplDerivedClass : BaseClass, IFace1 { }
名前空間内で直接宣言され、他のクラスに入れ子にされていないクラスは、public または internal のいずれかです。 クラスは 既定で internal です。
クラスのメンバー (入れ子にされているクラスを含む) は public、protected internal、protected、internal、private、または privateprotectedのいずれかとして宣言することができます。メンバーは既定で private です。
詳細については、「アクセス修飾子」を参照してください。
型パラメーターを持つジェネリック クラスを宣言することができます。 詳細については、「ジェネリック クラス」を参照してください。 クラスには、次のメンバーの宣言を含めることができます。
コンストラクター 定数
フィールド ファイナライザー メソッド プロパティ インデクサー 演算子 イベント デリゲート クラス
                         class (C# リファレンス) 2020/11/02 • • Edit Online
    class TestClass {
// Methods, properties, fields, events, delegates
// and nested classes go here. }
 
   インターフェイス 構造体型 列挙型
例
ここでは、クラスのフィールド、コンストラクター、メソッドの宣言例を示します。 また、オブジェクト インスタンスの作成とインスタンス データの出力の例も示します。次の例では、2つのクラスが宣言されています。最初の Child クラスには、2つのプライベート フィールド(name と age)、2つのパブリックコンストラクター、および1つのパブリックメソッドがあります。2番目のクラスである
StringTest は、 Main の格納に使用されます。
    備考
前の例で、プライベート フィールド ( name および age ) にアクセスできるのは、 Child クラスのパブリック メソッドだけであることに 注意してください。たとえば、次のステートメントを使用して Main メソッドから子の名前を印刷することはできません。
  class Child {
private int age; private string name;
// Default constructor: public Child()
{
name = "N/A"; }
// Constructor:
public Child(string name, int age) {
this.name = name;
this.age = age; }
// Printing method: public void PrintChild() {
Console.WriteLine("{0}, {1} years old.", name, age); }
}
class StringTest {
static void Main() {
} }
// Create objects by using the new operator: Child child1 = new Child("Craig", 11);
Child child2 = new Child("Sally", 10);
// Create an object using the default constructor: Child child3 = new Child();
// Display results: Console.Write("Child child1.PrintChild(); Console.Write("Child child2.PrintChild(); Console.Write("Child child3.PrintChild();
#1: "); #2: "); #3: ");
/* Output:
Child #1: Craig, 11 years old. Child #2: Sally, 10 years old. Child #3: N/A, 0 years old.
*/

      Main から Child のプライベート メンバーへのアクセスは、 Main がそのクラスのメンバーである場合にのみ可能です。 アクセス修飾子を指定せずにクラス内で宣言された型は既定で private になります。そのため、キーワードが削除されてもこ
の例のデータメンバーは private です。 最後に、パラメーターなしのコンストラクターを使って作成したオブジェクト(child3)の age フィールドが、既定で0に初期化
されていることに注意してください。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード 参照型
    Console.Write(child1.name); // Error
 
             インターフェイスによりコントラクトが定義されます。そのコントラクトを実装する class または struct では、インターフェイスで 定義されているメンバーを実装する必要があります。 C# 8.0 以降では、インターフェイスによってメンバーの既定の実装を定義 できます。共通の機能を1回で実装する目的で static メンバーも定義できます。
次の例の ImplementationClass クラスは、 SampleMethod を返す、パラメーターのない void メソッドを実装する必要があり ます。
使用例を含む詳細については、「インターフェイス」を参照してください。 例
    インターフェイスには、名前空間またはクラスのメンバーを指定できます。 インターフェイス宣言には、次のメンバーの宣言を含め ることができます (実装なしのシグネチャ)。
メソッド プロパティ インデクサー イベント
これらのメンバー宣言には通常、本文が含まれません。 C# 8.0 以降では、インターフェイス メンバーで本文を宣言できます。 こ れは 既定の実装 と呼ばれています。 本文のあるメンバーでは、実装がオーバーライドされないクラスおよび構造体に "既定の" 実装を与えることがインターフェイスに許可されます。 また、C# 8.0 以降、インターフェイスには次を含めることができます。
定数
オペレーター
静的コンストラクター。
入れ子にされた型 静的フィールド、メソッド、プロパティ、インデクサー、イベント
interface (C# リファレンス) 2021/03/06 • • Edit Online
    interface ISampleInterface
{
    void SampleMethod();
}
class ImplementationClass : ISampleInterface
{
    // Explicit interface member implementation:
    void ISampleInterface.SampleMethod()
    {
        // Method implementation.
    }
    static void Main()
    {
        // Declare an interface instance.
        ISampleInterface obj = new ImplementationClass();
        // Call the member.
        obj.SampleMethod();
    }
}
 
      明示的なインターフェイス実装構文を使用するメンバー宣言。 明示的なアクセス修飾子 (既定のアクセスは public )。
インターフェイスには、インスタンスの状態を含めることはできません。 静的フィールドが許可されるようになりましたが、インスタン ス フィールドはインターフェイスでは許可されません。 インスタンスの自動プロパティでは暗黙的に隠しフィールドが宣言されること があり、インターフェイスではサポートされていません。 このルールは、プロパティの宣言に微細な影響を与えます。 インターフェイ ス宣言では、次のコードによって、 class や struct の場合のように自動実装プロパティが宣言されることはありません。 その 代わり、既定の実装が与えられないが、インターフェイスを実装する何らかの型で実装する必要があるプロパティが宣言されま す。
インターフェイスは、1 つ以上の基底インターフェイスから継承できます。 あるインターフェイスで基底インターフェイスに実装されて いるメソッドがオーバーライドされるとき、そのインターフェイスでは明示的なインターフェイス実装構文を使用する必要がありま す。
基本型のリストに基底クラスとインターフェイスが含まれる場合は、基底クラスがリストの最初に表示されます。
インターフェイスを実装するクラスは、そのインターフェイスのメンバーを明示的に実装できます。 明示的に実装されているメン バーには、クラス インスタンスではアクセスできません。インターフェイスのインスタンスを使用した場合にのみアクセスできます。 ま た、既定のインターフェイス メンバーには、インターフェイスのインスタンス経由でのみアクセスできます。
明示的なインターフェイス実装の詳細については、「明示的なインターフェイスの実装」を参照してください。 例
ここでは、インターフェイスの実装例を示します。 この例では、インターフェイスにプロパティ宣言が含まれ、クラスに実装が含まれ ます。 IPoint を実装するクラスのインスタンスには、整数プロパティ x および y が含まれています。
       public interface INamed
{
  public string Name {get; set;}
}
 
      C# 言語仕様
詳細については、C# 言語仕様の「インターフェイス」セクションと C# 8.0 の既定のインターフェイス メンバーに関するページを参
照してください。 関連項目
   interface IPoint
{
   // Property signatures:
   int X
   {
get;
set; }
int Y {
get;
set; }
   double Distance
   {
get; }
}
class Point : IPoint
{
   // Constructor:
   public Point(int x, int y)
   {
X = x;
Y = y; }
   // Property implementation:
   public int X { get; set; }
   public int Y { get; set; }
   // Property implementation
   public double Distance =>
      Math.Sqrt(X * X + Y * Y);
}
class MainClass
{
   static void PrintPoint(IPoint p)
   {
      Console.WriteLine("x={0}, y={1}", p.X, p.Y);
   }
   static void Main()
   {
      IPoint p = new Point(2, 3);
      Console.Write("My Point: ");
      PrintPoint(p);
} }
// Output: My Point: x=2, y=3

       C# リファレンス
C# プログラミング ガイド C# のキーワード 参照型 インターフェイス プロパティの使用 インデクサーの使用

         NOTE
この記事では、Null 許容参照型について説明します。 また、Null 許容値型を宣言することもできます。
 Null 許容参照型は、C# 8.0 以降、"Null 許容認識コンテキスト" にオプトインしたコードで使用できます。 Null 許容参照 型、Null スタティック分析の警告、Null 免除演算子は、オプションの言語機能です。 既定では、すべてオフになっています。 "Null 許容コンテキスト" は、プロジェクト レベルでビルド設定を使用して、またはコード内で pragma を使用して制御されま す。
Null 許容認識コンテキストでは、次の規則が使用されます。
参照型 T の変数は、Null 以外で初期化する必要があり、 null の可能性がある値が割り当てられない場合があります。 参照型 T? の変数は、 null で初期化することも、 null を割り当てることもできます。ただし、逆参照する前に、 null かどうかをチェックする必要があります。
型 T? の変数 m は、m! のようにNull免除演算子を適用する場合、Nullではないと見なされます。
Null非許容参照型 T とNull許容参照型 T? の区別は、コンパイラによる前述の規則の解釈によって適用されます。型 T の変数と型 T? の変数は、同じ.NET型で表されます。次の例は、Null非許容文字列とNull許容文字列を宣言し、
Null 免除演算子を使用して、値を Null 非許容文字列に割り当てます。
変数 notNull と nullable は両方とも、String型で表されます。Null非許容型とNull許容型は両方とも、同じ型に格 納されるため、Null 許容参照型を使用できない場所がいくつかあります。 通常、Null 許容参照型は、基底クラスまたは実装 されたインターフェイスとして使用できません。 Null 許容参照型は、オブジェクトの作成または型のテスト式で使用することはで きません。 Null 許容参照型は、メンバー アクセス式の型にすることはできません。 次の例は、これらのコンストラクトを示しま す。
    string notNull = "Hello";
string? nullable = default;
notNull = nullable!; // null forgiveness
       public MyClass : System.Object? // not allowed
{
}
var nullEmpty = System.String?.Empty; // Not allowed
var maybeObject = new object?(); // Not allowed
try
{
    if (thing is string? nullableString) // not allowed
        Console.WriteLine(nullableString);
} catch (Exception? e) // Not Allowed
{
    Console.WriteLine("error");
}
 Null 許容参照とスタティック分析
前のセクションの例は、Null 許容参照型の特性を示しています。 Null 許容参照型は新しいクラスの型ではなく、既存の参照
Null 許容参照型 (C# リファレンス) 2021/03/06 • • Edit Online
 
 型に対する注釈です。 コンパイラは、これらの注釈を使用して、ユーザーがコード内で発生する可能性のある Null 参照エラー を検出しやすくします。 Null 非許容参照型と Null 参照型の間には、ランタイムの違いはありません。 コンパイラは、Null 非 許容参照型のランタイム チェックを追加しません。 この利点は、コンパイル時分析にあります。 コンパイラは、コード内で発生す る可能性のある Null エラーの検出と修正に役立つ警告を生成します。 意図を宣言すると、コンパイラは、コードがその意図に 違反したときに警告を発行します。
Null 許容の有効なコンテキストでは、コンパイラは、Null 許容と Null 非許容の両方の参照型の変数に対してスタティック分 析を実行します。 コンパイラは、各参照変数の null 状態を "null ではない" または "null かもしれない" として追跡します。 Null 非許容参照の既定の状態は、"null ではない" です。 Null 許容参照の既定の状態は、"null かもしれない" です。
Null 非許容参照型の null 状態は "null ではない" であるため、この型は常に安全に逆参照できます。 この規則を適用する ために、Null 非許容参照型が Null 以外の値に初期化されていない場合、コンパイラは警告を発行します。 ローカル変数 は、宣言されている場所に割り当てる必要があります。 すべてのコンストラクターは、その本体または呼び出されるコンストラク ター内で、またはフィールド初期化子を使用してすべてのフィールドに割り当てる必要があります。 状態が "null かもしれない" である参照に、Null 非許容参照が割り当てられている場合、コンパイラは警告を発行します。 しかし、Null 非許容参照 は"null ではない" であるため、これらの変数が逆参照される場合、警告は変更されません。
Null 許容参照型は、 null に初期化することも、割り当てることもできます。 したがって、スタティック分析では、変数が逆参照 される前に、それが "null ではない" であることを確認する必要があります。 Null 許容参照が "null かもしれない" であると判 断された場合、それを Null 非許容参照変数に割り当てることはできません。 次のクラスは、これらの警告の例を示します。

      次のスニペットは、このクラスを使用したときにコンパイラが警告を発行する場所を示します。
    string shortDescription = default; // Warning! non-nullable set to null;
var product = new ProductDescription(shortDescription); // Warning! static analysis knows shortDescription
maybe null.
string description = "widget";
var item = new ProductDescription(description);
item.SetDescriptions(description, "These widgets will do everything.");
 上記の例は、参照変数の null 状態を判断するコンパイラのスタティック分析を示しています。 コンパイラは、null のチェックと割 り当てに関する言語規則を適用して、その分析を通知します。 コンパイラは、メソッドまたはプロパティのセマンティクスについて想 定することはできません。 null チェックを実行するメソッドを呼び出した場合、コンパイラは、それらのメソッドが変数の null 状態 に影響することを認識できません。 API が引数と戻り値のセマンティクスについてコンパイラに通知するために追加できる属性が いくつかあります。 これらの属性は、.NET Core ライブラリ内の多数の一般的な API に適用されています。 たとえ ば、IsNullOrEmpty は更新され、コンパイラは、そのメソッドを null チェックとして正しく解釈します。 null 状態のスタティック分 析に適用される属性の詳細については、Null 許容属性に関する記事を参照してください。
  public class ProductDescription
{
    private string shortDescription;
    private string? detailedDescription;
    public ProductDescription() // Warning! short description not initialized.
    {
    }
    public ProductDescription(string productDescription) =>
        this.shortDescription = productDescription;
    public void SetDescriptions(string productDescription, string? details=null)
    {
        shortDescription = productDescription;
        detailedDescription = details;
    }
    public string GetDescription()
    {
        if (detailedDescription.Length == 0) // Warning! dereference possible null
        {
            return shortDescription;
        }
else {
            return $"{shortDescription}\n{detailedDescription}";
        }
}
    public string FullDescription()
    {
        if (detailedDescription == null)
        {
            return shortDescription;
        }
        else if (detailedDescription.Length > 0) // OK, detailedDescription can't be null.
        {
            return $"{shortDescription}\n{detailedDescription}";
        }
        return shortDescription;
    }
}

       Null 許容コンテキストの設定
Null許容コンテキストを制御するには、2つの方法があります。プロジェクトレベルでは、<Nullable>enable</Nullable> プロ ジェクトを追加できます。 単一の C# ソース ファイルでは、 #nullable enable pragma を追加して、Null 許容コンテキストを 有効にすることができます。 Null 許容戦略の設定 に関する記事を参照してください。
C# 言語仕様
詳細については、C# 言語仕様に関する次の提案を参照してください。
Null 許容参照型
null 許容参照型仕様の下書き
関連項目
C# リファレンス null 許容値型
  
       メソッド(またはローカル関数)が値を返さないことを指定するには、メソッドの戻り値の型として void を使用します。
    public static void Display(IEnumerable<int> numbers)
{
    if (numbers is null)
    {
return; }
    Console.WriteLine(string.Join(" ", numbers));
}
 さらに、不明な型へのポインターを宣言するための参照型として void を使用できます。詳しくは、「ポインター型」をご覧くださ い。
変数の型として void を使用することはできません。 関連項目
C# リファレンス System.Void
void (C# リファレンス) 2020/11/02 • • Edit Online
 
     C# 3 以降、メソッド スコープで宣言された変数には暗黙的な "型" var を与えることができます。 暗黙的に型指定された ローカル変数では、型を自分で宣言した場合と同様に厳密に型指定されますが、コンパイラが型を決定します。 次の 2 つの
i の宣言は機能的に等しくなります。
  var キーワードは、コンストラクターの呼び出し式と共に使用するのが一般的です。 var を使用すると、次の例に示すよう に、変数宣言およびオブジェクトのインスタンス化において型名を繰り返す必要がなくなります。
C#9.0以降では、代替としてターゲット型の new 式を使用できます。
例
次の例は、2つのクエリ式を示しています。最初の式では、var の使用が許可されますが、必須ではありません。クエリ結果の 型を IEnumerable<string> として明示的に指定できるためです。一方、2つ目の式の var では、匿名型のコレクションとし ての結果が許され、その型の名前にはコンパイラ自体以外はアクセスできません。 var を使うと、結果のために新しいクラスを 作成する必要がなくなります。 例 #2 では、 foreach 繰り返し変数 item も暗黙的に型指定する必要があります。
    var (C# リファレンス) 2020/11/02 • • Edit Online
    var i = 10; // Implicitly typed.
int i = 10; // Explicitly typed.
    IMPORTANT
var を null 許容参照型を有効にして使用すると、式の型で null 値が許容されない場合でも、常に null 値を許容する参照型を表しま す。
  var xs = new List<int>();
    List<int> xs = new();
List<int>? ys = new();
 
     関連項目
C# リファレンス 暗黙的に型指定されるローカル変数 LINQ クエリ操作での型の関係
   // Example #1: var is optional when
// the select clause specifies a string
string[] words = { "apple", "strawberry", "grape", "peach", "banana" };
var wordQuery = from word in words
                where word[0] == 'g'
                select word;
// Because each element in the sequence is a string,
// not an anonymous type, var is optional here also.
foreach (string s in wordQuery)
{
    Console.WriteLine(s);
}
// Example #2: var is required because
// the select clause specifies an anonymous type
var custQuery = from cust in customers
                where cust.City == "Phoenix"
                select new { cust.Name, cust.Phone };
// var must be used because each item
// in the sequence is an anonymous type
foreach (var item in custQuery)
{
    Console.WriteLine("Name={0}, Phone={1}", item.Name, item.Phone);
}
 
                         C# の組み込みの値型を次の表に一覧表示します。 C #
bool
byte
sbyte
char
decimal
double
float
int
uint
long
ulong
short
ushort
C# の組み込みの参照型を次の表に一覧表示します。 C#
object
string
dynamic
.NET
System.Boolean System.Byte System.SByte System.Char System.Decimal System.Double System.Single System.Int32 System.UInt32 System.Int64 System.UInt64 System.Int16 System.UInt16
.NET
System.Object System.String System.Object
                                                                          上の表の左の列にある各 C# 型キーワードは、対応する .NET 型の別名です。 これらは交換可能です。 たとえば、次の宣言 では、同じ型の変数が宣言されています。
組み込み型 (C# リファレンス) 2020/11/02 • • Edit Online
 
    void キーワードで、値がないことが表されます。値を返さないメソッドの戻り値の型として使用します。 関連項目
C# リファレンス C# 型の既定値
   int a = 123;
System.Int32 b = 123;
 
     型は、次のいずれかの型である場合、 アンマネージド型 です。
sbyte 、 byte 、 short 、 ushort 、 int 、 uint 、 long 、 ulong 、 char 、 float 、 double 、 decimal 、または
bool
すべての列挙型 すべてのポインター 型
アンマネージド型のフィールドのみが含まれるすべてのユーザー定義の構造体型で、かつ C# 7.3 以前の場合は、構築され た型 (1 つ以上の型引数が含まれる型) でない
C#7.3以降、unmanaged 制約を使用して、型パラメーターが非ポインターで、null非許容で、アンマネージド型であることを 指定できます。
C# 8.0 以降では、次の例に示すように、アンマネージド型のフィールドのみが含まれる " 構築された " 構造体型もアンマネージ ド型になります。
        using System;
public struct Coords<T>
{
public T X;
public T Y; }
public class UnmanagedTypes
{
    public static void Main()
    {
        DisplaySize<Coords<int>>();
        DisplaySize<Coords<double>>();
    }
    private unsafe static void DisplaySize<T>() where T : unmanaged
    {
        Console.WriteLine($"{typeof(T)} is unmanaged and its size is {sizeof(T)} bytes");
    }
}
// Output:
// Coords`1[System.Int32] is unmanaged and its size is 8 bytes
// Coords`1[System.Double] is unmanaged and its size is 16 bytes
 ジェネリック構造体は、構築されたアンマネージド型およびアンマネージドでない型の両方のソースになる場合があります。 前の 例では、ジェネリック構造体 Coords<T> を定義し、構築されたアンマネージド型の例を示します。アンマネージド型でない例は
Coords<object> です。アンマネージドでない object 型のフィールドがあるため、これはアンマネージドではありません。構築 された"すべての"型をアンマネージド型にする場合は、ジェネリック構造体の定義で unmanaged 制約を使用します。
        public struct Coords<T> where T : unmanaged
{
public T X;
public T Y; }
 アンマネージド型 (C# リファレンス) 2020/11/02 • • Edit Online
 
        C# 言語仕様
詳しくは、「C# 言語仕様」の「ポインター型」をご覧ください。
関連項目
C# リファレンス
ポインター型 メモリおよびスパンに関連する型 sizeof 演算子
stackalloc

            次の表では、C# の型の既定値を示します。
任意の参照型 任意の組み込み整数数値型
任意の組み込み浮動小数点数値型 bool
char
enum
null
0 (ゼロ) 0 (ゼロ) false
'\0' (U+0000)
式 (E)0 によって生成される値。 E は列挙型識別子です。
                           struct
   すべての値型フィールドが既定値に設定され、すべての参照型フィール ドが null に設定された値。
    任意の null 許容値型
  HasValue プロパティが false で、Value プロパティが未定義のイ ンスタンス。 その規定値は、null 許容値型の "null" 値とも呼ばれま す。
  次の例に示すように、型の既定値を生成するには default 演算子を使います。
C#7.1以降、default リテラルを使用して、その型の既定値に変数を初期化できます。
値の型については、次の例が示すように、暗黙的なパラメーターなしのコンストラクターによっても、型の既定値が生成されま す。
実行時に、System.Type インスタンスが値の型を表している場合は、Activator.CreateInstance(Type) メソッドを使用して、パ ラメーターなしのコンストラクターを呼び出して、型の既定値を取得できます。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
  int a = default(int);
    int a = default;
     var n = new System.Numerics.Complex();
Console.WriteLine(n);  // output: (0, 0)
 既定値
C# 型の既定値 (C# リファレンス) 2021/03/16 • • Edit Online
 
    既定のコンストラクター
関連項目
C# リファレンス コンストラクター

             キーワードは、コンパイラで特別な意味を持つ、事前に定義されている予約済みの識別子です。 キーワードは、プレフィックスと して @ を含めない限り、プログラムで識別子として使用できません。 たとえば、 @if は有効な識別子ですが、 if は違いま す。これは、 if がキーワードだからです。
このトピックの最初の表では、C# プログラムの予約済み識別子であるキーワードの一覧を示します。 2 番目の表では、C# のコ ンテキスト キーワードの一覧を示します。 コンテキスト キーワードは、プログラムの限定されたコンテキストでのみ特別な意味を 持つもので、そのコンテキストの外部では識別子として使用することができます。 一般に、C# 言語に新しいキーワードが追加さ れると、それらはコンテキスト キーワードとして追加されます。これは、以前のバージョンで記述されたプログラムの破損を防ぐため です。
       abstract break char continue do event finally foreach in
is
new
out protected ref
short string throw uint
as
byte checked decimal double explicit fixed goto int
lock null override public return sizeof struct true ulong
base case class default else extern float
if
interface long object params readonly sbyte stackalloc switch
try unchecked
bool catch const delegate enum false
for
implicit internal namespace operator private record sealed static
this
typeof unsafe
                                                                                                                                            C# のキーワード 2021/03/22 • • Edit Online
 
                   ushort using virtual void
       volatile while
コンテキスト キーワード
コンテキスト キーワードを使用して、コード内で特定の意味を付与することができます。ただし C# ではコンテキスト キーワードは 予約語ではありません。 partial や where など、2つ以上のコンテキストで特別な意味を持つコンテキストキーワードもあり ます。
          add
async
descending
from
group
let
notnull
orderby
remove
unmanaged (ジェネリック型制約) when (フィルター条件)
ある場合
関連項目
C# リファレンス
alias await dynamic get
into
nameof
nuint
partial (型)
select
value
where (ジェネリック型制約) yield
ascending by
equals global join
nint
on
partial (メソッド) set
var
where (クエリ句)
                                                                     
                 アクセス修飾子は、メンバーまたは型の宣言されたアクセシビリティを指定するときに使用されるキーワードです。 ここでは、4 つ のアクセス修飾子について説明します。
アクセス修飾子を使用して、次の 6 つのアクセシビリティ レベルを指定できます。
public :アクセスは無制限です。
protected :コンテナーであるクラスまたはそこから派生した型にアクセスが限定されます。
internal :アクセスは現在のアセンブリに限定されます。
protected internal :現在のアセンブリ、または包含クラスから派生した型にアクセスが限定されます。 private :コンテナーである型にアクセスが限定されます。
private protected :包含クラス、または包含クラスから派生した型にアクセスが制限されます。
このセクションでは、以下についても説明します。
アクセシビリティ レベル: 4 つのアクセス修飾子を使用して、6 つのアクセシビリティ レベルを宣言します。
アクセシビリティ ドメイン: プログラムのセクション内で、メンバーを参照できる位置を指定します。
アクセシビリティ レベルの使用に関する制限事項: 宣言されたアクセシビリティ レベルの使用に関する制限事項をまとめ たものです。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード アクセス修飾子 アクセス キーワード 修飾子
 public
 protected
 internal
 private
      アクセス修飾子 (C# リファレンス) 2020/11/02 • • Edit Online
 
             以下に示したのは、メンバーに適用されるアクセシビリティ レベルの宣言です。 public 、 protected 、 internal 、 private の各アクセス修飾子を使用して指定します。
     public
protected
internal
protected internal
private
アクセスは無制限です。
コンテナーであるクラスまたはそこから派生した型にアクセスが限定され ます。
アクセスは現在のアセンブリに限定されます。
現在のアセンブリ、またはコンテナーであるクラスから派生した型にアク セスが限定されます。
コンテナーである型にアクセスが限定されます。
                         private protected
  現在のアセンブリ内の、コンテナーであるクラス、またはコンテナーである クラスから派生した型にアクセスが制限されます。 C# 7.2 以降で使 用可能です。
   protected internal または private protected の組み合わせを使う場合を除き、1 つのメンバーまたは 1 つの型に指定で きるアクセス修飾子は 1 つだけです。
アクセス修飾子を名前空間に適用することはできません。 名前空間には、アクセス制限がありません。
メンバーが宣言されているコンテキストによっては、決まったアクセシビリティしか宣言できない場合があります。 メンバーの宣言に アクセス修飾子が指定されていない場合は、既定のアクセシビリティが使用されます。
トップレベルの型(他の型に対して入れ子にされていない型)に指定できるアクセシビリティは internal と public だけです。 既定では、そのような型に internal のアクセシビリティが適用されます。
入れ子にされた型 (他の型のメンバーになっている型) には、次の表に示したアクセシビリティを宣言することができます。
enum public なし
               class
    private
    public
protected
internal
private
protected internal private protected
      アクセシビリティ レベル (C# リファレンス) 2020/11/02 • • Edit Online
 
                      interface public なし
     struct
    private
    public internal private
   入れ子にされた型のアクセシビリティは、その型のアクセシビリティ ドメインによって決まります。このアクセシビリティ ドメインは、その メンバーに対して宣言されているアクセシビリティと、そのメンバーの直接のコンテナーである型のアクセシビリティ ドメインの両方に よって決定されます。 ただし、入れ子にされた型のアクセシビリティ ドメインが、その型を含んでいる型のアクセシビリティ ドメインを 上回ることはできません。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
アクセス修飾子
アクセシビリティ ドメイン
アクセシビリティ レベルの使用に関する制限事項 アクセス修飾子
public
private
protected
internal

    メンバーのアクセシビリティ ドメインとは、どのプログラム セクションをメンバーから参照できるかを規定するものです。 そのメンバー が他の型の入れ子になっている場合、そのアクセシビリティ ドメインは、そのメンバーのアクセシビリティ レベルと、その直接のコンテ ナーである型のアクセシビリティ ドメインとの両方によって決定されます。
トップレベルの型のアクセシビリティ ドメインは、それが宣言されているプロジェクトのプログラム テキストと同じかそれ以上になりま す。 つまり、そのプロジェクトのすべてのソース ファイルがアクセシビリティ ドメインに含まれます。 入れ子にされた型のアクセシビリ ティ ドメインは、それが宣言されている型のプログラム テキストと同じかそれ以上になります。 つまり、アクセシビリティ ドメインは 型の本体 (入れ子にされたすべての型のコンテナー) です。 入れ子にされた型のアクセシビリティ ドメインが、その型を含んでいる 型のアクセシビリティ ドメインを超えることはありません。 次の例では、以上の概念を説明します。
例
この例には、トップレベルの型 T1 があり、そこに M1 と M2 の2つのクラスが入れ子にされています。これらのクラスには、それ ぞれ異なるアクセシビリティが宣言されたいくつかのフィールドがあります。 Main メソッドの各ステートメントには、それぞれのメン バーのアクセシビリティ ドメインを示したコメントが記述されています。 アクセスできないメンバーを参照するステートメントがコメン ト アウトされていることに注目してください。アクセスできないメンバーを参照したことが原因で発生するコンパイラ エラーを確認し たい場合は、1 つずつコメントを解除してください。
   アクセシビリティ ドメイン (C# リファレンス) 2020/11/02 • • Edit Online
  public class T1
{
    public static int publicInt;
    internal static int internalInt;
    private static int privateInt = 0;
static T1() {
        // T1 can access public or internal members
        // in a public or private (or internal) nested class.
        M1.publicInt = 1;
        M1.internalInt = 2;
        M2.publicInt = 3;
        M2.internalInt = 4;
        // Cannot access the private member privateInt
        // in either class:
        // M1.privateInt = 2; //CS0122
}
    public class M1
    {
        public static int publicInt;
        internal static int internalInt;
        private static int privateInt = 0;
}
    private class M2
    {
        public static int publicInt = 0;
        internal static int internalInt = 0;
        private static int privateInt = 0;
} }
class MainClass
{

          {
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
アクセス修飾子
アクセシビリティ レベル
アクセシビリティ レベルの使用に関する制限事項 アクセス修飾子
public
private
protected
internal
   } }
static void Main()
{
// Access is unlimited.
T1.publicInt = 1;
// Accessible only in current assembly.
T1.internalInt = 2;
// Error CS0122: inaccessible outside T1.
// T1.privateInt = 3;
// Access is unlimited.
T1.M1.publicInt = 1;
// Accessible only in current assembly.
T1.M1.internalInt = 2;
// Error CS0122: inaccessible outside M1.
//    T1.M1.privateInt = 3;
// Error CS0122: inaccessible outside T1.
//    T1.M2.publicInt = 1;
// Error CS0122: inaccessible outside T1.
//    T1.M2.internalInt = 2;
// Error CS0122: inaccessible outside M2.
//    T1.M2.privateInt = 3;
// Keep the console open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();
 
         宣言で型を指定する場合、その型のアクセシビリティ レベルがメンバーまたは他の型のアクセシビリティ レベルに依存するかどうか をチェックしてください。 たとえば、直接基底クラスは、少なくともその派生クラスと同程度にアクセス可能である必要があります。 次の宣言はコンパイラエラーになりますが、それは基底クラス BaseClass のアクセシビリティが MyClass のアクセシビリティよりも 低いためです。
      class BaseClass {...}
public class MyClass: BaseClass {...} // Error
 宣言されたアクセシビリティ レベルの制限を次の表にまとめます。
CONTEXT
クラス
デリゲート
定数
フィールド
メソッド
Properties
イベント
インデクサー
オペレーター
コンストラクター
クラスの型の直接基底クラスは、少なくとも、クラスの型自体と同程度 にアクセス可能である必要があります。
デリゲート型の戻り値の型およびパラメーターの型は、少なくとも、デリ ゲート型自体と同程度にアクセス可能である必要があります。
定数の型は、少なくとも定数自体と同程度にアクセス可能である必 要があります。
フィールドの型は、少なくともフィールド自体と同程度にアクセス可能で ある必要があります。
メソッドの戻り値の型およびパラメーターの型は、少なくとも、メソッド自 体と同程度にアクセス可能である必要があります。
プロパティの型は、少なくともプロパティ自体と同程度にアクセス可能 である必要があります。
イベントの型は、少なくともイベント自体と同程度にアクセス可能であ る必要があります。
インデクサーの型とパラメーターの型は、少なくとも、インデクサー自体と 同程度にアクセス可能である必要があります。
演算子の戻り値の型とパラメーターの型は、少なくとも、演算子自体 と同程度にアクセス可能である必要があります。
コンストラクターのパラメーターの型は、少なくとも、コンストラクター自 体と同程度にアクセス可能である必要があります。
       インターフェイス
   インターフェイスの型の明示的な基本インターフェイスは、少なくとも、イ ンターフェイスの型自体と同程度にアクセス可能である必要がありま す。
                                   アクセシビリティ レベルの使用に関する制限事
項 (C# リファレンス) 2020/11/02 • • Edit Online
 
 例
さまざまな型の不適切な宣言の例を次に示します。 各宣言の後のコメントは、予期されるコンパイラ エラーを示しています。
    // Restrictions on Using Accessibility Levels
// CS0052 expected as well as CS0053, CS0056, and CS0057
// To make the program work, change access level of both class B
// and MyPrivateMethod() to public.
using System;
// A delegate:
delegate int MyDelegate();
class B {
    // A private method:
    static int MyPrivateMethod()
    {
return 0; }
}
public class A
{
    // Error: The type B is less accessible than the field A.myField.
    public B myField = new B();
    // Error: The type B is less accessible
    // than the constant A.myConst.
    public readonly B myConst = new B();
    public B MyMethod()
    {
        // Error: The type B is less accessible
        // than the method A.MyMethod.
        return new B();
}
    // Error: The type B is less accessible than the property A.MyProp
    public B MyProp
    {
set {
}
}
    MyDelegate d = new MyDelegate(B.MyPrivateMethod);
    // Even when B is declared public, you still get the error:
    // "The parameter B.MyPrivateMethod is not accessible due to
    // protection level."
    public static B operator +(A m1, B m2)
    {
        // Error: The type B is less accessible
        // than the operator A.operator +(A,B)
        return new B();
}
    static void Main()
    {
        Console.Write("Compiled successfully");
    }
}
 
           C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード アクセス修飾子 アクセシビリティ ドメイン アクセシビリティ レベル アクセス修飾子
public
private
protected
internal

         internal キーワードは、型と型のメンバーを示すアクセス修飾子です。
このページでは、 アクセスについて説明します。 キーワードも アクセス修飾子
に含まれます。
internal 型またはメンバーは、次の例のように、同じアセンブリ内のファイルでのみアクセスできます。
internal とその他のアクセス修飾子の比較については、「アクセシビリティレベル」と「アクセス修飾子」を参照してください。 アセンブリについて詳しくは、「.NET のアセンブリ」をご覧ください。
一般的に、内部アクセスはコンポーネント ベースの開発で使用されます。これは、コンポーネントのグループを、アプリケーション コードの他の部分に公開することなくプライベートに連携させることができるためです。 たとえば、グラフィカル ユーザー インターフェ イスを構築するためのフレームワークでは、内部アクセスによってメンバーを使用することで連携する Control クラスと Form ク ラスを提供できます。 これらは内部のメンバーなので、フレームワークを使用しているコードには公開されません。
型またはメンバーが定義されているアセンブリの外側で、型またはメンバーを内部アクセスで参照するとエラーになります。 例
    internal
internal
protected internal
     public class BaseClass
{
    // Only accessible within the same assembly.
    internal static int x = 0;
}
     この例には、2つのファイル(Assembly1.cs と BaseClass が含まれています。2番目のファイルでは、
)が含まれています。最初のファイルには、内部の基底クラス のインスタンス化を試行するとエラーが発生します。
Assembly1_a.cs
  BaseClass
    // Assembly1.cs
// Compile with: /target:library
internal class BaseClass
{
   public static int intM = 0;
}
     // Assembly1_a.cs
// Compile with: /reference:Assembly1.dll
class TestAccess
{
} }
static void Main()
{
   var myBase = new BaseClass();
// CS0122
 例
この例では、例 1 で使用したのと同じファイルを使用し、   のアクセシビリティ レベルを   に変更します。 ま
internal (C# リファレンス) 2020/11/02 • • Edit Online
  BaseClass
  public
 
         た、メンバー intM のアクセシビリティレベルを   に変更します。この場合、クラスのインスタンス化は可能ですが、内 部メンバーへのアクセスはできません。
    // Assembly2.cs
// Compile with: /target:library
public class BaseClass
{
   internal static int intM = 0;
}
     // Assembly2_a.cs
// Compile with: /reference:Assembly2.dll
public class TestAccess
{
   static void Main()
   {
      var myBase = new BaseClass();   // Ok.
      BaseClass.intM = 444;    // CS0117
   }
}
 C# 言語仕様
詳細については、「C# 言語仕様」の宣言されたアクセシビリティに関するセクションを参照してください。 言語仕様は、C# の構
文と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード アクセス修飾子 アクセシビリティ レベル 修飾子
public
private
protected
 internal
 
       private キーワードはメンバーアクセス修飾子です。
このページでは、   アクセスについて説明します。   キーワードも   アクセス修飾子に
含まれます。
プライベート アクセスは、最も制限の多いアクセス レベルです。 次の例に示すように、プライベート メンバーは、宣言されているク ラスまたは構造体の本体内でのみアクセスできます。
同じ本体にある入れ子にされた型も、プライベート メンバーにアクセスできます。
プライベート メンバーへの参照を、クラスの外側やメンバーが宣言されているクラスの外側から行った場合は、コンパイル時のエ ラーが発生します。
private とその他のアクセス修飾子の比較については、「アクセシビリティレベル」と「アクセス修飾子」を参照してください。 例
この例では、Employee クラスに name と salary という2つのプライベートデータメンバーが含まれています。これらのメン バーは、プライベートメンバーであり、メンバーメソッド以外からはアクセスできません。 GetName と Salary というパブリックメ ソッドが追加されており、プライベートメンバーへの制御されたアクセスが許可されています。 name メンバーはパブリックメソッド を通してアクセスされ、 salary メンバーはパブリックな読み取り専用プロパティを通してアクセスされます (詳細については、「プロ パティ」を参照してください)。
        private (C# リファレンス) 2020/11/02 • • Edit Online
  private
  private
  private protected
    class Employee
{
    private int i;
    double d;   // private access by default
}
  
           C# 言語仕様
詳細については、「C# 言語仕様」の宣言されたアクセシビリティに関するセクションを参照してください。 言語仕様は、C# の構
文と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード アクセス修飾子 アクセシビリティ レベル 修飾子
public
protected
internal
   class Employee2
{
    private string name = "FirstName, LastName";
    private double salary = 100.0;
    public string GetName()
    {
        return name;
    }
    public double Salary
    {
        get { return salary; }
    }
}
class PrivateTest
{
    static void Main()
    {
        var e = new Employee2();
        // The data members are inaccessible (private), so
        // they can't be accessed like this:
        //    string n = e.name;
        //    double s = e.salary;
        // 'name' is indirectly accessed via method:
        string n = e.GetName();
        // 'salary' is indirectly accessed via property
        double s = e.Salary;
    }
}
 
       protected キーワードはメンバーアクセス修飾子です。
protected メンバーは、そのクラス内部と、派生クラスのインスタンスからアクセスできます。
protected と他のアクセス修飾子の比較については、「アクセシビリティレベル」を参照してください。
例
派生クラス内で基底クラスの protected メンバーにアクセスできるのは、派生クラスの型を通してアクセスした場合のみです。 た とえば、次のコード セグメントを考えてみます。
    NOTE
このページでは、 アクセスについて説明します。 protected キーワードもアクセス修飾子の protected internal と に含まれます。
   protected
 private protected
      class A {
    protected int x = 123;
}
class B : A {
    static void Main()
    {
        var a = new A();
        var b = new B();
        // Error CS1540, because x can only be accessed by
        // classes derived from A.
        // a.x = 10;
        // OK, because this class derives from A.
b.x = 10; }
}
  ステートメント a.x = 10 でエラーが発生します。これは、クラス B のインスタンスではなく、静的メソッド Main 内にあるためで す。
構造体は継承できないため、構造体のメンバーを protected にすることはできません。 例
この例では、DerivedPoint クラスは Point から派生しています。そのため、基底クラスのprotectedメンバーに、派生クラス から直接アクセスできます。
 protected (C# リファレンス) 2021/03/06 • • Edit Online
 
           x と y のアクセスレベルをprivateに変更すると、コンパイラによってエラーメッセージが生成されます。 'Point.y' is inaccessible due to its protection level.
'Point.x' is inaccessible due to its protection level.
C# 言語仕様
詳細については、「C# 言語仕様」の宣言されたアクセシビリティに関するセクションを参照してください。 言語仕様は、C# の構
文と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
アクセス修飾子
アクセシビリティ レベル
修飾子
public
private
internal
Internal Virtual キーワードのセキュリティ関連事項
     class Point {
    protected int x;
    protected int y;
}
class DerivedPoint: Point
{
    static void Main()
    {
} }
var dpoint = new DerivedPoint();
// Direct access to protected members.
dpoint.x = 10;
dpoint.y = 15;
Console.WriteLine($"x = {dpoint.x}, y = {dpoint.y}");
// Output: x = 10, y = 15
 
              public キーワードは、型と型のメンバーを示すアクセス修飾子です。パブリックアクセスは、最も制限の少ないアクセスレベル です。 次の例のように、パブリック メンバーへのアクセスには制限がありません。
詳しくは、「アクセス修飾子」および「アクセシビリティ レベル」をご覧ください。 例
次の例では、2つのクラス(PointTest と Program)が宣言されています。 PointTest のパブリックメンバー x および y は、 Program から直接アクセスされます。
       public アクセスレベルをprivateまたはprotectedに変更すると、次のエラーメッセージが表示されます。 'PointTest.y' はアクセスできない保護レベルになっています。
C# 言語仕様
詳細については、「C# 言語仕様」の宣言されたアクセシビリティに関するセクションを参照してください。 言語仕様は、C# の構
文と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド アクセス修飾子
C# のキーワード アクセス修飾子
public (C# リファレンス) 2021/03/06 • • Edit Online
    class SampleClass
{
    public int x; // No access restrictions.
}
    class PointTest
{
public int x;
    public int y;
}
class Program
{
    static void Main()
    {
        var p = new PointTest();
        // Direct access to public members.
        p.x = 10;
        p.y = 15;
        Console.WriteLine($"x = {p.x}, y = {p.y}");
} }
// Output: x = 10, y = 15
 
    アクセシビリティ レベル 修飾子
private
protected
internal

     キーワード組み合わせ protected internal はメンバー アクセス修飾子です。 protected internal メンバーには、現在のアセ ンブリから、または包含クラスから派生した型からアクセスできます。 protected internal と他のアクセス修飾子の比較につい ては、「アクセシビリティ レベル」を参照してください。
例
基底クラスのプロテクト内部メンバーは、包含アセンブリ内の任意の型からアクセスします。 派生クラス型の変数経由でアクセス する場合にのみ、別のアセンブリにある派生クラスでもアクセスできます。 たとえば、次のコード セグメントを考えてみます。
     // Assembly1.cs
// Compile with: /target:library
public class BaseClass
{
   protected internal int myValue = 0;
}
class TestAccess
{
    void Access()
    {
        var baseObject = new BaseClass();
        baseObject.myValue = 5;
    }
}
     // Assembly2.cs
// Compile with: /reference:Assembly1.dll
class DerivedClass : BaseClass
{
    static void Main()
    {
        var baseObject = new BaseClass();
        var derivedObject = new DerivedClass();
        // Error CS1540, because myValue can only be accessed by
        // classes derived from BaseClass.
        // baseObject.myValue = 10;
        // OK, because this class derives from BaseClass.
        derivedObject.myValue = 10;
    }
}
   この例には、2 つのファイル (
る ともう1つのクラスである
を持っています。これは
で にアクセスしようとするとエラーが発生します。一方で、派生クラス のインスタンスからこのメンバーに アクセスすると成功します。
Assembly1.cs
と ) が含まれています。 最初のファイルには public 基底クラスであ が含まれています。 BaseClass はprotectedinternalメンバーの
  BaseClass
   myValue
TestAccess
型にアクセスされます。2番目のファイルでは、BaseClass のインスタンス経由
 DerivedClass
 myValue
 構造体は継承できないため、構造体メンバーは protected internal になりません。
Assembly2.cs
 TestAccess
protected internal (C# リファレンス) 2020/11/02 • • Edit Online
 
         C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
アクセス修飾子
アクセシビリティ レベル
修飾子
public
private
internal
Internal Virtual キーワードのセキュリティ関連事項

     キーワード組み合わせ private protected はメンバー アクセス修飾子です。 private protected メンバーには、包含クラスか ら派生した型からアクセスできますが、その包含アセンブリ内に限られます。 private protected と他のアクセス修飾子の比較 については、「アクセシビリティ レベル」を参照してください。
例
基底クラスの private protected メンバーには、変数の静的な型が派生クラス型の場合にのみ、その包含アセンブリで派生型 からアクセスできます。 たとえば、次のコード セグメントを考えてみます。
     NOTE
private protected アクセス修飾子は、C# バージョン 7.2 以降で有効です。
      public class BaseClass
{
    private protected int myValue = 0;
}
public class DerivedClass1 : BaseClass
{
    void Access()
    {
        var baseObject = new BaseClass();
        // Error CS1540, because myValue can only be accessed by
        // classes derived from BaseClass.
        // baseObject.myValue = 5;
        // OK, accessed through the current derived class instance
myValue = 5; }
}
     // Assembly2.cs
// Compile with: /reference:Assembly1.dll
class DerivedClass2 : BaseClass
{
    void Access()
    {
} }
// Error CS0122, because myValue can only be
// accessed by types in Assembly1
// myValue = 10;
   この例には、2つのファイル(Assembly1.cs と )が含まれています。最初のファイルにはpublic基底クラスであ る とそれから派生した型である が含まれています。 BaseClass はprivateprotectedメンバー を持っています。 はこれに2通りのアクセスを試行します。最初に BaseClass のインスタンス経由
で にアクセスしようとするとエラーが出ます。 ただし、 DerivedClass1 で継承されたメンバーとして使用してみると成 功します。
Assembly2.cs
   BaseClass
DerivedClass1
 DerivedClass1
  myValue
  myValue
private protected (C# リファレンス) 2020/11/02 • • Edit Online
 
            2 番目のファイルでは、   の継承されたメンバーとして   にアクセスしようとしてエラーを出します。これに は Assembly1 の派生型のみがアクセスできるためです。
に Assembly2 という名前のInternalsVisibleToAttributeが含まれている場合、派生クラス DerivedClass1 は、 で宣言された private protected メンバーにアクセスできます。 InternalsVisibleTo を使用すると、
メンバーを他のアセンブリの派生クラスから参照できるようになります。 構造体は継承できないため、構造体メンバーは private protected になりません。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
アクセス修飾子
アクセシビリティ レベル
修飾子
public
private
internal
Internal Virtual キーワードのセキュリティ関連事項
   Assembly1.cs
DerivedClass2
myValue
     BaseClass
 private protected
 
    abstract 修飾子は、その修飾対象の実装が不足しているか、不完全であることを示します。クラスやメソッド、プロパティ、イ ンデクサー、イベントと組み合わせてabstract修飾子を使用することができます。クラス宣言に abstract 修飾子を使用し て、クラスは他のクラスの基底クラスとしてのみ使用することを意図し、それ自体ではインスタンス化されないことを示します。 abstract としてマークされたメンバーは、その抽象クラスから派生した非抽象クラスによって実装される必要があります。
例
この例で、 GetArea の機能は、 Shape から派生している Square クラスで実装する必要があります。
       abstract class Shape
{
    public abstract int GetArea();
}
class Square : Shape
{
    int side;
    public Square(int n) => side = n;
    // GetArea method is required to avoid a compile-time error.
    public override int GetArea() => side * side;
    static void Main()
    {
        var sq = new Square(12);
        Console.WriteLine($"Area of the square = {sq.GetArea()}");
    }
}
// Output: Area of the square = 144
 抽象クラスには次の特徴があります。 抽象クラスはインスタンス化できません。 抽象クラスには抽象メソッドとアクセサーを記述することができます。
sealed修飾子を使って抽象クラスを修飾することはできません。2つの修飾子が逆の意味を持つためです。 sealed 修飾子を指定したクラスは継承が禁止されるのに対し、 abstract 修飾子を指定したクラスは継承による使用が強制 されます。
抽象クラスから派生した具象クラスには、継承されたすべての抽象メソッドとアクセサーの実際の機能を実装する必要が あります。
メソッドまたはプロパティに機能が実装されていないことを示すには、そのメソッドまたはプロパティの宣言で abstract 修飾子を 使います。
抽象メソッドには次の特徴があります。
抽象メソッドは、仮想メソッドの性質を暗に含んでいます。
抽象メソッドの宣言は、抽象クラスでしか認められません。 抽象メソッドの宣言には実際の機能が実装されないため、メソッドの本体はありません。つまり、メソッドの宣言は、末尾
   abstract (C# リファレンス) 2020/11/02 • • Edit Online
 
    のセミコロンがあるだけで、シグネチャの後ろに中かっこ ({ }) は存在しません。 次に例を示します。
  public abstract void MyMethod();
 実際の機能は、メソッド (具象クラスのメンバー) に override を指定して実装します。
抽象メソッドの宣言に static 修飾子や virtual 修飾子を使うのは誤りです。 抽象プロパティは、宣言と呼び出しの構文の違いを除けば、抽象メソッドと似た働きを持ちます。
abstract 修飾子を静的プロパティに対して使うのは誤りです。
継承する抽象プロパティは、派生クラス内で override 修飾子を使ったプロパティ宣言を記述することでオーバーライドす
ることができます。
抽象クラスの詳細については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。
すべてのインターフェイス メンバーの機能は、抽象クラスで実装する必要があります。 インターフェイスを実装する抽象クラスで、インターフェイス メソッドを抽象メソッドにマップすることもできます。 次に例を示します。
     interface I {
void M(); }
abstract class C : I
{
    public abstract void M();
}
 例
この例の DerivedClass クラスは、抽象クラス BaseClass から派生しています。 この抽象クラスには、 AbstractMethod という 抽象メソッドのほか、 X と Y の 2 つの抽象プロパティが存在します。
   
        この例の抽象クラスを次のようなステートメントでインスタンス化しようとするとどうなるかを次に示します。
このように、抽象クラス 'BaseClass' のインスタンスをコンパイラが作成できないことを伝えるエラーが発生します。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
C# リファレンス
C# プログラミング ガイド 修飾子
virtual
override
  BaseClass bc = new BaseClass();   // Error
   abstract class BaseClass   // Abstract class
{
    protected int _x = 100;
    protected int _y = 150;
    public abstract void AbstractMethod();
    public abstract int X    { get; }
    public abstract int Y    { get; }
}
class DerivedClass : BaseClass
{
    public override void AbstractMethod()
    {
// Abstract method
} }
_x++;
_y++; }
public override int X
{
get {
        return _x + 10;
    }
}
// overriding property
// overriding property
public override int Y
{
get {
        return _y + 10;
    }
}
static void Main()
{
var o = new DerivedClass();
o.AbstractMethod();
Console.WriteLine($"x = {o.X}, y = {o.Y}");
// Output: x = 111, y = 161

  C# のキーワード

          async 修飾子を使用して、メソッド、ラムダ式、または匿名メソッドが非同期であることを指定します。この修飾子が使用され ているメソッドまたは式を、"非同期メソッド"と呼びます。次の例では、ExampleMethodAsync という名前の非同期メソッドを定 義します。
非同期プログラミングに慣れていない場合、または、非同期メソッドで await 演算子を使って、実行時間が長くなる可能性 のある処理を、呼び出し元のスレッドをブロックすることなく実行する方法を理解していない場合は、「async および await を使 用した非同期プログラミング」の概要を参照してください。 次のコードは、非同期メソッド内のコード で、HttpClient.GetStringAsync メソッドを呼び出します。
非同期メソッドは、最初の await 式に到達するまで同期的に実行されますが、この時点で、待機していたタスクが完了する まで中断されます。 次のセクションの例で示すように、その間はメソッドの呼び出し元に制御が戻ります。
async キーワードで修飾されているメソッドに await 式またはステートメントが含まれていない場合、メソッドは同期的に実行 されます。 await ステートメントが含まれていない非同期メソッドが存在する場合は、その状態がエラーを示す可能性があるた め、コンパイラによって警告が通知されます。 「コンパイラの警告 (レベル 1) CS4014」をご覧ください。
async は、メソッド、ラムダ式、または匿名メソッドを修飾する場合にのみキーワードとなるため、コンテキストキーワードです。 それ以外の場合は、識別子として解釈されます。
例
次の例は、非同期のイベントハンドラー StartButton_Click と非同期メソッド ExampleMethodAsync との間の制御構造およ び制御フローを示しています。 非同期メソッドの結果は、Web ページの文字数です。 このコードは、Visual Studio で Windows Presentation Foundation (WPF) アプリまたは Windows ストア アプリを作成する場合に適しています。アプリの設 定に関するコード内のコメントを参照してください。
このコードは、Visual Studio で、Windows Presentation Foundation (WPF) アプリまたは Windows ストア アプリとして実 行できます。 StartButton という名前のボタン コントロールと、 ResultsTextBox という名前のテキストボックス コントロールが 必要です。 次のように、名前とハンドラーを必ず設定してください。
WPF アプリとしてコードを実行するには:
次のコードを、MainWindow.xaml.csの MainWindow クラスに貼り付けます。 System.Net.Http に対する参照を追加します。
System.Net.Httpに対する using ディレクティブを追加します。
     public async Task<int> ExampleMethodAsync()
{
//... }
   string contents = await httpClient.GetStringAsync(requestUrl);
         <Button Content="Button" HorizontalAlignment="Left" Margin="88,77,0,0" VerticalAlignment="Top" Width="75" Click="StartButton_Click" Name="StartButton"/>
<TextBox HorizontalAlignment="Left" Height="137" Margin="88,140,0,0" TextWrapping="Wrap"
         Text="&lt;Enter a URL&gt;" VerticalAlignment="Top" Width="310" Name="ResultsTextBox"/>
  async (C# リファレンス) 2020/11/02 • • Edit Online
 
     Windows ストア アプリとしてコードを実行するには: 次のコードを、MainPage.xaml.csの MainPage クラスに貼り付けます。
System.Net.Http と System.Threading.Tasks に対する using ディレクティブを追加します。
     private async void StartButton_Click(object sender, RoutedEventArgs e)
{
    // ExampleMethodAsync returns a Task<int>, which means that the method
    // eventually produces an int result. However, ExampleMethodAsync returns
    // the Task<int> value as soon as it reaches an await.
    ResultsTextBox.Text += "\n";
try {
    }
    catch (Exception)
    {
        // Process the exception if one occurs.
    }
}
public async Task<int> ExampleMethodAsync()
{
    var httpClient = new HttpClient();
    int exampleInt = (await httpClient.GetStringAsync("http://msdn.microsoft.com")).Length;
    ResultsTextBox.Text += "Preparing to finish ExampleMethodAsync.\n";
    // After the following return statement, any method that's awaiting
    // ExampleMethodAsync (in this case, StartButton_Click) can get the
    // integer result.
    return exampleInt;
}
// The example displays the following output:
// Preparing to finish ExampleMethodAsync.
// Length: 53292
int length = await ExampleMethodAsync();
// Note that you could put "await ExampleMethodAsync()" in the next line where
// "length" is, but due to when '+=' fetches the value of ResultsTextBox, you
// would not see the global side effect of ExampleMethodAsync setting the text.
ResultsTextBox.Text += String.Format("Length: {0:N0}\n", length);
     IMPORTANT
タスクの詳細およびタスクを待機している間に実行されるコードの詳細については、「async および await を使用した非同期プログラミング」 を参照してください。 類似した要素を使用するフル コンソールの例については、「完了時での複数の非同期タスクとプロセスの実行 (C#)」を 参照してください。
 戻り値の型 非同期メソッドの戻り値の型を次に示します。
Task Task<TResult>
void。 async void メソッドは、呼び出し元でそれらのメソッドを await できず、正常終了またはエラー状態を報告するた めに別のメカニズムを実装する必要があるため、一般に、イベント ハンドラー以外のコードには推奨されません。
C# 7.0 以降、アクセス可能な を持つ任意の型です。 型は この実装例で、 NuGet パッケージ を追加することで使用できます。
非同期メソッドでは in、ref、out パラメーターを宣言できません。また、参照戻り値を指定することもできません。ただし、これら のパラメーターを持つメソッドを呼び出すことはできます。
   GetAwaiter
System.Threading.Tasks.ValueTask<TResult>
 System.Threading.Tasks.Extensions

     メソッドの return ステートメントで   型のオペランドを指定している場合、非同期メソッドの戻り値の型として Task<TResult> を指定します。 メソッドの完了時に意味のある値を返さない場合は、 Task を使用します。 これにより、メソッ
ドの呼び出しでは Task が返されますが、 Task の完了時に、 await を待機している Task 式はすべて、 void に評価さ れます。
戻り値の型 void は主として、その戻り値の型が要求されるイベントハンドラーの定義に使用されます。 void を返す非同 期メソッドの呼び出し元は、このメソッドを待機できず、このメソッドがスローする例外をキャッチできません。
C#7.0以降、GetAwaiter メソッドを持つ別の型(通常は値の型)を返して、コードのパフォーマンスが重要なセクションでメモリ 割り当てを最小限に抑えます。
使用例を含む詳細については、「非同期の戻り値の型」をご覧ください。 関連項目
AsyncStateMachineAttribute
await
async および await を使用した非同期プログラミング 完了時の非同期タスクの処理
   TResult
 
     定数フィールドまたはローカル定数を宣言するには、 const キーワードを使用します。 定数フィールドとローカルは変数でない ため、変更できません。 定数には、数字、ブール値、文字列、または null 参照が含まれます。 いずれかの時点で変わることが 予想される情報を表すために定数を作成してはなりません。 たとえば、サービスの価格、製品バージョン番号、会社のブランド 名などを格納するためには定数フィールドを使用しないでください。 これらの値は時間の経過とともに変更される場合がありま す。コンパイラは定数を伝達するため、ライブラリでコンパイルされた他のコードを再コンパイルして、変更点を反映することが必 要になってしまいます。 readonly キーワードも参照してください。 次に例を示します。
解説
定数宣言の型は、宣言で導入されるメンバーの型を指定します。 ローカル定数または定数フィールドの初期化子は、ターゲッ ト型に暗黙に変換できる定数式であることが必要です。
定数式は、コンパイル時にすべて評価されます。このため、参照型の定数になりうる値は、string とnull参照に限られま す。
定数宣言は、複数の定数を宣言できます。たとえば、次のように宣言できます。
static 修飾子は、定数宣言では使用できません。 定数は、次に示すように、定数式の一部になることができます。
    const int X = 0;
public const double GravitationalConstant = 6.673e-11;
private const string ProductName = "Visual C#";
    public const double X = 1.0, Y = 2.0, Z = 3.0;
      public const int C1 = 5;
public const int C2 = C1 + 100;
     NOTE
readonly キーワードは、 const キーワードとは異なります。 const フィールドは、フィールドの宣言でしか初期化できません。 readonly フィールドは、宣言またはコンストラクターのどちらかで初期化できます。 このため、 readonly フィールドは、使用するコンスト ラクターに応じて異なる値を持つことができます。 また、 const フィールドがコンパイル時定数であるのに対し、 フィールドは実
行時定数として使用できます。たとえば、 のように使用しま す。
   readonly
 public static readonly uint l1 = (uint)DateTime.Now.Ticks;
 例
const (C# リファレンス) 2020/11/02 • • Edit Online
 
       例 この例では、定数をローカル変数として使用する方法を示しています。
    public class SealedTest
{
    static void Main()
    {
        const int C = 707;
        Console.WriteLine($"My local constant = {C}");
    }
}
// Output: My local constant = 707
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード 修飾子
readonly
   public class ConstTest
{
    class SampleClass
    {
        public int x;
        public int y;
        public const int C1 = 5;
        public const int C2 = C1 + 5;
        public SampleClass(int p1, int p2)
        {
x = p1;
y = p2; }
}
    static void Main()
    {
        var mC = new SampleClass(11, 22);
        Console.WriteLine($"x = {mC.x}, y = {mC.y}");
        Console.WriteLine($"C1 = {SampleClass.C1}, C2 = {SampleClass.C2}");
} }
/* Output
    x = 11, y = 22
    C1 = 5, C2 = 10
*/
 
             event キーワードを使用し、パブリッシャークラス内にイベントを宣言します。 例
次の例では、基になるデリゲート型として EventHandler を使用するイベントを宣言し、発生させる方法について説明します。 完全なコード例については、「.NET ガイドラインに準拠したイベントを発行する方法」を参照してください。この例では、ジェネリッ ク EventHandler<TEventArgs> デリゲート型を使用する方法と、イベントをサブスクライブして、イベント ハンドラー メソッドを 作成する方法も確認できます。
    public class SampleEventArgs
{
    public SampleEventArgs(string text) { Text = text; }
    public string Text { get; } // readonly
}
public class Publisher
{
    // Declare the delegate (if using non-generic pattern).
    public delegate void SampleEventHandler(object sender, SampleEventArgs e);
    // Declare the event.
    public event SampleEventHandler SampleEvent;
    // Wrap the event in a protected virtual method
    // to enable derived classes to raise the event.
    protected virtual void RaiseSampleEvent()
    {
        // Raise the event in a thread-safe manner using the ?. operator.
        SampleEvent?.Invoke(this, new SampleEventArgs("Hello"));
    }
}
 イベントは、宣言元 (パブリッシャー クラス) のクラスまたは構造体内でしか呼び出せない特殊なマルチキャスト デリゲートです。 他のクラスまたは構造体がイベントを受信登録した場合、パブリッシャー クラスがイベントを発生させると、他のクラスまたは構造 体のイベント ハンドラー メソッドが呼び出されます。 詳細およびコード例については、「イベント」および「デリゲート」を参照してく ださい。
イベントは、public、private、protected、internal、protected internal、または private protected としてマークできます。 こ れらのアクセス修飾子により、クラスのユーザーがイベントにアクセスする方法が定義されます。 詳細については、「アクセス修飾 子」を参照してください。
キーワードとイベント イベントには次のキーワードが適用されます。
   static
   クラスのインスタンスが存在しない場合でも、 呼び出し元がいつでもイベントを使用できる ようになります。
   静的クラスと静的クラス メンバー
 event (C# リファレンス) 2020/11/02 • • Edit Online
 
              virtual
   override キーワードを使用してイベントの動 作をオーバーライドすることを派生クラスに許 可します。
   継承
 sealed 派生クラスでは、それが仮想ではなくなったこ とを指定します。
イベントは、static キーワードを使用して静的イベントとして宣言されることもあります。 その場合、クラスのインスタンスが存在し なくても、呼び出し元がいつでもイベントを使用できるようになります。 詳細については、「静的クラスと静的クラス メンバー」を参 照してください。
イベントは、virtual キーワードを使用して仮想イベントとしてマークできます。 その場合、派生クラスでは、override キーワード を使用してイベントの動作をオーバーライドできます。 詳細については、「継承」を参照してください。 仮想イベントをオーバーラ イドするイベントは、sealed にすることもできます。その場合、派生クラスでは、イベントが仮想でなくなります。 最後に、イベント はabstractとして宣言できます。その場合、コンパイラはイベントアクセサーブロックの add と remove を生成しません。した がって、派生クラスごとに固有の実装を提供する必要があります。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
add
remove
修飾子
デリゲートを結合する方法 (マルチキャスト デリゲート)
    abstract
   コンパイラはイベント アクセサー ブロックの add と remove を生成しません。した
がって、派生クラスは固有の実装を提供す る必要があります。
      
       extern 修飾子は、外部で実装されるメソッドを宣言するために使用します。 extern 修飾子は一般に、相互運用サービス を使用してアンマネージ コードを呼び出すときに、 DllImport 属性と共に使用します。 この場合、次の例に示すように、メソッ ドを static として宣言する必要もあります。
extern キーワードでは、外部アセンブリのエイリアスも定義できます。これにより、単一アセンブリ内から1つのコンポーネントの 複数バージョンを参照できます。 詳細については、「extern エイリアス」を参照してください。
abstract修飾子および extern 修飾子を一緒に使用して同一のメンバーを修飾すると、エラーになります。 extern 修飾子 を使用すると、メソッドがC#コードの外部で実装されていることを意味します。一方、abstract 修飾子を使用すると、メソッ ドの実装がクラスには用意されていないことを意味します。
extern キーワードの C# での用法は、C++ の場合よりも制限されています。 C# のキーワードと C++ のキーワードを比較する には、C++ 言語リファレンスの「extern を使用したリンケージの指定」を参照してください。
例1
この例では、ユーザーの入力したメッセージをプログラムが受け取って、メッセージ ボックスに表示します。 このプログラムは、
User32.dllライブラリからインポートされた MessageBox メソッドを使用します。
      [DllImport("avifil32.dll")]
private static extern void AVIFileInit();
          //using System.Runtime.InteropServices;
class ExternTest
{
    [DllImport("User32.dll", CharSet=CharSet.Unicode)]
    public static extern int MessageBox(IntPtr h, string m, string c, int type);
    static int Main()
    {
} }
string myString;
Console.Write("Enter your message: ");
myString = Console.ReadLine();
return MessageBox((IntPtr)0, myString, "My Message Box", 0);
 例2
この例は、C ライブラリ (ネイティブ DLL) を呼び出す C# プログラムを示しています。 1. 次の C ファイルを作成し、 cmdll.c という名前を付けます。
     // cmdll.c
// Compile with: -LD
int __declspec(dllexport) SampleMethod(int i)
{
  return i*10;
}
 extern (C# リファレンス) 2021/03/06 • • Edit Online
 
      2. Visual Studio のインストール ディレクトリから Visual Studio x64 (または x32) Native Tools コマンド プロンプト ウィン ドウを開き、コマンド プロンプトで「cl -LD cmdll.c」と入力して、 cmdll.c ファイルをコンパイルします。
3. 同じディレクトリに、次の C# ファイルを作成し、 cm.cs という名前を付けます。
     // cm.cs
using System;
using System.Runtime.InteropServices;
public class MainClass
{
    [DllImport("Cmdll.dll")]
      public static extern int SampleMethod(int x);
    static void Main()
    {
        Console.WriteLine("SampleMethod() returns {0}.", SampleMethod(5));
    }
}
 4. Visual Studio のインストール ディレクトリから Visual Studio x64 (または x32) Native Tools コマンド プロンプト ウィン ドウを開き、次のように入力して cm.cs ファイルをコンパイルします。
csc cm.cs (x64 コマンド プロンプトの場合) または csc -platform:x86 cm.cs (x32 コマンド プロンプトの場合) これで、実行可能ファイル cm.exe が作成されます。
5. cm.exe を実行します。 SampleMethod メソッドは、DLL ファイルに値 5 を渡します。DLL は 10 で乗算した値を返し ます。 このプログラムの出力は、次のようになります。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
System.Runtime.InteropServices.DllImportAttribute
C# リファレンス
C# プログラミング ガイド C# のキーワード 修飾子
       SampleMethod() returns 50.
 
     ジェネリック型パラメーターの in キーワードは、型パラメーターが反変であることを指定します。 in キーワードは、ジェネリック インターフェイスとデリゲートで使用できます。
反変性は、ジェネリック パラメーターによって指定された型よりも弱い派生型を使用できるようにする機能です。 これにより、反 変性のインターフェイスを実装するクラスの暗黙の型変換とデリゲート型の暗黙の型変換が可能となります。 ジェネリック型パラ メーターの共変性および反変性は参照型ではサポートされますが、値型ではサポートされません。
型をジェネリック インターフェイスまたはデリゲートで反変として宣言できるのは、メソッドの戻り値の型ではなく、メソッドのパラメー ターの型を定義する場合のみです。 In 、 ref 、 out パラメーターはインバリアントである必要があります。これは、これらのパ ラメーターが共変でも反変でもないことを意味します。
反変の型パラメーターを持つインターフェイスを使用すると、そのインターフェイスのメソッドは、インターフェイス型パラメーターによっ て指定された型よりも弱い派生型の引数を受け取ることができます。 たとえば、IComparer<T> インターフェイスでは、T 型が 反変なので、 が を継承する場合、特別な変換メソッドを使用しなくても IComparer<Person> 型のオブ ジェクトを 型のオブジェクトに割り当てることができます。
反変のデリゲートには、型は同じでありながらより弱い派生ジェネリック型パラメーターを持つ別のデリゲートを割り当てることがで きます。
詳細については、「共変性と反変性」を参照してください。 反変のジェネリック インターフェイス
次の例では、反変のジェネリック インターフェイスを宣言、拡張、および実装する方法を示します。 また、このインターフェイスを 実装するクラスの暗黙的な変換を使用する方法も示します。
   Employee
Person
 IComparer<Employee>
    // Contravariant interface.
interface IContravariant<in A> { }
// Extending contravariant interface.
interface IExtContravariant<in A> : IContravariant<A> { }
// Implementing contravariant interface.
class Sample<A> : IContravariant<A> { }
class Program
{
    static void Test()
    {
} }
IContravariant<Object> iobj = new Sample<Object>();
IContravariant<String> istr = new Sample<String>();
// You can assign iobj to istr because
// the IContravariant interface is contravariant.
istr = iobj;
 反変の汎用デリゲート
次の例では、反変の汎用デリゲートを宣言、インスタンス化、および呼び出す方法を示します。 また、デリゲート型を暗黙的に 変換する方法も示します。
in (ジェネリック修飾子) (C# リファレンス) 2020/11/02 • • Edit Online
 
    C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
out
共変性と反変性 修飾子
   // Contravariant delegate.
public delegate void DContravariant<in A>(A argument);
// Methods that match the delegate signature. public static void SampleControl(Control control) {}
public static void SampleButton(Button button) {}
public void Test()
{
    // Instantiating the delegates with the methods.
    DContravariant<Control> dControl = SampleControl;
    DContravariant<Button> dButton = SampleButton;
    // You can assign dControl to dButton
    // because the DContravariant delegate is contravariant.
    dButton = dControl;
    // Invoke the delegate.
    dButton(new Button());
}
 
        new キーワードを宣言の修飾子として使用すると、基底クラスから継承されたメンバーを明示的に隠ぺいできます。継承され たメンバーを隠ぺいすると、派生バージョンのメンバーで基底クラスのバージョンが置き換えられます。 new 修飾子を使わずにメ ンバーを隠ぺいすることもできますが、コンパイラ警告が表示されます。メンバーを明示的に隠ぺいするために new を使用する 場合は、この警告が抑制されます。
new キーワードは、型のインスタンスの作成に使用することも、またはジェネリック型制約として使用することもできます。 継承されたメンバーを隠ぺいするには、派生クラスで同じメンバー名を使用してメンバーを宣言し、 new キーワードで修飾しま
す。 次に例を示します。
    public class BaseC
{
public int x;
    public void Invoke() { }
}
public class DerivedC : BaseC
{
    new public void Invoke() { }
}
   この例では、 BaseC.Invoke は DerivedC.Invoke で隠ぺいされます。 x フィールドは、似た名前によって隠ぺいされないた め、影響を受けません。
継承による名前の隠ぺいは、次のいずれかの形式で行われます。
一般的に、定数、フィールド、プロパティ、型をクラスまたは構造体で使用すると、同じ名前を共有するすべての基底ク ラスメンバーが隠ぺいされます。次のような特殊な状況があります。たとえば、呼び出し可能ではない型を持つ N と いう名前の新しいフィールドを宣言し、基本型が N をメソッドとして宣言する場合は、新しいフィールドが呼び出し構 文内で基本型の宣言を隠ぺいすることはありません。 詳細については、C# 言語仕様の「メンバー ルックアップ」セクショ ンを参照してください。
メソッドをクラスまたは構造体で使用すると、基底クラスで同じ名前を共有するプロパティ、フィールド、型が隠ぺいされま す。 また、同じシグネチャを持つすべての基底クラス メソッドも隠ぺいされます。
インデクサーをクラスまたは構造体で使用すると、同じシグネチャを持つすべての基底クラス インデクサーが隠ぺいされま す。
new とoverrideには相反する意味があるため、同じメンバーにこの2つの修飾子を使用するとエラーになります。 new 修飾 子は、同じ名前で新しいメンバーを作成し、元のメンバーを隠ぺいします。 override 修飾子は、継承されたメンバーの実装 を拡張します。
宣言で、継承されたメンバーを隠ぺいしない new 修飾子を使用すると、警告が出力されます。 例
この例では、基底クラス BaseC と派生クラス DerivedC が同じフィールド名 x を使用するため、継承されるフィールドの値が 隠ぺいされます。 この例では、 new 修飾子の使い方を示します。 また、基底クラスの隠ぺいされたメンバーに完全修飾名を 使ってアクセスする方法も示します。
  new 修飾子 (C# リファレンス) 2020/11/02 • • Edit Online
 
  例
この例では、入れ子になったクラスが、基底クラスにある同名のクラスを隠ぺいします。 この例では、 new 修飾子を使って警告 メッセージが表示されないようにする方法に加えて、完全修飾名を使用してクラスの隠ぺいされたメンバーにアクセスする方法も 示します。
   public class BaseC
{
    public static int x = 55;
    public static int y = 22;
}
public class DerivedC : BaseC
{
    // Hide field 'x'.
    new public static int x = 100;
    static void Main()
    {
        // Display the new value of x:
        Console.WriteLine(x);
        // Display the hidden value of x:
        Console.WriteLine(BaseC.x);
        // Display the unhidden member y:
        Console.WriteLine(y);
    }
}
/*
Output:
100
55
22
*/
 
         new 修飾子を削除すると、プログラムのコンパイルおよび実行は行われますが、次の警告が出力されます。
C# 言語仕様
詳細については、C# 言語仕様の「new 修飾子」セクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
修飾子
Override キーワードと New キーワードによるバージョン管理 Override キーワードと New キーワードを使用する場合について
  The keyword new is required on 'MyDerivedC.x' because it hides inherited member 'MyBaseC.x'.
    public class BaseC
{
    public class NestedC
    {
        public int x = 200;
        public int y;
    }
}
public class DerivedC : BaseC
{
    // Nested type hiding the base type members.
    new public class NestedC
    {
        public int x = 100;
        public int y;
        public int z;
}
    static void Main()
    {
        // Creating an object from the overlapping class:
        NestedC c1  = new NestedC();
        // Creating an object from the hidden class:
        BaseC.NestedC c2 = new BaseC.NestedC();
        Console.WriteLine(c1.x);
        Console.WriteLine(c2.x);
    }
}
/*
Output:
100
200
*/
 
     ジェネリック型パラメーターの out キーワードは、型パラメーターが共変であることを指定します。 out キーワードは、ジェネリック インターフェイスとデリゲートで使用できます。
共変性は、ジェネリック パラメーターによって指定された型よりも強い派生型を使用できるようにする機能です。 これにより、共 変性のインターフェイスを実装するクラスの暗黙の型変換とデリゲート型の暗黙の型変換が可能となります。 共変性および反 変性は参照型ではサポートされますが、値の型ではサポートされません。
共変の型パラメーターを持つインターフェイスを使用すると、そのインターフェイスのメソッドは、型パラメーターによって指定された 型よりも強い派生型を返すことができます。 たとえば、.NET Framework 4 の IEnumerable<T> では T 型が共変なので、特 別な変換メソッドを使用しなくても IEnumerable(Of String) 型のオブジェクトを IEnumerable(Of Object) 型のオブジェクト に割り当てることができます。
共変のデリゲートには、型は同じでありながらより強い派生ジェネリック型パラメーターを持つ別のデリゲートを割り当てることがで きます。
詳細については、「共変性と反変性」を参照してください。
例 - 共変のジェネリック インターフェイス
次の例では、共変のジェネリック インターフェイスを宣言、拡張、および実装する方法を示します。 また、共変のインターフェイス を実装するクラスの暗黙的な変換を使用する方法も示します。
      // Covariant interface.
interface ICovariant<out R> { }
// Extending covariant interface.
interface IExtCovariant<out R> : ICovariant<R> { }
// Implementing covariant interface.
class Sample<R> : ICovariant<R> { }
class Program
{
    static void Test()
    {
} }
ICovariant<Object> iobj = new Sample<Object>();
ICovariant<String> istr = new Sample<String>();
// You can assign istr to iobj because
// the ICovariant interface is covariant.
iobj = istr;
 ジェネリック インターフェイスでは、次の条件を満たす場合に型パラメーターを共変として宣言できます。 型パラメーターがインターフェイス メソッドの戻り値の型としてのみ使用され、メソッド引数の型として使用されない。
out (ジェネリック修飾子) (C# リファレンス) 2020/11/02 • • Edit Online
 
      型パラメーターがインターフェイス メソッドのジェネリック制約として使用されない。
例 - 共変の汎用デリゲート 次の例では、共変の汎用デリゲートを宣言、インスタンス化、および呼び出す方法を示します。 また、デリゲート型を暗黙的に
変換する方法も示します。
    // Covariant delegate.
public delegate R DCovariant<out R>();
// Methods that match the delegate signature.
public static Control SampleControl()
{ return new Control(); }
public static Button SampleButton()
{ return new Button(); }
public void Test()
{
    // Instantiate the delegates with the methods.
    DCovariant<Control> dControl = SampleControl;
    DCovariant<Button> dButton = SampleButton;
    // You can assign dButton to dControl
    // because the DCovariant delegate is covariant.
    dControl = dButton;
    // Invoke the delegate.
    dControl();
}
 汎用デリゲートでは、メソッドの戻り値の型としてのみ使用され、メソッド引数には使用されない型を共変として宣言できます。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
関連項目
ジェネリック インターフェイスの変性
in
修飾子
   NOTE
この規則には例外が 1 つあります。 共変のインターフェイスで反変の汎用デリゲートをメソッド パラメーターとして使用する場合は、 共変の型をこのデリゲートのジェネリック型パラメーターとして使用できます。 共変および反変の汎用デリゲートの詳細については、 「デリゲートの変性」および「Func および Action 汎用デリゲートでの変性の使用」を参照してください。
 
       override 修飾子は、継承したメソッド、プロパティ、インデクサー、またはイベントの抽象実装または仮想実装を拡張したり修 飾したりする際に必要です。
次の例では、 Square クラスが GetArea のオーバーライドされる実装を提供する必要があります。これは、 GetArea が Shape 抽象クラスから継承されているためです。
      override メソッドは、基底クラスから継承されるメソッドの新しい実装を提供します。 override 宣言によってオーバーライド されるメソッドを、オーバーライドされる基本メソッドと言います。 メソッドには、オーバーライドされる基本メソッドと同 じシグネチャが必要です。 C# 9.0 以降、共変の戻り値の型が メソッドによってサポートされています。 特に、
override メソッドの戻り値の型は、対応する基本メソッドの戻り値の型から派生できます。C#8.0以前の場合、override メソッドとオーバーライドされた基本メソッドの戻り値の型は同じである必要があります。
非仮想メソッドまたは静的メソッドをオーバーライドすることはできません。 オーバーライドされる基本メソッドは、 virtual 、 abstract 、 override のいずれかである必要があります。
override 宣言は、 virtual メソッドのアクセシビリティを変更できません。 override メソッドと virtual メソッドの両方に、 同じアクセス レベル修飾子が必要です。
override メソッドの修飾に、修飾子 new 、 static 、または virtual は使用できません。
オーバーライドするプロパティの宣言では、継承されるプロパティとまったく同じアクセス修飾子、型、および名前を指定する必要 があります。 C# 9.0 以降、共変の戻り値の型が読み取り専用のオーバーライドするプロパティによってサポートされています。 オーバーライドされたプロパティは、 virtual 、 abstract 、または override である必要があります。
override キーワードの使い方の詳細については、「OverrideキーワードとNewキーワードによるバージョン管理」および 「Override キーワードと New キーワードを使用する場合について」を参照してください。 継承については、「継承」を参照してく ださい。
 override
  override
                例
override (C# リファレンス) 2020/11/02 • • Edit Online
    abstract class Shape
{
    public abstract int GetArea();
}
class Square : Shape
{
    int side;
    public Square(int n) => side = n;
    // GetArea method is required to avoid a compile-time error.
    public override int GetArea() => side * side;
    static void Main()
    {
        var sq = new Square(12);
        Console.WriteLine($"Area of the square = {sq.GetArea()}");
    }
}
// Output: Area of the square = 144
 
    この例では、   という基底クラスと、   という派生クラスを定義します。   クラスには追加 のフィールド   があり、このフィールドを処理に含めるために、 CalculatePay メソッドをオーバーライドします。
Employee
  salesbonus
SalesEmployee
SalesEmployee
        class TestOverride
{
    public class Employee
    {
        public string name;
        // Basepay is defined as protected, so that it may be
        // accessed only by this class and derived classes.
        protected decimal basepay;
        // Constructor to set the name and basepay values.
        public Employee(string name, decimal basepay)
        {
            this.name = name;
            this.basepay = basepay;
        }
        // Declared virtual so it can be overridden.
        public virtual decimal CalculatePay()
        {
            return basepay;
        }
}
    // Derive a new class from Employee.
    public class SalesEmployee : Employee
    {
        // New field that will affect the base pay.
        private decimal salesbonus;
        // The constructor calls the base-class version, and
        // initializes the salesbonus field.
        public SalesEmployee(string name, decimal basepay,
                  decimal salesbonus) : base(name, basepay)
        {
            this.salesbonus = salesbonus;
}
        // Override the CalculatePay method
        // to take bonus into account.
        public override decimal CalculatePay()
        {
            return basepay + salesbonus;
        }
}
    static void Main()
    {
        // Create some new employees.
        var employee1 = new SalesEmployee("Alice",
                      1000, 500);
        var employee2 = new Employee("Bob", 1200);
        Console.WriteLine($"Employee1 {employee1.name} earned: {employee1.CalculatePay()}");
        Console.WriteLine($"Employee2 {employee2.name} earned: {employee2.CalculatePay()}");
    }
} /*
*/
Output:
Employee1 Alice earned: 1500
Employee2 Bob earned: 1200
 
         C# 言語仕様
詳細については、C# 言語仕様に関するページの「オーバーライド メソッド」セクションを参照してください。 共変の戻り値の型の詳細については、機能提案メモを参照してください。
関連項目
C# リファレンス 継承
C# キーワード 修飾子 abstract virtual
new (修飾子) ポリモーフィズム

          readonly キーワードは、次の4つのコンテキストで使用できる修飾子です。
フィールドの宣言では、 readonly は、フィールドへの割り当てが、宣言の一部として、または同じクラスのコンストラク ター内でのみ可能であることを示します。 readonly フィールドは、フィールドの宣言とコンストラクターで複数回割り当て および再割り当てを行うことができます。
readonly フィールドは、コンストラクターが終了した後で割り当てることはできません。この規則は、値型と参照型では 意味が異なります。
値型にはそのデータが直接含まれるため、 値型のフィールドは変更できません。 参照型にはそのデータへの参照が含まれるため、 参照型のフィールドは、常に同じオブジェクトを参照す る必要があります。 そのオブジェクトは不変ではありません。 修飾子があると、フィールドを参照型の別の インスタンスで置き換えることはできません。 ただし、フィールドのインスタンス データを読み取り専用フィールドで変更 することは禁止されません。
型定義では、 readonly は構造体型が変更不可であることを示します。 詳細については、「構造 体型」の記事の「 構造体」セクションを参照してください。
構造体型内のインスタンスメンバー宣言では、readonly は、インスタンスメンバーによって構造体の状態が変更され ないことを示します。詳細については、構造体型に関する記事の「readonly インスタンスメンバー」セクションを参照し てください。
ref readonly メソッドの戻り値では、 readonly 修飾子は、メソッドが参照を返し、その参照への書き込みが許可さ れないことを示します。
readonly struct と ref readonly のコンテキストは、C#7.2で追加されました。 readonly 構造体メンバーは、C#8.0で 追加されました。
読み取り専用フィールドの例
この例では、 year フィールドの値は、クラス コンストラクターで値が割り当てられていても ChangeYear メソッドでは変更できま せん。
   readonly
 readonly
 readonly
    WARNING
変更可能な参照型である外部から参照できる読み取り専用フィールドを含む外部から参照できる型はセキュリティの脆弱性があ り、警告 CA2104 がトリガーされる可能性があります: "読み取り専用の変更可能な参照型を宣言しません"。
   readonly struct
 readonly
        readonly (C# リファレンス) 2020/11/02 • • Edit Online
 
   readonly のフィールドに値を割り当てることができるのは、次のコンテキスト内に限られます。 値が宣言で初期化される場合。次に例を示します。
インスタンス フィールド宣言を含むクラスのインスタンス コンストラクター内。
静的フィールド宣言を含むクラスの静的コンストラクター内。
また、これらのコンストラクターコンテキスト内でのみ、readonly フィールドをoutパラメーターまたはrefパラメーターとして渡す ことができます。
  public readonly int y = 5;
      NOTE
readonly キーワードは const キーワードとは異なります。 const フィールドは、フィールドの宣言でしか初期化できません。 readonly フィールドは、フィールドの宣言と任意のコンストラクターで複数回割り当てることができます。 このため、 readonly フィールドは、使用するコ ンストラクターに応じて異なる値を持つことができます。 また、次の例のように、 const フィールドがコンパイル時定数であるのに対し、
readonly フィールドは実行時定数として使用できます。
      public static readonly uint timeStamp = (uint)DateTime.Now.Ticks;
     class Age {
    readonly int year;
    Age(int year)
    {
        this.year = year;
    }
    void ChangeYear()
    {
        //year = 1967; // Compile error if uncommented.
    }
}
 
   上の例で、次の例のようなステートメントを使うものとします。
この場合、次のコンパイル エラー メッセージが表示されます。 読み取り専用フィールドに割り当てることはできません (コンストラクター、変数初期化子では可)
ref readonly の戻り値の例
での readonly 修飾子は、返される参照を変更できないことを示します。次の例は、originに参照を返しま
す。 修飾子を使用して、呼び出し元が origin を変更できないことを示しています。
返される型を readonly struct にする必要はありません。 ref で返すことができる任意の型を、 ref readonly で返すこと ができます。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 言語仕様の提案を参照することもできます。
  p2.y = 66;        // Error
   ref return
 readonly
    private static readonly SamplePoint origin = new SamplePoint(0, 0, 0);
public static ref readonly SamplePoint Origin => ref origin;
      public class SamplePoint
{
    public int x;
    // Initialize a readonly field
    public readonly int y = 25;
    public readonly int z;
    public SamplePoint()
    {
        // Initialize a readonly instance field
z = 24; }
    public SamplePoint(int p1, int p2, int p3)
    {
        x = p1;
        y = p2;
        z = p3;
}
    public static void Main()
    {
        SamplePoint p1 = new SamplePoint(11, 21, 32);
        Console.WriteLine($"p1: x={p1.x}, y={p1.y}, z={p1.z}");
        SamplePoint p2 = new SamplePoint();
        p2.x = 55;   // OK
        Console.WriteLine($"p2: x={p2.x}, y={p2.y}, z={p2.z}");
    }
/* Output:
        p1: x=11, y=21, z=32
        p2: x=55, y=25, z=24
    */
}
// OK
 
       readonly ref と readonly struct readonly 構造体メンバー
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード 修飾子
const
フィールド

       sealed 修飾子をクラスに適用すると、それ以外のクラスが、そのクラスから継承できなくなります。 次の例では、 B クラスは A クラスを継承しますが、 B クラスからはどのクラスも継承できなくなります。
sealed 修飾子は、基底クラスの仮想メソッドまたは仮想プロパティをオーバーライドするメソッドやプロパティで使用することもで きます。 これにより、クラスの派生が行えるようになり、そのクラスが特定の仮想メソッドまたは仮想プロパティをオーバーライドでき なくなります。
例
次の例では、 Z は Y から継承しますが、 Z は仮想関数 F をオーバーライドできません。この仮想関数は X で宣言され
ており、 Y でシールされています。
    class A {}
sealed class B : A {}
      class X {
    protected virtual void F() { Console.WriteLine("X.F"); }
    protected virtual void F2() { Console.WriteLine("X.F2"); }
}
class Y : X {
    sealed protected override void F() { Console.WriteLine("Y.F"); }
    protected override void F2() { Console.WriteLine("Y.F2"); }
}
class Z : Y {
    // Attempting to override F causes compiler error CS0239.
    // protected override void F() { Console.WriteLine("Z.F"); }
    // Overriding F2 is allowed.
    protected override void F2() { Console.WriteLine("Z.F2"); }
}
 新しいメソッドまたはプロパティをクラスで定義するときに、派生クラスによるオーバーライドを防ぐには、その派生クラスを virtual として宣言しないようにします。
abstract 修飾子をシール クラスで使用するとエラーになります。抽象メソッドまたは抽象プロパティを実装するクラスでは、抽象 クラスを継承する必要があるためです。
sealed 修飾子は、メソッドまたはプロパティに適用するときは、常にoverrideと一緒に使用する必要があります。 構造体は暗黙的にシールされるため、継承できません。
詳細については、「継承」を参照してください。
上記以外の例については、「抽象クラスとシール クラス、およびクラス メンバー」を参照してください。
 例
sealed (C# リファレンス) 2020/11/02 • • Edit Online
 
          前の例で、次のステートメントを使用して、シール クラスからの継承を試みたとします。
 class MyDerivedC: SealedClass {} // Error
この場合、次のエラー メッセージが表示されます。
 'MyDerivedC': cannot derive from sealed type 'SealedClass'
注釈
クラス、メソッド、またはプロパティをシールするかどうかを判断するには、通常、次の 2 つの点を検討する必要があります。
クラスをカスタマイズすることで、派生クラスにもたらされる可能性があるメリット。 派生クラスがクラスを変更することで、そのクラスが正常に、または期待どおりに機能しなくなる可能性。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
静的クラスと静的クラス メンバー 抽象クラスとシール クラス、およびクラス メンバー アクセス修飾子
修飾子
override
virtual
     sealed class SealedClass
{
public int x;
    public int y;
}
class SealedTest2
{
    static void Main()
    {
        var sc = new SealedClass();
        sc.x = 110;
        sc.y = 150;
        Console.WriteLine($"x = {sc.x}, y = {sc.y}");
} }
// Output: x = 110, y = 150
 
           このページでは、 static 修飾子キーワードについて説明します。 static キーワードも using static ディレクティブに含ま れます。
static 修飾子は、静的メンバーの宣言に使用します。静的メンバーは、特定のオブジェクトではなく、型自体に属するメン バーです。 static 修飾子は static クラスの宣言に使用できます。 クラス、インターフェイス、構造体では、 static 修飾 子をフィールド、メソッド、プロパティ、演算子、イベント、コンストラクターに追加できます。 static 修飾子はインデクサーおよび ファイナライザーと併用できません。 詳細については、「静的クラスと静的クラス メンバー」を参照してください。
C#8.0以降では、ローカル関数に static 修飾子を追加できます。静的なローカル関数では、ローカル変数やインスタンス の状態をキャプチャすることはできません。
C#9.0以降では、static 修飾子をラムダ式または匿名メソッドに追加できます。静的ラムダまたは匿名メソッドでは、ローカ ル変数またはインスタンスの状態をキャプチャすることはできません。
例 - 静的クラス
次のクラスは static として宣言され、 static メソッドのみが含まれます。
定数宣言や型宣言は暗黙的な static メンバーです。 static メンバーはインスタンスを使って参照できません。代わりに、 型の名前を使って参照します。 たとえば、次のクラスを考えてみます。
メンバー x を参照するには、同じスコープからその静的メンバーにアクセス可能でない限り、完全修飾名( ) を使用します。
クラスのインスタンスには、そのクラスのインスタンスフィールドすべてにそれぞれのコピーが含まれていますが、各 static フィール ドのコピーは 1 つだけです。
static メソッドまたはプロパティ アクセサーへの参照には、 this は使用できません。
static キーワードをクラスに適用する場合、そのクラスのすべてのメンバーが static でなければなりません。
クラス、インターフェイス、 static クラスには、 static コンストラクターを含めることができます。 static コンストラクターは、プ ログラムが開始されてからクラスがインスタンス化されるまでの間に呼び出されます。
              static
 MyBaseC.MyStruct.x
        static (C# リファレンス) 2020/11/02 • • Edit Online
    static class CompanyEmployee
{
    public static void DoSomething() { /*...*/ }
    public static void DoSomethingElse() { /*...*/  }
}
    public class MyBaseC
{
    public struct MyStruct
    {
        public static int x = 100;
    }
}
  Console.WriteLine(MyBaseC.MyStruct.x);
 
    static メンバーの例を示すために、ある企業の従業員を表すクラスを考えてみます。このクラスには、従業員数を数えるメ ソッドと、従業員数を格納するフィールドがあります。 メソッドとフィールドはどちらも、従業員のインスタンスに属しておらず、 全 体として従業員のクラスに属しています。クラスの static メンバーとして宣言する必要があります。
例 - 静的フィールドとメソッド
この例では、新しい従業員の名前と ID を読み取り、従業員数のカウンターを 1 つインクリメントして、新しい従業員の情報と 従業員数を表示します。 このプログラムでは、現在の従業員数がキーボードから読み取られます。
    NOTE
static キーワードの用法は、C++ の場合よりも制限されています。 C++ キーワードと比較するには、「ストレージ クラス (C++)」をご覧 ください。
  
   例 - 静的な初期化
この例では、まだ宣言されていない別の static フィールドを使用することで static フィールドを初期化できます。 static フィールドに値を明示的に割り当てるまで、結果は未定義になります。
      public class Employee4
{
    public string id;
    public string name;
    public Employee4()
    {
    }
    public Employee4(string name, string id)
    {
        this.name = name;
        this.id = id;
    }
    public static int employeeCounter;
    public static int AddEmployee()
    {
        return ++employeeCounter;
    }
}
class MainClass : Employee4
{
    static void Main()
    {
} }
Console.Write("Enter the employee's name: ");
string name = Console.ReadLine();
Console.Write("Enter the employee's ID: ");
string id = Console.ReadLine();
// Create and configure the employee object.
Employee4 e = new Employee4(name, id);
Console.Write("Enter the current number of employees: ");
string n = Console.ReadLine();
Employee4.employeeCounter = Int32.Parse(n);
Employee4.AddEmployee();
// Display the new information.
Console.WriteLine($"Name: {e.name}");
Console.WriteLine($"ID:   {e.id}");
Console.WriteLine($"New Number of Employees: {Employee4.employeeCounter}");
/*
Input:
Matthias Berndt
AF643G
15
 *
Sample Output:
Enter the employee's name: Matthias Berndt
Enter the employee's ID: AF643G
Enter the current number of employees: 15
Name: Matthias Berndt
ID:   AF643G
New Number of Employees: 16
*/

        C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
修飾子
using static ディレクティブ 静的クラスと静的クラス メンバー
   class Test {
    static int x = y;
    static int y = 5;
    static void Main()
    {
        Console.WriteLine(Test.x);
        Console.WriteLine(Test.y);
Test.x = 99;
        Console.WriteLine(Test.x);
    }
}
/* Output:
0 5 99
*/
 
      unsafe キーワードは、ポインターに関連するすべての操作に必要な、unsafeコンテキストを示します。詳細については、「ア ンセーフ コードとポインター」を参照してください。
unsafe 修飾子は、型またはメンバーの宣言で使用できます。そのため、型やメンバーの全体的なテキスト範囲がunsafeコ ンテキストと見なされます。 たとえば、次に示すのは、 unsafe 修飾子を使用して宣言されたメソッドです。
unsafe コンテキストのスコープはパラメーター リストからメソッドの末尾までなので、ポインターはパラメーター リストでも使用できま す。
また、unsafe ブロックを使用して、そのブロック内で unsafe コードを使用できるようにすることもできます。 次に例を示します。
アンセーフコードをコンパイルするには、-unsafe コンパイラオプションを指定する必要があります。unsafeコードは、共通言 語ランタイムでは検証できません。
例
      unsafe static void FastCopy(byte[] src, byte[] dst, int count)
{
    // Unsafe context: can use pointers here.
}
   unsafe static void FastCopy ( byte* ps, byte* pd, int count ) {...}
     unsafe {
    // Unsafe context: can use pointers here.
}
      // compile with: -unsafe
class UnsafeTest
{
    // Unsafe method: takes pointer to int.
    unsafe static void SquarePtrParam(int* p)
    {
*p *= *p; }
    unsafe static void Main()
    {
        int i = 5;
        // Unsafe method: uses address-of operator (&).
        SquarePtrParam(&i);
        Console.WriteLine(i);
} }
// Output: 25
 C# 言語仕様
unsafe (C# リファレンス) 2020/11/02 • • Edit Online
 
         詳細については、「C# 言語の仕様」のアンセーフ コードに関するセクションを参照してください。 言語仕様は、C# の構文と使 用法に関する信頼性のある情報源です。
関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
fixed ステートメント アンセーフ コードとポインター 固定サイズ バッファー

        virtual キーワードは、メソッド、プロパティ、インデクサー、またはイベント宣言を変更し、それを派生クラスでオーバーライドで きるようにするために使用されます。 たとえば、次のメソッドはそれを継承する任意のクラスでオーバーライドできます。
仮想メンバーの実装は、派生クラスのオーバーライドメンバーによって変更できます。 virtual キーワードの使い方について詳 しくは、「Override キーワードと New キーワードによるバージョン管理」および「Override キーワードと New キーワードを使用 する場合について」をご覧ください。
注釈
仮想メソッドが呼び出されると、オブジェクトの実行時の型が、オーバーライドするメンバーに対してチェックされます。 いずれの派 生クラスもメンバーをオーバーライドしなかった場合は、最派生クラスのオーバーライド メンバー (元のメンバーである可能性があ ります) が呼び出されます。
既定では、メソッドは仮想ではありません。 非仮想メソッドをオーバーライドすることはできません。
virtual 修飾子を、 static 、 abstract 、 private 、 override 修飾子と共に使用することはできません。 次のコードは、 仮想のプロパティの例です。
    public virtual double Area()
{
return x * y; }
       virtual (C# リファレンス) 2020/11/02 • • Edit Online
 
    仮想プロパティは、宣言と呼び出しの構文の違いを除けば、仮想メソッドと似た働きを持ちます。 virtual 修飾子を静的プロパティに対して使うのは誤りです。
継承する仮想プロパティは、派生クラス内で override 修飾子を使ったプロパティ宣言を記述することでオーバーライド することができます。
例
この例では、 Shape クラスに 2 つの座標 ( x と y ) と仮想メソッド Area() が含まれています。 他の図形クラス ( 、 Cylinder 、 Sphere など) は Shape クラスを継承しており、各図の表面積が計算されています。 各派生クラスは、
のオーバーライド実装を独自に持っています。
次の宣言に示すように、継承されたクラス ( Circle 、 Sphere 、および Cylinder ) はいずれも、基底クラスを初期化するコン ス トラクターを使用します。
次のプログラムは、メソッドに関連付けられたオブジェクトに従って Area() メソッドの適切な実装を呼び出すことにより、各図形 の面積を計算し、表示します。
    Circle
   Area()
     public Cylinder(double r, double h): base(r, h) {}
        class MyBaseClass
{
    // virtual auto-implemented property. Overrides can only
    // provide specialized behavior if they implement get and set accessors.
    public virtual string Name { get; set; }
    // ordinary virtual property with backing field
    private int num;
    public virtual int Number
    {
        get { return num; }
        set { num = value; }
    }
}
class MyDerivedClass : MyBaseClass
{
    private string name;
   // Override auto-implemented property with ordinary property
   // to provide specialized accessor behavior.
    public override string Name
    {
get {
            return name;
        }
set {
else {
                name = "Unknown";
            }
} }
}
if (!string.IsNullOrEmpty(value))
{
    name = value;
}

   class TestClass
{
    public class Shape
    {
        public const double PI = Math.PI;
        protected double x, y;
        public Shape()
        {
        }
        public Shape(double x, double y)
        {
this.x = x;
this.y = y; }
        public virtual double Area()
        {
return x * y; }
}
    public class Circle : Shape
    {
        public Circle(double r) : base(r, 0)
        {
        }
        public override double Area()
        {
            return PI * x * x;
        }
}
    class Sphere : Shape
    {
        public Sphere(double r) : base(r, 0)
        {
        }
        public override double Area()
        {
            return 4 * PI * x * x;
        }
}
    class Cylinder : Shape
    {
        public Cylinder(double r, double h) : base(r, h)
        {
        }
        public override double Area()
        {
            return 2 * PI * x * x + 2 * PI * x * y;
        }
}
static void Main()
{
    double r = 3.0, h = 5.0;
    Shape c = new Circle(r);
    Shape s = new Sphere(r);
    Shape l = new Cylinder(r, h);
    // Display results.
    Console.WriteLine("Area of Circle
    Console.WriteLine("Area of Sphere
= {0:F2}", c.Area());
= {0:F2}", s.Area());
  
      C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
ポリモーフィズム
abstract override new (修飾子)
       Console.WriteLine("Area of Cylinder = {0:F2}", l.Area());
}
}
/*
Output:
Area of Circle
Area of Sphere
Area of Cylinder = 150.80
*/
= 28.27
= 113.10
 
      volatile キーワードは、同時に実行されている複数のスレッドによって、フィールドが変更される可能性があることを示します。 コンパイラ、ランタイム システム、さらにはハードウェアで、パフォーマンスを上げる目的でメモリの場所との読み書きを再整理でき ます。 volatile が宣言されているフィールドはこのような最適化の対象になりません。 volatile 修飾子を追加することで、 すべてのスレッドによって、他のスレッドにより実行される volatile 書き込みがその実行順序どおりに観察されます。 volatile 書 き込みの単一の全体的順序がすべての実行スレッドから認識される保証はありません。
volatile キーワードは次の型のフィールドに使用できます。
参照型。
ポインター型 (unsafe コンテキスト内)。 ポインター自体は volatile にできますが、ポインターが指しているオブジェクトは volatile にできません。 つまり、"volatile を指すポインター" は宣言できません。
sbyte 、 byte 、 short 、 ushort 、 int 、 uint 、 char 、 float 、 bool など、単純型。 基本型が byte 、 sbyte 、 short 、 ushort 、 int 、 uint のいずれかの enum 型。 参照型であることが判明しているジェネリック型パラメーター。
IntPtr および UIntPtr。
double や long など、その他の型には volatile を指定できません。そのような型のフィールドに対する読み書きはアトミッ クになるとは限らないためです。 そのような型のフィールドへのマルチスレッド アクセスを保護するために、Interlocked クラス メン バーを使用するか、 lock ステートメントでアクセスを保護します。
volatile キーワードは class または struct のフィールドにのみ適用できます。 ローカル変数を volatile として宣言す ることはできません。
例
次の例は、publicのフィールド変数を volatile として宣言する方法を示しています。
               class VolatileTest
{
    public volatile int sharedStorage;
    public void Test(int _i)
    {
        sharedStorage = _i;
    }
}
 次の例は、補助スレッドつまりワーカー スレッドを作成および使用して、プライマリ スレッドとの並行処理を実行する方法を示し ています。 マルチスレッドについて詳しくは、「マネージド スレッド処理」をご覧ください。
volatile (C# リファレンス) 2020/11/02 • • Edit Online
 
       volatile 修飾子を の宣言に追加することで、(前述のコードにある抜粋に似た)同じ結果が常に得られま す。しかしながら、この修飾子が メンバーになければ、動作は予測できません。 DoWork メソッドでメンバーアク セスが最適化されることがありますが、古いデータが読み取られます。 マルチスレッド プログラミングの性質上、古い読み取りの数 は予測できません。 プログラムを実行するたびに若干異なる結果が得られます。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
_shouldStop
  _shouldStop
  public class Worker
{
    // This method is called when the thread is started.
    public void DoWork()
    {
        bool work = false;
        while (!_shouldStop)
        {
            work = !work; // simulate some work
        }
        Console.WriteLine("Worker thread: terminating gracefully.");
    }
    public void RequestStop()
    {
        _shouldStop = true;
    }
    // Keyword volatile is used as a hint to the compiler that this data
    // member is accessed by multiple threads.
    private volatile bool _shouldStop;
}
public class WorkerThreadExample
{
    public static void Main()
    {
        // Create the worker thread object. This does not start the thread.
        Worker workerObject = new Worker();
        Thread workerThread = new Thread(workerObject.DoWork);
        // Start the worker thread.
        workerThread.Start();
        Console.WriteLine("Main thread: starting worker thread...");
        // Loop until the worker thread activates.
        while (!workerThread.IsAlive)
;
        // Put the main thread to sleep for 500 milliseconds to
        // allow the worker thread to do some work.
        Thread.Sleep(500);
        // Request that the worker thread stop itself.
        workerObject.RequestStop();
        // Use the Thread.Join method to block the current thread
        // until the object's thread terminates.
        workerThread.Join();
        Console.WriteLine("Main thread: worker thread has terminated.");
    }
    // Sample output:
    // Main thread: starting worker thread...
    // Worker thread: terminating gracefully.
    // Main thread: worker thread has terminated.
}

       関連項目
C# 言語仕様: volatile キーワード C# リファレンス
C# プログラミング ガイド
C# のキーワード
修飾子
lock ステートメント Interlocked

               ステートメントは、プログラムの命令です。 次の表で参照されているトピックで明記されているステートメントを除いて、ステートメ ントは順番に実行されます。 C# ステートメントのキーワードの一覧を次の表に示します。 いずれかのキーワードで表されないス テートメントの詳細については、「ステートメント」を参照してください。
    選択ステートメント 繰り返しステートメント ジャンプ ステートメント 例外処理ステートメント checked と unchecked fixed ステートメント lock ステートメント
関連項目
C# リファレンス ステートメント C# のキーワード
C #
if、else、switch、case do、for、foreach、in、while break、continue、default、goto、return、yield throw、tr y-catch、tr y-finally、tr y-catch-finally checked、unchecked
fixed
lock
                          ステートメントのキーワード (C# リファレンス) 2020/11/02 • • Edit Online
 
    if ステートメントは、ブール式の値に基づいて実行するステートメントを決定します。次の例では、 bool 変数 condition を true に設定してから、 if ステートメントにチェックインします。 出力は The variable is set to true. になります。
     bool condition = true;
if (condition)
{
    Console.WriteLine("The variable is set to true.");
}
else {
    Console.WriteLine("The variable is set to false.");
}
 このトピックの例を実行するには、コンソールアプリケーションの Main メソッドに例を挿入します。 C#の if ステートメントは、次の例に示すように2つの形式を取ります。
    // if-else statement
if (condition)
{
    then-statement;
}
else {
    else-statement;
}
// Next statement in the program.
// if statement without an else
if (condition)
{
    then-statement;
}
// Next statement in the program.
     if-else ステートメントで、 がtrueに評価されると、 then-statement が実行されます。 condition がfalse
の場合は、
が実行されます。 が同時に true と false に評価されることはないため、 ステートメントの と の両方が実行されることは決してありません。
または が実行された後、制御は if ステートメントの後のステートメントに移ります。
condition
    then-statement
else-statement
 else-statement
if-else
   then-statement
else-statement
condition
  else ステートメントが含まれない if ステートメントで condition がtrueに評価された場合は、 then-statement が実行 されます。 condition がfalseの場合、制御は if ステートメントの後のステートメントに移ります。
then-statement と else-statement はどちらも、中かっこ({})で囲まれた1つのステートメントまたは複数のステートメント で構成できます。 ステートメントが 1 つの場合、中かっこは省略可能ですが、使用することが推奨されます。
then-statement および else-statement では、任意の種類のステートメントを使用できます。元の if ステートメント内に 別の if ステートメントを入れ子にすることもできます。 入れ子になった if ステートメントでは、各 else 句が、対応する
if がない最後の else に属します。 次の例では、 と の両方が true に評価されると、 n > 20 が表示 されます。 m > 10 が trueで n > 20 が falseの場合は、 が表示されます。
        Result1
m > 10
   Result2
if-else (C# リファレンス) 2020/11/02 • • Edit Online
 
    代わりに Result2 がfalseの場合に (m > 10) を表示させるには、次の例に示すように、中かっこを使用して入れ子になっ た if の開始と終了を設定することで、その関連付けを指定します。
    // Try with m = 12 and then with m = 8.
if (m > 10)
{
    if (n > 20)
        Console.WriteLine("Result1");
} else {
    Console.WriteLine("Result2");
}
   条件 (m > 10) が false に評価されると、 Result2 が表示されます。 例
次の例では、キーボードから文字を入力すると、プログラムが、入れ子になった if ステートメントを実行して、入力された文字 が英字かどうかを判別します。 入力された文字が英字である場合、プログラムはその文字が小文字と大文字のどちらであるか を判別します。 いずれの場合も、メッセージが表示されます。
   // Try with m = 12 and then with m = 8.
int m = 12;
int n = 18;
if (m > 10)
    if (n > 20)
    {
        Console.WriteLine("Result1");
} else {
        Console.WriteLine("Result2");
    }
 
  例
以下の部分的なコードに示すように、if ステートメントをelseブロック内に入れ子にすることもできます。この例では、2つの elseブロックと1つのthenブロックの中で if ステートメントを入れ子にしています。コメントに、各ブロックでどの条件がtrue または false であるかを示しています。
   Console.Write("Enter a character: ");
char c = (char)Console.Read();
if (Char.IsLetter(c))
{
    if (Char.IsLower(c))
    {
        Console.WriteLine("The character is lowercase.");
    }
else {
        Console.WriteLine("The character is uppercase.");
    }
} else {
    Console.WriteLine("The character isn't an alphabetic character.");
}
//Sample Output:
//Enter a character: 2
//The character isn't an alphabetic character.
//Enter a character: A
//The character is uppercase.
//Enter a character: h
//The character is lowercase.
 
  例
この例では、入力された文字が小文字、大文字、または数値のいずれであるかを判別します。 3 つすべての条件が false の 場合、文字は英数字ではありません。 この例では、いずれの場合もメッセージが表示されます。
   // Change the values of these variables to test the results.
bool Condition1 = true;
bool Condition2 = true;
bool Condition3 = true;
bool Condition4 = true;
if (Condition1)
{
    // Condition1 is true.
}
else if (Condition2)
{
    // Condition1 is false and Condition2 is true.
}
else if (Condition3)
{
    if (Condition4)
    {
        // Condition1 and Condition2 are false. Condition3 and Condition4 are true.
    }
else {
        // Condition1, Condition2, and Condition4 are false. Condition3 is true.
    }
} else {
    // Condition1, Condition2, and Condition3 are false.
}
 
   else ブロックまたは then ブロック内のステートメントを任意の有効なステートメントにできるように、条件には任意の有効なブー ル式を使用できます。 ! 、 && 、 || 、 & 、 | 、 ^ などの論理演算子を使用して複合条件を作成できます。 次のコードに 例を示します。
   Console.Write("Enter a character: ");
char ch = (char)Console.Read();
if (Char.IsUpper(ch))
{
    Console.WriteLine("The character is an uppercase letter.");
}
else if (Char.IsLower(ch))
{
    Console.WriteLine("The character is a lowercase letter.");
}
else if (Char.IsDigit(ch))
{
    Console.WriteLine("The character is a number.");
}
else {
    Console.WriteLine("The character is not alphanumeric.");
}
//Sample Input and Output:
//Enter a character: E
//The character is an uppercase letter.
//Enter a character: e
//The character is a lowercase letter.
//Enter a character: 4
//The character is a number.
//Enter a character: =
//The character is not alphanumeric.
 
          C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
?:演算子
if-else ステートメント (C++) switch
  // NOT
bool result = true;
if (!result)
{
    Console.WriteLine("The condition is true (result is false).");
}
else {
    Console.WriteLine("The condition is false (result is true).");
}
// Short-circuit AND
int m = 9;
int n = 7;
int p = 5;
if (m >= n && m >= p)
{
    Console.WriteLine("Nothing is larger than m.");
}
// AND and NOT
if (m >= n && !(p > m))
{
    Console.WriteLine("Nothing is larger than m.");
}
// Short-circuit OR
if (m > n || m > p)
{
    Console.WriteLine("m isn't the smallest.");
}
// NOT and OR
m = 4;
if (!(m >= n || m >= p))
{
    Console.WriteLine("Now m is the smallest.");
}
// Output:
// The condition is false (result is true).
// Nothing is larger than m.
// Nothing is larger than m.
// m isn't the smallest.
// Now m is the smallest.

       この記事では、switch ステートメントについて説明します。 switch 式(C#8.0で導入)については、式と演算子のセクショ ンの switch 式に関する記事をご覧ください。
switch ステートメントは選択ステートメントです。このステートメントは、実行する1つの"switchセクション"を候補のリストか ら "match 式" によるパターン マッチに基づいて選択します。
      using System;
public class Example
{
   public static void Main()
   {
      int caseSwitch = 1;
      switch (caseSwitch)
      {
          case 1:
              Console.WriteLine("Case 1");
              break;
          case 2:
              Console.WriteLine("Case 2");
              break;
          default:
              Console.WriteLine("Default case");
              break;
} }
}
// The example displays the following output:
//       Case 1
  switch ステートメントは、1つの式が3つ以上の条件に対してテストされる場合に、if-elseコンストラクトの代わりとしてよく使 用されます。 たとえば、次の switch ステートメントは、 Color 型の変数に 3 つの値のいずれかが含まれているかどうかを確 認します。
 switch (C# リファレンス) 2020/11/02 • • Edit Online
 
  これは、 if - else コンストラクトを使用する次の例に相当します。
    using System;
public enum Color { Red, Green, Blue }
public class Example
{
   public static void Main()
   {
      Color c = (Color) (new Random()).Next(0, 3);
      if (c == Color.Red)
         Console.WriteLine("The color is red");
      else if (c == Color.Green)
         Console.WriteLine("The color is green");
      else if (c == Color.Blue)
         Console.WriteLine("The color is blue");
      else
         Console.WriteLine("The color is unknown.");
} }
// The example displays the following output:
//       The color is red
 match 式
match式は、case ラベルのパターンと照合する値を指定します。構文は次のとおりです。
C# 6 以前では、match 式は、次の型の値を返す必要があります。
char。 string。
  switch (expr)
    using System;
public enum Color { Red, Green, Blue }
public class Example
{
   public static void Main()
   {
      Color c = (Color) (new Random()).Next(0, 3);
      switch (c)
      {
         case Color.Red:
            Console.WriteLine("The color is red");
            break;
         case Color.Green:
            Console.WriteLine("The color is green");
            break;
         case Color.Blue:
            Console.WriteLine("The color is blue");
            break;
         default:
            Console.WriteLine("The color is unknown.");
            break;
} }
}
 
  bool。
integral 値。 int や long など。 enum値。
C# 7.0 以降は、match 式は NULL 以外の式にできます。 switch セクション
switch ステートメントには、1つ以上のswitchセクションが含まれています。各switchセクションには、1つ以上の"caseラ ベル" (case ラベルまたは default ラベルのいずれか) と、その後に続く 1 つ以上のステートメントのリストが含まれています。
switch ステートメントでは、任意のswitchセクションに少なくとも1つのdefaultラベルを配置することができます。次の例 に、3 つの switch セクションを持つシンプルな ステートメントを示します。各セクションには 2 つのステートメントがありま す。 2 番目の switch セクションには、 ラベルと case 3: ラベルが含められています。
switch ステートメントには、任意の数のswitchセクションを含めることができます。また、次の例に示すように、各セクションに 1 つ以上の case ラベルを含めることができます。 ただし、複数の case ラベルで同じ式を使用することはできません。
   switch
  case 2:
     using System;
public class Example
{
   public static void Main()
   {
      Random rnd = new Random();
      int caseSwitch = rnd.Next(1,4);
      switch (caseSwitch)
      {
          case 1:
              Console.WriteLine("Case 1");
              break;
          case 2:
          case 3:
              Console.WriteLine($"Case {caseSwitch}");
              break;
          default:
              Console.WriteLine($"An unexpected value ({caseSwitch})");
break; }
} }
// The example displays output like the following:
//       Case 1
 1 つの switch ステートメントでは、1 つの switch セクションのみが実行されます。 C# では 1 つの switch セクションから次のセ クションへ実行が連続することが許可されません。 このため、次のコードでは、コンパイラ エラー CS0163:"コントロールは 1 つの case ラベルから別のラベル (<case label>) へ流れ落ちることはできません。" が生成されます。
    switch (caseSwitch)
{
    // The following switch section causes an error.
    case 1:
        Console.WriteLine("Case 1...");
        // Add a break or other jump statement here.
    case 2:
        Console.WriteLine("... and/or Case 2");
break; }
 この要件は、通常、break ステートメント、goto ステートメント、または return ステートメントを使用して、switch セクションを明

   示的に終了することによって満たされます。 ただし、次のコードも有効です。このコードでは、プログラムの制御が switch セクションにフォール スルー (流れ落ちる、case ラベルを超えてコードを実行することが) できないためです。
    switch (caseSwitch)
{
    case 1:
        Console.WriteLine("Case 1...");
        break;
    case 2:
    case 3:
        Console.WriteLine("... and/or Case 2");
        break;
    case 4:
        while (true)
           Console.WriteLine("Endless looping. . . .");
    default:
        Console.WriteLine("Default value...");
        break;
}
 match 式に一致する case ラベルが含まれた switch セクションにおけるステートメント リストの実行は、ステートメント リストに 沿って最初のステートメントから順に開始され、通常は、 break 、 、 goto label 、 return 、または throw などの ジャンプ ステートメントに達するまで続きます。 この時点で、制御は ステートメントの外側、または他の case ラベルに 移動します。 goto ステートメントを使用する場合は、制御をconstantラベルに転送する必要があります。この制約が必要 になるのは、非 constant ラベルに制御を転送しようとすると望ましくない副作用 (コード内の意図しない場所に制御を転送し てしまったり、無限ループを作成してしまったりなど) が生じる可能性があるためです。
case ラベル
各caseラベルで、match式と比較するためのパターンを指定します(前の例では caseSwitch 変数)。一致すると、最初 の一致 case を含む switch セクションに制御が移ります。 match 式と一致する case ラベル パターンがない場合は、
default caseラベルがあれば、制御はそのラベルを含むセクションに移ります。 default caseがない場合は、どのswitchセ クションのステートメントも実行されず、制御は switch ステートメント外に移ります。
switch ステートメントとパターンマッチングの詳細については、「switch ステートメントによるパターンマッチング」を参照してく ださい。
C# 6 でサポートされるのは定数パターンのみで、定数値の繰り返しは許可されません。このため、case ラベルでは相互に排他 的な値が定義され、match式と一致するのは1つのパターンだけです。そのため、case ステートメントが表示される順序は 重要ではありません。
一方、C# 7.0 では他のパターンがサポートされているため、case ラベルで定義する値が相互に排他的である必要はなく、 match 式と一致するパターンが複数存在する可能性があります。 一致するパターンを含む最初の switch セクションのステート メントのみが実行されるので、ここでは、case ステートメントが表示される順序が重要になってきます。C#によってswitchセク ションが検出され、その switch セクションの case ステートメントが前のステートメントと同じだったり、そのステートメントのサブセッ トだったりすると、コンパイラ エラー CS8120 "switch case は既に以前のケースで処理されています" が生成されます。
次の例は、相互に排他的でない各種パターンを使用する switch ステートメントを示しています。 case 0: switchセクション を移動し、そのセクションが switch ステートメントの最初のセクションでなくなると、C#によってコンパイラエラーが生成されま す。値がゼロの整数は、整数すべてのサブセットであるためです。これは、 case int val ステートメントで定義されているパター ンです。
   goto case
 switch
           default
     using System;
using System.Collections.Generic;
using System.Linq;
public class Example
{
public static void Main()

     public static void Main()
   {
      var values = new List<object>();
      for (int ctr = 0; ctr <= 7; ctr++) {
         if (ctr == 2)
            values.Add(DiceLibrary.Roll2());
         else if (ctr == 4)
            values.Add(DiceLibrary.Pass());
         else
            values.Add(DiceLibrary.Roll());
}
      Console.WriteLine($"The sum of { values.Count } die is { DiceLibrary.DiceSum(values) }");
   }
}
public static class DiceLibrary
{
   // Random number generator to simulate dice rolls.
   static Random rnd = new Random();
   // Roll a single die.
   public static int Roll()
   {
      return rnd.Next(1, 7);
   }
   // Roll two dice.
   public static List<object> Roll2()
   {
      var rolls = new List<object>();
      rolls.Add(Roll());
      rolls.Add(Roll());
      return rolls;
}
   // Calculate the sum of n dice rolls.
   public static int DiceSum(IEnumerable<object> values)
   {
      var sum = 0;
      foreach (var item in values)
      {
            switch (item)
            {
} }
return sum; }
// A single zero value.
case 0:
   break;
// A single value.
case int val:
sum += val;
   break;
// A non-empty collection.
case IEnumerable<object> subList when subList.Any():
   sum += DiceSum(subList);
   break;
// An empty collection.
case IEnumerable<object> subList:
   break;
//  A null reference.
case null:
   break;
// A value that is neither an integer nor a collection.
default:
   throw new InvalidOperationException("unknown item type");
  
      この問題を修正し、コンパイラの警告が表示されないようにするには、次の 2 つのいずれかの方法を使用します。 switch セクションの順序を変更する。
case ラベルでwhen句を使用する。 default case
caseでは、match式がどの case ラベルとも一致しない場合に実行するswitchセクションを指定します。
caseを指定しない場合、match式がどの case ラベルとも一致しないと、プログラムフローが switch ステートメン トにフォール スルーします。
default caseは、switch ステートメントで任意の順序で指定できます。このcaseは、ソースコード内での順序に関係な く、すべての case ラベルが評価された後、最後に評価されます。
switch ステートメントによるパターン マッチング
各 case ステートメントで定義されたパターンがmatch式と一致した場合に、switchセクションが実行されます。定数パター
ンは、すべてのバージョンの C# でサポートされます。 それ以外のパターンは、C# 7.0 以降でサポートされています。 定数パターン
定数パターンでは、match 式が、指定された定数と等しいかどうかがテストされます。 構文は次のとおりです。
ここで constant はテスト対象の値です。 constant には、次のいずれかの定数式を指定できます。
bool リテラル。 true または false 。
任意の integral 定数。 int 、 long 、 byte など。 宣言された const 変数の名前。
列挙定数。
char リテラル。
string リテラル。
定数式は以下のように評価されます。
expr と constant が整数型の場合、式から true が返されるかどうか (つまり、 expr == constant であるかどうか) が
C# の等値演算子によって判定されます。
それ以外の場合、式の値は静的 Object.Equals(expr, constant) メソッドの呼び出しによって判定されます。
次の例では、定数パターンを使用して、特定の日付が、週末か、週の開始日または最終日か、週の途中かを判断します。 つ まり、現在の日付の DateTime.DayOfWeek プロパティを、DayOfWeek 列挙のメンバーと照合します。
  default
  default
      case constant:
        public static object Pass()
   {
      if (rnd.Next(0, 2) == 0)
         return null;
      else
         return new List<object>();
} }
 
  次の例では、定数パターンを使用して、自動コーヒー メーカーをシミュレートするコンソール アプリケーションのユーザー入力を処 理します。
   using System;
class Program
{
    static void Main()
    {
} }
switch (DateTime.Now.DayOfWeek)
{
   case DayOfWeek.Sunday:
   case DayOfWeek.Saturday:
      Console.WriteLine("The weekend");
      break;
   case DayOfWeek.Monday:
      Console.WriteLine("The first day of the work week.");
      break;
   case DayOfWeek.Friday:
      Console.WriteLine("The last day of the work week.");
      break;
   default:
      Console.WriteLine("The middle of the work week.");
break; }
// The example displays output like the following:
//       The middle of the work week.
 
    型パターン
型パターンを使用すると、型の評価と変換を簡潔に記述できます。 switch ステートメントと共に使用してパターンマッチングを 実行すると、指定された型に式を変換できるかどうかがテストされ、変換できる場合は、その型の変数にキャストされます。 構 文は次のとおりです。
ここで type は、expr の結果が変換される型の名前、varname は、一致した場合に expr の結果が変換されるオブジェクトを 表しています。 コンパイル時の型 expr は、C# 7.1 以降では、ジェネリック型パラメーターにすることができます。
以下のいずれかの条件がtrueである場合に case 式は true となります。
expr が type と同じ型のインスタンスである。
expr が type から派生した型のインスタンスである。 つまり、expr の結果を type のインスタンスにアップキャストできる。
expr のコンパイル時の型が type の基底クラスであり、expr の実行時の型が type または type から派生した型である。 変数の "コンパイル時の型" とは、その変数の型宣言で定義されている型です。 変数の "実行時の型" とは、その変数
   case type varname
   using System;
class Example
{
   static void Main()
   {
       Console.WriteLine("Coffee sizes: 1=small 2=medium 3=large");
       Console.Write("Please enter your selection: ");
       string str = Console.ReadLine();
       int cost = 0;
       // Because of the goto statements in cases 2 and 3, the base cost of 25
       // cents is added to the additional cost for the medium and large sizes.
       switch (str)
       {
          case "1":
          case "small":
cost += 25;
              break;
          case "2":
          case "medium":
              cost += 25;
              goto case "1";
          case "3":
          case "large":
              cost += 50;
              goto case "1";
          default:
              Console.WriteLine("Invalid selection. Please select 1, 2, or 3.");
break; }
      if (cost != 0)
      {
          Console.WriteLine("Please insert {0} cents.", cost);
      }
      Console.WriteLine("Thank you for your business.");
   }
}
// The example displays output like the following:
//         Coffee sizes: 1=small 2=medium 3=large
//         Please enter your selection: 2
//         Please insert 50 cents.
//         Thank you for your business.

 に代入されているインスタンスの型です。
expr が、type インターフェイスを実装する型のインスタンスである。
case 式が true の場合は、varname が確実に割り当てられ、switch セクションにのみローカル スコープが含まれます。
null は型と一致しないことに注意してください。 null を一致させるには、次の case ラベルを使用します。
次の例では、型パターンを使用して、さまざまな種類のコレクション型に関する情報を提供します。
  case null:
     using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
class Example
{
    static void Main(string[] args)
    {
        int[] values = { 2, 4, 6, 8, 10 };
        ShowCollectionInformation(values);
        var names = new List<string>();
        names.AddRange(new string[] { "Adam", "Abigail", "Bertrand", "Bridgette" });
        ShowCollectionInformation(names);
        List<int> numbers = null;
        ShowCollectionInformation(numbers);
    }
    private static void ShowCollectionInformation(object coll)
    {
        switch (coll)
        {
} }
case Array arr:
   Console.WriteLine($"An array with {arr.Length} elements.");
   break;
case IEnumerable<int> ieInt:
   Console.WriteLine($"Average: {ieInt.Average(s => s)}");
   break;
case IList list:
   Console.WriteLine($"{list.Count} items");
   break;
case IEnumerable ie:
   string result = "";
   foreach (var e in ie)
      result += $"{e} ";
   Console.WriteLine(result);
   break;
case null:
   // Do nothing for a null.
   break;
default:
   Console.WriteLine($"A instance of type {coll.GetType().Name}");
   break;
}
// The example displays the following output:
//     An array with 5 elements.
// 4 items
 
 次のコードに示すように、   の代わりに、コレクションの型を型パラメーターとして使用して、ジェネリック メソッドを作成する ことができます。
    using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
class Example
{
    static void Main(string[] args)
    {
        int[] values = { 2, 4, 6, 8, 10 };
        ShowCollectionInformation(values);
        var names = new List<string>();
        names.AddRange(new string[] { "Adam", "Abigail", "Bertrand", "Bridgette" });
        ShowCollectionInformation(names);
        List<int> numbers = null;
        ShowCollectionInformation(numbers);
    }
    private static void ShowCollectionInformation<T>(T coll)
    {
        switch (coll)
        {
} }
case Array arr:
   Console.WriteLine($"An array with {arr.Length} elements.");
   break;
case IEnumerable<int> ieInt:
   Console.WriteLine($"Average: {ieInt.Average(s => s)}");
   break;
case IList list:
   Console.WriteLine($"{list.Count} items");
   break;
case IEnumerable ie:
   string result = "";
   foreach (var e in ie)
      result += $"{e} ";
   Console.WriteLine(result);
   break;
case object o:
   Console.WriteLine($"A instance of type {o.GetType().Name}");
   break;
default:
    Console.WriteLine("Null passed to this method.");
    break;
}
// The example displays the following output:
//     An array with 5 elements.
// 4 items
//     Null passed to this method.
 ジェネリックバージョンは、2つの点で最初のサンプルと異なります。まず、null のcaseを使用できません。コンパイラは任意 の型 T を 以外の型に変換できないため、定数のcaseは使用できません。 default のcaseだったものは、null 以外の をテストするようになりました。つまり、default のcaseは null のみをテストします。
パターン マッチングを使用しない場合、このコードは次のように記述できます。 型パターン マッチングを使用することにより、変換 結果が null であるかどうかをテストしたり、キャストを繰り返したりする必要がなくなるため、コードがよりコンパクトで読みやすく なります。
  object
  object
 object
 
      case ステートメントおよび when 句
C#7.0以降では、caseステートメントは相互に排他的である必要がないため、when 句を追加して、caseステートメントを trueに評価するために満たされなければならない条件を指定できます。 when 句には、ブール値を返す任意の式を指定でき ます。
  using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
class Example
{
    static void Main(string[] args)
    {
        int[] values = { 2, 4, 6, 8, 10 };
        ShowCollectionInformation(values);
        var names = new List<string>();
        names.AddRange(new string[] { "Adam", "Abigail", "Bertrand", "Bridgette" });
        ShowCollectionInformation(names);
        List<int> numbers = null;
        ShowCollectionInformation(numbers);
    }
    private static void ShowCollectionInformation(object coll)
    {
        if (coll is Array)
        {
           Array arr = (Array) coll;
           Console.WriteLine($"An array with {arr.Length} elements.");
        }
        else if (coll is IEnumerable<int>)
        {
            IEnumerable<int> ieInt = (IEnumerable<int>) coll;
            Console.WriteLine($"Average: {ieInt.Average(s => s)}");
        }
        else if (coll is IList)
        {
            IList list = (IList) coll;
            Console.WriteLine($"{list.Count} items");
        }
        else if (coll is IEnumerable)
        {
            IEnumerable ie = (IEnumerable) coll;
            string result = "";
            foreach (var e in ie)
               result += $"{e} ";
            Console.WriteLine(result);
        }
        else if (coll == null)
        {
            // Do nothing.
        }
else {
            Console.WriteLine($"An instance of type {coll.GetType().Name}");
        }
} }
// The example displays the following output:
//     An array with 5 elements.
// 4 items

     次の例では、 Shape 基底クラス、 Shape から派生する   クラス、および を定義しています。ここでは when 句を使用して、同じ長さと幅が割り当てられている ブジェクトとしてインスタンス化されていなくても、 ShowShapeInfo によって確実に
このメソッドは、 null オブジェクトの情報や、面積がゼロの図形の情報を表示しようとしません。
Rectangle
から派生する   クラス オブジェクトが、   オ
として処理されるようにしています。
Rectangle
Square
      Rectangle
Square
     Square
     using System;
public abstract class Shape
{
   public abstract double Area { get; }
   public abstract double Circumference { get; }
}
public class Rectangle : Shape
{
   public Rectangle(double length, double width)
   {
      Length = length;
      Width = width;
   }
   public double Length { get; set; }
   public double Width { get; set; }
   public override double Area
   {
      get { return Math.Round(Length * Width,2); }
   }
   public override double Circumference
   {
      get { return (Length + Width) * 2; }
   }
}
public class Square : Rectangle
{
   public Square(double side) : base(side, side)
   {
Side = side; }
   public double Side { get; set; }
}
public class Circle : Shape
{
   public Circle(double radius)
   {
      Radius = radius;
   }
   public double Radius { get; set; }
   public override double Circumference
   {
      get { return 2 * Math.PI * Radius; }
   }
   public override double Area
   {
      get { return Math.PI * Math.Pow(Radius, 2); }
   }
}
public class Example
{

{
    この例で、 Shape オブジェクトが null かどうかをテストしようとする when 句は実行されません。 null をテストするための正 しい型パターンは case null: です。
     public static void Main()
   {
      Shape sh = null;
      Shape[] shapes = { new Square(10), new Rectangle(5, 7),
                         sh, new Square(0), new Rectangle(8, 8),
                         new Circle(3) };
      foreach (var shape in shapes)
         ShowShapeInfo(shape);
}
   private static void ShowShapeInfo(Shape sh)
   {
switch (sh) {
         // Note that this code never evaluates to true.
         case Shape shape when shape == null:
            Console.WriteLine($"An uninitialized shape (shape == null)");
            break;
         case null:
            Console.WriteLine($"An uninitialized shape");
            break;
         case Shape shape when sh.Area == 0:
            Console.WriteLine($"The shape: {sh.GetType().Name} with no dimensions");
            break;
         case Square sq when sh.Area > 0:
            Console.WriteLine("Information about square:");
            Console.WriteLine($"   Length of a side: {sq.Side}");
            Console.WriteLine($"   Area: {sq.Area}");
            break;
         case Rectangle r when r.Length == r.Width && r.Area > 0:
            Console.WriteLine("Information about square rectangle:");
            Console.WriteLine($"   Length of a side: {r.Length}");
            Console.WriteLine($"   Area: {r.Area}");
            break;
         case Rectangle r when sh.Area > 0:
            Console.WriteLine("Information about rectangle:");
            Console.WriteLine($"   Dimensions: {r.Length} x {r.Width}");
            Console.WriteLine($"   Area: {r.Area}");
            break;
         case Shape shape when sh != null:
            Console.WriteLine($"A {sh.GetType().Name} shape");
            break;
         default:
            Console.WriteLine($"The {nameof(sh)} variable does not represent a Shape.");
            break;
} }
}
// The example displays the following output:
//
//
//
//
//
//
//
//
//
//
//
//
Information about square:
   Length of a side: 10
   Area: 100
Information about rectangle:
   Dimensions: 5 x 7
   Area: 35
An uninitialized shape
The shape: Square with no dimensions
Information about square rectangle:
   Length of a side: 8
   Area: 64
A Circle shape

       C# 言語仕様
詳細については、C# 言語仕様に関するページの「switch ステートメント」を参照してください。 言語仕様は、C# の構文と使
用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
if-else
パターン一致

          do ステートメントでは、指定されたブール式が true と評価される間、ステートメントまたはステートメントブロックが実行されま す。ループの各実行の後に式が評価されるため、do-while ループは1回以上実行されます。whileループは、これとは異な り、0 回以上実行されます。
do ステートメントブロック内の任意の位置で、breakステートメントを使用してループを抜けることができます。
continue ステートメントを使用すると、 while 式の評価に直接ステップ実行できます。 式の評価が true の場合、ループの 最初のステートメントから実行が続行されます。 それ以外の場合、実行は、ループの後の最初のステートメントから続行されま す。
また、goto、return、throwステートメントのいずれかを使って do-while ループを終了することもできます。 例
do ステートメントの使用方法を次の例に示します。[実行]を選択して、コード例を実行します。その後に、コードを変更し、 もう一度実行することができます。
C# 言語仕様
詳細については、「C# 言語仕様」の do ステートメントに関するセクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
while ステートメント
      int n = 0; do
{
    Console.WriteLine(n);
    n++;
} while (n < 5);
 do (C# リファレンス) 2020/11/02 • • Edit Online
 
      for ステートメントでは、指定されたブール式が true と評価される間、ステートメントまたはステートメントブロックが実行され ます。
for ステートメントブロック内の任意の位置で、breakステートメントを使ってループから抜けることができます。また は、continue ステートメントを使って、ループ内の次の繰り返しにスキップできます。 また、goto、return、throw ステートメント のいずれかを使って for ループを終了することもできます。
for ステートメントの構造
for ステートメントには、initializer、condition、iteratorのセクションが定義されています。
3 つのセクションはすべて省略可能です。 ループの本体は、ステートメントまたはステートメントのブロックのいずれかです。 次の例では、 for ステートメントと定義されているすべてのセクションが示されています。
initializer セクション
initializer セクション内のステートメントは、ループに入る前に 1 回だけ実行されます。 initializer セクションは、次のいずれかで
す。
ローカル ループ変数の宣言と初期化。ループの外からアクセスすることはできません。 次に列挙した 0 個以上のステートメント式 (コンマ区切り)。
代入ステートメント
メソッドの呼び出し
前置または後置のインクリメント式 ( ++i 、 i++ など) 前置または後置のデクリメント式 ( --i 、 i-- など) new 演算子を使用したオブジェクト作成
await 式
上記の例のinitializerセクションは、ローカルループ変数 i を宣言して初期化します。
condition セクション
condition セクション (ある場合) は、ブール式にする必要があります。 その式はループの反復の前に毎回評価されます。
     for (initializer; condition; iterator)
    body
     for (int i = 0; i < 5; i++)
{
    Console.WriteLine(i);
}
   int i = 0
 for (C# リファレンス) 2020/11/02 • • Edit Online
 
     conditionセクションが存在しないか、ブール式が true に評価される場合、次のループの反復が実行されます。そうでない場 合は、ループが終了します。
上記の例のcondition セクションでは、ローカル ループ変数の値に基づいて、ループが終了するかどうかを決定します。
iterator セクション
ループ本体の反復処理が終わるたびに実行される処理を iterator セクションで定義します。 iterator セクションには、次のス
テートメント式を 0 個以上、コンマで区切って記述します。 代入ステートメント
メソッドの呼び出し
前置または後置のインクリメント式 ( ++i 、 i++ など) 前置または後置のデクリメント式 ( --i 、 i-- など) new 演算子を使用したオブジェクト作成
await 式
上記の例の iterator セクションでは、ローカルのループ変数をインクリメントします。
使用例
次の例は、for ステートメントセクションのやや特殊な使用例です。initializerセクションで外部ループ変数に値を代入 し、initializer セクションと iterator セクションの両方でメソッドを呼び出しています。さらに、iterator セクションで 2 つの変数の 値を変更しています。 [実行] を選択して、コード例を実行します。 その後に、コードを変更し、もう一度実行することができま す。
次の例では、無限 for ループが定義されます。
C# 言語仕様
詳細については、「C# 言語仕様」の for ステートメントに関するセクションを参照してください。
  i<5
   i++
     int i;
int j = 10;
for (i = 0, Console.WriteLine($"Start: i={i}, j={j}"); i < j; i++, j--, Console.WriteLine($"Step: i={i}, j=
{j}"))
{
    // Body of the loop.
}
     for ( ; ; ) {
    // Body of the loop.
}
 関連項目

     C# リファレンス
C# プログラミング ガイド C# のキーワード foreach、in

          foreach ステートメントは、次の例のように、System.Collections.IEnumerableまたは System.Collections.Generic.IEnumerable<T> インターフェイスを実装している型のインスタンス内の要素ごとに、ステートメン トまたはステートメントのブロックを実行します。
  foreach ステートメントは、これらの型に制限されません。これは次の条件を満たす任意の型のインスタンスと共に使用できま す。
戻り値の型がクラス、構造体、インターフェイス型のいずれかである、パラメーターなしのパブリックメソッド GetEnumerator が ある型。C#9.0以降では、GetEnumerator メソッドを型の拡張メソッドにすることができます。
GetEnumerator メソッドの戻り値の型に、パブリックプロパティ Current と、戻り値の型がBooleanであるパラメーターなし のパブリックメソッド MoveNext がある。
次の例では、何のインターフェイスも実装していないSystem.Span<T>型のインスタンスを使用して、foreach ステートメント を使用します。
        C# 7.3 以降、列挙子の Current プロパティによって、参照戻り値 ( ref T 。この場合、 T はコレクション要素の型です) が 返される場合、次の例のように、 ref または ref readonly 修飾子を使用して繰り返し変数を宣言することができます。
 foreach、in (C# リファレンス) 2020/11/02 • • Edit Online
    var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
int count = 0;
foreach (int element in fibNumbers)
{
    Console.WriteLine($"Element #{count}: {element}");
count++; }
Console.WriteLine($"Number of elements: {count}");
    public class IterateSpanExample
{
    public static void Main()
    {
        Span<int> numbers = new int[] { 3, 14, 15, 92, 6 };
        foreach (int number in numbers)
        {
            Console.Write($"{number} ");
        }
        Console.WriteLine();
    }
}
 
           C# 8.0 以降、 await foreach ステートメントを使用して、データの非同期ストリーム、つまり、IAsyncEnumerable<T> イン ターフェイスを実装するコレクション型を使用できます。 次の要素が非同期で取得されている限り、ループの各反復は中断され る可能性があります。 await foreach ステートメントを使用する方法の例を次に示します。
既定では、ストリーム要素はキャプチャされたコンテキストで処理されます。 コンテキストのキャプチャを無効にする場合 は、TaskAsyncEnumerableExtensions.ConfigureAwait 拡張メソッドを使用します。 同期コンテキストおよび現在のコンテキ ストのキャプチャについての詳細は、「タスク ベースの非同期パターンの利用」を参照してください。 非同期ストリームの詳細につ いては、「C# 8.0 の新機能」の記事の「非同期ストリーム」セクションを参照してください。
foreach ステートメントブロック内の任意の位置で、breakステートメントを使ってループから抜けることができます。また は、continue ステートメントを使って、ループ内の次の繰り返しにスキップできます。 また、goto、return、throw ステートメント のいずれかを使って foreach ループを終了することもできます。
foreach ステートメントを null に適用した場合、NullReferenceExceptionがスローされます。 foreach ステートメントの ソース コレクションが空の場合、 foreach ループの本体は実行されず、スキップされます。
繰り返し変数の型
次のコードに示すように、 var キーワードを使用して、コンパイラによって foreach ステートメントで繰り返し変数の型が推論 されるようにすることができます。
次のコードに示すように、繰り返し変数の型を明示的に指定することもできます。
前の形式では、コレクション要素の型 T は、繰り返し変数の型 V に暗黙的または明示的に変換できる必要があります。 T から V への明示的な変換が実行時に失敗した場合、foreach ステートメントからInvalidCastExceptionがスローされ
ます。 たとえば、 T が非シール クラス型の場合、 V は任意のインターフェイス型にすることができ、 T で実装されないものにす
              public class ForeachRefExample
{
    public static void Main()
    {
        Span<int> storage = stackalloc int[10];
        int num = 0;
        foreach (ref int item in storage)
        {
            item = num++;
        }
        foreach (ref readonly var item in storage)
        {
            Console.Write($"{item} ");
        }
// Output:
        // 0 1 2 3 4 5 6 7 8 9
    }
}
    await foreach (var item in GenerateSequenceAsync())
{
    Console.WriteLine(item);
}
  foreach (var item in collection) { }
    IEnumerable<T> collection = new T[5];
foreach (V item in collection) { }
 
          ることもできます。実行時に、コレクション要素の型は T から派生したものである可能性があり、実際には V を実装します。 そうでない場合は、InvalidCastException がスローされます。
C# 言語仕様
詳細については、「C# 言語仕様」の foreach ステートメントに関するセクションを参照してください。
C# 8.0 以降に追加された機能の詳細については、機能の提案に関する次の記述を参照してください。
非同期ストリーム (C# 8.0)
foreach ループに対する拡張機能 GetEnumerator のサポート(C#9.0)
関連項目
C# リファレンス
C# キーワード
配列での foreach の使用 for ステートメント
  
          while ステートメントでは、指定されたブール式が true と評価される間に、ステートメントまたはステートメントブロックが実行 されます。ループの各実行の前に式が評価されるため、while ループは0回以上実行されます。doループは、これとは異な り、1 回以上実行されます。
while ステートメントブロック内の任意の位置で、breakステートメントを使用してループを抜けることができます。
continue ステートメントを使用すると、 while 式の評価に直接ステップ実行できます。 式の評価が true の場合、ループの 最初のステートメントから実行が続行されます。 それ以外の場合、実行は、ループの後の最初のステートメントから続行されま す。
また、goto、return、throwステートメントのいずれかを使って while ループを終了することもできます。 例
while ステートメントの使用方法を次の例に示します。[実行]を選択して、コード例を実行します。その後に、コードを変更 し、もう一度実行することができます。
C# 言語仕様
詳細については、「C# 言語仕様」の while ステートメントに関するセクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
do ステートメント
    int n = 0;
while (n < 5)
{
    Console.WriteLine(n);
n++; }
 while (C# リファレンス) 2020/11/02 • • Edit Online
 
   break ステートメントは、これを囲むループまたはswitchステートメントのうち、最も内側のものを終了させます。終了したス テートメントの次にステートメントがある場合は、そこに制御が移動します。
例
次の例では、条件付きステートメントに1から100までをカウントするカウンターがあります。ただし、break ステートメントによっ
て、ループは 4 回で終了します。
    class BreakTest
{
    static void Main()
    {
        for (int i = 1; i <= 100; i++)
        {
if (i == 5) {
break; }
            Console.WriteLine(i);
        }
        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
/* Output:
1 2 3 4
*/
} }
 例
次に示すのは、switchステートメントで break を使用する例です。
break (C# リファレンス) 2020/11/02 • • Edit Online
 
  4 を入力すると、出力は次のようになります。
例
この例では、 break ステートメントを使用して、入れ子になった内側のループから抜け出し、外側のループに制御を戻します。 コントロールは、入れ子になったループの 1 つ上のレベルに_のみ_返されます。
    Enter your selection (1, 2, or 3): 4
Sorry, invalid selection.
    class Switch
{
    static void Main()
    {
        Console.Write("Enter your selection (1, 2, or 3): ");
        string s = Console.ReadLine();
        int n = Int32.Parse(s);
switch (n) {
            case 1:
                Console.WriteLine("Current value is 1");
                break;
            case 2:
                Console.WriteLine("Current value is 2");
                break;
            case 3:
                Console.WriteLine("Current value is 3");
                break;
            default:
                Console.WriteLine("Sorry, invalid selection.");
                break;
}
        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
} }
/*
Sample Input: 1
Sample Output:
Enter your selection (1, 2, or 3): 1
Current value is 1
*/
 
    例
この例で、 break ステートメントは、ループの各繰り返し時に現在の分岐を抜けるためだけに使用されています。 ループ自体 は、入れ子になったswitchステートメントに属する break のインスタンスの影響は受けません。
  class BreakInNestedLoops
{
    static void Main(string[] args)
    {
} }
int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
char[] letters = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' };
// Outer loop.
for (int i = 0; i < numbers.Length; i++)
{
    Console.WriteLine($"num = {numbers[i]}");
    // Inner loop.
    for (int j = 0; j < letters.Length; j++)
    {
if (j == i) {
            // Return control to outer loop.
break; }
        Console.Write($" {letters[j]} ");
    }
    Console.WriteLine();
}
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/*
* Output:
num = 0
num = 1 a
num = 2 ab
num = 3 abc
num = 4 abcd
num = 5 abcde
num = 6 abcdef
num = 7 abcdefg
num = 8 abcdefgh
num = 9 abcdefghi
*/

      C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード switch
   class BreakFromSwitchInsideLoop
{
    static void Main(string[] args)
    {
        // loop 1 to 3
        for (int i = 1; i <= 3; i++)
        {
switch(i) {
} }
} }
case 1:
    Console.WriteLine("Current value is 1");
    break;
case 2:
    Console.WriteLine("Current value is 2");
    break;
case 3:
    Console.WriteLine("Current value is 3");
    break;
default:
    Console.WriteLine("This shouldn't happen.");
    break;
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/*
* Output:
    Current value is 1
    Current value is 2
    Current value is 3
*/
 
          continue ステートメントは、それを囲んでいるwhile、do、for、またはforeachステートメントの次の反復処理にコントロール を渡します。
例
この例では、1 から 10 までカウントするようカウンターが初期化されます。 continue ステートメントと式 (i < 9) を組み合わ せて使用すると、 for 本文の continue から終わりまでのステートメントが、 i が 9 未満のイテレーションではスキップされま す。 for ループの最後の2つのイテレーション(i==9とi==10)では、continue ステートメントは実行されず、i の値が コンソールに出力されます。
        class ContinueTest
{
    static void Main()
    {
        for (int i = 1; i <= 10; i++)
        {
if (i < 9) {
continue; }
            Console.WriteLine(i);
        }
        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
/*
Output:
9
10
*/
} }
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
break ステートメント
continue (C# リファレンス) 2020/11/02 • • Edit Online
 
   goto ステートメントは、プログラムの制御をラベル付きステートメントに直接移します。
goto の一般的な用途は、特定のswitch-caseラベルまたは switch ステートメントの既定のラベルに、制御を移動すること
です。
goto ステートメントは、深い入れ子のループから抜ける場合にも便利です。
例
次の例では、switchステートメントでの goto の使い方を示します。
     class SwitchTest
{
    static void Main()
    {
} }
Console.WriteLine("Coffee sizes: 1=Small 2=Medium 3=Large");
Console.Write("Please enter your selection: ");
string s = Console.ReadLine();
int n = int.Parse(s);
int cost = 0;
switch (n)
{
    case 1:
        cost += 25;
        break;
    case 2:
cost += 25;
        goto case 1;
    case 3:
cost += 50;
        goto case 1;
    default:
        Console.WriteLine("Invalid selection.");
break; }
if (cost != 0)
{
    Console.WriteLine($"Please insert {cost} cents.");
}
Console.WriteLine("Thank you for your business.");
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/*
Sample Input:  2
Sample Output:
Coffee sizes: 1=Small 2=Medium 3=Large
Please enter your selection: 2
Please insert 50 cents.
Thank you for your business.
*/
 goto (C# リファレンス) 2020/11/02 • • Edit Online
 
  例
次の例では、 goto を使って入れ子になったループから抜け出す方法を示します。
    public class GotoTest1
{
    static void Main()
    {
        int x = 200, y = 4;
        int count = 0;
        string[,] array = new string[x, y];
        // Initialize the array.
        for (int i = 0; i < x; i++)
            for (int j = 0; j < y; j++)
                array[i, j] = (++count).ToString();
        // Read input.
        Console.Write("Enter the number to search for: ");
        // Input a string.
        string myNumber = Console.ReadLine();
        // Search.
        for (int i = 0; i < x; i++)
        {
            for (int j = 0; j < y; j++)
            {
} }
if (array[i, j].Equals(myNumber))
{
goto Found; }
        Console.WriteLine($"The number {myNumber} was not found.");
        goto Finish;
    Found:
        Console.WriteLine($"The number {myNumber} is found.");
    Finish:
        Console.WriteLine("End of search.");
        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
} }
/*
Sample Input: 44
Sample Output
Enter the number to search for: 44
The number 44 is found.
End of search.
*/
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。

     関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
goto ステートメント (C++)

         return ステートメントは、メソッドの実行を終了し、呼び出し側のメソッドに制御を戻します。省略可能な値を返すこともでき ます。 メソッドが void 型の場合、 return ステートメントは省略できます。
return ステートメントが try ブロック内にある場合は、制御が呼び出し側のメソッドに返される前に、 finally ブロック (存在 する場合) が実行されます。
例
次の例では、メソッド CalculateArea() がローカル変数 area を double 値として返します。
        class ReturnTest
{
    static double CalculateArea(int r)
    {
        double area = r * r * Math.PI;
        return area;
    }
    static void Main()
    {
} }
int radius = 5;
double result = CalculateArea(radius);
Console.WriteLine("The area is {0:0.00}", result);
// Keep the console open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
// Output: The area is 78.54
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード return ステートメント
return (C# リファレンス) 2020/11/02 • • Edit Online
 
     プログラムの実行中に例外が発生したことを通知します。 注釈
throw の構文は次のとおりです。
ここで e は System.Exception から派生したクラスのインスタンスです。 次の例では、 GetNumber という名前のメソッドに渡さ れた引数が内部配列の有効なインデックスに対応していない場合に、 throw ステートメントを使用して IndexOutOfRangeException をスローします。
  throw [e];
      using System;
public class NumberGenerator
{
   int[] numbers = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };
   public int GetNumber(int index)
   {
      if (index < 0 || index >= numbers.Length) {
         throw new IndexOutOfRangeException();
}
      return numbers[index];
   }
}
   その後、メソッドの呼び出し元が ブロックまたは try-catch-finally ブロックを使用して、スローされた例外を処理 します。 次の例では、 メソッドによってスローされた例外を処理します。
try-catch
 GetNumber
    using System;
public class Example
{
   public static void Main()
   {
      var gen = new NumberGenerator();
      int index = 10;
      try {
          int value = gen.GetNumber(index);
          Console.WriteLine($"Retrieved {value}");
      }
      catch (IndexOutOfRangeException e)
      {
         Console.WriteLine($"{e.GetType().Name}: {index} is outside the bounds of the array");
      }
} }
// The example displays the following output:
//        IndexOutOfRangeException: 10 is outside the bounds of the array
 throw (C# リファレンス) 2020/11/02 • • Edit Online
 
     例外を再スローする
throw を catch ブロックで使用すると、 catch ブロックで処理された例外を再スローすることもできます。 この場合、 throw は例外オペランドを使用しません。 これは、メソッドが呼び出し元から他のライブラリ メソッドに引数を渡し、そのライブラリ メソッ ドが、呼び出し元に渡す必要がある例外をスローするときに最も役立ちます。 たとえば、次の例では、初期化されていない文 字列の最初の文字を取得しようとしたときにスローされた NullReferenceException を再スローします。
    using System;
public class Sentence
{
   public Sentence(string s)
   {
Value = s; }
   public string Value { get; set; }
   public char GetFirstCharacter()
   {
      try {
         return Value[0];
        }
      catch (NullReferenceException e) {
throw; }
} }
public class Example
{
   public static void Main()
   {
      var s = new Sentence(null);
      Console.WriteLine($"The first character is {s.GetFirstCharacter()}");
   }
}
// The example displays the following output:
//    Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an
object.
//       at Sentence.GetFirstCharacter()
//       at Example.Main()
     IMPORTANT
catch ブロックで throw e 構文を使用すると、呼び出し元に渡す新しい例外をインスタンス化することもできます。 この場 合、StackTrace プロパティから使用できる、元の例外のスタック トレースが保持されません。
   throw 式
C#7.0以降、throw は、式およびステートメントとして使用できます。これにより、以前サポートされていなかったコンテキストで
の例外のスローが可能になります。 次の設定があります。
条件演算子。 次の例では、 throw 式を使用して、メソッドに空の文字列配列が渡された場合に ArgumentExceptionをスローします。C#7.0より前では、このロジックが if/else ステートメントで使用されている 必要があります。

           Null合体演算子。次の例では、null合体演算子と共に throw 式を使用して、Name プロパティに割り当てられた 文字列が null の場合に例外をスローします。
式形式のラムダまたはメソッド。 次の例では、DateTime 値への変換がサポートされていないため InvalidCastException をスローする、式形式のメソッドを示しています。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド try-catch
C# のキーワード
方法: 例外を明示的にスローする
    public string Name
{
    get => name;
    set => name = value ??
}
throw new ArgumentNullException(paramName: nameof(value), message: "Name cannot be null");
     DateTime ToDateTime(IFormatProvider provider) =>
         throw new InvalidCastException("Conversion to a DateTime is not supported.");
    private static void DisplayFirstNumber(string[] args)
{
   string arg = args.Length >= 1 ? args[0] :
                              throw new ArgumentException("You must supply an argument");
   if (Int64.TryParse(arg, out var number))
      Console.WriteLine($"You entered {number:F0}");
   else
      Console.WriteLine($"{arg} is not a number.");
}
 
      try-catchステートメントは、try ブロックと、それに続く1つ以上の catch 句で構成されます。この句にはさまざまな例外の ハンドラーを指定します。
例外がスローされると、共通言語ランタイム(CLR)によって、この例外を処理する catch ステートメントが検索されます。現在 実行されているメソッドにそのような catch ブロックが含まれていない場合、CLRは現在のメソッドを呼び出したメソッドを検索 し、呼び出し履歴の上位を検索していきます。 catch ブロックが見つからない場合、CLRはハンドルされていない例外のメッ セージをユーザーに表示し、プログラムの実行を停止します。
try ブロックには、例外を発生させる可能性がある保護されたコードが含まれます。このブロックは、例外がスローされるか、ブ ロックが正常に終了するまで実行されます。たとえば、次の例では null オブジェクトをキャストしようとする と、NullReferenceException 例外が発生します。
catch 句は、引数なしで使用してすべての種類の例外をキャッチできますが、この使用方法はお勧めできません。通常は、 回復方法が判明している例外のみキャッチします。 したがって、System.Exception から派生したオブジェクト引数を必ず指定 します。以下に例を示します。
同一のtry-catchステートメントで、特定の catch 句を複数回使用することもできます。この場合、catch 句は順序どおり にチェックされるため、 catch 句の順序が重要になります。 例外は、特殊性の高い順にキャッチしてください。 後のブロックに到 達しないような順序で catch ブロックを並べた場合、コンパイラでエラーが発生します。
処理対象の例外をフィルター処理する方法の1つに、catch 引数の使用があります。また、例外フィルターを使用して例外を 確認し、それを処理するかどうかを決定することもできます。 例外フィルターが false を返す場合、ハンドラーの検索が続行され ます。
スタックはフィルターの影響を受けないため、キャッチと再スロー (以下で説明します) には例外フィルターが適しています。 後のハ ンドラーでスタックをダンプすると、再スローされた最後の場所だけではなく、例外が最初に発生した場所がわかります。 例外の フィルター式の一般的な用途の 1 つにログの記録があります。 常に false を返しログも出力するフィルターを作成すれば、処理 や再スローの必要なしにそのままの状態で例外をログに記録することができます。
catch ステートメントでキャッチされた例外を再びスローするには、catch ブロックでthrowステートメントを使用できます。次 の例では、IOException 例外からソース情報を抽出した後、親メソッドに例外をスローします。
    object o2 = null;
try
{
    int i2 = (int)o2;   // Error
}
     catch (InvalidCastException e)
{
}
     catch (ArgumentException e) when (e.ParamName == "...")
{
}
 try-catch (C# リファレンス) 2020/11/02 • • Edit Online
 
  例外をキャッチして、別の例外をスローできます。 これを行うには、次の例に示すように、キャッチする例外を内部例外として指 定します。
次の例に示すように、指定した条件が true の場合に例外を再スローすることもできます。
    catch (InvalidCastException e)
{
    // Perform some action here, and then throw a new exception.
    throw new YourCustomException("Put your error message here.", e);
}
     catch (InvalidCastException e)
{
    if (e.Data == null)
    {
throw; }
else {
        // Take some action.
    }
}
     NOTE
また、例外フィルターを使用すると、多くの場合、よりクリーンな方法で同様の結果を得ることができます (このドキュメントで前述したような、 スタックの変更もありません)。 次の例では、呼び出し元に対して前の例と同様の動作をします。 この関数は、 e.Data が null の場合 に、 InvalidCastException を呼び出し元にスローして戻します。
      catch (InvalidCastException e) when (e.Data != null) {
// Take some action. }
  try ブロック内では、そのブロックで宣言されている変数のみを初期化します。そうしないと、ブロックの実行が完了する前に例 外が発生する可能性があります。 たとえば、次のコードでは、変数 n が try ブロック内で初期化されています。 この変数を
try ブロックの外側にある Write(n) ステートメントで使おうとすると、コンパイラエラーが発生します。
    catch (FileNotFoundException e)
{
    // FileNotFoundExceptions are handled here.
}
catch (IOException e)
{
    // Extract some information from this exception, and then
    // throw it to the parent method.
    if (e.Source != null)
        Console.WriteLine("IOException source: {0}", e.Source);
    throw;
}
 
        catch の詳細については、「try-catch-finally」を参照してください。 非同期メソッドの例外
非同期メソッドは async 修飾子でマークされ、通常は 1 つ以上の await 式またはステートメントが含まれます。 await 式で は、await 演算子が Task または Task<TResult> に適用されます。
コントロールが非同期メソッドの await に到達すると、メソッドの進行状況は、待機中のタスクが完了するまで中断されます。 タスクが完了すると、メソッドで実行を再開できます。 詳細については、Async および Await を使用した非同期プログラミングに 関するページをご覧ください。
await が適用される完了したタスクは、タスクを返すメソッドでハンドルされない例外が発生したことが原因で、違反状態にな る場合があります。 タスクを待機すると例外がスローされます。 タスクを返す非同期処理が取り消された場合に、取り消された 状態でタスクを終了することもできます。 キャンセルされたタスクを待機していると、 OperationCanceledException がスローされ ます。
例外をキャッチするには、 try ブロックでタスクを待機し、関連付けられている catch ブロックで例外をキャッチします。 例につ いては、async メソッドの例に関するセクションを参照してください。
待機中の非同期メソッドで複数の例外が発生したことが原因で、タスクが違反状態になることがあります。 たとえば、タスクは Task.WhenAll の呼び出しの結果になることがあります。 このようなタスクを待機すると、1 つの例外のみがキャッチされます。ど の例外がキャッチされるかは予測できません。 例については、Task.WhenAll の例に関するセクションを参照してください。
例
例外が発生する可能性がある ProcessString メソッドへの呼び出しを含む try ブロックの例を次に示します。 catch 句に は、メッセージを画面に表示するだけの例外ハンドラーがあります。 throw ステートメントが の内側から呼び 出されると、システムによって catch ステートメントが検索され、メッセージ が表示されます。
   ProcessString
 Exception caught
   static void Main()
{
int n; try
{
        // Do not initialize this variable here.
n = 123; }
    catch
    {
    }
    // Error: Use of unassigned local variable 'n'.
    Console.Write(n);
}
 
  2 つの catch ブロックの例
次の例では、2 種類の catch ブロックが使用され、特殊性が最も高い最初の例外がキャッチされます。
特殊性が最も低い例外をキャッチするには、 ProcessString の throw ステートメントを throw new Exception() と置き換え ることができます。
この例で特殊性が最も低い catch ブロックを最初に配置すると、"
A previous catch clause already catches all exceptions of this or a super type ('System.Exception') " というエ
ラー メッセージが表示されます。
        class TryFinallyTest
{
    static void ProcessString(string s)
    {
        if (s == null)
        {
            throw new ArgumentNullException();
        }
}
    static void Main()
    {
        string s = null; // For demonstration purposes.
try {
            ProcessString(s);
        }
        catch (Exception e)
        {
            Console.WriteLine("{0} Exception caught.", e);
        }
} }
/*
Output:
System.ArgumentNullException: Value cannot be null.
   at TryFinallyTest.Main() Exception caught.
 * */
 
  非同期メソッドの例
次の例では、非同期メソッドの例外処理を示します。 非同期タスクからスローされる例外をキャッチするには、 try ブロックに
await 式を配置し、 catch ブロックで例外をキャッチします。
例外処理を示すために、この例の 行のコメントを解除します。タスクの IsFaulted プロパティが
True に設定され、タスクの プロパティが例外に設定され、例外が catch ブロックでキャッチされ
ます。
行のコメントを解除して、非同期処理を取り消したときに何が起こるかを示します。 タスクの プロパティが true に設定され、例外が catch ブロックでキャッチされます。 この例に該当しない一部の
条件では、タスクの プロパティが true に設定され、 IsCanceled が false に設定されます。
  throw new Exception
 Exception.InnerException
 throw new OperationCanceledException
 IsCanceled
  IsFaulted
   class ThrowTest3
{
    static void ProcessString(string s)
    {
        if (s == null)
        {
            throw new ArgumentNullException();
        }
}
    static void Main()
    {
try {
            ProcessString(s);
        }
        // Most specific:
        catch (ArgumentNullException e)
        {
            Console.WriteLine("{0} First exception caught.", e);
        }
        // Least specific:
        catch (Exception e)
        {
            Console.WriteLine("{0} Second exception caught.", e);
        }
} }
string s = null;
/*
 Output:
 System.ArgumentNullException: Value cannot be null.
 at Test.ThrowTest3.ProcessString(String s) ... First exception caught.
*/
 
      Task.WhenAll の例
次の例では、複数のタスクで複数の例外が発生する可能性がある例外処理について説明します。 try ブロックは Task.WhenAll の呼び出しで返されるタスクを待機します。 WhenAll が適用される 3 つのタスクが完了すると、このタスクは完 了します。
3つのタスクでそれぞれ例外が発生します。 catch ブロックは例外を反復処理します。この例外は、Task.WhenAllで返され たタスクの Exception.InnerExceptions プロパティで見つかります。
   public async Task DoSomethingAsync()
{
    Task<string> theTask = DelayAsync();
try {
        Debug.WriteLine("Result: " + result);
    }
    catch (Exception ex)
    {
        Debug.WriteLine("Exception Message: " + ex.Message);
    }
    Debug.WriteLine("Task IsCanceled: " + theTask.IsCanceled);
    Debug.WriteLine("Task IsFaulted:  " + theTask.IsFaulted);
    if (theTask.Exception != null)
    {
} }
string result = await theTask;
Debug.WriteLine("Task Exception Message: "
    + theTask.Exception.Message);
Debug.WriteLine("Task Inner Exception Message: "
    + theTask.Exception.InnerException.Message);
private async Task<string> DelayAsync()
{
    await Task.Delay(100);
    // Uncomment each of the following lines to
    // demonstrate exception handling.
    //throw new OperationCanceledException("canceled");
    //throw new Exception("Something happened.");
    return "Done";
}
// Output when no exception is thrown in the awaited method:
//   Result: Done
//   Task IsCanceled: False
//   Task IsFaulted:  False
// Output when an Exception is thrown in the awaited method:
//   Exception Message: Something happened.
//   Task IsCanceled: False
//   Task IsFaulted:  True
//   Task Exception Message: One or more errors occurred.
//   Task Inner Exception Message: Something happened.
// Output when a OperationCanceledException or TaskCanceledException
// is thrown in the awaited method:
//   Exception Message: canceled
//   Task IsCanceled: True
//   Task IsFaulted:  False

          C# 言語仕様
詳細については、「C# 言語仕様」の「try ステートメント」セクションを参照してください。
参照
C# リファレンス
C# プログラミングガイド
C# のキーワード
try、throw、catch ステートメント (C++) throw
try-finally
方法: 例外を明示的にスローする
   public async Task DoMultipleAsync()
{
    Task theTask1 = ExcAsync(info: "First Task");
    Task theTask2 = ExcAsync(info: "Second Task");
    Task theTask3 = ExcAsync(info: "Third Task");
    Task allTasks = Task.WhenAll(theTask1, theTask2, theTask3);
try {
        await allTasks;
    }
    catch (Exception ex)
    {
} }
Debug.WriteLine("Exception: " + ex.Message);
Debug.WriteLine("Task IsFaulted: " + allTasks.IsFaulted);
foreach (var inEx in allTasks.Exception.InnerExceptions)
{
    Debug.WriteLine("Task Inner Exception: " + inEx.Message);
}
private async Task ExcAsync(string info)
{
    await Task.Delay(100);
    throw new Exception("Error-" + info);
}
// Output:
//   Exception: Error-First Task
//   Task IsFaulted: True
//   Task Inner Exception: Error-First Task
//   Task Inner Exception: Error-Second Task
//   Task Inner Exception: Error-Third Task
 
     finally ブロックを使用すると、try ブロックで割り当てられたリソースをクリーンアップし、 try ブロックで例外が発生してもコー ドを実行することができます。 通常、制御が ステートメントを離れると、 try ブロックのステートメントが実行されま す。 制御の移動は、 break ステートメント、 ステートメント、 goto ステートメント、 return またはステートメントの 正常な実行の結果や、 try ステートメントで生じた例外の反映の結果として生じます。
ハンドルされている例外では、関連する finally ブロックの実行が保証されます。ただし、例外がハンドルされていない場 合、 finally ブロックの実行は、例外のアンワインド操作のトリガー方法に依存します。 つまり、コンピューターの設定に依存 するということでもあります。 finally 句が実行されないのは、プログラムが直ちに停止している場合のみです。これの例は、IL ステートメントが壊れているために InvalidProgramException がスローされる場合です。 ほとんどのオペレーティング システムで は、プロセスの停止とアンロードの一環として、リソースの適切なクリーンアップが行われます。
 finally
  continue
    通常、ハンドルされていない例外によってアプリケーションが終了した場合、
ありません。 ただし、このような状況でも実行する必要のあるステートメントが
ステートメントに catch ブロックを追加するという方法があります。 または、 try -
ローされた例外があれば、コール スタックの上の方でキャッチすることもできます。 つまり、 try - finally ステートメントが含まれ ているメソッドを呼び出すメソッド内でも、そのメソッドを呼び出すメソッド内でも、コール スタック内の任意のメソッド内でも、例外 をキャッチできるということです。 例外がキャッチされない場合、 finally ブロックの実行は、例外のアンワインド操作がオペレー ティング システムによってトリガーされるかどうかに依存します。
例
次の例では、無効な変換ステートメントによって System.InvalidCastException 例外が発生しています。この例外はハンド ルされていません。
finally
ブロックが実行されるかどうかは重要では ブロックにある場合は、 try - finally ステートメントの try ブロックでス
  finally
 finally
   try-finally (C# リファレンス) 2021/03/06 • • Edit Online
 
   次の例では、コールスタックのずっと上の方のメソッド内で TryCast メソッドからの例外がキャッチされます。
   public class ThrowTestA
{
    static void Main()
    {
        int i = 123;
        string s = "Some string";
        object obj = s;
try {
            Console.WriteLine("WriteLine at the end of the try block.");
        }
finally {
} }
// Invalid conversion; obj contains a string, not a numeric type.
i = (int)obj;
// The following statement is not run.
// To run the program in Visual Studio, type CTRL+F5. Then
// click Cancel in the error dialog.
Console.WriteLine("\nExecution of the finally block after an unhandled\n" +
    "error depends on how the exception unwind operation is triggered.");
Console.WriteLine("i = {0}", i);
    // Output:
    // Unhandled Exception: System.InvalidCastException: Specified cast is not valid.
    //
    // Execution of the finally block after an unhandled
    // error depends on how the exception unwind operation is triggered.
    // i = 123
}
 
            finally の詳細については、「try-catch-finally」を参照してください。
C# には、IDisposable オブジェクトに対して同様の機能を便利な構文で提供する using ステートメントも含まれています。
C# 言語仕様
詳細については、「C# 言語仕様」の「try ステートメント」セクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド
  public class ThrowTestB
{
    static void Main()
    {
try {
TryCast(); }
        catch (Exception ex)
        {
} }
// TryCast produces an unhandled exception.
// Catch the exception that is unhandled in TryCast.
Console.WriteLine
    ("Catching the {0} exception triggers the finally block.",
    ex.GetType());
// Restore the original unhandled exception. You might not
// know what exception to expect, or how to handle it, so pass
// it on.
throw;
    public static void TryCast()
    {
        int i = 123;
        string s = "Some string";
        object obj = s;
try {
            Console.WriteLine("WriteLine at the end of the try block.");
        }
finally {
            // Report that the finally block is run, and show that the value of
            // i has not been changed.
            Console.WriteLine("\nIn the finally block in TryCast, i = {0}.\n", i);
} }
    // Output:
    // In the finally block in TryCast, i = 123.
    // Catching the System.InvalidCastException exception triggers the finally block.
    // Unhandled Exception: System.InvalidCastException: Specified cast is not valid.
}
// Invalid conversion; obj contains a string, not a numeric type.
i = (int)obj;
// The following statement is not run.

     C# のキーワード
try、throw、catch ステートメント (C++) throw
try-catch
方法: 例外を明示的にスローする

               通常、 catch および は、 try ブロックのリソースを取得して使用する場合に、対で記述されます。 catch ブロック で例外的な状況を処理し、 ブロックでリソースを解放します。
例外の再スローの使用例を含む詳細については、「try-catch」および例外のスローに関するページをご覧ください。 finally ブロックの詳細については、「try-finally」を参照してください。
例
finally
 finally
     public class EHClass
{
    void ReadFile(int index)
    {
        // To run this code, substitute a valid path from your local machine
        string path = @"c:\users\public\test.txt";
        System.IO.StreamReader file = new System.IO.StreamReader(path);
        char[] buffer = new char[10];
try {
            file.ReadBlock(buffer, index, buffer.Length);
        }
        catch (System.IO.IOException e)
        {
            Console.WriteLine("Error reading from {0}. Message = {1}", path, e.Message);
        }
finally {
            if (file != null)
            {
                file.Close();
            }
}
        // Do something with buffer...
    }
}
 C# 言語仕様
詳細については、「C# 言語仕様」の「try ステートメント」セクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
try、throw、catch ステートメント (C++) throw
方法: 例外を明示的にスローする
using ステートメント
try-catch-finally (C# リファレンス) 2020/11/02 • • Edit Online
 
          C# のステートメントは、checked または unchecked のいずれかのコンテキストで実行できます。 checked コンテキストでは、算 術オーバーフローにより例外が発生します。 unchecked コンテキストでは、算術オーバーフローが無視され、結果の格納先の 型に収まらない上位ビットが破棄されて、結果が切り詰められます。
checked: checked コンテキストを指定します。
unchecked: unchecked コンテキストを指定します。 オーバーフロー チェックにより、次の操作が影響を受けます。
整数型で次の定義済み演算子を使用する式: ++、--、(単項) -、+、-、*、/
整数型間か、 float または double から整数型へのの明示的な数値変換。
checked と unchecked のいずれも指定されない場合、非定数式(実行時に評価される式)の既定のコンテキストが- checked コンパイラ オプションの値によって定義されます。 既定では、そのオプションの値の設定が解除され、算術演算が unchecked コンテキストで実行されます。
定数式 (コンパイル時に完全に評価される式) の場合、既定のコンテキストは常に確認されます。 定数式が unchecked コン テキストに明示的に配置されていない限り、式のコンパイル時の評価中に発生するオーバーフローによってコンパイル時エラーが 発生します。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード ステートメントのキーワード
   Checked と Unchecked (C# リファレンス) 2020/11/02 • • Edit Online
 
     checked キーワードは、整数型の算術演算と変換に対してオーバーフローチェックを明示的に有効にするために使用します。
既定では、定数値のみを含む式がチェック先の型の範囲外にある値を生成した場合、コンパイラ エラーが発生します。 式が 1 つ以上の非定数値を含む場合、コンパイラはオーバーフローを検出しません。次の例で i2 に割り当てられた式を評価して も、コンパイラ エラーは発生しません。
    // The following example causes compiler error CS0220 because 2147483647
// is the maximum value for integers.
//int i1 = 2147483647 + 10;
// The following example, which includes variable ten, does not cause
// a compiler error.
int ten = 10;
int i2 = 2147483647 + ten;
// By default, the overflow in the previous statement also does
// not cause a run-time exception. The following line displays
// -2,147,483,639 as the sum of 2,147,483,647 and 10.
Console.WriteLine(i2);
 既定では、これらの非定数式のオーバーフローは実行時にもチェックされず、オーバーフロー例外も発生しません。 前の例で は、2 つの正の整数の合計として -2,147,483,639 が表示されます。
オーバーフローチェックを有効にするには、コンパイラオプション、環境設定、または checked キーワードを使用します。 checked 式または checked ブロックを使用して、前の合計によって生じたオーバーフローを実行時に検出する方法を次の例
に示します。 どちらの例でもオーバーフロー例外が発生します。
       // If the previous sum is attempted in a checked environment, an
// OverflowException error is raised.
// Checked expression.
Console.WriteLine(checked(2147483647 + ten));
// Checked block.
checked
{
    int i3 = 2147483647 + ten;
    Console.WriteLine(i3);
}
 unchecked キーワードを使用してオーバーフロー チェックを行わないようにすることもできます。
例
この例では、 checked を使用して実行時のオーバーフロー チェックを有効にする方法を示します。
 checked (C# リファレンス) 2020/11/02 • • Edit Online
 
     C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
  class OverFlowTest
{
    // Set maxIntValue to the maximum value for integers.
    static int maxIntValue = 2147483647;
    // Using a checked expression.
    static int CheckedMethod()
    {
int z = 0; try
{
            // The following line raises an exception because it is checked.
            z = checked(maxIntValue + 10);
        }
        catch (System.OverflowException e)
        {
            // The following line displays information about the error.
            Console.WriteLine("CHECKED and CAUGHT:  " + e.ToString());
        }
        // The value of z is still 0.
return z; }
    // Using an unchecked expression.
    static int UncheckedMethod()
    {
int z = 0; try
{
            // The following calculation is unchecked and will not
            // raise an exception.
            z = maxIntValue + 10;
        }
        catch (System.OverflowException e)
        {
            // The following line will not be executed.
            Console.WriteLine("UNCHECKED and CAUGHT:  " + e.ToString());
        }
        // Because of the undetected overflow, the sum of 2147483647 + 10 is
        // returned as -2147483639.
        return z;
}
    static void Main()
    {
        Console.WriteLine("\nCHECKED output value is: {0}",
                          CheckedMethod());
        Console.WriteLine("UNCHECKED output value is: {0}",
                          UncheckedMethod());
}
    /*
   Output:
   CHECKED and CAUGHT:  System.OverflowException: Arithmetic operation resulted
   in an overflow.
      at ConsoleApplication1.OverFlowTest.CheckedMethod()
   CHECKED output value is: 0
   UNCHECKED output value is: -2147483639
 */
}

      関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード Checked と Unchecked unchecked

     unchecked キーワードは、整数型の算術演算と変換に対してオーバーフローチェックを抑制するために使用します。
unchecked コンテキストでは、式が変換先の型の範囲外の値を生成した場合に、オーバーフローが検出されません。 たとえ ば、次の例では、unchecked ブロックまたは式で計算が行われるため、結果がintegerに対して大きすぎるという事実が無視 され、 int1 には-2,147,483,639 の値が割り当てられます。
unchecked 環境が削除されると、コンパイルエラーが発生します。式のすべての用語が定数なので、コンパイル時にはオー バーフローを検出できます。
非定数の用語を含む式は、実行時およびコンパイル時に既定ではチェックされません。 checked 環境を有効にする方法につ いては、「checked」をご覧ください。
オーバーフローのチェックには時間がかかるため、オーバーフローの危険性がない状況では、unchecked コードを使用すること で、パフォーマンスを改善できる可能性があります。 ただし、オーバーフローの可能性がある場合は、checked 環境を使用して ください。
例
この例では、 unchecked キーワードの使用方法を示します。
     unchecked {
    int1 = 2147483647 + 10;
}
int1 = unchecked(ConstantMax + 10);
   unchecked (C# リファレンス) 2020/11/02 • • Edit Online
 
     C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
  class UncheckedDemo
{
    static void Main(string[] args)
    {
        // int.MaxValue is 2,147,483,647.
        const int ConstantMax = int.MaxValue;
        int int1;
        int int2;
        int variableMax = 2147483647;
        // The following statements are checked by default at compile time. They do not
        // compile.
        //int1 = 2147483647 + 10;
        //int1 = ConstantMax + 10;
        // To enable the assignments to int1 to compile and run, place them inside
        // an unchecked block or expression. The following statements compile and
        // run.
        unchecked
        {
            int1 = 2147483647 + 10;
        }
        int1 = unchecked(ConstantMax + 10);
        // The sum of 2,147,483,647 and 10 is displayed as -2,147,483,639.
        Console.WriteLine(int1);
        // The following statement is unchecked by default at compile time and run
        // time because the expression contains the variable variableMax. It causes
        // overflow but the overflow is not detected. The statement compiles and runs.
        int2 = variableMax + 10;
        // Again, the sum of 2,147,483,647 and 10 is displayed as -2,147,483,639.
        Console.WriteLine(int2);
        // To catch the overflow in the assignment to int2 at run time, put the
        // declaration in a checked block or expression. The following
        // statements compile but raise an overflow exception at run time.
        checked
        {
            //int2 = variableMax + 10;
        }
        //int2 = checked(variableMax + 10);
        // Unchecked sections frequently are used to break out of a checked
        // environment in order to improve performance in a portion of code
        // that is not expected to raise overflow exceptions.
        checked
        {
            // Code that might cause overflow should be executed in a checked
            // environment.
            unchecked
            {
                // This section is appropriate for code that you are confident
                // will not result in overflow, and for which performance is
                // a priority.
}
            // Additional checked code here.
        }
} }

      す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード Checked と Unchecked checked

    fixed ステートメントは、移動可能な変数がガベージコレクターにより再配置されることを防ぎます。 fixed ステートメント は、unsafeコンテキストでのみ許可されます。 fixed キーワードは、固定サイズバッファーの作成にも使うことができます。
fixed ステートメントは、マネージド変数へのポインターを設定し、ステートメントの実行中にその変数を"固定"します。移動 可能なマネージド変数へのポインターは、 fixed コンテキストでのみ有効です。 fixed コンテキストがない場合、ガベージ コレ クションによって変数が予期せず再配置される可能性があります。C#コンパイラでは、fixed ステートメントでマネージド変数 へのポインターを割り当てることだけができます。
    class Point {
public int x;
    public int y;
}
unsafe private static void ModifyFixedStorage()
{
    // Variable pt is a managed variable, subject to garbage collection.
    Point pt = new Point();
    // Using fixed allows the address of pt members to be taken,
    // and "pins" pt so that it is not relocated.
    fixed (int* p = &pt.x)
    {
*p = 1; }
}
 配列、文字列、固定サイズ バッファー、または変数のアドレスを使って、ポインターを初期化できます。 次の例では、変数のア ドレス、配列、および文字列の使い方を示します。
    Point point = new Point();
double[] arr = { 0, 1.5, 2.3, 3.4, 4.0, 5.9 };
string str = "Hello World";
// The following two assignments are equivalent. Each assigns the address
// of the first element in array arr to pointer p.
// You can initialize a pointer by using an array.
fixed (double* p = arr) { /*...*/ }
// You can initialize a pointer by using the address of a variable.
fixed (double* p = &arr[0]) { /*...*/ }
// The following assignment initializes p by using a string.
fixed (char* p = str) { /*...*/ }
// The following assignment is not valid, because str[0] is a char,
// which is a value, not a variable.
//fixed (char* p = &str[0]) { /*...*/ }
 C#7.3以降では、fixed ステートメントは、配列、文字列、固定サイズバッファー、アンマネージド型変数以外の型でも動作 します。 GetPinnableReference という名前のメソッドを実装する型はピン留めできます。 GetPinnableReference は ref
  fixed ステートメント (C# リファレンス) 2020/11/02 • • Edit Online
 
     変数をアンマネージド型にして返す必要があります。 .NET Core 2.0 で導入された .NET 型 System.Span<T> と System.ReadOnlySpan<T> はこのパターンを活用し、ピン留めできます。 以下の例を参照してください。
    unsafe private static void FixedSpanExample()
{
    int[] PascalsTriangle = {
                  1,
                1,  1,
              1,  2,  1,
            1,  3,  3,  1,
          1,  4,  6,  4,  1,
1, 5, 10,10,5, 1 };
    Span<int> RowFive = new Span<int>(PascalsTriangle, 10, 5);
    fixed (int* ptrToRow = RowFive)
    {
        // Sum the numbers 1,4,6,4,1
        var sum = 0;
        for (int i = 0; i < RowFive.Length; i++)
        {
            sum += *(ptrToRow + i);
        }
        Console.WriteLine(sum);
    }
}
 このパターンに参加する必要のある型を作成する場合は、パターンの実装の例について、 「Span<T>.GetPinnableReference()」を参照してください。
複数のポインターは、すべて同じ型の場合、1 つのステートメントで初期化できます。
異なる型のポインターを初期化するには、次の例で示すように、 fixed ステートメントを入れ子にします。
ステートメント内のコードの実行が済むと、固定された変数は固定を解除されて、ガベージ コレクションの対象になります。 その ため、 fixed ステートメントの外側ではこれらの変数を参照しないでください。 fixed ステートメントで宣言された変数は、そ のステートメントにスコープされるので、この処理が簡単になります。
fixed ステートメントで初期化されたポインターは読み取り専用変数です。ポインター値を変更するには、2つ目のポインター 変数を宣言し、それを変更する必要があります。 fixed ステートメントで宣言された変数は変更できません。
  fixed (byte* ps = srcarray, pd = dstarray) {...}
     fixed (int* p1 = &point.x)
{
    fixed (double* p2 = &arr[5])
    {
        // Do something with p1 and p2.
    }
}
     fixed (byte* ps = srcarray, pd = dstarray)
{
... }
// ps and pd are no longer in scope here.
 
          スタックにメモリを割り当てることができ、スタックはガベージ コレクションの対象にならないので、固定する必要はありません。 これ を行うには、 stackalloc 式を使用します。
C# 言語仕様
詳細については、「C# 言語仕様」の fixed ステートメントに関するセクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード unsafe
ポインター型 固定サイズ バッファー
    fixed (byte* ps = srcarray, pd = dstarray)
{
    byte* pSourceCopy = ps;
    pSourceCopy++; // point to the next element.
    ps++; // invalid: cannot modify ps, as it is declared in the fixed statement.
}
 
     lock ステートメントは、指定のオブジェクトに対する相互排他ロックを取得し、ステートメントブロックを実行してからロックを解 放します。 ロックが保持されている間、ロックを保持するスレッドではロックを再度取得し、解放することができます。 他のスレッド はブロックされてロックを取得できず、ロックが解放されるまで待機します。
lock ステートメントの形式は次のようになります。
x は参照型の式です。これは次にまったく等しくなります。
    lock (x) {
    // Your code...
}
     object __lockObj = x;
bool __lockWasTaken = false;
try
{
    System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);
    // Your code...
}
finally {
    if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
}
 このコードではtry...finallyブロックが使用されているため、lock ステートメントの本文内で例外がスローされた場合でもロック は解放されます。
lock ステートメントの本文でawait演算子を使用することはできません。 ガイドライン
共有リソースへのスレッド アクセスを同期する場合、専用オブジェクト インスタンス (
private readonly object balanceLock = new object(); など) またはコードの関連のない部分によってロック オブジェクトとし
て使用される可能性がない別のインスタンスをロックします。 異なる共有リソースに対して同じロック オブジェクト インスタンスを 使用することは避けてください。デッドロックやロックの競合が発生する可能性があります。 特に、以下をロック オブジェクトとして 使用しないでください。
this 。ロックとして呼び出し元に使用される可能性があります。
Type インスタンス。typeof 演算子またはリフレクションによって取得される可能性があります。 文字列リテラルを含む文字列インスタンス。インターン処理される可能性があります。
ロックの競合を減らすために、できるだけ短い時間ロックを保持します。 例
次の例では、専用 balanceLock インスタンスをロックすることでそのプライベート balance フィールドへのアクセスを同期する Account クラスが定義されます。ロッキングに同じインスタンスを使用すると、2つのスレッドが Debit または Credit メソッド
を同時に呼び出すことによって balance フィールドを同時に更新することができなくなります。
      lock ステートメント (C# リファレンス) 2020/11/02 • • Edit Online
 
   using System;
using System.Threading.Tasks;
public class Account
{
    private readonly object balanceLock = new object();
    private decimal balance;
    public Account(decimal initialBalance) => balance = initialBalance;
    public decimal Debit(decimal amount)
    {
        if (amount < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "The debit amount cannot be negative.");
        }
        decimal appliedAmount = 0;
        lock (balanceLock)
        {
            if (balance >= amount)
            {
                balance -= amount;
                appliedAmount = amount;
            }
}
        return appliedAmount;
    }
    public void Credit(decimal amount)
    {
        if (amount < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "The credit amount cannot be negative.");
        }
        lock (balanceLock)
        {
            balance += amount;
        }
}
    public decimal GetBalance()
    {
} }
lock (balanceLock)
{
    return balance;
}
class AccountTest
{
    static async Task Main()
    {
        var account = new Account(1000);
        var tasks = new Task[100];
        for (int i = 0; i < tasks.Length; i++)
        {
            tasks[i] = Task.Run(() => Update(account));
        }
        await Task.WhenAll(tasks);
        Console.WriteLine($"Account's balance is {account.GetBalance()}");
        // Output:
        // Account's balance is 2000
    }
    static void Update(Account account)
  
        static void Update(Account account)
 C# 言語仕様
詳細については、「C# 言語仕様」の lock ステートメントに関するセクションを参照してください。
関連項目
C# リファレンス
C# キーワード System.Threading.Monitor System.Threading.SpinLock System.Threading.Interlocked 同期プリミティブの概要
   {
    decimal[] amounts = { 0, 2, -3, 6, -2, -1, 8, -5, 11, -6 };
    foreach (var amount in amounts)
    {
        if (amount >= 0)
        {
            account.Credit(amount);
        }
else {
            account.Debit(Math.Abs(amount));
        }
} }
}
 
       in、ref または out のないメソッドで宣言されたパラメーターは、呼び出されたメソッドに値で渡されます。 メソッドでその値を変更 できますが、呼び出し元のプロシージャに制御が渡されるときに、変更された値は保持されません。 メソッド パラメーターのキー ワードを使用して、この動作を変更できます。
ここでは、メソッドのパラメーターを宣言するときに使用できるキーワードについて説明します。 params は、このパラメーターが異なる数の引数を取得する可能性があることを指定します。
in は、このパラメーターが参照によって渡されますが、呼び出されたメソッドでは読み取りのみが行われることを指定しま す。
ref は、このパラメーターが参照によって渡され、呼び出されたメソッドでは読み取りまたは書き込みが行われる可能性が あることを指定します。
out は、このパラメーターが参照によって渡され、呼び出されたメソッドでは書き込みが行われることを指定します。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
メソッドのパラメーター (C# リファレンス) 2020/11/02 • • Edit Online
 
      params キーワードを使用すると、可変数個の引数を受け取るメソッドパラメーターを指定できます。パラメーターの型は1次 元配列でなければなりません。
1つのメソッド宣言内では、params キーワード以後にパラメーターを追加できないため、1つの params キーワードだけを使用 できます。
params パラメーターの宣言された型が1次元配列でない場合は、コンパイラエラーCS0225が発生します。 params パラメーターを使用してメソッドを呼び出す場合は、以下を渡すことができます。
配列要素の型の引数のコンマ区切りのリスト。 指定した型の引数の配列。
引数なし。 引数を渡さない場合、 params リストの長さはゼロになります。
例
次の例に示すように、さまざまな方法で params パラメーターに引数を渡すことができます。
      params (C# リファレンス) 2020/11/02 • • Edit Online
 
     C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
  public class MyClass
{
    public static void UseParams(params int[] list)
    {
        for (int i = 0; i < list.Length; i++)
        {
            Console.Write(list[i] + " ");
        }
        Console.WriteLine();
    }
    public static void UseParams2(params object[] list)
    {
        for (int i = 0; i < list.Length; i++)
        {
            Console.Write(list[i] + " ");
        }
        Console.WriteLine();
    }
    static void Main()
    {
        // You can send a comma-separated list of arguments of the
        // specified type.
        UseParams(1, 2, 3, 4);
        UseParams2(1, 'a', "test");
        // A params parameter accepts zero or more arguments.
        // The following calling statement displays only a blank line.
        UseParams2();
        // An array argument can be passed, as long as the array
        // type matches the parameter type of the method being called.
        int[] myIntArray = { 5, 6, 7, 8, 9 };
        UseParams(myIntArray);
        object[] myObjArray = { 2, 'b', "test", "again" };
        UseParams2(myObjArray);
        // The following call causes a compiler error because the object
        // array cannot be converted into an integer array.
        //UseParams(myObjArray);
        // The following call does not cause an error, but the entire
        // integer array becomes the first element of the params array.
        UseParams2(myIntArray);
/* Output:
1234 1 a test
56789
2 b test again System.Int32[]
*/
} }

     C# リファレンス
C# プログラミング ガイド C# のキーワード メソッド パラメーター

    in キーワードを指定すると、引数が参照渡しされますが、引数が変更されることはありません。仮パラメーターを引数(変数 にする必要があります) の別名にします。 つまり、パラメーターに対するすべての操作は引数に対して行われます。 これは、ref またはoutキーワードと似ています。ただし、呼び出されたメソッドで in 引数を変更することはできません。 ref 引数には変 更が許される一方で、 out 引数の場合、呼び出されたメソッドによって変更される必要があります。そのような変更は、呼び出 し元のコンテキストで観察できます。
    int readonlyArgument = 44;
InArgExample(readonlyArgument);
Console.WriteLine(readonlyArgument);     // value is still 44
void InArgExample(in int number)
{
    // Uncomment the following line to see error CS8331
    //number = 19;
}
 前の例は、通常、 in 修飾子が呼び出しサイトでは不要であることを示しています。 これはメソッド宣言でのみ必要です。
in 引数として渡される変数は、メソッド呼び出しで渡される前に初期化する必要があります。ただし、呼び出されたメソッドで は値の割り当てや、引数の変更を行うことはできません。
in パラメーター修飾子はC#7.2以降で使用可能です。以前のバージョンでは、コンパイラエラー CS8107 ("Feature 'readonly references' is not available in C# 7.0. Please use language version 7.2 or greater." ('読み取り専用参照' 機能は C# 7.0 では使用できません。7.2 以上の言語バージョンを使用してください)) が生成されました。コンパイラ言語のバー ジョンを構成するには、「C# 言語のバージョンの選択」をご覧ください。
in 、 ref 、および out キーワードは、オーバーロード解決のためのメソッド シグネチャの一部とは見なされません。 したがっ て、唯一の違いが、1つのメソッドは ref または in 引数を受け取り、もう一方のメソッドは out 引数を受け取ることである 場合、メソッドはオーバーロードできません。 たとえば、次のコードはコンパイルされません。
in の有無に基づくオーバーロードが可能です。
    NOTE
foreach ステートメントの一部、または LINQ クエリの join 句の一部として、型パラメーターが反変であることを示すために in キー ワードをジェネリック型パラメーターで使用することもできます。 これらのコンテキストでの in キーワードの使用の詳細については、これらすべ ての使用に関するリンクを提供する「in」を参照してください。
       class CS0663_Example
{
    // Compiler error CS0663: "Cannot define overloaded
    // methods that differ only on in, ref and out".
    public void SampleMethod(in int i) { }
    public void SampleMethod(ref int i) { }
}
 in パラメーター修飾子 (C# リファレンス) 2021/03/16 • • Edit Online
 
  オーバーロードの解決ルール
in 引数の意図を理解して、値と in 引数の比較によって、メソッドに対するオーバーロードの解決ルールを理解できます。
in パラメーターを使用してメソッドを定義すると、パフォーマンスを最適化できる可能性があります。一部の struct 型引数 は、サイズが大きくなる可能性があり、メソッドが短いループまたは重要なコード パスで呼び出される場合、その構造のコピーのコ ストが重要になります。呼び出されたメソッドは引数の状態を変更しないため、メソッドで in パラメーターを宣言して、参照で 安全に渡すことができる引数を指定します。 参照によりこれらの引数を渡して、(可能性がある) 高額なコピーを回避します。
呼び出しサイトで引数に in を指定することは、通常は省略可能です。値で引数を渡す場合と in 修飾子を使用して参 照で渡す場合の間に、セマンティックの相違点はありません。 引数の値が変更される可能性があることを示す必要はないた め、呼び出しサイトの in 修飾子は省略可能です。呼び出しサイトで in 修飾子を明示的に追加して、引数が値ではな く、参照で渡されるようにします。明示的に in を使用すると、次の2つの効果があります。
1つ目は、呼び出しサイトで in を指定すると、一致する in パラメーターで定義されたメソッドがコンパイラで強制的に選択 されます。それ以外の場合は、2つのメソッドで in の有無のみが異なるときは、値によるオーバーロードの方が適しています。
2 つ目は、 in を指定して、参照で引数を渡す意図を宣言します。 in で使用される引数では、直接参照できる場所を表 す必要があります。 out および ref 引数と同じ一般ルールが適用されます。定数、通常のプロパティ、または値を生成する その他の式を使用することはできません。それ以外の場合は、呼び出しサイトで in を省略すると、メソッドに読み取り専用の 参照で渡すために、一時変数の作成を許可することが、コンパイラに通知されます。 コンパイラでは、一時変数を作成して、
in 引数でのいくつかの制限に対処します。
一時変数では、 in パラメーターとしてコンパイル時の定数を許可します。 一時変数では、プロパティ、または in パラメーターのその他の式を許可します。 一時変数では、引数型からパラメーターの型への暗黙の変換がある引数を許可します。
先のすべてのインスタンスで、コンパイラは定数、プロパティ、またはその他の式の値を格納する一時変数を作成します。 これらのルールが発生するコード例を次に示します。
     static void Method(in int argument)
{
    // implementation removed
}
Method(5); // OK, temporary variable created.
Method(5L); // CS1503: no implicit conversion from long to int
short s = 0;
Method(s); // OK, temporary int created with the value 0
Method(in s); // CS1503: cannot convert from in short to in int
int i = 42;
Method(i); // passed by readonly reference
Method(in i); // passed by readonly reference, explicitly using `in`
 ここでは、値の引数で使用する別のメソッドが使用できたと想定します。 次のコードに示すように、結果が変更されます。
   class InOverloads
{
    public void SampleMethod(in int i) { }
    public void SampleMethod(int i) { }
}
 
     引数が参照で渡されるメソッドの呼び出しは、最後のメソッドのみです。
in パラメーターの制限
次の種類のメソッドには、 in 、 ref 、 out キーワードを使用することはできません。
async 修飾子を使用して定義した Async メソッド。
yieldreturnまたは yield break ステートメントを含むIteratorメソッド。 拡張メソッドの最初の引数では、その引数が構造体でない限り、 in 修飾子を使用することはできません。 拡張メソッドの 1 番目の引数がジェネリック型である場合 (その型が構造体として制約されている場合でも)。
in 修飾子、それと ref および out との違いについては、安全で効率的なコードの記述に関する記事で説明されていま す。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
    NOTE
先のコードでは、わかりやすくするために int を引数型として使用します。 int は最新のマシンの参照より大きくなることはないため、読 み取り専用の参照として単一の int を渡すメリットはありません。
     static void Method(int argument)
{
    // implementation removed
}
static void Method(in int argument)
{
    // implementation removed
}
Method(5); // Calls overload passed by value
Method(5L); // CS1503: no implicit conversion from long to int
short s = 0;
Method(s); // Calls overload passed by value.
Method(in s); // CS1503: cannot convert from in short to in int
int i = 42;
Method(i); // Calls overload passed by value
Method(in i); // passed by readonly reference, explicitly using `in`
 
        ref キーワードは、参照渡しで渡される値を示します。このキーワードは、4つの異なるコンテキストで使用されます。
メソッド シグネチャとメソッドの呼び出しで、参照によってメソッドに引数を渡します。 詳細については、「参照渡しで引数を 渡す」を参照してください。
メソッド シグネチャで、参照渡しで呼び出し元に値を返します。 詳細については、参照戻り値に関するページを参照してく ださい。 メンバーの本文で、参照戻り値が、呼び出し元によって変更される参照としてローカルに格納されること、または、通常は ローカル変数が参照渡しによって別の値にアクセスすることを示します。 詳細については、「ref ローカル変数」を参照してく ださい。
struct の宣言で、 ref struct または readonly ref struct を宣言します。 詳細については、「構造体型」の記事の 「 ref 構造体」セクションを参照してください。
参照渡しで引数を渡す
メソッドのパラメーター リストで使用した場合、 ref キーワードは、引数を値ではなく、参照によって渡すことを示します。 ref キーワードは、仮パラメーターを引数 (変数にする必要があります) の別名にします。 つまり、パラメーターに対するすべての操作 は引数に対して行われます。 たとえば、呼び出し元がローカル変数の式、または配列要素のアクセス式を渡し、呼び出された メソッドが ref パラメーターが参照するオブジェクトを置き換える場合、メソッドから戻ったとき、呼び出し元のローカル変数または 配列要素では新しいオブジェクトが参照されます。
ref パラメーターを使用するには、メソッド定義と呼び出し元のメソッドの両方が、次の例に示すように ref キーワードを明示 的に使用する必要があります。
     ref または in パラメーターに渡す引数は、渡す前に初期化する必要があります。これは、引数を渡す前に明示的に初期 化する必要がない out パラメーターとは異なります。
クラスのメンバーは、 ref 、 in 、または out のみが異なるシグネチャを持つことはできません。 1 つの型の 2 つのメンバー間の 唯一の違いが、1つには ref パラメーターが存在し、もう1つには out または in パラメーターが存在することである場合、 コンパイラ エラーが発生します。 たとえば、次のコードはコンパイルされません。
ref (C# リファレンス) 2020/11/02 • • Edit Online
    NOTE
参照渡しの概念と参照型の概念を混同しないでください。 2 つの概念は同じではありません。 メソッドのパラメーターは、値型か参照型かど うかに関係なく、 ref によって変更できます。 参照渡しで渡される場合、値型はボックス化されません。
    void Method(ref int refArgument)
{
    refArgument = refArgument + 44;
}
int number = 1;
Method(ref number);
Console.WriteLine(number);
// Output: 45
 
    ただし、次の例に示すように、1 つのメソッドに ref 、 in または out パラメーターがあり、もう 1 つのメソッドに値パラメーター がある場合、メソッドをオーバーロードすることができます。
非表示やオーバーライドなど、シグネチャの一致が必要な他の状況では、 in 、 ref 、 out はシグネチャの一部であり、互い に一致しません。
プロパティは変数ではありません。 プロパティはメソッドであり、 ref パラメーターに渡すことはできません。 次の種類のメソッドには、 ref 、 in 、 out キーワードを使用することはできません。
async 修飾子を使用して定義した Async メソッド。
yieldreturnまたは yield break ステートメントを含むIteratorメソッド。
さらに、拡張メソッドには次の制約があります。 拡張メソッドの最初の引数では、 out キーワードを使用できません。
拡張メソッドの最初の引数が構造体ではない場合、または構造体として制約されていないジェネリック型である場合、その 引数で ref キーワードを使用することはできません。
最初の引数が構造体である場合を除き、 in キーワードは使用できません。 ジェネリック型では、構造体として制約されて いる場合であっても、 in キーワードを使用することはできません。
参照渡しで引数を渡す:使用例
前の例は、参照によって値型を渡す例でした。 ref キーワードを使用して、参照渡しで参照型を渡すこともできます。参照 型を参照渡しで渡すと、呼び出されたメソッドは、参照パラメーターが呼び出し元で参照するオブジェクトに置換できます。 オブ ジェクトの格納場所は、参照パラメーターの値としてメソッドに渡されます。 パラメーターの格納場所の値を変更する場合は (新 しいオブジェクトをポイント)、呼び出し元が参照する格納場所を変更することもできます。 次の例では、参照型のインスタンスを
ref パラメーターとして渡します。
     class CS0663_Example
{
    // Compiler error CS0663: "Cannot define overloaded
    // methods that differ only on ref and out".
    public void SampleMethod(out int i) { }
    public void SampleMethod(ref int i) { }
}
    class RefOverloadExample
{
    public void SampleMethod(int i) { }
    public void SampleMethod(ref int i) { }
}
 
      参照型を値渡しまたは参照渡しで渡す方法の詳細については、「参照型パラメーターの引き渡し」を参照してください。 参照戻り値
参照戻り値 (または ref 戻り値) は、メソッドから呼び出し元に参照渡しで返される値です。 つまり、呼び出し元はメソッドによっ て返される値を変更することができ、呼び出し元メソッド内のオブジェクトの状態にその変更が反映されます。
参照戻り値は ref キーワードを使用して以下に定義されます。 メソッドシグネチャ。たとえば、次のメソッドシグネチャは、GetCurrentPrice メソッドが参照渡しでDecimal値を返すこと
を示しています。
メソッドの return ステートメントで返される変数と return トークンの間。次に例を示します。
呼び出し元がオブジェクトの状態を変更するには、ref ローカル変数として明示的に定義した変数に参照戻り値を格納する必 要があります。
        class Product
{
    public Product(string name, int newID)
    {
        ItemName = name;
        ItemID = newID;
    }
    public string ItemName { get; set; }
    public int ItemID { get; set; }
}
private static void ChangeByReference(ref Product itemRef)
{
    // Change the address that is stored in the itemRef parameter.
    itemRef = new Product("Stapler", 99999);
    // You can change the value of one of the properties of
    // itemRef. The change happens to item in Main as well.
    itemRef.ItemID = 12345;
}
private static void ModifyProductsByReference()
{
    // Declare an instance of Product and display its initial values.
    Product item = new Product("Fasteners", 54321);
    System.Console.WriteLine("Original values in Main.  Name: {0}, ID: {1}\n",
        item.ItemName, item.ItemID);
    // Pass the product instance to ChangeByReference.
    ChangeByReference(ref item);
    System.Console.WriteLine("Back in Main.  Name: {0}, ID: {1}\n",
        item.ItemName, item.ItemID);
}
// This method displays the following output:
// Original values in Main.  Name: Fasteners, ID: 54321
// Back in Main.  Name: Stapler, ID: 12345
 public ref decimal GetCurrentPrice()
  return ref DecimalArray[0];
 
     次に、メソッド シグネチャとメソッド本体の両方を示す、より完全な ref 戻り値の例を示します。
  呼び出されたメソッドによって、戻り値が ref readonly として宣言されて参照渡しで値が返されることもあり、返された値が呼 び出し元のコードで変更できないように強制されることもあります。 呼び出し元のメソッドでは、ローカルの ref readonly 変数に 値を格納することで、返された値のコピーを回避できます。
例については、「ref 戻り値と ref ローカル変数の使用例」を参照してください。 ref ローカル変数
ref ローカル変数は、 return ref を使用して返された値を参照するために使用します。 ref ローカル変数は、初期化して ref 戻り値以外の値にすることができません。 言い換えると、初期化の右側は参照にする必要があります。 ref ローカル変数の値 に変更を加えると、参照渡しの値を返すメソッドのオブジェクトの状態に反映されます。
refローカル変数を定義するには、変数宣言の前と、参照渡しで値を返すメソッドの呼び出しの直前に、ref キーワードを使 用します。
たとえば、次のステートメントは、GetEstimatedValue という名前のメソッドによって返されるrefローカル変数を定義していま す。
同じ方法で、参照渡しの値にアクセスできます。 場合によっては、参照渡しの値へのアクセスによって負荷がかかる可能性があ るコピー操作が回避され、パフォーマンスが向上します。 たとえば、次のステートメントは、値の参照に使用される ref ローカル値 をどのように定義できるかを示しています。
どちらの例も、ref キーワードは両方の位置で使用する必要があります。そうしないと、コンパイラエラーCS8172"値を使用 して参照渡し変数を初期化することはできません" が生成されます。
C#7.3以降、foreach ステートメントの反復変数をrefローカルまたはrefreadonlyローカル変数にすることができます。詳 細については、foreach ステートメントに関する記事を参照してください。
また、C# 7.3 以降では、ref 代入演算子を使用して、ref ローカルまたは ref readonly ローカル変数を再割り当てできます。 ref readonly ローカル
ref readonly ローカルは、その署名に があり、 return ref を使用するメソッドまたはプロパティにより返される 値の参照に使用されます。 変数は ref ローカル変数のプロパティと readonly 変数の組み合わせです。そ れに割り当てられたストレージのエイリアスであり、変更できません。
ref 戻り値と ref ローカル変数の使用例
次の例は、Title と という2つのStringフィールドを持つ Book クラスを定義しています。また、Book オブジェクト のプライベート配列を含む クラスも定義しています。 個々のブック オブジェクトは、 GetBookByTitle メソッド
       ref readonly
  Author
ref readonly
   BookCollection
   public static ref int Find(int[,] matrix, Func<int, bool> predicate)
{
    for (int i = 0; i < matrix.GetLength(0); i++)
        for (int j = 0; j < matrix.GetLength(1); j++)
            if (predicate(matrix[i, j]))
                return ref matrix[i, j];
    throw new InvalidOperationException("Not found");
}
  ref decimal estValue = ref Building.GetEstimatedValue();
  ref VeryLargeStruct reflocal = ref veryLargeStruct;
 
    を呼び出すことによって参照渡しで返されます。
    呼び出し元が によって返される値を ref ローカル変数として格納する場合、呼び出し元が戻り値に加えた 変更が オブジェクトに反映されます。次の例を参照してください。
GetBookByTitle
 BookCollection
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
安全で効率的なコードを記述する ref 戻り値と ref ローカル変数
  public class Book
{
    public string Author;
    public string Title;
}
public class BookCollection
{
    private Book[] books = { new Book { Title = "Call of the Wild, The", Author = "Jack London" },
                        new Book { Title = "Tale of Two Cities, A", Author = "Charles Dickens" }
                       };
    private Book nobook = null;
    public ref Book GetBookByTitle(string title)
    {
        for (int ctr = 0; ctr < books.Length; ctr++)
        {
            if (title == books[ctr].Title)
                return ref books[ctr];
}
        return ref nobook;
    }
    public void ListBooks()
    {
        foreach (var book in books)
        {
            Console.WriteLine($"{book.Title}, by {book.Author}");
        }
        Console.WriteLine();
    }
}
   var bc = new BookCollection();
bc.ListBooks();
ref var book = ref bc.GetBookByTitle("Call of the Wild, The");
if (book != null)
    book = new Book { Title = "Republic, The", Author = "Plato" };
bc.ListBooks();
// The example displays the following output:
//       Call of the Wild, The, by Jack London
//       Tale of Two Cities, A, by Charles Dickens
//
//       Republic, The, by Plato
//       Tale of Two Cities, A, by Charles Dickens
 
       ref 条件式 パラメーターの引き渡し メソッド パラメーター
C# リファレンス
C# プログラミング ガイド C# のキーワード

    out キーワードによって、参照により引数が渡されます。仮パラメーターを引数(変数にする必要があります)の別名にします。 つまり、パラメーターに対するすべての操作は引数に対して行われます。これは、refキーワードと似ていますが、ref では、変 数を初期化してから渡す必要があります。inキーワードとも似ていますが、in では、呼び出されたメソッドで引数の値を変更 することはできません。 out パラメーターを使用するには、メソッド定義と呼び出し元のメソッドの両方で out キーワードを明 示的に使用する必要があります。 次に例を示します。
  out の引数として渡される変数は、メソッド呼び出しで渡される前に初期化する必要はありません。ただし、呼び出されたメ ソッドでは、メソッドから制御が返される前に値を割り当てる必要があります。
in 、 ref 、および out キーワードは、オーバーロード解決のためのメソッド シグネチャの一部とは見なされません。 したがっ て、唯一の違いが、1つのメソッドは ref または in 引数を受け取り、もう一方のメソッドは out 引数を受け取ることである 場合、メソッドはオーバーロードできません。 たとえば、次のコードはコンパイルされません。
ただし、一方のメソッドが ref 、 in 、または out 引数を受け取り、もう一方のメソッドにいずれの修飾子もない場合は、オー バーロードを実行できます。この例を次に示します。
コンパイラは、呼び出しサイトのパラメーター修飾子と、メソッド呼び出しで使用されるパラメーター修飾子を照合して、最適な オーバーロードを選択します。
  プロパティは変数ではないため、 out パラメーターとして渡すことはできません。
out パラメーター修飾子 (C# リファレンス) 2020/11/02 • • Edit Online
    int initializeInMethod;
OutArgExample(out initializeInMethod);
Console.WriteLine(initializeInMethod);
void OutArgExample(out int number)
{
number = 44; }
// value is now 44
    NOTE
out キーワードは、ジェネリック型パラメーターと共に使用すると、型パラメーターが共変であることを指定することもできます。 このコンテキス トでの out キーワードの使用方法の詳細については、「out (ジェネリック修飾子)」を参照してください。
    class CS0663_Example
{
    // Compiler error CS0663: "Cannot define overloaded
    // methods that differ only on ref and out".
    public void SampleMethod(out int i) { }
    public void SampleMethod(ref int i) { }
}
    class OutOverloadExample
{
    public void SampleMethod(int i) { }
    public void SampleMethod(out int i) => i = 5;
}
 
      次の種類のメソッドには、 in 、 ref 、 out キーワードを使用することはできません。 async 修飾子を使用して定義した Async メソッド。
yieldreturnまたは yield break ステートメントを含むIteratorメソッド。
さらに、拡張メソッドには次の制約があります。 拡張メソッドの最初の引数では、 out キーワードを使用できません。
拡張メソッドの最初の引数が構造体ではない場合、または構造体として制約されていないジェネリック型である場合、その 引数で ref キーワードを使用することはできません。
最初の引数が構造体である場合を除き、 in キーワードは使用できません。 ジェネリック型では、構造体として制約されて いる場合であっても、 in キーワードを使用することはできません。
out パラメーターの宣言
out 引数を含むメソッドの宣言は、複数の値を返すための従来の回避策です。C#7.0以降、同様のシナリオでは値タプルを 検討してください。次の例では out を使用して、1つのメソッド呼び出しで3つの変数を返します。3番目の引数がnullに 割り当てられます。 これにより、必要に応じてメソッドが値を返すことができます。
    out 引数を含むメソッドの呼び出し
C#6以前では、変数を別のステートメントで宣言してから out 引数として渡す必要があります。次の例では、number とい
う名前の変数を宣言してから、文字列を数値に変換する Int32.TryParse メソッドに渡しています。
  C#7.0以降では、out 変数を、別の変数宣言内ではなく、メソッド呼び出しの引数リスト内で宣言できます。これにより、よ りコンパクトで読みやすいコードが生成されます。また、メソッド呼び出しの前に誤って変数に値を割り当てることもなくなります。 次の例は前の例と似ていますが、Int32.TryParseメソッドの呼び出しで number 変数を定義している点が異なります。
    void Method(out int answer, out string message, out string stillNull)
{
    answer = 44;
    message = "I've been returned";
    stillNull = null;
}
int argNumber;
string argMessage, argDefault;
Method(out argNumber, out argMessage, out argDefault);
Console.WriteLine(argNumber);
Console.WriteLine(argMessage);
Console.WriteLine(argDefault == null);
// The example displays the following output:
// 44
//      I've been returned
// True
    string numberAsString = "1640";
int number;
if (Int32.TryParse(numberAsString, out number))
    Console.WriteLine($"Converted '{numberAsString}' to {number}");
else
    Console.WriteLine($"Unable to convert '{numberAsString}'");
// The example displays the following output:
//       Converted '1640' to 1640
 
        前の例では、 number 変数は int として厳密に型指定されています。 次の例のように、暗黙的に型指定されたローカル変 数を宣言することもできます。
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード メソッド パラメーター
   string numberAsString = "1640";
if (Int32.TryParse(numberAsString, out int number))
    Console.WriteLine($"Converted '{numberAsString}' to {number}");
else
    Console.WriteLine($"Unable to convert '{numberAsString}'");
// The example displays the following output:
//       Converted '1640' to 1640
    string numberAsString = "1640";
if (Int32.TryParse(numberAsString, out var number))
    Console.WriteLine($"Converted '{numberAsString}' to {number}");
else
    Console.WriteLine($"Unable to convert '{numberAsString}'");
// The example displays the following output:
//       Converted '1640' to 1640
 
       namespace キーワードは、関連する一連のオブジェクトを含む範囲を宣言するために使用されます。名前空間を利用し、コー ド要素を整理したり、グローバルに一意の型を作成したりできます。
    namespace SampleNamespace
{
    class SampleClass { }
    interface ISampleInterface { }
    struct SampleStruct { }
    enum SampleEnum { a, b }
    delegate void SampleDelegate(int i);
    namespace Nested
    {
        class SampleClass2 { }
    }
}
 注釈
名前空間内では、以下の型を 0 個以上宣言できます。
別の名前空間
class interface struct enum delegate
C# ソース ファイル内に名前空間を明示的に宣言しているかどうかに関係なく、コンパイラは既定の名前空間を追加します。 こ の無名の名前空間はグローバル名前空間とも呼ばれますが、すべてのファイルに存在します。 グローバル名前空間内にある識 別子は、名前付き名前空間で利用できます。
名前空間には暗黙的にパブリック アクセスが設定されます。この属性は変更できません。 名前空間内の要素に割り当てること ができるアクセス修飾子については、「アクセス修飾子」を参照してください。
名前空間は、2つ以上の宣言で定義できます。たとえば、次の例では、MyCompany 名前空間の一部として2つのクラスを定 義しています。
 namespace (C# リファレンス) 2020/11/02 • • Edit Online
 
         例 入れ子になった名前空間で静的なメソッドを呼び出す方法の例を次に示します。
    namespace SomeNameSpace
{
    public class MyClass
    {
        static void Main()
        {
            Nested.NestedNameSpaceClass.SayHello();
        }
}
    // a nested namespace
    namespace Nested
    {
        public class NestedNameSpaceClass
        {
} }
}
// Output: Hello
public static void SayHello()
{
    Console.WriteLine("Hello");
}
 C# 言語仕様
詳細については、C# 言語仕様に関する記事の「名前空間」に関するセクションを参照してください。
関連項目
C# リファレンス
C# キーワード
using
using static 名前空間エイリアス修飾子 :: 名前空間
   namespace MyCompany.Proj1
{
    class MyClass
    {
    }
}
namespace MyCompany.Proj1
{
    class MyClass1
    {
    }
}
 
          using キーワードは、主に次の3つの場合に使用します。
ステートメントの使用では、破棄されるオブジェクトの末尾でスコープを定義します。
using ディレクティブでは、名前空間のエイリアスを作成したり、他の名前空間で定義されている型をインポートしたりしま す。
静的ディレクティブの使用では、1 つのクラスのメンバーをインポートします。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード 名前空間
extern
using (C# リファレンス) 2021/03/06 • • Edit Online
 
       using ディレクティブは、次の3つの用途で使用します。 名前空間で型の使用を許可する場合。これにより、その名前空間内では型を修飾せずに使用できます。
アクセスを型名で修飾することなく、型の静的メンバーおよび入れ子にされた型へのアクセスを許可する場合。
詳細については、「using static ディレクティブ」を参照してください。 名前空間または型のエイリアスを作成する場合。 これは "using エイリアス ディレクティブ" と呼ばれます。
using キーワードは、usingステートメントの作成にも使用します。ファイルやフォントなどのIDisposableオブジェクトを正しく 処理できるようになります。 詳しくは、「using ステートメント」をご覧ください。
using static 型 アクセスを型名で修飾することなく型の静的メンバーにアクセスできます。
  using System.Text;
   using static System.Math;
   using Project = PC.MyCompany.Project;
     using static System.Console;
using static System.Math;
class Program
{
    static void Main()
    {
        WriteLine(Sqrt(3*3 + 4*4));
    }
}
 注釈
using ディレクティブのスコープは、このディレクティブが存在するファイルに限定されます。
using ディレクティブは、次のように記述することができます。
ソース コード ファイルの先頭、任意の名前空間または型定義の前。
任意の名前空間内、ただし、この名前空間内で宣言された任意の名前空間または型の前。 それ以外の場合は、コンパイラ エラー CS1529 が生成されます。
using 別名ディレクティブを作成すると、名前空間または型の識別子を修飾しやすくなります。いずれの using ディレクティ ブにおいても、前に置かれる using に関係なく、完全に修飾された名前空間または型を使用する必要があります。 using ディレクティブの宣言内では、 using 別名を使用することができません。 たとえば、次の場合はコンパイラ エラーが生成されま す。
using ディレクティブ (C# リファレンス) 2021/03/06 • • Edit Online
 
   using ディレクティブを作成すると、名前空間内の型を、名前空間を指定することなく使用できます。 using ディレクティブで は、指定した名前空間に入れ子になった別の名前空間へのアクセスは許可されません。
名前空間は、ユーザー定義とシステム定義の 2 つのカテゴリに分類されます。 ユーザー定義の名前空間は、コードで定義され た名前空間です。 システム定義の名前空間の一覧については、「.NET API ブラウザー」を参照してください。
例1
次の例は、名前空間の using エイリアスを定義して使用する方法を示しています。
    namespace PC
{
    // Define an alias for the nested namespace.
    using Project = PC.MyCompany.Project;
    class A
    {
void M() {
            // Use the alias
            var mc = new Project.MyClass();
        }
    }
    namespace MyCompany
    {
} }
namespace Project
{
    public class MyClass { }
}
  usingエイリアスディレクティブの右側には、オープンジェネリック型を配置できません。たとえば、List<T> のusingエイリアスを 作成することはできませんが、List<int> のusingエイリアスは作成できます。
例2
次の例は、クラスの using ディレクティブと using エイリアスを定義する方法を示しています。
    using s = System.Text;
using s.RegularExpressions; // Generates a compiler error.
 
            C# 言語仕様
詳細については、C# 言語仕様に関するページの using ディレクティブに関するセクションを参照してください。 言語仕様は、
C# の構文と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド 名前空間の使用
C# のキーワード 名前空間
using ステートメント
  using System;
// Using alias directive for a class.
using AliasToMyClass = NameSpace1.MyClass;
// Using alias directive for a generic class.
using UsingAlias = NameSpace2.MyClass<int>;
namespace NameSpace1
{
    public class MyClass
    {
} }
public override string ToString()
{
    return "You are in NameSpace1.MyClass.";
}
namespace NameSpace2
{
    class MyClass<T>
    {
} }
public override string ToString()
{
    return "You are in NameSpace2.MyClass.";
}
namespace NameSpace3
{
    class MainClass
    {
} }
static void Main()
{
    var instance1 = new AliasToMyClass();
    Console.WriteLine(instance1);
    var instance2 = new UsingAlias();
    Console.WriteLine(instance2);
}
// Output:
//    You are in NameSpace1.MyClass.
//    You are in NameSpace2.MyClass.

     using static ディレクティブは、型名を指定せずにアクセスできる静的メンバーおよび入れ子にされた型を指定します。 構文 は次のとおりです。
fully-qualified-type-name は、型名を指定せずに参照できる静的メンバーおよび入れ子にされた型の名前です。 完全修 飾型名 (完全な名前空間名と型名) を指定しないと、C# によってコンパイラ エラー CS0246: "型または名前空間の名前 'type/namespace' が見つかりませんでした (using ディレクティブまたはアセンブリ参照が指定されていることを確認してくださ い)" が生成されます。
using static ディレクティブは、インスタンス メンバーがある場合でも、静的メンバーがあるすべての型 (または入れ子にされた 型) に適用されます。 ただし、インスタンス メンバーは、型のインスタンスを通してのみ呼び出すことができます。
using static ディレクティブは、C#6で導入されました。 Remarks
通常は、静的メンバーを呼び出すときに、型名とメンバー名を指定します。 同じ型名を繰り返し入力してその型のメンバーを 呼び出すと、コードが冗長でわかりにくくなる可能性があります。たとえば、次の Circle クラスの定義は、Mathクラスのメン バー数を参照します。
  using static <fully-qualified-type-name>;
        using System;
public class Circle
{
   public Circle(double radius)
   {
      Radius = radius;
   }
   public double Radius { get; set; }
   public double Diameter
   {
      get { return 2 * Radius; }
   }
   public double Circumference
   {
      get { return 2 * Radius * Math.PI; }
   }
   public double Area
   {
      get { return Math.PI * Math.Pow(Radius, 2); }
   }
}
  メンバーが参照されるたびに Math クラスを明示的に参照する必要がなくなれば、 using static ディレクティブによって生成さ れるコードがより簡潔になります。
using static ディレクティブ (C# リファレンス) 2020/11/02 • • Edit Online
 
    using static は、指定した型で宣言されているアクセス可能な静的メンバーおよび入れ子になった型のみをインポートしま す。 継承されたメンバーはインポートされません。 using static ディレクティブを使用して、Visual Basic モジュールを含む、名前 付きの型からインポートすることができます。 F# の最上位の関数が、有効な C# 識別子を名前に持つ名前付きの型の静的メ ンバーとしてメタデータに存在する場合は、その F# 関数をインポートできます。
using static を使用すると、指定した型で宣言された拡張メソッドを拡張メソッドの参照で使用できるようになります。 ただ し、コード内で修飾なしで参照している場合は、拡張メソッドの名前はスコープにインポートされません。
同じコンパイル単位または名前空間の多様な using static ディレクティブによってさまざまな型からインポートされた同じ名前 を持つメソッドが、メソッド グループを形成します。 これらのメソッド グループ内のオーバーロードの解決方法は、C# の通常の規 則に従います。
例
次の例では、 using static ディレクティブを使用して、Console クラス、Math クラス、および String クラスの静的メンバーを、 型名を指定せずに使用できるようにしています。
      using System;
using static System.Math;
public class Circle
{
   public Circle(double radius)
   {
      Radius = radius;
   }
   public double Radius { get; set; }
   public double Diameter
   {
      get { return 2 * Radius; }
   }
   public double Circumference
   {
      get { return 2 * Radius * PI; }
   }
   public double Area
   {
      get { return PI * Pow(Radius, 2); }
   }
}
 
       上の例では、 using static ディレクティブを Double 型に適用することもできます。 それにより、型名を指定せず に、TryParse(String,Double)メソッドを呼び出せるようになります。ただし、どの数値型の TryParse メソッドが呼び出された かを判断するために using static ディレクティブを確認する必要が出てくるため、コードが読みにくくなります。
    using System;
using static System.Console;
using static System.Math;
using static System.String;
class Program
{
   static void Main()
   {
      Write("Enter a circle's radius: ");
      var input = ReadLine();
      if (!IsNullOrEmpty(input) && double.TryParse(input, out var radius)) {
         var c = new Circle(radius);
         string s = "\nInformation about the circle:\n";
s=s+Format(" s=s+Format(" s=s+Format(" s=s+Format(" WriteLine(s);
}
else {
Radius: {0:N2}\n", c.Radius);
Diameter: {0:N2}\n", c.Diameter);
Circumference: {0:N2}\n", c.Circumference);
Area: {0:N2}\n", c.Area);
         WriteLine("Invalid input...");
      }
} }
public class Circle
{
   public Circle(double radius)
   {
      Radius = radius;
   }
   public double Radius { get; set; }
   public double Diameter
   {
      get { return 2 * Radius; }
   }
   public double Circumference
   {
      get { return 2 * Radius * PI; }
   }
   public double Area
   {
      get { return PI * Pow(Radius, 2); }
   }
}
// The example displays the following output:
//
//
//
//
//
//
//
Enter a circle's radius: 12.45
Information about the circle:
   Radius: 12.45
   Diameter: 24.90
   Circumference: 78.23
Area: 486.95

      関連項目
using ディレクティブ C# リファレンス
C# のキーワード 名前空間の使用 名前空間

             IDisposableオブジェクトの正しい使用を保証する簡易構文を提供します。C#8.0以降は、using ステートメントによって IAsyncDisposable オブジェクトが適切に使用されるようになります。
例
using ステートメントを使用する方法の例を次に示します。
    string manyLines=@"This is line one
This is line two
Here is line three
The penultimate line is line four
This is the final, fifth line.";
using (var reader = new StringReader(manyLines))
{
    string? item;
    do {
        item = reader.ReadLine();
        Console.WriteLine(item);
    } while(item != null);
}
 C#8.0以降では、中かっこを必要としない using ステートメントに次の代替構文を使用できます。
    string manyLines=@"This is line one
This is line two
Here is line three
The penultimate line is line four
This is the final, fifth line.";
using var reader = new StringReader(manyLines);
string? item;
do {
    item = reader.ReadLine();
    Console.WriteLine(item);
} while(item != null);
 Remarks
File と Font は、アンマネージド リソース (この場合はファイル ハンドルとデバイス コンテキスト) にアクセスするマネージド型の例で す。 アンマネージ リソースや、それをカプセル化するクラス ライブラリ型は他にもたくさんあります。 このようなすべての型 は、IDisposable インターフェイスまたは IAsyncDisposable インターフェイスを実装する必要があります。
IDisposable オブジェクトの有効期間が1つのメソッドに限定されているとき、それを using ステートメントで宣言し、インスタ ンス化してください。 using ステートメントは、オブジェクトで正しくDisposeメソッドを呼び出します。(前述のようにこのステート メントを使用する場合) Dispose が呼び出されるとすぐに、オブジェクト自体がスコープの外側に出されます。 オブジェクトは、
using ブロック内では読み取り専用です。変更したり再割り当てしたりすることはできません。オブジェクトに IDisposable で はなく が実装されている場合、using ステートメントからはDisposeAsyncが呼び出され、返される ValueTask の を行います。 IAsyncDisposable の詳細については、「DisposeAsync メソッドの実装」を参照してくだ さい。
   IAsyncDisposable
 awaits
using ステートメント (C# リファレンス) 2021/03/06 • • Edit Online
 
      using ステートメントにより、using ブロック内で例外が発生した場合でも必ずDispose(またはDisposeAsync)が呼び出 されます。オブジェクトを try ブロックに配置し、finally ブロック内でDispose(またはDisposeAsync)を呼び出しても、同 じ結果が得られます。実際には、コンパイラによって using ステートメントがこのように変換されます。前のコード例は、コンパイ ル時に次のコードに展開されます (オブジェクトのスコープ制限を定義する中かっこが加えられていることに注意してください)。
     string manyLines=@"This is line one
This is line two
Here is line three
The penultimate line is line four
This is the final, fifth line.";
{
    var reader = new StringReader(manyLines);
    try {
        string? item;
        do {
            item = reader.ReadLine();
            Console.WriteLine(item);
        } while(item != null);
} finally {
        reader?.Dispose();
    }
}
 新しい using ステートメントの構文は似たコードに変換されます。変数が宣言されている場所で try ブロックが開きます。 finally ブロックは、囲んでいるブロックの終わり、通常はメソッドの最後に追加されます。
try - finally ステートメントの詳細については、「try-finally」の記事を参照してください。
次の例のように、1つの using ステートメントで型の複数のインスタンスを宣言できます。1つのステートメントで複数の変数を
宣言する場合、暗黙的に型指定された変数 ( var ) を使用できないことに注意してください。
      string numbers=@"One
Two
Three
Four.";
string letters=@"A
B
C
D.";
using (StringReader left = new StringReader(numbers),
    right = new StringReader(letters))
{
    string? item;
    do {
        item = left.ReadLine();
        Console.Write(item);
        Console.Write("    ");
        item = right.ReadLine();
        Console.WriteLine(item);
    } while(item != null);
}
 次の例に示すように、C# 8 で導入された新しい構文を使用して、同じ型の複数の宣言を組み合わせることができます。

          リソースオブジェクトをインスタンス化してから、変数を using ステートメントに渡すことはできますが、これはベストプラクティスで はありません。 この場合、アンマネージド リソースへのアクセスがなくなっている可能性が高いのにもかかわらず、制御が using ブロックを離れた後もオブジェクトはスコープ内に残ります。つまり、完全に初期化されることはなくなります。 using ブロックの 外側でオブジェクトを使用しようとすると、例外がスローされる可能性があります。このため、オブジェクトを using ステートメント でインスタンス化して、そのスコープを using ブロックに制限することをお勧めします。
    string manyLines=@"This is line one
This is line two
Here is line three
The penultimate line is line four
This is the final, fifth line.";
var reader = new StringReader(manyLines);
using (reader)
{
    string? item;
    do {
        item = reader.ReadLine();
        Console.WriteLine(item);
    } while(item != null);
}
// reader is in scope here, but has been disposed
  IDisposable オブジェクトの破棄に関する詳細については、「IDisposableを実装するオブジェクトの使用」を参照してくださ い。
C# 言語仕様
詳細については、C# 言語仕様に関するページの using ステートメントに関するセクションを参照してください。 言語仕様は、
C# の構文と使用法に関する信頼性のある情報源です。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
using ディレクティブ ガベージ コレクション
   string numbers=@"One
Two
Three
Four.";
string letters=@"A
B
C
D.";
using StringReader left = new StringReader(numbers),
    right = new StringReader(letters);
string? item;
do {
    item = left.ReadLine();
    Console.Write(item);
    Console.Write("    ");
    item = right.ReadLine();
    Console.WriteLine(item);
} while(item != null);
 
    IDisposable を実装するオブジェクトの使用 IDisposable インターフェイス
C# 8.0 の using ステートメント

    場合によっては、同じ完全修飾型名を持つ、2 つのバージョンのアセンブリを参照する必要が生じることもあります。 たとえば、 同じアプリケーション内で、2 つ以上のバージョンのアセンブリを使用する必要が生じることもあるでしょう。 外部アセンブリ エイリア スを使用すれば、各アセンブリの名前空間を、エイリアスを付けたルート レベルの名前空間内でラップして、それらを同じファイル 内で使用できるようにすることができます。
同じ完全修飾型名を持つ 2 つのアセンブリを参照するには、コマンド プロンプトで次のようにエイリアスを指定する必要がありま す。
 /r:GridV1=grid.dll
/r:GridV2=grid20.dll
これにより、外部エイリアス GridV1 および GridV2 が作成されます。 これらのエイリアスをプログラム内から使用するには、
extern キーワードを使用してそれらを参照します。次に例を示します。 extern alias GridV1;
extern alias GridV2;
各 extern エイリアスの宣言では、グローバル名前空間に対応する (ただし、グローバル名前空間内にはない) 追加のルート レ ベル名前空間が導入されています。 そのため、各アセンブリの型は、適切な名前空間エイリアスをルートに持つ完全修飾名を 使用して、明確に参照することができます。
前の例では、 GridV1::Grid が grid.dll からのグリッド コントロールで、 GridV2::Grid が grid20.dll からのグリッド コント ロールになります。
Visual Studio の使用
Visual Studio を使用している場合は、同様の方法でエイリアスを指定できます。
Visual Studio のプロジェクトに、grid.dll と grid20.dll の参照を追加します。 プロパティ タブを開き、エイリアスをグローバルから GridV1 および GridV2 にそれぞれ変更します。
上記と同じ方法でこれらのエイリアスを使用します
これで、"using エイリアス ディレクティブ" を使用して、名前空間または型のエイリアスを作成できるようになりました。 詳細につ いては、using ディレクティブに関する記事をご覧ください。
    NOTE
extern キーワードは、アンマネージ コードで記述されたメソッドを宣言するために、メソッド修飾子として使用することもできます。
                extern alias GridV1;
extern alias GridV2;
  extern alias (C# リファレンス) 2020/11/02 • • Edit Online
    using Class1V1 = GridV1::Namespace.Class1;
using Class1V2 = GridV2::Namespace.Class1;
 
       C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド
C# のキーワード
::演算子
-reference (C# コンパイラ オプション)

        is 演算子では、式の結果と指定された型との間に互換性があるかどうかが確認されるか、または(C#7.0以降では)パター ンに対して式がテストされます。型テストの is 演算子について詳しくは、型テストとキャスト演算子に関する記事の「is演算 子」セクションをご覧ください。
is を使用したパターン マッチング
C#7.0以降では、is およびswitchステートメントでパターンマッチングがサポートされています。 is キーワードでは、以下の
パターンがサポートされています。
型パターン: 式を指定された型に変換できるかどうかがテストされ、できる場合は変数がその型の変数にキャストされます。 定数パターン: 式の評価が指定された定数値になるかどうかをテストします。
var パターン: 照合が常に成功し、式の値が新しいローカル変数にバインドされます。
型パターン
型パターンを使用してパターンマッチングを実行すると、式を指定された型に変換できるかどうかが is によってテストされ、変 換できる場合はその型の変数にキャストされます。 is ステートメントのわかりやすい拡張機能であり、型の評価および変換を 簡潔に記述できます。 is 型パターンの一般的な形式は次のとおりです。
ここでexprは何らかの型のインスタンスに評価される式、typeはexprの結果が変換される型の名前、varnameは is のテ スト結果が true である場合にexprの結果が変換されるオブジェクトをそれぞれ表しています。
exprが null ではなく、以下のいずれかの条件がtrueである場合に、is 式は true となります。
expr が type と同じ型のインスタンスである。
expr が type から派生した型のインスタンスである。 つまり、expr の結果を type のインスタンスにアップキャストできる。 expr のコンパイル時の型が type の基底クラスであり、expr の実行時の型が type または type から派生した型である。 変 数の "コンパイル時の型" とは、その変数の宣言で定義されている型です。 変数の "実行時の型" とは、その変数に代入さ れているインスタンスの型です。
expr が、type インターフェイスを実装する型のインスタンスである。
C#7.1 以降、expr はジェネリック型パラメーターとその制約によって定義されるコンパイル時型を持つことができます。
exprが true であり is が if ステートメントに使用されている場合は、varnameは if ステートメント内のみに割り当て られます。 varname のスコープは、 is 式から if ステートメントを閉じるブロックの末尾までになります。 他の任意の場所に varname を使用すると、割り当てられていない変数の使用によるコンパイル時エラーが生成されます。
次の例では、is 型のパターンを使用して、型IComparable.CompareTo(Object)のメソッドの実装を提供します。
  expr is type varname
 is (C# リファレンス) 2021/03/06 • • Edit Online
 
  パターン マッチングを使用しない場合、このコードは次のように記述できます。 型パターン マッチングを使用することにより、変換 結果が null であるかどうかをテストする必要がなくなるため、コードがよりコンパクトで読みやすくなります。
    using System;
public class Employee : IComparable
{
    public String Name { get; set; }
    public int Id { get; set; }
    public int CompareTo(Object o)
    {
        var e = o as Employee;
        if (e == null)
        {
           throw new ArgumentException("o is not an Employee object.");
        }
        return Name.CompareTo(e.Name);
    }
}
 is 型パターンを使用すると、値の型の種類を判定する場合によりコンパクトなコードを記述できます。 次の例では、 is 型パ ターンを使用し、オブジェクトが Person インスタンスか Dog インスタンスかを判定した後に適切なプロパティの値を表示してい ます。
    using System;
public class Employee : IComparable
{
    public String Name { get; set; }
    public int Id { get; set; }
    public int CompareTo(Object o)
    {
        if (o is Employee e)
        {
            return Name.CompareTo(e.Name);
        }
        throw new ArgumentException("o is not an Employee object.");
    }
}
 
    パターン マッチングを使用せずにこれと同等のコードを記述する場合は、明示的なキャストを含む代入処理を個別に行う必要 があります。
  using System;
public class Example
{
   public static void Main()
   {
      Object o = new Person("Jane");
      ShowValue(o);
      o = new Dog("Alaskan Malamute");
      ShowValue(o);
   }
   public static void ShowValue(object o)
   {
      if (o is Person p) {
         Console.WriteLine(p.Name);
      }
      else if (o is Dog d) {
         Console.WriteLine(d.Breed);
      }
} }
public struct Person
{
   public string Name { get; set; }
   public Person(string name) : this()
   {
Name = name; }
}
public struct Dog
{
   public string Breed { get; set; }
   public Dog(string breedName) : this()
   {
      Breed = breedName;
   }
}
// The example displays the following output:
// Jane
// Alaskan Malamute

    定数パターン
定数パターンを使用してパターンマッチングを実行すると、式が指定された定数と等しいかどうかが is によってテストされます。 C#6以前のバージョンでの定数パターンはswitchステートメントでサポートされています。C#7.0以降では、is ステートメン トでもサポートされています。 構文は次のとおりです。
ここで expr は評価する式、constant はテストする値を表しています。 constant には、次のいずれかの定数式を指定できま す。
リテラル値。
宣言された const 変数の名前。
  expr is constant
   using System;
public class Example
{
   public static void Main()
   {
      Object o = new Person("Jane");
      ShowValue(o);
      o = new Dog("Alaskan Malamute");
      ShowValue(o);
   }
   public static void ShowValue(object o)
   {
      if (o is Person) {
         Person p = (Person) o;
         Console.WriteLine(p.Name);
      }
      else if (o is Dog) {
         Dog d = (Dog) o;
         Console.WriteLine(d.Breed);
      }
} }
public struct Person
{
   public string Name { get; set; }
   public Person(string name) : this()
   {
Name = name; }
}
public struct Dog
{
   public string Breed { get; set; }
   public Dog(string breedName) : this()
   {
      Breed = breedName;
   }
}
// The example displays the following output:
// Jane
//       Alaskan Malamute

  列挙定数。 定数式は以下のように評価されます。
expr と constant が整数型の場合、式から true が返されるかどうか (つまり、 expr == constant であるかどうか) が C# の等値演算子によって判定されます。
それ以外の場合、式の値は静的 Object.Equals(expr, constant) メソッドの呼び出しによって判定されます。 次の例では、型パターンと定数パターンを組み合わせてオブジェクトが Dice インスタンスであるかどうかをテストし、そうである場
合はサイコロ振り操作の値が 6 であるかどうかをテストします。
     using System;
public class Dice
{
    Random rnd = new Random();
    public Dice()
    {
    }
    public int Roll()
    {
        return rnd.Next(1, 7);
    }
}
class Program
{
    static void Main(string[] args)
    {
        var d1 = new Dice();
        ShowValue(d1);
    }
    private static void ShowValue(object o)
    {
        const int HIGH_ROLL = 6;
        if (o is Dice d && d.Roll() is HIGH_ROLL)
            Console.WriteLine($"The value is {HIGH_ROLL}!");
        else
            Console.WriteLine($"The dice roll is not a {HIGH_ROLL}!");
} }
// The example displays output like the following:
//      The value is 6!
 定数パターンを使用して、 null のチェックを実行できます。 is ステートメントで null キーワードがサポートされています。 構文は次のとおりです。
null チェックの比較を示す例を次に示します。
  expr is null
 
      式 x is null は、参照型と Null 許容値型に対して異なる方法で計算されます。 Null 許容値型の場合 は、Nullable<T>.HasValue が使用されます。 参照型の場合は、 (object)x == null が使用されます。
var パターン
var パターンによるパターンマッチは常に成功します。構文は次のとおりです。
ここで expr の値は常に varname というローカル変数に代入されます。 varname は、expr のコンパイル時の型と同じ型の変 数です。
expr が null に評価された場合、 is 式の結果 true が生成され、 null が varname に割り当てられます。 var パターン は、 null 値に対して true が生成される is の数少ない使用法の 1 つです。
次の例に示すように、 var パターンを使用してブール式内に一時変数を作成できます。
   expr is var varname
   using System;
class Program
{
    static void Main(string[] args)
    {
        object o = null;
        if (o is null)
        {
            Console.WriteLine("o does not have a value");
        }
else {
            Console.WriteLine($"o is {o}");
        }
int? x = 10;
        if (x is null)
        {
            Console.WriteLine("x does not have a value");
        }
else {
            Console.WriteLine($"x is {x.Value}");
        }
        // 'null' check comparison
        Console.WriteLine($"'is' constant pattern 'null' check result : { o is null }");
        Console.WriteLine($"object.ReferenceEquals 'null' check result : { object.ReferenceEquals(o, null)
        Console.WriteLine($"Equality operator (==) 'null' check result : { o == null }");
}"); }
    // The example displays the following output:
    // o does not have a value
    // x is 10
    // 'is' constant pattern 'null' check result : True
    // object.ReferenceEquals 'null' check result : True
    // Equality operator (==) 'null' check result : True
}

           前の例では、コストが高い操作の結果を格納するために一時変数を使用しています。 変数は、複数回使用できます。
C# 言語仕様
詳細については、C# 言語仕様の「The is operator (is 演算子)」セクションおよび以下の C# 言語提案を参照してください。
パターン マッチング
ジェネリックを使用したパターン マッチング
関連項目
C# リファレンス
C# キーワード 型テストとキャスト演算子
  using System;
using System.Collections.Generic;
using System.Linq;
class Program
{
    static void Main()
    {
        int[] testSet = { 100271, 234335, 342439, 999683 };
        var primes = testSet.Where(n => Factor(n).ToList() is var factors
                                    && factors.Count == 2
                                    && factors.Contains(1)
                                    && factors.Contains(n));
        foreach (int prime in primes)
        {
            Console.WriteLine($"Found prime: {prime}");
        }
}
    static IEnumerable<int> Factor(int number)
    {
        int max = (int)Math.Sqrt(number);
        for (int i = 1; i <= max; i++)
        {
            if (number % i == 0)
            {
} }
} }
yield return i;
if (i != number / i)
{
    yield return number / i;
}
// The example displays the following output:
//       Found prime: 100271
//       Found prime: 999683

            new 制約は、ジェネリッククラス宣言内の型引数に、パブリックでパラメーターなしのコンストラクターが必要であることを指定しま す。 new 制約を使用する場合、型を抽象型にすることはできません。
new 制約は、次の例に示すように、ジェネリッククラスである型の新しいインスタンスを作成する場合に型パラメーターに適用さ れます。
new() 制約を別の制約と併用する場合、この制約を最後に指定する必要があります。
詳細については、「型パラメーターの制約」を参照してください。
new キーワードは、型のインスタンスの作成に使用することも、またはメンバーの宣言修飾子として使用することもできます。
C# 言語仕様
詳細については、C# 言語仕様の「型パラメーターの制約」セクションを参照してください。
関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード ジェネリック
    class ItemFactory<T> where T : new()
{
    public T GetNewItem()
    {
        return new T();
    }
}
     public class ItemFactory2<T>
    where T : IComparable, new()
{}
 new 制約 (C# リファレンス) 2020/11/02 • • Edit Online
 
          ジェネリック定義の where 句では、型の制約を指定します。この型は、ジェネリック型、メソッド、デリゲート、またはローカル関数 における型パラメーターの引数として使用されます。 制約では、インターフェイス (基底クラス) を指定したり、参照、値、またはア ンマネージド型となるジェネリック型を要求したりすることができます。 それらにより型引数が処理する必要がある機能が宣言さ れえます。
たとえば、型パラメーター T がIComparable<T>インターフェイスを実装するように、次のように MyGenericClass ジェネリック クラスを宣言できます。
where 句には基底クラスの制約を含めることもできます。基底クラスの制約は、そのジェネリック型の型引数として使用される 型が、指定されたクラスを基底クラスとして持つか、その基底クラスであることを示しています。 基底クラスの制約を使用する場 合は、型パラメーターに関する制約よりも前に制約を記述する必要があります。 一部の型は、基底クラスの制約として許可さ れません (Object、Array、ValueType)。 C# 7.3 より前は、Enum、Delegate、MulticastDelegate も基底クラスの制約とし て許可されていません。 次の例では、この型は基底クラスとして指定できるようになったことを示しています。
C# 8.0 以降の null 許容コンテキストでは、基本クラス型の null 許容属性が適用されます。 基底クラスが null 非許容の場 合(たとえば、Base)、型引数はnull非許容である必要があります。基底クラスがnull許容の場合(Base? など)、型引数 は null 許容型または null 非許容型のいずれかになります。 基底クラスが null 非許容であるときに、型引数が null 許容の 参照型である場合、コンパイラからは警告を発行されます。
where 句では、型が class または であることを指定できます。 struct 制約では、 System.ValueType の基底ク ラスの制約を指定する必要はありません。 型は基底クラスの制約として使用できません。 class 制約と
struct 制約の両方の例を次に示します。
C#8.0以降のnull許容コンテキストでは、class 制約には、型がnull非許容の参照型である必要があります。null許容 の参照型を許可するには、class? 制約を使用して、null許容とnull非許容の参照型の両方を許可します。
where 句には、notnull 制約を含めることができます。 notnull 制約では、型パラメーターをnull非許容型に制限しま す。 その型には、値型または null 非許容参照型を指定できます。 notnull 制約は、C# 8.0 以降の nullable enable コ ンテキストでコンパイルされたコードで使用できます。 他の制約とは異なり、型引数が notnull 制約に違反すると、コンパイラ
   public class AGenericClass<T> where T : IComparable<T> { }
     NOTE
クエリ式での where 句の詳細については、「where 句」を参照してください。
     public class UsingEnum<T> where T : System.Enum { }
public class UsingDelegate<T> where T : System.Delegate { }
public class Multicaster<T> where T : System.MulticastDelegate { }
    struct
 System.ValueType
     class MyClass<T, U>
    where T : class
where U : struct {}
       where (ジェネリック型制約) (C# リファレンス) 2020/11/03 • • Edit Online
 
   によりエラーではなく警告が生成されます。 警告は、   コンテキストでのみ生成されます。
    IMPORTANT
notnull 制約が含まれるジェネリック宣言は、null 許容が未指定のコンテキストで使用できますが、コンパイラではその制約は強制されま せん。
      #nullable enable
    class NotNullContainer<T>
        where T : notnull
    {
    }
#nullable restore
   where 句には、 制約を含めることもできます。 unmanaged 制約では、アンマネージド型と呼ばれる型に対して型 パラメーターを制限します。 制約を使用すると、C# でローレベルの相互運用コードを記述しやすくなります。 この 制約では、すべてのアンマネージド型にわたって再利用可能なルーチンを可能にします。 unmanaged 制約は、 class や
struct 制約と組み合わせることはできません。 unmanaged 制約は struct にする必要がある型を適用します。
where 句には、コンストラクター制約 new() を含めることもできます。 その制約では、 new 演算子を使用して型パラメーター のインスタンスを作成できるようにします。 new() 制約に基づいて、コンパイラで、指定されている型引数にはアクセス可能なパ ラメーターなしのコンストラクターが必要であることが認識されます。 次に例を示します。
new() 制約は where 句の最後に示されます。 new() 制約は、 struct や unmanaged 制約と組み合わせることはできま せん。 それらの制約を満たすすべての型には、 new() 制約を重複させて、アクセス可能なパラメーターなしのコンストラクターが 含まれている必要があります。
複数の型パラメーターがある場合には、型パラメーターごとに where 句を1つずつ使用します。次に例を示します。
unmanaged
 unmanaged
        class UnManagedWrapper<T>
    where T : unmanaged
{}
     public class MyGenericClass<T> where T : IComparable<T>, new()
{
    // The following line is not possible without new() constraint:
    T item = new T();
}
       public interface IMyInterface { }
namespace CodeExample
{
    class Dictionary<TKey, TVal>
        where TKey : IComparable<TKey>
        where TVal : IMyInterface
    {
        public void Add(TKey key, TVal val) { }
} }
 次の例に示すように、ジェネリック メソッドの型パラメーターにも制約を適用できます。
  public void MyMethod<T>(T t) where T : IMyInterface { }
  nullable enable
 
         デリゲートに対する型パラメーター制約を記述する構文は、メソッドの構文と同じである点に注意してください。
  delegate T MyDelegate<T>() where T : new();
 汎用デリゲートについては、「汎用デリゲート」を参照してください。 制約の構文と使用方法の詳細については、「型パラメーターの制約」を参照してください。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド ジェネリックの概要
new 制約 型パラメーターの制約

   base キーワードは、派生クラス内から基底クラスのメンバーにアクセスするために使います。 別のメソッドによってオーバーライドされた基底クラスのメソッドを呼び出します。 派生クラスのインスタンスを作成するときに基底クラスのどのコンストラクターを呼び出す必要があるかを指定します。
基底クラスへのアクセスは、コンストラクター、インスタンス メソッド、またはインスタンスのプロパティ アクセサーにおいてのみ許可さ れます。
静的メソッド内から base キーワードを使うとエラーになります。 アクセスされる基底クラスは、クラス宣言で指定されている基底クラスです。 たとえば、 class ClassB : ClassA と指定すると、
ClassA の基底クラスに関係なく、ClassA のメンバーが ClassB からアクセスされます。 例
この例では、基底クラス Person と派生クラス の両方に、 Getinfo という名前のメソッドがあります。 base キー ワードを使うことで、派生クラス内から基底クラスの メソッドを呼び出すことができます。
    Employee
 Getinfo
base (C# リファレンス) 2020/03/18 • • Edit Online
 
     その他の例については、「new」、「virtual」、「override」をご覧ください。
例 この例では、派生クラスのインスタンスを作成するときに呼び出される基底クラスのコンストラクターを指定する方法を示します。
  public class Person
{
    protected string ssn = "444-55-6666";
    protected string name = "John L. Malgraine";
    public virtual void GetInfo()
    {
        Console.WriteLine("Name: {0}", name);
        Console.WriteLine("SSN: {0}", ssn);
    }
}
class Employee : Person
{
    public string id = "ABC567EFG";
    public override void GetInfo()
    {
        // Calling the base class GetInfo method:
        base.GetInfo();
        Console.WriteLine("Employee ID: {0}", id);
} }
class TestClass
{
    static void Main()
    {
        Employee E = new Employee();
        E.GetInfo();
    }
}
/*
Output
Name: John L. Malgraine
SSN: 444-55-6666
Employee ID: ABC567EFG
*/

        C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 参照
C# リファレンス
C# プログラミングガイド C# のキーワード
this
  public class BaseClass
{
int num;
    public BaseClass()
    {
        Console.WriteLine("in BaseClass()");
    }
    public BaseClass(int i)
    {
num = i;
        Console.WriteLine("in BaseClass(int i)");
    }
    public int GetNum()
    {
return num; }
}
public class DerivedClass : BaseClass
{
    // This constructor will call BaseClass.BaseClass()
    public DerivedClass() : base()
    {
    }
    // This constructor will call BaseClass.BaseClass(int i)
    public DerivedClass(int i) : base(i)
    {
    }
    static void Main()
    {
        DerivedClass md = new DerivedClass();
        DerivedClass md1 = new DerivedClass(1);
    }
}
/*
Output:
in BaseClass()
in BaseClass(int i)
*/

    this キーワードはクラスの現在のインスタンスを参照します。拡張メソッドの最初のパラメーターの修飾子としても使用されま す。
this の一般的な使い方を次に示します。 似た名前によって非表示にされるメンバーを修飾する場合は次のようになります。
    NOTE
ここでは、クラス インスタンスでの this の使用について説明します。 拡張メソッドでの使用の詳細については、「拡張メソッド」を参照してく ださい。
     public class Employee
{
    private string alias;
    private string name;
    public Employee(string name, string alias)
    {
} }
// Use this to qualify the members of the class
// instead of the constructor parameters.
this.name = name;
this.alias = alias;
 オブジェクトを他のメソッドにパラメーターとして渡す場合は次のようになります。
インデクサーを宣言する場合は、次のようになります。
静的メンバー関数は、クラス レベルで存在し、オブジェクトの一部ではないため、 this ポインターがありません。 静的メソッドで this を参照するとエラーになります。
例
この例では、似た名前によって非表示にされている クラスのメンバー name と alias を修飾するために this が 使用されています。 また、別のクラスに属するメソッド にオブジェクトを渡すためにも使用されています。
  CalcTax(this);
     public int this[int param]
{
    get { return array[param]; }
    set { array[param] = value; }
}
  Employee
 CalcTax
this (C# リファレンス) 2020/05/20 • • Edit Online
 
       C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 参照
C# リファレンス
C# プログラミングガイド
  class Employee
{
    private string name;
    private string alias;
    private decimal salary = 3000.00m;
    // Constructor:
    public Employee(string name, string alias)
    {
        // Use this to qualify the fields, name and alias:
        this.name = name;
        this.alias = alias;
}
    // Printing method:
    public void printEmployee()
    {
        Console.WriteLine("Name: {0}\nAlias: {1}", name, alias);
        // Passing the object to the CalcTax method by using this:
        Console.WriteLine("Taxes: {0:C}", Tax.CalcTax(this));
}
    public decimal Salary
    {
        get { return salary; }
    }
}
class Tax {
    public static decimal CalcTax(Employee E)
    {
        return 0.08m * E.Salary;
    }
}
class MainClass
{
    static void Main()
    {
        // Create objects:
        Employee E1 = new Employee("Mingda Pan", "mpan");
        // Display results:
        E1.printEmployee();
    }
}
/* Output:
    Name: Mingda Pan
    Alias: mpan
    Taxes: $240.00
*/

  C# のキーワード base
メソッド

    null キーワードは、いかなるオブジェクトも参照していないnull参照を表すリテラルです。 null は参照型変数の既定値で す。 null 許容値型を除き、通常の値の型を null にすることはできません。
次の例では、 null キーワードの一部の動作を示します。
null (C# リファレンス) 2020/11/02 • • Edit Online
 
     C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
  class Program
{
    class MyClass
    {
        public void MyMethod() { }
    }
    static void Main(string[] args)
    {
} }
// Set a breakpoint here to see that mc = null.
// However, the compiler considers it "unassigned."
// and generates a compiler error if you try to
// use the variable.
MyClass mc;
// Now the variable can be used, but...
mc = null;
// ... a method call on a null object raises
// a run-time NullReferenceException.
// Uncomment the following line to see for yourself.
// mc.MyMethod();
// Now mc has a value.
mc = new MyClass();
// You can call its method.
mc.MyMethod();
// Set mc to null again. The object it referenced
// is no longer accessible and can now be garbage-collected.
mc = null;
// A null string is not the same as an empty string.
string s = null;
string t = String.Empty; // Logically the same as ""
// Equals applied to any null object returns false.
bool b = (t.Equals(s));
Console.WriteLine(b);
// Equality operator also returns false when one
// operand is null.
Console.WriteLine("Empty string {0} null string", s == t ? "equals": "does not equal");
// Returns true.
Console.WriteLine("null == null is {0}", null == null);
// A value type cannot be null
// int i = null; // Compiler error!
// Use a nullable value type instead:
int? i = null;
// Keep the console window open in debug mode.
System.Console.WriteLine("Press any key to exit.");
System.Console.ReadKey();

     関連項目
C# リファレンス
C# キーワード
C# 型の既定値 Nothing (Visual Basic)

                bool 型キーワードは、ブール値(true または false のいずれか)を表す.NETSystem.Boolean構造体型のエイリアスで す。
bool 型の値を使って論理演算を実行するには、ブール論理演算子を使用します。 bool 型は、比較および等値演算子の 結果の型です。 bool 式は、if、do、while、およびforステートメントおよび条件演算子 ?: で制御条件式にすることがで きます。
bool 型の既定値は false です。 リテラル
true および false リテラルを使用して、 bool 変数を初期化したり、 bool 値を渡したりすることができます。
3 値ブール型ロジック
3値ロジックをサポートする必要がある場合は、null許容型の bool? を使用します。たとえば、3値ブール型をサポートする データベースを操作する場合などです。 bool? オペランドの場合、定義済みの & 演算子と | 演算子は3値ロジックをサ ポートします。 詳細については、「Boolean logical operators (ブール論理演算子)」記事の「Nullable Boolean logical operators (null 許容論理演算子)」セクションを参照してください。
null 許容値型の詳細については、「null 許容値型」を参照してください。 コンバージョン
C#には、bool 型が関係する変換が2つのみ用意されています。対応するnull許容型の bool? への暗黙的な変換と、 bool? 型からの明示的な変換です。ただし、.NETには、bool 型との間の変換に使用できる追加のメソッドが用意されてい
ます。 詳細については、System.Boolean API リファレンス ページの「ブール値との間の変換」セクションを参照してください。 C# 言語仕様
詳細については、C# 言語仕様の「Bool 型」セクションを参照してください。 関連項目
C# リファレンス
値型
true および false 演算子
    bool check = true;
Console.WriteLine(check ? "Checked" : "Not checked");  // output: Checked
Console.WriteLine(false ? "Checked" : "Not checked");  // output: Not checked
 bool (C# リファレンス) 2020/11/02 • • Edit Online
 
         default キーワードは、以下の2とおりの方法で使用できます。 switch ステートメントで既定のラベルを指定するため。
型の既定値を生成するための既定の演算子またはリテラルとして。 関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード
 default (C# リファレンス) 2020/11/02 • • Edit Online
 
     コンテキスト キーワードを使用して、コード内で特定の意味を付与することができます。ただし C# ではコンテキスト キーワードは 予約語ではありません。 このセクションでは、次のコンテキスト キーワードを紹介します。
    add
async
await dynamic
get global init partial
remove
set value
var
where yield
クライアント コードがイベントをサブスクライブするときに呼び出されるカ スタム イベント アクセサーを定義します。
修飾されたメソッド、ラムダ式、または匿名メソッドが非同期であること を示します。
待機中のタスクが完了するまで async のメソッドを中断します。 コンパイル時の型チェックをバイパスする処理を可能にする参照型を
定義します。
プロパティまたはインデクサーのアクセサー メソッドを定義します。
グローバル名前空間のエイリアス (それ以外の場合は無名です)。
プロパティまたはインデクサーのアクセサー メソッドを定義します。
同一コンパイル ユニットに部分クラス、部分構造体、または部分イン ターフェイスを定義します。
クライアント コードがイベントのサブスクライブを解除するときに呼び出 されるカスタム イベント アクセサーを定義します。
プロパティまたはインデクサーのアクセサー メソッドを定義します。
アクセサーを設定したり、イベント ハンドラーを追加または削除したり するために使用されます。
メソッド スコープで宣言された変数の型をコンパイラで判断できるよう にします。
ジェネリック宣言に制約を追加します (「where」も参照してください)。 反復子ブロックで使用され、列挙子オブジェクトに値を返すか、反復
処理の終了を通知します。
                                               when
    catch ブロックまたは switch ステートメントの case ラベルの フィルター条件を指定します。
       C# 3.0 で導入されたすべてのクエリ キーワードもコンテキスト キーワードです。 詳細については「クエリ キーワード (LINQ)」を参 照してください。
コンテキスト キーワード (C# リファレンス) 2021/03/13 • • Edit Online
 
    関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード

      add コンテキストキーワードは、カスタムイベントアクセサーを定義するときに使用されます。このアクセサーは、クライアントコー ドがイベントをサブスクライブするときに呼び出されます。カスタムの add アクセサーを指定するときは、removeアクセサーも指 定する必要があります。
例
次の例は、カスタムの add アクセサーとremoveアクセサーが指定されているイベントを示しています。サンプル全体について
は、「インターフェイス イベントを実装する方法」を参照してください。
    class Events : IDrawingObject
{
    event EventHandler PreDrawEvent;
    event EventHandler IDrawingObject.OnDraw
    {
        add => PreDrawEvent += value;
        remove => PreDrawEvent -= value;
    }
}
 通常は、独自のカスタム イベント アクセサーを提供する必要はありません。 イベントを宣言するときにコンパイラで自動生成され るアクセサーは、ほとんどのシナリオで利用することができます。
関連項目
イベント
add (C# リファレンス) 2020/11/02 • • Edit Online
 
        get キーワードは、プロパティのアクセサーメソッド、またはプロパティ値かインデクサー要素を返すインデクサーを定義します。 詳しくは、「プロパティ (C# プログラミング ガイド)」、「自動実装するプロパティ (C# プログラミング ガイド)」、および「インデクサー (C# プログラミング ガイド)」をご覧ください。
次の例では、 Seconds という名前のプロパティの get アクセサーと set アクセサーを定義しています。 また、 _seconds とい う名前のプライベート フィールドを使って、プロパティの値を戻しています。
      class TimePeriod
{
     private double _seconds;
     public double Seconds
     {
         get { return _seconds; }
         set { _seconds = value; }
     }
}
 前の例のように、多くの場合、get アクセサーは値を返す1つのステートメントで構成されます。C#7.0以降では、式形式の メンバーとして get アクセサーを実装できます。 次の例では、 get アクセサーと set アクセサーの両方を、式形式のメンバー として実装しています。
    class TimePeriod
{
    private double _seconds;
    public double Seconds
    {
        get => _seconds;
        set => _seconds = value;
    }
}
 プロパティの get アクセサーと set アクセサーがプライベートバッキングフィールドの値の設定と取得以外の操作を実行しない 単純な場合では、自動実装プロパティに対する C# コンパイラのサポートを利用できます。 次の例では、自動実装プロパティと して Hours を実装しています。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
    class TimePeriod2
{
    public double Hours { get; set; }
}
 get (C# リファレンス) 2021/03/06 • • Edit Online
 
     関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード プロパティ

           部分型定義を使用すると、クラス、構造体、インターフェイス、またはレコードの定義を複数のファイルに分割することができま す。
File1.cs 内:
    namespace PC
{
    partial class A
    {
} }
int num = 0;
void MethodA() { }
partial void MethodC();
 File2.cs 宣言内:
    namespace PC
{
    partial class A
    {
        void MethodB() { }
        partial void MethodC() { }
    }
}
 注釈
クラス型、構造体型、またはインターフェイス型を複数のファイルに分割する操作は、大規模なプロジェクトや、Windows フォー ム デザイナーで自動生成されるコードを処理する場合に役立ちます。 部分型には、部分メソッドが含まれる場合があります。 詳細については、「部分クラスと部分メソッド」を参照してください。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド 修飾子 ジェネリックの概要
partial 型 (C# リファレンス) 2020/11/02 • • Edit Online
 
      部分メソッドには、部分型の一部に定義されたシグネチャ、および部分型の別の部分に定義された実装があります。 部分メ ソッドを使用すると、イベント ハンドラーと同じように、開発者が実装するかどうかを決定できるメソッド フックをクラス デザイナー で提供できます。 開発者が実装を指定しない場合、コンパイラはコンパイル時にシグネチャを削除します。 部分メソッドには次 の条件が適用されます。
部分型の両方の部分のシグネチャが一致する必要がある。
メソッドが void を返す必要がある。
アクセス修飾子はできない。 部分メソッドは暗黙的にプライベート メソッドになる。
部分クラスの 2 つの部分に定義された部分メソッドを次の例に示します。
    namespace PM
{
    partial class A
    {
        partial void OnSomethingHappened(string s);
    }
    // This part can be in a separate file.
    partial class A
    {
} }
// Comment out this method and the program
// will still compile.
partial void OnSomethingHappened(String s)
{
    Console.WriteLine("Something happened: {0}", s);
}
 詳細については、「部分クラスと部分メソッド」を参照してください。 関連項目
C# リファレンス partial 型
partial メソッド (C# リファレンス) 2020/11/02 • • Edit Online
 
     remove コンテキストキーワードは、カスタムイベントアクセサーを定義するときに使用されます。このアクセサーは、クライアント コードがイベントから登録を解除するときに呼び出されます。カスタムの remove アクセサーを指定するときは、addアクセサーも 指定する必要があります。
例
次の例は、カスタムのaddアクセサーと remove アクセサーが指定されているイベントを示しています。サンプル全体について
は、「インターフェイス イベントを実装する方法」を参照してください。
      class Events : IDrawingObject
{
    event EventHandler PreDrawEvent;
    event EventHandler IDrawingObject.OnDraw
    {
        add => PreDrawEvent += value;
        remove => PreDrawEvent -= value;
    }
}
 通常は、独自のカスタム イベント アクセサーを提供する必要はありません。 イベントを宣言するときにコンパイラで自動生成され るアクセサーは、ほとんどのシナリオで利用することができます。
関連項目
イベント
remove (C# リファレンス) 2020/11/02 • • Edit Online
 
       set キーワードは、プロパティまたはインデクサーで、プロパティ値またはインデクサーの要素値を割り当てる"アクセサー"メソッド を定義します。 使用例を含む詳細については、「プロパティ」、「自動実装プロパティ」、および「インデクサー」を参照してくださ い。
次の例では、 Seconds という名前のプロパティの get アクセサーと set アクセサーを定義しています。 また、 _seconds とい う名前のプライベート フィールドを使って、プロパティの値を戻しています。
      class TimePeriod
{
     private double _seconds;
     public double Seconds
     {
         get { return _seconds; }
         set { _seconds = value; }
     }
}
 多くの場合、前の例のように、set アクセサーは値を割り当てる1つのステートメントで構成されます。C#7.0以降では、式 形式のメンバーとして set アクセサーを実装できます。 次の例では、 get アクセサーと set アクセサーの両方を、式形式の メンバーとして実装しています。
    class TimePeriod
{
    private double _seconds;
    public double Seconds
    {
        get => _seconds;
        set => _seconds = value;
    }
}
 プロパティの get アクセサーと set アクセサーがプライベートバッキングフィールドの値の設定と取得以外の操作を実行しない 単純な場合では、自動実装プロパティに対する C# コンパイラのサポートを利用できます。 次の例では、自動実装プロパティと して Hours を実装しています。
C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
    class TimePeriod2
{
    public double Hours { get; set; }
}
 set (C# リファレンス) 2020/11/02 • • Edit Online
 
     関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード プロパティ

       コンテキストキーワード when は、次のコンテキストでフィルター条件を指定するために使用できます。
try/catchまたはtry/catch/finallyブロックの catch ステートメント。 switchステートメントの case ラベル。
switch 式。
catch ステートメントでの when
C#6から、when を catch ステートメントで使用して、特定の例外のハンドラーを実行するためにtrueになる必要がある条 件を指定できるようになりました。 構文は次のとおりです。
exprの箇所には、ブール値に評価される式を指定します。 true が返された場合は、例外ハンドラーが実行されます。 false の場合は実行されません。
次の例では、when キーワードを使用し、例外メッセージのテキストに応じて、HttpRequestExceptionのハンドラーが条件付 きで実行されるようにしています。
     catch (ExceptionType [e]) when (expr)
 when (C# リファレンス) 2020/11/02 • • Edit Online
 
      switch ステートメントでの when
C# 7.0 以降では、 case ラベルが相互に排他的である必要がなくなり、 switch ステートメントでの case ラベルの表示順序 によって、実行されるswitchブロックを決定できるようになりました。 when キーワードを使用すると、フィルター条件がtrueで ある場合にのみ、関連付けられた case ラベルも true になるフィルター条件を指定できます。 構文は次のとおりです。
expr の箇所には、match 式と比較される定数パターンまたは型パターンを指定し、when-condition の箇所には、任意の ブール式を指定します。
次の例では、when キーワードを使用して、面積が0の Shape オブジェクトに対するテストと、面積が0より大きい各種の Shape オブジェクトに対するテストを実行しています。
   case (expr) when (when-condition):
   using System;
using System.Net.Http;
using System.Threading.Tasks;
class Program
{
    static void Main()
    {
        Console.WriteLine(MakeRequest().Result);
    }
    public static async Task<string> MakeRequest()
    {
} }
var client = new HttpClient();
var streamTask = client.GetStringAsync("https://localHost:10000");
try
{
    var responseText = await streamTask;
    return responseText;
}
catch (HttpRequestException e) when (e.Message.Contains("301"))
{
    return "Site Moved";
}
catch (HttpRequestException e) when (e.Message.Contains("404"))
{
    return "Page Not Found";
}
catch (HttpRequestException e)
{
    return e.Message;
}
    using System;
public abstract class Shape
{
   public abstract double Area { get; }
   public abstract double Circumference { get; }
}
public class Rectangle : Shape
{
   public Rectangle(double length, double width)
   {
Length = length;

       Length = length;
      Width = width;
   }
   public double Length { get; set; }
   public double Width { get; set; }
   public override double Area
   {
      get { return Math.Round(Length * Width,2); }
   }
   public override double Circumference
   {
      get { return (Length + Width) * 2; }
   }
}
public class Square : Rectangle
{
   public Square(double side) : base(side, side)
   {
Side = side; }
   public double Side { get; set; }
}
public class Example
{
   public static void Main()
   {
      Shape sh = null;
      Shape[] shapes = { new Square(10), new Rectangle(5, 7),
                         new Rectangle(10, 10), sh, new Square(0) };
      foreach (var shape in shapes)
         ShowShapeInfo(shape);
}
   private static void ShowShapeInfo(Object obj)
   {
      switch (obj)
      {
         case Shape shape when shape.Area == 0:
            Console.WriteLine($"The shape: {shape.GetType().Name} with no dimensions");
            break;
         case Square sq when sq.Area > 0:
            Console.WriteLine("Information about the square:");
            Console.WriteLine($"   Length of a side: {sq.Side}");
            Console.WriteLine($"   Area: {sq.Area}");
            break;
         case Rectangle r when r.Area > 0:
            Console.WriteLine("Information about the rectangle:");
            Console.WriteLine($"   Dimensions: {r.Length} x {r.Width}");
            Console.WriteLine($"   Area: {r.Area}");
            break;
         case Shape shape:
            Console.WriteLine($"A {shape.GetType().Name} shape");
            break;
         case null:
            Console.WriteLine($"The {nameof(obj)} variable is uninitialized.");
            break;
         default:
            Console.WriteLine($"The {nameof(obj)} variable does not represent a Shape.");
            break;
} }
}
// The example displays the following output:
   //       Information about the square:

    関連項目
switch ステートメント try/catch ステートメント try/catch/finally ステートメント
   //
//
//
//
//
//
//
//
//
//
//
Information about the square:
   Length of a side: 10
   Area: 100
Information about the rectangle:
   Dimensions: 5 x 7
   Area: 35
Information about the rectangle:
   Dimensions: 10 x 10
   Area: 100
The obj variable is uninitialized.
The shape: Square with no dimensions
 
        コンテキストキーワード value は、set アクセサーのpropertyとindexer宣言で使用されます。これは、メソッドの入力パラ メーターに似ています。 value という単語は、クライアントコードでプロパティまたはインデクサーに割り当てる値を表します。次 の例の MyDerivedClass には、 Name というプロパティがあります。このプロパティは value パラメーターを使用して、バッキング フィールド name に新しい文字列を割り当てます。クライアントコードから見ると、演算は簡単な代入演算として記述されま す。
     class MyBaseClass
{
    // virtual auto-implemented property. Overrides can only
    // provide specialized behavior if they implement get and set accessors.
    public virtual string Name { get; set; }
    // ordinary virtual property with backing field
    private int num;
    public virtual int Number
    {
        get { return num; }
        set { num = value; }
    }
}
class MyDerivedClass : MyBaseClass
{
    private string name;
   // Override auto-implemented property with ordinary property
   // to provide specialized accessor behavior.
    public override string Name
    {
get {
            return name;
        }
set {
else {
                name = "Unknown";
            }
} }
}
if (!string.IsNullOrEmpty(value))
{
    name = value;
}
 詳細については、プロパティとインデクサーに関するページを参照してください。 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で す。
value (C# リファレンス) 2020/11/02 • • Edit Online
 
    関連項目
C# リファレンス
C# プログラミング ガイド C# のキーワード

                   ステートメントで yield コンテキストキーワードを使用した場合、メソッド、演算子、または get アクセサーが反復子であるこ とを示します。 yield を使用して反復子を定義すると、カスタムコレクション型のIEnumerator<T>およびIEnumerableパ ターンを実装するときに明示的な余分なクラス (列挙の状態を保持するクラス。たとえば IEnumerator を参照) が不要になりま す。
yield ステートメントの2つの形式を次の例に示します。
Remarks
各要素を 1 つずつ返すには、 yield return ステートメントを使用します。
Iterator メソッドから返されるシーケンスを、foreach ステートメントまたは LINQ クエリを使って使用することができます。
foreach ループの各イテレーションは、Iterator メソッドを呼び出します。 yield return ステートメントが Iterator メソッドに到
達すると、expression が返され、コードの現在の位置が保持されます。次回、Iterator関数が呼び出されると、この位置か ら実行が再開されます。
yield break ステートメントを使用すると、反復を終了できます。 反復子について詳しくは、「Iterators」をご覧ください。
Iterator メソッドと get アクセサー 反復子の宣言は、次の要件を満たす必要があります。
戻り値の型は、IEnumerable、IEnumerable<T>、IEnumerator、または IEnumerator<T> であることが必要です。
この宣言には、in、ref、または out パラメーターを含めることはできません。
yield またはIEnumerableを返す反復子のIEnumerator型は object です。反復子がIEnumerable<T>または IEnumerator<T> を返す場合、 yield return ステートメント内の式の型から、ジェネリック型パラメーターへの暗黙的な変換 が存在する必要があります。
yield return または yield break ステートメントを以下に含めることはできません。 ラムダ式および匿名メソッド。
unsafe ブロックを含むメソッド。 詳しくは、「unsafe」をご覧ください。
例外処理
yield return ステートメントは、try-catchブロックに配置することはできません。 yield return ステートメントは、try-
finally ステートメントの try ブロックに配置できます。
yield break ステートメントは、try ブロックまたは catch ブロックには配置できますが、finally ブロックには配置できません。 foreach 本体(Iteratorメソッドの外部)で例外がスローされた場合、Iteratorメソッドの finally ブロックが実行されます。
    yield return <expression>;
yield break;
               yield (C# リファレンス) 2021/03/06 • • Edit Online
 
    技術的な実装
次のコードは、iteratorメソッドから IEnumerable<string> を返した後、要素を反復処理します。
への呼び出しでは、メソッドの本体は実行されません。 この呼び出しでは、 IEnumerable<string> が 変数に返されます。
     IEnumerable<string> elements = MyIteratorMethod();
foreach (string element in elements)
{
... }
   MyIteratorMethod
 elements
  ループの反復処理では、MoveNext について ステートメントに到達するまで、
よって返される式は、ループ本体による処理に対する elements のCurrentプロパティも決定します。
メソッドが呼び出されます。 この呼び出しでは、次の
foreach
   MyIteratorMethod
elements
yield return
の本体が実行されます。 変数の値だけでなく、
ステートメントに である、
ステートメント ルー
ステートメント本体 ステートメン
 element
yield return
 IEnumerable<string>
   foreach ループの以降の各反復処理では、反復子本体の実行が中断した場所から続行し、 に到達したときに再度停止します。iteratorメソッドまたは foreach ステートメントの最後に到達すると、 プは完了します。
例
次の例では、 yield return ループ内に for ステートメントが含まれます。 Main メソッド内の の各反復処理では、Power Iterator関数が呼び出されます。Iterator関数を呼び出すごとに、 トの次の実行に進みます。これは、 for ループの次の反復処理で行われます。
yield return
   Iterator メソッドの戻り値の型は IEnumerable であり、これは反復子インターフェイス型です。 Iterator メソッドが呼び出される と、数値の累乗を含む列挙可能なオブジェクトが返されます。
foreach
yield break
  yield return
    public class PowersOf2
{
    static void Main()
    {
        // Display powers of 2 up to the exponent of 8:
        foreach (int i in Power(2, 8))
        {
            Console.Write("{0} ", i);
        }
}
    public static System.Collections.Generic.IEnumerable<int> Power(int number, int exponent)
    {
        int result = 1;
        for (int i = 0; i < exponent; i++)
        {
            result = result * number;
            yield return result;
        }
}
    // Output: 2 4 8 16 32 64 128 256
}
 例

     次の例は、反復子である get アクセサーを示しています。この例では、各   ステートメントがユーザー定義クラ スのインスタンスを返します。
    public static class GalaxyClass
{
    public static void ShowGalaxies()
    {
        var theGalaxies = new Galaxies();
        foreach (Galaxy theGalaxy in theGalaxies.NextGalaxy)
        {
            Debug.WriteLine(theGalaxy.Name + " " + theGalaxy.MegaLightYears.ToString());
        }
}
    public class Galaxies
    {
        public System.Collections.Generic.IEnumerable<Galaxy> NextGalaxy
        {
get {
} }
}
yield return new Galaxy { Name = "Tadpole", MegaLightYears = 400 };
yield return new Galaxy { Name = "Pinwheel", MegaLightYears = 25 };
yield return new Galaxy { Name = "Milky Way", MegaLightYears = 0 };
yield return new Galaxy { Name = "Andromeda", MegaLightYears = 3 };
    public class Galaxy
    {
        public String Name { get; set; }
        public int MegaLightYears { get; set; }
    }
}
 C# 言語仕様
詳細については、「C# 言語の仕様」を参照してください。 言語仕様は、C# の構文と使用法に関する信頼性のある情報源で
す。 関連項目
C# リファレンス
C# プログラミング ガイド foreach、in
反復子
 yield return
 
        このセクションでは、クエリ式で使用するコンテキスト キーワードについて説明します。 このセクションの内容
from データ ソースおよび範囲変数 (反復変数に類似) を指定します。
select クエリ実行で返されるシーケンスに含まれる要素の型と形状を指定し ます。
group 指定したキー値に基づき、クエリ結果をグループ化します。
into join 句、group 句、または select 句の結果への参照として機能す
る識別子を指定します。
orderby 要素型の既定の比較子に基づき、クエリ結果を昇順または降順で 並べ替えます。
join 指定した 2 つの一致基準の等価比較に基づき、2 つのデータ ソース を結合します。
let 範囲変数を使用して、クエリ式のサブ式の結果を格納します。 in join 句のコンテキスト キーワードです。
on join 句のコンテキスト キーワードです。
equals join 句のコンテキスト キーワードです。
by group 句のコンテキスト キーワードです。 ascending orderby 句のコンテキスト キーワードです。 descending orderby 句のコンテキスト キーワードです。
関連項目
C# のキーワード 統合言語クエリ (LINQ) C# での LINQ
       where
   論理 AND演算子 ( && )と論理 OR演算子 ( || )で区切られた 1 つ以上のブール式に基づき、ソース要素をフィルター処理します。
                                               クエリ キーワード (C# リファレンス) 2020/11/02 • • Edit Online
 
             クエリ式は、 from 句で始める必要があります。 また、クエリ式にはサブクエリを含めることができます。サブクエリも from 句で始 めます。 from 句は次を指定します。
クエリまたはサブクエリを実行するデータ ソース。
ソース シーケンスの各要素を表す、ローカルの 範囲変数。 範囲変数とデータソースの両方は厳密に型指定されます。 from 句で参照されるデータソースには、IEnumerable
型、IEnumerable<T> 型、あるいは IQueryable<T> のような派生型が含まれている必要があります。
次の例では、 numbers はデータ ソースであり、 num は範囲変数です。 var キーワードが使用されていても、両方の変数が厳
密に型指定されていることに注目してください。
     class LowNums
{
    static void Main()
    {
} }
// A simple data source.
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
// Create the query.
// lowNums is an IEnumerable<int>
var lowNums = from num in numbers
    where num < 5
    select num;
// Execute the query.
foreach (int i in lowNums)
{
    Console.Write(i + " ");
}
// Output: 4 1 3 2 0
 範囲変数
データ ソースが IEnumerable<T> を実装するとき、コンパイラは範囲変数の型を推測します。 たとえば、ソースの型が の場合、範囲変数は Customer ではないかと推測されます。ソースがArrayListのような非ジェネ
リック 型のときにのみ、型を明示的に指定する必要があります。 詳細については、「LINQ を使用して ArrayList にクエリを実行する方法」を参照してください。
前述の例では、 num は型 int として推測されます。 範囲変数は厳密に型指定されるため、範囲変数の上でメソッドを呼 び出したり、他の操作で範囲変数を使用したりできます。 たとえば、 select num を記述する代わりに、
select num.ToString() を記述し、クエリ式が整数ではなく文字列のシーケンスを返すようにできます。 あるいは、式でシーケ ンス 14、11、13、12、10 を返すように select num + 10 を記述できます。 詳細については、「select 句」をご覧ください。
範囲変数は foreach ステートメントの繰り返し変数に似ていますが、1 つだけ非常に重要な違いがあります。範囲変数がソー スのデータを格納することは決してありません。 これは構文上の利便性のためです。クエリの実行時に何が起こるのかクエリで表 現できます。 詳細については、「LINQ クエリの概要 (C#)」を参照してください。
  IEnumerable<Customer>
 IEnumerable
   from 句 (C# リファレンス) 2021/03/06 • • Edit Online
 
   複合 from 句
ソース シーケンスの各要素がそれ自体シーケンスになったり、それ自体にシーケンスが含まれたりすることがあります。 たとえば、 データ ソースが になることがあります。この場合、シーケンスの各学生オブジェクト参照にテストの点数 の一覧が含まれます。各 要素内の内部一覧にアクセスするには、複合 from 句を利用できます。この手法 は、foreachステートメントを入れ子にして使う場合に似ています。where句またはorderby句をいずれかの from 句に追 加し、結果を絞り込むことができます。 次は、 Student オブジェクトのシーケンスの例です。テストの点数を表す整数の内部
List がそれぞれに含まれています。内部一覧にアクセスするには、複合 from 句を利用できます。必要に応じて、2つの from 句の間に句を挿入できます。
 IEnumerable<Student>
 Student
 
    複数の from 句を使用して結合を実行する
複合 from 句を使用し、単一データソースの内部コレクションにアクセスします。ただし、個別データソースから補足クエリを生 成する複数の from 句をクエリに含めることもできます。この手法では、join句で不可能な特定の結合操作を実行できま す。
2つの from 句を使用し、2つのデータソースの完全なクロス結合を作る様子を示したのが次の例です。
  class CompoundFrom
{
    // The element type of the data source.
    public class Student
    {
        public string LastName { get; set; }
        public List<int> Scores {get; set;}
    }
    static void Main()
    {
} }
// Use a collection initializer to create the data source. Note that
// each element in the list contains an inner sequence of scores.
List<Student> students = new List<Student>
{
   new Student {LastName="Omelchenko", Scores= new List<int> {97, 72, 81, 60}},
   new Student {LastName="O'Donnell", Scores= new List<int> {75, 84, 91, 39}},
   new Student {LastName="Mortensen", Scores= new List<int> {88, 94, 65, 85}},
   new Student {LastName="Garcia", Scores= new List<int> {97, 89, 85, 82}},
   new Student {LastName="Beebe", Scores= new List<int> {35, 72, 91, 70}}
};
// Use a compound from to access the inner sequence within each element.
// Note the similarity to a nested foreach statement.
var scoreQuery = from student in students
                 from score in student.Scores
                    where score > 90
                    select new { Last = student.LastName, score };
// Execute the queries.
Console.WriteLine("scoreQuery:");
// Rest the mouse pointer on scoreQuery in the following line to
// see its type. The type is IEnumerable<'a>, where 'a is an
// anonymous type defined as new {string Last, int score}. That is,
// each instance of this anonymous type has two members, a string
// (Last) and an int (score).
foreach (var student in scoreQuery)
{
    Console.WriteLine("{0} Score: {1}", student.Last, student.score);
}
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/*
scoreQuery:
Omelchenko Score: 97
O'Donnell Score: 91
Mortensen Score: 94
Garcia Score: 97
Beebe Score: 91
*/

     複数の from 句を使用する結合操作の詳細については、「左外部結合の実行」を参照してください。
  class CompoundFrom2
{
    static void Main()
    {
} }
char[] upperCase = { 'A', 'B', 'C' };
char[] lowerCase = { 'x', 'y', 'z' };
// The type of joinQuery1 is IEnumerable<'a>, where 'a
// indicates an anonymous type. This anonymous type has two
// members, upper and lower, both of type char.
var joinQuery1 =
    from upper in upperCase
    from lower in lowerCase
    select new { upper, lower };
// The type of joinQuery2 is IEnumerable<'a>, where 'a
// indicates an anonymous type. This anonymous type has two
// members, upper and lower, both of type char.
var joinQuery2 =
    from lower in lowerCase
    where lower != 'x'
    from upper in upperCase
    select new { lower, upper };
// Execute the queries.
Console.WriteLine("Cross join:");
// Rest the mouse pointer on joinQuery1 to verify its type.
foreach (var pair in joinQuery1)
{
    Console.WriteLine("{0} is matched to {1}", pair.upper, pair.lower);
}
Console.WriteLine("Filtered non-equijoin:");
// Rest the mouse pointer over joinQuery2 to verify its type.
foreach (var pair in joinQuery2)
{
    Console.WriteLine("{0} is matched to {1}", pair.lower, pair.upper);
}
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
        Cross join:
        A is matched to x
        A is matched to y
        A is matched to z
        B is matched to x
        B is matched to y
        B is matched to z
        C is matched to x
        C is matched to y
        C is matched to z
        Filtered non-equijoin:
        y is matched to A
        y is matched to B
        y is matched to C
        z is matched to A
        z is matched to B
        z is matched to C
        */

   関連項目
クエリ キーワード (LINQ) 統合言語クエリ (LINQ)

   where 句をクエリ式で使用して、クエリ式で返されるデータソースの要素を指定します。ブール条件(述語)を(範囲変数で 参照される)各ソース要素に適用し、指定した条件に該当するものを返します。単一のクエリ式に複数の where 句を含める ことができ、単一の句に複数の述語部分式を含めることができます。
例
次の例では、where 句で、5未満の数値を除くすべての数値を除外します。 where 句を削除すると、データソースのすべて
の数値が返されます。 式 num < 5 は、各要素に適用される述語です。
     class WhereSample
{
    static void Main()
    {
} }
// Simple data source. Arrays support IEnumerable<T>.
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
// Simple query with one predicate in where clause.
var queryLowNums =
    from num in numbers
    where num < 5
    select num;
// Execute the query.
foreach (var s in queryLowNums)
{
    Console.Write(s.ToString() + " ");
}
//Output: 4 1 3 2 0
 例
単一の where 句内には、&&および||演算子を使用して、必要な数の述語を指定できます。次の例のクエリでは、5未満 の偶数のみを選択するために 2 つの述語を指定します。
where 句 (C# リファレンス) 2021/03/06 • • Edit Online
 
    例
where 句には、ブール値を返す1つ以上のメソッドを含めることができます。次の例の where 句では、範囲変数の現在の 値が偶数であるか、奇数であるかを判断するためのメソッドを使用します。
  class WhereSample2
{
    static void Main()
    {
} }
// Output:
// 4 2 0
// 4 2 0
// Data source.
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
// Create the query with two predicates in where clause.
var queryLowNums2 =
    from num in numbers
    where num < 5 && num % 2 == 0
    select num;
// Execute the query
foreach (var s in queryLowNums2)
{
    Console.Write(s.ToString() + " ");
}
Console.WriteLine();
// Create the query with two where clause.
var queryLowNums3 =
    from num in numbers
    where num < 5
    where num % 2 == 0
    select num;
// Execute the query
foreach (var s in queryLowNums3)
{
    Console.Write(s.ToString() + " ");
}

        注釈
where 句はフィルターメカニズムです。クエリ式のほぼどこにでも指定できますが、最初の句や最後の句にすることはできませ ん。 where 句は、ソース要素のフィルター処理をグループ化の前に行うか後に行うかによって、group句の前または後に指定 できます。
指定した述語がデータ ソース内の要素に対して有効でない場合は、コンパイル時エラーが発生します。 これは、LINQ で提供 される厳密な型チェックの 1 つの利点です。
コンパイル時に、where キーワードはWhere標準クエリ演算子メソッドの呼び出しに変換されます。 関連項目
クエリ キーワード (LINQ) from 句
select 句 データのフィルター処理 C# での LINQ 統合言語クエリ (LINQ)
   class WhereSample3
{
    static void Main()
    {
        // Data source
        int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
        // Create the query with a method call in the where clause.
        // Note: This won't work in LINQ to SQL unless you have a
        // stored procedure that is mapped to a method by this name.
        var queryEvenNums =
            from num in numbers
            where IsEven(num)
            select num;
         // Execute the query.
        foreach (var s in queryEvenNums)
        {
            Console.Write(s.ToString() + " ");
        }
}
    // Method may be instance method or static method.
    static bool IsEven(int i)
    {
        return i % 2 == 0;
    }
}
//Output: 4 8 6 2 0
 
      クエリ式で、 select 句は、クエリが実行されたときに生成される値の型を指定します。 結果は、以前のすべての句の評価と select 句自体の式に基づいています。クエリ式は、select 句またはgroup句のいずれかで終了する必要があります。
次の例は、クエリ式での単純な select 句を示したものです。
       class SelectSample1
{
    static void Main()
    {
} }
//Create the data source
List<int> Scores = new List<int>() { 97, 92, 81, 60 };
// Create the query.
IEnumerable<int> queryHighScores =
    from score in Scores
    where score > 80
    select score;
// Execute the query.
foreach (int i in queryHighScores)
{
    Console.Write(i + " ");
}
//Output: 97 92 81
  select
  select
 句によって生成されるシーケンスの型は、クエリ変数 queryHighScores の型を決定します。最も簡単なケースでは、
句は、範囲変数だけを指定します。 これにより、返されるシーケンスにデータ ソースと同じ型の要素が含まれます。 詳 細については、「LINQクエリ操作での型の関係」を参照してください。ただし、select 句は、ソースデータを新しい型に変換 する (または 投影 する) ための強力なメカニズムも提供します。 詳細については、「LINQ によるデータ変換 (C#)」を参照してく ださい。
例
次の例は、 句のすべての異なる形式を示しています。 各クエリで、 select 句と クエリ変数 ( studentQuery1 、 など) の型の関係に注意してください。
    select
 studentQuery2
select 句 (C# リファレンス) 2021/03/06 • • Edit Online
     class SelectSample2
{
    // Define some classes
    public class Student
    {
        public string First { get; set; }
        public string Last { get; set; }
        public int ID { get; set; }
        public List<int> Scores;
        public ContactInfo GetContactInfo(SelectSample2 app, int id)
        {
            ContactInfo cInfo =
                (from ci in app.contactList
                where ci.ID == id
                select ci)
                .FirstOrDefault();

  60}}, 39}},
        return cInfo;
    }
    public override string ToString()
    {
        return First + " " + Last + ":" + ID;
    }
}
public class ContactInfo
{
    public int ID { get; set; }
    public string Email { get; set; }
    public string Phone { get; set; }
    public override string ToString() { return Email + "," + Phone; }
}
public class ScoreInfo
{
    public double Average { get; set; }
    public int ID { get; set; }
}
// The primary data source
List<Student> students = new List<Student>()
{
     new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int>() {97, 92, 81,
     new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int>() {75, 84, 91,
     new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int>() {88, 94, 65, 91}},
     new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int>() {97, 89, 85, 82}},
};
// Separate data source for contact info.
List<ContactInfo> contactList = new List<ContactInfo>()
{
    new ContactInfo {ID=111, Email="SvetlanO@Contoso.com", Phone="206-555-0108"},
    new ContactInfo {ID=112, Email="ClaireO@Contoso.com", Phone="206-555-0298"},
    new ContactInfo {ID=113, Email="SvenMort@Contoso.com", Phone="206-555-1130"},
    new ContactInfo {ID=114, Email="CesarGar@Contoso.com", Phone="206-555-0521"}
};
static void Main(string[] args)
{
    SelectSample2 app = new SelectSample2();
    // Produce a filtered sequence of unmodified Students.
    IEnumerable<Student> studentQuery1 =
        from student in app.students
        where student.ID > 111
        select student;
    Console.WriteLine("Query1: select range_variable");
    foreach (Student s in studentQuery1)
    {
        Console.WriteLine(s.ToString());
    }
    // Produce a filtered sequence of elements that contain
    // only one property of each Student.
    IEnumerable<String> studentQuery2 =
        from student in app.students
        where student.ID > 111
        select student.Last;
    Console.WriteLine("\r\n studentQuery2: select range_variable.Property");
    foreach (string s in studentQuery2)
  
foreach (string s in studentQuery2)
  {
    Console.WriteLine(s);
}
// Produce a filtered sequence of objects created by
// a method call on each Student.
IEnumerable<ContactInfo> studentQuery3 =
    from student in app.students
    where student.ID > 111
    select student.GetContactInfo(app, student.ID);
Console.WriteLine("\r\n studentQuery3: select range_variable.Method");
foreach (ContactInfo ci in studentQuery3)
{
    Console.WriteLine(ci.ToString());
}
// Produce a filtered sequence of ints from
// the internal array inside each Student.
IEnumerable<int> studentQuery4 =
    from student in app.students
    where student.ID > 111
    select student.Scores[0];
Console.WriteLine("\r\n studentQuery4: select range_variable[index]");
foreach (int i in studentQuery4)
{
    Console.WriteLine("First score = {0}", i);
}
// Produce a filtered sequence of doubles
// that are the result of an expression.
IEnumerable<double> studentQuery5 =
    from student in app.students
    where student.ID > 111
    select student.Scores[0] * 1.1;
Console.WriteLine("\r\n studentQuery5: select expression");
foreach (double d in studentQuery5)
{
    Console.WriteLine("Adjusted first score = {0}", d);
}
// Produce a filtered sequence of doubles that are
// the result of a method call.
IEnumerable<double> studentQuery6 =
    from student in app.students
    where student.ID > 111
    select student.Scores.Average();
Console.WriteLine("\r\n studentQuery6: select expression2");
foreach (double d in studentQuery6)
{
    Console.WriteLine("Average = {0}", d);
}
// Produce a filtered sequence of anonymous types
// that contain only two properties from each Student.
var studentQuery7 =
    from student in app.students
    where student.ID > 111
    select new { student.First, student.Last };
Console.WriteLine("\r\n studentQuery7: select new anonymous type");
foreach (var item in studentQuery7)
{
    Console.WriteLine("{0}, {1}", item.Last, item.First);
}
  
          // Produce a filtered sequence of named objects that contain
        // a method return value and a property from each Student.
        // Use named types if you need to pass the query variable
        // across a method boundary.
        IEnumerable<ScoreInfo> studentQuery8 =
            from student in app.students
            where student.ID > 111
            select new ScoreInfo
            {
                Average = student.Scores.Average(),
                ID = student.ID
};
        Console.WriteLine("\r\n studentQuery8: select new named type");
        foreach (ScoreInfo si in studentQuery8)
        {
            Console.WriteLine("ID = {0}, Average = {1}", si.ID, si.Average);
        }
        // Produce a filtered sequence of students who appear on a contact list
        // and whose average is greater than 85.
        IEnumerable<ContactInfo> studentQuery9 =
            from student in app.students
            where student.Scores.Average() > 85
            join ci in app.contactList on student.ID equals ci.ID
            select ci;
        Console.WriteLine("\r\n studentQuery9: select result of join clause");
        foreach (ContactInfo ci in studentQuery9)
        {
            Console.WriteLine("ID = {0}, Email = {1}", ci.ID, ci.Email);
        }
        // Keep the console window open in debug mode
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
        }
}
/* Output
    Query1: select range_variable
    Claire O'Donnell:112
    Sven Mortensen:113
    Cesar Garcia:114
    studentQuery2: select range_variable.Property
    O'Donnell
    Mortensen
    Garcia
    studentQuery3: select range_variable.Method
    ClaireO@Contoso.com,206-555-0298
    SvenMort@Contoso.com,206-555-1130
    CesarGar@Contoso.com,206-555-0521
    studentQuery4: select range_variable[index]
    First score = 75
    First score = 88
    First score = 97
    studentQuery5: select expression
    Adjusted first score = 82.5
    Adjusted first score = 96.8
    Adjusted first score = 106.7
    studentQuery6: select expression2
    Average = 72.25
    Average = 84.5
    Average = 88.25
  
         前の例の studentQuery8 に示すように、返されるシーケンスの要素にソース要素のプロパティのサブセットのみを含めることもで きます。 返されるシーケンスをできるだけ小さく維持することで、メモリ要件を減らし、クエリの実行の速度を向上させることができ ます。 これを行うには、 select 句で匿名型を作成し、オブジェクト初期化子を使用して、ソース要素からの適切なプロパティ で初期化します。 これを行う方法の例については、「オブジェクト初期化子とコレクション初期化子」を参照してください。
注釈
コンパイル時に、 select 句は、Select標準クエリ演算子へのメソッドの呼び出しに変換されます。
関連項目
C# リファレンス
クエリ キーワード (LINQ)
from 句
partial (メソッド) (C# リファレンス) 匿名型
C# での LINQ
統合言語クエリ (LINQ)
     */
studentQuery7: select new anonymous type
O'Donnell, Claire
Mortensen, Sven
Garcia, Cesar
studentQuery8: select new named type
ID = 112, Average = 72.25
ID = 113, Average = 84.5
ID = 114, Average = 88.25
studentQuery9: select result of join clause
ID = 114, Email = CesarGar@Contoso.com
 
       group 句は、グループのキー値に一致する0個以上の項目を含むIGrouping<TKey,TElement>オブジェクトのシーケンスを 返します。 たとえば、各文字列の最初の文字に基づいて文字列のシーケンスをグループ化することができます。 この場合、最 初の文字がキーで、型はcharであり、各IGrouping<TKey,TElement>オブジェクトの Key プロパティに格納されています。 コンパイラは、キーの型を推論します。
次の例で示すように、クエリ式は group 句で終了できます。
各グループで追加のクエリ操作を実行する場合、into コンテキスト キーワードを使用して一時的な識別子を指定できます。 into を使用する場合、次の抜粋に示すように、クエリを続行し、最終的には select ステートメントまたは別の group 句
でそれを終了する必要があります。
この記事の「例」のセクションでは、 into を含む場合と含まない場合の group の使用方法の完全な例があります。 グループ クエリの結果を列挙する
group クエリによって生成されるIGrouping<TKey,TElement>オブジェクトは基本的には、リストのリストであるため、各グルー プのアイテムにアクセスするには、入れ子になった foreach ループを使用する必要があります。 外側のループがグループ キーを 反復処理し、内側のループがグループ自体の各項目を反復処理します。 グループには、キーがある場合はありますが、要素は ありません。次に、前のコード例でクエリを実行する foreach ループを示します。
    // Query variable is an IEnumerable<IGrouping<char, Student>>
var studentQuery1 =
    from student in students
    group student by student.Last[0];
      // Group students by the first letter of their last name
// Query variable is an IEnumerable<IGrouping<char, Student>>
var studentQuery2 =
    from student in students
    group student by student.Last[0] into g
    orderby g.Key
    select g;
      // Iterate group items with a nested foreach. This IGrouping encapsulates
// a sequence of Student objects, and a Key of type char.
// For convenience, var can also be used in the foreach statement.
foreach (IGrouping<char, Student> studentGroup in studentQuery2)
{
     Console.WriteLine(studentGroup.Key);
     // Explicit type for student could also be used here.
     foreach (var student in studentGroup)
     {
         Console.WriteLine("   {0}, {1}", student.Last, student.First);
     }
}
 キーの種類
グループ キーは、文字列、組み込みの数値型、またはユーザー定義の名前付きの型または匿名型など、任意の型にすること
group 句 (C# リファレンス) 2021/03/06 • • Edit Online
 
 ができます。 文字列でグループ化する
前のコード例では、 char を使用していました。 姓を完全に指定するなど、簡単に代わりに文字列のキーを指定できます。
ブールでグループ化する
次の例では、結果を2つのグループに分割するためのキー用のブール値の用途を示します。値は group 句のサブ式で生成 されることに注意してください。
    // Same as previous example except we use the entire last name as a key.
// Query variable is an IEnumerable<IGrouping<string, Student>>
var studentQuery3 =
    from student in students
    group student by student.Last;
 
    数値の範囲でグループ化する 次の例では、パーセンタイルの範囲を示す数値のグループキーを作成する式を使用しています。 group 句でメソッドを2度
  class GroupSample1
{
    // The element type of the data source.
    public class Student
    {
        public string First { get; set; }
        public string Last { get; set; }
        public int ID { get; set; }
        public List<int> Scores;
}
    public static List<Student> GetStudents()
    {
60}},
} }
    // Use a collection initializer to create the data source. Note that each element
    //  in the list contains an inner sequence of scores.
    List<Student> students = new List<Student>
    {
       new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int> {97, 72, 81,
       new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int> {75, 84, 91, 39}},
       new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int> {99, 89, 91, 95}},
       new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int> {72, 81, 65, 84}},
       new Student {First="Debra", Last="Garcia", ID=115, Scores= new List<int> {97, 89, 85, 82}}
};
    return students;
}
static void Main()
{
    // Obtain the data source.
    List<Student> students = GetStudents();
    // Group by true or false.
    // Query variable is an IEnumerable<IGrouping<bool, Student>>
    var booleanGroupQuery =
        from student in students
        group student by student.Scores.Average() >= 80; //pass or fail!
    // Execute the query and access items in each group
    foreach (var studentGroup in booleanGroupQuery)
    {
        Console.WriteLine(studentGroup.Key == true ? "High averages" : "Low averages");
        foreach (var student in studentGroup)
        {
            Console.WriteLine("   {0}, {1}:{2}", student.Last, student.First, student.Scores.Average());
        }
}
    // Keep the console window open in debug mode.
    Console.WriteLine("Press any key to exit.");
    Console.ReadKey();
/* Output:
  Low averages
   Omelchenko, Svetlana:77.5
   O'Donnell, Claire:72.25
   Garcia, Cesar:75.5
  High averages
   Mortensen, Sven:93.5
   Garcia, Debra:88.25
*/

  呼び出さなくて済むように、メソッド呼び出しの結果を格納する便利な場所として let を使用できます。 クエリ式でメソッドを安 全に使用する方法の詳細については、「クエリ式の例外の処理」を参照してください。
    class GroupSample2
{
    // The element type of the data source.
    public class Student
    {
        public string First { get; set; }
        public string Last { get; set; }
        public int ID { get; set; }
        public List<int> Scores;
}
    public static List<Student> GetStudents()
    {
60}},
} }
    // Use a collection initializer to create the data source. Note that each element
    //  in the list contains an inner sequence of scores.
    List<Student> students = new List<Student>
    {
       new Student {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int> {97, 72, 81,
       new Student {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int> {75, 84, 91, 39}},
       new Student {First="Sven", Last="Mortensen", ID=113, Scores= new List<int> {99, 89, 91, 95}},
       new Student {First="Cesar", Last="Garcia", ID=114, Scores= new List<int> {72, 81, 65, 84}},
       new Student {First="Debra", Last="Garcia", ID=115, Scores= new List<int> {97, 89, 85, 82}}
};
    return students;
}
// This method groups students into percentile ranges based on their
// grade average. The Average method returns a double, so to produce a whole
// number it is necessary to cast to int before dividing by 10.
static void Main()
{
    // Obtain the data source.
    List<Student> students = GetStudents();
    // Write the query.
    var studentQuery =
        from student in students
        let avg = (int)student.Scores.Average()
        group student by (avg / 10) into g
        orderby g.Key
        select g;
    // Execute the query.
    foreach (var studentGroup in studentQuery)
    {
        int temp = studentGroup.Key * 10;
        Console.WriteLine("Students with an average between {0} and {1}", temp, temp + 10);
        foreach (var student in studentGroup)
        {
            Console.WriteLine("   {0}, {1}:{2}", student.Last, student.First, student.Scores.Average());
        }
}
    // Keep the console window open in debug mode.
    Console.WriteLine("Press any key to exit.");
    Console.ReadKey();
/* Output:
     Students with an average between 70 and 80
       Omelchenko, Svetlana:77.5
       O'Donnell, Claire:72.25
Garcia, Cesar:75.5

      複合キーでグループ化する
1 つ以上のキーを使用して要素をグループ化するには、複合キーを使用します。 複合キーは、キー要素を保持する、匿名型 または名前付きの型を使用して作成できます。 次の例では、クラス Person が、 surname と city という名前のメンバーで 宣言されていると想定しています。 group 句により、同じ名前と同じ市の人物のセットごとに、別のグループが作成されます。
クエリ変数を別のメソッドに渡す場合には、名前付きの型を使用します。 キーの自動実装プロパティを使用して特殊クラスを作 成し、Equals メソッドと GetHashCode メソッドをオーバーライドします。 これらのメソッドを厳密にオーバーライドする必要がな い構造体を使用することも可能です。 詳細については、「自動実装するプロパティを使用して簡易クラスを実装する方法」と 「ディレクトリ ツリーで重複するファイルを照会する方法」を参照してください。 後述の記事には、名前付きの型を複合キーで使 用する方法のコード例があります。
例
次の例では、グループにその他のクエリ ロジックが適用されていない場合、ソース データをグループに並べる標準的なパターンを 示します。 これは連結なしのグループ化と呼ばれます。 文字列の配列の要素は、最初の文字でグループ化されます。 クエリの 結果は、型 char のパブリック Key プロパティを含むIGrouping<TKey,TElement>型とグループに各項目を含む IEnumerable<T> コレクションです。
group 句の結果は、シーケンスのシーケンスです。そのため、返される各グループ内の各要素にアクセスするには、次の例のよ うに、グループキーを反復処理するループ内で入れ子になった foreach ループを使用します。
    group person by new {name = person.surname, city = person.city};
        Garcia, Cesar:75.5
    Students with an average between 80 and 90
      Garcia, Debra:88.25
    Students with an average between 90 and 100
      Mortensen, Sven:93.5
*/
    
    例
この例では、作成後に、into と共にcontinuationを使用し、グループに追加のロジックを実行する方法を示します。詳しく は、「into」をご覧ください。 次の例では、キー値が母音であるものだけを選択するために各グループに問い合せを行います。
  class GroupExample1
{
    static void Main()
    {
        // Create a data source.
        string[] words = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese" };
        // Create the query.
        var wordGroups =
            from w in words
            group w by w[0];
        // Execute the query.
        foreach (var wordGroup in wordGroups)
        {
            Console.WriteLine("Words that start with the letter '{0}':", wordGroup.Key);
            foreach (var word in wordGroup)
            {
                Console.WriteLine(word);
            }
}
        // Keep the console window open in debug mode
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
} }
/* Output:
      Words that start with the letter 'b':
blueberry
        banana
      Words that start with the letter 'c':
chimpanzee
        cheese
      Words that start with the letter 'a':
abacus
apple */

              注釈
コンパイル時に group 句がGroupByメソッドの呼び出しに変換されます。
関連項目
IGrouping<TKey,TElement> GroupBy
ThenBy
ThenByDescending
クエリ キーワード
統合言語クエリ (LINQ) 入れ子になったグループの作成 クエリ結果のグループ化 グループ化操作でのサブクエリの実行
  class GroupClauseExample2
{
    static void Main()
    {
        // Create the data source.
        string[] words2 = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese", "elephant",
"umbrella", "anteater" };
        // Create the query.
        var wordGroups2 =
            from w in words2
            group w by w[0] into grps
            where (grps.Key == 'a' || grps.Key == 'e' || grps.Key == 'i'
                   || grps.Key == 'o' || grps.Key == 'u')
            select grps;
        // Execute the query.
        foreach (var wordGroup in wordGroups2)
        {
            Console.WriteLine("Groups that start with a vowel: {0}", wordGroup.Key);
            foreach (var word in wordGroup)
            {
                Console.WriteLine("   {0}", word);
            }
}
        // Keep the console window open in debug mode
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
} }
/* Output:
    Groups that start with a vowel: a
        abacus
        apple
        anteater
    Groups that start with a vowel: e
        elephant
    Groups that start with a vowel: u
        umbrella
*/

      into コンテキストキーワードは、group、join、またはselect句の結果を新しい識別子に保存するための一時的な識別子 を作成するために使用できます。この識別子自体を追加のクエリコマンドのジェネレーターにすることができます。 group また は select 句で使用する場合、新しい識別子の使用は継続と呼ばれることもあります。
例
次の例では、 into キーワードを使用して、推定の型 IGrouping を持つ一時的な識別子 fruitGroup を有効にする方法 を示します。 識別子を使用すると、各グループに対して Count メソッドを呼び出し、2 つ以上の単語を含むグループのみを選 択することができます。
       class IntoSample1
{
    static void Main()
    {
} }
// Create a data source.
string[] words = { "apples", "blueberries", "oranges", "bananas", "apricots"};
// Create the query.
var wordGroups1 =
    from w in words
    group w by w[0] into fruitGroup
    where fruitGroup.Count() >= 2
    select new { FirstLetter = fruitGroup.Key, Words = fruitGroup.Count() };
// Execute the query. Note that we only iterate over the groups,
// not the items in each group
foreach (var item in wordGroups1)
{
    Console.WriteLine(" {0} has {1} elements.", item.FirstLetter, item.Words);
}
// Keep the console window open in debug mode
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
/* Output:
   a has 2 elements.
   b has 2 elements.
*/
 group 句での into の使用は、各グループに対して追加のクエリ操作を実行する場合にのみ必要です。詳しくは、「group 句」をご覧ください。
join 句での into の使用例については、「join句」を参照してください。 関連項目
クエリ キーワード (LINQ) C# での LINQ
group 句
into (C# リファレンス) 2021/03/06 • • Edit Online
 
     クエリ式では、orderby 句によって返されるシーケンスまたはサブシーケンス(グループ)が昇順または降順で並べ替えられます。 2 番目の並べ替え操作を 1 つ以上実行するために、複数のキーを指定できます。 並べ替えは、要素の型の既定の比較演 算子によって実行されます。 既定の並べ替え順は昇順です。 カスタムの比較演算子を指定することもできます。 ただしこれ は、メソッド ベースの構文を使用する場合にのみ使用できます。 詳細については、データの並べ替え に関するページを参照し てください。
例
次の例では、最初のクエリが A から始まるアルファベット順で単語を並べ替え、2 番目のクエリが同じ単語を降順で並べ替えま す(ascending キーワードは、既定の並べ替え値で、省略可能です)。
 orderby 句 (C# リファレンス) 2020/11/02 • • Edit Online
 
    例
次の例では、学生の姓で最初の並べ替えを実行し、学生の名で 2 番目の並べ替えを実行します。
  class OrderbySample1
{
    static void Main()
    {
} }
/* Output:
Ascending:
apple
blueberry
cherry
Descending:
cherry
blueberry
apple
*/
// Create a delicious data source.
string[] fruits = { "cherry", "apple", "blueberry" };
// Query for ascending sort.
IEnumerable<string> sortAscendingQuery =
    from fruit in fruits
    orderby fruit //"ascending" is default
    select fruit;
// Query for descending sort.
IEnumerable<string> sortDescendingQuery =
    from w in fruits
    orderby w descending
    select w;
// Execute the query.
Console.WriteLine("Ascending:");
foreach (string s in sortAscendingQuery)
{
    Console.WriteLine(s);
}
// Execute the query.
Console.WriteLine(Environment.NewLine + "Descending:");
foreach (string s in sortDescendingQuery)
{
    Console.WriteLine(s);
}
// Keep the console window open in debug mode.
Console.WriteLine("Press any key to exit.");
Console.ReadKey();
    class OrderbySample2
{
    // The element type of the data source.
    public class Student
    {
        public string First { get; set; }
        public string Last { get; set; }
        public int ID { get; set; }
    }
    public static List<Student> GetStudents()

  } }
{
    // Use a collection initializer to create the data source. Note that each element
    //  in the list contains an inner sequence of scores.
    List<Student> students = new List<Student>
    {
       new Student {First="Svetlana", Last="Omelchenko", ID=111},
       new Student {First="Claire", Last="O'Donnell", ID=112},
       new Student {First="Sven", Last="Mortensen", ID=113},
       new Student {First="Cesar", Last="Garcia", ID=114},
       new Student {First="Debra", Last="Garcia", ID=115}
    };
    return students;
}
static void Main(string[] args)
{
    // Create the data source.
    List<Student> students = GetStudents();
    // Create the query.
    IEnumerable<Student> sortedStudents =
        from student in students
        orderby student.Last ascending, student.First ascending
        select student;
    // Execute the query.
    Console.WriteLine("sortedStudents:");
    foreach (Student student in sortedStudents)
        Console.WriteLine(student.Last + " " + student.First);
    // Now create groups and sort the groups. The query first sorts the names
    // of all students so that they will be in alphabetical order after they are
    // grouped. The second orderby sorts the group keys in alpha order.
    var sortedGroups =
        from student in students
        orderby student.Last, student.First
        group student by student.Last[0] into newGroup
        orderby newGroup.Key
        select newGroup;
    // Execute the query.
    Console.WriteLine(Environment.NewLine + "sortedGroups:");
    foreach (var studentGroup in sortedGroups)
    {
        Console.WriteLine(studentGroup.Key);
        foreach (var student in studentGroup)
        {
            Console.WriteLine("   {0}, {1}", student.Last, student.First);
        }
}
    // Keep the console window open in debug mode
    Console.WriteLine("Press any key to exit.");
    Console.ReadKey();
/* Output:
sortedStudents:
Garcia Cesar
Garcia Debra
Mortensen Sven
O'Donnell Claire
Omelchenko Svetlana
sortedGroups:
G
   Garcia, Cesar
   Garcia, Debra
M
  
       M
 注釈
コンパイル時に、orderby 句はOrderByメソッドの呼び出しに変換されます。 orderby 句内の複数のキーは、ThenByメ ソッドの呼び出しに変換されます。
関連項目
C# リファレンス
クエリ キーワード (LINQ) C# での LINQ
group 句 統合言語クエリ (LINQ)
        Mortensen, Sven
O
   O'Donnell, Claire
   Omelchenko, Svetlana
*/
 
    join 句は、オブジェクトモデル内での直接リレーションシップがない、さまざまなソースシーケンスの要素を関連付ける際に役 立ちます。 唯一の要件は、等価性を比較できるいくつかの値が各ソース内の要素間で共有されていることです。 たとえば、食 品販売会社には特定の商品についての供給元のリストと購入者のリストがあります。 join 句は、たとえば指定された地域の すべての供給元および購入者のリストを作成するために使用できます。
join 句では、2つのソースシーケンスを入力として受け取ります。各シーケンスの要素は、もう一方のシーケンスの対応する プロパティと比較できるプロパティであるか、そのプロパティを含む要素であることが必要です。 join 句では、特殊な equals キーワードを使用して、指定されたキーの等価性が比較されます。 join 句によって実行される結合はすべてが等結合です。
join 句の出力形式は、実行する結合の種類によって異なります。最も一般的な3種類の結合を以下に示します。 内部結合
グループ結合 左外部結合
内部結合
次の例は、単純な内部等結合を示しています。 このクエリによって "商品名/カテゴリ" のペアからなるフラットなシーケンスが生 成されます。複数の要素に同じカテゴリ文字列が含まれます。 categories の要素に一致する products がない場合、その カテゴリは結果に含まれません。
詳細については、「内部結合の実行」を参照してください。 グループ結合
into 式を使用した join 句はグループ結合と呼ばれます。
グループ結合によって生成される階層形式の結果シーケンスでは、左側のソース シーケンスの要素と一致する右側のソース シーケンスの 1 つ以上の要素が関連付けられています。 リレーショナル データベースにおいてグループ結合に相当する用語はあ りません。グループ結合とは、本質的にはオブジェクト配列のシーケンスです。
右側のソースシーケンスの要素に左側のソースの要素と一致するものが見つからない場合は、その項目に対して join 句に よって空の配列が生成されます。 つまりグループ結合は、結果シーケンスがグループに整理されることを除けば、基本的には内 部等結合です。
グループ結合の結果を選択しただけでは、項目にアクセスすることはできでも、その照合に使用するキーを特定することはできま せん。 そのため、通常はグループ結合の結果を選択し、前の例に示したようなキー名を含む新しい型にするとさらに便利になり ます。
       var innerJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID
    select new { ProductName = prod.Name, Category = category.Name }; //produces flat sequence
     var innerGroupJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    select new { CategoryName = category.Name, Products = prodGroup };
 join 句 (C# リファレンス) 2020/11/02 • • Edit Online
 
     また、当然ながらグループ結合の結果を別のサブクエリのジェネレーターとして使用することもできます。
    var innerGroupJoinQuery2 =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    from prod2 in prodGroup
    where prod2.UnitPrice > 2.50M
    select prod2;
 詳細については、「グループ結合の実行」を参照してください。 左外部結合
左外部結合では、右側のシーケンスに一致する要素がなくても、左側のソース シーケンスのすべての要素が返されます。 LINQで左外部結合を実行するには、DefaultIfEmpty メソッドとグループ結合を組み合わせて使用し、左側の要素に一致 するものがない場合に既定の右側の要素を生成するように指定します。参照型用の既定値として null を使用するか、 ユーザー定義の既定の型を指定できます。 次の例では、ユーザー定義の既定の型を示しています。
詳細については、「左外部結合の実行」を参照してください。 等値演算子
join 句は等結合を実行します。つまり、基準にできるのは2つのキーの等価性に関する照合のみです。"~より大きい"や "等しくない" など、他の種類の比較はサポートされていません。 すべての結合が等結合であることを明確化するために、 join 句では == 演算子ではなく equals キーワードを使用します。 equals キーワードは join 句でしか使用できず、また == 演算子とは 1 つの重要な点で異なります。 を指定すると、左側のキーでは外部のソース シーケンス、右側のキーで は内部のソースが使用されます。 外部のソースは の左側のスコープ内、内部のソース シーケンスは右側のスコープ内 でのみ使用できます。
非等結合
複数の from 句を使用して新しいシーケンスをクエリに個別に導入することで、非等結合、クロス結合、およびその他のカスタ
ム結合操作を実行できます。 詳細については、「カスタム結合操作の実行」を参照してください。 オブジェクト コレクションとリレーショナル テーブルでの結合の比較
LINQ クエリ式での結合操作は、オブジェクト コレクションに対して実行されます。 2 つのリレーショナル テーブルの "結合" とまっ たく同じ方法でオブジェクト コレクションを結合することはできません。 LINQ では、2 つのソース シーケンスがリレーションシップに よって関連付けられていない場合にのみ明示的な join 句が必要になります。LINQtoSQLを使用する場合、外部キー テーブルはオブジェクト モデル内でプライマリ テーブルのプロパティとして表されます。 たとえば Northwind データベースでは、 Customer テーブルに Orders テーブルとの外部キー リレーションシップがあります。 テーブルをオブジェクト モデルに割り当てる と、Customer クラスには、その Customer に関連付けられた Orders のコレクションを含む Orders プロパティが含まれます。 実質的には、既に結合が実行されていることになります。
LINQ to SQL を使用した関連テーブル間でのクエリの詳細については、「方法: データベース リレーションシップを割り当てる」を 参照してください。
     var leftOuterJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    from item in prodGroup.DefaultIfEmpty(new Product { Name = String.Empty, CategoryID = 0 })
    select new { CatName = category.Name, ProdName = item.Name };
    複合キー
equals
 equals

  複合キーを使用すると、複数の値の等価性をテストできます。 詳細については、「複合キーを使用した結合」を参照してくださ い。 複合キーは、 group 句でも使用できます。
例
次の例では、同じ照合キーを使用し、同じデータ ソースでの内部結合、グループ結合、左外部結合の結果を比較していま す。 これらの例には、結果をコンソールにわかりやすく表示するためのコードがいくつか追加されています。
    class JoinDemonstration
{
#region Data
    class Product
    {
        public string Name { get; set; }
        public int CategoryID { get; set; }
    }
    class Category
    {
        public string Name { get; set; }
        public int ID { get; set; }
    }
    // Specify the first data source.
    List<Category> categories = new List<Category>()
    {
        new Category {Name="Beverages", ID=001},
        new Category {Name="Condiments", ID=002},
        new Category {Name="Vegetables", ID=003},
        new Category {Name="Grains", ID=004},
        new Category {Name="Fruit", ID=005}
    };
    // Specify the second data source.
    List<Product> products = new List<Product>()
   {
      new Product {Name="Cola",  CategoryID=001},
      new Product {Name="Tea",  CategoryID=001},
      new Product {Name="Mustard", CategoryID=002},
      new Product {Name="Pickles", CategoryID=002},
      new Product {Name="Carrots", CategoryID=003},
      new Product {Name="Bok Choy", CategoryID=003},
      new Product {Name="Peaches", CategoryID=005},
      new Product {Name="Melons", CategoryID=005},
    };
    #endregion
    static void Main(string[] args)
    {
        JoinDemonstration app = new JoinDemonstration();
        app.InnerJoin();
        app.GroupJoin();
        app.GroupInnerJoin();
        app.GroupJoin3();
        app.LeftOuterJoin();
        app.LeftOuterJoin2();
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
}
    void InnerJoin()
    {

          // Create the query that selects
        // a property from each element.
        var innerJoinQuery =
           from category in categories
           join prod in products on category.ID equals prod.CategoryID
           select new { Category = category.ID, Product = prod.Name };
        Console.WriteLine("InnerJoin:");
        // Execute the query. Access results
        // with a simple foreach statement.
        foreach (var item in innerJoinQuery)
        {
            Console.WriteLine("{0,-10}{1}", item.Product, item.Category);
        }
        Console.WriteLine("InnerJoin: {0} items in 1 group.", innerJoinQuery.Count());
        Console.WriteLine(System.Environment.NewLine);
    }
    void GroupJoin()
    {
        // This is a demonstration query to show the output
        // of a "raw" group join. A more typical group join
        // is shown in the GroupInnerJoin method.
        var groupJoinQuery =
           from category in categories
           join prod in products on category.ID equals prod.CategoryID into prodGroup
           select prodGroup;
        // Store the count of total items (for demonstration only).
        int totalItems = 0;
        Console.WriteLine("Simple GroupJoin:");
        // A nested foreach statement is required to access group items.
        foreach (var prodGrouping in groupJoinQuery)
        {
            Console.WriteLine("Group:");
            foreach (var item in prodGrouping)
            {
                totalItems++;
                Console.WriteLine("   {0,-10}{1}", item.Name, item.CategoryID);
            }
}
        Console.WriteLine("Unshaped GroupJoin: {0} items in {1} unnamed groups", totalItems,
groupJoinQuery.Count());
        Console.WriteLine(System.Environment.NewLine);
    }
    void GroupInnerJoin()
    {
        var groupJoinQuery2 =
            from category in categories
            orderby category.ID
            join prod in products on category.ID equals prod.CategoryID into prodGroup
            select new
            {
                Category = category.Name,
                Products = from prod2 in prodGroup
                           orderby prod2.Name
                           select prod2
};
        //Console.WriteLine("GroupInnerJoin:");
        int totalItems = 0;
        Console.WriteLine("GroupInnerJoin:");
        foreach (var productGroup in groupJoinQuery2)
        {
Console.WriteLine(productGroup.Category);
  
              foreach (var prodItem in productGroup.Products)
            {
                totalItems++;
                Console.WriteLine("  {0,-10} {1}", prodItem.Name, prodItem.CategoryID);
            }
}
        Console.WriteLine("GroupInnerJoin: {0} items in {1} named groups", totalItems,
groupJoinQuery2.Count());
        Console.WriteLine(System.Environment.NewLine);
    }
    void GroupJoin3()
    {
        var groupJoinQuery3 =
            from category in categories
            join product in products on category.ID equals product.CategoryID into prodGroup
            from prod in prodGroup
            orderby prod.CategoryID
            select new { Category = prod.CategoryID, ProductName = prod.Name };
        //Console.WriteLine("GroupInnerJoin:");
        int totalItems = 0;
        Console.WriteLine("GroupJoin3:");
        foreach (var item in groupJoinQuery3)
        {
            totalItems++;
            Console.WriteLine("   {0}:{1}", item.ProductName, item.Category);
        }
        Console.WriteLine("GroupJoin3: {0} items in 1 group", totalItems);
        Console.WriteLine(System.Environment.NewLine);
    }
    void LeftOuterJoin()
    {
        // Create the query.
        var leftOuterQuery =
           from category in categories
           join prod in products on category.ID equals prod.CategoryID into prodGroup
           select prodGroup.DefaultIfEmpty(new Product() { Name = "Nothing!", CategoryID = category.ID });
        // Store the count of total items (for demonstration only).
        int totalItems = 0;
        Console.WriteLine("Left Outer Join:");
        // A nested foreach statement  is required to access group items
        foreach (var prodGrouping in leftOuterQuery)
        {
            Console.WriteLine("Group:");
            foreach (var item in prodGrouping)
            {
                totalItems++;
                Console.WriteLine("  {0,-10}{1}", item.Name, item.CategoryID);
            }
        }
        Console.WriteLine("LeftOuterJoin: {0} items in {1} groups", totalItems, leftOuterQuery.Count());
        Console.WriteLine(System.Environment.NewLine);
}
    void LeftOuterJoin2()
    {
        // Create the query.
        var leftOuterQuery2 =
           from category in categories
           join prod in products on category.ID equals prod.CategoryID into prodGroup
           from item in prodGroup.DefaultIfEmpty()
  
from item in prodGroup.DefaultIfEmpty()
  select new { Name = item == null ? "Nothing!" : item.Name, CategoryID = category.ID };
        Console.WriteLine("LeftOuterJoin2: {0} items in 1 group", leftOuterQuery2.Count());
        // Store the count of total items
        int totalItems = 0;
        Console.WriteLine("Left Outer Join 2:");
        // Groups have been flattened.
        foreach (var item in leftOuterQuery2)
        {
            totalItems++;
            Console.WriteLine("{0,-10}{1}", item.Name, item.CategoryID);
        }
        Console.WriteLine("LeftOuterJoin2: {0} items in 1 group", totalItems);
    }
} /*Output:
InnerJoin:
Cola      1
Tea       1
Mustard   2
Pickles   2
Carrots   3
Bok Choy  3
Peaches   5
Melons    5
InnerJoin: 8 items in 1 group.
Unshaped GroupJoin:
Group:
Cola 1
Tea 1 Group:
Mustard 2
    Pickles   2
Group:
Carrots 3
    Bok Choy  3
Group:
Group:
    Peaches   5
    Melons    5
Unshaped GroupJoin: 8 items in 5 unnamed groups
GroupInnerJoin:
Beverages
Cola 1
    Tea        1
Condiments
Mustard 2
    Pickles    2
Vegetables
Bok Choy 3
    Carrots    3
Grains
Fruit
    Melons     5
    Peaches    5
GroupInnerJoin: 8 items in 5 named groups
GroupJoin3:
    Cola:1
Tea:1
  Mustard:2

           Mustard:2
    注釈
join 句の後に into がない場合は、Joinメソッド呼び出しに変換されます。 join 句の後に into がある場合
は、GroupJoin メソッド呼び出しに変換されます。 関連項目
クエリ キーワード (LINQ)
統合言語クエリ (LINQ)
結合演算
group 句
左外部結合の実行
内部結合の実行
グループ化結合の実行
join 句の結果の順序指定
複合キーを使用した結合
Visual Studio 向けの互換性のあるデータベース システム
     Pickles:2
    Carrots:3
    Bok Choy:3
    Peaches:5
    Melons:5
GroupJoin3: 8 items in 1 group
Left Outer Join:
Group:
Cola 1
Tea 1 Group:
Mustard 2
    Pickles   2
Group:
Carrots 3
    Bok Choy  3
Group:
    Nothing!  4
Group:
Peaches 5
    Melons    5
LeftOuterJoin: 9 items in 5 groups
LeftOuterJoin2: 9 items in 1 group
Left Outer Join 2:
Cola      1
Tea       1
Mustard   2
Pickles   2
Carrots   3
Bok Choy  3
Nothing!  4
Peaches   5
Melons    5
LeftOuterJoin2: 9 items in 1 group
Press any key to exit.
*/

   クエリ式では、後続の句で使用するために、サブ式の結果を保存すると便利な場合があります。 let キーワードを使用してこ れを行うことができます。これにより新しい範囲変数を作成し、指定した式の結果でそれを初期化します。 値で初期化される と、範囲変数を使用して別の値を格納することはできません。 ただし、範囲変数がクエリ可能型を保持している場合、クエリを 実行できます。
例
次の例で、let は2つの方法で使用されます。
1. それ自体を照会できる列挙可能な型を作成します。
2. クエリが値変数 word に対して を 1 回のみ呼び出すことができるようにします。 let を使用しない場合、 where 句の各述語内で、 を呼び出す必要があります。
 ToLower
 ToLower
let 句 (C# リファレンス) 2020/11/02 • • Edit Online
 
         関連項目
C# リファレンス
クエリ キーワード (LINQ) C# での LINQ 統合言語クエリ (LINQ) クエリ式の例外の処理
  class LetSample1
{
    static void Main()
    {
        string[] strings =
        {
            "A penny saved is a penny earned.",
            "The early bird catches the worm.",
            "The pen is mightier than the sword."
};
        // Split the sentence into an array of words
        // and select those whose first letter is a vowel.
        var earlyBirdQuery =
            from sentence in strings
            let words = sentence.Split(' ')
            from word in words
            let w = word.ToLower()
            where w[0] == 'a' || w[0] == 'e'
                || w[0] == 'i' || w[0] == 'o'
                || w[0] == 'u'
            select word;
        // Execute the query.
        foreach (var v in earlyBirdQuery)
        {
            Console.WriteLine("\"{0}\" starts with a vowel", v);
        }
        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
} }
/* Output:
    "A" starts with a vowel
    "is" starts with a vowel
    "a" starts with a vowel
    "earned." starts with a vowel
    "early" starts with a vowel
    "is" starts with a vowel
*/

         ascending
  ascending
コンテキスト キーワードは、クエリ式の orderby 句で使用され、並べ替え順序として昇順を指定します。 は既定の並べ替え順序であるため、指定する必要はありません。
例
orderby句での ascending の使用例を次に示します。
関連項目
C# リファレンス C# での LINQ descending
     IEnumerable<string> sortAscendingQuery =
    from vegetable in vegetables
    orderby vegetable ascending
    select vegetable;
 ascending (C# リファレンス) 2020/11/02 • • Edit Online
 
         descending コンテキストキーワードは、クエリ式のorderby句で使用され、並べ替え順序として降順を指定します。 例
orderby句での descending の使用例を次に示します。
関連項目
C# リファレンス C# での LINQ ascending
     IEnumerable<string> sortDescendingQuery =
    from vegetable in vegetables
    orderby vegetable descending
    select vegetable;
 descending (C# リファレンス) 2020/11/02 • • Edit Online
 
     on コンテキストキーワードは、結合条件を指定するためにクエリ式のjoin句で使用されます。 例
join 句での on の使用例を次に示します。
関連項目
C# リファレンス 統合言語クエリ (LINQ)
    var innerJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID
    select new { ProductName = prod.Name, Category = category.Name };
 on (C# リファレンス) 2020/11/02 • • Edit Online
 
     equals コンテキストキーワードは、クエリ式の join 句で、2つのシーケンスの要素を比較するときに使用されます。詳細に ついては、「join 句」を参照してください。
例
join 句での equals キーワードの使用例を次に示します。
関連項目
統合言語クエリ (LINQ)
     var innerJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID
    select new { ProductName = prod.Name, Category = category.Name };
 equals (C# リファレンス) 2020/11/02 • • Edit Online
 
     by コンテキストキーワードは、クエリ式の group 句で使用され、返される項目をグループ化する方法を指定します。詳しく は、「group 句」をご覧ください。
例
group 句での by コンテキストキーワードの使用例を次に示します。ここでは、各学生の姓の1文字目に従って学生をグ ループ化するように指定しています。
関連項目
C# での LINQ
    var query = from student in students
            group student by student.LastName[0];
 by (C# リファレンス) 2020/11/02 • • Edit Online
 
         in キーワードは、次のコンテキストで使用されます。
ジェネリック インターフェイスとデリゲートのジェネリック型パラメーター パラメーター修飾子として。この場合、値ではなく参照で、メソッドに引数を渡すことができます。 foreach ステートメント。
LINQ クエリ式内の from 句。
LINQ クエリ式内の join 句。
関連項目
C# のキーワード C# リファレンス
in (C# リファレンス) 2020/11/02 • • Edit Online
 
               C# には多数の演算子が用意されています。 これらの多くは組み込み型によってサポートされており、これらの型の値を使用し て基本的な操作を実行できます。 これらの演算子には、次のグループが含まれます。
算術演算子では、数値オペランドを使用して算術演算が実行されます 比較演算子では、数値オペランドが比較されます
ブール論理演算子では、 bool オペランドに対して論理演算が実行されます ビットごとおよびシフト演算子では、整数型のオペランドに対してビットごとまたはシフト演算が実行されます 等値演算子では、そのオペランドが等しいかどうかが確認されます
通常は、これらの演算子をオーバーロードできます。つまり、ユーザー定義型のオペランドに対して演算子の動作を指定できま す。
最も単純な C# 式は、変数のリテラル (たとえば、整数と実数の数) と名前です。 演算子を使用すると、これらを複雑な式に 組み合わせることができます。 演算子の優先順位と結合規則によって、式の中の操作の実行順序が決まります。 かっこを使 用すれば、演算子の優先順位と結合規則によって定められた評価の順序を変更することができます。
次のコードでは、式の例が代入の右側にあります。
    int a, b, c;
a = 7;
b = a;
c = b++;
b = a + b * c;
c = a >= 100 ? b : c / 10;
a = (int)Math.Sqrt(b * b + c * c);
string s = "String literal";
char l = s[s.Length - 1];
var numbers = new List<int>(new[] { 1, 2, 3 });
b = numbers.FindLast(n => n > 1);
 通常、式によって結果が生成され、別の式に含めることができます。 void メソッド呼び出しは、結果を生成しない式の例で す。 次の例に示すように、これはステートメントとしてのみ使用できます。
C# に用意されている他の種類の式を次に示します。 補間された文字列式では、書式設定された文字列を作成するための便利な構文が提供されます。
  Console.WriteLine("Hello, world!");
     var r = 2.3;
var message = $"The area of a circle with radius {r} is {Math.PI * r * r:F3}.";
Console.WriteLine(message);
// Output:
// The area of a circle with radius 2.3 is 16.619.
 ラムダ式を使用すると、匿名関数を作成できます。
C# 演算子と式 (C# リファレンス) 2021/03/06 • • Edit Online
 
         クエリ式を使用すると、C# でクエリ機能を直接使用できるようになります。
    var scores = new[] { 90, 97, 78, 68, 85 };
IEnumerable<int> highScoresQuery =
    from score in scores
    where score > 80
    orderby score descending
    select score;
Console.WriteLine(string.Join(" ", highScoresQuery));
// Output:
// 97 90 85
 式本体の定義を使用すると、メソッド、コンストラクター、プロパティ、インデクサー、またはファイナライザーの簡潔な定義を提供 できます。
演算子の優先順位
複数の演算子を含む式では、優先順位の高い方の演算子が優先順位の低い方の演算子よりも先に評価されます。 次の例 では、乗算は加算より優先順位が高いため、最初に乗算が実行されます。
演算子の優先順位によって定められた評価の順序を変更するには、かっこを使用します。
次の表は、C# の演算子を優先順位の高い順にまとめたものです。 各行内の演算子の優先順位は同じです。
    var a = 2 + 2 * 2;
Console.WriteLine(a); //  output: 6
     var a = (2 + 2) * 2;
Console.WriteLine(a); //  output: 8
    x.y、f(x)、a[i]、 x?.y 、 x?[y] 、x++、x- -、x!、new、typeof、checked、unchecked、default、nameof、del egate、sizeof、stackalloc、x->y
   1次式
 +x、-x、!x、~x、++x、--x、^x、(T)x、await、&x、*x、true and false
x..y
switch
ある場合
単項
範囲 switch 式 with 式
                 x*y、x/y、x%y 乗法 x+y、x–y 加法
       int[] numbers = { 2, 3, 4, 5 };
var maximumSquare = numbers.Max(x => x * x);
Console.WriteLine(maximumSquare);
// Output:
// 25
 
                x<<y,x>>y シフト x<y,x>y、x<=y,x>=y、is、as 関係式と型検査 x==y,x!=y 等価比較
x&y ブール演算の論理 AND またはビット演算の論理 AND x^y ブール演算の論理 XOR またはビット演算の論理 XOR x|y ブール演算の論理 OR またはビット演算の論理 OR
x&&y 条件 AND
x||y 条件 OR
x??y Null 合体演算子
c?t:f 条件演算子
x=y、x+=y、x-=y、x*=y、x/=y、x%=y、x&=y、x|= 代入とラムダ宣言 y、x ^= y、x <<= y、x >>= y、x ??= y、=>
演算子の結合規則 演算子の優先順位が同じ場合は、演算子の結合規則によって、操作の実行順序が決まります。
結合規則が左から右 の演算子は、左から右に順番に評価されます。 代入演算子と null 合体演算子を除き、2 項演算 子はすべて左からの結合です。 たとえば、 a + b - c は (a + b) - c と評価されます。
結合規則が右から左 の演算子は、右から左に評価されます。 代入演算子、null 合体演算子、および条件演算子 ?: は、右からの結合です。たとえば、 x = y = z は x = (y = z) と評価されます。
演算子の結合規則によって定められた評価の順序を変更するには、かっこを使用します。
オペランドの評価
式内のオペランドは、演算子の優先順位と結合規則に関係なく、左から右に評価されます。 次の例では、演算子とオペランド が評価される順序を示しています。
a + b a、b、+
a + b * c a、b、c、*、+
                                                  int a = 13 / 5 / 2;
int b = 13 / (5 / 2);
Console.WriteLine($"a = {a}, b = {b}");  // output: a = 1, b = 6
            
                a / b + c * d a、b、/、c、d、*、+
     a / (b + c) * d a、b、c、+、/、d、*
通常、演算子のオペランドはすべて評価されます。 ただし、一部の演算子では、条件付きでオペランドが評価されます。 つま り、このような演算子では、左端のオペランドの値によって、他の (または、どの) オペランドを評価するかどうかが定義されます。 これらの演算子は、条件付き論理AND(&&)およびOR(||)演算子、null合体演算子 ?? と ??=、null条件演算子
?. と ?[] 、および条件演算子 ?: です。 詳細については、演算子ごとの説明を参照してください。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
式 演算子
関連項目
C# リファレンス 演算子のオーバーロード 式ツリー
  
                   次の演算子は、数値型のオペランドを使用して算術演算を実行します。 単項演算子: ++ (インクリメント)、 -- (デクリメント)、 + (プラス)、 - (マイナス)。
2 項演算子: * (乗算)、 / (除算)、 % (剰余)、 + (加算)、 - (減算)。 これらの演算子は、整数と浮動小数点のすべての数値型によってサポートされています。
整数型の場合は、これらの演算子 ( ++ 演算子と -- 演算子を除く) が、 int 、 uint 、 long 、および ulong 型に対して 定義されます。 オペランドが他の整数型 ( sbyte 、 byte 、 short 、 ushort 、 char ) のときは、それらの値は int 型に変 換され、演算の結果もその型になります。 オペランドが異なる整数型または浮動小数点型の場合、それらの値は格納されて いる最も近い型に変換されます (その型が存在する場合)。 詳しくは、「C# 言語仕様」の「数値の上位変換」セクションをご覧く ださい。 ++ 演算子と -- 演算子は、すべての整数数値型と浮動小数点数値型、およびchar型に対して定義されます。
インクリメント演算子 ++
単項インクリメント演算子 ++ は、オペランドを1ずつインクリメントします。このオペランドは、変数、プロパティのアクセス、また
はインデクサーのアクセスである必要があります。
インクリメント演算子は、後置インクリメント演算子である x++ と、前置インクリメント演算子である ++x という 2 つの形式で
サポートされます。 後置インクリメント演算子
次の例に示すように、 x++ の結果は、演算子の "前の" x 値です。
前置インクリメント演算子
次の例に示すように、 ++x の結果は、演算子の "後ろの" x 値です。
デクリメント演算子 --
単項デクリメント演算子 -- は、オペランドを1ずつデクリメントします。このオペランドは、変数、プロパティのアクセス、またはイ
ンデクサーのアクセスである必要があります。
デクリメント演算子は、後置デクリメント演算子である x-- と、前置デクリメント演算子である --x という2つの形式でサポー
トされます。
後置デクリメント演算子
次の例に示すように、 x-- の結果は、演算子の "前の" x 値です。
     int i = 3;
Console.WriteLine(i);   // output: 3
Console.WriteLine(i++); // output: 3
Console.WriteLine(i);   // output: 4
     double a = 1.5;
Console.WriteLine(a);   // output: 1.5
Console.WriteLine(++a); // output: 2.5
Console.WriteLine(a);   // output: 2.5
 算術演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
   前置デクリメント演算子
次の例に示すように、 --x の結果は、演算子の "後ろの" x 値です。
単項プラス演算子と単項マイナス演算子
単項 + 演算子によって、そのオペランドの値が返されます。単項 - 演算子は、そのオペランドの数値の否定を計算します。
    double a = 1.5;
Console.WriteLine(a);   // output: 1.5
Console.WriteLine(--a); // output: 0.5
Console.WriteLine(a);   // output: 0.5
     Console.WriteLine(+4);     // output: 4
Console.WriteLine(-4);     // output: -4
Console.WriteLine(-(-4));  // output: 4
uint a = 5;
var b = -a;
Console.WriteLine(b);            // output: -5
Console.WriteLine(b.GetType());  // output: System.Int64
Console.WriteLine(-double.NaN);  // output: NaN
 ulong型は、単項 - 演算子をサポートしません。 乗算演算子 *
乗算演算子 ( * ) は、そのオペランドの積を計算します。
単項 * 演算子は、ポインター間接参照演算子です。 除算演算子 /
除算演算子 / は、左側のオペランドを右側のオペランドで除算します。 整数の除算
整数型のオペランドに対する / 演算子の結果は、整数型で、2つのオペランドの商を0方向に丸めたものと等しくなります。
    Console.WriteLine(5 * 2);         // output: 10
Console.WriteLine(0.5 * 2.5);     // output: 1.25
Console.WriteLine(0.1m * 23.4m);  // output: 2.34
     Console.WriteLine(13 / 5);
Console.WriteLine(-13 / 5);
Console.WriteLine(13 / -5);
Console.WriteLine(-13 / -5);  // output: 2
// output: 2
// output: -2
// output: -2
   2 つのオペランドの商を浮動小数点数として取得するには、 float 、 double 、または decimal 型を使います。
   int i = 3;
Console.WriteLine(i);   // output: 3
Console.WriteLine(i--); // output: 3
Console.WriteLine(i);   // output: 2
 
         浮動小数点の除算
float 、 double 、 decimal 型に対する / 演算子の結果は、2 つのオペランドの商となります。
オペランドの1つが であった場合、もう1つのオペランドを float や にすることはできません。float と double は暗黙的に に変換できないためです。 float または オペランドは明示的に decimal 型に変
換する必要があります。 数値型間の変換について詳しくは、組み込みの数値変換に関するページをご覧ください。 剰余演算子 %
剰余演算子 % は、左側のオペランドを右側のオペランドで除算した後の剰余を計算します。 整数の剰余
整数型のオペランドの場合、 a % b の結果は a - (a / b) * b で生成される値になります。 0 以外の剰余の符号は、次 の例で示されるように、左側のオペランドの符号と同じになります。
Math.DivRem メソッドを使用して、整数除算と剰余の結果の両方を計算します。 浮動小数点の剰余
float オペランドと double オペランドの場合、有限の x と y の x % y の結果は、次のような値 z となります。
z の符号は、0 以外の場合、 x の符号と同じになります。
z の絶対値は、 |x| - n * |y| で生成される値となります。 n は、 |x| / |y| 以下で最も大きい整数であり、 |x| と |y| はそれぞれ、 x と y の絶対値です。
無限オペランドがある % 演算子の動作については、C#言語仕様に関するページの「剰余演算」セクションを参照してくださ い。
decimal オペランドの場合、剰余演算子 % はSystem.Decimal型の剰余演算子に等しくなります。 次の例では、浮動小数点オペランドを使用した剰余演算子の動作を示しています。
      Console.WriteLine(16.8f / 4.1f);
Console.WriteLine(16.8d / 4.1d);
Console.WriteLine(16.8m / 4.1m);
// output: 4.097561
// output: 4.09756097560976
// output: 4.0975609756097560975609756098
   decimal
double
    decimal
double
     Console.WriteLine(5 % 4);   // output: 1
Console.WriteLine(5 % -4);  // output: 1
Console.WriteLine(-5 % 4);  // output: -1
Console.WriteLine(-5 % -4); // output: -1
        NOTE
剰余を計算するこの手法は、整数オペランドに使用される手法に類似していますが、IEEE 754 の仕様とは異なります。 IEEE 754 の仕様 に準拠する剰余演算が必要な場合、Math.IEEERemainder メソッドを使用してください。
     Console.WriteLine(13 / 5.0);       // output: 2.6
int a = 13;
int b = 5;
Console.WriteLine((double)a / b);  // output: 2.6
 
    加算演算子 +
加算演算子 + は、そのオペランドの合計を計算します。
文字列連結とデリゲートの組み合わせにも、 + 演算子を使用できます。 詳細については、「 + および += 演算子」の記事 を参照してください。
減算演算子 -
減算演算子 - は、その左側のオペランドから右側のオペランドを減算します。
デリゲートの削除には、 - 演算子を使用することもできます。 詳細については、「 - および -= 演算子」の記事を参照してく ださい。
複合代入。
2項演算子 op の場合、フォームの複合代入式
上記の式は、次の式と同じです。
ただし、x が評価されるのは1回だけです。 次の例は、算術演算子を使用した複合代入の使用方法を示しています。
    Console.WriteLine(5 + 4);       // output: 9
Console.WriteLine(5 + 4.3);     // output: 9.3
Console.WriteLine(5.1m + 4.2m); // output: 9.3
     Console.WriteLine(47 - 3);      // output: 44
Console.WriteLine(5 - 4.3);     // output: 0.7
Console.WriteLine(7.5m - 2.3m); // output: 5.2
   x op= y
   x = x op y
    Console.WriteLine(-5.2f % 2.0f); // output: -1.2
Console.WriteLine(5.9 % 3.1);    // output: 2.8
Console.WriteLine(5.9m % 3.1m);  // output: 2.8
 
      数値の上位変換のため、 op 演算の結果は、 x の型 T に暗黙的に変換できない可能性があります。 そのような場合、 op が定義済みの演算子であり、演算の結果が x の型 T に明示的に変換できる場合、 x op= y の形式の複合代入式
は、 x が 1 回だけ評価される点を除き、 x = (T)(x op y) と等価です。 次の例は、その動作を示します。
      byte a = 200;
byte b = 100;
var c = a + b;
Console.WriteLine(c.GetType());  // output: System.Int32
Console.WriteLine(c);  // output: 300
a += b;
Console.WriteLine(a);  // output: 44
 イベントのサブスクリプションとサブスクリプションの解除には、 += 演算子と -= 演算子もそれぞれ使用できます。 詳細について は、「イベントのサブスクリプションとサブスクリプション解除を行う方法」を参照してください。
演算子の優先順位と結合規則 次の算術演算子の一覧は、優先度が高い順に並べられています。
後置インクリメント演算子 x++ と後置デクリメント演算子 x-- 前置インクリメント演算子 ++x とデクリメント演算子 --x および単項演算子 + と - 乗算演算子 *、/、%
加法 + および - 演算子
2 項算術演算子は左結合です。 つまり、優先度が同じ演算子は、左から右に評価されます。 演算子の優先順位と結合規則によって定められた評価の順序を変更するには、かっこ () を使用します。
優先度順に並べられた C# 演算子の完全な一覧については、C# 演算子に関する記事の「演算子の優先順位」セクションを 参照してください。
    Console.WriteLine(2 + 2 * 2);   // output: 6
Console.WriteLine((2 + 2) * 2); // output: 8
Console.WriteLine(9 / 5 / 2);   // output: 0
Console.WriteLine(9 / (5 / 2)); // output: 4
 算術オーバーフローと 0 による除算
   int a = 5;
a += 9;
Console.WriteLine(a);  // output: 14
a -= 4;
Console.WriteLine(a);  // output: 10
a *= 2;
Console.WriteLine(a);  // output: 20
a /= 4;
Console.WriteLine(a);  // output: 5
a %= 3;
Console.WriteLine(a);  // output: 2
 
       算術演算の結果が関係する数値型の有限値の範囲外にある場合は、算術演算子の動作は、そのオペランドの型に依存し ます。
整数の算術オーバーフロー
0 による整数除算では、常に DivideByZeroException がスローされます。
整数の算術オーバーフローの場合、オーバーフロー チェック コンテキスト (checked または unchecked) が結果の動作を制御し ます。
checked コンテキストでは、定数式でオーバーフローが発生すると、コンパイル時エラーが発生します。 それ以外の場合は、 実行時に演算が実行されると OverflowException がスローされます。
unchecked コンテキストでは、結果の格納先の型に収まらない上位ビットが破棄されて、結果が切り詰められます。
checkedとuncheckedのステートメントとともに、checked 演算子と unchecked 演算子を使用して、式が評価されるオー バーフロー チェック コンテキストを制御することができます。
      int a = int.MaxValue;
int b = 3;
Console.WriteLine(unchecked(a + b));  // output: -2147483646
try
{
    int d = checked(a + b);
}
catch(OverflowException)
{
    Console.WriteLine($"Overflow occurred when adding {a} to {b}.");
}
 既定では、算術演算は unchecked コンテキストで発生します。 浮動小数点演算のオーバーフロー
float 型と double 型を使用した算術演算では、例外はスローされません。 これらの型を使用した算術演算の結果は、無 限および数値ではないことを表す特殊な値のいずれかになる可能性があります。
     double a = 1.0 / 0.0;
Console.WriteLine(a);                    // output: Infinity
Console.WriteLine(double.IsInfinity(a)); // output: True
Console.WriteLine(double.MaxValue + double.MaxValue); // output: Infinity
double b = 0.0 / 0.0;
Console.WriteLine(b);                // output: NaN
Console.WriteLine(double.IsNaN(b));  // output: True
  decimal 型のオペランドの場合、算術オーバーフローは常にOverflowExceptionをスローし、0による除算は常に DivideByZeroException をスローします。
丸め誤差
実数の浮動小数点表記と浮動小数点演算の一般的な制限事項により、浮動小数点型を使った計算で丸め誤差が生じる 可能性があります。 つまり、式の生成された結果が、予期した数学的結果と異なる場合があります。 次の例は、こうしたいくつ かのケースを示しています。

                        詳細については、System.Double、System.Single、または System.Decimal の参照ページの解説を参照してください。 演算子のオーバーロード可/不可
ユーザー定義型は、単項算術演算子(++ 、 -- 、 + 、 - )と2項算術演算子(* 、 / 、 % 、 + 、 - )をオーバーロードで きます。 2 項演算子をオーバーロードすると、対応する複合代入演算子も暗黙的にオーバーロードされます。 ユーザー定義 型は、複合代入演算子を明示的にオーバーロードすることはできません。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
後置インクリメント演算子と後置デクリメント演算子 前置インクリメント演算子と前置デクリメント演算子 単項プラス演算子
単項マイナス演算子
乗算演算子
除算演算子
剰余演算子
加算演算子
減算演算子
複合代入
checked 演算子と unchecked 演算子 数値の上位変換
関連項目
C# リファレンス
C# の演算子と式 System.Math System.MathF .NET における数値
   Console.WriteLine(.41f % .2f); // output: 0.00999999
double a = 0.1;
double b = 3 * a;
Console.WriteLine(b == 0.3);
Console.WriteLine(b - 0.3);
// output: False
// output: 5.55111512312578E-17
decimal c = 1 / 3.0m;
decimal d = 3 * c;
Console.WriteLine(d == 1.0m);  // output: False
Console.WriteLine(d);          // output: 0.9999999999999999999999999999
 
             次の演算子は、bool オペランドを使用して論理演算を実行します。
単項 ! (論理否定)演算子。
二項 & (論理AND)、| (論理OR)、および ^ (論理排他的OR)演算子。これらの演算子は常に両方のオペランド を評価します。
二項 && (条件付き論理AND)および || (条件付き論理OR)演算子。これらの演算子では、必要な場合にのみ右 側のオペランドが評価されます。
整数の数値型のオペランドの場合、 & 、 | 、 ^ 演算子でビットごとの論理演算を実行します。 詳しくは、「ビットごとの演算 子とシフト演算子」をご覧ください。
論理否定演算子 !
単項の接頭辞 ! 演算子では、そのオペランドの論理否定が計算されます。 つまり、オペランドが false と評価された場合
は true 、オペランドが true と評価された場合は false が生成されます。
C#8.0以降では、単項後置の ! 演算子はnull免除演算子です。 論理 AND 演算子 &
& 演算子がそのオペランドの論理 AND を計算します。 x と y の両方が true と評価されれば、 x & y の結果は true です。それ以外の場合、結果は false です。
& 演算子は、左側のオペランドが false と評価されても両方のオペランドを評価するため、操作結果は右側のオペランドの 値に関係なく、 false になります。
次の例では、 & 演算子の右側のオペランドはメソッド呼び出しで、左側のオペランドの値に関係なく実行されます。
    bool passed = false;
Console.WriteLine(!passed);  // output: True
Console.WriteLine(!true);    // output: False
     bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}
bool a = false & SecondOperand();
Console.WriteLine(a);
// Output:
// Second operand is evaluated.
// False
bool b = true & SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
 ブール論理演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
           条件付き論理AND演算子 && もそのオペランドの論理ANDを計算しますが、左側のオペランドが false と評価された場 合、右側のオペランドは評価されません。
整数の数値型のオペランドの場合、& 演算子でそのオペランドのビットごとの論理ANDを計算します。単項 & 演算子はア ドレス演算子です。
論理排他的 OR 演算子: ^
^ 演算子は、そのオペランドの論理排他的OR(論理XORとも呼ばれます)を計算します。 x が true に評価され、y
が false に評価された場合、または x が false に評価され、 y が true に評価された場合、 x ^ y の結果は true です。 それ以外の場合、結果は false です。 つまり、 bool オペランドの場合、 ^ 演算子は非等値演算子 != と同じ結 果を計算します。
整数の数値型のオペランドの場合、^ 演算子でそのオペランドのビットごとの論理排他的ORを計算します。 論理 OR 演算子 |
| 演算子がそのオペランドの論理 OR を計算します。 x または y のどちらかが true と評価された場合、 x | y の結果 は true になります。それ以外の場合、結果は false です。
| 演算子は、左側のオペランドが true と評価されても両方のオペランドを評価するため、操作結果は右側のオペランドの 値に関係なく、 true になります。
次の例では、 | 演算子の右側のオペランドはメソッド呼び出しで、左側のオペランドの値に関係なく実行されます。
    Console.WriteLine(true ^ true);
Console.WriteLine(true ^ false);
Console.WriteLine(false ^ true);
Console.WriteLine(false ^ false);  // output: False
// output: False
// output: True
// output: True
     bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}
bool a = true | SecondOperand();
Console.WriteLine(a);
// Output:
// Second operand is evaluated.
// True
bool b = false | SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
 条件付き論理OR演算子 || もそのオペランドの論理ORを計算しますが、左側のオペランドが true と評価された場合、 右側のオペランドは評価されません。
整数の数値型のオペランドの場合、| 演算子でそのオペランドのビットごとの論理ORを計算します。 条件付き論理 AND 演算子 &&
条件論理AND演算子 && は、"短絡"論理AND演算子とも呼ばれ、そのオペランドの論理ANDを計算します。 x と y の両方が true と評価されれば、 x && y の結果は true です。 それ以外の場合、結果は false です。 x が
 
     false に評価される場合、 y は評価されません。
次の例では、 && 演算子の右側のオペランドはメソッド呼び出しで、左側のオペランドが false と評価されると実行されませ
ん。
    bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}
bool a = false && SecondOperand();
Console.WriteLine(a);
// Output:
// False
bool b = true && SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
 論理AND演算子 & もそのオペランドの論理ANDを計算しますが、常に両方のオペランドを評価します。 条件付き論理 OR 演算子 ||
条件論理OR演算子 || は、"短絡"論理OR演算子とも呼ばれ、そのオペランドの論理ORを計算します。 x または y のどちらかが true と評価された場合、 x || y の結果は true になります。 それ以外の場合、結果は false です。 x が true に評価される場合、 y は評価されません。
次の例では、 || 演算子の右側のオペランドはメソッド呼び出しで、左側のオペランドが true と評価されると実行されませ ん。
     bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}
bool a = true || SecondOperand();
Console.WriteLine(a);
// Output:
// True
bool b = false || SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
 論理OR演算子 | もそのオペランドの論理ORを計算しますが、常に両方のオペランドを評価します。 null 許容ブール論理演算子
bool? オペランドの場合、& (論理AND)演算子および | (論理OR)演算子は、次のように3値論理をサポートします。
& 演算子は、その両方のオペランドが true に評価される場合にのみ true を生成します。 x または y のいず れかが false に評価される場合、(もう一方のオペランドが null に評価された場合でも) x & y は false を生成 します。 それ以外の場合、 x & y の結果は null になります。

   | 演算子は、その両方のオペランドが false に評価される場合にのみ false を生成します。 x または y のい ずれかが true に評価される場合、(もう一方のオペランドが null に評価された場合でも) x | y は true を生成 します。 それ以外の場合、 x | y の結果は null になります。
そのセマンティクスを次の表に示します。
X Y
true true TRUE False true null False true False False False null null true null False null null
X&Y X|Y
true true false true null true False true False False False null null true False null null null
                                                                            これらの演算子の動作は、null 許容値型の一般的な演算子の動作とは異なります。 通常、値型のオペランドに定義されて いる演算子も、対応する null 値型のオペランドと共に使用できます。 このような演算子では、そのオペランドのいずれかが
null として評価される場合に null を生成します。 しかし、 & および | 演算子は、オペランドの 1 つが null として評 価される場合でも、null 以外の値を生成する可能性があります。 null 許容値型の演算子の動作については、null 許容値 型に関する記事の「リフト演算子」セクションを参照してください。
次の例に示すように、 ! 演算子と ^ 演算子を bool? オペランドと共に使用することもできます。
条件付き論理演算子 && と || では、 bool? オペランドをサポートしません。 複合代入。
2項演算子 op の場合、フォームの複合代入式
上記の式は、次の式と同じです。
    bool? test = null;
Display(!test);         // output: null
Display(test ^ false);  // output: null
Display(test ^ null);   // output: null
Display(true ^ null);   // output: null
void Display(bool? b) => Console.WriteLine(b is null ? "null" : b.Value.ToString());
   x op= y
   x = x op y
 
   ただし、x が評価されるのは1回だけです。
次の例に示すように、 & 、 | 、および ^ 演算子は複合代入をサポートします。
    bool test = true;
test &= false;
Console.WriteLine(test);  // output: False
test |= true;
Console.WriteLine(test);  // output: True
test ^= false;
Console.WriteLine(test);  // output: True
     NOTE
条件付き論理演算子 && と || は複合代入をサポートしません。
 演算子の優先順位 次の論理演算子の一覧は、優先度が高い順に並べられています。
論理否定演算子 ! 論理AND演算子 & 論理排他的OR演算子 ^ 論理OR演算子 | 条件付き論理AND演算子 && 条件付き論理OR演算子 ||
演算子の優先順位によって定められた評価の順序を変更するには、かっこ () を使用します。
    Console.WriteLine(true | true & false);   // output: True
Console.WriteLine((true | true) & false); // output: False
bool Operand(string name, bool value)
{
    Console.WriteLine($"Operand {name} is evaluated.");
    return value;
}
var byDefaultPrecedence = Operand("A", true) || Operand("B", true) && Operand("C", false);
Console.WriteLine(byDefaultPrecedence);
// Output:
// Operand A is evaluated.
// True
var changedOrder = (Operand("A", true) || Operand("B", true)) && Operand("C", false);
Console.WriteLine(changedOrder);
// Output:
// Operand A is evaluated.
// Operand C is evaluated.
// False
 優先度順に並べられた C# 演算子の完全な一覧については、C# 演算子に関する記事の「演算子の優先順位」セクションを 参照してください。
演算子のオーバーロード可/不可

              ユーザー定義型は、 ! 、 & 、 | 、および ^ 演算子をオーバーロードできます。 2 項演算子をオーバーロードすると、対応す る複合代入演算子も暗黙的にオーバーロードされます。 ユーザー定義型は、複合代入演算子を明示的にオーバーロードす ることはできません。
ユーザー定義型は条件付き論理演算子 && と || をオーバーロードできません。ただし、ユーザー定義型がtrueおよび false演算子と & または | 演算子を特定の方法でオーバーロードしている場合は、その型のオペランドに対してそれぞれ
&& または || 演算の評価が可能になります。詳細については、「C#言語仕様」のユーザー定義型条件論理演算子に関 するセクションを参照してください。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
 論理否定演算子
 論理演算子
 条件論理演算子
 複合代入
関連項目
C# リファレンス
C# の演算子と式 ビットごとの演算子とシフト演算子

               以下の演算子では、整数型または char 型のオペランドに対してビットごとの演算またはシフト演算が実行されます。
単項 ~ (ビットごとの補数)演算子
2項 << (左シフト)および >> (右シフト)シフト演算子
2項 & (論理AND)、| (論理OR)、および ^ (論理排他的OR)演算子
これらの演算子は、 int 、 uint 、 long 、 ulong 型に対して定義されています。 両方のオペランドが他の整数型 ( sbyte 、 byte 、 short 、 ushort 、 char ) の場合、それらの値は int 型に変換され、演算の結果もその型になります。 オペランド が異なる整数型の場合、それらの値は最も近い含んでいる整数型に変換されます。 詳しくは、「C# 言語仕様」の「数値の上
位変換」セクションをご覧ください。
& 、 | 、 ^ の各演算子は、 bool 型のオペランドに対しても定義されています。 詳しくは、「ブール論理演算子」をご覧くださ
い。
ビットごとの演算子およびシフト演算が原因でオーバーフローが発生することはなく、checked と unchecked のコンテキストで同 じ結果が生成されることはありません。
ビットごとの補数演算子 ~
~ 演算子では、各ビットを反転させることにより、オペランドのビットごとの補数が生成されます。
~ シンボルはファイナライザーの宣言にも使用できます。詳細については、「Finalizers」(ファイナライザー)を参照してくださ い。
左シフト演算子 <<
<< 演算子では、左側のオペランドが、右側のオペランドで定義されたビット数だけ左にシフトされます。
次の例に示すように、左シフト演算子では、結果の型の範囲外にある上位ビットは破棄され、空の下位ビット位置は、ゼロに 設定されます。
     uint a = 0b_0000_1111_0000_1111_0000_1111_0000_1100;
uint b = ~a;
Console.WriteLine(Convert.ToString(b, toBase: 2));
// Output:
// 11110000111100001111000011110011
     uint x = 0b_1100_1001_0000_0000_0000_0000_0001_0001;
Console.WriteLine($"Before: {Convert.ToString(x, toBase: 2)}");
uint y = x << 4;
Console.WriteLine($"After:  {Convert.ToString(y, toBase: 2)}");
// Output:
// Before: 11001001000000000000000000010001
// After:  10010000000000000000000100010000
 シフト演算子は int 、 uint 、 long 、 ulong 型に対してのみ定義されるので、演算の結果には常に少なくとも 32 ビットが
ビットごとの演算子とシフト演算子 (C# リファ
レンス) 2020/11/02 • • Edit Online
 
    含まれます。 左側のオペランドが別の整数型 ( sbyte 、 byte 、 short 、   、 char ) の場合、次の例で示すように、そ の値は int 型に変換されます。
    byte a = 0b_1111_0001;
var b = a << 8;
Console.WriteLine(b.GetType());
Console.WriteLine($"Shifted byte: {Convert.ToString(b, toBase: 2)}");
// Output:
// System.Int32
// Shifted byte: 1111000100000000
 << 演算子の右側のオペランドでのシフト数の定義方法については、「シフト演算子のシフト数」セクションをご覧ください。 右シフト演算子 >>
>> 演算子では、左側のオペランドが、右側のオペランドで定義されたビット数だけ右にシフトされます。 次の例で示すように、右シフト演算では、下位ビットが破棄されます。
    uint x = 0b_1001;
Console.WriteLine($"Before: {Convert.ToString(x, toBase: 2), 4}");
uint y = x >> 2;
Console.WriteLine($"After:  {Convert.ToString(y, toBase: 2), 4}");
// Output:
// Before: 1001
// After:    10
 空の上位ビット位置は、左側のオペランドの型に基づいて次のように設定されます。
左側のオペランドの型が int または long である場合、右シフト演算子では、"算術"シフトが実行されます:左側の オペランドの最上位ビット (符号ビット) の値が空の上位ビット位置に反映されます。 つまり、左側のオペランドが負でな い場合は空の上位ビット位置が 0 に設定され、負の場合は 1 に設定されます。
    int a = int.MinValue;
Console.WriteLine($"Before: {Convert.ToString(a, toBase: 2)}");
int b = a >> 3;
Console.WriteLine($"After:  {Convert.ToString(b, toBase: 2)}");
// Output:
// Before: 10000000000000000000000000000000
// After:  11110000000000000000000000000000
 左側のオペランドの型が uint または ulong である場合、右シフト演算子では、"論理"シフトが実行されます:空の 上位ビット位置は常に 0 に設定されます。
    uint c = 0b_1000_0000_0000_0000_0000_0000_0000_0000;
Console.WriteLine($"Before: {Convert.ToString(c, toBase: 2), 32}");
uint d = c >> 3;
Console.WriteLine($"After:  {Convert.ToString(d, toBase: 2), 32}");
// Output:
// Before: 10000000000000000000000000000000
// After:     10000000000000000000000000000
 >> 演算子の右側のオペランドでのシフト数の定義方法については、「シフト演算子のシフト数」セクションをご覧ください。
 ushort
 
     論理 AND 演算子 &
& 演算子によって、その整数オペランドのビットごとの論理ANDが計算されます。
bool オペランドの場合、& 演算子がそのオペランドの論理ANDを計算します。単項 & 演算子はアドレス演算子です。 論理排他的 OR 演算子: ^
^ 演算子によって、その整数オペランドのビットごとの論理排他的OR(ビットごとの論理XORとも呼ばれます)が計算されま す。
bool オペランドの場合、^ 演算子がそのオペランドの論理排他的ORを計算します。 論理 OR 演算子 |
| 演算子によって、その整数オペランドのビットごとの論理ORが計算されます。
bool オペランドの場合、| 演算子がそのオペランドの論理ORを計算します。 複合代入。
2項演算子 op の場合、フォームの複合代入式
上記の式は、次の式と同じです。
ただし、x が評価されるのは1回だけです。 次の例では、ビットごとの演算子およびシフト演算子を使った複合代入の使用方法を示します。
    uint a = 0b_1111_1000;
uint b = 0b_1001_1101;
uint c = a & b;
Console.WriteLine(Convert.ToString(c, toBase: 2));
// Output:
// 10011000
     uint a = 0b_1111_1000;
uint b = 0b_0001_1100;
uint c = a ^ b;
Console.WriteLine(Convert.ToString(c, toBase: 2));
// Output:
// 11100100
     uint a = 0b_1010_0000;
uint b = 0b_1001_0001;
uint c = a | b;
Console.WriteLine(Convert.ToString(c, toBase: 2));
// Output:
// 10110001
   x op= y
   x = x op y
 
     数値の上位変換のため、 op 演算の結果は、 x の型 T に暗黙的に変換できない可能性があります。 そのような場合、 op が定義済みの演算子であり、演算の結果が x の型 T に明示的に変換できる場合、 x op= y の形式の複合代入式
は、 x が 1 回だけ評価される点を除き、 x = (T)(x op y) と等価です。 次の例は、その動作を示します。
      byte x = 0b_1111_0001;
int b = x << 8;
Console.WriteLine($"{Convert.ToString(b, toBase: 2)}");  // output: 1111000100000000
x <<= 8;
Console.WriteLine(x);  // output: 0
 演算子の優先順位 次のビットごとの演算子およびシフト演算子の一覧は、優先度が高い順に並べられています。
ビットごとの補数演算子 ~ シフト演算子 << および >> 論理AND演算子 & 論理排他的OR演算子 ^ 論理OR演算子 |
演算子の優先順位によって定められた評価の順序を変更するには、かっこ () を使用します。
    uint a = 0b_1101;
uint b = 0b_1001;
uint c = 0b_1010;
uint d1 = a | b & c;
Display(d1);  // output: 1101
uint d2 = (a | b) & c;
Display(d2);  // output: 1000
void Display(uint x) => Console.WriteLine($"{Convert.ToString(x, toBase: 2), 4}");
 優先度順に並べられた C# 演算子の完全な一覧については、C# 演算子に関する記事の「演算子の優先順位」セクションを 参照してください。
   uint a = 0b_1111_1000;
a &= 0b_1001_1101;
Display(a);  // output: 10011000
a |= 0b_0011_0001;
Display(a);  // output: 10111001
a ^= 0b_1000_0000;
Display(a);  // output:   111001
a <<= 2;
Display(a);  // output: 11100100
a >>= 4;
Display(a);  // output:     1110
void Display(uint x) => Console.WriteLine($"{Convert.ToString(x, toBase: 2), 8}");
 
        シフト演算子のシフト数
シフト演算子 << および >> の場合、右側のオペランドの型は、 int であるか、または int への事前に定義された暗黙的
な数値変換を持つ型にする必要があります。
x << count および x >> count の式では、実際のシフト数は次のように x の型によって異なります。
x の型が int または uint である場合、シフト数は、右側のオペランドの下位5ビットで定義されます。つまり、シ フト数は count & 0x1F (または count & 0b_1_1111 ) から計算されます。
x の型が long または ulong である場合、シフト数は、右側のオペランドの下位6ビットで定義されます。つまり、 シフト数は count & 0x3F (または count & 0b_11_1111 ) から計算されます。
次の例は、その動作を示します。
          int count1 = 0b_0000_0001;
int count2 = 0b_1110_0001;
int a = 0b_0001;
Console.WriteLine($"{a} << {count1} is {a << count1}; {a} << {count2} is {a << count2}");
// Output:
// 1 << 1 is 2; 1 << 225 is 2
int b = 0b_0100;
Console.WriteLine($"{b} >> {count1} is {b >> count1}; {b} >> {count2} is {b >> count2}");
// Output:
// 4 >> 1 is 2; 4 >> 225 is 2
     NOTE
前の例で示したように、右側のオペランドの値が左側のオペランドのビット数よりも大きい場合でも、シフト演算の結果が 0 以外になることが あります。
 列挙論理演算子
~ 、 & 、 | 、 ^ の演算子は、任意の列挙型でもサポートされます。 オペランドが同じ列挙型の場合、基になっている整数 型の対応する値に対して、論理演算が実行されます。 たとえば、基になる型が U である列挙型 T の任意の x と y に 対して、式 x & y では式 (T)((U)x & (U)y) と同じ結果が生成されます。
通常、ビットごとの論理演算子は、Flags 属性で定義されている列挙型で使います。 詳しくは、「列挙型」記事の「ビット フラグ としての列挙型」セクションをご覧ください。
演算子のオーバーロード可/不可
ユーザー定義型では、 ~ 、 << 、 >> 、 & 、 | 、 ^ の各演算子をオーバーロードできます。 2 項演算子をオーバーロードする と、対応する複合代入演算子も暗黙的にオーバーロードされます。 ユーザー定義型は、複合代入演算子を明示的にオー バーロードすることはできません。
ユーザー定義型 T で << または >> 演算子をオーバーロードする場合、左側のオペランドの型は T である必要があり、右 側のオペランドの型は int である必要があります。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
 ビットごとの補数演算子

        シフト演算子 論理演算子 複合代入 数値の上位変換
参照
C# リファレンス
C# の演算子と式 ブール論理演算子

              == (等価)と != (非等値)演算子は、そのオペランドが等しいかどうを確認します。 等値演算子 ==
等値演算子 == は、そのオペランドが等しい場合には true を返し、それ以外の場合は false を返します。 値の型の等価性
組み込みの値の型のオペランドは、その値が等しい場合は等しくなります。
    int a = 1 + 2 + 3;
int b = 6;
Console.WriteLine(a == b);  // output: True
char c1 = 'a';
char c2 = 'A';
Console.WriteLine(c1 == c2);  // output: False
Console.WriteLine(c1 == char.ToLower(c2));  // output: True
     NOTE
== 、 < 、 > 、 <= 、および >= 演算子の場合、いずれかのオペランドが数値 (Double.NaN または Single.NaN) でない場合、演算結 果は false になります。 つまり、 NaN の値は、 NaN を含む他のどの double (または float ) の値を上回ることも、下回ることも、 等しいこともありません。 詳細およびサンプルについては、Double.NaN または Single.NaN の参照記事をご覧ください。
  同じ列挙型の 2 つのオペランドは、基になる整数型の対応する値が等しい場合は等しくなります。 既定ではユーザー定義struct型は == 演算子をサポートしていません。 == 演算子をサポートするには、ユーザー定義
struct でそれをオーバーロードする必要があります。
C#7.3より、== および != 演算子はC#のタプルによってサポートされています。詳細については、タプル型に関する記事
のタプルの等価性に関するセクションを参照してください。
参照型の等価性
既定では、レコードではない 2 つの参照型オペランドは、同じオブジェクトを参照しているときに等しくなります。
等値演算子 (C# リファレンス) 2021/03/06 • • Edit Online
 
    次の例は、ユーザー定義の参照型が既定で == 演算子をサポートしていることを示しています。ただし、参照型は == 演算 子をオーバーロードできます。参照型が == 演算子をオーバーロードする場合、その型の2つの参照が同じオブジェクトを参 照しているかどうかを調べるには Object.ReferenceEquals メソッドを使用します。
レコードの型の等価性
C#9.0以降で利用できるレコードの型では、既定で値の等価性セマンティクスを提供する == 演算子と != 演算子をサポー トします。つまり、2つのレコードオペランドは、いずれも null であるか、すべてのフィールドと自動実装プロパティの該当値が 等しいときに等しくなります。
    public class RecordTypesEquality
{
    public record Point(int X, int Y, string Name);
    public record TaggedNumber(int Number, List<string> Tags);
    public static void Main()
    {
} }
var p1 = new Point(2, 3, "A");
var p2 = new Point(1, 3, "B");
var p3 = new Point(2, 3, "A");
Console.WriteLine(p1 == p2);  // output: False
Console.WriteLine(p1 == p3);  // output: True
var n1 = new TaggedNumber(2, new List<string>() { "A" });
var n2 = new TaggedNumber(2, new List<string>() { "A" });
Console.WriteLine(n1 == n2);  // output: False
 前の例からわかるように、レコードではない参照型メンバーの場合、参照されるインスタンスではなく、参照値が比較されます。 文字列の等価性
2つのstringオペランドは、その両方が null であるか、両方の文字列インスタンスの長さが同じで、それぞれの文字列の位 置に同じ文字が含まれている場合に等しくなります。
    public class ReferenceTypesEquality
{
    public class MyClass
    {
        private int id;
        public MyClass(int id) => this.id = id;
    }
    public static void Main()
    {
} }
var a = new MyClass(1);
var b = new MyClass(1);
var c = a;
Console.WriteLine(a == b);  // output: False
Console.WriteLine(a == c);  // output: True
    string s1 = "hello!";
string s2 = "HeLLo!";
Console.WriteLine(s1 == s2.ToLower());  // output: True
string s3 = "Hello!";
Console.WriteLine(s1 == s3);  // output: False
 
        序数の比較では大文字と小文字が区別されます。 文字列の比較に関する詳細については、「C# で文字列を比較する方 法」を参照してください。
デリゲートの等価性
同じランタイム型を持つ2つのデリゲートオペランドが等しくなるのは、それらの両方が null であるか、それらの呼び出しリスト が同じ長さで、各位置に等しいエントリを含んでいる場合です。
詳細については、C# 言語仕様の「Delegate equality operators (デリゲートの等値演算子)」セクションをご覧ください。 次の例に示すように、意味的に等しいラムダ式を評価して生成されるデリゲートは、等しくありません。
非等値演算子 !=
非等値演算子 != は、そのオペランドが等しくない場合には true を返し、それ以外の場合は false を返します。組み込 み型のオペランドの場合、式 x != y と式 !(x == y) では同じ結果が生成されます。 等価型の詳細については、「等値演 算子」セクションを参照してください。
!= 演算子の使用例を次に示します。
    Action a = () => Console.WriteLine("a");
Action b = a + a;
Action c = a + a;
Console.WriteLine(object.ReferenceEquals(b, c));  // output: False
Console.WriteLine(b == c);  // output: True
     Action a = () => Console.WriteLine("a");
Action b = () => Console.WriteLine("a");
Console.WriteLine(a == b);  // output: False
Console.WriteLine(a + b == a + b);  // output: True
Console.WriteLine(b + a == a + b);  // output: False
       int a = 1 + 1 + 2 + 3;
int b = 6;
Console.WriteLine(a != b);  // output: True
string s1 = "Hello";
string s2 = "Hello";
Console.WriteLine(s1 != s2);  // output: False
object o1 = 1;
object o2 = 1;
Console.WriteLine(o1 != o2);  // output: True
 演算子のオーバーロード可/不可
ユーザー定義型は == 演算子と != 演算子をオーバーロードできます。ある型でこの2つの演算子の1つをオーバーロード
する場合は、もう 1 つの演算子もオーバーロードする必要があります。
レコードの型で == 演算子と != 演算子を明示的にオーバーロードすることはできません。 レコードの型 T の == 演算子と != 演算子の動作を変更する必要がある場合、次のシグネチャでIEquatable<T>.Equalsメソッドを実装します。
  public virtual bool Equals(T? other);
 
            C# 言語仕様
詳細については、C# 言語仕様に関するページの「関係演算子と型検査演算子」のセクションを参照してください。 レコードの型の等価性に関する詳細については、レコード機能提案メモ ページの「等値メンバー」セクションを参照してください。
関連項目
C# リファレンス
C# の演算子と式 System.IEquatable<T> Object.Equals Object.ReferenceEquals 等価比較
比較演算子

             < (小なり)、 > (大なり)、 <= (以下)、および >= (以上) 比較演算子は、関係演算子とも呼ばれ、そのオペランドの比較に 使用されます。 これらの演算子は、整数と浮動小数点のすべての数値型によってサポートされています。
char型では、比較演算子もサポートされています。オペランドが char 場合は、対応する文字コードが比較されます。 列挙型は比較演算子もサポートします。 同じ列挙型のオペランドで、基になる整数型の対応する値が比較されます。
== および != 演算子では、そのオペランドが等しいかどうかが確認されます。 小なり演算子 <
左側のオペランドが右側のオペランドより小さい場合、 < 演算子から true が返され、それ以外の場合は false が返されま す。
大なり演算子 >
左側のオペランドが右側のオペランドより大きい場合、 > 演算子から true が返され、それ以外の場合は false が返されま
す。
以下演算子 <=
左側のオペランドが右側のオペランド以下の場合、 <= 演算子から true が返され、それ以外の場合は false が返されま す。
    NOTE
== 、 < 、 > 、 <= 、および >= 演算子の場合、いずれかのオペランドが数値 (Double.NaN または Single.NaN) でない場合、演算結 果は false になります。 つまり、 NaN の値は、 NaN を含む他のどの double (または float ) の値を上回ることも、下回ることも、 等しいこともありません。 詳細およびサンプルについては、Double.NaN または Single.NaN の参照記事をご覧ください。
      Console.WriteLine(7.0 < 5.1);
Console.WriteLine(5.1 < 5.1);
Console.WriteLine(0.0 < 5.1);
// output: False
// output: False
// output: True
Console.WriteLine(double.NaN < 5.1);   // output: False
Console.WriteLine(double.NaN >= 5.1);  // output: False
     Console.WriteLine(7.0 > 5.1);
Console.WriteLine(5.1 > 5.1);
Console.WriteLine(0.0 > 5.1);
// output: True
// output: False
// output: False
Console.WriteLine(double.NaN > 5.1);   // output: False
Console.WriteLine(double.NaN <= 5.1);  // output: False
 比較演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
         以上演算子 >=
左側のオペランドが右側のオペランド以上の場合、 >= 演算子から true が返され、それ以外の場合は false が返されま
す。
演算子のオーバーロード可/不可
ユーザー定義型は、 < 、 > 、 <= 、および >= 演算子をオーバーロードできます。
ある型で < または > 演算子のいずれかをオーバーロードする場合は、 < と > の両方をオーバーロードする必要がありま す。 ある型で <= または >= 演算子のいずれかをオーバーロードする場合は、 <= と >= の両方をオーバーロードする必要 があります。
C# 言語仕様
詳細については、C# 言語仕様に関するページの「関係演算子と型検査演算子」のセクションを参照してください。
関連項目
C# リファレンス
C# の演算子と式 System.IComparable<T> 等値演算子
    Console.WriteLine(7.0 >= 5.1);
Console.WriteLine(5.1 >= 5.1);
Console.WriteLine(0.0 >= 5.1);
// output: True
// output: True
// output: False
Console.WriteLine(double.NaN < 5.1);   // output: False
Console.WriteLine(double.NaN >= 5.1);  // output: False
    Console.WriteLine(7.0 <= 5.1);
Console.WriteLine(5.1 <= 5.1);
Console.WriteLine(0.0 <= 5.1);
// output: False
// output: True
// output: True
Console.WriteLine(double.NaN > 5.1);   // output: False
Console.WriteLine(double.NaN <= 5.1);  // output: False
 
             型のメンバーにアクセスするときは、次の演算子と式を使用できます。
. (メンバーアクセス):名前空間または型のメンバーにアクセスします
[] (配列要素またはインデクサーアクセス):配列要素または型のインデクサーにアクセスします
?. および ?[] (null条件演算子):オペランドがnullでない場合にのみ、メンバーまたは要素へのアクセス操作を実行し
ます
() (呼び出し):アクセスしたメソッドを呼び出すか、デリゲートを呼び出します
^ (末尾からのインデックス):要素の位置がシーケンスの末尾からであることを示します
.. (範囲):シーケンス要素の範囲を取得するために使用できるインデックスの範囲を指定します
メンバー アクセス式 . 以下の例に示すように、名前空間のメンバーまたは型にアクセスするために . トークンを使います。
次の using ディレクティブの例に示すように、 . を使って、名前空間内の入れ子になった名前空間にアクセスします。
次のコードに示すように、. を使って"修飾名"を作成して名前空間内の型にアクセスします。
using ディレクティブを使い、必要に応じて修飾名を利用します。 次のコードに示すように、. を使って、型のメンバー(静的および非静的)にアクセスします。
  using System.Collections.Generic;
   System.Collections.Generic.IEnumerable<int> numbers = new int[] { 1, 2, 3 };
     var constants = new List<double>();
constants.Add(Math.PI);
constants.Add(Math.E);
Console.WriteLine($"{constants.Count} values to show:");
Console.WriteLine(string.Join(", ", constants));
// Output:
// 2 values to show:
// 3.14159265358979, 2.71828182845905
 また、 . を使って拡張メソッドにアクセスすることもできます。 インデクサー演算子 []
通常、角かっこ [] は、配列、インデクサー、またはポインター要素へのアクセスに使用されます。
配列へのアクセス 次の例は、配列要素へのアクセス方法を示しています。
メンバー アクセス演算子と式 (C# リファレンス) 2021/03/06 • • Edit Online
 
         配列インデックスが配列の対応するディメンションの範囲に含まれない場合、IndexOutOfRangeException がスローされます。 前述の例が示すように、配列型の宣言と配列インスタンスのインスタンス化にも角かっこを使用します。 配列の詳細については、「配列」を参照してください。
インデクサーへのアクセス
次の例では、インデクサーへのアクセスを示すために .NET Dictionary<TKey,TValue> 型を使用します。
インデクサーを使用すると、配列のインデックス作成と同様の方法でユーザー定義型のインスタンスのインデックスを作成すること ができます。 整数である必要がある配列インデックスとは異なり、任意の型を持つインデクサー パラメーターを宣言できます。
インデクサーの詳細については、「インデクサー」を参照してください。 [] の他の使用方法
ポインター要素へのアクセスの詳細については、ポインターに関連する演算子に関する記事の「ポインター要素アクセス演算子 []」セクションを参照してください。
角かっこは、属性を指定するためにも使用されます。
Null 条件演算子 ?. および ?[]
C# 6 以降で使用できる Null 条件付き演算子は、そのオペランドが null 以外と評価された場合にのみ、オペランドにメンバー アクセス操作(?.)または要素アクセス操作(?[])を適用し、それ以外の場合は、null を返します。つまり、以下のように なります。
a が null と評価された場合、 a?.x または a?[x] の結果は null です。
a が null 以外と評価された場合、 a?.x または a?[x] の結果は、 a.x または a[x] の結果とそれぞれ同じで す。
    var dict = new Dictionary<string, double>();
dict["one"] = 1;
dict["pi"] = Math.PI;
Console.WriteLine(dict["one"] + dict["pi"]);  // output: 4.14159265358979
     [System.Diagnostics.Conditional("DEBUG")]
void TraceMethod() {}
    int[] fib = new int[10];
fib[0] = fib[1] = 1;
for (int i = 2; i < fib.Length; i++)
{
    fib[i] = fib[i - 1] + fib[i - 2];
}
Console.WriteLine(fib[fib.Length - 1]);  // output: 55
double[,] matrix = new double[2,2];
matrix[0,0] = 1.0;
matrix[0,1] = 2.0;
matrix[1,0] = matrix[1,1] = 3.0;
var determinant = matrix[0,0] * matrix[1,1] - matrix[1,0] * matrix[0,1];
Console.WriteLine(determinant);  // output: -3
 
     Null 条件演算子はショートサーキットです。 つまり、条件付きのメンバーまたは要素アクセス操作のチェーン内にある 1 つの操 作から null が返された場合、残りのチェーンは実行されません。 次の例では、 A が null と評価されると B は評価され ず、 A または B が null と評価されると C は評価されません。
?. および ?[] 演算子の使用例を次に示します。
    A?.B?.Do(C);
A?.B?[C];
     double SumNumbers(List<double[]> setsOfNumbers, int indexOfSetToSum)
{
    return setsOfNumbers?[indexOfSetToSum]?.Sum() ?? double.NaN;
}
var sum1 = SumNumbers(null, 0);
Console.WriteLine(sum1);  // output: NaN
var numberSets = new List<double[]>
{
    new[] { 1.0, 2.0, 3.0 },
null };
var sum2 = SumNumbers(numberSets, 0);
Console.WriteLine(sum2);  // output: 6
var sum3 = SumNumbers(numberSets, 1);
Console.WriteLine(sum3);  // output: NaN
 前の例では、null条件演算の結果が null の場合に評価する代替の式を指定するために、null合体演算子 ?? も使用 しています。
a.x または a[x] がnull非許容値型の T の場合は、a?.x または a?[x] は対応するnull許容値型の T? になりま す。 T 型の式が必要な場合は、次の例に示すように、null合体演算子 ?? をnull条件式に適用します。
    int GetSumOfFirstTwoOrDefault(int[] numbers)
{
    if ((numbers?.Length ?? 0) < 2)
    {
return 0; }
    return numbers[0] + numbers[1];
}
Console.WriteLine(GetSumOfFirstTwoOrDefault(null));  // output: 0
Console.WriteLine(GetSumOfFirstTwoOrDefault(new int[0]));  // output: 0
Console.WriteLine(GetSumOfFirstTwoOrDefault(new[] { 3, 4, 5 }));  // output: 7
   前の例では、 ?? 演算子を使用しなければ、 numbers が null の場合、 numbers?.Length < 2 は false と評価されま す。
Null条件メンバーアクセス演算子 ?. はElvis演算子とも呼ばれます。
   NOTE
a.x または a[x] が例外をスローした場合は、 a?.x または a?[x] が、null以外の a に対して同じ例外をスローしま す。 たとえば、 a が null 以外の配列インスタンスで、 x が a の範囲外にある場合、 a?[x] は IndexOutOfRangeException をスローします。
 
      スレッドセーフなデリゲートの呼び出し
次のコードに示すように、?. 演算子を使用してデリゲートがnull以外かどうかを確認し、それをスレッドセーフな方法で呼び
出します (たとえば、イベントを発生させる場合)。
このコードは、C# 5 以前で使用する次のコードと同等です。
これは、null 以外の のみが呼び出されるようにするためのスレッドセーフな方法です。 デリゲート インスタンスは不変 であるため、 ローカル変数によって参照されるオブジェクトを変更できるスレッドはありません。 具体的には、別のスレッ ドによって実行されるコードが イベントから登録解除され、 handler が呼び出される前に
PropertyChanged が null になる場合、 によって参照されるオブジェクトは影響を受けません。 ?. 演算子では、 左側のオペランドが1回だけ評価され、null以外として検証された後に null に変更できないことが保証されます。
呼び出し式 ()
かっこ () は、メソッドを呼び出すとき、またはデリゲートを呼び出すときに使用します。
メソッドを呼び出す方法 (引数を指定した場合と指定しない場合) とデリゲートを呼び出す方法の例を次に示します。
  PropertyChanged?.Invoke(...)
     var handler = this.PropertyChanged;
if (handler != null)
{
    handler(...);
}
  handler
 handler
  PropertyChanged
  handler
    Action<int> display = s => Console.WriteLine(s);
var numbers = new List<int>();
numbers.Add(10);
numbers.Add(17);
display(numbers.Count);   // output: 2
numbers.Clear();
display(numbers.Count);   // output: 0
 かっこは、 new 演算子を使用してコンストラクターを呼び出すときにも使用します。 () の他の使用方法
式に含まれる演算を評価する順序を調整する場合にもかっこを使用します。 詳細については、C# 演算子に関するページを 参照してください。
明示的な型変換を実行するキャスト式でも、かっこが使われます。 末尾からのインデックス演算子 ^
^ 演算子はC#8.0以降で使用することができ、要素の位置がシーケンスの末尾からであることを示します。長さが length のシーケンスの場合、 ^n は、シーケンスの先頭からのオフセットが length - n である要素を指します。 たとえば、 ^1 は、 シーケンスの最後の要素を指し、 ^length は、シーケンスの最初の要素を指します。
   
      前の例で示すように、式 ^e は System.Index 型です。 式 ^e で、 e の結果は int に暗黙に変換される必要がありま す。
さらに、 ^ 演算子を範囲演算子 と組み合わせて使用してインデックスの範囲を作成することもできます。 詳細については、 「インデックスと範囲」を参照してください。
範囲演算子 .
.. 演算子はC#8.0以降で使用することができ、インデックスの範囲の先頭と末尾をオペランドとして指定します。左側のオ ペランドは "包含的" で、範囲の先頭を含みます。 右側のオペランドは "排他的" で、範囲の末尾を含みません。 次の例で示 すように、どちらのオペランドであっても、シーケンスの先頭または末尾からのインデックスとすることができます。
    int[] numbers = new[] { 0, 10, 20, 30, 40, 50 };
int start = 1;
int amountToTake = 3;
int[] subset = numbers[start..(start + amountToTake)];
Display(subset);  // output: 10 20 30
int margin = 1;
int[] inner = numbers[margin..^margin];
Display(inner);  // output: 10 20 30 40
string line = "one two three";
int amountToTakeFromEnd = 5;
Range endIndices = ^amountToTakeFromEnd..^0;
string end = line[endIndices];
Console.WriteLine(end);  // output: three
void Display<T>(IEnumerable<T> xs) => Console.WriteLine(string.Join(" ", xs));
 前の例で示すように、式 a..b は System.Range 型です。 式 a..b で、 a および b の結果は暗黙に int または Index に変換される必要があります。
.. 演算子のオペランドのいずれかを省略して、変更可能な範囲を取得することができます。
a.. は a..^0 と同じです。 ..b は 0..b と同じです。 .. は 0..^0 と同じです。
   int[] xs = new[] { 0, 10, 20, 30, 40 };
int last = xs[^1];
Console.WriteLine(last);  // output: 40
var lines = new List<string> { "one", "two", "three", "four" };
string prelast = lines[^2];
Console.WriteLine(prelast);  // output: three
string word = "Twenty";
Index toFirst = ^word.Length;
char first = word[toFirst];
Console.WriteLine(first);  // output: T
 
              詳細については、「インデックスと範囲」を参照してください。 演算子のオーバーロード可/不可
. 、 () 、 ^ 、および .. の各演算子はオーバーロードできません。 [] 演算子も、オーバーロードできない演算子と見なさ れます。 ユーザー定義型を使用したインデックス作成をサポートするには、インデクサーを使用してください。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
メンバー アクセス 要素アクセス NULL 条件演算子 呼び出し式
インデックスと範囲について詳しくは、機能提案メモを参照してください。 関連項目
C# リファレンス
C# の演算子と式
?? (Null 合体演算子) :: 演算子
   int[] numbers = new[] { 0, 10, 20, 30, 40, 50 };
int amountToDrop = numbers.Length / 2;
int[] rightHalf = numbers[amountToDrop..];
Display(rightHalf);  // output: 30 40 50
int[] leftHalf = numbers[..^amountToDrop];
Display(leftHalf);  // output: 0 10 20
int[] all = numbers[..];
Display(all);  // output: 0 10 20 30 40 50
void Display<T>(IEnumerable<T> xs) => Console.WriteLine(string.Join(" ", xs));
 
         次の演算子と式を使用して、型のチェックまたは型の変換を実行できます。
is 演算子: 式のランタイム型と指定された型の間に互換性があるかどうかを確認します
as 演算子: 式のランタイム型と指定された型の間に互換性がある場合、式を指定された型に明示的に変換します キャスト式: 明示的な変換を実行します
typeof 演算子: 型の System.Type インスタンスを取得します
is 演算子
is 演算子では、式の結果のランタイム型と指定された型の間に互換性があるかどうかが調べられます。C#7.0以降の is
演算子では、パターンに対する式の結果のテストも行われます。 is 型テスト演算子を使用する式の形式は次のとおりです
E は値を返す式であり、 T は型または型パラメーターの名前です。 E を匿名メソッドまたはラムダ式にすることはできませ ん。
式 E is T では、 E の結果が null ではなく、参照変換、ボックス化変換、またはボックス化解除変換によって型 T に変換 できる場合は true が返され、それ以外の場合は false が返されます。 is 演算子では、ユーザー定義変換は考慮され ません。
次の例で示す is 演算子では、式の結果のランタイム型が指定された型から派生する場合、つまり型の間に参照変換が存 在する場合は、 true が返されます。
  E is T
      public class Base { }
public class Derived : Base { }
public static class IsOperatorExample
{
    public static void Main()
    {
} }
object b = new Base();
Console.WriteLine(b is Base);  // output: True
Console.WriteLine(b is Derived);  // output: False
object d = new Derived();
Console.WriteLine(d is Base);  // output: True
Console.WriteLine(d is Derived); // output: True
 次の例で示す is 演算子では、ボックス化変換とボックス化解除変換は考慮されますが、数値変換は考慮されません。
型のテスト演算子とキャスト式 (C# リファレン
ス)
2020/11/02 • • Edit Online
 
       C# の変換については、C# 言語仕様の「Conversions (変換)」の章をご覧ください。 パターン マッチングを使用する型テスト
C#7.0以降の is 演算子では、パターンに対する式の結果のテストも行われます。具体的には、次の形式の型パターンがサ ポートされます。
E は値を返す式、 T は型または型パラメーターの名前、 v は T 型の新しいローカル変数です。 E の結果が null ではな く、参照変換、ボックス化変換、またはボックス化解除変換によって T に変換できる場合、式 E is T v から true が返さ れ、 E の結果の変換された値が変数 v に代入されます。
次の例では、型パターンによる is 演算子の使用方法を示します。
型パターンおよび他のサポートされるパターンについて詳しくは、「is を使用したパターン マッチング」をご覧ください。 as 演算子
as 演算子では、式の結果が、指定された参照型またはnull許容値型に明示的に変換されます。変換できない場合、 as 演算子からは null が返されます。 キャスト式とは異なり、 as 演算子では例外はスローされません。
式の形式は次のとおりです
E は値を返す式であり、 T は型または型パラメーターの名前です。次の式と同じ結果が生成されます
ただし、E が評価されるのは1回だけです。
as 演算子では、参照、null許容、ボックス化、およびボックス化解除の各変換だけが考慮されます。 as 演算子を使って、
ユーザー定義の変換を実行することはできません。 これを行うには、キャスト式を使用します。 as 演算子の使用例を次に示します。
  E is T v
      int i = 23;
object iBoxed = i;
int? jNullable = 7;
if (iBoxed is int a && jNullable is int b)
{
    Console.WriteLine(a + b);  // output 30
}
   E as T
   E is T ? (T)(E) : (T)null
    int i = 27;
Console.WriteLine(i is System.IFormattable);  // output: True
object iBoxed = i;
Console.WriteLine(iBoxed is int);  // output: True
Console.WriteLine(iBoxed is long);  // output: False
 
             NOTE
上の例のように、変換が成功したかどうかを確認するには、 as 式の結果を null と比較する必要があります。 C# 7.0 以降では、変換 が成功するかどうかのテストと、成功する場合の新しい変数への結果の代入の両方を、is 演算子を使って行うことができます。
 キャスト式
(T)E という形式のキャスト式では、式 E の結果が、型 T に明示的に変換されます。型 E から型 T への明示的な変 換が存在しない場合は、コンパイル時エラーが発生します。 実行時に、明示的な変換が成功せず、キャスト式で例外がス ローされる可能性があります。
次の例では、数値と参照の明示的な変換を示します。
    double x = 1234.7;
int a = (int)x;
Console.WriteLine(a);   // output: 1234
IEnumerable<int> numbers = new int[] { 10, 20, 30 };
IList<int> list = (IList<int>)numbers;
Console.WriteLine(list.Count);  // output: 3
Console.WriteLine(list[1]);  // output: 20
 サポートされる明示的な変換については、C# 言語仕様の「Explicit conversions (明示的な変換)」セクションをご覧ください。 カスタムの明示的または暗黙的な型変換を定義する方法については、「User-defined conversion operators」(ユーザー定 義の変換演算子) を参照してください。
() の他の使用方法 かっこは、メソッドまたはデリゲートを呼び出すときにも使います。
他には、式に含まれる演算を評価する順序を調整する場合にもかっこを使います。 詳細については、C# 演算子に関するペー ジを参照してください。
typeof 演算子
typeof 演算子では、型のSystem.Typeインスタンスが取得されます。 typeof 演算子への引数では、次の例で示すよう に、型または型パラメーターの名前を指定する必要があります。
      void PrintType<T>() => Console.WriteLine(typeof(T));
Console.WriteLine(typeof(List<string>));
PrintType<int>();
PrintType<System.Int32>();
PrintType<Dictionary<int, char>>();
// Output:
// System.Collections.Generic.List`1[System.String]
// System.Int32
// System.Int32
// System.Collections.Generic.Dictionary`2[System.Int32,System.Char]
    IEnumerable<int> numbers = new[] { 10, 20, 30 };
IList<int> indexable = numbers as IList<int>;
if (indexable != null)
{
    Console.WriteLine(indexable[0] + indexable[indexable.Count - 1]);  // output: 40
}
 
              バインドされていないジェネリック型で   演算子を使うこともできます。 バインドされていないジェネリック型の名前には、 適切な数のコンマが含まれる必要があります。これは、型パラメーターの数より 1 だけ少ない数です。 次の例では、バインドされ ていないジェネリック型での typeof 演算子の使用方法を示します。
式を typeof 演算子の引数にすることはできません。式の結果のランタイム型に対するSystem.Typeインスタンスを取得する には、Object.GetType メソッドを使います。
typeof 演算子での型テスト 演算子を使って、式の結果のランタイム型が指定された型と完全に一致するかどうかを調べます。 次の例では、
演算子と is 演算子で実行される型チェックの違いを示します。
     Console.WriteLine(typeof(Dictionary<,>));
// Output:
// System.Collections.Generic.Dictionary`2[TKey,TValue]
    typeof
  typeof
    public class Animal { }
public class Giraffe : Animal { }
public static class TypeOfExample
{
    public static void Main()
    {
        object b = new Giraffe();
        Console.WriteLine(b is Animal);  // output: True
        Console.WriteLine(b.GetType() == typeof(Animal));  // output: False
        Console.WriteLine(b is Giraffe);  // output: True
        Console.WriteLine(b.GetType() == typeof(Giraffe));  // output: True
    }
}
 演算子のオーバーロード可/不可
is 、 as 、および typeof の各演算子はオーバーロードできません。
ユーザー定義型で () 演算子をオーバーロードすることはできませんが、キャスト式で実行できるカスタム型変換を定義するこ とはできます。 詳細については、「ユーザー定義の変換演算子」 に関するページを参照してください。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
is 演算子
as 演算子 キャスト式 typeof 演算子
関連項目
C# リファレンス
C# の演算子と式
パターン マッチング、is 演算子、as 演算子を使用して安全にキャストする方法 .NET のジェネリック
  typeof
 
    ユーザー定義型では、別の型との間にカスタムの暗黙的または明示的な変換を定義できます。
暗黙的変換では特別な構文を呼び出す必要はなく、代入やメソッド呼び出しなど、さまざまな状況で発生する可能性があり ます。 事前に定義された C# の暗黙的な変換は常に成功し、例外がスローされることはありません。 ユーザー定義の暗黙的 な変換も同様に動作します。 カスタムの変換によって例外がスローされたり情報が失われたりする可能性がある場合は、明示 的な変換として定義します。
ユーザー定義の変換は、is および as 演算子からは考慮されません。 ユーザー定義の明示的な変換を呼び出すには、キャスト 式を使用します。
暗黙的または明示的な変換を定義するには、 operator とそれぞれ implicit または explicit のキーワードを使用しま す。 変換を定義する型は、その変換のソース型またはターゲット型のいずれかである必要があります。 2 つのユーザー定義型 間の変換は、2 つの型のどちらでも定義できます。
次の例は、暗黙的な変換と明示的な変換を定義する方法を示しています。
       using System;
public readonly struct Digit
{
    private readonly byte digit;
    public Digit(byte digit)
    {
        if (digit > 9)
        {
            throw new ArgumentOutOfRangeException(nameof(digit), "Digit cannot be greater than nine.");
        }
        this.digit = digit;
    }
    public static implicit operator byte(Digit d) => d.digit;
    public static explicit operator Digit(byte b) => new Digit(b);
    public override string ToString() => $"{digit}";
}
public static class UserDefinedConversions
{
    public static void Main()
    {
        var d = new Digit(7);
        byte number = d;
        Console.WriteLine(number);  // output: 7
        Digit digit = (Digit)number;
        Console.WriteLine(digit);  // output: 7
    }
}
  また、事前に定義されたC#演算子をオーバーロードするには operator キーワードも使用します。詳細については、「演算 子のオーバーロード」を参照してください。
ユーザー定義の変換演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
             C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
変換演算子 ユーザー定義の変換 暗黙的な変換 明示的な変換
関連項目
C# リファレンス
C# の演算子と式
演算子のオーバーロード
型テストとキャスト演算子
キャストと型変換
設計ガイドライン - 変換演算子
Chained user-defined explicit conversions in C# (C# でのユーザー定義の明示的変換の連結)

             次の演算子を使って、ポインターを操作することができます。
単項 & (アドレス取得)演算子:変数のアドレスを取得します
単項 * (ポインター間接参照)演算子:ポインターが指す位置にある変数を取得します
-> (メンバーアクセス)および [] (要素アクセス)演算子 算術演算子 +、-、++、--
比較演算子 ==、!=、<、>、<=、>=
ポインター型については、「ポインター型」をご覧ください。
アドレス取得演算子 &
単項の & 演算子からは、そのオペランドのアドレスが返されます。
    NOTE
ポインターに関するすべての操作には、unsafe コンテキストが必要です。 unsafe ブロックを含むコードは、 -unsafe コンパイラ オプションで コンパイルする必要があります。
      unsafe {
    int number = 27;
    int* pointerToNumber = &number;
    Console.WriteLine($"Value of the variable: {number}");
    Console.WriteLine($"Address of the variable: {(long)pointerToNumber:X}");
}
// Output is similar to:
// Value of the variable: 27
// Address of the variable: 6C1457DBD4
 & 演算子のオペランドは、固定変数である必要があります。"固定"変数とは、ガベージコレクターの操作によって影響を受け ない記憶域の場所に存在する変数です。前の例では、ローカル変数 number はスタックに存在するので固定変数です。ガ ベージ コレクターによって影響を受ける可能性がある (たとえば再配置) 記憶域の場所にある変数は、"移動可能" 変数と呼 ばれます。オブジェクトフィールドや配列の要素は、移動可能変数の例です。 fixed ステートメントで移動可能変数を"固 定"または"ピン留め"した場合は、移動可能変数のアドレスを取得できます。取得したアドレスは、fixed ステートメントのブ ロック内でのみ有効です。 fixed ステートメントと & 演算子の使い方の例を次に示します。
     unsafe {
    byte[] bytes = { 1, 2, 3 };
    fixed (byte* pointerToFirst = &bytes[0])
    {
        // The address stored in pointerToFirst
        // is valid only inside this fixed statement block.
    }
}
 定数または値のアドレスを取得できません。
ポインターに関連する演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
       固定変数と移動可能変数について詳しくは、「C# 言語仕様」の「Fixed and moveable variables (固定変数と移動可能変 数)」セクションをご覧ください。
2項 & 演算子では、ブール型オペランドの論理ANDまたは整数オペランドのビットごとの論理ANDが計算されます。 ポインター間接参照演算子 *
単項ポインター間接参照演算子 * では、オペランドが指し示す変数が取得されます。逆参照演算子とも呼ばれます。 * 演算子のオペランドは、ポインター型である必要があります。
    unsafe {
    char letter = 'A';
    char* pointerToLetter = &letter;
    Console.WriteLine($"Value of the `letter` variable: {letter}");
    Console.WriteLine($"Address of the `letter` variable: {(long)pointerToLetter:X}");
    *pointerToLetter = 'Z';
    Console.WriteLine($"Value of the `letter` variable after update: {letter}");
}
// Output is similar to:
// Value of the `letter` variable: A
// Address of the `letter` variable: DCB977DDF4
// Value of the `letter` variable after update: Z
 void* 型の式に * 演算子を適用することはできません。 2項 * 演算子では、数値オペランドの積が計算されます。
ポインター メンバー アクセス演算子 ->
-> 演算子では、ポインターの間接参照とメンバー アクセスが組み合わされます。 つまり、 x が T* 型のポインターで、 y が
T 型のアクセス可能なメンバーである場合に、次のような形式の式を考えます
上記の式は、次の式と同じです。
-> 演算子の使用例を次に示します。
  x->y
   (*x).y
 
     void* 型の式に -> 演算子を適用することはできません。 ポインター要素アクセス演算子 []
ポインター型の式 p の場合、 p[n] の形式のポインター要素アクセスは、 *(p + n) と評価されます。 n は、 int 、 uint 、 long 、または ulong に暗黙的に変換できる型でなければなりません。 ポインターでの + 演算子の動作については、「ポ インターに対する整数値の加算または減算」セクションをご覧ください。
次の例では、ポインターと [] 演算子による配列要素へのアクセス方法を示します。
     unsafe {
    char* pointerToChars = stackalloc char[123];
    for (int i = 65; i < 123; i++)
    {
        pointerToChars[i] = (char)i;
    }
    Console.Write("Uppercase letters: ");
    for (int i = 65; i < 91; i++)
    {
        Console.Write(pointerToChars[i]);
    }
}
// Output:
// Uppercase letters: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  前の例では、 stackalloc 式によってスタックにメモリ ブロックが割り当てられています。
void* 型の式でポインター要素アクセスに [] を使うことはできません。 配列要素またはインデクサーアクセスには [] 演算子を使用することもできます。
    NOTE
ポインター要素アクセス演算子では、範囲外のエラーはチェックされません。
 ポインター算術演算子
   public struct Coords
{
    public int X;
    public int Y;
    public override string ToString() => $"({X}, {Y})";
}
public class PointerMemberAccessExample
{
    public static unsafe void Main()
    {
} }
Coords coords;
Coords* p = &coords;
p->X = 3;
p->Y = 4;
Console.WriteLine(p->ToString());  // output: (3, 4)
 
   ポインターで次の算術演算を実行できます。
ポインターに整数値を加算する、またはポインターから整数値を減算する 2 個のポインターを減算する ポインターをインクリメントまたはデクリメントする
void* 型のポインターでこれらの演算を実行することはできません。
数値型でサポートされている算術演算については、「算術演算子」をご覧ください。
ポインターへの整数値の加算またはポインターからの整数値の減算
T* 型のポインター p と、 int 、 uint 、 long 、または ulong に暗黙的に変換できる型の式 n の場合、加算と減算は 次のように定義されます。
式 p + n および n + p では、どちらの場合も、 p によって与えられるアドレスに n * sizeof(T) を加算した結果であ る、 T* 型のポインターが生成されます。
式 p - n では、 p によって与えられるアドレスから n * sizeof(T) を減算した結果である、 T* 型のポインターが生成 されます。
sizeof 演算子では、型のサイズ(バイト単位)が取得されます。 次の例では、ポインターでの + 演算子の使用方法を示します。
       unsafe {
    const int Count = 3;
    int[] numbers = new int[Count] { 10, 20, 30 };
    fixed (int* pointerToFirst = &numbers[0])
    {
        int* pointerToLast = pointerToFirst + (Count - 1);
        Console.WriteLine($"Value {*pointerToFirst} at address {(long)pointerToFirst}");
        Console.WriteLine($"Value {*pointerToLast} at address {(long)pointerToLast}");
    }
}
// Output is similar to:
// Value 10 at address 1818345918136
// Value 30 at address 1818345918144
 ポインターの減算
T* 型の 2 つのポインター p1 と p2 の場合、式 p1 - p2 では、 p1 と p2 によって指定されるアドレスの間の差を によって除算した値が生成されます。 結果の型は long です。 つまり、 p1 - p2 は
   sizeof(T)
 ((long)(p1) - (long)(p2)) / sizeof(T)
ポインターの減算の例を次に示します。
として計算されます。
    unsafe {
    int* numbers = stackalloc int[] { 0, 1, 2, 3, 4, 5 };
    int* p1 = &numbers[1];
    int* p2 = &numbers[5];
    Console.WriteLine(p2 - p1);  // output: 4
}
 ポインターのインクリメントとデクリメント
++ インクリメント演算子では、ポインターオペランドに1が加算されます。 -- デクリメント演算子では、ポインターオペランド から 1 が減算されます。

           どちらの演算子も、後置 ( p++ および p-- ) と前置 ( ++p および --p ) の 2 つの形式でサポートされます。 p++ および p-- の結果は、演算の"前"の p の値です。 ++p および --p の結果は、演算の"後"の p の値です。
次の例では、後置と前置両方のインクリメント演算子の動作を示します。
    unsafe {
    int* numbers = stackalloc int[] { 0, 1, 2 };
    int* p1 = &numbers[0];
    int* p2 = p1;
    Console.WriteLine($"Before operation: p1 - {(long)p1}, p2 - {(long)p2}");
    Console.WriteLine($"Postfix increment of p1: {(long)(p1++)}");
    Console.WriteLine($"Prefix increment of p2: {(long)(++p2)}");
    Console.WriteLine($"After operation: p1 - {(long)p1}, p2 - {(long)p2}");
}
// Output is similar to
// Before operation: p1 - 816489946512, p2 - 816489946512
// Postfix increment of p1: 816489946512
// Prefix increment of p2: 816489946516
// After operation: p1 - 816489946516, p2 - 816489946516
 ポインター比較演算子
== 、 != 、 < 、 > 、 <= 、 >= 演算子を使って、 void* を含む任意のポインター型のオペランドを比較できます。 これらの演
算子では、2 つのオペランドによって指定されるアドレスが、符号なし整数のように比較されます。 他の型のオペランドに対するこれらの演算子の動作については、「等値演算子」および「比較演算子」をご覧ください。
演算子の優先順位 次のポインター関連演算子の一覧は、優先度が高い順に並べられています。
後置インクリメント x++ およびデクリメント x-- 演算子、 -> および [] 演算子 前置インクリメント ++x およびデクリメント --x 演算子、 & および * 演算子 加法 + および - 演算子
比較 <、>、<=、>= 演算子
等値 == および != 演算子 演算子の優先順位によって定められた評価の順序を変更するには、かっこ () を使用します。
優先度順に並べられた C# 演算子の完全な一覧については、C# 演算子に関する記事の「演算子の優先順位」セクションを 参照してください。
演算子のオーバーロード可/不可 ユーザー定義型では、ポインター関連演算子 & 、 * 、 -> 、 [] をオーバーロードできません。
C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
固定変数と移動可能変数 アドレス取得演算子 ポインター間接参照 ポインター メンバー アクセス ポインター要素アクセス

           ポインター算術
ポインター インクリメントおよびデクリメント ポインター比較
関連項目
C# リファレンス
C# の演算子と式 ポインター型 unsafe キーワード fixed キーワード stackalloc sizeof 演算子

       代入演算子 = は、右辺オペランドの値を、左辺オペランドに指定された変数、プロパティ、またはインデクサー要素に割り当 てます。 代入式の結果は、左辺のオペランドに割り当てられる値です。 右辺のオペランドの型は、左辺のオペランドの型と同じ であるか、暗黙に変換できる必要があります。
代入演算子 = は右結合です。つまり、次の形式の式があるとします
これが次のように評価されます。
次の例では、左側のオペランドとしてローカル変数、プロパティ、およびインデクサー要素を使用する代入演算子の使用方法を 示します。
  a=b=c
   a = (b = c)
     var numbers = new List<double>() { 1.0, 2.0, 3.0 };
Console.WriteLine(numbers.Capacity);
numbers.Capacity = 100;
Console.WriteLine(numbers.Capacity);
// Output:
// 4 // 100
int newFirstElement;
double originalFirstElement = numbers[0];
newFirstElement = 5;
numbers[0] = newFirstElement;
Console.WriteLine(originalFirstElement);
Console.WriteLine(numbers[0]);
// Output:
// 1
// 5
 ref 代入演算子
C#7.3以降では、ref代入演算子 = ref を使用して、refローカル変数またはref読み取り専用ローカル変数を割り当てる ことができます。 次の例は、ref 代入演算子の使用方法を示しています。
代入演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
          ref 代入演算子の場合、その両方のオペランドの型が同じである必要があります。 複合代入。
2項演算子 op の場合、フォームの複合代入式
上記の式は、次の式と同じです。
ただし、x が評価されるのは1回だけです。 複合代入は、算術、ブール論理、ビット単位論理およびシフトの各演算子でサポートされています。
null 合体割り当て
C#8.0以降では、null合体割り当て演算子 ??= を使用して、左側のオペランドが null に評価された場合にのみ、右側 のオペランドの値を左側のオペランドに割り当てることができます。 詳細については、「?? and ??= 演算子」の記事を参照してく ださい。
演算子のオーバーロード可/不可
ユーザー定義型は、代入演算子をオーバーロードできません。 ただし、ユーザー定義型は、別の型への暗黙的な変換を定義 できます。 この方法により、ユーザー定義型の値を、別の型の変数、プロパティ、またはインデクサー要素に割り当てることができ ます。 詳細については、「ユーザー定義の変換演算子」 に関するページを参照してください。
ユーザー定義型は、複合代入演算子を明示的にオーバーロードすることはできません。 ただし、ユーザー定義型が二項演算 子 op をオーバーロードし、 op= 演算子も存在する場合は、それも暗黙的にオーバーロードされます。
C# 言語仕様
詳細については、C# 言語仕様の「Assignment operators (代入演算子)」セクションを参照してください。 ref代入演算子 = ref の詳細については、機能提案メモを参照してください。
  x op= y
   x = x op y
 関連項目
   void Display(double[] s) => Console.WriteLine(string.Join(" ", s));
double[] arr = { 0.0, 0.0, 0.0 };
Display(arr);
ref double arrayElement = ref arr[0];
arrayElement = 3.0;
Display(arr);
arrayElement = ref arr[arr.Length - 1];
arrayElement = 5.0;
Display(arr);
// Output:
// 0 0 0
// 3 0 0
// 3 0 5
 
    C# リファレンス C# の演算子と式 ref キーワード

                 "ラムダ式" を使用して匿名関数を作成します。 ラムダ宣言演算子 => を使用して、ラムダのパラメーター リストを式本体から 分離します。 ラムダ式は、次の 2 つの形式のいずれかにすることができます。
式形式のラムダは、式本体に式が含まれます。
ステートメント形式のラムダは、式本体にステートメント ブロックが含まれます。
ラムダ式を作成するには、ラムダ演算子の左辺に入力パラメーターを指定し (ある場合)、右辺に式またはステートメント ブロック を指定します。
ラムダ式は、デリゲート型に変換できます。 ラムダ式を変換できるデリゲート型は、パラメータと戻り値の型で定義されます。 ラム ダ式が値を返さない場合は Action デリゲート型のいずれかに変換でき、値を返す場合は Func デリゲート型のいずれかに変 換できます。 たとえば、2 つのパラメーターがあり、値を返さないラムダ式は、Action<T1,T2> デリゲートに変換できます。 1 つ のパラメーターがあり、値を返すラムダ式は、Func<T,TResult>デリゲートに変換できます。次の例では、x という名前のパラ メーターを指定し、 x の二乗の値を返すラムダ式 x => x * x を、デリゲート型の変数に割り当てます。
式形式のラムダは、次の例に示すように、式ツリー型にも変換できます。
ラムダ式は、デリゲート型または式ツリーのインスタンスを必要とするすべてのコードで使用できます。たとえ ば、Task.Run(Action) メソッドの引数として使用すると、バックグラウンドで実行する必要があるコードを渡すことができます。 ま た、次の例に示すように、C# で LINQ を作成する場合にもラムダ式を使用できます。
メソッド ベースの構文を使用して System.Linq.Enumerable クラス (たとえば、LINQ to Objects、LINQ to XML など) の Enumerable.Select メソッドを呼び出すと、パラメーターはデリゲート型 System.Func<T,TResult> になります。 System.Linq.Queryable クラス (たとえば、LINQ to SQL など) の Queryable.Select メソッドを呼び出すと、パラメーター型は 式ツリー型 になります。 どちらの場合も、同じラムダ式を使用してパラメーター値を指 定できます。 これにより、2 つの 呼び出しは外観が似ていますが、ラムダから実際に作成されるオブジェクトの型は異 なります。
  (input-parameters) => expression
   (input-parameters) => { <sequence-of-statements> }
       Expression<Func<TSource,TResult>>
 Select
ラムダ式 (C# リファレンス) 2021/03/06 • • Edit Online
    Func<int, int> square = x => x * x;
Console.WriteLine(square(5));
// Output:
// 25
    System.Linq.Expressions.Expression<Func<int, int>> e = x => x * x;
Console.WriteLine(e);
// Output:
// x => (x * x)
    int[] numbers = { 2, 3, 4, 5 };
var squaredNumbers = numbers.Select(x => x * x);
Console.WriteLine(string.Join(" ", squaredNumbers));
// Output:
// 4 9 16 25
 
  式形式のラムダ
=> 演算子の右辺に式があるラムダ式を"式形式のラムダ"と呼びます。式形式のラムダは式の結果を返します。基本的な 形式は次のとおりです。
式形式のラムダの本体を、メソッド呼び出しで構成できます。 ただし、SQL Server などの .NET 共通言語ランタイム (CLR) の コンテキスト外部で評価される式ツリーを作成する場合は、ラムダ式内でメソッド呼び出しを使用しないでください。 .NET 共通 言語ランタイム (CLR) のコンテキストの外部では、これらのメソッドは通用しません。
ステートメント形式のラムダ ステートメント形式のラムダは式形式のラムダに似ていますが、ステートメントが中かっこで囲まれる点が異なります。
ステートメント形式のラムダの本体は任意の数のステートメントで構成できますが、実際面では通常、2、3 個以下にします。
  (input-parameters) => expression
   (input-parameters) => { <sequence-of-statements> }
     Action<string> greet = name =>
{
    string greeting = $"Hello {name}!";
    Console.WriteLine(greeting);
};
greet("World");
// Output:
// Hello World!
 ステートメント形式のラムダを使用して式ツリーを作成することはできません。
ラムダ式の入力パラメーター
ラムダ式の入力パラメーターをかっこで囲みます。 入力パラメーターがないことを指定するには、次のように空のかっこを使用しま す。
ラムダ式に入力パラメーターが 1 つしかない場合、かっこは省略可能です。
入力パラメーターが 2 つ以上ある場合は、コンマで区切ります。
場合によっては、コンパイラで入力パラメーターの型を推論できないことがあります。 次の例のように、型を明示的に指定できま す。
入力パラメーターの型は、すべて明示的またはすべて暗黙的である必要があります。それ以外の場合は、CS0748 コンパイラ エラーが発生します。
  Action line = () => Console.WriteLine();
   Func<double, double> cube = x => x * x * x;
   Func<int, int, bool> testForEquality = (x, y) => x == y;
   Func<int, string, bool> isTooLong = (int x, string s) => s.Length > x;
 
   C# 9.0 以降では、破棄を使用して、式で使用しないラムダ式の 2 つ以上の入力パラメーターを指定できます。
 ラムダの破棄パラメーターは、ラムダ式を使用してイベント ハンドラー指定する場合に便利です。
非同期ラムダ
async キーワードと await キーワードを使用すると、非同期処理を組み込んだラムダ式およびステートメントを簡単に作成でき ます。たとえば、次に示すWindowsフォーム例には、非同期メソッド ExampleMethodAsyncを呼び出して待機するイベント ハンドラーが含まれています。
   非同期ラムダを使用して、同じイベント ハンドラーを追加できます。 このハンドラーを追加するには、次の例に示すように、ラム ダパラメーターリストの前に async 修飾子を追加します。
 非同期メソッドの作成および使用方法の詳細については、「Async および Await を使用した非同期プログラミング」を参照して
 Func<int, int, int> constant = (_, _) => 42;
    NOTE
下位互換性のために、1 つの入力パラメーターにのみ _ という名前が付けられた場合、ラムダ式内で _ はそのパラメーターの名前として 扱われます。
    public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();
        button1.Click += button1_Click;
    }
    private async void button1_Click(object sender, EventArgs e)
    {
        await ExampleMethodAsync();
        textBox1.Text += "\r\nControl returned to Click event handler.\n";
    }
    private async Task ExampleMethodAsync()
    {
        // The following line simulates a task-returning asynchronous process.
        await Task.Delay(1000);
    }
}
    public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();
        button1.Click += async (sender, e) =>
        {
            await ExampleMethodAsync();
            textBox1.Text += "\r\nControl returned to Click event handler.\n";
        };
}
    private async Task ExampleMethodAsync()
    {
        // The following line simulates a task-returning asynchronous process.
        await Task.Delay(1000);
    }
}
 
       ください。 ラムダ式とタプル
C# 7.0 以降、C# 言語には、タプルのサポートが組み込まれています。 タプルは、ラムダ式への引数として指定できるほか、ラム ダ式で返すこともできます。 場合によっては、C# コンパイラは、型の推定を使用して、タプル コンポーネントの型を判定すること もあります。
タプルを定義するには、そのコンポーネントのコンマ区切りリストをかっこで囲みます。 次の例では、3 つのコンポーネントを持つタ プルを使用して、ラムダ式に連続した数値を渡します。このラムダ式により、各値が 2 倍になり、乗算の結果を格納する 3 つの コンポーネントを持つタプルが返されます。
通常、タプルのフィールド名は Item1 、 Item2 のようになります。ただし、次の例のとおり、名前付きのコンポーネントを持つタプ ルを定義することができます。
C# のタプルの詳細については、タプル型に関するページを参照してください。 標準クエリ演算子を使用したラムダ
いくつかある実装の中で特に、LINQ to Objects は、汎用デリゲートの Func<TResult> ファミリに属する型の入力パラメーター を持ちます。 これらのデリゲートは、型パラメーターを使用して、入力パラメーターの数と型に加え、デリゲートの戻り値の型を定 義します。 Func デリゲートは、ソースデータのセット内の各要素に適用されるユーザー定義の式をカプセル化する場合に非常 に便利です。 たとえば、Func<T,TResult>デリゲート型を考えてみましょう。
このデリゲートを Func<int, bool> としてインスタンス化できます。 int は入力パラメーター、 bool は戻り値です。 戻り値は 必ず最後の型パラメーターで指定されます。 たとえば、 Func<int, string, bool> は 2 つの入力パラメーター ( int と
string)と戻り値の型 bool を持つデリゲートを定義しています。次の Func デリゲートを呼び出すと、入力パラメーターが5 に等しいかどうかを示す true または false が返されます。
たとえば、Queryable 型で定義された標準クエリ演算子において、引数型が Expression<TDelegate> の場合もラムダ式を 使用できます。 Expression<TDelegate> 引数を指定すると、ラムダは式ツリーにコンパイルされます。
次の例では、Count 標準クエリ演算子を使用します。
           Func<(int, int, int), (int, int, int)> doubleThem = ns => (2 * ns.Item1, 2 * ns.Item2, 2 * ns.Item3);
var numbers = (2, 3, 4);
var doubledNumbers = doubleThem(numbers);
Console.WriteLine($"The set {numbers} doubled: {doubledNumbers}");
// Output:
// The set (2, 3, 4) doubled: (4, 6, 8)
    Func<(int n1, int n2, int n3), (int, int, int)> doubleThem = ns => (2 * ns.n1, 2 * ns.n2, 2 * ns.n3);
var numbers = (2, 3, 4);
var doubledNumbers = doubleThem(numbers);
Console.WriteLine($"The set {numbers} doubled: {doubledNumbers}");
  public delegate TResult Func<in T, out TResult>(T arg)
    Func<int, bool> equalsFive = x => x == 5;
bool result = equalsFive(4);
Console.WriteLine(result);   // False
    int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
int oddNumbers = numbers.Count(n => n % 2 == 1);
Console.WriteLine($"There are {oddNumbers} odd numbers in {string.Join(" ", numbers)}");
 
  入力パラメーターの型はコンパイラが推論できますが、明示的に指定することもできます。 この特定のラムダ式は、2 で除算した ときに剰余が 1 になる整数 ( n ) をカウントします。
次の例では、numbers 配列内で9より前にある要素をすべて含むシーケンスを作成します。これは、9がシーケンス内で条件 を満たさない最初の数値であるためです。
次の例では、複数の入力パラメーターをかっこで囲んで指定します。 このメソッドは、値が numbers 配列内のその位置を表す 序数よりも小さい数値が出現するまで、その配列に含まれるすべての要素を返します。
ラムダ式の型の推定
ラムダを記述する際、多くの場合は入力パラメーターの型を指定する必要はありません。これは、ラムダ本体やパラメーターの型 など C# 言語仕様に記述されている要素に基づいて、コンパイラが型を推定できるためです。 ほとんどの標準クエリ演算子で は、最初の入力がソースシーケンス内の要素の型です。 IEnumerable<Customer> を問い合わせると、入力変数は
Customer オブジェクトであると推論されます。これは、そのメソッドとプロパティにアクセスできることを意味します。
ラムダの型の推定の一般規則は、次のとおりです。 ラムダにはデリゲート型と同じ数のパラメーターが含まれていなければなりません。 ラムダに含まれる各入力パラメーターは、対応するデリゲート パラメーターに暗黙的に変換できなければなりません。 ラムダの戻り値 (ある場合) は、デリゲートの戻り値の型に暗黙的に変換できなければなりません。
共通型システムには "ラムダ式" の概念が組み込まれていないため、ラムダ式自体は型を持ちません。 しかし、変則的ではあっ てもラムダ式の "型" を表現できると都合が良い場合もあります。 このような場合の型は、ラムダ式の変換後のデリゲート型また は Expression 型を指します。
ラムダ式における外部変数のキャプチャと変数のスコープ
ラムダでは "外部変数" を参照できます。 それは、そのラムダ式を定義しているメソッドのスコープ内にある変数、またはそのラム ダ式を含む型のスコープ内にある変数です。 こうして取り込まれた変数は、ラムダ式で使用するために格納されます。これは、 変数がスコープ外に出てガベージ コレクトされる場合でも変わりません。 外部変数は、ラムダ式で使用される前に明示的に代 入する必要があります。 次の例は、こうした規則を示しています。
          int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
var firstNumbersLessThanSix = numbers.TakeWhile(n => n < 6);
Console.WriteLine(string.Join(" ", firstNumbersLessThanSix));
// Output:
// 5 4 1 3
    int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
var firstSmallNumbers = numbers.TakeWhile((n, index) => n >= index);
Console.WriteLine(string.Join(" ", firstSmallNumbers));
// Output:
// 5 4
  customers.Where(c => c.City == "London");
 
    ラムダ式における変数のスコープには、次の規則が適用されます。
取り込まれた変数は、その変数を参照するデリゲートがガベージ コレクションの対象になるまでガベージ コレクトされませ ん。
ラムダ式内に導入された変数は、外側のメソッドでは参照できません。 ラムダ式は、外側のメソッドから in、ref、または out パラメーターを直接取り込むことはできません。 ラムダ式に含まれる return ステートメントで外側のメソッドが戻ることはありません。
ジャンプ先がラムダ式ブロックの外側にある場合は、ラムダ式に goto、break、または continue ステートメントを含めるこ とはできません。 また、ジャンプ先がブロックの内部にある場合に、ラムダ式ブロックの外部でジャンプ ステートメントを使 用するとエラーになります。
   public static class VariableScopeWithLambdas
{
    public class VariableCaptureGame
    {
        internal Action<int> updateCapturedLocalVariable;
        internal Func<int, bool> isEqualToCapturedLocalVariable;
        public void Run(int input)
        {
int j = 0;
            updateCapturedLocalVariable = x =>
            {
                j = x;
                bool result = j > input;
                Console.WriteLine($"{j} is greater than {input}: {result}");
            };
            isEqualToCapturedLocalVariable = x => x == j;
            Console.WriteLine($"Local variable before lambda invocation: {j}");
            updateCapturedLocalVariable(10);
            Console.WriteLine($"Local variable after lambda invocation: {j}");
} }
    public static void Main()
    {
        var game = new VariableCaptureGame();
        int gameInput = 5;
        game.Run(gameInput);
        int jTry = 10;
        bool result = game.isEqualToCapturedLocalVariable(jTry);
        Console.WriteLine($"Captured local variable is equal to {jTry}: {result}");
        int anotherJ = 3;
        game.updateCapturedLocalVariable(anotherJ);
        bool equalToAnother = game.isEqualToCapturedLocalVariable(anotherJ);
        Console.WriteLine($"Another lambda observes a new value of captured variable: {equalToAnother}");
    }
    // Output:
    // Local variable before lambda invocation: 0
    // 10 is greater than 5: True
    // Local variable after lambda invocation: 10
    // Captured local variable is equal to 10: True
    // 3 is greater than 5: False
    // Another lambda observes a new value of captured variable: True
}

            C# 9.0 以降では、ラムダ式に   修飾子を適用して、ラムダによる意図しないローカル変数またはインスタンスの状態の キャプチャを防ぐことができます。
静的ラムダでは外側のスコープからローカル変数またはインスタンスの状態をキャプチャすることはできませんが、静的メンバーと 定数の定義は参照することができます。
C# 言語仕様
詳細については、「C# 言語仕様」の無名関数の式に関するセクションを参照してください。
C# 9.0 で追加された機能の詳細については、機能の提案に関する次の記述を参照してください。
ラムダ ディスカード パラメーター 静的な匿名関数
関連項目
C# リファレンス
C# の演算子と式 統合言語クエリ (LINQ) 式ツリー ローカル関数とラムダ式の比較
Visual Studio 2008 C# Samples (Visual Studio 2008 の C# サンプル) (LINQ サンプル クエリ ファイルと XQuery プログ ラムを参照してください)
static
   Func<double, double> square = static x => x * x;
 
            + 演算子と += 演算子は、組み込みの整数および浮動小数点型の数値型、文字列型、デリゲート型によってサポートされ ています。
算術演算子 + については、「算術演算子(C#リファレンス)」の記事の「単項プラス演算子と単項マイナス演算子」セクション と「加算演算子 +」セクションを参照してください。
文字列連結
一方または両方のオペランドが文字列型の場合、 + 演算子によってそのオペランドの文字列表現が連結されます ( null の
文字列表現は空の文字列です)。
C# 6 以降、文字列補間という文字列を書式設定するより便利な方法が提供されています。
デリゲートの組み合わせ
同じデリゲート型のオペランドの場合、呼び出されると左側のオペランドを呼び出してから右側のオペランドを呼び出す新しいデリ ゲート インスタンスが + 演算子によって返されます。 いずれかのオペランドが null の場合、 + 演算子によって別のオペラン ドの値が返されます ( null でもある場合があります)。 次の例では、デリゲートが + 演算子と組み合わされるしくみを説明し ています。
デリゲートの削除を実行するには、 - 演算子を使用します。 デリゲート型の詳細については、デリゲートに関するページを参照してください。
加算代入演算子 +=
次のような += 演算子を使用する式があるとします
    Console.WriteLine("Forgot" + "white space");
Console.WriteLine("Probably the oldest constant: " + Math.PI);
Console.WriteLine(null + "Nothing to add.");
// Output:
// Forgotwhite space
// Probably the oldest constant: 3.14159265358979
// Nothing to add.
     Console.WriteLine($"Probably the oldest constant: {Math.PI:F2}");
// Output:
// Probably the oldest constant: 3.14
     Action a = () => Console.Write("a");
Action b = () => Console.Write("b");
Action ab = a + b;
ab();  // output: ab
   x += y
 + および += 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
           上記の式は、次の式と同じです。
  x=x+y
 ただし、x が評価されるのは1回だけです。 += 演算子の使用例を次に示します。
    int i = 5;
i += 9;
Console.WriteLine(i);
// Output: 14
string story = "Start. ";
story += "End.";
Console.WriteLine(story);
// Output: Start. End.
Action printer = () => Console.Write("a");
printer();  // output: a
Console.WriteLine();
printer += () => Console.Write("b");
printer();  // output: ab
 イベントをサブスクライブするとき、+= 演算子を使用してイベントハンドラーメソッドを指定することもできます。詳細について は、「方法: イベント サブスクリプションとサブスクリプションの解除」を参照してください。
演算子のオーバーロード可/不可
ユーザー定義型は + 演算子をオーバーロードできます。 2 項 + 演算子をオーバーロードすると、 += 演算子も暗黙的に
オーバーロードされます。 ユーザー定義型では、 += 演算子を明示的にオーバーロードできません。 C# 言語仕様
詳細については、C# 言語仕様の単項プラス演算子と加算演算子に関するセクションを参照してください。 関連項目
C# リファレンス
C# の演算子と式 複数の文字列を連結する方法 イベント
算術演算子
- および -= 演算子

         - 演算子と -= 演算子は、組み込みの整数および浮動小数点型の数値型と、デリゲート型によってサポートされています。 算術演算子 - については、「算術演算子(C#リファレンス)」の記事の「単項プラス演算子と単項マイナス演算子」セクション
と「減算演算子 -」セクションを参照してください。 デリゲートの削除
同じデリゲート型のオペランドに対しては、 - 演算子は、次のように計算されるデリゲート インスタンスを返します。
両方のオペランドが null 値ではなく、右側のオペランドの呼び出しリストが左側のオペランドの呼び出しリストの適切な 連続するサブリストの場合は、演算の結果は右側のオペランドのエントリを左側のオペランドの呼び出しリストから削除す ることによって取得される新しい呼び出しリストとなります。 右側のオペランドのリストが、左側のオペランドのリストで複数 の連続するサブリストと一致する場合、右端の一致するサブリストのみが削除されます。 削除によりリストが空になる場 合、結果は null になります。
    Action a = () => Console.Write("a");
Action b = () => Console.Write("b");
var abbaab = a + b + b + a + a + b;
abbaab();  // output: abbaab
Console.WriteLine();
var ab = a + b;
var abba = abbaab - ab;
abba();  // output: abba
Console.WriteLine();
var nihil = abbaab - abbaab;
Console.WriteLine(nihil is null);  // output: True
 右側のオペランドの呼び出しリストが左側のオペランドの呼び出しリストの適切な連続するサブリストでない場合は、演 算結果は左側のオペランドになります。 たとえば、マルチキャストのデリゲートの一部ではないデリゲートを削除しても何 も行われず、マルチキャストのデリゲートは変更されません。
- および -= 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
        前の例では、デリゲート中に削除デリゲートのインスタンスが比較されることも示しています。 たとえば、同一のラムダ式の 評価から生成されるデリゲートが等しくない、などです。 デリゲートの等値の詳細については、C# 言語仕様のデリゲート の等値演算子に関するセクションを参照してください。
左側のオペランドが null の場合は、演算結果は null になります。 右側のオペランドが null の場合は、演算結 果は左側のオペランドになります。
    Action a = () => Console.Write("a");
var nothing = null - a;
Console.WriteLine(nothing is null);  // output: True
var first = a - null;
a();  // output: a
Console.WriteLine();
Console.WriteLine(object.ReferenceEquals(first, a));  // output: True
 デリゲートを組み合わせるには、 + 演算子を使用します。 デリゲート型の詳細については、デリゲートに関するページを参照してください。
減算代入演算子 -=
次のような -= 演算子を使用する式があるとします
上記の式は、次の式と同じです。
ただし、x が評価されるのは1回だけです。 -= 演算子の使用例を次に示します。
  x -= y
   x=x-y
    Action a = () => Console.Write("a");
Action b = () => Console.Write("b");
var abbaab = a + b + b + a + a + b;
var aba = a + b + a;
var first = abbaab - aba;
first();  // output: abbaab
Console.WriteLine();
Console.WriteLine(object.ReferenceEquals(abbaab, first));  // output: True
Action a2 = () => Console.Write("a");
var changed = aba - a;
changed();  // output: ab
Console.WriteLine();
var unchanged = aba - a2;
unchanged();  // output: aba
Console.WriteLine();
Console.WriteLine(object.ReferenceEquals(aba, unchanged));  // output: True
 
           イベントから登録を解除するときに、-= 演算子を使用して削除するイベントハンドラーメソッドを指定することもできます。詳 細については、「イベントのサブスクリプションとサブスクリプション解除を行う方法」を参照してください。
演算子のオーバーロード可/不可
ユーザー定義型は - 演算子をオーバーロードできます。 2 項 - 演算子をオーバーロードすると、 -= 演算子も暗黙的に
オーバーロードされます。 ユーザー定義型では、 -= 演算子を明示的にオーバーロードできません。 C# 言語仕様
詳細については、C# 言語仕様の単項マイナス演算子と減算演算子に関するセクションを参照してください。 関連項目
C# リファレンス
C# の演算子と式 イベント 算術演算子
+ および += 演算子
   int i = 5;
i -= 9;
Console.WriteLine(i);
// Output: -4
Action a = () => Console.Write("a");
Action b = () => Console.Write("b");
var printer = a + b + a;
printer();  // output: aba
Console.WriteLine();
printer -= a;
printer();  // output: ab
 
   条件演算子 ?: は、三項条件演算子とも呼ばれ、ブール式を評価し、ブール式の評価結果 ( true または false ) に応じ て、2 つの式のいずれかの結果を返します。
この条件演算子の構文は次のとおりです。
式は true または false と評価する必要があります。 式が評価され、その結果が演算の結果になります。
が true と評価された場合は、 が false と評価された場合は、
  condition ? consequent : alternative
   condition
condition
  consequent
condition
    または alternative のみが評価されます。 consequent と alternative の型は、暗黙的にターゲット型に変換できる必要があります。
条件式のターゲット型が不明な場合(たとえば、var キーワードを使用する場合)またはC#8.0以前の場合、consequent と alternative の型は同じであるか、またはある型から別の型に暗黙的に変換される必要があります。
条件演算子は右結合です。つまり、次の形式の式があるとします。
これが次のように評価されます。
式が評価され、その結果が演算の結果になります。
C# 9.0 以降、条件式はターゲット型になっています。 つまり、条件式のターゲット型がわかっている場合、次の例に示すように、
alternative
consequent
      var rand = new Random();
var condition = rand.NextDouble() > 0.5;
int? x = condition ? 12 : null;
IEnumerable<int> xs = x is null ? new List<int>() { 0, 1 } : new int[] { 2, 3 };
       var rand = new Random();
var condition = rand.NextDouble() > 0.5;
var x = condition ? 12 : (int?)null;
   a?b:c?d:e
   a ? b : (c ? d : e)
     TIP
次のニーモニック デバイスを使用して、条件演算子の評価方法を思い出すことができます。
  is this condition true ? yes : no
  条件演算子の使用例を次に示します。
?: 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
      ref 条件式
C# 7.2 以降、ref 条件式は、ref ローカルまたは ref readonly ローカル変数を使用して条件付きで割り当てることができま
す。ref条件式を参照戻り値または ref メソッドの引数として使用することもできます。 ref 条件式の構文は次のとおりです。
ref条件式では、元の条件演算子と同じように、2つの式(consequent または alternative)のいずれかのみが評価されま す。
ref条件式の場合、consequent と alternative の型は同じである必要があります。ref条件式は、ターゲット型ではありま せん。
ref 条件演算子の使用例を次に示します。
  condition ? ref consequent : ref alternative
         var smallArray = new int[] { 1, 2, 3, 4, 5 };
var largeArray = new int[] { 10, 20, 30, 40, 50 };
int index = 7;
ref int refValue = ref ((index < 5) ? ref smallArray[index] : ref largeArray[index - 5]);
refValue = 0;
index = 2;
((index < 5) ? ref smallArray[index] : ref largeArray[index - 5]) = 100;
Console.WriteLine(string.Join(" ", smallArray));
Console.WriteLine(string.Join(" ", largeArray));
// Output:
// 1 2 100 4 5
// 10 20 0 40 50
  条件演算子と if..else ステートメント
if-else ステートメントではなく条件演算子を使用すると、値の計算を条件付きで実行する必要がある場合に、コードをもっと簡 潔にできる可能性があります。 次の例では、整数を負の値または負以外の値に分類するための 2 つの方法を示しています。
   double sinc(double x) => x != 0.0 ? Math.Sin(x) / x : 1;
Console.WriteLine(sinc(0.1));
Console.WriteLine(sinc(0.0));
// Output:
// 0.998334166468282
// 1
 
            演算子のオーバーロード可/不可 ユーザー定義型は条件演算子をオーバーロードできません。
C# 言語仕様
詳細については、「C# 言語仕様」の「条件演算子」セクションを参照してください。
C# 7.2 以降に追加された機能の詳細については、機能の提案に関する次の記述を参照してください。
ref 条件式 (C# 7.2) ターゲット型の条件式 (C# 9.0)
関連項目
C# リファレンス
C# の演算子と式 if-else ステートメント ?. および ?[] 演算子 ?? および ??= 演算子 ref キーワード
   int input = new Random().Next(-5, 5);
string classify;
if (input >= 0)
{
    classify = "nonnegative";
}
else {
    classify = "negative";
}
classify = (input >= 0) ? "nonnegative" : "negative";
 
       C#8.0以降では、単項の接尾辞 ! 演算子はnull免除(またはnull抑制)演算子です。有効なnull許容注釈コンテキ ストでは、null 免除演算子を使用して、参照型の式 x が null : x! ではないことを宣言します。 単項の接頭辞 ! 演算 子は、論理否定演算子です。
null 免除演算子は実行時には影響を与えません。 式の null 状態を変更することによって、コンパイラの静的フロー分析にの み影響を与えます。実行時に、式 x! は基になる式 x の結果に評価されます。
null 許容参照型の機能の詳細については、「null 許容参照型」を参照してください。 使用例
null 免除演算子のユース ケースの 1 つは、引数検証ロジックをテストすることです。 たとえば、次のクラスを考えてみます。
MSTest テスト フレームワーク を使用して、コンストラクターの検証ロジックに対して次のテストを作成できます。
null 免除演算子を使用しない場合は、コンパイラによって上のコードに対して次の警告が生成されます:
Warning CS8625: Cannot convert null literal to non-nullable reference type 。 null 免除演算子を使用すると、 null を渡すことが予測されており、警告を生成しないことがコンパイラに通知されます。
また、式を null にできないことが明確にわかっているが、コンパイラでそのことを認識できない場合にも、null免除演算子を使 用できます。 次の例では、 IsValid メソッドによって true が返された場合、その引数は null ではなく、安全に逆参照で きます。
    #nullable enable
public class Person
{
    public Person(string name) => Name = name ?? throw new ArgumentNullException(nameof(name));
    public string Name { get; }
}
     [TestMethod, ExpectedException(typeof(ArgumentNullException))]
public void NullNameShouldThrowTest()
{
    var person = new Person(null!);
}
         public static void Main()
{
    Person? p = Find("John");
    if (IsValid(p))
    {
        Console.WriteLine($"Found {p!.Name}");
    }
}
public static bool IsValid(Person? person)
{
    return person != null && !string.IsNullOrEmpty(person.Name);
}
 ! (null 免除) 演算子 (C# リファレンス) 2021/03/06 • • Edit Online
 
         null 免除演算子を使用しない場合は、コンパイラによって   コードに対して次の警告が生成されます: 。
IsValid メソッドを変更できる場合は、NotNullWhen属性を使用して、メソッドによって true が返されたときに IsValid メソッドの引数を null にできないことをコンパイラに通知することができます。
p.Name
   Warning CS8602: Dereference of a possibly null reference
       public static void Main()
{
    Person? p = Find("John");
    if (IsValid(p))
    {
        Console.WriteLine($"Found {p.Name}");
    }
}
public static bool IsValid([NotNullWhen(true)] Person? person)
{
    return person != null && !string.IsNullOrEmpty(person.Name);
}
 前の例では、null 免除演算子を使用する必要はありません。これは、 if ステートメント内で p を null にできないことを把 握するのに十分な情報がコンパイラに含まれているためです。 変数の null 状態に関する追加情報を提供するための属性の 詳細については、null 予測を定義する属性を使用した API のアップグレードに関するページを参照してください。
C# 言語仕様
詳細については、null 許容参照型仕様の下書きの「null 免除演算子」セクションを参照してください。
関連項目
C# リファレンス
C# の演算子と式
チュートリアル: null 許容参照型を使用して設計する

       null合体演算子 ?? では、それが null ではない場合、その左側のオペランドの値が返されます。それ以外の場合は、右 側のオペランドが評価され、その結果が返されます。 ?? 演算子では、左側のオペランドがnull値以外に評価された場合 は、その右側のオペランドは評価されません。
C#8.0以降では、左側のオペランドが null に評価された場合にのみ、右側のオペランドの値を左側のオペランドに割り当て るnull合体割り当て演算子 ??= を使用できます。 ??= 演算子では、左側のオペランドがnull値以外に評価された場合 は、その右側のオペランドは評価されません。
    List<int> numbers = null;
int? a = null;
(numbers ??= new List<int>()).Add(5);
Console.WriteLine(string.Join(" ", numbers));  // output: 5
numbers.Add(a ??= 0);
Console.WriteLine(string.Join(" ", numbers));  // output: 5 0
Console.WriteLine(a);  // output: 0
 ??= 演算子の左側のオペランドは、変数、プロパティ、またはインデクサー要素である必要があります。
C#7.3以前では、?? 演算子の左側のオペランドの型は、参照型またはnull許容値型である必要があります。C#8.0以 降では、その要件は次に置き換えられます。 ?? 演算子と ??= 演算子の左側のオペランドの型は、null 非許容値型にする ことはできません。 特に、C# 8.0 以降では、null 合体演算子を制約のない型パラメーターと共に使用できます。
null 合体演算子は、右結合です。 つまり、フォームの式
は次のように評価されます。
例
?? 演算子および ??= 演算子は、次のシナリオで役立つことがあります。
null条件演算子?.および?[]を含む式は、null条件演算の式の結果が null の場合に評価する代替の式を指定 するために、 ?? 演算子を使用することができます。
    private static void Display<T>(T a, T backup)
{
    Console.WriteLine(a ?? backup);
}
     a ?? b ?? c
d ??= e ??= f
     a ?? (b ?? c)
d ??= (e ??= f)
 ?? および ?? 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
           null値許容型を使用して、基になる値の型の値を提供する必要がある場合、?? 演算子を使用して、null値許容 型が null の場合に提供する値を指定します。
null値許容型が null の場合に使用される値を、基になる値型の既定値にする場合 は、Nullable<T>.GetValueOrDefault() メソッドを使用します。
C#7.0以降では、?? 演算子の右側のオペランドとして throw 式を使用し、引数のチェックコードをより簡潔にする ことができます。
上記の例は、式のようなメンバーを使用してプロパティを定義する方法も示しています。 C#8.0以降では、??= 演算子を使用して、フォームのコード
を、以下のコードに置き換えます。
演算子のオーバーロード可/不可 演算子 ?? および ??= はオーバーロードできません。
C# 言語仕様
?? 演算子の詳細については、C#言語仕様のnull合体演算子に関するセクションを参照してください。
??= リテラルの詳細については、機能提案メモを参照してください。 参照
C# リファレンス C# の演算子と式
    int? a = null;
int b = a ?? -1;
Console.WriteLine(b);  // output: -1
     public string Name
{
get => name;
    set => name = value ?? throw new ArgumentNullException(nameof(value), "Name cannot be null");
}
     if (variable is null)
{
    variable = expression;
}
   variable ??= expression;
    double SumNumbers(List<double[]> setsOfNumbers, int indexOfSetToSum)
{
    return setsOfNumbers?[indexOfSetToSum]?.Sum() ?? double.NaN;
}
var sum = SumNumbers(null, 0);
Console.WriteLine(sum);  // output: NaN
 
   ?. および ?[] 演算子 ?:演算子 (C# リファレンス)

        => トークンは、ラムダ演算子、および式本体の定義におけるメンバー名とメンバー実装の区切り記号という2つの形式でサ ポートされています。
ラムダ演算子
ラムダ式では、ラムダ演算子 => により、左側の入力パラメーターと右側のラムダ本体とが分けられます。
次の例は、メソッド構文で LINQ 機能を使用して、ラムダ式の使用法を示しています。
    string[] words = { "bot", "apple", "apricot" };
int minimalLength = words
  .Where(w => w.StartsWith("a"))
  .Min(w => w.Length);
Console.WriteLine(minimalLength);   // output: 5
int[] numbers = { 4, 7, 10 };
int product = numbers.Aggregate(1, (interim, next) => interim * next);
Console.WriteLine(product);   // output: 280
 ラムダ式の入力パラメーターは、コンパイル時に厳密に型指定されます。 前の例のように、コンパイラが入力パラメーターの型を 推論できる場合は、型宣言を省略できます。 入力パラメーターの型を指定する必要がある場合は、次の例に示すように、パラ メーターごとに指定する必要があります。
次の例は、入力パラメーターを含まないラムダ式を定義する方法を示しています。
詳細については、「ラムダ式」を参照してください。 式本体の定義
式本体の定義には、次の一般的な構文があります。
ここで、 expression には有効な式を指定します。 expression の戻り値の型は、メンバーの戻り値の型に暗黙的に変換可 能である必要があります。 メンバーの戻り値の型が void の場合や、メンバーがコンストラクター、ファイナライザー、プロパティま たはインデクサー set のアクセサーの場合、 expression は "ステートメント式" である必要があります。 式の結果が破棄され るため、その式の戻り値の型は任意の型にすることができます。
    int[] numbers = { 4, 7, 10 };
int product = numbers.Aggregate(1, (int interim, int next) => interim * next);
Console.WriteLine(product);   // output: 280
     Func<string> greet = () => "Hello, World!";
Console.WriteLine(greet());
   member => expression;
     次の例は、 Person.ToString メソッドの式本体の定義を示しています。
=> 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
       これは、次のメソッド定義の短縮形バージョンです。
    public override string ToString()
{
   return $"{fname} {lname}".Trim();
}
 メソッド、演算子、および読み取り専用プロパティの式本体の定義は、C# 6 以降でサポートされています。 コンストラクター、ファ イナライザー、プロパティ アクセサー、およびインデクサー アクセサーの式本体の定義は、C# 7.0 以降でサポートされています。
詳細については、「式形式のメンバー」を参照してください。 演算子のオーバーロード可/不可
=> 演算子はオーバーロードできません。 C# 言語仕様
ラムダ演算子の詳細については、「C# 言語仕様」の匿名関数の式に関するセクションを参照してください。 関連項目
C# リファレンス C# の演算子と式
 public override string ToString() => $"{fname} {lname}".Trim();
 
         エイリアスが設定された名前空間のメンバーにアクセスするには、名前空間エイリアス修飾子 :: を使います。 :: 修飾子は 2 つの識別子の間でのみ使用できます。 左側の識別子には、次のエイリアスのいずれかを指定できます。
using エイリアス ディレクティブを使って作成された名前空間エイリアス:
    using forwinforms = System.Drawing;
using forwpf = System.Windows;
public class Converters
{
    public static forwpf::Point Convert(forwinforms::Point point) => new forwpf::Point(point.X,
point.Y);
}
 extern エイリアス。
global エイリアス。これはグローバル名前空間エイリアスです。グローバル名前空間は、名前付き名前空間内で宣 言されていない名前空間と型を含んだ名前空間です。 global エイリアスを :: 修飾子と共に使った場合は、ユー ザー定義の名前空間エイリアス global が存在していたとしても、常にグローバル名前空間が参照されます。
次の例では、 エイリアスを使って、グローバル名前空間のメンバーである .NET の System 名前空間にアクセス
     します。
エイリアスを使わない場合は、 MyCompany.MyProduct 名前空間のメンバーであるユーザー定義の 名前空間がアクセスされます。
global
 global
 System
    namespace MyCompany.MyProduct.System
{
    class Program
    {
        static void Main() => global::System.Console.WriteLine("Using global alias");
    }
    class Console
    {
        string Suggestion => "Consider renaming this class";
    }
}
     NOTE
global キーワードは、 :: 修飾子の左側の識別子に指定した場合にのみ、グローバル名前空間エイリアスとなります。
  また、 . トークンを使って、エイリアスが設定された名前空間のメンバーにアクセスすることもできます。 ただし、 . トークンは型 のメンバーにアクセスするためにも使用されます。 :: 修飾子を使う場合、その左側の識別子は、同じ名前を持つ型または名 前空間が存在したとしても、常に名前空間エイリアスを参照することが保証されます。
C# 言語仕様
詳細については、C# 言語仕様に関するページの「名前空間エイリアス修飾子」セクションをご覧ください。
:: 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
    関連項目
C# リファレンス C# の演算子と式 名前空間の使用

        await 演算子では、そのオペランドによって表わされる非同期操作が完了するまで、外側のasyncメソッドの評価が保留に なります。 非同期操作が完了すると、 await 演算子から演算の結果が返されます (結果がある場合)。 既に完了している操 作を表すオペランドに await 演算子が適用されると、外側のメソッドを保留にすることなく、演算の結果がすぐに返されます。
await 演算子では、asyncメソッドを評価するスレッドがブロックされません。 await 演算子によって外側のasyncメソッドが 保留になるとき、メソッドの呼び出し元にコントロールが戻ります。
次の例では、完了時にバイト配列を生成する非同期操作を表わす Task<byte[]> インスタンス が、HttpClient.GetByteArrayAsyncメソッドから返されます。操作が完了するまで、await 演算子によって
メソッドが保留になります。 DownloadDocsMainPageAsync が保留になると、
の呼び出し元である Main メソッドにコントロールが返されます。 DownloadDocsMainPageAsync メソッドで実行される非同期操作の結果が必要になるまで Main メソッドが実行されます。GetByteArrayAsyncですべての バイトが得られると、 DownloadDocsMainPageAsync メソッドの残りが評価されます。 その後、 Main メソッドの残りが評価されま す。
  DownloadDocsMainPageAsync
  DownloadDocsMainPageAsync
       using System;
using System.Net.Http;
using System.Threading.Tasks;
public class AwaitOperator
{
    public static async Task Main()
    {
        Task<int> downloading = DownloadDocsMainPageAsync();
        Console.WriteLine($"{nameof(Main)}: Launched downloading.");
        int bytesLoaded = await downloading;
        Console.WriteLine($"{nameof(Main)}: Downloaded {bytesLoaded} bytes.");
    }
    private static async Task<int> DownloadDocsMainPageAsync()
    {
        Console.WriteLine($"{nameof(DownloadDocsMainPageAsync)}: About to start downloading.");
        var client = new HttpClient();
        byte[] content = await client.GetByteArrayAsync("https://docs.microsoft.com/en-us/");
        Console.WriteLine($"{nameof(DownloadDocsMainPageAsync)}: Finished downloading.");
        return content.Length;
    }
}
// Output similar to:
// DownloadDocsMainPageAsync: About to start downloading.
// Main: Launched downloading.
// DownloadDocsMainPageAsync: Finished downloading.
// Main: Downloaded 27700 bytes.
 前の例では、async Main メソッドが使用されています。これは C# 7.1 以降で可能です。 詳細は、「await operator in the Main method」 (Main メソッドの await 演算子) セクションを参照してください。
await 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
                                       メソッド、ラムダ式、asyncキーワードで修飾される匿名メソッドでのみ await 演算子を使用できます。asyncメソッド内で は、同期関数の本文の中、lockステートメントのブロックの内部、安全でないコンテキストの中で await 演算子を使用するこ とはできません。
.NETの型としてTask、Task<TResult>、ValueTask、ValueTask<TResult>がありますが、await 演算子のオペランドはその いずれかになります。ただし、待機可能な式であれば await 演算子のオペランドになります。詳細については、「C#言語仕 様」の「待機可能な式」セクションを参照してください。
式 t の型が Task<TResult> または ValueTask<TResult> の場合、式 await t の型は TResult になります。 t の型 が Task または ValueTask の場合、 await t の型は void になります。 いずれの場合も、 t で例外がスローされる場合、 await t で再び例外がスローされます。 例外処理の詳細については、try-catch ステートメントに関する記事の「非同期メ
ソッドの例外」を参照してください。
async キーワードと await キーワードは、C#5以降で使用できます。
非同期のストリームと破棄可能
C# 8.0 以降、非同期のストリームと破棄可能を使用できます。
await foreach ステートメントを使用してデータの非同期ストリームを利用できます。 詳細については、 foreach ステートメン トに関する記事、および記事「C# 8.0 の新機能」の「非同期ストリーム」セクションを参照してください。
await using ステートメントを使用し、非同期破棄可能オブジェクト、つまり、IAsyncDisposableインターフェイスを実装する 型のオブジェクトを操作します。 詳細については、「DisposeAsync メソッドの実装」記事の「非同期の破棄可能の使用」を参 照してください。
Main メソッドの await 演算子
C#7.1以降、アプリケーションエントリポイントである Main メソッドから Task または Task<int> が返され、その本文で await 演算子を使用できるよう、非同期にすることができます。以前のC#バージョンでは、非同期操作の完了を Main メ
ソッドが待つようにする目的で、対応する async メソッドから返される Task<TResult> インスタンスの Task<TResult>.Result プロパティの値を取得できます。 値を生成しない非同期操作の場合、Task.Wait メソッドを呼び出すことができます。 言語の バージョンを選択する方法については、「C# 言語のバージョン管理」を参照してください。
C# 言語仕様
詳細については、「C# 言語仕様」の「Await 式」セクションを参照してください。
関連項目
C# リファレンス
C# の演算子と式
async
タスクの非同期プログラミング モデル
非同期プログラミング
非同期の詳細
チュートリアル: async と await を使用した Web へのアクセス
チュートリアル: C#8.0 および .NET Core 3.0 を使用して非同期ストリームを生成および使用する
           NOTE
非同期プログラミングの概要については、「async および await を使用した非同期プログラミング」を参照してください。 async と await による非同期プログラミングは、タスクベースの非同期パターンに続きます。
 
         既定値式を使用すると、型の既定値が生成されます。 既定値式には、次の 2 種類があります: default 演算子の呼び出し と、default リテラルです。
また、 switch ステートメント内の既定の case ラベルとして、 default キーワードを使うこともできます。 default 演算子
default 演算子への引数では、次の例で示すように、型または型パラメーターの名前を指定する必要があります。
       Console.WriteLine(default(int));  // output: 0
Console.WriteLine(default(object) is null);  // output: True
void DisplayDefaultOf<T>()
{
    var val = default(T);
    Console.WriteLine($"Default value of {typeof(T)} is {(val == null ? "null" : val.ToString())}.");
}
DisplayDefaultOf<int?>();
DisplayDefaultOf<System.Numerics.Complex>();
DisplayDefaultOf<System.Collections.Generic.List<int>>();
// Output:
// Default value of System.Nullable`1[System.Int32] is null.
// Default value of System.Numerics.Complex is (0, 0).
// Default value of System.Collections.Generic.List`1[System.Int32] is null.
 default リテラル
C#7.1以降では、default リテラルを使って、コンパイラが式の型を推論できる場合に、型の既定値を生成できます。 default リテラル式では、 T が推定型である式 default(T) と同じ値が生成されます。 default リテラルは、次のいずれの
場合でも使用できます。
変数の代入または初期化。
省略可能なメソッド パラメーターの既定値の宣言。 メソッド呼び出しでの引数値の指定。
return ステートメント内、または式のようなメンバー内の式として。 default リテラルの使い方の例を次に示します。
      既定値式 (C# リファレンス) 2020/11/02 • • Edit Online
 
         C# 言語仕様
詳細については、「C# 言語仕様」の「既定値の式」セクションをご覧ください。
default リテラルについて詳しくは、機能提案メモをご覧ください。 関連項目
C# リファレンス
C# の演算子と式 C# 型の既定値 .NET のジェネリック
    T[] InitializeArray<T>(int length, T initialValue = default)
{
    if (length < 0)
    {
        throw new ArgumentOutOfRangeException(nameof(length), "Array length must be nonnegative.");
    }
    var array = new T[length];
    for (var i = 0; i < length; i++)
    {
        array[i] = initialValue;
    }
    return array;
}
void Display<T>(T[] values) => Console.WriteLine($"[ {string.Join(", ", values)} ]");
Display(InitializeArray<int>(3));  // output: [ 0, 0, 0 ]
Display(InitializeArray<bool>(4, default));  // output: [ False, False, False, False ]
System.Numerics.Complex fillValue = default;
Display(InitializeArray(3, fillValue));  // output: [ (0, 0), (0, 0), (0, 0) ]
 
      delegate 演算子を使うと、デリゲート型に変換できる匿名メソッドを作成できます。
    Func<int, int, int> sum = delegate (int a, int b) { return a + b; };
Console.WriteLine(sum(3, 4));  // output: 7
     NOTE
C# 3 以降では、匿名関数を作成するためのより簡潔で表現性に優れた方法がラムダ式によって提供されています。 ラムダ式を作成する には、=> 演算子を使います。
外部変数のキャプチャなど、ラムダ式の機能の詳細については、ラムダ式に関するページをご覧ください。
  Func<int, int, int> sum = (a, b) => a + b; Console.WriteLine(sum(3, 4)); // output: 7
   delegate 演算子を使用する際に、パラメーターリストを省略する場合があります。そうした場合、次の例に示すように、作成 された匿名メソッドは任意のパラメーター リストを持つデリゲート型に変換できます。
    Action greet = delegate { Console.WriteLine("Hello!"); };
greet();
Action<int, double> introduce = delegate { Console.WriteLine("This is world!"); };
introduce(42, 2.7);
// Output:
// Hello!
// This is world!
 これは、ラムダ式でサポートされていない匿名メソッドの唯一の機能です。 それ以外の場合は、すべてラムダ式を使用してインラ イン コードを書くことをお勧めします。
C# 9.0 以降では、破棄を使用して、メソッドで使用しない匿名メソッドの 2 つ以上の入力パラメーターを指定できます。
下位互換性のために、1 つのパラメーターにのみ _ という名前が付けられた場合、 _ は匿名メソッド内でそのパラメーターの 名前として扱われます。
また、C#9.0以降では、static 修飾子を匿名メソッドの宣言で使用できます。
静的な匿名メソッドでは、外側のスコープからローカル変数またはインスタンスの状態をキャプチャすることはできません。 delegate キーワードは、デリゲート型を宣言するためにも使います。
    Func<int, int, int> constant = delegate (int _, int _) { return 42; };
Console.WriteLine(constant(3, 4));  // output: 42
      Func<int, int, int> sum = static delegate (int a, int b) { return a + b; };
Console.WriteLine(sum(10, 4));  // output: 14
  delegate 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
      C# 言語仕様
詳細については、「C# 言語仕様」の無名関数の式に関するセクションを参照してください。
関連項目
C# リファレンス C# の演算子と式 => 演算子

          nameof 式を使うと、変数、型、またはメンバーの名前が文字列定数として生成されます。
    Console.WriteLine(nameof(System.Collections.Generic));  // output: Generic
Console.WriteLine(nameof(List<int>));  // output: List
Console.WriteLine(nameof(List<int>.Count));  // output: Count
Console.WriteLine(nameof(List<int>.Add));  // output: Add
var numbers = new List<int> { 1, 2, 3 };
Console.WriteLine(nameof(numbers));  // output: numbers
Console.WriteLine(nameof(numbers.Count));  // output: Count
Console.WriteLine(nameof(numbers.Add));  // output: Add
 前の例で示されているように、型と名前空間の場合、生成される名前は完全修飾ではありません。 逐語的識別子の場合、次の例に示すように、 @ 文字は名前の一部ではありません。
nameof 式はコンパイル時に評価され、実行時には影響を与えません。
nameof 式を使って、引数をチェックするコードの保守性を高めることができます。
nameof 式はC#6以降で使用できます。 C# 言語仕様
詳細については、C# 言語仕様の「Nameof 式」セクションをご覧ください。 関連項目
C# リファレンス C# の演算子と式
    var @new = 5;
Console.WriteLine(nameof(@new));  // output: new
       public string Name
{
get => name;
    set => name = value ?? throw new ArgumentNullException(nameof(value), $"{nameof(Name)} cannot be null");
}
  nameof 式 (C# リファレンス) 2021/03/06 • • Edit Online
 
       new 演算子は型の新しいインスタンスを作成します。
new キーワードは、メンバーの宣言修飾子またはジェネリック型制約として使用することもできます。
コンストラクターの呼び出し
型の新しいインスタンスを作成するには、通常は new 演算子を使用して、その型のコンストラクターの1つを呼び出します。
 オブジェクトまたはコレクション初期化子を new 演算子と共に使用して、1つのステートメント内でオブジェクトのインスタンス化 と初期化を行うことができます。次に例を示します。
 C# 9.0 以降、コンストラクターの呼び出し式はターゲット型になっています。 つまり、式のターゲット型がわかっている場合は、次 の例に示すように、型名を省略できます。
 前の例に示されているように、ターゲット型の new 式では常にかっこを使用します。
new 式のターゲット型が不明な場合(たとえば var キーワードを使用する場合)は、型名を指定する必要があります。
配列の作成
new 演算子を使用して配列インスタンスを作成することもできます。次に例を示します。
new 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
    var dict = new Dictionary<string, int>();
dict["first"] = 10;
dict["second"] = 20;
dict["third"] = 30;
Console.WriteLine(string.Join("; ", dict.Select(entry => $"{entry.Key}: {entry.Value}")));
// Output:
// first: 10; second: 20; third: 30
    var dict = new Dictionary<string, int>
{
    ["first"] = 10,
    ["second"] = 20,
    ["third"] = 30
};
Console.WriteLine(string.Join("; ", dict.Select(entry => $"{entry.Key}: {entry.Value}")));
// Output:
// first: 10; second: 20; third: 30
    List<int> xs = new();
List<int> ys = new(capacity: 10_000);
List<int> zs = new() { Capacity = 20_000 };
Dictionary<int, List<int>> lookup = new()
{
    [1] = new() { 1, 2, 3 },
    [2] = new() { 5, 8, 3 },
    [5] = new() { 1, 0, 4 }
};
 
           1 つのステートメント内で配列の初期化構文を使用して配列インスタンスを作成し、そこに要素を設定します。 次の例に、これ を行うためのさまざまな方法を示します。
配列の詳細については、「配列」を参照してください。 匿名型のインスタンス化
匿名型のインスタンスを作成するには、 new 演算子とオブジェクト初期化子構文を使用します。
型インスタンストの破棄
以前作成した型のインスタンスを破棄する必要はありません。 参照型と値型のインスタンスは両方とも自動的に破棄されま す。 値型のインスタンスは、それらを格納しているコンテキストが破棄されるとすぐに破棄されます。 参照型のインスタンスはガ ベージ コレクターによって、そのインスタンスへの最後の参照が削除された後、不特定のタイミングで破棄されます。
ファイル ハンドルなどのアンマネージド リソースを含む型インスタンスの場合、格納されているリソースができるだけ早く確実に解 放されるように、決定的なクリーンアップを使用することをお勧めします。 詳細については、System.IDisposable API リファレン スと using ステートメントに関する記事を参照してください。
演算子のオーバーロード可/不可 ユーザー定義型は new 演算子をオーバーロードできません。
C# 言語仕様
詳細については、C# 言語仕様の new 演算子に関するセクションを参照してください。 ターゲット型の new 式について詳しくは、機能提案メモをご覧ください。
参照
C# リファレンス
C# の演算子と式 オブジェクト初期化子とコレクション初期化子
     var numbers = new int[3];
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
Console.WriteLine(string.Join(", ", numbers));
// Output:
// 10, 20, 30
    var a = new int[3] { 10, 20, 30 };
var b = new int[] { 10, 20, 30 };
var c = new[] { 10, 20, 30 };
Console.WriteLine(c.GetType());  // output: System.Int32[]
    var example = new { Greeting = "Hello", Name = "World" };
Console.WriteLine($"{example.Greeting}, {example.Name}!");
// Output:
// Hello, World!
 
       sizeof は、指定された型の変数が占有しているバイト数を返します。 sizeof 演算子への引数は、アンマネージド型の名 前、またはアンマネージド型に制限される型パラメーターである必要があります。
sizeof 演算子にはunsafeコンテキストが必要です。ただし、次の表に示す式は、コンパイル時に対応する定数値に評価さ れ、unsafe コンテキストを必要としません。
sizeof(sbyte) 1 sizeof(byte) 1 sizeof(short) 2 sizeof(ushort) 2 sizeof(int) 4 sizeof(uint) 4 sizeof(long) 8 sizeof(ulong) 8 sizeof(char) 2 sizeof(float) 4 sizeof(double) 8 sizeof(decimal) 16 sizeof(bool) 1
sizeof 演算子のオペランドが列挙型の名前である場合も、unsafeコンテキストを使用する必要はありません。 sizeof 演算子の使用例を次に示します。
                                                                      sizeof 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
            sizeof 演算子は、マネージドメモリ内の共通言語ランタイムによって割り当てられるバイト数を返します。構造体型の場 合、前の例のように、その値に埋め込みが含まれます。 sizeof 演算子の結果は、アンマネージドメモリの型のサイズを返す Marshal.SizeOf メソッドの結果とは異なる場合があります。
C# 言語仕様
詳細については、C# 言語仕様の sizeof 演算子に関するセクションを参照してください。
参照
C# リファレンス
C# の演算子と式 ポインターに関連する演算子 ポインター型 メモリおよびスパンに関連する型 .NET のジェネリック
    using System;
public struct Point
{
    public Point(byte tag, double x, double y) => (Tag, X, Y) = (tag, x, y);
    public byte Tag { get; }
    public double X { get; }
    public double Y { get; }
}
public class SizeOfOperator
{
    public static void Main()
    {
        Console.WriteLine(sizeof(byte));  // output: 1
        Console.WriteLine(sizeof(double));  // output: 8
        DisplaySizeOf<Point>();  // output: Size of Point is 24
        DisplaySizeOf<decimal>();  // output: Size of System.Decimal is 16
unsafe {
            Console.WriteLine(sizeof(Point*));  // output: 8
        }
}
    static unsafe void DisplaySizeOf<T>() where T : unmanaged
    {
        Console.WriteLine($"Size of {typeof(T)} is {sizeof(T)}");
    }
}
 
               stackalloc 式を使用すると、スタックにメモリブロックを割り当てることができます。メソッドの実行中に作成された、スタックに 割り当てられたメモリブロックは、そのメソッドが戻るときに自動的に破棄されます。 stackalloc を使用して割り当てられたメモ リを明示的に開放することはできません。 スタックに割り当てられたメモリ ブロックは、ガベージ コレクションの対象外であり、
fixed ステートメントを使用してピン留めする必要はありません。
stackalloc 式の結果を、次のいずれかの型の変数に割り当てることができます。
C# 7.2 以降では System.Span<T> または System.ReadOnlySpan<T>。次に例を示します。
スタックに割り当てられたメモリ ブロックを Span<T> 変数または ReadOnlySpan<T> 変数に割り当てるとき に、unsafe コンテキストを使用する必要はありません。
これらの型を操作するときに、次の例に示すように、条件式または代入式の中で stackalloc 式を使用できます。
C# 8.0 以降では、次の例のように、Span<T> または ReadOnlySpan<T> の変数が許可されるところでは、他の式の 中で stackalloc 式を使用できます。
      int length = 3;
Span<int> numbers = stackalloc int[length];
for (var i = 0; i < length; i++)
{
    numbers[i] = i;
}
      int length = 1000;
Span<byte> buffer = length <= 1024 ? stackalloc byte[length] : new byte[length];
      Span<int> numbers = stackalloc[] { 1, 2, 3, 4, 5, 6 };
var ind = numbers.IndexOfAny(stackalloc[] { 2, 4, 6 ,8 });
Console.WriteLine(ind);  // output: 1
     NOTE
スタックに割り当てられたメモリを操作するときは、できるだけ Span<T> 型または ReadOnlySpan<T> 型を使用することをお勧め します。
 ポインター型。次に例を示します。
    unsafe {
    int length = 3;
    int* numbers = stackalloc int[length];
    for (var i = 0; i < length; i++)
    {
        numbers[i] = i;
    }
}
 stackalloc 式 (C# リファレンス) 2020/11/02 • • Edit Online
 
             前の例に示したように、ポインター型を操作するときは、   コンテキストを使用する必要があります。
 ポインター型の場合、ローカル変数宣言でのみ stackalloc 式を使用し、変数を初期化できます。 スタックで使用可能なメモリ容量は制限されています。 スタックに割り当てたメモリが多すぎると、StackOverflowException が
スローされます。 これを回避するために、次の規則に従ってください。 stackalloc を使って割り当てるメモリ容量を制限する:
スタックで使用可能なメモリ容量はコードが実行される環境によって異なるため、実際の制限値は控えめに定義する必 要があります。
ループ内での stackalloc の使用を避ける。ループの外側でメモリブロックを割り当て、それをループ内で再利用してく ださい。
新しく割り当てられたメモリの内容は未定義です。 これは、使用する前に初期化する必要があります。 たとえば、すべての項 目を T 型の既定値に設定するSpan<T>.Clearメソッドを使用できます。
C# 7.3 以降、配列初期化子構文を使用して、新しく割り当てられたメモリの内容を定義できます。 これを実行するさまざまな 方法を次の例に示します。
式 stackalloc T[E] では、 T はアンマネージド型である必要があり、 E は負でない int 値に評価される必要があります。 セキュリティ
stackalloc を使用すると、共通言語ランタイム(CLR)のバッファーオーバーラン検出機能が自動的に有効になります。バッ ファー オーバーランが検出されると、悪意のあるコードが実行される可能性を最小限に抑えるために、プロセスはできる限り迅速 に終了されます。
C# 言語仕様
詳細については、C#言語仕様に関するページの「スタック割り当て」セクションと、入れ子になった stackalloc の許可に関す
る機能提案メモをご覧ください。 関連項目
C# リファレンス
C# の演算子と式 ポインターに関連する演算子 ポインター型 メモリおよびスパンに関連する型 stackalloc の注意事項
     const int MaxStackLimit = 1024;
Span<byte> buffer = inputLength <= MaxStackLimit ? stackalloc byte[inputLength] : new
byte[inputLength];
      Span<int> first = stackalloc int[3] { 1, 2, 3 };
Span<int> second = stackalloc int[] { 1, 2, 3 };
ReadOnlySpan<int> third = stackalloc[] { 1, 2, 3 };
     unsafe
 
       この記事では、C#8.0で導入された switch 式について説明します。 switch ステートメントについては、ステートメントのセ クションの switch ステートメントに関する記事を参照してください。
基本的な例
switch 式では、式のコンテキストにおいて switch と同様のセマンティクスが提供されます。switchアームで値が生成される ときの簡潔な構文が提供されます。次の例では、switch式の構造を示します。オンラインマップでの視方向を表す enum の 値が、対応する基本方位に変換されます。
       public static class SwitchExample
{
    public enum Directions
    {
        Up,
        Down,
        Right,
        Left
}
    public enum Orientation
    {
        North,
        South,
        East,
        West
}
    public static void Main()
    {
        var direction = Directions.Right;
        Console.WriteLine($"Map view direction is {direction}");
        var orientation = direction switch
        {
            Directions.Up    => Orientation.North,
            Directions.Right => Orientation.East,
            Directions.Down  => Orientation.South,
            Directions.Left  => Orientation.West,
};
        Console.WriteLine($"Cardinal orientation is {orientation}");
    }
}
 前のサンプルでは、switch 式の基本的な要素が示されています。
"範囲式":前の例では、変数 direction が範囲式として使用されています。 "switch式アーム":各switch式アームには、"パターン"、省略可能な"ケースガード"、=> トークン、"式"が含まれていま す。
"switch式の結果"は、"パターン"が"範囲式"と一致し、"ケースガード"が true と評価される(存在する場合)、最初の "switch式アーム"の式の値です。 => トークンの右側の"式"として、式ステートメントを使用することはできません。
"switch 式アーム" は、テキストの順番に評価されます。 高い "switch 式アーム" がすべての値と一致するため、低い "switch 式アーム" を選択できない場合、コンパイラではエラーが発行されます。
 switch 式 (C# リファレンス) 2021/03/06 • • Edit Online
 
 パターンとケース ガード
switch 式アームでは、多くのパターンがサポートされています。 前の例では "定数パターン" が使用されています。 "定数パター ン" では、範囲式と値が比較されます。 その値は、コンパイル時定数である必要があります。 "型パターン" では、範囲式と既 知の型が比較されます。 次の例では、シーケンスから 3 番目の要素が取得されます。 シーケンスの型に基づいて、異なるメ ソッドが使用されます。
パターンは再帰的にすることができます。パターンで型をテストし、その型が一致する場合、そのパターンは範囲式の 1 つまたは 複数のプロパティ値と一致します。 再帰パターンを使用して、前の例を拡張できます。 要素数が 3 未満の配列に対する switch 式アームを追加します。 再帰パターンを次の例に示します。
    public static T TypeExample<T>(IEnumerable<T> sequence) =>
    sequence switch
    {
        System.Array array => (T)array.GetValue(2),
        IList<T> list      => list[2],
        IEnumerable<T> seq => seq.Skip(2).First(),
};
     public static T RecursiveExample<T>(IEnumerable<T> sequence) =>
    sequence switch
    {
        System.Array { Length : 0}       => default(T),
        System.Array { Length : 1} array => (T)array.GetValue(0),
        System.Array { Length : 2} array => (T)array.GetValue(1),
};
System.Array array
IList<T> list
IEnumerable<T> seq
=> (T)array.GetValue(2),
=> list[2],
=> seq.Skip(2).First(),
 再帰パターンでは、範囲式のプロパティを調べることはできますが、任意のコードを実行することはできません。 when 句で指定 する "ケース ガード" を使用して、他のシーケンス型と同様のチェックを行うことができます。
    public static T CaseGuardExample<T>(IEnumerable<T> sequence) =>
    sequence switch
{
};
System.Array { Length : 0}
System.Array { Length : 1} array
System.Array { Length : 2} array
System.Array array
IEnumerable<T> list when !list.Any()
IEnumerable<T> list when list.Count() < 3 => list.Last(),
IList<T> list                             => list[2],
IEnumerable<T> seq                        => seq.Skip(2).First(),
=> default(T),
=> (T)array.GetValue(0),
=> (T)array.GetValue(1),
=> (T)array.GetValue(2),
=> default(T),
 最後に、_ パターンと null パターンを追加して、他のどのswitch式アームによっても処理されない引数をキャッチすることが できます。 そのようにすると、switch 式が "網羅的" になります。これは、範囲式で可能性のあるすべての値が処理されることを 意味します。 次の例では、そのような式アームを追加しています。

          前の例では、 null パターンが追加され、 IEnumerable<T> 型パターンが _ パターンに変更されています。 null パターンで は、switch 式アームとして null チェックが提供されます。 そのアームの式によって、ArgumentNullException がスローされま す。 _ パターンは、それより前にあるアームで一致していないすべての入力と一致します。 null チェックの後で指定する必要 があります。そうしないと、 null 入力と一致します。
網羅的でない switch 式
switch 式のどのパターンでも引数がキャッチされない場合、ランタイムで例外がスローされます。 .NET Core 3.0 以降のバージョ ンでは、例外は System.Runtime.CompilerServices.SwitchExpressionException です。 .NET Framework では、例外は InvalidOperationException です。
関連項目
再帰パターンに関する C# 言語仕様の提案 C# リファレンス
C# の演算子と式
パターン マッチング
   public static T ExhaustiveExample<T>(IEnumerable<T> sequence) =>
    sequence switch
    {
        System.Array { Length : 0}       => default(T),
        System.Array { Length : 1} array => (T)array.GetValue(0),
        System.Array { Length : 2} array => (T)array.GetValue(1),
};
System.Array array
IEnumerable<T> list
    when !list.Any()
IEnumerable<T> list
    when list.Count() < 3
IList<T> list
null _
=> (T)array.GetValue(2),
=> default(T),
=> list.Last(),
=> list[2],
=> throw new ArgumentNullException(nameof(sequence)),
=> sequence.Skip(2).First(),
 
              true 演算子は、オペランドが確実にtrueであることを示すブール値 true を返します。 false 演算子は、オペランドが確 実にfalseであることを示す bool 値 true を返します。 true および false 演算子が互いに補完することは保証されて いません。 つまり、 true と false 演算子の両方が同じオペランドに対して bool 値 false を返す場合があります。 ある 型でこの 2 つの演算子の 1 つを定義する場合は、もう 1 つの演算子も定義する必要があります。
    TIP
3 値ロジックをサポートする必要がある場合は、 bool? 型を使用します。たとえば、3 値ブール型をサポートするデータベースを操作する場 合などです。 C# には、 bool? オペランドを使用して 3 値ロジックをサポートする & および | 演算子があります。 詳細については、 「Boolean logical operators (ブール論理演算子)」記事の「Nullable Boolean logical operators (null 許容論理演算子)」セクションを 参照してください。
 ブール式
true 演算子が定義された型は、if、do、while、およびforステートメントと、条件演算子 ?: の制御条件式の結果の型
にすることができます。 詳細については、「C# 言語仕様」のブール型の式に関するセクションを参照してください。 ユーザー定義の条件付き論理演算子
true と false 演算子が定義された型によって、論理OR演算子または論理AND演算子| が特定の方法でオーバー ロード&される場合、条件付き論理OR演算子 || または条件付き論理AND演算子 && を、それぞれ、その型のオペラ ンドに対して評価することができます。 詳細については、「C# 言語仕様」のユーザー定義型条件論理演算子に関するセクショ ンを参照してください。
例
次の例では、true と false 演算子の両方を定義する型を示します。この型により、論理AND演算子 & もオーバーロー ドされ、演算子 && もその型のオペランドで評価できるようになります。
true 演算子と false 演算子 (C# リファレンス) 2020/11/02 • • Edit Online
 
      && 演算子のショートサーキット動作に注意してください。 メソッドから LaunchStatus.Red が返される と、&& 演算子の右側のオペランドは評価されません。これは、 が確実にfalseであるためです。したがっ て、論理 AND の結果は右側のオペランドの値に依存しません。 この例の出力は次のとおりです。
GetFuelLaunchStatus
 LaunchStatus.Red
  using System;
public struct LaunchStatus
{
    public static readonly LaunchStatus Green = new LaunchStatus(0);
    public static readonly LaunchStatus Yellow = new LaunchStatus(1);
    public static readonly LaunchStatus Red = new LaunchStatus(2);
    private int status;
    private LaunchStatus(int status)
    {
        this.status = status;
    }
    public static bool operator true(LaunchStatus x) => x == Green || x == Yellow;
    public static bool operator false(LaunchStatus x) => x == Red;
    public static LaunchStatus operator &(LaunchStatus x, LaunchStatus y)
    {
        if (x == Red || y == Red || (x == Yellow && y == Yellow))
        {
return Red; }
        if (x == Yellow || y == Yellow)
        {
            return Yellow;
        }
        return Green;
    }
    public static bool operator ==(LaunchStatus x, LaunchStatus y) => x.status == y.status;
    public static bool operator !=(LaunchStatus x, LaunchStatus y) => !(x == y);
    public override bool Equals(object obj) => obj is LaunchStatus other && this == other;
    public override int GetHashCode() => status;
}
public class LaunchStatusTest
{
    public static void Main()
    {
        LaunchStatus okToLaunch = GetFuelLaunchStatus() && GetNavigationLaunchStatus();
        Console.WriteLine(okToLaunch ? "Ready to go!" : "Wait!");
    }
    static LaunchStatus GetFuelLaunchStatus()
    {
        Console.WriteLine("Getting fuel launch status...");
        return LaunchStatus.Red;
    }
    static LaunchStatus GetNavigationLaunchStatus()
    {
        Console.WriteLine("Getting navigation launch status...");
        return LaunchStatus.Yellow;
    }
}

    関連項目
C# リファレンス C# の演算子と式
   Getting fuel launch status...
Wait!
 
    C#9.0以降で使用可能な with 式は、指定されたプロパティと変更されたフィールドにより、レコードオペランドのコピーを生 成します。
    using System;
public class WithExpressionBasicExample
{
    public record NamedPoint(string Name, int X, int Y);
    public static void Main()
    {
        var p1 = new NamedPoint("A", 0, 0);
        Console.WriteLine($"{nameof(p1)}: {p1}");  // output: p1: NamedPoint { Name = A, X = 0, Y = 0 }
        var p2 = p1 with { Name = "B", X = 5 };
        Console.WriteLine($"{nameof(p2)}: {p2}");  // output: p2: NamedPoint { Name = B, X = 5, Y = 0 }
        var p3 = p1 with
            {
Name = "C",
Y=4 };
        Console.WriteLine($"{nameof(p3)}: {p3}");  // output: p3: NamedPoint { Name = C, X = 0, Y = 4 }
        Console.WriteLine($"{nameof(p1)}: {p1}");  // output: p1: NamedPoint { Name = A, X = 0, Y = 0 }
    }
}
 前の例で示したように、変更するメンバーとその新しい値は、オブジェクト初期化子構文を使用して指定します。 with 式で は、左側のオペランドがレコード型である必要があります。
次の例に示すように、 with 式の結果は、式のオペランドと同じランタイム型になります。
    using System;
public class InheritanceExample
{
    public record Point(int X, int Y);
    public record NamedPoint(string Name, int X, int Y) : Point(X, Y);
    public static void Main()
    {
} }
Point p1 = new NamedPoint("A", 0, 0);
Point p2 = p1 with { X = 5, Y = 3 };
Console.WriteLine(p2 is NamedPoint);  // output: True
Console.WriteLine(p2);  // output: NamedPoint { X = 5, Y = 3, Name = A }
 参照型のメンバーの場合、レコードがコピーされるときにインスタンスへの参照のみがコピーされます。 コピーと元のレコードの両方 が、同じ参照型のインスタンスにアクセスできます。 次の例は、その動作を示します。
with 式 (C# リファレンス) 2021/03/06 • • Edit Online
 
  すべてのレコード型には、"コピー コンストラクター" があります。 これは、含んでいるレコード型の 1 つのパラメーターを持つコンス トラクターです。その引数の状態が新しいレコードインスタンスにコピーされます。 with 式の評価では、コピーコンストラクター が呼び出され、元のレコードに基づいて新しいレコード インスタンスがインスタンス化されます。 その後、新しいインスタンスは、指 定された変更に従って更新されます。 既定では、コピー コンストラクターは暗黙的、つまり、コンパイラによって生成されます。 レ コード コピーのセマンティクスをカスタマイズする必要がある場合は、必要な動作が含まれるコピー コンストラクターを明示的に宣 言します。 次の例では、明示的なコピー コンストラクターを使用して前の例が更新されます。 新しいコピー動作では、レコード がコピーされるときにリスト参照ではなくリスト項目がコピーされます。
    using System;
using System.Collections.Generic;
public class UserDefinedCopyConstructorExample
{
    public record TaggedNumber(int Number, List<string> Tags)
    {
        protected TaggedNumber(TaggedNumber original)
        {
            Number = original.Number;
            Tags = new List<string>(original.Tags);
        }
        public string PrintTags() => string.Join(", ", Tags);
    }
    public static void Main()
    {
} }
var original = new TaggedNumber(1, new List<string> { "A", "B" });
var copy = original with { Number = 2 };
Console.WriteLine($"Tags of {nameof(copy)}: {copy.PrintTags()}");
// output: Tags of copy: A, B
original.Tags.Add("C");
Console.WriteLine($"Tags of {nameof(copy)}: {copy.PrintTags()}");
// output: Tags of copy: A, B
    using System;
using System.Collections.Generic;
public class ExampleWithReferenceType
{
    public record TaggedNumber(int Number, List<string> Tags)
    {
        public string PrintTags() => string.Join(", ", Tags);
    }
    public static void Main()
    {
} }
var original = new TaggedNumber(1, new List<string> { "A", "B" });
var copy = original with { Number = 2 };
Console.WriteLine($"Tags of {nameof(copy)}: {copy.PrintTags()}");
// output: Tags of copy: A, B
original.Tags.Add("C");
Console.WriteLine($"Tags of {nameof(copy)}: {copy.PrintTags()}");
// output: Tags of copy: A, B, C
 
      C# 言語仕様 詳細については、レコード機能提案メモの次のセクションを参照してください。
with 式
コピー メンバーとクローン メンバー
関連項目
C# リファレンス C# の演算子と式

     ユーザー定義型は定義済みの C# 演算子をオーバーロードできます。 つまり、1 つまたは両方のオペランドに該当する型では、 演算のカスタム実装を提供できます。 オーバーロード可能な C# 演算子は、「オーバーロード可能な演算子」のセクションで示 します。
演算子の宣言には operator キーワードを使用します。演算子の宣言では、次の規則を満たす必要があります。 これには、 public と static 修飾子の両方が含まれています。
単項演算子には、1 つの入力パラメーターがあります。 2 項演算子には、2 つの入力パラメーターがあります。 どちらの場合 も、少なくとも 1 つのパラメーターの型が T または T? でなければなりません。 T は演算子の宣言が含まれる型です。
次の例は、有理数を表す簡略化された構造を定義しています。 構造体がいくつかの算術演算子をオーバーロードします。
   演算子のオーバーロード (C# リファレンス) 2021/03/06 • • Edit Online
 
       int から Fraction への暗黙的な変換を定義することで、前の例を拡張できます。その場合、オーバーロードされた演算子 はこれら 2 つの型の引数をサポートします。 つまり、整数を分数に足し、結果として分数を取得できるようになります。
また、 operator キーワードを使用してカスタムの型変換を定義することもできます。 詳細については、「ユーザー定義の変換 演算子」 に関するページを参照してください。
オーバーロード可能な演算子
次の表は、C# 演算子のオーバーロード可/不可に関する情報を示します。
   using System;
public readonly struct Fraction
{
    private readonly int num;
    private readonly int den;
    public Fraction(int numerator, int denominator)
    {
        if (denominator == 0)
        {
            throw new ArgumentException("Denominator cannot be zero.", nameof(denominator));
        }
        num = numerator;
        den = denominator;
    }
    public static Fraction operator +(Fraction a) => a;
    public static Fraction operator -(Fraction a) => new Fraction(-a.num, a.den);
    public static Fraction operator +(Fraction a, Fraction b)
        => new Fraction(a.num * b.den + b.num * a.den, a.den * b.den);
    public static Fraction operator -(Fraction a, Fraction b)
        => a + (-b);
    public static Fraction operator *(Fraction a, Fraction b)
        => new Fraction(a.num * b.num, a.den * b.den);
    public static Fraction operator /(Fraction a, Fraction b)
    {
        if (b.num == 0)
        {
            throw new DivideByZeroException();
        }
        return new Fraction(a.num * b.den, a.den * b.num);
    }
    public override string ToString() => $"{num} / {den}";
}
public static class OperatorOverloading
{
    public static void Main()
    {
} }
var a = new Fraction(5, 4);
var b = new Fraction(1, 2);
Console.WriteLine(-a);   // output: -5 / 4
Console.WriteLine(a + b);  // output: 14 / 8
Console.WriteLine(a - b);  // output: 6 / 8
Console.WriteLine(a * b);  // output: 5 / 8
Console.WriteLine(a / b);  // output: 10 / 4

                +x、-x、!x、~x、++、--、true、false これらの単項演算子はオーバーロードできます。
/
       x+y、x-y、x*y、x/y、x%y、x&y、x|y、x^y、x<<y,x >>y、x==y、x!=y、x<y,x>y、x<=y,x>=y
   これらの 2 項演算子はオーバーロードできます。 特定の演算子はペ アでオーバーロードする必要があります。詳細については、この表の後 にある注を参照してください。
   x&&y、x||y
  条件付き論理演算子は、オーバーロードできません。 ただし、オー バーロードされた true および false 演算子を含む型が特定の 方法で & または | もオーバーロードしている場合は、その型のオ ペランドに対してそれぞれ && または || 演算子の評価が可能に なります。 詳細については、「C# 言語仕様」のユーザー定義型条件 論理演算子に関するセクションを参照してください。
 a[i], a?[i] 要素へのアクセスはオーバーロード可能な演算子とは見なされていま せんが、インデクサーを定義することができます。
   (T)x
   キャスト演算子をオーバーロードすることはできませんが、キャスト式で 実行できるカスタム型変換を定義することはできます。 詳細について は、「ユーザー定義の変換演算子」 に関するページを参照してくださ い。
   +=、-=、*=、/=、%=、&=、|=、^=、<<=, >>=
 複合代入演算子を明示的にオーバーロードすることはできません。 た だし、二項演算子をオーバーロードするとき、対応する複合代入演 算子がある場合は、それも暗黙的にオーバーロードされます。 たとえ ば、 += は、オーバーロード可能な + を使用して評価されます。
    ^x、x = y、x.y、 x?.y 、c ? t : f、x ?? y、x ??= y、x..y、x- >y、=>、f(x)、as、await、checked、unchecked、default、delega te、is、nameof、new、sizeof、stackalloc、switch、typeof、with
  これらの演算子はオーバーロードできません。
     NOTE
比較演算子は、ペアでオーバーロードする必要があります。 つまり、ペアのどちらかの演算子をオーバーロードする場合、もう一方の演算子も オーバーロードする必要があります。 次のようなペアがこれに該当します。
== 演算子と != 演算子 < 演算子と > 演算子 <= 演算子と >= 演算子
 C# 言語仕様
詳細については、「C# 言語仕様」の次のセクションを参照してください。
演算子のオーバーロード 演算子
関連項目
C# リファレンス
C# の演算子と式 ユーザー定義の変換演算子 設計ガイドライン - 演算子のオーバーロード 設計ガイドライン - 等値演算子

  C# のオーバーロードされた演算子が常に静的である理由

     特殊文字は、それが付加されたプログラム要素 (リテラル文字列、識別子、または属性名) を変更する、コンテキストに応じた 定義済みの文字です。 C# では、次の特殊文字がサポートされています。
@: 逐語的識別子の文字。 $: 挿入文字列の文字。
関連項目
C# リファレンス
C# プログラミング ガイド
C#の特殊文字 2020/11/02 • • Edit Online
 
       $ 特殊文字は、リテラル文字列を挿入文字列として識別します。挿入文字列は、補間式が含まれている可能性がある文 字列リテラルです。 挿入文字列が結果の文字列に解決されると、補間式を含む項目は、式の結果の文字列表現によって置 き換えられます。 この機能は、C# 6 以降で使用できます。
文字列補間では、複合文字列の書式設定機能よりも読み取りやすく便利な構文を使用して書式指定された文字列を作成 できます。 次の例では、両方の機能を使用して、同じ出力を生成します。
    string name = "Mark";
var date = DateTime.Now;
// Composite formatting:
Console.WriteLine("Hello, {0}! Today is {1}, it's {2:HH:mm} now.", name, date.DayOfWeek, date);
// String interpolation:
Console.WriteLine($"Hello, {name}! Today is {date.DayOfWeek}, it's {date:HH:mm} now.");
// Both calls produce the same output that is similar to:
// Hello, Mark! Today is Wednesday, it's 19:40 now.
 挿入文字列の構造
文字列リテラルを挿入文字列として識別するため、先頭に $ の記号を追加してください。 $ と文字列リテラルを開始する
" の間に空白を入れることはできません。 補間式を含む項目の構造は、次のとおりです。
角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。
  {<interpolationExpression>[,<alignment>][:<formatString>]}
     interpolationExpression
   書式設定される結果を生成する式です。 null の文字列表記は String.Empty です。
    alignment
  式の結果の文字列表現で、最小文字数を定義する値を持つ定数 式です。 正の場合は、文字列表現は右揃えで配置され、負の場合 は、左揃えで配置されます。 詳細については、「Alignment コンポー ネント」を参照してください。
  formatString 式の結果の型によってサポートされる書式指定文字列です。 詳細に ついては、「Format String コンポーネント」を参照してください。
次の例では、前述したオプションの書式設定コンポーネントを使用します。
  $ - 文字列補間 (C# リファレンス) 2020/05/14 • • Edit Online
 
                 特殊文字
挿入文字列で生成された文字列にかっこ "{" または "}" を含めるには、2 つのかっこ "{{" または "}}" を使用します。 詳細につ
いては、「エスケープ中かっこ ({})」を参照してください。
コロン (":") が補間式の項目で特別な意味を持つときに、補間式で条件演算子を使用するには、その式を丸かっこで囲みま
す。 次の例では、かっこを結果の文字列に含める方法、および補間式で条件演算子を使用する方法を示します。
verbatim補間文字列は、$ 文字で始まり、@ 文字が続きます。逐語的文字列の詳細については、stringと逐語的識 別子に関するトピックを参照してください。
暗黙的な変換と IFormatProvider 実装の指定方法
挿入文字列から暗黙の変換を行う方法は 3 種類あります。
1. 挿入文字列から String インスタンスへの変換。これは、適切に書式設定された文字列表現の結果で置き換えられ る、補間式の項目を含む挿入文字列分析の結果です。 この変換では CurrentCulture を使用して、式の結果の書 式を設定します。
2. 書式設定される式の結果と、挿入文字列から複合書式指定文字列を表す FormattableString インスタンスへの変 換。 これは、単一の FormattableString インスタンスから、カルチャ固有のコンテンツを持つ複数の結果文字列の作成 を可能にするものです。 そのためには、次のいずれかのメソッドを呼び出します。
CurrentCulture の結果文字列を生成する ToString() オーバーロード。 InvariantCulture の結果文字列を生成する Invariant メソッド。 特定のカルチャの結果文字列を生成する ToString(IFormatProvider) メソッド。
ToString(IFormatProvider) メソッドを使用して、カスタム書式設定をサポートする IFormatProvider インターフェイス のユーザー定義の実装を提供することもできます。 詳細については、「ICustomFormatter を使用したカスタム書式設 定」の「.NET での書式設定」のセクションを参照してください。
    string name = "Horace";
int age = 34;
Console.WriteLine($"He asked, \"Is your name {name}?\", but didn't wait for a reply :-{{");
Console.WriteLine($"{name} is {age} year{(age == 1 ? "" : "s")} old.");
// Expected output is:
// He asked, "Is your name Horace?", but didn't wait for a reply :-{
// Horace is 34 years old.
     NOTE
C# 8.0 以降では、 $ と @ のトークンを任意の順序で使用できます。 $@"..." と @$"..." はどちらも有効な verbatim 補間文字 列です。 以前のバージョンの C# では、 $ トークンは @ トークンの前に記述する必要があります。
       Console.WriteLine($"|{"Left",-7}|{"Right",7}|");
const int FieldWidthRightAligned = 20;
Console.WriteLine($"{Math.PI,FieldWidthRightAligned} - default formatting of the pi number");
Console.WriteLine($"{Math.PI,FieldWidthRightAligned:F3} - display only three decimal digits of the pi
number");
// Expected output is:
// |Left   |  Right|
//     3.14159265358979 - default formatting of the pi number
//                3.142 - display only three decimal digits of the pi number
 
                   3. 挿入文字列から IFormattable インスタンスへの変換。これは、単一の IFormattable インスタンスから、カルチャ固有 のコンテンツを持つ複数の結果文字列の作成も可能にするものです。
次の例では、カルチャ固有の結果の文字列を作成するために、FormattableString への暗黙の変換を使用します。
    double speedOfLight = 299792.458;
FormattableString message = $"The speed of light is {speedOfLight:N3} km/s.";
System.Globalization.CultureInfo.CurrentCulture = System.Globalization.CultureInfo.GetCultureInfo("nl-NL"); string messageInCurrentCulture = message.ToString();
var specificCulture = System.Globalization.CultureInfo.GetCultureInfo("en-IN");
string messageInSpecificCulture = message.ToString(specificCulture);
string messageInInvariantCulture = FormattableString.Invariant(message);
Console.WriteLine($"{System.Globalization.CultureInfo.CurrentCulture,-10} {messageInCurrentCulture}"); Console.WriteLine($"{specificCulture,-10} {messageInSpecificCulture}"); Console.WriteLine($"{"Invariant",-10} {messageInInvariantCulture}");
// Expected output is:
// nl-NL      The speed of light is 299.792,458 km/s.
// en-IN      The speed of light is 2,99,792.458 km/s.
// Invariant  The speed of light is 299,792.458 km/s.
 その他の技術情報
文字列補間を初めてお使いの場合は、C# の文字列補完に関する対話形式チュートリアルを参照してください。 また、補間さ れた文字列を使用して書式設定された文字列を生成する方法を示したもう 1 つのチュートリアル「C# における文字列補間」 を確認することもできます。
補完文字列のコンパイル
補完文字列が string 型の場合、通常はString.Formatメソッドの呼び出しに変換されます。分析後の動作が連結と等
しくなるようであれば、コンパイラでは、String.Format を String.Concat に置換する場合があります。
補間文字列の型が IFormattable または FormattableString の場合、コンパイラは FormattableStringFactory.Create メ
ソッドの呼び出しを生成します。 C# 言語仕様
詳しくは、C# 言語仕様に関するページの補完文字列のセクションを参照してください。 関連項目
C# リファレンス
C# 特殊文字
文字列 標準の数値書式指定文字列 複合書式指定 String.Format
 
     特殊文字 @ は、逐語的識別子として機能します。これは次の目的に使用できます。
1.C#のキーワードを識別子として使用できるようにする。コード要素のプレフィックスとして @ 文字を使用すると、その要 素はC# のキーワードではなく、識別子としてコンパイラに解釈されます。 次の例では、 @ 文字を使用して、 for ルー プで使用する for という識別子を定義しています。
    string[] @for = { "John", "James", "Joan", "Jamie" };
for (int ctr = 0; ctr < @for.Length; ctr++)
{
   Console.WriteLine($"Here is your gift, {@for[ctr]}!");
}
// The example displays the following output:
//     Here is your gift, John!
//     Here is your gift, James!
//     Here is your gift, Joan!
//     Here is your gift, Jamie!
 2. 文字列リテラルを逐語的に解釈することを示す。 このインスタンス内の @ 文字は、逐語的文字列リテラルを定義しま す。単純なエスケープシーケンス(バックスラッシュの "\\" など)、16進数のエスケープシーケンス(大文字Aの
"\x0041" など)、Unicodeのエスケープシーケンス(大文字Aの "\u0041" など)は、リテラルに解釈されます。引 用符のエスケープ シーケンス ( "" ) だけは、リテラルに解釈されません。1 個の二重引用符が生成されます。 また、逐 語的な補間文字列の場合、中かっこエスケープシーケンス({{ と }})は文字どおり解釈されません。単一の中かっ こ文字が生成されます。 次の例では、2 つの同じファイル パスを定義しています。一方は通常の文字列リテラルを使用 して、もう一方は 逐語的文字列リテラルを使用して定義しています。 これは、逐語的文字列リテラルの一般的な用途 の 1 つです。
      string filename1 = @"c:\documents\files\u0066.txt";
string filename2 = "c:\\documents\\files\\u0066.txt";
Console.WriteLine(filename1);
Console.WriteLine(filename2);
// The example displays the following output:
//     c:\documents\files\u0066.txt
//     c:\documents\files\u0066.txt
 次の例は、同じ文字シーケンスを通常の文字列リテラルと 逐語的文字列リテラルで定義した場合の結果を示したもの です。
    string s1 = "He said, \"This is the last \u0063hance\x0021\"";
string s2 = @"He said, ""This is the last \u0063hance\x0021""";
Console.WriteLine(s1);
Console.WriteLine(s2);
// The example displays the following output:
//     He said, "This is the last chance!"
//     He said, "This is the last \u0063hance\x0021"
 3. 名前の競合がある場合に、コンパイラが属性を区別できるようにする。 属性は Attribute の派生クラスです。 通常、そ の型の名前には Attribute サフィックスが含まれます。これは、コンパイラがその規則を強制していない場合でも同様で す。 そのため属性は、完全な型名 (たとえば、   ) か、短縮名 (たとえば、   ) によってコード内
@ (C# リファレンス) 2020/11/02 • • Edit Online
  [InfoAttribute]
  [Info]
 
     から参照できます。 ただし、短縮された 2 つの属性型名が同じである場合、一方の型名に Attribute サフィックスが 含まれていて、もう一方に含まれていないと、名前の競合が発生します。 たとえば、次のコードでは、 Info と
InfoAttribute のどちらの属性が Example クラスに適用されるかをコンパイラが判断できないため、コンパイルが失敗 します。 詳細については、CS1614 を参照してください。
      using System;
[AttributeUsage(AttributeTargets.Class)]
public class Info : Attribute
{
   private string information;
   public Info(string info)
   {
      information = info;
   }
}
[AttributeUsage(AttributeTargets.Method)]
public class InfoAttribute : Attribute
{
   private string information;
   public InfoAttribute(string info)
   {
      information = info;
   }
}
[Info("A simple executable.")] // Generates compiler error CS1614. Ambiguous Info and InfoAttribute.
// Prepend '@' to select 'Info'. Specify the full name 'InfoAttribute' to select it.
public class Example
{
   [InfoAttribute("The entry point.")]
   public static void Main()
   {
   }
}
 関連項目
C# リファレンス
C# プログラミング ガイド C# 特殊文字

           ほとんどの属性は、クラスやメソッドなど、特定の言語要素に適用されます。ただし、属性の中にはグローバルなものがあり、ア センブリまたはモジュール全体に適用されます。 たとえば、AssemblyVersionAttribute 属性は、次のように、バージョン情報を アセンブリに埋め込むときに使用できます。
ソースコードでは、グローバル属性は、トップレベルの using ディレクティブより後、型、モジュール、または名前空間の宣言より 前に指定します。 グローバル属性は複数のソース ファイルに指定できますが、それらのファイルは、1 つのコンパイル パスでコンパ イルする必要があります。 Visual Studio によって、.NET Framework プロジェクトの AssemblyInfo.cs ファイルにグローバル属 性が追加されます。 これらの属性は、.NET Core プロジェクトには追加されません。
アセンブリの属性は、アセンブリに関する情報を提供する値です。 これらは次のカテゴリに分けられます。
アセンブリ ID 属性 情報属性
アセンブリ マニフェスト属性
アセンブリ ID 属性
アセンブリの ID は、名前、バージョン、カルチャの 3 つの属性によって識別されます (適用できる場合は厳密な名前も使用され ます)。 アセンブリの完全な名前を形成するこれらの属性は、コード内でアセンブリを参照するときに必要になります。 アセンブリ のバージョンとカルチャは、属性を使用して設定できます。 ただし、名前の値は、コンパイラ、[アセンブリ情報] ダイアログ ボック スの Visual Studio IDE、またはアセンブリ リンカー (Al.exe) (アセンブリの作成時) によって設定されます。 アセンブリ名は、アセ ンブリ マニフェストに基づいています。 AssemblyFlagsAttribute 属性は、アセンブリの複数のコピーが共存できるかどうかを指 定します。
次の表に ID 属性を示します。
AssemblyVersionAttribute アセンブリのバージョンを指定します。 AssemblyCultureAttribute アセンブリがサポートするカルチャを指定します。
情報属性
情報属性は、追加の会社情報または製品情報をアセンブリに指定する場合に使用します。 次の表は、System.Reflection 名前空間で定義されている情報属性を示しています。
  [assembly: AssemblyVersion("1.0.0.0")]
             AssemblyFlagsAttribute
  同じコンピューター、同じプロセス、または同じアプリケーション ドメイン での side-by-side 実行をアセンブリがサポートするかどうかを指定し ます。
     AssemblyProductAttribute アセンブリ マニフェストの製品名を指定します。
  予約済みの属性:アセンブリ レベルの属性 2020/04/23 • • Edit Online
 
                AssemblyTrademarkAttribute AssemblyInformationalVersionAttribute AssemblyCompanyAttribute AssemblyCopyrightAttribute
AssemblyFileVersionAttribute
CLSCompliantAttribute
アセンブリ マニフェスト属性
アセンブリ マニフェストの商標を指定します。
アセンブリ マニフェストの情報バージョンを指定します。
アセンブリ マニフェストの会社名を指定します。
アセンブリ マニフェストの著作権を指定するカスタム属性を定義しま す。
Win32 ファイル バージョン リソースの特定のバージョン番号を設定し ます。
アセンブリが共通言語仕様 (CLS) に準拠しているかどうかを示しま す。
                      アセンブリ マニフェスト属性を使用すると、アセンブリ マニフェストの情報を指定できます。 属性には、タイトル、説明、既定のエ イリアス、および構成が含まれます。 次の表は、System.Reflection 名前空間で定義されているアセンブリ マニフェスト属性を 示しています。
    AssemblyTitleAttribute AssemblyDescriptionAttribute AssemblyConfigurationAttribute
AssemblyDefaultAliasAttribute
アセンブリ マニフェストのアセンブリ タイトルを指定します。 アセンブリ マニフェストのアセンブリの説明を指定します。
アセンブリ マニフェストのアセンブリ構成 (小売、デバッグなど) を指定し ます。
アセンブリ マニフェストのわかりやすい既定の別名を定義します。
              
    これらの属性は、コード内の要素に適用できます。 それによって、このような要素にセマンティックの意味が追加されます。 コンパ イラでは、これらのセマンティックの意味を使用して出力が変更され、コードを使用する開発者による間違いの可能性が報告さ れます。
Conditional 属性
Conditional 属性を使用すると、プリプロセス識別子に依存したメソッドの実行を指定できます。 Conditional 属性は
ConditionalAttribute の別名であり、メソッドまたは属性クラスに適用できます。
次の例では、 Conditional は、プログラム固有の診断情報の表示を有効または無効にするメソッドに適用されています。
        #define TRACE_ON
using System;
using System.Diagnostics;
namespace AttributeExamples
{
    public class Trace
    {
        [Conditional("TRACE_ON")]
        public static void Msg(string msg)
        {
            Console.WriteLine(msg);
        }
}
    public class TraceExample
    {
} }
public static void Main()
{
    Trace.Msg("Now in Main...");
    Console.WriteLine("Done.");
}
  TRACE_ON 識別子が定義されていない場合、トレース出力は表示されません。対話型ウィンドウで自分で探してください。 多くの場合、Conditional 属性は、リリースビルドではなく、デバッグビルドのトレース機能とログ機能を有効にするために
DEBUG 識別子と共に使用されます。次に例を示します。
条件付きの印が付いたメソッドが呼び出されると、指定のプリプロセッサ シンボルの有無に従って、呼び出しの実行か省略が決 定されます。 シンボルが定義されている場合は呼び出しが実行され、定義されていない場合は省略されます。 条件付きメソッ ドは、クラスまたは構造体宣言のメソッドである必要があり、戻り値の型が void である必要があります。 Conditional を使 用すると、   ブロック内にメソッドを含めるよりも、クリーンで洗練されており、エラーが発生しにくくなります。
     [Conditional("DEBUG")]
static void DebugMethod()
{
}
  予約済みの属性:ConditionalAttribute、
ObsoleteAttribute、 AttributeUsageAttribute 2021/03/06 • • Edit Online
  #if...#endif
 
  メソッドに複数の   属性が付いている場合、そのメソッドの呼び出しは、1 つ以上の条件付きシンボルが定義され ているときに実行されます(シンボルはOR演算子によって論理的にリンクされています)。次の例では、A または B が存在 すると、メソッドが呼び出されます。
属性クラスでの Conditional の使用
Conditional 属性は、属性クラスの定義にも適用できます。 次の例では、カスタム属性 Documentation は、 DEBUG が定
義されている場合にのみ、情報をメタデータに追加します。
    [Conditional("A"), Conditional("B")]
static void DoIfAorB()
{
// ... }
        [Conditional("DEBUG")]
public class DocumentationAttribute : System.Attribute
{
string text;
    public DocumentationAttribute(string text)
    {
        this.text = text;
    }
}
class SampleClass
{
    // This attribute will only be included if DEBUG is defined.
    [Documentation("This method displays an integer.")]
    static void DoWork(int i)
    {
        System.Console.WriteLine(i.ToString());
    }
}
  Obsolete 属性
Obsolete 属性は、コード要素の使用が推奨されなくなったことを示します。非推奨とマークされたエンティティを使用すると、 警告またはエラーが生成されます。 Obsolete 属性は、1回だけ使用できる属性であり、属性を使用できる任意のエンティティ に適用できます。 Obsolete はObsoleteAttributeの別名です。
次の例では、 Obsolete 属性がクラス A およびメソッド B.OldMethod に適用されています。 B.OldMethod に適用された属 性コンストラクターの2番目の引数が true に設定されているため、このメソッドではコンパイルエラーが発生します。一方、ク ラス A が使用されると、警告が生成されます。 しかし、 B.NewMethod の呼び出しでは、警告もエラーも生成されません。 たと えば、前の定義でこれを使用すると、次のコードで 2 つの警告と 1 つのエラーが生成されます。
        Conditional
 
   最初の引数として属性コンストラクターに指定された文字列は、警告またはエラーの一部として表示されます。クラス A の警 告が2つ生成されます。1つはクラス参照の宣言の警告で、もう1つはクラスコンストラクターの警告です。 Obsolete 属性は 引数なしで使用できますが、代わりに何を使用するかの説明を含めることをお勧めします。
AttributeUsage 属性
AttributeUsage 属性によって、カスタム属性クラスの使用方法が決まります。AttributeUsageAttributeは、カスタム属性
定義に適用する属性です。 AttributeUsage 属性を使用すると、以下を制御できます。
適用できるプログラム要素属性。 使用法を制限しない限り、属性は以下のプログラム要素のいずれかに適用できます。 アセンブリ
name
フィールド
event
メソッド
param property return 型
1 つのプログラム要素に属性を複数回適用できるかどうか。 属性が派生クラスに継承されるかどうか。
    明示的に適用すると、既定の設定は次の例のようになります。
   using System;
namespace AttributeExamples
{
    [Obsolete("use class B")]
    public class A
    {
        public void Method() { }
    }
    public class B
    {
        [Obsolete("use NewMethod", true)]
        public void OldMethod() { }
        public void NewMethod() { }
    }
    public static class ObsoleteProgram
    {
} }
public static void Main()
{
    // Generates 2 warnings:
    A a = new A();
    // Generate no errors or warnings:
    B b = new B();
    b.NewMethod();
    // Generates an error, compilation fails.
    // b.OldMethod();
}
 
         この例で NewAttribute クラスはサポートされている任意のプログラム要素に適用できます。ただし、各エンティティに適用でき るのは 1 回のみです。 基底クラスに適用すると、属性は派生クラスに継承されます。
AllowMultiple 引数と Inherited 引数は省略できるので、次のコードは同じ効果を持ちます。
最初の AttributeUsageAttribute 引数は、AttributeTargets 列挙型の 1 つまたは複数の要素でなければなりません。 次の 例のように、複数のターゲット型を OR 演算子で 1 つにまとめることができます。
C#7.3以降、プロパティ、または自動実装バッキングフィールドに属性を適用できるようになりました。属性に field 指定子 を指定しない限り、属性はプロパティに適用されます。 その両方の例を次に示します。
    [AttributeUsage(AttributeTargets.All)]
class NewAttribute : Attribute { }
     [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
class NewPropertyOrFieldAttribute : Attribute { }
     class MyClass
{
    // Attribute attached to property:
    [NewPropertyOrField]
    public string Name { get; set; }
    // Attribute attached to backing field:
    [field:NewPropertyOrField]
    public string Description { get; set; }
}
 AllowMultiple引数が true の場合、次の例のように、結果の属性を1つのエンティティに複数回適用できます。
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
class MultiUse : Attribute { }
[MultiUse]
[MultiUse]
class Class1 { }
[MultiUse, MultiUse]
class Class2 { }
   この例では、 AllowMultiple が true に設定されているので、 MultiUseAttribute を繰り返し適用できます。 示されている どちらの形式でも、複数の属性を適用できます。
Inheritedが false の場合、属性は属性クラスから派生したクラスに継承されません。次に例を示します。
   [AttributeUsage(AttributeTargets.All,
                   AllowMultiple = false,
                   Inherited = true)]
class NewAttribute : Attribute { }
 
       この例で、 NonInheritedAttribute は継承によって DClass に適用されません。 関連項目
Attribute System.Reflection 属性
リフレクション
   [AttributeUsage(AttributeTargets.Class, Inherited = false)]
class NonInheritedAttribute : Attribute { }
[NonInherited]
class BClass { }
class DClass : BClass { }
 
        info 属性を使用して、メソッドの呼び出し元に関する情報を取得します。 ソース コードのファイル パス、ソース コードの行番 号、呼び出し元のメンバー名を取得します。 メンバー呼び出し元情報を取得するには、省略可能なパラメーターに適用される 属性を使用します。 省略可能な各パラメーターでは既定値が指定されます。 次の表 は、System.Runtime.CompilerServices 名前空間で定義されている呼び出し元情報の属性の一覧です。
CallerLineNumberAttribute メソッドの呼び出し元であるソース ファイルの Integer 行番号。
CallerMemberNameAttribute 呼び出し元のメソッド名またはプロパティ名。 String
この情報は、トレースの作成、デバッグ、および診断ツールの作成に役立ちます。 呼び出し元情報の属性を使用する方法の 例を次に示します。 TraceMessage メソッドを呼び出すたびに、呼び出し元情報は、省略可能なパラメーターの引数として設 定されます。
   CallerFilePathAttribute
   呼び出し元を含むソース ファイルのフル パス です。 完全なパスは、コンパイル時のパスで す。
    String
                 public void DoProcessing()
{
    TraceMessage("Something happened.");
}
public void TraceMessage(string message,
        [CallerMemberName] string memberName = "",
        [CallerFilePath] string sourceFilePath = "",
        [CallerLineNumber] int sourceLineNumber = 0)
{
    Trace.WriteLine("message: " + message);
    Trace.WriteLine("member name: " + memberName);
    Trace.WriteLine("source file path: " + sourceFilePath);
    Trace.WriteLine("source line number: " + sourceLineNumber);
}
// Sample Output:
//  message: Something happened.
//  member name: DoProcessing
//  source file path: c:\Visual Studio Projects\CallerInfoCS\CallerInfoCS\Form1.cs
//  source line number: 31
 省略可能な各パラメーターには、明示的な既定値を指定します。 省略可能と指定されていないパラメーターには、呼び出し 元情報の属性を適用できません。 呼び出し元情報の属性によってパラメーターが省略可能になるわけではありません。 この属 性は、引数を省略したときに渡される既定値に影響します。 呼び出し元情報の値は、コンパイル時に中間言語 (IL) 内にリテ ラルとして出力されます。 例外の StackTrace プロパティの結果とは異なり、難読化による影響は受けません。 省略可能な引 数を明示的に指定して、呼び出し元情報を制御したり、非表示にしたりできます。
メンバー名
CallerMemberName 属性を使用して、呼び出されたメソッドにメンバー名を String 引数として指定することを回避できます。 この方法を使用すると、リファクタリングの名前の変更で   値が変更されないという問題が発生しなくなります。 この利
  予約済みの属性:呼び出し元情報を判断する 2020/04/23 • • Edit Online
  String
 
     点は、次のタスクで役立ちます。
トレース ルーチンと診断ルーチンの使用。
データ バインディング時の INotifyPropertyChanged インターフェイスの実装。 このインターフェイスを使用すると、オブジェク
トのプロパティが、プロパティが変更されたことをデータ バインド コントロールに通知できます。これによって、このコントロール は、更新された情報を表示できます。 CallerMemberName 属性がない場合は、リテラルとしてプロパティ名を指定する必要 があります。
次のグラフは、 CallerMemberName 属性の使用時に返されるメンバー名を示します。
      メソッド、プロパティ、またはイベント コンストラクター 静的コンストラクター デストラクターです。 ユーザー定義の演算子または変換
含んでいないメンバー (型に適用されているアセンブリ レベルや属性な ど)
関連項目
名前付き引数と省略可能な引数
System.Reflection Attribute
属性
呼び出しが発生したメソッド、プロパティ、またはイベントの名前。 文字列「.ctor」
文字列「.cctor」
文字列「Finalize」
生成されたメンバー名 (「op_Addition」など)。
省略可能なパラメーターの既定値。
                   Attribute コンストラクター
   属性が適用されるメソッドまたはプロパティの名前。 属性がメンバー 内の要素 (パラメーター、戻り値、ジェネリック型パラメーターなど) であ る場合、この結果は、その要素に関連付けられているメンバーの名前 になります。
   
            null 許容コンテキストの場合、コンパイラではコードの静的分析を実行して、すべての参照型変数の null 状態を判断します。 null 以外:静的分析によって、変数に null 以外の値が割り当てられていることが判断されます。
null の可能性あり:静的分析では、変数に null 以外の値が割り当てられていることを判断できません。
API のセマンティクスについての情報をコンパイラに提供する属性を適用できます。 この情報は、コンパイラで静的分析を実行 し、変数が null でないかどうかを判断するのに役立ちます。 この記事では、これらの各属性とその使用方法について簡単に説 明します。 すべての例では C# 8.0 以降を想定しており、コードは null 許容コンテキストに含まれています。
よくある例から始めましょう。 ライブラリに、リソース文字列を取得するための次の API があるとします。
前述の例では、.NETのよくある Try* パターンに従っています。このAPIには、2つの参照引数(key および message パラ メーター) があります。 この API には、これらの引数の null 性に関連する次の規則があります。
呼び出し元では、 key の引数として null を渡すことはできません。 呼び出し元では、 message の引数として、値が null の変数を渡すことができます。
メソッドから true が返された場合、 message の値は null ではありません。 戻り値が false, である場 合、 (およびその null 状態) の値は null です。
key の規則は、変数型で表すことができます。key はnull非許容参照型である必要があります。 message パラメーターは より複雑です。引数として null が許可されますが、成功した場合、out 引数がnullでないことが保証されます。これらの シナリオでは、予測を記述するために、より豊富なボキャブラリが必要です。
変数の null 状態に関する追加情報を表すために、いくつかの属性が追加されました。 C# 8 で null 許容参照型型が導入さ れる前に記述したすべてのコードでは、"null が認識されません" でした。 つまり、参照型変数は null である可能性があります が、nullチェックは必須ではありません。コードが"null許容認識"になると、それらの規則は変わります。参照型を null 値 にすることはできません。また、null許容参照型は、逆参照される前に null に対してチェックする必要があります。
APIの規則は、TryGetValue APIシナリオで見たとおり、より複雑になる可能性があります。多くのAPIには、変数を null にできる場合やできない場合のより複雑な規則があります。 このような場合は、次の属性のいずれかを使用して、これらの規 則を表します。
AllowNull:null 非許容の入力引数は null にすることができます。
DisallowNull:null 許容の入力引数を null にすることはできません。
MaybeNull:null 非許容の戻り値は null である可能性があります。
NotNull:null 許容の戻り値が null になることはありません。
MaybeNullWhen:メソッドから指定された bool 値が返された場合、null非許容の入力引数はnullである可能性があ ります。
NotNullWhen:メソッドから指定された bool 値が返された場合、null許容の入力引数はnullにはなりません。 NotNullIfNotNull:指定されたパラメーターの引数が null でない場合、戻り値は null ではありません。 DoesNotReturn:メソッドから制御が返されることはありません。 つまり、常に例外がスローされます。 DoesNotReturnIf:関連付けられた bool パラメーターに指定された値がある場合、このメソッドから制御が返されることは ありません。
  bool TryGetMessage(string key, out string message)
      TryGetMessage
 message
  予約済み属性はコンパイラの null 状態の静的分
析に寄与する
2021/03/06 • • Edit Online
 
     MemberNotNull:メソッドから戻ったときに、列挙されたメンバーは null になりません。 MemberNotNullWhen:指定された bool 値がメソッドから返された場合、列挙されたメンバーはnullになりません。
前述の説明は、各属性動作に関するクイック リファレンスです。 次の各セクションでは、動作と意味について、より詳しく説明し ます。
これらの属性を追加すると、API の規則に関する詳細情報がコンパイラに与えられます。 呼び出し元のコードが、null 許容が 有効なコンテキストでコンパイルされると、呼び出し元がこれらの規則に違反したときに、コンパイラによって警告されます。 このよ うな属性では、実装に対するその他のチェックが有効になりません。
事前条件を指定する: AllowNull と DisallowNull
適切な既定値が設定されているため、 null を返すことのない読み取りおよび書き込みプロパティについて考えてみます。 呼び 出し元では、その既定値に設定するときに、setアクセサーに null を渡します。たとえば、チャットルームで画面名を要求す るメッセージング システムがあるとします。 何も指定されていない場合、システムによってランダムな名前が生成されます。
null 許容の認識されないコンテキストで上記のコードをコンパイルする場合、何も問題はありません。 null 許容参照型を有効 にすると、 ScreenName プロパティが null 非許容参照になります。 これは get アクセサーでは正しい動作です。 null が返さ れることはありません。呼び出し元では、返されたプロパティで null をチェックする必要はありません。しかし、ここでプロパティ を null に設定すると、警告が生成されます。この種類のコードをサポートするには、次のコードに示すよう に、System.Diagnostics.CodeAnalysis.AllowNullAttribute 属性をプロパティに追加します。
これと、この記事で説明されている他の属性を使用するには、System.Diagnostics.CodeAnalysisの using ディレクティブを 追加する必要がある場合があります。 属性は、 set アクセサーではなく、プロパティに適用されます。 AllowNull 属性では "事前条件"を指定し、入力にのみ適用されます。 get アクセサーには戻り値がありますが、入力引数はありません。したがっ て、 AllowNull 属性は set アクセサーにのみ適用されます。
前の例では、引数に AllowNull 属性を追加する場合の検索方法が示されています。
1. その変数の一般的なコントラクトは、 null にできないため、null 非許容参照型が必要であるというものです。
2. 入力変数を null にするシナリオはありますが、それらは最も一般的な使用方法ではありません。 ほとんどの場合、プロパティ、または in 、 out 、および ref 引数にこの属性が必要になります。 AllowNull 属性は、通常
は変数がnull以外だが、null を事前条件として許可する必要がある場合に最適です。
DisallowNull を使用するシナリオと比較してください。この属性を使用して、null許容参照型の入力変数を null にできな いことを指定します。 null は既定値であるが、クライアントではnull以外の値にしか設定できないというプロパティについて考 えてみます。 次のコードがあるとします。
      public string ScreenName
{
   get => _screenName;
   set => _screenName = value ?? GenerateRandomScreenName();
}
private string _screenName;
      [AllowNull]
public string ScreenName
{
   get => _screenName;
   set => _screenName = value ?? GenerateRandomScreenName();
}
private string _screenName = GenerateRandomScreenName();
      
       上記のコードは、 ReviewComment が null である可能性はあるが、 null に設定できないという設計を表すのに最適な方法 です。 このコードが null 許容認識になると、System.Diagnostics.CodeAnalysis.DisallowNullAttribute を使用して、呼び 出し元に対して、この概念をより明確に表すことができます。
null 許容コンテキストでは、 ReviewComment get アクセサーから null の既定値が返される可能性があります。 コンパイラか らは、アクセスの前にチェックする必要があることが警告されます。 さらに、 null である可能性があっても、呼び出し元で明示 的に null に設定できないことが、呼び出し元に警告されます。 DisallowNull 属性では、"事前条件"も指定され、これは
get アクセサーには影響しません。 以下について、これらの特性を監視する場合は、 DisallowNull 属性を使用します。 1. 主なシナリオでは (多くの場合、最初にインスタンス化されるときに)、変数が null である可能性があります。
2. 変数は、明示的に null に設定することはできません。
このような状況は、もともと "null として認識されていなかった" コードでよく見られます。 オブジェクト プロパティが、2 つの異なる 初期化操作で設定されている可能性があります。 一部のプロパティは、一部の非同期処理が完了した後にのみ設定される 可能性があります。
AllowNull および DisallowNull 属性を使用すると、変数の事前条件が、これらの変数のnull許容注釈と一致しない可 能性があることを指定できます。 これにより、API の特性の詳細が提供されます。 この追加情報は、呼び出し元で API を正し く使用するのに役立ちます。 次の属性を使用して、事前条件を指定することを忘れないでください。
AllowNull:null 非許容の入力引数を null にすることができます。 DisallowNull:null 許容の入力引数を null にすることはできません。
事後条件を指定する: MaybeNull と NotNull 次のシグネチャを持つメソッドがあるとします。
検索された名前が見つからなかったときに null を返す、このようなメソッドを記述した可能性があります。 null は、レコード が見つからなかったことを明確に示しています。この例では、戻り値の型を Customer から Customer? に変更する可能性が あります。 戻り値を null 許容参照型として宣言すると、この API の意図が明確になります。
「ジェネリック定義と NULL 値の許容」に記載されている理由により、その手法はジェネリック メソッドでは機能しません。 同様の パターンに従うジェネリック メソッドがある場合があります。
    [DisallowNull]
public string? ReviewComment
{
    get => _comment;
    set => _comment = value ?? throw new ArgumentNullException(nameof(value), "Cannot set to null");
}
string? _comment;
          public Customer FindCustomer(string lastName, string firstName)
     public T Find<T>(IEnumerable<T> sequence, Func<T, bool> predicate)
 戻り値が T? であることを指定することはできません。 検索された項目が見つからない場合、このメソッドからは null が返さ
   public string ReviewComment
{
    get => _comment;
    set => _comment = value ?? throw new ArgumentNullException(nameof(value), "Cannot set to null");
}
string _comment;
 
    れます。戻り値の型として T? を宣言することはできないため、メソッドの戻り値に   注釈を追加します。
    [return: MaybeNull]
public T Find<T>(IEnumerable<T> sequence, Func<T, bool> predicate)
 前のコードでは、コントラクトは null 非許容型を意味するが、戻り値は実際には null である "可能性がある" ことを呼び出し元 に通知します。APIはnull非許容型で、通常はジェネリック型パラメーターである必要はあるが、null が返されるインスタンス が存在する可能性がある場合は、 MaybeNull 属性を使用します。
型がnull許容参照型である場合でも、戻り値あるいは out または ref 引数がnullでないことを指定することもできます。 配列が、多数の要素を保持するのに十分な大きさであることを保証するメソッドについて考えてみます。 入力引数に容量がな い場合、ルーチンで新しい配列を割り当てて、そこに既存のすべての要素をコピーします。 入力引数が null である場合は、 ルーチンで新しいストレージを割り当てます。 十分な容量がある場合、ルーチンでは何も行いません。
次のように、このルーチンを呼び出すことができます。
null 参照型を有効にした後、確実に前のコードが警告なしでコンパイルされるようにする必要があります。 メソッドから制御が 戻ったときに、 引数がnullでないことが保証されます。しかし、null参照で EnsureCapacity を呼び出すことはでき ます。 をnull許容参照型にして、NotNull 事後条件をパラメーター宣言に追加することができます。
上記のコードは、既存のコントラクトを明確に表しています。呼び出し元では null 値を持つ変数を渡すことはできますが、戻 り値はnullになることはないことが保証されます。 NotNull 属性は、null が引数として渡される可能性があるが、メソッドか ら制御が戻ったときにその引数が null でないことが保証される、 ref および out 引数に最も役立ちます。
無条件の事後条件は、次の属性を使用して指定します。 MaybeNull:null 非許容の戻り値は null である可能性があります。
NotNull:null 許容の戻り値が null になることはありません。
条件付きの事後条件を指定する: NotNullWhen 、 MaybeNullWhen 、および NotNullIfNotNull
string メソッドString.IsNullOrEmpty(String)は見慣れたものかもしれません。引数がnullまたは空の文字列の場合、こ のメソッドから true が返されます。これは、nullチェックの形式です。メソッドから false が返された場合、呼び出し元で引 数の null チェックを行う必要はありません。 この null 許容認識のようなメソッドを作成するには、引数を null 許容参照型に 設定し、 NotNullWhen 属性を追加します。
これにより、戻り値が false であるコードでは、nullチェックを行う必要がないことがコンパイラに通知されます。属性を追加す ると、 IsNullOrEmpty で必要な null チェックが実行されることがコンパイラの静的分析に通知されます。 false が返された場 合、入力引数は null ではありません。
   public void EnsureCapacity<T>(ref T[] storage, int size)
     // messages has the default value (null) when EnsureCapacity is called:
EnsureCapacity<string>(ref messages, 10);
// messages is not null.
EnsureCapacity<string>(messages, 50);
   storage
  storage
  public void EnsureCapacity<T>([NotNull] ref T[]? storage, int size)
         bool IsNullOrEmpty([NotNullWhen(false)] string? value);
   MaybeNull
 
   .NET Core 3.0 の場合、上記のように String.IsNullOrEmpty(String) メソッドに注釈が付けられます。 コードベースには、オブ ジェクトの状態で null 値をチェックする、同様のメソッドが存在する場合があります。 コンパイラではカスタムの null チェック メソッ ドが認識されないため、注釈を自分で追加する必要があります。 属性を追加すると、コンパイラの静的分析で、テストされた変 数が null チェックされたかどうが認識されます。
これらの属性のもう 1 つの用途は、 Try* パターンです。 ref および out 変数の事後条件は、戻り値を通じて伝達されま す。 前述のこのメソッドについて考えてみます。
上記のメソッドは、一般的な.NET表現形式に従います。戻り値は、message が見つかった値に設定されているかどうか、ま たはメッセージが見つからない場合は、既定値に設定されているかどうかを示します。メソッドから true が返された場合、
message の値はnullではありません。それ以外の場合、メソッドでは message がnullに設定されます。 属性を使用して、その表現方法を伝達することができます。 null 許容参照型のシグネチャを更新する場合
は、 を string? にして、属性を追加します。
前述の例では、 TryGetMessage から true が返された場合、 message の値は null ではないと認識されます。 同じように、 コードベースで同様のメソッドに注釈を付ける必要があります。引数は null である可能性があり、メソッドから true が返さ れた場合は null ではないと認識されます。
最後にもう 1 つ属性があります。これも必要になる可能性があります。 戻り値の null 状態は、1 つまたは複数の入力引数の null状態に依存する場合があります。特定の入力引数が null でない場合は常に、これらのメソッドからnull以外の値が 返されます。 これらのメソッドに正しく注釈を付けるには、 NotNullIfNotNull 属性を使用します。 次のメソッドがあるとします。
url 引数がnullでない場合、出力は null ではありません。null許容参照を有効にすると、APIでnull入力が受け入れ られることがない場合、そのシグネチャは正常に機能します。 しかし、入力が null である可能性がある場合は、戻り値も null である可能性があります。 シグネチャを次のコードに変更できます。
これも機能しますが、多くの場合、呼び出し元での追加の null チェックの実装が強制されます。コントラクトは、入力引数 url が null である場合にのみ、戻り値が null になるというものです。 このコントラクトを表すには、次のコードに示すよう
に、このメソッドに注釈を付けます。
戻り値と引数の両方に、 ? で注釈が付けられています。これは、どちらも null である可能性があることを示しています。 url 引数が null でない場合、属性によって、戻り値がnullにならないことがさらに明確になります。
  bool TryGetMessage(string key, out string message)
     NotNullWhen
  message
  bool TryGetMessage(string key, [NotNullWhen(true)] out string? message)
      string GetTopLevelDomainFromFullUrl(string url);
   string? GetTopLevelDomainFromFullUrl(string? url);
     [return: NotNullIfNotNull("url")]
string? GetTopLevelDomainFromFullUrl(string? url);
    string? userInput = GetUserInput();
if (!string.IsNullOrEmpty(userInput))
{
   int messageLength = userInput.Length; // no null check needed.
}
// null check needed on userInput here.
 
      条件付きの事後条件は、これらの属性を使用して指定します。
MaybeNullWhen:メソッドから指定された bool 値が返された場合、null非許容の入力引数はnullである可能性があ ります。
NotNullWhen:メソッドから指定された bool 値が返された場合、null許容の入力引数はnullにはなりません。 NotNullIfNotNull:指定されたパラメーターの入力引数が null でない場合、戻り値は null ではありません。
コンストラクターのヘルパー メソッド: MemberNotNull と MemberNotNullWhen
これらの属性は、コンストラクターからヘルパー メソッドに共通コードをリファクタリングする際の目的を指定するために使用しま す。 C# コンパイラによって、コンストラクターとフィールド初期化子が分析され、各コンストラクターから戻る前に、すべての null 非許容参照フィールドが初期化されていることが確認されます。 ただし、C# コンパイラによって、すべてのヘルパー メソッドを介 したフィールドの割り当てが追跡されるわけではありません。 コンストラクターで直接ではなく、ヘルパー メソッドでフィールドが初 期化されると、コンパイラから警告 CS8618 が発行されます。メソッドの宣言にMemberNotNullAttributeを追加し、メソッド 内で null 以外の値に初期化されるフィールドを指定します。 たとえば、次の例を考えてみましょう。
       public class Container
{
    private string _uniqueIdentifier; // must be initialized.
    private string? _optionalMessage;
    public Container()
    {
Helper(); }
    public Container(string message)
    {
Helper();
        _optionalMessage = message;
    }
    [MemberNotNull(nameof(_uniqueIdentifier))]
    private void Helper()
    {
        _uniqueIdentifier = DateTime.Now.Ticks.ToString();
    }
}
  MemberNotNull 属性コンストラクターへの引数として複数のフィールド名を指定できます。 MemberNotNullWhenAttributeには bool 引数があります。ヘルパーメソッドによってフィールドが初期化されたかどうかを
示す bool がヘルパー メソッドから返される状況では、 MemberNotNullWhen を使用します。 到達できないコードを検証する
一部のメソッド (通常は例外ヘルパーまたはその他のユーティリティ メソッド) は、常に例外をスローすることによって終了します。 あるいは、ヘルパーでは、ブール型引数の値に基づいて、例外がスローされる場合があります。
最初のケースでは、メソッド宣言に DoesNotReturn 属性を追加できます。コンパイラは、3つの方法で役立ちます。1つ目で は、例外をスローせずにメソッドを終了できるパスがある場合、コンパイラから警告が出されます。 2 つ目では、コンパイラによっ て、適切な catch 句が検出されるまで、そのメソッドの呼び出しの後にコードが"到達できない"ものとしてマークされます。3 つ目では、到達できないコードが null 状態に影響することはありません。 たとえば、次のメソッドがあったとします。
  
         2つ目のケースでは、メソッドのブール型パラメーターに DoesNotReturnIf 属性を追加します。前の例は次のように変更できま す。
    private void FailFast([DoesNotReturnIf(false)] bool isValid)
{
    if (!isValid)
    {
        throw new InvalidOperationException();
    }
}
public void SetState(object containedField)
{
    FailFast(isInitialized);
    // unreachable code when "isInitialized" is false:
    _field = containedField;
}
 まとめ
null許容参照型を追加すると、null である可能性のある変数に関するAPIの予測を記述するための、最初のボキャブラリ が提供されます。 属性には、変数の null 状態を事前条件および事後条件として記述するために、より豊富なボキャブラリが 用意されています。 これらの属性では、予測をより明確に記述し、API を使用して開発者により優れたエクスペリエンスを提供 します。
null 許容コンテキストのライブラリを更新する際には、API のユーザーに正しい使用方法を示すために、これらの属性を追加し ます。 これらの属性は、入力引数と戻り値の null 状態を完全に記述するのに役立ちます。
AllowNull:null 非許容の入力引数を null にすることができます。
DisallowNull:null 許容の入力引数を null にすることはできません。
MaybeNull:null 非許容の戻り値は null である可能性があります。
NotNull:null 許容の戻り値が null になることはありません。
MaybeNullWhen:メソッドから指定された bool 値が返された場合、null非許容の入力引数はnullである可能性があ
    IMPORTANT
C# の最新バージョンについては、公式のドキュメントで追跡しています。 現在は、C# 9.0 について記述しています。 使用している C# の バージョンによっては、さまざまな機能を使用できない場合があります。 お使いのプロジェクトの C# の "既定" のバージョンは、ターゲット フ レームワークに基づいています。 詳細については、C# 言語のバージョン管理の既定に関する記事を参照してください。
    [DoesNotReturn]
private void FailFast()
{
    throw new InvalidOperationException();
}
public void SetState(object containedField)
{
    if (!isInitialized)
    {
        FailFast();
    }
    // unreachable code:
    _field = containedField;
}
 
     ります。
NotNullWhen:メソッドから指定された bool 値が返された場合、null許容の入力引数はnullにはなりません。 NotNullIfNotNull:指定されたパラメーターの入力引数が null でない場合、戻り値は null ではありません。 DoesNotReturn:メソッドから制御が返されることはありません。 つまり、常に例外がスローされます。
DoesNotReturnIf:関連付けられた bool パラメーターに指定された値がある場合、このメソッドから制御が返されることは ありません。

             このセクションでは、次の C# プリプロセッサ ディレクティブについて説明します。
#if
#else
#elif
#endif
#define
#undef
#warning
#error
#line
#nullable
#region #endregion #pragma
#pragma warning #pragma checksum
詳細および例については、個々のトピックを参照してください。
コンパイラに個別のプリプロセッサはありませんが、このセクションに示すディレクティブは、ある場合と同じように処理されます。 こ れらは条件付きコンパイルに役立ちます。 C や C++ のディレクティブとは異なり、マクロを作成するのにこれらのディレクティブを 使用することはできません。
プリプロセッサ ディレクティブは、行の唯一の命令である必要があります。 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ 2021/03/06 • • Edit Online
 
      C#コンパイラでは、#if ディレクティブ、次いで#endifディレクティブが検出されると、これらのディレクティブ間のコードがコンパイ ルされます (指定されたシンボルが定義されている場合に限る)。 C および C++ とは異なり、シンボルに数値を割り当てることは できません。C#の #if ステートメントはブール値で、シンボルが定義されているかどうかのみをテストします。次に例を示しま す。
演算子==(等式)および!=(不等式)は、bool値 true または false をテストするためにのみ使用できます。 true は、 シンボルが定義されていることを意味します。 ステートメント #if DEBUG と #if (DEBUG == true) の意味は同じです。 && (かつ)、|| (または)、! (not) の各演算子を使用すると、複数のシンボルが定義されているかどうかを評価できます。 シンボルと演 算子は、かっこを使用してグループ化できます。
注釈
#if と#else、#elif、#endif、#define、#undefの各ディレクティブを組み合わせると、1つ以上のシンボルが存在するかどう かに応じてコードを含めたり除外したりできます。 これは、デバッグ ビルドのコードをコンパイルする場合や、特定の構成でコンパ イルを行う場合に役立ちます。
#if ディレクティブで始まる条件付きディレクティブは、 #endif ディレクティブで明示的に終了させる必要があります。
#define を使用するとシンボルを定義できます。定義したシンボルを #if ディレクティブに渡す式として使用すると、この式は
true と評価されます。
シンボルは、-define コンパイラ オプションでも定義できます。 #undef を使うと、シンボルを未定義状態にできます。
-define または #define で定義されたシンボルは、同じ名前の変数とは競合しません。変数名をプリプロセッサディレクティ ブに渡すことはできません。シンボルはプリプロセッサ ディレクティブだけで評価されます。
#define を使用して作成したシンボルのスコープは、そのシンボルが定義されているファイルです。
ビルド システムは、SDK 型プロジェクトの各種ターゲット フレームワークを表す、定義済みプリプロセッサ シンボルも認識します。
これは、複数の .NET バージョンをターゲットとできるアプリケーションを作成する場合に役立ちます。 SYMBOLS
    #if DEBUG
    Console.WriteLine("Debug version");
#endif
           .NET Framework
      , NET48 , , , NET47 ,
, , NET46 , , , NET45 ,
NET40 , NET35 , NET20
NETFRAMEWORK
  NET462
NET461
NET472
NET471
  NET452
NET451
   .NET Standard
     NETSTANDARD
,,, ,,, ,,,
NETSTANDARD2_1
NETSTANDARD2_0
      NETSTANDARD1_6
NETSTANDARD1_5
NETSTANDARD1_4
      NETSTANDARD1_3
NETSTANDARD1_2
NETSTANDARD1_1
    NETSTANDARD1_0
  #if (C# リファレンス) 2020/11/02 • • Edit Online
 
   他の定義済みシンボルとしては、DEBUG定数とTRACE定数があります。 #define を使用して、プロジェクトに設定された値 をオーバーライドできます。 たとえば、DEBUG シンボルは、ビルド構成プロパティ ("デバッグ" モードまたは "リリース" モード) に応 じて自動的に設定されます。
例
次の例は、ファイルで MYTEST シンボルを定義し、MYTEST シンボルと DEBUG シンボルの値をテストする方法を示していま す。 この例の出力は、プロジェクトをデバッグとリリースのどちらの構成モードでビルドするかによって異なります。
SYMBOLS
    .NET 5 (および .NET Core)
     NET, , , , ,,,
,,
NET5_0
NETCOREAPP
NETCOREAPP3_1
      NETCOREAPP3_0
NETCOREAPP2_2
NETCOREAPP2_1
      NETCOREAPP2_0
NETCOREAPP1_1
NETCOREAPP1_0
        NOTE
従来の非 SDK スタイルのプロジェクトでは、プロジェクトの [プロパティ] ページを使用して、Visual Studio のさまざまなターゲット フレームワー クの条件付きコンパイル シンボルを手動で構成する必要があります。
      #define MYTEST
using System;
public class MyClass
{
    static void Main()
    {
#if (DEBUG && !MYTEST)
        Console.WriteLine("DEBUG is defined");
#elif (!DEBUG && MYTEST)
        Console.WriteLine("MYTEST is defined");
#elif (DEBUG && MYTEST)
        Console.WriteLine("DEBUG and MYTEST are defined");
#else
        Console.WriteLine("DEBUG and MYTEST are not defined");
#endif
} }
 次の例は、各種ターゲット フレームワークをテストし、可能な場合には新しい API を使用できるようにする方法を示しています。
    public class MyClass
{
    static void Main()
{
#if NET40
        WebClient _client = new WebClient();
#else
        HttpClient _client = new HttpClient();
#endif
}
//... }
 関連項目
C# リファレンス
C# プログラミング ガイド

   C# プリプロセッサ ディレクティブ
方法: トレースとデバッグを指定して条件付きコンパイルを実行する

      #else を使用すると、複合条件付きディレクティブを作成できるため、先行する#ifまたは(省略可能な)#elifディレクティブの 式がいずれも true に評価されない場合は、コンパイラが #else と以降の #endif の間のすべてのコードを評価します。
解説
#endifが、#else の後の次のプリプロセッサディレクティブになる必要があります。 #else の使用例については、「#if」を参照 してください。
関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
 #else (C# リファレンス) 2020/11/02 • • Edit Online
 
      #elif を使用すると、複合条件付きディレクティブを作成できます。 #elif 式が評価されるのは、先行するディレクティブ式 #ifおよび #elif (オプション)が true と評価されなかった場合です。 #elif 式が true と評価された場合は、#elif と 次の条件付きディレクティブの間にあるすべてのコードが、コンパイラによって評価されます。 次に例を示します。
複数のシンボルを評価するときには、 == (等値)、 != (非等値)、 && (AND)、および || (OR) の演算子を使用できます。 シンボルと演算子は、かっこを使用してグループ化できます。
注釈
#elif では、次のように記述した場合と同じ結果が得られます。
#elif を使用する方が簡単です。 #if には対になる #endif が必要ですが、 #elif では対応する #endif が不要なため です。
#elif の使用例については、「#if」を参照してください。 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
    #define VC7
//...
#if debug
    Console.WriteLine("Debug build");
#elif VC7
    Console.WriteLine("Visual Studio 7");
#endif
     #else #if
  #elif (C# リファレンス) 2020/11/02 • • Edit Online
 
       #endif は#ifディレクティブで始まる、条件付きディレクティブの終了を指定します。たとえば、次のように入力します。
解説
#if ディレクティブで始まる条件付きディレクティブは、 #endif ディレクティブで明示的に終了させる必要があります。 #endif
の使用例については、「#if」を参照してください。 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
    #define DEBUG
// ...
#if DEBUG
    Console.WriteLine("Debug version");
#endif
   #endif (C# リファレンス) 2020/11/02 • • Edit Online
 
     #define は、シンボルを定義するために使用します。次の例に示すように、定義したシンボルを式として#ifディレクティブに渡 すと、式は true と評価されます。
注釈
シンボルを使用して、コンパイル条件を指定できます。 シンボルは、#if または #elif で評価できます。 ま た、ConditionalAttribute を使用して、条件付きコンパイルを実行することもできます。
シンボルを定義することはできますが、シンボルに値は代入できません。 #define ディレクティブは、ファイル内で、プリプロセッサ ディレクティブではない他の命令よりも前に記述する必要があります。
シンボルは、-define コンパイラ オプションでも定義できます。 #undef を使うと、シンボルを未定義状態にできます。
-define または #define で定義されたシンボルは、同じ名前の変数とは競合しません。変数名をプリプロセッサディレクティ
ブに渡すことはできません。シンボルはプリプロセッサ ディレクティブだけで評価されます。 #define で定義されたシンボルのスコープは、そのシンボルが定義されたファイル内だけです。 次の例に示すように、 #define ディレクティブは、ファイルの先頭で指定する必要があります。
  #define DEBUG
     NOTE
#define ディレクティブを使用して、通常 C および C++ で行うように定数値を宣言することはできません。 C# の定数は、クラスまたは 構造体の静的メンバーとして定義することができます。 そのような定数がいくつかある場合は、それを保持するための "Constants" クラスを 個別に作成することを検討してください。
           #define DEBUG
//#define TRACE
#undef TRACE
using System;
public class TestDefine
{
    static void Main()
{
#if (DEBUG)
        Console.WriteLine("Debugging is enabled.");
#endif
#if (TRACE)
     Console.WriteLine("Tracing is enabled.");
#endif }
}
// Output:
// Debugging is enabled.
 シンボルの定義を解除する方法の例については、「#undef」を参照してください。
#define (C# リファレンス) 2020/11/02 • • Edit Online
 
     関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
const
方法: トレースとデバッグを指定して条件付きコンパイルを実行する #undef
#if

        #undef を使用すると、シンボルを未定義にすることができます。未定義のシンボルを#ifディレクティブで式として使用すると、 その式は false と評価されます。
シンボルは、#defineディレクティブまたは-defineコンパイラオプションのいずれかで定義できます。 #undef ディレクティブは、 ファイル内で、ディレクティブではない他のステートメントよりも前に記述する必要があります。
例
     // preprocessor_undef.cs
// compile with: /d:DEBUG
#undef DEBUG
using System;
class MyClass
{
    static void Main()
{
#if DEBUG
        Console.WriteLine("DEBUG is defined");
#else
        Console.WriteLine("DEBUG is not defined");
#endif
} }
 DEBUG が定義されていません 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
#undef (C# リファレンス) 2021/03/06 • • Edit Online
 
        #warning を使用すると、コード内の特定の場所からCS1030レベル1のコンパイラの警告を生成できます。次に例を示しま す。
解説
#warning は条件付きディレクティブ内で一般的に使用されます。#errorを使用してユーザー定義のエラーを生成することも できます。
例
  #warning Deprecated code in this method.
      // preprocessor_warning.cs
// CS1030 expected
#define DEBUG
class MainClass
{
    static void Main()
    {
#if DEBUG
#warning DEBUG is defined
#endif
} }
 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
#warning (C# リファレンス) 2020/11/02 • • Edit Online
 
         #error を使用すると、コード内の特定の場所からユーザー定義のCS1029エラーを生成できます。次に例を示します。
  #error Deprecated code in this method.
     NOTE
コンパイラは #error version を特別な方法で処理し、使用されているコンパイラと言語バージョンを含むメッセージと共にコンパイラ エ ラー CS8304 を報告します。
  注釈
#error は条件付きディレクティブ内で一般的に使用されます。
#warning を使用してユーザー定義の警告を生成することもできます。 例
     // preprocessor_error.cs
// CS1029 expected
#define DEBUG
class MainClass
{
    static void Main()
    {
#if DEBUG
#error DEBUG is defined
#endif
} }
 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
#error (C# リファレンス) 2020/11/02 • • Edit Online
 
   #line を使用すると、コンパイラの行番号および(必要に応じて)エラーと警告に出力されるファイル名を変更することができま す。
次の例では、行番号に関連付けられている 2 つの警告を報告する方法を示します。 #line 200 ディレクティブは次の行番号 が200(既定では#6)になるように強制し、次の #line ディレクティブまでファイル名を"Special"として報告します。
#line default ディレクティブは、行の番号付けをその既定の番号付けに戻します。つまり、前のディレクティブで番号が付け 直された行をカウントします。
      class MainClass
{
    static void Main()
    {
#line 200 "Special"
int i;
        int j;
#line default
char c;
        float f;
#line hidden // numbering not affected
string s;
double d; }
}
 コンパイルで生成される出力は次のとおりです。
注釈
#line ディレクティブは、ビルドプロセスで自動化された中間ステップで使用される場合があります。たとえば、行が元のソース コード ファイルから削除されても、ファイル内の元の行番号付けに基づいてコンパイラに引き続き出力を生成させる場合は、行 を削除してから #line を使用して元の行番号付けをシミュレートできます。
開発者がコードをステップ実行すると、 #line hidden と次の #line ディレクティブ (別の #line hidden ディレクティブではな いと仮定) の間のすべての行がステップ オーバーされるように、 #line hidden ディレクティブは、連続する行をデバッガーから隠し ます。 このオプションは、ユーザー定義のコードとコンピューターによって生成されたコードを ASP.NET が区別できるようするために 使用することもできます。 この機能を主に使用しているのは ASP.NET ですが、より多くのソース ジェネレーターが利用できる可 能性はあります。
#line hidden ディレクティブはエラーの報告でのファイル名や行番号には影響しません。 つまり、非表示のブロックでエラーが 発生した場合、コンパイラはエラーの現在のファイル名と行番号を報告します。
#line filename ディレクティブは、コンパイラ出力に表示するファイル名を指定します。 既定では、ソース コード ファイルの実 際の名前が使用されます。 ファイル名は、二重引用符 ("") で囲み、前に行番号を付ける必要があります。
    Special(200,13): warning CS0168: The variable 'i' is declared but never used
Special(201,13): warning CS0168: The variable 'j' is declared but never used
MainClass.cs(9,14): warning CS0168: The variable 'c' is declared but never used
MainClass.cs(10,15): warning CS0168: The variable 'f' is declared but never used
MainClass.cs(12,16): warning CS0168: The variable 's' is declared but never used
MainClass.cs(13,16): warning CS0168: The variable 'd' is declared but never used
      #line (C# リファレンス) 2020/11/02 • • Edit Online
 
    ソースコードファイルは、任意の数の #line ディレクティブを持つことができます。 例1
次の例では、デバッガーがコード内の非表示の行を無視する方法を示します。 例を実行すると、次の 3 行のテキストが表示さ れます。 しかし、例に示されているようにブレークポイントを設定し、F10 キーを押してコードをステップ実行すると、デバッガーが 非表示の行を無視することがわかります。 非表示の行にブレークポイントを設定した場合でも、デバッガーは無視することに注 目してください。
    // preprocessor_linehidden.cs
using System;
class MainClass
{
    static void Main()
    {
        Console.WriteLine("Normal line #1."); // Set break point here.
#line hidden
        Console.WriteLine("Hidden line.");
#line default
        Console.WriteLine("Normal line #2.");
    }
}
 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ

       #nullable プリプロセッサディレクティブは、"Null許容注釈コンテキスト"と"Null許容警告コンテキスト"を設定します。この ディレクティブでは、Null 許容注釈の効果があるかどうか、および NULL 値の許容の警告が与えられるかどうかが制御されま す。 各コンテキストは "無効" または "有効" になります。
どちらのコンテキストもプロジェクトレベル(C#ソースコードの外部)で指定することができます。 #nullable ディレクティブは、注 釈と警告のコンテキストを制御し、プロジェクト レベルの設定よりも優先されます。 ディレクティブは、別のディレクティブがそれを オーバーライドするか、ソース ファイルの末尾に達するまで、制御するコンテキストを設定します。
ディレクティブの効果は次のとおりです。
  #nullable disable
  #nullable enable
  #nullable restore
 #nullable disable annotations
 #nullable enable annotations
 #nullable restore annotations
 #nullable disable warnings
 #nullable enable warnings
  #nullable restore warnings
関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
: Null 許容注釈および警告コンテキストを "無効" に設定します。 : Null 許容注釈および警告コンテキストを "有効" に設定します。
: Null 許容注釈および警告コンテキストを、プロジェクト設定に復元します。 : Null 許容注釈コンテキストを "無効" に設定します。
: Null 許容注釈コンテキストを "有効" に設定します。
: Null 許容注釈コンテキストを、プロジェクト設定に復元します。
: Null 許容警告コンテキストを "無効" に設定します。 : Null 許容警告コンテキストを "有効" に設定します。
: Null 許容警告コンテキストをプロジェクト設定に復元します。
#nullable - C# リファレンス 2021/03/06 • • Edit Online
 
         #region を使用すると、コードブロックを指定できます。このブロックは、コードエディターのアウトライン機能を使用して、展開 や折りたたみを行うことができます。 コード ファイルが長い場合は、現在操作している部分に集中できるように 1 つ以上の領域 を折りたたむ (非表示にする) ことができると便利です。 次の例では、領域を定義する方法を示します。
    #region MyClass definition
public class MyClass
{
    static void Main()
    {
    }
} #endregion
 Remarks
#region ブロックは、#endregionディレクティブで終了させる必要があります。
#region ブロックは、#if ブロックと重複することはできません。 ただし、 #region ブロックを #if ブロック内に入れ子にしたり、
#if ブロックを #region ブロック内に入れ子にしたりすることはできます。 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
    #region (C# リファレンス) 2020/11/02 • • Edit Online
 
        #endregion は#regionブロックの終了を示します。次に例を示します。
    #region MyClass definition
class MyClass
{
    static void Main()
    {
    }
} #endregion
 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
#endregion (C# リファレンス) 2020/11/02 • • Edit Online
 
           #pragma は、ファイル内に指定され、そのファイルのコンパイルについての特別な命令をコンパイラに指示します。命令はコンパ イラによってサポートされている必要があります。 つまり、 #pragma を使用してカスタムの前処理命令を作成することはできませ
  ん。 Microsoft C# コンパイラは、次の 2 つの #pragma warning
#pragma checksum
構文
パラメーター
pragma-name
認識されているプラグマの名前。
 pragma-arguments
プラグマに固有の引数。 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ #pragma warning #pragma checksum
命令をサポートしています。
  #pragma pragma-name pragma-arguments
#pragma
   #pragma (C# リファレンス) 2020/11/02 • • Edit Online
 
         #pragma warning を使用すると、特定の警告を有効または無効にすることができます。 構文
パラメーター
warning-list 警告番号のコンマ区切りのリスト。"CS"というプレフィックスは省略可能です。
警告番号が指定されていないと、 disable はすべての警告を無効にし、 restore はすべての警告を有効にします。
例
    #pragma warning disable warning-list
#pragma warning restore warning-list
        NOTE
Visual Studio で警告番号を調べるには、プロジェクトをビルドし、[ ] ウィンドウで警告番号を探してください。
     // pragma_warning.cs
using System;
#pragma warning disable 414, CS3021
[CLSCompliant(false)]
public class C
{
    int i = 1;
    static void Main()
    {
    }
}
#pragma warning restore CS3021
[CLSCompliant(false)]  // CS3021
public class D
{
    int i = 1;
    public static void F()
    {
    }
}
 関連項目
C# リファレンス
C# プログラミング ガイド
C# プリプロセッサ ディレクティブ
C# コンパイラ エラー コード分析の警告を抑制する方法
#pragma 警告 (C# リファレンス) 2021/03/06 • • Edit Online
 
    ASP.NET ページのデバッグに使用するソース ファイルのチェックサムを生成します。 構文
パラメーター
"filename"
変更または更新を監視する必要があるファイルの名前。
"{guid}"
ハッシュ アルゴリズムのグローバル一意識別子 (GUID)。
 "checksum_bytes"
チェックサムのバイト数を表す 16 進数の文字列。 偶数の 16 進数である必要があります。 奇数の数値を指定すると、コンパ イル時に警告が出力され、ディレクティブが無視されます。
解説
Visual Studio デバッガーは、常に正しいソースを検出するために、チェックサムを使用します。 コンパイラはソース ファイルの チェックサムを計算し、プログラム データベース (PDB) ファイルに結果を出力します。 デバッガーは、その PDB ファイルを使用し て、ソース ファイルについて計算したチェックサムと比較します。
このソリューションは ASP.NET プロジェクトには使用できません。計算されたチェックサムは、.aspx ファイルではなく、生成された ソース ファイルを対象としているためです。 この問題に対応するため、 #pragma checksum によって ASP.NET ページのチェックサ ムがサポートされています。
Visual C# で ASP.NET プロジェクトを作成すると、生成されるソース ファイルにソースの生成元である .aspx ファイルのチェックサ ムが含められます。 コンパイラは、この情報を PDB ファイルに書き込みます。
ファイルに #pragma checksum ディレクティブが見つからない場合、コンパイラはチェックサムを計算し、PDBファイルにその値を書 き込みます。
例
  #pragma checksum "filename" "{guid}" "checksum bytes"
          class TestClass
{
    static int Main()
    {
        #pragma checksum "file.cs" "{406EA660-64CF-4C82-B6F0-42D48172A799}" "ab007f1d23d9" // New checksum
    }
}
 関連項目
C# リファレンス
#pragma checksum (C# リファレンス) 2020/11/02 • • Edit Online
 
   C# プログラミング ガイド
C# プリプロセッサ ディレクティブ

           コンパイラは、実行可能ファイル (.exe)、ダイナミック リンク ライブラリ (.dll)、またはコード モジュール (.netmodule) を生成しま す。
すべてのコンパイル オプションは、 -option および /option という 2 つの形で使用できます。 このドキュメントでは、 -option のみを示しています。
Visual Studio では、コンパイラ オプションは web.config ファイルに設定します。 詳細については、<compiler> 要素に関する ページを参照してください。
このセクションの内容
コマンド ラインから Visual C# アプリケーションを構築する方法については、「csc.exe を使用したコマンド ラインからのビ
ルド」を参照してください。
Visual Studio のコマンド ラインの環境変数を設定する方法 VsDevCmd.bat を実行してコマンドライン ビルドを有効
にする手順について説明します。
カテゴリ別の C# コンパイラ オプションの一覧 コンパイラ オプションのカテゴリ別一覧。 アルファベット順の C# コンパイラ オプションの一覧 コンパイラ オプションのアルファベット順一覧。
関連項目
プロジェクト デザイナーの [ビルド] ページ プロジェクトのコンパイル、ビルド、デバッグ方法を制御するプロパティを設定しま
す。 Visual C# プロジェクトのカスタム ビルド手順に関する情報が含まれています。 既定のビルドとカスタム ビルド ビルドの種類と構成に関する情報です。 ビルドの準備と管理 Visual Studio 開発環境でビルドするための手順です。
C# コンパイラ オプション 2020/11/02 • • Edit Online
 
            一部の C# コンパイラ エラーには、エラーが生成された理由について説明するトピックがあり、エラーの解決方法が示されている ことがあります。 次のいずれかの手順に従って、特定のエラー メッセージのヘルプが存在するかどうかを確認してください。
[出力] ウィンドウでエラー番号 (例: CS0029) を見つけ、その番号を Microsoft Docs で検索します。 [出力] ウィンドウ でエラー番号 (例: CS0029) を選択し、F1 キーを押します。
[索引] の [検索] ボックスにエラー番号を入力します。
上記のどの手順でもエラーに関する情報を取得できない場合は、このページの最後に移動し、エラー番号またはエラー テキスト を含むフィードバックを送信してください。
C# でのエラーと警告のオプションを構成する方法については、「[ビルド] ページ (プロジェクト デザイナー) (C#)」を参照してくださ い。
関連項目
C# コンパイラ オプション
申し訳ありませんが、この C# エラーに関する詳細情報はありません。 [ビルド] ページ (プロジェクト デザイナー) (C#)
-warn (C# コンパイラ オプション)
-nowarn (C# コンパイラ オプション)
    NOTE
次の手順で参照している Visual Studio ユーザー インターフェイス要素の一部は、お使いのコンピューターでは名前や場所が異なる場合が あります。 これらの要素は、使用している Visual Studio のエディションや独自の設定によって決まります。 詳細については、「IDE をカスタマ イズする」をご覧ください。
 C# コンパイラ エラー 2020/11/02 • • Edit Online
 
   C# ("シー シャープ" と読みます) は、シンプルで最新のタイプ セーフなオブジェクト指向のプログラミング言語です。 C# には、C ファミリの言語でルートがあり、C、C++、Java プログラマーにすぐに慣れることができます。 C# は、ECMA International by ecma-334 _ STANDARD、ISO/iec By _ iso/iec 23270 標準として標準化されています。 Microsoft の .NET Framework 用 C# コンパイラは、これらの標準の両方の準拠した実装です。
C# はオブジェクト指向言語ですが、C# にはさらに "コンポーネント指向" プログラミングのサポートが含まれています。 最近のソ フトウェア設計では、機能を自己完結型および自己記述型パッケージの形式にしたソフトウェア コンポーネントをますます使用 するようになっています。 そのようなコンポーネントの鍵となるのは、プロパティ、メソッド、イベントを使用してプログラミング モデル を表すこと、コンポーネントについての宣言的な情報を提供する属性があること、独自のドキュメントが組み込まれていることで す。 C# には、これらの概念を直接サポートする言語構成要素が用意されています。 C# は、ソフトウェアコンポーネントを作成 して使用するための非常に自然な言語です。
堅牢で持続性のあるアプリケーションの構築に役立つ C# の機能がいくつかあります。 ガベージコレクション _ は、未使用のオ ブジェクトによって占有されているメモリを自動的に解放します。 _例外処理*_ は、エラーの検出と回復を行うための構造化さ れた拡張可能なアプローチを提供します。また、言語の 型セーフ な * 設計により、初期化されていない変数からの読み取り、 配列の境界外のインデックス作成、またはチェックを行わない型キャストの実行が不可能になります。
C#は"統合型システム"を採用しています。 int や double などのプリミティブ型を含めたC#のすべての型は、ルートとな る1つの object 型から派生しています。したがって、すべての型が一般的な操作のセットを共有し、すべての型の値を一貫 した方法で格納、転送、操作することができます。 さらに、C# はユーザー定義の参照型と値型の両方をサポートしているた め、オブジェクトを動的に割り当てることも、軽量の構造体をインラインで格納することもできます。
C# のプログラムとライブラリが互換性を保ちながら時間とともに進化できるように、C# の設計では "バージョン管理" に大きな 重点が置かれています。 多くのプログラミング言語は、この問題にほとんど注意を払っていません。その結果、それらの言語で書 かれたプログラムは、依存するライブラリの新しいバージョンが導入されたときに必要以上に頻繁に中断されてしまいます。 C# の設計でバージョン管理の考慮の影響を直接受けている側面として、別個の virtual 修飾子と override 修飾子、メソッ ドのオーバーロードの解決規則、明示的なインターフェイス メンバー宣言のサポートなどがあります。
この章の残りの部分では、C# 言語の重要な機能について説明します。 後の章では、ルールと例外について詳しく説明し、場 合によっては数学的に説明しますが、この章では、完全性を犠牲にし、簡潔さを重視しています。 この目的は、初期のプログ ラムの記述と後の章の読み取りを容易にする言語の概要をリーダーに提供することです。
Hello world
"Hello, World" は、プログラミング言語を紹介するために伝統的に使用されているプログラムです。 これを C# で記述すると次
のようになります。
通常、C#のソースファイルのファイル拡張子は .cs です。"Hello,World"プログラムがファイルに格納されていると仮定する と、 hello.cs コマンドラインを使用して、MicrosoftC#コンパイラでプログラムをコンパイルできます。
これにより、という名前の実行可能アセンブリが生成さ hello.exe れます。このアプリケーションの実行時に生成される出力は 次のようになります。
"Hello,World"プログラムは System 名前空間を参照する using ディレクティブで始まります。名前空間は、C#のプログラ ムとライブラリを階層的に整理するための手段です。 名前空間には、型と他の名前空間が含まれます。たとえば、 System 名 前空間には多数の型(プログラムで参照される Console クラスなど)と、他の多数の名前空間(IO や Collections など) が含まれます。特定の名前空間を参照する using ディレクティブを使用すると、その名前空間のメンバーである型を修飾せ
         はじめに
2021/03/06 • • Edit Online
    using System;
class Hello {
static void Main() { Console.WriteLine("Hello, World");
} }
  csc hello.cs
  Hello, World
 
   ずに使用できます。 using ディレクティブにより、プログラムで   を   の省略形 として使用できます。
"Hello,World"プログラムで宣言された Hello クラスにはメンバーが1つあります。Main という名前のメソッドです。 Main メソッドは static 修飾子を使用して宣言されています。インスタンスメソッドが this で囲んだ特定のオブジェクトインスタン スを参照できるのに対し、静的メソッドは特定のオブジェクトを参照せずに機能します。 規則により、 Main という名前の静的メ ソッドはプログラムのエントリ ポイントとして使用されます。
プログラムの出力は、 System 名前空間にある Console クラスの WriteLine メソッドによって生成されます。 このクラスは、 既定では Microsoft C# コンパイラによって自動的に参照される .NET Framework クラスライブラリによって提供されます。 C# 自体には、個別のランタイムライブラリがないことに注意してください。 代わりに、.NET Framework は C# のランタイムライブラリ です。
プログラムの構造
C# の主要な組織概念は、プログラム _ _、名前空間_、 _型_、 _メンバー_、および _アセンブリ*_ です。 C# プログラムは、1 つまたは複数のソース ファイルで構成されています。 プログラムは型を宣言します。型にはメンバーが含まれていて、複数の名 前空間に編成することができます。 型の例には、クラスおよびインターフェイスがあります。 メンバーの例には、フィールド、メソッ ド、プロパティ、およびイベントがあります。 C# プログラムはコンパイルされると、物理的にアセンブリにパッケージ化されます。 アセ ンブリには、通常、 .exe .dll *アプリケーション* と _ ライブラリ * のどちらを実装するかに応じて、ファイル拡張子またはが含 まれます。
例を示します。
Console.WriteLine
System.Console.WriteLine
        using System;
namespace Acme.Collections {
public class Stack {
Entry top;
public void Push(object data) { top = new Entry(top, data);
}
public object Pop() {
if (top == null) throw new InvalidOperationException(); object result = top.data;
top = top.next;
return result;
}
class Entry {
public Entry next; public object data;
public Entry(Entry next, object data) { this.next = next;
this.data = data;
} }
} }
  という名前空間で、という名前のクラスを宣言 Stack Acme.Collections します。 このクラスの完全修飾名は Acme.Collections.Stack です。 このクラスには複数のメンバーが含まれています: top という名前のフィールドが 1 つ、 Push
と Pop という名前のメソッドが合わせて2つ、そして Entry という名前の入れ子になったクラスです。 Entry クラスにはさら に、3 つのメンバーが含まれています: next という名前のフィールド、 data という名前のフィールド、およびコンストラクターで す。例のソースコードが acme.cs のファイルに保存されていることを前提に、次のコマンドラインをご覧ください。
このコマンドラインは例をライブラリ(Main エントリポイントがないコード)としてコンパイルし、acme.dll という名前のアセンブリ を生成します。
アセンブリには、*中間言語 _ (IL) 命令の形式の実行可能コードと、_ metadata * 形式のシンボリック情報が含まれていま す。 アセンブリの IL コードは実行前に、.NET 共通言語ランタイムの Just-In-Time (JIT) コンパイラによって、プロセッサ固有の コードに自動的に変換されます。
    csc /t:library acme.cs
   アセンブリはコードとメタデータの両方を含む自己記述的な機能的単位であるため、 #include ディレクティブおよびヘッダー ファ

 イルが C# に含まれている必要はありません。 特定のアセンブリに含まれているパブリックの型とメンバーは、単にプログラムのコン パイル中にそのアセンブリを参照することにより、C#プログラムで利用可能になります。たとえば、このプログラムでは acme.dll アセンブリの Acme.Collections.Stack クラスを使用しています。
     test.cs
 acme.dll
プログラムがファイルに格納されている場合 test.cs 、をコンパイルするときに、 コンパイラのオプションを 使用してアセンブリを参照でき /r ます。
これにより test.exe という名前の実行可能なアセンブリが作成され、これが実行された場合に、次の出力が生成されます。
C# では、プログラムのソース テキストを複数のソース ファイルに保存することができます。 複数ファイルの C# プログラムがコンパイ ルされると、ソース ファイルはすべて同時に処理され、ソース ファイルは自由に相互を参照できるようになります。概念的には、 ソース ファイルが処理される前に、すべて 1 つの大きいファイルに連結されるようなものです。 C# では事前宣言をする必要があ りません。ごく一部の例外を除いて、宣言の順序は重要でないためです。 C# ではソース ファイルがパブリック型 1 つのみの宣言 に制限されません。また、ソース ファイルの名前がソース ファイルで宣言された型に一致する必要もありません。
型と変数
C# の型には、*値型 _ と _ 参照型 * の2種類があります。 値型の変数が直接データを格納するのに対して、参照型の変数 はデータへの参照を格納し、後者はオブジェクトとして知られています。 参照型を使用すると 2 つの変数が同じオブジェクトを参 照できるため、1 つの変数に対する演算によって、もう一方の変数によって参照されるオブジェクトに影響を与えることができま す。 値型の場合、各変数が独自のデータ コピーを保持し、1 つの変数に対する演算で別の変数に影響を与えることはできま せん(ref と out のパラメーターの変数の場合を除く)。
C# の値型はさらに、単純型 _、 _列挙型_、 _構造体型_、および _null 許容型_ に分割され、c# の参照型はさらに、 _クラ ス型_、 _インターフェイス型_、 _配列型*、および _ *デリゲート型* * に分割されます。
   次の表は、C# の型システムの概要を示しています。
値型 単純型
符号付きの整数: sbyte 、 short 、 int 、 long
符号なしの整数: byte 、 ushort 、 uint 、 ulong
Unicode文字: char
IEEE 浮動小数点: float 、 double 高精度の 10 進数: decimal ブール値: bool
                                           列挙型
enum E {...} 形式のユーザー定義型
      using System;
using Acme.Collections;
class Test {
static void Main() {
Stack s = new Stack(); s.Push(1);
s.Push(10);
s.Push(100); Console.WriteLine(s.Pop()); Console.WriteLine(s.Pop()); Console.WriteLine(s.Pop());
} }
  csc /r:acme.dll test.cs
    100 10 1
 
        構造体の型
null 許容型
参照型 クラスの種類
インターフェイス型
配列型
デリゲート型
struct S {...} 形式のユーザー定義 型
null 値を持つその他すべての値型の拡 張子
その他すべての型の最終的な基底クラス: object
Unicode文字列: string
class C {...} 形式のユーザー定義型
interface I {...} 形式のユーザー定 義型
1 次元または多次元、たとえば int[] お よび int[,]
フォームのユーザー定義型 (例: delegate int D(...)
                                              8 つの整数型は、符号付きまたは符号なしの形式で、8 ビット、16 ビット、32 ビットおよび 64 ビットの値をサポートします。 2つの浮動小数点型 ( float と) は、 double 32 ビットの単精度と64ビットの倍精度の IEEE 754 形式を使用して表されま
す。
decimal 型は128ビットのデータ型で、財務や通貨の計算に適しています。
C# の bool 型は、ブール値 (またはの値) を表すために使用され true false ます。 C#における文字および文字列の処理では、Unicodeエンコーディングを使用します。 char 型はUTF-16コード単位を表
 し、string 型は一連のUTF-16コード単位を表します。 次の表は、C# の数値型をまとめたものです。
BITS TYPE
符号付き整数 8
16 short
32 int
符号なしの整数 8
16 ushort
32 uint 64 ulong
/
-128... 127 -32768... 32、767
-2147483648... 2、147、 483、647
0... 255
0... 65、535
0... 4、294、967、295
0... 18、446、744、073、 709、551、615
1.5×10^−45~3.4×10 ^ 38、7桁の有効桁数
5.0×10^−324~1.7× 10 ^ 308、15桁の有効桁数
        sbyte
                        64
long
 byte
-9223372036854775808... 9、223、372、036、854、 775、807
                                   浮動小数点 32
float
        64 double
    
 BITS TYPE /
         Decimal 128 decimal 1.0 × 10 ^ −28から7.9 × 10 ^ 28、28桁の有効桁数
C# プログラムでは 型宣言 を使用して新しい型を作成します。 型宣言は、新しい型の名前とメンバーを指定します。 C# の 型カテゴリのうち 5 つはユーザー定義が可能です。クラス型、構造体型、インターフェイス型、列挙型、そしてデリゲート型です。
クラス型は、データメンバー (フィールド) と関数メンバー (メソッド、プロパティなど) を含むデータ構造を定義します。 クラス型で は、単一継承とポリモーフィズムをサポートします。このメカニズムによって派生クラスが基底クラスを拡張して特殊化できます。
構造体型は、データメンバーと関数メンバーを持つ構造体を表すという点で、クラス型に似ています。 ただし、クラスとは異な り、構造体は値型であり、ヒープ割り当ては必要ありません。 構造体型はユーザー指定の継承をサポートせず、すべての構造 体型は暗黙的に object 型を継承します。
インターフェイス型は、パブリック関数メンバーの名前付きセットとしてコントラクトを定義します。 インターフェイスを実装するクラス または構造体は、インターフェイスの関数メンバーの実装を提供する必要があります。 インターフェイスは複数の基本インター フェイスから継承でき、クラスまたは構造体は複数のインターフェイスを実装できます。
"デリゲート型" は、特定のパラメーター リストおよび戻り値の型を持つメソッドへの参照を表します。 デリゲートを使用すれば、変 数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。 デリゲートはまた、他のいくつかの 言語にみられる関数ポインターの概念に似ていますが、関数ポインターとは異なり、デリゲートはオブジェクト指向でタイプ セーフ です。
クラス、構造体、インターフェイス、およびデリゲート型はすべてジェネリックをサポートし、他の型でパラメーター化することができま す。
列挙型は、名前付き定数を持つ別個の型です。 すべての列挙型には基になる型があり、これは8つの整数型のいずれかであ る必要があります。 列挙型の値のセットは、基になる型の値のセットと同じです。
C# は、あらゆる型の 1 次元および多次元の配列をサポートしています。 上記の型とは異なり、配列型は使用前に宣言する 必要がありません。代わりに配列型は、角かっこで囲んだ型名を後に付けることにより構成されます。たとえば、 int[] はの1 次元配列で、は int の2次元配列であり、 int[,] int int[][] はの1次元配列の1次元配列です int 。
Null許容型は、使用する前に宣言する必要もありません。Null非許容の値型ごとに、 T 対応するnull許容型があり
T? ます。これには、追加の値を保持でき null ます。たとえば、 int? は、任意の32ビット整数または値を保持できる型で
す null 。
C# の型システムは、任意の型の値をオブジェクトとして扱うことができるように統合されています。 C# における型はすべて、直 接的または間接的に object クラス型から派生し、 object はすべての型の究極の基底クラスです。 参照型の値は、値を 単純に object 型としてみなすことによってオブジェクトとして扱われます。値型の値は、ボックス化_および_ボックス化解除 操作を実行することで、オブジェクトとして扱われます。 次の例では、 int 値は object 値に変換され、また int に戻され ます。
      値型の値を型に変換すると、 object オブジェクトインスタンス("box"とも呼ばれます)が値を保持するために割り当てられ、 値がそのボックスにコピーされます。逆に、 object 参照が値型にキャストされると、参照先のオブジェクトが正しい値の型のボッ クスであることがチェックされます。チェックに成功した場合は、ボックス内の値がコピーされます。
C# の統合型システムは、値型が "オンデマンド" でオブジェクトになる可能性があることを意味します。 こうした統一性があるた め、 object 型を使用する汎用的なライブラリは、参照型と値型の両方で使用できます。
C# には、フィールド、配列要素、ローカル変数、パラメーターなどの、いくつかの種類の 変数 があります。 変数はストレージの 場所を表し、すべての変数には、次の表に示すように、変数に格納できる値を決定する型があります。
null 非許容値型 型そのものの値
null 許容値型 Null 値またはその正確な型の値
             using System;
class Test {
static void Main() { int i = 123; object o = i;
// Boxing // Unboxing
} }
int j = (int)o;
 
      object
Null 参照、任意の参照型のオブジェクトへの参照、または任意の値 型のボックス化された値への参照
    クラス型 Null 参照、そのクラス型のインスタンスへの参照、またはそのクラス型 から派生したクラスのインスタンスへの参照
配列型 Null 参照、その配列型のインスタンスへの参照、または互換性のある 配列型のインスタンスへの参照
デリゲート型 Null 参照、またはそのデリゲート型のインスタンスへの参照
式
式 _ は、 _オペランド_ と _演算子*_ から構築されます。 式の演算子は、オペランドに適用する演算を表します。 演算子の例 として、 + 、 - 、 _ 、 / 、および new などがあります。 オペランドの例としては、リテラル、フィールド、ローカル変数、式などが あります。
式に複数の演算子が含まれている場合、演算子の *優先順位 は、個々の演算子が評価される順序を制御します。 たとえ ば、式 x + y _ z の評価は x + (y * z) ですが、これは * 演算子が + 演算子より高い優先順位だからです。
ほとんどの演算子は オーバーロード できます。 演算子をオーバーロードすると、ユーザー定義演算子の実装を、1 つまたは両 方のオペランドがユーザー定義のクラスまたは構造体型である演算子に指定することができます。
次の表は、演算子のカテゴリを優先順位の高い順に一覧表示する C# の演算子をまとめたものです。 同じカテゴリ内の演算 子の優先順位は同じです。
    インターフェイスの型
        [ ]
プライマリ x.m x(...)
x[...]
x++
x--
new T(...)
new T(...){...}
new {...}
new T[...]
typeof(T)
checked(x)
unchecked(x)
default(T)
delegate {...}
メンバー アクセス。 メソッドおよびデリゲートの呼び出し。 配列アクセスおよびインデクサー アクセス。 後置インクリメント。
後置デクリメント。 オブジェクトおよびデリゲートの作成。 初期化子を使用したオブジェクトの作成 匿名オブジェクト初期化子
配列の作成
T の System.Type オブジェクトの取得 checked コンテキストで式を評価します。 unchecked コンテキストで式を評価します。
T 型の既定値の取得 匿名関数 (匿名メソッド)。
                                                                                                   単項 +x ID -x 否定
Null 参照、そのインターフェイス型を実装するクラス型のインスタンスへ の参照、またはそのインターフェイス型を実装する値型のボックス化さ れた値への参照
           
 [ ]
                                          乗法
加法
Shift
関係式と型検査
!x
~x
++x
--x
(T)x
await x
x*y
x/y
x%y
x+y
x-y
x<<y
x>>y
x<y
x>y
x<=y
x>=y
xisT
xasT
x==y
x!=y
x&y
x^y
x|y
x&&y
x||y
x??y
論理否定 ビットごとの否定。 前置インクリメント。 前置デクリメント。
x を明示的に T 型に変換
x が完了するのを非同期的に待つ
乗算
除算
剰余
加算、文字列の連結、デリゲートの組み合 わせ。
減算、デリゲートの削除。 左シフト。
右シフト。
より小さい
より大きい 以下 以上
x が T であれば true を、そうでなけ れば false を返す
T として型指定された x か、x が T でない場合は null を返す
等しい 等しくない
整数のビットごとの AND、ブール型の論理 AND
整数のビットごとの XOR、ブール型の論理 XOR。
整数のビットごとの OR、ブール型の論理 OR。
y x がの場合にのみ評価されます。 true
y x がの場合にのみ評価されます。 false
y xがの場合はnull、xそれ以 外の場合はに評価されます。
                                                                              等価比較
論理積
論理 XOR
論理和
条件 AND
条件 OR
Null 合体演算子
                                             
  [ ]
      条件付き
x?y:z
x = y
(T x) => y
x が true の場合は y を、x が false の場合は z を評価する
割り当て
匿名関数 (ラムダ式)
      代入または匿名関数
ステートメント
   プログラムの処理は、"ステートメント" を使用して表されます。 C# はさまざまな種類のステートメントをサポートしており、その多 くは埋め込みステートメントとして定義されています。
"ブロック" を使用すると、1 つのステートメントしか使用できないコンテキストで複数のステートメントを記述できます。 ブロックは、 区切り記号 { と } の間に記述されたステートメントのリストから成ります。
"宣言ステートメント" は、ローカル変数および定数の宣言に使用します。
"式ステートメント" は、式の評価に使用します。 ステートメントとして使用できる式には、メソッドの呼び出し、演算子を使用し たオブジェクト new の割り当て、演算子と = 複合代入演算子、および演算子とawait式を使用した加算およびデクリメント 演算が含まれ ++ -- ます。
"選択ステートメント" は、式の値に基づいて、実行できる多数のステートメントから 1 つを選択するために使用します。 このグ ループには if および switch ステートメントが含まれます。
繰り返し ステートメント は、埋め込みステートメントを繰り返し実行するために使用されます。 このグループには、 while 、 do 、 for 、および foreach ステートメントが含まれます。
"ジャンプ ステートメント" は、制御を移すために使用します。 このグループには、 break 、 continue 、 goto 、 throw 、 return 、および yield ステートメントが含まれます。
try ... catch ステートメントはブロックの実行中に発生した例外をキャッチするために使用し、 try ... finally ステートメント は例外が発生したかどうかにかかわらず常に実行される終了処理コードを指定するために使用します。
checked およびステートメントは、 unchecked 整数型の算術演算および変換のオーバーフローチェックコンテキストを制御する ために使用されます。
lock ステートメントは、指定のオブジェクトに対する相互排他ロックを取得し、ステートメントを実行してからロックを解放するた めに使用します。
using ステートメントは、リソースを取得し、ステートメントを実行してからそのリソースを破棄するために使用します。 各種類のステートメントの例を次に示します。
ローカル変数の宣言
ローカル定数宣言
       式ステートメント
     x op= y
   複合代入。サポートされて *= /= %= += -= <<= いる >>= 演算子 &= ^= |=
     static void Main() { int a;
int b = 2, c = 3;
a = 1;
Console.WriteLine(a + b + c);
}
    static void Main() {
const float pi = 3.1415927f; const int r = 25; Console.WriteLine(pi * r * r);
}
 
  if ステートメント
switch ステートメント
  while ステートメント
do ステートメント
for ステートメント
foreach ステートメント
        static void Main() { int i;
i = 123; Console.WriteLine(i); i++; Console.WriteLine(i);
// Expression statement // Expression statement // Expression statement // Expression statement
}
    static void Main(string[] args) { if (args.Length == 0) {
Console.WriteLine("No arguments"); }
else {
Console.WriteLine("One or more arguments");
} }
    static void Main(string[] args) { int n = args.Length;
switch (n) {
} }
case 0:
Console.WriteLine("No arguments"); break;
case 1:
Console.WriteLine("One argument"); break;
default:
Console.WriteLine("{0} arguments", n); break;
    static void Main(string[] args) { int i = 0;
while (i < args.Length) { Console.WriteLine(args[i]); i++;
} }
    static void Main() { string s;
do {
s = Console.ReadLine();
if (s != null) Console.WriteLine(s);
} while (s != null); }
    static void Main(string[] args) {
for (int i = 0; i < args.Length; i++) {
Console.WriteLine(args[i]); }
}
    static void Main(string[] args) { foreach (string s in args) {
Console.WriteLine(s); }
}
 
 break ステートメント
  continue ステートメント
goto ステートメント
return ステートメント
yield ステートメント
     throw``try ステートメントとステートメント
   static void Main() { while (true) {
} }
string s = Console.ReadLine(); if (s == null) break; Console.WriteLine(s);
    static void Main(string[] args) {
for (int i = 0; i < args.Length; i++) {
if (args[i].StartsWith("/")) continue;
Console.WriteLine(args[i]); }
}
    static void Main(string[] args) { int i = 0;
goto check;
loop: Console.WriteLine(args[i++]); check:
if (i < args.Length) goto loop;
}
    static int Add(int a, int b) { return a + b;
}
static void Main() { Console.WriteLine(Add(1, 2)); return;
}
    static IEnumerable<int> Range(int from, int to) { for (int i = from; i < to; i++) {
yield return i; }
yield break; }
static void Main() {
foreach (int x in Range(-10,10)) {
Console.WriteLine(x); }
}
 
   checked``unchecked ステートメントとステートメント
lock ステートメント
  using ステートメント
クラスとオブジェクト
*クラス _ は、C# の最も基本的な型です。 クラスは、状態 (フィールド) とアクション (メソッドおよびその他の関数メンバー) を 1 つの単位としてまとめたデータ構造です。 クラスは、動的に作成されたクラスの *インスタンス* ( *オブジェクト* とも呼ばれます) の定義を提供します。 クラスは、*派生クラス* が _ 基底クラス * を拡張および特殊化できる機構である *継承* と *ポリモーフィ ズム* をサポートしています。
新しいクラスはクラス宣言を使用して作成されます。 クラス宣言は、クラスの属性と修飾子、クラスの名前、基底クラス (指定さ れている場合)、およびクラスによって実装されるインターフェイスを指定するヘッダーで開始します。 ヘッダーの後にはクラス本体 が続きます。これは、区切り記号 { と } の間に記述するメンバー宣言のリストで構成されます。
 Point という名前の単純なクラスの宣言を次に示します。
   static double Divide(double x, double y) {
if (y == 0) throw new DivideByZeroException(); return x / y;
}
static void Main(string[] args) { try {
if (args.Length != 2) {
throw new Exception("Two numbers required");
}
double x = double.Parse(args[0]); double y = double.Parse(args[1]); Console.WriteLine(Divide(x, y));
}
catch (Exception e) {
Console.WriteLine(e.Message); }
finally {
Console.WriteLine("Good bye!");
} }
    static void Main() {
int i = int.MaxValue; checked {
Console.WriteLine(i + 1);
}
unchecked {
// Exception
// Overflow
} }
Console.WriteLine(i + 1);
    class Account {
decimal balance;
public void Withdraw(decimal amount) {
} }
lock (this) {
if (amount > balance) {
throw new Exception("Insufficient funds"); }
balance -= amount; }
    static void Main() {
using (TextWriter w = File.CreateText("test.txt")) {
} }
w.WriteLine("Line one"); w.WriteLine("Line two"); w.WriteLine("Line three");
 
  クラスのインスタンスは new 演算子を使用して作成されます。この演算子は新しいインスタンスのメモリを割り当て、コンストラク ターを呼び出してインスタンスを初期化し、インスタンスへの参照を返します。次のステートメントは、2つの Point オブジェクト を作成し、2 つの変数に、それらのオブジェクトへの参照を格納します。
オブジェクトによって占有されているメモリは、オブジェクトが使用されなくなったときに自動的に解放されます。 C# では、オブジェ クトの割り当てを明示的に解除する必要がなく、また解除することもできません。
メンバー
クラスのメンバーは、*静的メンバー _ または _ インスタンスメンバー * のいずれかです。 静的メンバーはクラスに属しており、イン
スタンス メンバーはオブジェクト (クラスのインスタンス) に属しています。 次の表は、クラスに含めることができるメンバーの種類の概要を示しています。
     定数 フィールド メソッド Properties
インデクサー
events
オペレーター コンストラクター
デストラクター
型
アクセシビリティ
クラスに関連付けられている定数値
クラスの変数
クラスによって実行可能な計算とアクション
クラスの名前付きプロパティの読み取りと書き込みに関連付けられて いるアクション
配列など、クラスのインスタンスのインデックス作成に関連付けられてい るアクション
クラスによって生成可能な通知 クラスによってサポートされている変換と式の演算子
クラスのインスタンスまたはクラス自体を初期化するために必要なアク ション
クラスのインスタンスが完全に破棄される前に実行するアクション クラスで宣言される、入れ子にされた型
                                      クラスの各メンバーにはアクセシビリティが関連付けられています。アクセシビリティは、メンバーへのアクセスが可能なプログラムのテ キストの範囲を制御します。 アクセシビリティには 5 つの有効な形式があります。 これらの概要を次の表に示します。
    public
protected
internal
protected internal
アクセスは制限されません。
アクセスは、このクラスまたはこのクラスから派生したクラスに制限され ます。
アクセスはこのプログラムに制限されます。
アクセスは、このプログラムまたはこのクラスから派生したクラスに制限 されます。
                    public class Point {
public int x, y;
public Point(int x, int y) { this.x = x;
this.y = y; }
}
  Point p1 = new Point(0, 0); Point p2 = new Point(10, 20);
 
      private アクセスはこのクラスに制限されます。 型パラメーター
クラス定義では、クラス名の後に型パラメーター名のリストを山かっこで囲むことで、型パラメーターのセットを指定できます。 これ で、クラスのメンバーを定義するクラス宣言の本体で型パラメーターを使用できます。 次の例では、 Pair の型パラメーターは
TFirst と TSecond です。
型パラメーターを受け取るように宣言されているクラス型は、ジェネリッククラス型と呼ばれます。 構造体、インターフェイス、および デリゲートの型もジェネリックです。
ジェネリック クラスを使用する場合は、それぞれの型パラメーターの型引数を指定する必要があります。
上記のように、指定された型引数を持つジェネリック型 Pair<int,string> は、構築された型と呼ばれます。 基底クラス
クラス宣言では、クラス名と型パラメーターの後にコロンと基底クラスの名前を入力することで、基底クラスを指定できます。 基底 クラスの指定の省略は、 object 型からの派生と同じです。 次の例では、 Point3D の基底クラスは Point であり、 Point の基底クラスは object です。
        クラスは、その基底クラスのメンバーを継承します。 継承とは、クラスに基底クラスのすべてのメンバーが暗黙的に格納されること を意味します。ただし、インスタンスコンストラクターと静的コンストラクター、および基底クラスのデストラクターは除きます。 派生ク ラスは、継承するメンバーに新しいメンバーを追加できますが、継承されたメンバーの定義を削除することはできません。 前述の 例では、 Point3D は、 Point から x フィールドと y フィールドを継承します。各 Point3D インスタンスには、 x 、 y 、 z の 3 つのフィールドが含まれています。
暗黙的な変換は、クラス型からその基底クラス型のいずれかに存在します。 そのため、クラス型の変数は、そのクラスのインスタ ンスまたは任意の派生クラスのインスタンスを参照できます。 たとえば、前述のクラス宣言では、 Point 型の変数が Point ま たは Point3D を参照できます。
フィールド
"フィールド" は、クラスまたはクラスのインスタンスに関連付けられている変数です。
修飾子を使用して宣言されたフィールドは、 static 静的フィールドを定義します。静的フィールドは、格納場所を1つだ け識別します。 クラスのインスタンスがいくつ作成されても、静的フィールドのコピーは 1 つだけです。
       public class Pair<TFirst,TSecond> {
public TFirst First;
public TSecond Second; }
    Pair<int,string> pair = new Pair<int,string> { First = 1, Second = "two" }; int i = pair.First; // TFirst is int
string s = pair.Second; // TSecond is string
    public class Point {
public int x, y;
public Point(int x, int y) { this.x = x;
this.y = y; }
}
public class Point3D: Point {
public int z;
public Point3D(int x, int y, int z): base(x, y) { this.z = z;
} }
  Point a = new Point(10, 20);
Point b = new Point3D(10, 20, 30);
 
 修飾子を指定せずに宣言されたフィールドは、 static インスタンスフィールド を定義します。 クラスの各インスタンスには、そ のクラスのすべてのインスタンス フィールドの個別のコピーが含まれています。
次の例では、 Color クラスの各インスタンスに、インスタンス フィールド r 、 g 、 b の個別のコピーが含まれていますが、静的 フィールド Black 、 White 、 Red 、 Green 、 Blue のコピーは 1 つだけです。
  前述の例のように、readonly 修飾子を使用して"読み取り専用フィールド"を宣言できます。フィールドへの割り当て readonly は、フィールドの宣言の一部として、または同じクラスのコンストラクター内でのみ行うことができます。
メソッド
*メソッド _ は、オブジェクトまたはクラスによって実行できる計算またはアクションを実装するメンバーです。 *静的メソッド* には、
クラスを使用してアクセスします。 _ インスタンスメソッド* は、クラスのインスタンスを介してアクセスされます。
メソッドには、メソッドに渡された値または変数参照を表す parameters _ のリスト (空の場合もあります) と、メソッドによって 計算および返される値の型を指定する_*戻り値の型*があります。メソッドの戻り値の型は、 void 値を返さない場合はで す。
型と同様に、メソッドには型パラメーターのセットを含めることができます。その場合、メソッドの呼び出し時に型引数を指定する 必要があります。 型引数は、型とは異なり、多くの場合メソッド呼び出しの引数から推論できます。型引数を明示的に指定す る必要はありません。
メソッドの "シグネチャ" は、メソッドが宣言されているクラス内で一意である必要があります。 メソッドのシグネチャは、メソッドの 名前、型パラメーターの数、およびメソッドのパラメーターの数、修飾子、型で構成されます。 メソッドのシグネチャに戻り値の型 は含まれません。
パラメーター
パラメーターは、値または変数参照をメソッドに渡すために使用されます。 メソッドのパラメーターは、メソッドの呼び出し時に指 定する "引数" から実際の値を取得します。 値パラメーター、参照パラメーター、出力パラメーター、およびパラメーター配列の 4 種類のパラメーターがあります。
"値パラメーター" は入力パラメーターの引き渡しに使用します。 値パラメーターは、パラメーターに渡された引数からその初期 値を取得するローカル変数に相当します。 値パラメーターに対する変更は、パラメーターに渡された引数には影響しません。
値パラメーターは省略可能であり、既定値を指定すると、対応する引数を省略できます。
"参照パラメーター" は入力パラメーターと出力パラメーターの引き渡しに使用します。 参照パラメーターに渡す引数は変数で ある必要があり、メソッドの実行中に、参照パラメーターは引数の変数と同じ格納場所を表します。 参照パラメーターは、 ref 修飾子で宣言されます。 ref パラメーターの使用例を次に示します。
  "出力パラメーター" は出力パラメーターの引き渡しに使用します。 呼び出し元が提供する引数の初期値が重要でないことを
   public class Color {
public static readonly Color Black = new Color(0, 0, 0); public static readonly Color White = new Color(255, 255, 255); public static readonly Color Red = new Color(255, 0, 0); public static readonly Color Green = new Color(0, 255, 0); public static readonly Color Blue = new Color(0, 0, 255); private byte r, g, b;
public Color(byte r, byte g, byte b) { this.r = r;
this.g = g;
this.b = b; }
}
    using System;
class Test {
static void Swap(ref int x, ref int y) { int temp = x;
x = y;
y = temp; }
static void Main() {
int i = 1, j = 2;
Swap(ref i, ref j); Console.WriteLine("{0} {1}", i, j);
} }
// Outputs "2 1"
 
 除き、出力パラメーターは参照パラメーターと同様です。 出力パラメーターは、 out 修飾子で宣言されます。 out パラメー ターの使用例を次に示します。
 "パラメーター配列"は、引数の変数の数をメソッドに渡せるようにします。パラメーター配列は、params 修飾子で宣言されま す。 パラメーター配列として使用できるのは、メソッドの最後のパラメーターのみです。パラメーター配列の型は、1 次元配列の 型である必要があります。 System.Console クラスの Write および WriteLine メソッドは、パラメーター配列の使用方法の 好例です。 これらのメソッドは次のように宣言されます。
パラメーター配列を使用するメソッド内では、パラメーター配列は、配列型の通常のパラメーターとまったく同じように動作しま す。 ただし、パラメーター配列を使用するメソッドの呼び出しでは、パラメーター配列の型の 1 つの引数またはパラメーター配列 の要素型の任意の数の引数を渡すことができます。 後者の場合、配列インスタンスが自動的に作成され、指定した引数を使 用して初期化されます。 次のような例があるとします。
これは、次の記述と同じです。
メソッドの本体とローカル変数 メソッドの本体は、メソッドが呼び出されたときに実行するステートメントを指定します。
メソッドの本体は、メソッドの呼び出しに固有の変数を宣言できます。 このような変数は "ローカル変数" と呼ばれます。 ローカ ル変数宣言は、型名、変数名、および (場合によっては) 初期値を指定します。 次の例では、初期値 0 を使用してローカル 変数 i を宣言し、初期値を使用せずにローカル変数 j を宣言します。
      C#では、ローカル変数の値を取得する前に、ローカル変数を"明示的に割り当てる"必要があります。たとえば、前述の i の宣言に初期値が含まれていなかった場合、コンパイラは以降の i の使用に対するエラーを報告します。これは、プログラム
   using System;
class Test {
static void Divide(int x, int y, out int result, out int remainder) { result = x / y;
} }
remainder = x % y; }
static void Main() { int res, rem;
Divide(10, 3, out res, out rem); Console.WriteLine("{0} {1}", res, rem);
// Outputs "3 1"
    public class Console {
public static void Write(string fmt, params object[] args) {...} public static void WriteLine(string fmt, params object[] args) {...} ...
}
  Console.WriteLine("x={0} y={1} z={2}", x, y, z);
    string s = "x={0} y={1} z={2}"; object[] args = new object[3]; args[0] = x;
args[1] = y;
args[2] = z; Console.WriteLine(s, args);
    using System;
class Squares {
static void Main() { int i = 0;
int j;
while (i < 10) {
}
} }
j = i * i;
Console.WriteLine("{0} x {0} = {1}", i, j); i = i + 1;
 
 内のそれらのポイントで i が明示的に割り当てられていないためです。
メソッドでは、 return ステートメントを使用して、呼び出し元に制御を戻すことができます。 void を返すメソッドの場合、 return ステートメントは式を指定できません。以外のステートメントを返すメソッドでは void 、 return ステートメントに戻り
値を計算する式を含める必要があります。
静的メソッドとインスタンス メソッド
static 修飾子で宣言されているメソッドは"静的メソッド"です。静的メソッドは、特定のインスタンスでは動作せず、静的メ
ンバーにのみ直接アクセスできます。
static 修飾子なしで宣言されているメソッドは"インスタンスメソッド"です。インスタンスメソッドは、特定のインスタンスで 動作し、静的メンバーとインスタンス メンバーの両方にアクセスできます。 インスタンス メソッドが呼び出されたインスタンスには、
this として明示的にアクセスできます。静的メソッドで this を参照するとエラーになります。 次の Entity クラスには、静的メンバーとインスタンスメンバーの両方があります。
 各 Entity インスタンスには、シリアル番号(およびここに表示されていないその他の情報)が含まれています。 Entity コンス トラクターは (インスタンス メソッドと同様に)、次に使用可能なシリアル番号を持つ新しいインスタンスを初期化します。 コンスト ラクターはインスタンス メンバーであるため、 serialNo インスタンス フィールドと nextSerialNo 静的フィールドの両方にアクセス できます。
静的メソッドである GetNextSerialNo と SetNextSerialNo は nextSerialNo 静的フィールドにアクセスできますが、 serialNo インスタンスフィールドに直接アクセスするとエラーになります。
Entity クラスの使用例を次に示します。
          静的メソッドである SetNextSerialNo と GetNextSerialNo はクラスで呼び出されますが、 GetSerialNo インスタンス メソッド はクラスのインスタンスで呼び出されます。
仮想メソッド、オーバーライド メソッド、および抽象メソッド
インスタンスメソッドの宣言に修飾子が含まれている場合 virtual 、メソッドは *仮想メソッド _ と呼ばれます。 virtual 修 飾子が存在しない場合、メソッドは、 非仮想メソッド * と呼ばれます。
仮想メソッドが呼び出されると、呼び出し元のインスタンスの *実行時の型 _ によって、呼び出す実際のメソッドの実装が決まり ます。 非仮想メソッドの呼び出しでは、インスタンスの _ コンパイル時の型* が決定要因になります。
仮想メソッドは派生クラスで"オーバーライド"できます。インスタンスメソッドの宣言に修飾子が含まれている場合 override 、メソッドは、同じシグネチャを持つ継承された仮想メソッドをオーバーライドします。 仮想メソッドの宣言には新しいメソッドが導
      class Entity {
static int nextSerialNo; int serialNo;
public Entity() {
serialNo = nextSerialNo++;
}
public int GetSerialNo() { return serialNo;
}
public static int GetNextSerialNo() { return nextSerialNo;
}
public static void SetNextSerialNo(int value) { nextSerialNo = value;
} }
    using System;
class Test {
static void Main() { Entity.SetNextSerialNo(1000);
Entity e1 = new Entity();
Entity e2 = new Entity(); Console.WriteLine(e1.GetSerialNo()); Console.WriteLine(e2.GetSerialNo()); Console.WriteLine(Entity.GetNextSerialNo());
} }
// Outputs "1000" // Outputs "1001" // Outputs "1002"
 
  入されていますが、オーバーライド メソッドの宣言では、そのメソッドの新しい実装を提供することで既存の継承された仮想メソッ ドを特殊化します。
抽象 メソッドは、実装のない仮想メソッドです。 抽象メソッドは修飾子を使用して宣言され、 abstract 宣言されているクラ スでのみ許可され abstract ます。抽象メソッドは、すべての非抽象派生クラスでオーバーライドする必要があります。
次の例では、式ツリー ノードを表す抽象クラス 、および定数、変数参照、算術演算の式ツリー ノードを実装する 3 つの派生クラス Constant 、 、 を宣言します (これはと似ていますが、 式ツリー型で導入さ れた式ツリー型と混同することはありません)。
   Expression
   VariableReference
Operation
   前述の 4 つのクラスは、算術式をモデル化するために使用できます。 たとえば、これらのクラスのインスタンスを使用して、式 x + 3 を次のように表すことができます。
  using System;
using System.Collections;
public abstract class Expression {
public abstract double Evaluate(Hashtable vars); }
public class Constant: Expression {
double value;
public Constant(double value) { this.value = value;
}
public override double Evaluate(Hashtable vars) { return value;
} }
public class VariableReference: Expression {
string name;
public VariableReference(string name) { this.name = name;
}
public override double Evaluate(Hashtable vars) { object value = vars[name];
if (value == null) {
throw new Exception("Unknown variable: " + name); }
return Convert.ToDouble(value); }
}
public class Operation: Expression {
Expression left; char op; Expression right;
public Operation(Expression left, char op, Expression right) { this.left = left;
this.op = op;
this.right = right;
}
public override double Evaluate(Hashtable vars) { double x = left.Evaluate(vars);
double y = right.Evaluate(vars);
switch (op) {
}
case '+': case '-': case '*': case '/':
return x + y; return x - y; return x * y; return x / y;
throw new Exception("Unknown operator"); }
}

    Expression インスタンスの Evaluate メソッドが呼び出され、指定された式を評価して double 値を生成します。メソッド は、(エントリの キーとしての)変数名と値(エントリの値)を格納する引数としてを受け取ります。 Evaluateメソッド は仮想抽象メソッドです。つまり、抽象でない派生クラスは、実際の実装を提供するためにオーバーライドする必要があります。
Evaluate の Constant の実装は、格納された定数を単に返します。 の実装は、ハッシュテーブル内の 変数名を検索し、結果の値を返します。 Operation の実装は、( メソッドを再帰的に呼び出すことによって)まず 左と右のオペランドを評価し、指定された算術演算を実行します。
次のプログラムでは、 Expression クラスを使用して、式 x * (y + 2) の異なる値の x と y を評価します。
  Hashtable
    Evaluate
VariableReference
    メソッドのオーバーロード
メソッド *オーバーロード _ では、一意のシグネチャを持つ限り、同じクラスの複数のメソッドが同じ名前を持つことができます。 オーバーロードされたメソッドの呼び出しをコンパイルするときに、コンパイラは _ オーバーロード解決* を使用して、呼び出す特 定のメソッドを決定します。 オーバーロードの解決では、引数に最も一致する 1 つのメソッドが特定されます。最も一致するメ ソッドが見つからない場合は、エラーが報告されます。次の例は、オーバーロードの解決が有効な場合を示しています。 Main メソッド内の各呼び出しのコメントは、実際に呼び出されるメソッドを示しています。
   Expression e = new Operation( new VariableReference("x"), '+',
new Constant(3));
    using System;
using System.Collections;
class Test {
static void Main() {
Expression e = new Operation(
new VariableReference("x"), '*',
new Operation(
new VariableReference("y"), '+',
new Constant(2)
) );
Hashtable vars = new Hashtable(); vars["x"] = 3;
vars["y"] = 5; Console.WriteLine(e.Evaluate(vars)); vars["x"] = 1.5;
vars["y"] = 9; Console.WriteLine(e.Evaluate(vars));
// Outputs "21"
// Outputs "16.5"
} }
 
  この例に示すように、パラメーターの厳密な型に引数を明示的にキャストするか、または型引数を明示的に指定することによ り、特定のメソッドを常に選択できます。
その他の関数メンバー
実行可能コードが含まれるメンバーは、クラスの "関数メンバー" と総称されます。 前のセクションでは、関数メンバーの主な種 類であるメソッドについて説明しました。 このセクションでは、C# でサポートされている他の種類の関数メンバー (コンストラク ター、プロパティ、インデクサー、イベント、演算子、およびデストラクター) について説明します。
次のコードは List<T> 、オブジェクトのgrowableリストを実装するという名前のジェネリッククラスを示しています。このクラスに は、最も一般的な種類の関数メンバーの例がいくつか含まれています。
    class Test {
static void F() { Console.WriteLine("F()");
}
static void F(object x) { Console.WriteLine("F(object)");
}
static void F(int x) { Console.WriteLine("F(int)");
}
static void F(double x) { Console.WriteLine("F(double)");
}
static void F<T>(T x) { Console.WriteLine("F<T>(T)");
}
static void F(double x, double y) { Console.WriteLine("F(double, double)");
} }
}
static void Main() { F();
// Invokes F()
// Invokes F(int)
// Invokes F(double) // Invokes F(object) // Invokes F(double) // Invokes F(object) // Invokes F<T>(T) // Invokes F(double,
F(1);
F(1.0); F("abc"); F((double)1); F((object)1); F<int>(1); F(1, 1);
double)
 
   コンストラクター
C# は、インスタンス コンストラクターと静的コンストラクターの両方をサポートします。 *インスタンスコンストラクター _ は、クラス のインスタンスを初期化するために必要なアクションを実装するメンバーです。 _ 静的コンストラクター* は、最初に読み込まれた
   public class List<T> { // Constant...
const int defaultCapacity = 4;
// Fields... T[] items; int count;
// Constructors...
public List(int capacity = defaultCapacity) {
items = new T[capacity]; }
// Properties... public int Count {
get { return count; } }
public int Capacity { get {
return items.Length; }
set {
if (value < count) value = count; if (value != items.Length) {
} }
}
T[] newItems = new T[value]; Array.Copy(items, 0, newItems, 0, count); items = newItems;
// Indexer...
public T this[int index] {
get {
return items[index];
}
set {
items[index] = value;
OnChanged(); }
}
// Methods...
public void Add(T item) {
if (count == Capacity) Capacity = count * 2; items[count] = item;
count++;
OnChanged();
}
protected virtual void OnChanged() {
if (Changed != null) Changed(this, EventArgs.Empty); }
public override bool Equals(object other) { return Equals(this, other as List<T>);
}
static bool Equals(List<T> a, List<T> b) {
if (a == null) return b == null;
if (b == null || a.count != b.count) return false; for (int i = 0; i < a.count; i++) {
if (!object.Equals(a.items[i], b.items[i])) { return false;
} }
return true; }
// Event...
public event EventHandler Changed;
// Operators...
public static bool operator ==(List<T> a, List<T> b) {
return Equals(a, b); }
public static bool operator !=(List<T> a, List<T> b) { return !Equals(a, b);
} }

 ときにクラス自体を初期化するために必要なアクションを実装するメンバーです。
コンストラクターは、戻り値の型がなく、含んでいるクラスと同じ名前を持つメソッドのように宣言されます。 コンストラクターの宣言 に static 修飾子が含まれている場合は、静的コンストラクターが宣言されます。それ以外の場合は、インスタンスコンストラ クターが宣言されます。
インスタンスコンストラクターはオーバーロードできます。たとえば、List<T> クラスは、2つの(1つはパラメーターなし、もう1つ は int パラメーターを受け取る)インスタンスコンストラクターを宣言します。インスタンスコンストラクターは、new 演算子を使 用して呼び出されます。次のステートメントは、 List<string> クラスの各コンストラクターを使用して2つのインスタンスを割り 当て List ます。
他のメンバーとは異なり、インスタンス コンストラクターは継承されず、クラスには、そのクラスで実際に宣言された以外のインスタ ンス コンストラクターがありません。 クラスのインスタンス コンストラクターが指定されていない場合は、パラメーターなしの空のコン ストラクターが自動的に指定されます。
プロパティ
*プロパティ _ は、フィールドの自然な拡張です。 フィールドとプロパティはどちらも型が関連付けられている名前付きのメンバー であり、それらにアクセスするための構文は同じです。 ただし、フィールドとは異なり、プロパティは格納場所を表しません。 プロパ ティには、その値が読み取られたとき、または書き込まれたときに実行されるステートメントを指定する _ アクセサー* があります。
プロパティはフィールドのように宣言されますが、宣言は、 get set { セミコロンで終わるのではなく、区切り記号との間に記 述されたアクセサーまたはアクセサーで終了する点が異なり } ます。アクセサーとアクセサーの両方を持つプロパティ get
set は、読み取り/書き込みプロパティ _、アクセサーだけを持つプロパティは読み取り専用 get _プロパティ*、アクセサーだ けを持つプロパティは、 set _*書き込み専用のプロパティ**ですが、プロパティは**です。
アクセサーは、 get プロパティの型の戻り値を持つパラメーターなしのメソッドに対応します。代入の対象として、プロパティが式 で参照されている場合は、プロパティの get アクセサーが呼び出され、プロパティの値が計算されます。
アクセサーは、 set という名前の1つのパラメーターを持ち、戻り値の型を持たないメソッドに対応し value ます。プロパティが 代入のターゲットとして、またはまたはのオペランドとして参照されている場合、 ++ -- set アクセサーは新しい値を提供す る引数を使用して呼び出されます。
List<T> クラスは2つのプロパティ(Count と Capacity)を宣言します。これらは、それぞれ読み取り専用プロパティと読み取 り/書き込みプロパティです。 これらのプロパティの使用例を次に示します。
フィールドおよびメソッドと同様に、C# はインスタンス プロパティと静的プロパティの両方をサポートします。 静的プロパティは修飾 子を使用して宣言され、 static インスタンスプロパティは使用されずに宣言されます。
プロパティのアクセサーは仮想にすることができます。 プロパティの宣言に virtual 、 abstract 、または override の各修飾 子が含まれている場合、その宣言はプロパティのアクセサーに適用されます。
インデクサー
"インデクサー" は、配列と同じ方法でオブジェクトのインデックスを作成できるようにするメンバーです。 インデクサーはプロパティ のように宣言されますが、メンバーの名前が、 this の後に区切り記号 [ と ] でパラメーター リストを囲んだものになる点が 異なります。 パラメーターは、インデクサーのアクセサーで使用できます。 プロパティと同様に、読み取り/書き込み、読み取り専 用、および書き込み専用のインデクサーを使用できます。また、インデクサーのアクセサーを仮想にすることができます。
List クラスは、int パラメーターを受け取る1つの読み取り/書き込みインデクサーを宣言します。インデクサーを使用する と、 int 値を持つ List インスタンスのインデックスを作成できます。 次に例を示します。
インデクサーはオーバーロードできます。つまり、パラメーターの数または型が異なる限り、クラスは複数のインデクサーを宣言でき ます。
           List<string> list1 = new List<string>(); List<string> list2 = new List<string>(10);
    List<string> names = new List<string>();
names.Capacity = 100; int i = names.Count; int j = names.Capacity;
// Invokes set accessor // Invokes get accessor // Invokes get accessor
    List<string> names = new List<string>(); names.Add("Liz");
names.Add("Martha");
names.Add("Beth");
for (int i = 0; i < names.Count; i++) { string s = names[i];
names[i] = s.ToUpper();
}
 
 events
"イベント" は、クラスまたはオブジェクトで通知を提供できるようにするメンバーです。 イベントはフィールドのように宣言されます が、 event キーワードが宣言に含まれており、型がデリゲート型でなければならない点が異なります。
イベント メンバーを宣言するクラス内では、イベントはデリゲート型のフィールドと同じように動作します (イベントが抽象イベントで なく、アクセサーを宣言しない場合)。 フィールドは、イベントに追加されたイベント ハンドラーを表すデリゲートへの参照を格納し ます。イベントハンドルが存在しない場合、フィールドは null です。
List<T> クラスは、 という1つのイベントメンバーを宣言します。このメンバーは新しい項目がリストに追加されたこと を示します。 イベントは、 仮想メソッドによって発生し OnChanged ます。このメソッドは、イベントが null (ハンド ラーが存在しないことを意味する) であるかどうかを最初に確認します。 イベントを発生させるという概念は、イベントによって表 されるデリゲートの呼び出しとまったく同じです。したがって、イベントを発生させるための特殊な言語コンストラクトはありません。
クライアントは、"イベントハンドラー"を使用してイベントに対応します。イベントハンドラーは、+= 演算子を使用してアタッ チされ、 -= 演算子を使用して削除されます。 次の例では、 List<string> の Changed イベントにイベント ハンドラーをア タッチします。
      イベントの基になる記憶域の制御が求められる高度なシナリオでは、イベントの宣言で add アクセサーと remove アクセサーを 明示的に指定できます。これらは、プロパティの set アクセサーにある程度似ています。
オペレーター
"演算子" は、クラスのインスタンスに特定の式の演算子を適用する意味を定義するメンバーです。 単項演算子、2 項演算 子、および変換演算子の3種類を定義できます。すべての演算子は public および static として宣言する必要がありま す。
List<T> クラスは 2 つの演算子 ( operator== と operator!= ) を宣言し、 List インスタンスにこれらの演算子を適用する 式に新しい意味を持たせます。 具体的には、 Equals メソッドを使用して含まれている各オブジェクトを比較する際に、演算 子が2つの List<T> インスタンスの等価性を定義します。次の例では、== 演算子を使用して2つの List<int> インスタ ンスを比較します。
       は True を出力します。これは、2つのリストに、同じ値を持つ同じ数のオブジェクトが同じ順序 で が定義されていない場合は、 a と b が異なる List<int> インスタン
は False を出力します。
デストラクター は、クラスのインスタンスを消滅させるために必要なアクションを実装するメンバーです。 デストラクターには、パラ
最初の で含まれているためです。 スを参照するため、最初の
Console.WriteLine
Changed
 Changed
   デストラクター
List<T>
operator==
 Console.WriteLine
   using System;
class Test {
static int changeCount;
static void ListChanged(object sender, EventArgs e) { changeCount++;
}
static void Main() {
List<string> names = new List<string>(); names.Changed += new EventHandler(ListChanged); names.Add("Liz");
names.Add("Martha");
names.Add("Beth"); Console.WriteLine(changeCount);
} }
// Outputs "3"
    using System;
class Test {
static void Main() {
} }
List<int>
a.Add(1);
a.Add(2);
List<int>
b.Add(1);
b.Add(2); Console.WriteLine(a == b); b.Add(3); Console.WriteLine(a == b);
a = new List<int>();
b = new List<int>();
// Outputs "True" // Outputs "False"
 
 メーターを指定できません。また、アクセシビリティ修飾子は使用できず、明示的に呼び出すこともできません。 インスタンスのデ ストラクターは、ガベージコレクション中に自動的に呼び出されます。
ガベージコレクターでは、オブジェクトを収集してデストラクターを実行するタイミングを、ワイド緯度で決定できます。 具体的に は、デストラクター呼び出しのタイミングは決定的ではなく、デストラクターは任意のスレッドで実行できます。 これらの理由によ り、他のソリューションが実現できない場合にのみ、クラスはデストラクターを実装する必要があります。
using ステートメントは、オブジェクトを破棄するためのより適切な方法を提供します。 構造体
構造体 は、クラスと同様に、データ メンバーおよび関数メンバーを含むことができるデータ構造ですが、値型でありヒープ割り当 てを必要としない点でクラスと異なります。 構造体型の変数は、構造体のデータを直接格納しますが、クラス型の変数は、動 的に割り当てられたオブジェクトへの参照を格納します。 構造体型はユーザー指定の継承をサポートせず、すべての構造体型 は暗黙的に object 型を継承します。
構造体は、値セマンティクスを持つ小規模なデータ構造に特に便利です。 構造体の主な例としては、複素数、座標系のポイ ント、ディクショナリのキーと値のペアなどがあります。 小規模なデータ構造には、クラスよりむしろ構造体を使用するほうが、アプ リケーションが実行するメモリ割り当ての数を大幅に減らすことができます。 たとえば、次のプログラムでは、100 個のポイントの 配列を作成し初期化します。 Point をクラスとして実装すると、101個の別々のオブジェクトがインスタンス化されます。配列 に1 個、残りは 100 個の要素に 1 個ずつです。
 別の方法と Point して、構造体を作成することもできます。
ここでは1つのオブジェクトのみがインスタンス化されます。すなわち、配列に1個です。そして、Point インスタンスがその配列 内にインラインで格納されます。
構造体コンストラクターは new 演算子を使って呼び出されますが、メモリが割り当てられていることを意味するものではありませ ん。 オブジェクトを動的に割り当てそこへの参照を返す代わりに、構造体コンストラクターは単に構造体の値自体 (通常、スタッ ク上の一時的な場所) を返し、この値は必要に応じてコピーされます。
クラスを使用すると、2 つの変数が同じオブジェクトを参照できるため、1 つの変数に対する操作によって、もう一方の変数によっ て参照されるオブジェクトに影響を与えることができます。 構造体を使用すると、各々の変数がデータのコピーを各々で持ち、1 つに対する操作がもう一方に影響を与えることはできません。 たとえば、次のコードフラグメントによって生成される出力は、がク ラスであるか構造体であるかによって異なり Point ます。
がクラスである場合 Point 、とは 20 a 同じオブジェクトを参照するため、出力はになり b ます。 Point が構造体の場 合、出力はになり 10 a ます。への代入に b よって値のコピーが作成され、このコピーはへの後続の代入の影響を受け
     class Point {
public int x, y;
public Point(int x, int y) { this.x = x;
this.y = y; }
}
class Test {
static void Main() {
Point[] points = new Point[100];
for (int i = 0; i < 100; i++) points[i] = new Point(i, i);
} }
    struct Point {
public int x, y;
public Point(int x, int y) { this.x = x;
this.y = y; }
}
    Point a = new Point(10, 10); Point b = a;
a.x = 20; Console.WriteLine(b.x);
 
 a.x ません。
前述の例では、構造体の 2 つの制限事項が強調されています。 1 つめは、構造体全体をコピーすることは通常、オブジェクト 参照をコピーするよりも非効率であり、割り当てと値パラメーターの引き渡しは参照型よりも構造体のほうが手がかかるということ です。 2 つめは、 ref および out パラメーターを除いて、構造体への参照を作成することはできず、そのために構造体を使 用できない状況が数多くあるということです。
配列
*配列 _ は、計算されたインデックスを通じてアクセスされる多数の変数を含むデータ構造です。 配列に含まれる変数は、配列
の *要素* とも呼ばれ、すべて同じ型であり、この型は配列の _ 要素型* と呼ばれます。
配列型は参照型で、配列変数の宣言は、配列インスタンスへの参照の領域を確保します。 実際の配列インスタンスは、実 行時に演算子を使用して動的に作成され new ます。 new 操作によって、新しい配列インスタンスの長さが指定され、それ はインスタンスの有効期間中は固定です。 配列の要素のインデックスは、 0 から Length - 1 までです。 new 演算子は配 列の要素を自動的に既定値に初期化します。たとえば、すべての数値型はゼロ、すべての参照型は null です。
次の例では、 int 要素の配列を作成し、その配列を初期化し、配列の内容を出力します。
  この例では、*1 次元配列 _ を作成して操作します。 C# では、"*多次元配列*_" もサポートされます。 配列型の次元数 は、配列型の _ ランク* とも呼ばれ、配列型の角かっこの間に記述されたコンマの数に1を加えたものです。 次の例では、1次 元、2次元、および3次元配列を割り当てます。
a1 配列は 10の要素、 a2 配列は 50(10×5)の要素、 a3 配列は 100(10×5×2)の要素を含みます。 配列の要素型には、配列型を含む任意の型を指定できます。 配列型の要素を持つ配列は、ジャグ配列 と呼ばれることがあ
ります。要素の配列の長さがすべて同じである必要がないからです。 次の例では、 int の配列の配列を割り当てます。
最初の行で3つの要素を持つ配列を作成しますが、各々は int[] 型で null 初期値を持ちます。それ以降の行では、3 つの要素を、それぞれ異なる長さの配列インスタンスへの参照で初期化します。
new 演算子では、配列要素の初期値を、区切り記号 { および } のあいだに記述された式の一覧である配列初期化 子を使用して指定することができます。次の例は、int[] を割り当て3つの要素で初期化します。
配列の長さは、との間の式の数から推論されることに注意して { } ください。 ローカル変数およびフィールド宣言をさらに短 縮して、配列型を再起動する必要がないようにできます。
    前述の例はどちらも、次の例と同等です。
   using System;
class Test {
static void Main() {
int[] a = new int[10];
for (int i = 0; i < a.Length; i++) {
a[i] = i * i; }
for (int i = 0; i < a.Length; i++) { Console.WriteLine("a[{0}] = {1}", i, a[i]);
} }
}
    int[] a1 = new int[10];
int[,] a2 = new int[10, 5]; int[,,] a3 = new int[10, 5, 2];
    int[][] a = new int[3][]; a[0] = new int[10];
a[1] = new int[5];
a[2] = new int[20];
  int[] a = new int[] {1, 2, 3};
  int[] a = {1, 2, 3};
 
  インターフェイス
"インターフェイス" は、クラスと構造体によって実装できるコントラクトを定義します。 1 つのインターフェイスには、メソッド、プロ パティ、イベント、およびインデクサーが含まれる場合があります。 インターフェイスでは、定義するメンバーの実装は行いません。 インターフェイスを実装するクラスまたは構造体によって提供される必要があるメンバーを指定するだけです。
インターフェイスは 多重継承 を使用する場合があります。 次の例では、インターフェイス IComboBox は ITextBox と IListBox の両方から継承します。
       クラスと構造体は、複数のインターフェイスを実装できます。 次の例では、クラス EditBox は IControl と IDataBound の両 方を実装しています。
 クラスまたは構造体が特定のインターフェイスを実装する場合、そのクラスまたは構造体のインスタンスはそのインターフェイス型 に暗黙的に変換できます。 次に例を示します。
インスタンスが特定のインターフェイスを静的に実装しないとわかっている場合は、動的な型キャストを使用できます。 たとえば、 次のステートメントは動的な型キャストを使用して、オブジェクト IControl とインターフェイスの実装を取得 IDataBound しま す。オブジェクトの実際の型はであるため、 EditBox キャストは成功します。
前のクラスでは、インターフェイスからの EditBox Paint メソッドとインターフェイスからのメソッドが、 IControl Bind IDataBound メンバーを使用して実装されてい public ます。C#では、明示的なインターフェイスメンバーの実装もサ ポートしています。これを使用すると、クラスまたは構造体がメンバーを作成するのを回避でき public ます。明示的なイン
ターフェイス メンバーの実装は、完全修飾のインターフェイス メンバー名を使用して書き込まれます。 たとえば、 クラス は、次のように明示的なインターフェイス メンバーの実装を使用して、 IControl.Paint メソッドおよび メ ソッドを実装できます。
         EditBox
  IDataBound.Bind
   int[] t = new int[3]; t[0] = 1;
t[1] = 2;
t[2] = 3;
int[] a = t;
    interface IControl {
void Paint(); }
interface ITextBox: IControl {
void SetText(string text); }
interface IListBox: IControl {
void SetItems(string[] items); }
interface IComboBox: ITextBox, IListBox {}
    interface IDataBound {
void Bind(Binder b); }
public class EditBox: IControl, IDataBound {
public void Paint() {...}
public void Bind(Binder b) {...} }
    EditBox editBox = new EditBox(); IControl control = editBox; IDataBound dataBound = editBox;
    object obj = new EditBox();
IControl control = (IControl)obj; IDataBound dataBound = (IDataBound)obj;
 
   明示的なインターフェイスメンバーは、インターフェイス型を経由してのみアクセスできます。たとえば、 IControl.Paint 前のク ラスによって提供されるの実装は、 EditBox 最初に参照を EditBox インターフェイス型に変換することによってのみ呼び出す ことができ IControl ます。
列挙型
列挙型 は、一連の名前付き定数を使用する固有の値の型です。 次の例では、、、 Color およびという3つの定数値を持つ
という名前の列挙型を宣言して使用し Red Green Blue ます。
     各列挙型には、列挙型の 基になる型 と呼ばれる対応する整数型があります。 基になる型を明示的に宣言しない列挙型に は、の基になる型があり int ます。列挙型のストレージ形式と使用可能な値の範囲は、基になる型によって決まります。列 挙型が受け取ることができる値のセットは、列挙型のメンバーによって制限されません。 特に、列挙型の基になる型の任意の 値を列挙型にキャストし、その列挙型の個別の有効な値にすることができます。
次の例では、基になる型を持つという名前の列挙型を宣言 Alignment sbyte しています。
前の例で示したように、列挙型メンバーの宣言には、メンバーの値を指定する定数式を含めることができます。 各列挙型メン バーの定数値は、列挙型の基になる型の範囲内である必要があります。 列挙メンバー宣言によって値が明示的に指定されて いない場合、メンバーには値 0 (列挙型の最初のメンバーの場合)、またはテキスト形式の前の列挙型メンバーの値に1を加え
     public class EditBox: IControl, IDataBound {
void IControl.Paint() {...}
void IDataBound.Bind(Binder b) {...} }
    EditBox editBox = new EditBox();
editBox.Paint(); // Error, no such method IControl control = editBox;
control.Paint(); // Ok
    using System;
enum Color {
Red, Green, Blue
}
class Test {
static void PrintColor(Color color) { switch (color) {
} }
case Color.Red: Console.WriteLine("Red"); break;
case Color.Green: Console.WriteLine("Green"); break;
case Color.Blue: Console.WriteLine("Blue"); break;
default:
Console.WriteLine("Unknown color"); break;
static void Main() {
Color c = Color.Red; PrintColor(c); PrintColor(Color.Blue);
} }
    enum Alignment: sbyte {
Left = -1, Center = 0, Right = 1
}
 
 た値が与えられます。 列挙値は、型キャストを使用して、整数値に変換できます。 次に例を示します。
任意の列挙型の既定値は、列挙型に変換された整数値0です。 変数が既定値に自動的に初期化される場合、これは列挙 型の変数に指定された値になります。列挙型の既定値を簡単に使用できるようにするために、リテラルは 0 暗黙的に任意 の列挙型に変換されます。 したがって、次の例も許可されます。
代理人
"デリゲート型" は、特定のパラメーター リストおよび戻り値を使用してメソッドへの参照を表します。 デリゲートを使用すれば、 変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。 デリゲートはまた、他のいくつか の言語にみられる関数ポインターの概念に似ていますが、関数ポインターとは異なり、デリゲートはオブジェクト指向でタイプ セー フです。
次の例では、 Function という名前のデリゲート型を宣言して使用します。
     Function デリゲート型のインスタンスは、 double 引数を取得して double 値を返す任意のメソッドを参照できます。
Apply メソッドは、指定された Function を double[] の要素に適用し、 double[] を結果とともに返します。 Main メソッ ドでは、Apply は に3つの異なる関数を適用するために使用されます。
デリゲートは、静的メソッド(前述の例の Square や Math.Sin など)またはインスタンスメソッド(前述の例の m.Multiply な ど) のいずれかを参照できます。 インスタンス メソッドを参照するデリゲートはまた、特定のオブジェクトを参照し、インスタンス メ ソッドがデリゲートから呼び出されると、そのオブジェクトは呼び出しで this になります。
その場で作成される「インライン メソッド」である匿名関数を使用してデリゲートを作成することもできます。 匿名関数では、周 囲のメソッドのローカル変数を確認できます。 このため、上記の乗数の例は、クラスを使用せずにより簡単に記述でき
       Multiplier ます。
double[]
 int i = (int)Color.Blue; // int i = 2;
Color c = (Color)2; // Color c = Color.Blue;
  Color c = 0;
    using System;
delegate double Function(double x);
class Multiplier {
double factor;
public Multiplier(double factor) { this.factor = factor;
}
public double Multiply(double x) { return x * factor;
} }
class Test {
static double Square(double x) { return x * x;
}
static double[] Apply(double[] a, Function f) {
double[] result = new double[a.Length];
for (int i = 0; i < a.Length; i++) result[i] = f(a[i]); return result;
}
static void Main() {
double[] a = {0.0, 0.5, 1.0};
double[] squares = Apply(a, Square); double[] sines = Apply(a, Math.Sin); Multiplier m = new Multiplier(2.0); double[] doubles = Apply(a, m.Multiply);
} }
 
  デリゲートの興味深く有用な点は、参照するメソッドのクラスを把握せず必要ともしないことです。重要なのは、参照されるメソッ ドは同じパラメーターを持ち、デリゲートとして型を返すということです。
属性
C# プログラムにおける型、メンバー、およびその他のエンティティは、動作の特定の側面を制御する修飾子をサポートします。 た とえばメソッドのアクセシビリティは、 public 、 protected 、 internal 、および private 修飾子を使用して制御されます。 C# はこの機能を一般化し、宣言情報のユーザー定義型をプログラム エンティティに追加して実行時に取得できるようにしま す。 プログラムでは、 属性 を定義して使用することによって、この追加の宣言情報を指定します。
次の例では、プログラムのエンティティに配置して関連するドキュメントへのリンクを提供することができる HelpAttribute 属性を 宣言しています。
      すべての属性クラスは System.Attribute 、.NETFrameworkによって提供される基本クラスから派生します。属性は、関連 付けられた宣言の直前に、名前を任意の変数とともに角かっこで囲んで与えることにより、適用できます。 属性の名前がで終 わる場合は、 Attribute 属性が参照されているときに名前のその部分を省略できます。 たとえば、 HelpAttribute 属性は 次のように使用できます。
この例では、をクラスに、別のをクラスの HelpAttribute Widget メソッドにアタッチし ます。 属性 クラスのパブリック コンストラクターは、属性がプログラム エンティティにアタッチされたときに提供する必要がある情報を制御しま す。その属性クラスのパブリックの読み取り/書き込みプロパティを参照することにより(Topic プロパティへの参照のような)、追 加情報を提供することができます。
次の例は、特定のプログラムエンティティの属性情報を、リフレクションを使用して実行時に取得する方法を示しています。
     HelpAttribute
 Display
 double[] doubles = Apply(a, (double x) => x * 2.0);
    using System;
public class HelpAttribute: Attribute {
string url; string topic;
public HelpAttribute(string url) { this.url = url;
}
public string Url {
get { return url; }
}
public string Topic {
get { return topic; } set { topic = value; }
} }
    [Help("http://msdn.microsoft.com/.../MyClass.htm")] public class Widget
{
[Help("http://msdn.microsoft.com/.../MyClass.htm", Topic = "Display")]
public void Display(string text) {} }
 
  リフレクションによって特定の属性が要求されると、プログラム ソースで提供される情報で属性クラスのコンストラクターが呼び出さ れ、結果の属性インスタンスが返されます。 追加情報がプロパティを通じて提供された場合、属性インスタンスが返される前 に、これらのプロパティは指定された値に設定されます。
   using System;
using System.Reflection;
class Test {
static void ShowHelp(MemberInfo member) {
HelpAttribute a = Attribute.GetCustomAttribute(member,
typeof(HelpAttribute)) as HelpAttribute; if (a == null) {
Console.WriteLine("No help for {0}", member); }
else {
Console.WriteLine("Help for {0}:", member); Console.WriteLine(" Url={0}, Topic={1}", a.Url, a.Topic);
} }
static void Main() {
ShowHelp(typeof(Widget)); ShowHelp(typeof(Widget).GetMethod("Display"));
} }
 
     C# のパターン一致拡張機能を使用すると、代数データ型と関数型言語のパターンマッチングの多くの利点が得られますが、基 になる言語のようにスムーズに統合されます。 基本的な機能は、 レコード型です。これは、データの形によって記述される意味 を持つ型です。また、パターンマッチングは、これらのデータ型を大幅に簡潔に分解できる新しい式の形式です。 このアプローチ の要素は、プログラミング言語 F # と スケール aの関連機能によって実現されています。
Is式
is 演算子は、パターンに対して式をテストするために拡張されています。
この形式の relational_expression は、C# 仕様の既存のフォームに追加されています。 トークンの左側の relational_expressionが is 値を指定していないか、型を持たない場合、コンパイル時エラーになります。
パターンのすべての識別子は、演算子の後に確実に代入される新しいローカル変数を導入します is (つまり、trueの場合は 確実に割り当てられます true )。definitelyassignedwhentrue
パターン
パターンは、 is 入力データの比較対象となるデータの構造を表すために、演算子とswitch_statement内で使用されます。 パターンは再帰的であるため、データの一部がサブパターンと照合される可能性があります。
    relational_expression
    : relational_expression 'is' pattern
    ;
    注: と constant_pattern の型の間には技術的にあいまいな点がありますが   、どちらも、修飾された識別 子の有効な解析である可能性があります。 constant_pattern 以前のバージョンの言語との互換性のために、型としてバ インドしようとしています。失敗した場合にのみ、他のコンテキストの場合と同様に、最初に見つかったもの (定数または型 のいずれかである必要があります)に解決されます。このあいまいさは、式の右辺にのみ存在し is ます。
  is-expression
     pattern
    : declaration_pattern
    | constant_pattern
    | var_pattern
    ;
declaration_pattern
    : type simple_designation
    ;
constant_pattern
    : shift_expression
    ;
var_pattern
    : 'var' simple_designation
    ;
   C# 7 のパターンマッチング 2020/11/02 • • Edit Online
   注: と constant_pattern の型の間には技術的にあいまいな点がありますが 、どちらも、修飾された識別 子の有効な解析である可能性があります。 constant_pattern 以前のバージョンの言語との互換性のために、型としてバ
 is-expression
 
  宣言パターン
Declaration_patternは、式が特定の型であるかどうかをテストし、テストが成功した場合はその型にキャストします。 Simple_designationが識別子の場合は、指定された識別子によって指定された型のローカル変数を導入します。 このローカ ル変数は、パターン一致操作の結果が true の場合に 確実に割り当てら れます。
この式のランタイムセマンティックは、パターンの型に対して左辺のrelational_expressionオペランドのランタイム型をテストするこ とです。 そのランタイム型 (または一部のサブタイプ) の場合、の結果はになり is operator true ます。 これは、結果がの場 合に左側のオペランドの値が割り当てられた識別子によって指定された新しいローカル変数を宣言し true ます。
左側の静的な型と指定された型の特定の組み合わせは互換性がないと見なされ、コンパイル時エラーが発生します。 静的な 型の値は、 E idpatterncompatible T 変換、暗黙の参照変換、ボックス化変換、明示的な参照変換、またはからへの
    declaration_pattern
    : type simple_designation
    ;
  アンボックス変換のいずれかが存在する場合、型とのパターン互換性があると言われ 型パターンの型と互換性のあるパターンでない場合、コンパイル時エラーになります。
E T ます。 型の式 E が、照合される
   注:C#7.1では、入力型または型 T がオープン型である場合に、パターンマッチング操作を許可するようにこれを拡張し ます。 この段落は、次のように置き換えられます。
左側の静的な型と指定された型の特定の組み合わせは互換性がないと見なされ、コンパイル時エラーが発生します。 静 的型の値は、 E patterncompatible T id変換、暗黙の参照変換、ボックス変換、明示的な参照変換、またはから へのボックス化変換、または E T ** E T がオープン型**である場合は、型とのパターン互換性があると言われます。 型の式 E が、照合される型パターンの型と互換性のあるパターンでない場合、コンパイル時エラーになります。
 宣言パターンは、参照型のランタイム型テストを実行する場合に便利です。
少し簡潔に
型が null 許容値型の場合、エラーになります。
宣言パターンは、null 許容型の値をテストするために使用できます。 Nullable<T>
がである場合 T 、またはの基本型またはインターフェイス T の場合は、型の値(またはボックス化された)が型パターンと一致 します。 たとえば、コード片で
ステートメントの条件 if は true 実行時で、変数は v ブロック内の型の値を保持し 3 int ます。 定数パターン
    var v = expr as Type;
if (v != null) { // code using v }
   if (expr is Type v) { // code using v }
  T T2 id 値が null 以外で、の型 T2
    int? x = 3;
if (x is int v) { // code using v }
   インドしようとしています。失敗した場合にのみ、他のコンテキストの場合と同様に、最初に見つかったもの (定数または型 のいずれかである必要があります)に解決されます。このあいまいさは、式の右辺にのみ存在し is ます。
 
  定数パターンは、定数値に対して式の値をテストします。 定数には、リテラル、宣言された変数の名前、列挙定数、式など、 任意の定数式を指定でき const typeof ます。
Eとcの両方が整数型の場合、式の結果がの場合、パターンは一致したと見なされ e == c true ます。 それ以外の場合は、がを返す場合、パターンは一致と見なされ object.Equals(e, c) true ます。 この場合、 e の静的な
型が定数の型と互換性のある パターン でない場合、コンパイル時エラーになります。 Var パターン
式 e は常に var_pattern と一致します。 言い換えると、 var パターン との一致は常に成功します。 Simple_designationが 識別子の場合は、実行時にeの値が新しく導入されたローカル変数にバインドされます。 ローカル変数の型は、 eの静的な型 です。
名前が型にバインドされている場合、エラーになり var ます。 Switch ステートメント
ステートメントは、 switch switch式と一致するパターンが関連付けられている最初のブロックを実行するために拡張されてい ます。
       var_pattern
    : 'var' simple_designation
    ;
      switch_label
    : 'case' complex_pattern case_guard? ':'
    | 'case' constant_expression case_guard? ':'
    | 'default' ':'
    ;
case_guard
    : 'when' expression
    ;
 パターンが一致する順序は定義されていません。 コンパイラは、パターンを順序どおりに一致させ、既に一致したパターンの結 果を再利用して、他のパターンとの照合結果を計算することができます。
Caseガードが存在する場合、その式は型に bool なります。これは、満たされた場合に満たす必要がある追加の条件として 評価されます。
Switch_labelが実行時に影響を与えない場合、これはエラーになります。これは、そのパターンが前のケースで包括されている ためです。 [TODO: この判断に至るためにコンパイラが使用する必要がある手法について、より正確に指定する必要がありま す。]
Switch_labelで宣言されたパターン変数は、その case ブロックに1つのswitch_labelが含まれている場合にのみ、その case ブ ロックで確実に割り当てられます。
[TODO: スイッチブロック に到達できる場合は、を指定する必要があります。] パターン変数のスコープ
パターンで宣言された変数のスコープは次のとおりです。
パターンが case ラベルの場合、変数のスコープは case ブロックになります。
   constant_pattern
    : shift_expression
    ;
 
  それ以外の場合、変数は is_pattern 式で宣言され、そのスコープは、次のように is_pattern 式を含む式をすぐに囲むコンスト ラクトに基づいています。
式が式形式のラムダ内にある場合、そのスコープはラムダの本体です。 式が式形式のメソッドまたはプロパティに含まれている場合、そのスコープはメソッドまたはプロパティの本体です。 式が句の句に含まれている場合 when catch 、そのスコープはその catch 句です。
式が iteration_statement内にある場合、そのスコープはそのステートメントにすぎません。 それ以外の場合、式が他のステートメント形式に含まれていると、そのスコープがステートメントを含むスコープになります。
スコープを決定するために、 embedded_statement は独自のスコープ内にあると見なされます。 たとえば、 if_statement の 文法は次のようになります。
したがって、 if_statement の制御されたステートメントがパターン変数を宣言している場合、そのスコープはその embedded_statementに制限されます。
この場合、のスコープ z は埋め込みステートメント M(y is var z); です。
その他の理由 (たとえば、パラメーターの既定値や属性など) でエラーが発生した場合は、これらのコンテキストには定数式が必
要であるため、どちらもエラーになります。
    if_statement
    : 'if' '(' boolean_expression ')' embedded_statement
    | 'if' '(' boolean_expression ')' embedded_statement 'else' embedded_statement
    ;
   if (x) M(y is var z);
     C# 7.3 では、 pattern 変数が宣言される次のコンテキストを追加しました。
式が コンストラクター初期化子内にある場合、そのスコープは コンストラクター初期化子 とコンストラクターの本体になり ます。
式がフィールド初期化子に含まれている場合、そのスコープは、その式が表示される equals_value_clause になりま す。
ラムダの本体に変換するように指定されているクエリ句に式が含まれている場合、その式のスコープはその式にすぎませ ん。
 構文のあいまいさを解消するための変更
ジェネリックには、C# 文法があいまいであるという点があります。言語仕様では、あいまいさを解決する方法が示されています。
   7.6.5.2 文法のあいまい性
単純名(7.6.3) とメンバーアクセス(7.6.5 を参照) の生産によって、式の文法があいまいになる可能性があります。 たとえ ば、ステートメントは次のようになります。
は F 、2つの引数 (と) を持つの呼び出しとして解釈される可能性があり G < A B > (7) ます。 または、1つの引数を 使用したの呼び出しとして解釈することもでき F ます。これは、 G 2つの型引数と1つの標準引数を持つジェネリックメ ソッドの呼び出しです。
  F(G<A,B>(7));
      トークンのシーケンスを 単純な名前 (7.6.3)、 メンバーアクセス (§ 7.6.5)、または ポインターメンバーアクセス (§ 18.5.2) で終 わり (4.4.1 を参照) として解析できる場合は、終了トークンの直後にあるトークンが調べられます ( 「 」を参照) > 。 のい

    C# 7 では、言語の複雑さに対処するためにこれらのあいまいさを解消するための十分な変更がいくつか追加されています。 out 変数宣言
Out 引数で変数を宣言できるようになりました。
ただし、型はジェネリックである場合があります。
引数の言語文法では 式が使用されるため、このコンテキストにはあいまいさの排除規則が適用されます。 この場合、閉じの > 後に識別子が続きます。この識別子は、型引数リストとして扱うことを許可するトークンの1つではありません。そのため、
あいまいさを解消するトークンのセットに識別子を追加すること*type-argument-list* を提案します。
タプルと分解宣言
組リテラルは、まったく同じ問題に実行されます。 タプル式を考えます。
  M(out Type name);
   M(out A<B> name);
 ずれかである場合
  (  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
 その後、 型引数リスト は、 単純名、 メンバーアクセス 、または ポインターメンバーアクセス の一部として保持され、トークン のシーケンスのその他の可能な解析はすべて破棄されます。 それ以外の場合、トークンのシーケンスを解析できない場合 でも、 型引数リスト は、 単純名、 メンバーアクセス 、または > ポインターメンバーアクセスの一部とは見なされません。 名 前空間または型名で型引数リストを解析する場合、これらの規則は適用されないことに注意してください (3.8 を参照)。 次のステートメント、
は、この規則に従って、1つの引数を使用したの呼び出しとして解釈されます。これは、2つの F G 型引数と1つの標準 引数を持つジェネリックメソッドの呼び出しです。 ステートメント
は、 F 2つの引数を持つの呼び出しとして解釈されます。次のステートメント、
は、ステートメントが記述されているかのように、小なり演算子、大なり演算子、および単項プラス演算子として解釈され
x = (F < A) > (+y) ます。 type-argument-listただし、その後に二項プラス演算子が続く単純な名前ではありません。
ステートメント内
トークン C<T> は、型引数リストを持つ名前空間または型名として解釈されます。
  F(G<A,B>(7));
     F(G < A, B > 7);
F(G < A, B >> 7);
   x = F < A > +y;
    x = y is C<T> + z;
 
   (A < B, C > D, E < F, G > H)
 以前の C# 6 規則で引数リストを解析する場合は、が最初のから始まる4つの要素を持つタプルとして解析され A < B ます。 ただし、分解の左側にこれが表示される場合は、前述のように、 識別子 トークンによってトリガーされるあいまいさを解消する 必要があります。
これは、2つの変数を宣言する分解宣言です。最初の変数は型で、は A<B,C> という名前 D です。言い換えると、組リテラ ルには2つの式が含まれ、それぞれが宣言式です。
仕様とコンパイラを簡単にするために、このタプルリテラルを (代入式の左側に表示するかどうかにかかわらず) 任意の場所に2要 素のタプルとして解析することを提案します。 これは、前のセクションで説明した非不明瞭の自然な結果になります。
パターンマッチング
パターンマッチングでは、式型のあいまいさが発生する新しいコンテキストが導入されます。以前は、演算子の右辺は is 型で した。 これで、型または式にすることができます。型である場合は、識別子の後に指定できます。 これにより、技術的には既存 のコードの意味を変更できます。
これは、次のように C# 6 規則で解析できます。
ただし、C# 7 の規則 (上記のあいまいさを排除したもの) は、として解析されます。
型の変数を宣言する B T<A> 。 さいわい、ネイティブコンパイラと Roslyn コンパイラには、C# 6 コードに構文エラーが発生す るというバグがあります。 そのため、このような重大な変更は考慮されません。
パターンマッチングでは、型の選択に向けたあいまいさの解決を推進する必要がある追加のトークンが導入されます。 次の例で は、既存の有効な C# 6 コードは、その他のあいまいさを排除する規則なしに分割されます。
排除規則に対する変更の提案 明確化トークンの一覧を変更するように仕様を修正することを提案します。
to
  (A<B,C> D, E<F,G> H) = e;
    var x = e is T < A > B;
   var x = ((e is T) < A) > B;
   var x = e is T<A> B;
     var x = e is A<B> && f;
var x = e is A<B> || f;
var x = e is A<B> & f;
var x = e is A<B>[];
// &&
// ||
// &
// [
   (  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
   (  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^  &&  ||  &  [
 
 また、特定のコンテキストでは、 識別子 を明確化トークンとして扱います。 これらのコンテキストは、明確されるトークンのシーケ ンスが、キーワード、、またはのいずれかの直前にあるか、または is case out タプルリテラルの最初の要素を解析するとき
に発生します (この場合、トークンの前にまたはが付いていて、識別子の後にが続く)、または 要素。
変更されたあいまいさの排除ルール 修正されていないあいまいさの規則は次のようになります。
( : ,
タプルリテラルの後続の
   トークンのシーケンスを、 単純な名前 (7.6.3)、 メンバーアクセス (§ 7.6.5)、または ポインターメンバーアクセス (§ 18.5.2) と して、型引数リスト(4.4.1を参照)として解析できる場合は、最後のトークンの直後にあるトークンが検査され、実行 > されているかどうかが確認されます。
のいずれか 。または 関係演算子の1つ 。または クエリ式の内部に表示されるコンテキストクエリキーワードもしくは
特定のコンテキストでは、 識別子 を明確化トークンとして扱います。 これらのコンテキストは、明確されているトークンの シーケンスの前に、またはのいずれかのキーワードが直前にあるか is case 、また out はタプルリテラルの最初の要 素を解析するときに発生します (この場合は、トークンの前にまたはが付いていて、識別子の後にが続き ( : , ま す)。
次のトークンがこのリストまたはこのようなコンテキストの識別子の中にある場合、 型引数リスト は 単純名、 メンバーアクセ ス 、または ポインターメンバーアクセス の一部として保持され、その他のトークンシーケンスの解析はすべて破棄されます。 それ以外の場合、トークンのシーケンスを解析できない場合でも、 型引数リスト は、 単純名、 メンバーアクセス 、または ポインターメンバーアクセスの一部とは見なされません。 名前空間または型名で型引数リストを解析する場合、これらの規 則は適用されないことに注意してください (3.8 を参照)。
 ( ) ] } : ; , . ? == != | ^ && || & [
 < > <= >= is as
 この提案による重大な変更 この修正候補の規則により、互換性に影響する変更は認識されません。
興味深い例 これらの非不明瞭な規則の興味深い結果を次に示します。
式は (A < B, C > D) 2 つの要素を持つタプルで、それぞれが比較されます。
式は (A<B,C> D, E) 2 つの要素を持つタプルで、最初の要素は宣言式です。 この呼び出しに M(A < B, C > D, E) は3つの引数があります。
呼び出しに M(out A<B,C> D, E) は2つの引数があり、最初の引数は out 宣言です。 この式では、 e is A<B> C 宣言式が使用されます。
Caseラベルでは、 case A<B> C: 宣言式が使用されます。 パターンマッチングの例
は 表現を置き換えることができます。
          var v = expr as Type;
if (v != null) {
    // code using v
}
 少し簡潔で、直接

  テスト (null 許容) 表現を置き換えることができます。
少し簡潔で、直接
算術単純化
(別の提案に従って) 式を表す一連の再帰型を定義するとします。
これで、式の (縮小されていない) 派生を計算する関数を定義できます。
    Type? v = x?.y?.z;
if (v.HasValue) {
    var value = v.GetValueOrDefault();
    // code using value
}
     if (x?.y?.z is Type value) {
    // code using value
}
     abstract class Expr;
class X() : Expr;
class Const(double Value) : Expr;
class Add(Expr Left, Expr Right) : Expr;
class Mult(Expr Left, Expr Right) : Expr;
class Neg(Expr Value) : Expr;
     Expr Deriv(Expr e)
{
  switch (e) {
    case X(): return Const(1);
    case Const(*): return Const(0);
    case Add(var Left, var Right):
      return Add(Deriv(Left), Deriv(Right));
    case Mult(var Left, var Right):
      return Add(Mult(Deriv(Left), Right), Mult(Left, Deriv(Right)));
    case Neg(var Value):
      return Neg(Deriv(Value));
  }
}
 位置指定パターンを示す式 simplifier を次に示します。
   if (expr is Type v) {
    // code using v
}
 
    Expr Simplify(Expr e)
{
  switch (e) {
    case Mult(Const(0), *): return Const(0);
    case Mult(*, Const(0)): return Const(0);
    case Mult(Const(1), var x): return Simplify(x);
    case Mult(var x, Const(1)): return Simplify(x);
    case Mult(Const(var l), Const(var r)): return Const(l*r);
    case Add(Const(0), var x): return Simplify(x);
    case Add(var x, Const(0)): return Simplify(x);
    case Add(Const(var l), Const(var r)): return Const(l+r);
    case Neg(Const(var k)): return Const(-k);
    default: return e;
} }
  
                 チュートリアルでは、製品や特定の機能領域について学習を開始するのに適した一般的なシナリオについて詳細な手順を示し ます。
このセクションには、C# プログラミングのチュートリアルへのリンクが含まれています。 このセクションの内容
完了時の非同期タスクの処理
async と await を使用して非同期ソリューションを作成する方法を示します。
C# または Visual Basic で Windows ランタイム コンポーネントを作成し、JavaScript からそれを呼び出す Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化した後、JavaScript を使用して Windows 用に作成された Windows 8.x Store アプリからコンポーネントを呼び出す方法を示します。
Office のプログラミング (C# および Visual Basic)
C# および Visual Basic を使用して、Excel ブックや Word 文書を作成する方法を示します。
動的オブジェクトの作成と使用 (C# および Visual Basic) テキストファイルの内容を動的に公開するカスタムオブジェクトを作成する方法、および IronPython ライブラリを使用 するプロジェクトを作成する方法を示します。
Visual C# による複合コントロールの作成 簡単な複合コントロールを作成し、継承によってその機能を拡張する例を示します。
Visual Studio のデザイン時機能を活用した Windows フォーム コントロールの作成 カスタム コントロールのカスタム デザイナーを作成する方法を示します。
Visual C# による Windows フォーム コントロールからの継承
単純な継承されたボタン コントロールを作成する例を示します。 このボタンは、標準 Windows フォーム ボタンから機 能を継承し、カスタム メンバーを公開します。
カスタム Windows フォーム コントロールのデザイン時のデバッグ
カスタム コントロールのデザイン時動作をデバッグする方法について説明します。
チュートリアル: デザイン アクションを使って一般的なタスクを実行する
TabControl でのタブの追加や削除、コントロールの親コントロールへのドッキング、 SplitContainer コントロールの方
向の変更など、よく実行されるタスクの例を示します。
C# でのクエリの作成 (LINQ)
LINQ クエリ式の記述に使用される C# 言語機能を示します。
データの操作 (C#) (LINQ to SQL)
データベース内のデータの追加、変更、および削除の LINQ to SQL のシナリオについて説明します。
簡単なオブジェクト モデルとクエリ (C#) (LINQ to SQL)
エンティティ クラスとエンティティ クラスをフィルター処理する簡単なクエリを作成する方法について説明します。
ストアド プロシージャのみを使用する (C#) (LINQ to SQL)
ストアド プロシージャのみを実行してデータにアクセスする LINQ to SQL を使用する方法を示します。
リレーションシップ間でのクエリの実行 (C#) (LINQ to SQL) データベース内の外部キーのリレーションシップを表す LINQ to SQL の関連付けの使用の例を示します。
   C# チュートリアル 2020/11/02 • • Edit Online
 
     C# でビジュアライザーを記述する
C# を使用して簡単なビジュアライザーを作成する方法を説明します。
関連項目
配置のサンプルとチュートリアル
一般的な配置シナリオの詳細な例を示します。 関連項目
C# プログラミング ガイド Visual Studio のサンプル

