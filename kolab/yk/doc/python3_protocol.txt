webbrowser --- 便利なウェブブラウザコントローラー¶
ソースコード: Lib/webbrowser.py

webbrowser モジュールにはウェブベースのドキュメントを表示するための、とてもハイレベルなインターフェースが定義されています。たいていの環境では、このモジュールの open() を呼び出すだけで正しく動作します。

Unixでは、X11上でグラフィカルなブラウザが選択されますが、グラフィカルなブラウザが利用できなかったり、X11が利用できない場合はテキストモードのブラウザが使われます。もしテキストモードのブラウザが使われたら、ユーザがブラウザから抜け出すまでプロセスの呼び出しはブロックされます。

環境変数 BROWSER が存在する場合、これは os.pathsep で区切られたブラウザのリストとして解釈され、プラットフォームのデフォルトのブラウザリストに先立って順に試みられます。リストの中の値に %s が含まれていれば、 %s を URL に置換したコマンドライン文字列と解釈されます；もし %s が含まれなければ、起動するブラウザの名前として単純に解釈されます。 1

非UnixプラットフォームあるいはUnix上でリモートブラウザが利用可能な場合、制御プロセスはユーザがブラウザを終了するのを待ちませんが、ディスプレイにブラウザのウィンドウを表示させたままにします。Unix上でリモートブラウザが利用可能でない場合、制御プロセスは新しいブラウザを立ち上げ、待ちます。

webbrowser スクリプトをこのモジュールのコマンドライン・インタフェースとして使うことができます。スクリプトは引数に 1 つの URL を受け付けます。また次のオプション引数を受け付けます。 -n により可能ならば新しいブラウザウィンドウで指定された URL を開きます。一方、 -t では新しいブラウザのページ (「タブ」) で開きます。 当然ながらこれらのオプションは排他的です。使用例は次の通りです:

python -m webbrowser -t "http://www.python.org"
以下の例外が定義されています:

exception webbrowser.Error
ブラウザのコントロールエラーが起こると発生する例外。

以下の関数が定義されています:

webbrowser.open(url, new=0, autoraise=True)
デフォルトのブラウザで url を表示します。new が 0 なら、url はブラウザの今までと同じウィンドウで開きます。new が 1 なら、可能であればブラウザの新しいウィンドウが開きます。new が 2 なら、可能であればブラウザの新しいタブが開きます。autoraise が True なら、可能であればウィンドウが前面に表示されます（多くのウィンドウマネージャではこの変数の設定に関わらず、前面に表示されます）。

幾つかのプラットフォームにおいて、ファイル名をこの関数で開こうとすると、OSによって関連付けられたプログラムが起動されます。しかし、この動作はポータブルではありませんし、サポートされていません。

引数 url を指定して 監査イベント webbrowser.open を送出します。

webbrowser.open_new(url)
可能であれば、デフォルトブラウザの新しいウィンドウで url を開きますが、そうでない場合はブラウザのただ１つのウィンドウで url を開きます。

webbrowser.open_new_tab(url)
可能であれば、デフォルトブラウザの新しいページ(「タブ」)で url を開きますが、そうでない場合は open_new() と同様に振る舞います。

webbrowser.get(using=None)
ブラウザの種類 using のコントローラーオブジェクトを返します。もし using が None なら、呼び出した環境に適したデフォルトブラウザのコントローラーを返します。

webbrowser.register(name, constructor, instance=None, *, preferred=False)
ブラウザの種類 name を登録します。ブラウザの種類が登録されたら、 get() でそのブラウザのコントローラーを呼び出すことができます。 instance が指定されなかったり、 None なら、インスタンスが必要な時には constructor がパラメータなしに呼び出されて作られます。 instance が指定されたら、 constructor は呼び出されないので、 None でかまいません。

preferred を True に設定すると、 get() の引数無しの呼び出しの結果が優先的にこのブラウザになります。 そうでない場合は、この関数は、変数 BROWSER を設定するか、 get() を空文字列ではない、宣言したハンドラの名前と一致する引数とともに呼び出すときにだけ、役に立ちます。

バージョン 3.7 で変更: preferred キーワード専用引数が追加されました。

いくつかの種類のブラウザがあらかじめ定義されています。このモジュールで定義されている、関数 get() に与えるブラウザの名前と、それぞれのコントローラークラスのインスタンスを以下の表に示します。

Type Name

Class Name

注釈

'mozilla'

Mozilla('mozilla')

'firefox'

Mozilla('mozilla')

'netscape'

Mozilla('netscape')

'galeon'

Galeon('galeon')

'epiphany'

Galeon('epiphany')

'skipstone'

BackgroundBrowser('skipstone')

'kfmclient'

Konqueror()

(1)

'konqueror'

Konqueror()

(1)

'kfm'

Konqueror()

(1)

'mosaic'

BackgroundBrowser('mosaic')

'opera'

Opera()

'grail'

Grail()

'links'

GenericBrowser('links')

'elinks'

Elinks('elinks')

'lynx'

GenericBrowser('lynx')

'w3m'

GenericBrowser('w3m')

'windows-default'

WindowsDefault

(2)

'macosx'

MacOSX('default')

(3)

'safari'

MacOSX('safari')

(3)

'google-chrome'

Chrome('google-chrome')

'chrome'

Chrome('chrome')

'chromium'

Chromium('chromium')

'chromium-browser'

Chromium('chromium-browser')

注釈:

"Konqueror"はUnixのKDEデスクトップ環境のファイルマネージャで、KDEが動作している時にだけ意味を持ちます。何か信頼できる方法でKDEを検出するのがいいでしょう; 変数 KDEDIR では十分ではありません。また、KDE 2で konqueror コマンドを使うときにも、"kfm"が使われます --- Konquerorを動作させるのに最も良い方法が実装によって選択されます。

Windowsプラットフォームのみ。

Mac OS X プラットフォームのみ。

バージョン 3.3 で追加: Chrome/Chromium のサポートが追加されました。

簡単な例を示します:

url = 'http://docs.python.org/'

# Open URL in a new tab, if a browser window is already open.
webbrowser.open_new_tab(url)

# Open URL in new window, raising the window if possible.
webbrowser.open_new(url)
ブラウザコントローラーオブジェクト
ブラウザコントローラーには以下のメソッドが定義されていて、モジュールレベルの便利な 3 つの関数に相当します:

controller.open(url, new=0, autoraise=True)
このコントローラーでハンドルされたブラウザで url を表示します。new が 1 なら、可能であればブラウザの新しいウィンドウが開きます。new が 2 なら、可能であればブラウザの新しいページ(「タブ」)が開きます。

controller.open_new(url)
可能であれば、このコントローラーでハンドルされたブラウザの新しいウィンドウで url を開きますが、そうでない場合はブラウザのただ１つのウィンドウで url を開きます。 open_new() の別名。

controller.open_new_tab(url)
可能であれば、このコントローラーでハンドルされたブラウザの新しいページ(「タブ」)で url を開きますが、そうでない場合は open_new() と同じです。

脚注

1
ここでブラウザの名前が絶対パスで書かれていない場合は PATH 環境変数で与えられたディレクトリから探し出されます。

cgi --- CGI (ゲートウェイインターフェース規格) のサポート
ソースコード: Lib/cgi.py

ゲートウェイインターフェース規格 (CGI) に準拠したスクリプトをサポートするためのモジュールです。

このモジュールでは、Python で CGI スクリプトを書く際に使える様々なユーティリティを定義しています。

はじめに
CGI スクリプトは、HTTP サーバによって起動され、通常は HTML の <FORM> または <ISINDEX> エレメントを通じてユーザが入力した内容を処理します。

ほとんどの場合、CGI スクリプトはサーバ上の特殊なディレクトリ cgi-bin の下に置きます。HTTP サーバは、まずスクリプトを駆動するためのシェルの環境変数に、リクエストの全ての情報 (クライアントのホスト名、リクエストされている URL、クエリ文字列、その他諸々) を設定し、スクリプトを実行した後、スクリプトの出力をクライアントに送信します。

スクリプトの入力端もクライアントに接続されていて、この経路を通じてフォームデータを読み込むこともあります。それ以外の場合には、フォームデータは URL の一部分である「クエリ文字列」を介して渡されます。このモジュールでは、上記のケースの違いに注意しつつ、Python スクリプトに対しては単純なインターフェースを提供しています。このモジュールではまた、スクリプトをデバッグするためのユーティリティも多数提供しています。また、最近はフォームを経由したファイルのアップロードをサポートしています (ブラウザ側がサポートしていればです)。

CGI スクリプトの出力は 2 つのセクションからなり、空行で分割されています。最初のセクションは複数のヘッダからなり、後続するデータがどのようなものかをクライアントに通知します。最小のヘッダセクションを生成するための Python のコードは以下のようなものです:

print("Content-Type: text/html")    # HTML is following
print()                             # blank line, end of headers
二つ目のセクションは通常、ヘッダやインラインイメージ等の付属したテキストをうまくフォーマットして表示できるようにした HTML です。以下に単純な HTML を出力する Python コードを示します:

print("<TITLE>CGI script output</TITLE>")
print("<H1>This is my first CGI script</H1>")
print("Hello, world!")
cgi モジュールを使う
import cgi と記述して開始します。

新たにスクリプトを書く際には、以下の行を付加するかどうか検討してください:

import cgitb
cgitb.enable()
これによって、特別な例外処理が有効にされ、エラーが発生した際にブラウザ上に詳細なレポートを出力するようになります。ユーザにスクリプトの内部を見せたくないのなら、以下のようにしてレポートをファイルに保存できます:

import cgitb
cgitb.enable(display=0, logdir="/path/to/logdir")
スクリプトを開発する際には、この機能はとても役に立ちます。 cgitb が生成する報告はバグを追跡するためにかかる時間を大幅に減らせるような情報を提供してくれます。スクリプトをテストし終わり、正確に動作することを確認したら、いつでも cgitb の行を削除できます。

入力されたフォームデータを取得するには、 FieldStorage クラスを使います。フォームが非 ASCII 文字を含んでいる場合は、 encoding キーワードパラメータを使用してドキュメントに対して定義されたエンコーディングの値を設定してください。それは、通常 HTML ドキュメントの HEAD セクション中の META タグ、あるいは Content-Type ヘッダーに含まれています。これは、標準入力または環境変数からフォームの内容を読み出します (どちらから読み出すかは、複数の環境変数の値が CGI 標準に従ってどのように設定されているかで決まります)。インスタンスが標準入力を使うかもしれないので、インスタンス生成を行うのは一度だけにしなければなりません。

FieldStorage のインスタンスは Python の辞書型のように添え字アクセスが可能です。 in を使用することによって要素が含まれているかの判定も出来ますし、標準の辞書メソッド keys() 及び組み込み関数 len() もサポートしています。空の文字列を含むフォーム要素は無視され、辞書には現れません。そのような値を保持するには、FieldStorage のインスタンス作成の際にオプションのキーワードパラメータ keep_blank_values に true を指定してください。

例えば、以下のコード (Content-Type ヘッダと空行はすでに出力された後とします) は name および addr フィールドが両方とも空の文字列に設定されていないか調べます:

form = cgi.FieldStorage()
if "name" not in form or "addr" not in form:
    print("<H1>Error</H1>")
    print("Please fill in the name and addr fields.")
    return
print("<p>name:", form["name"].value)
print("<p>addr:", form["addr"].value)
...further form processing here...
ここで、 form[key] で参照される各フィールドはそれ自体が FieldStorage (または MiniFieldStorage 。フォームのエンコードによって変わります) のインスタンスです。インスタンスの属性 value の内容は対応するフィールドの値で、文字列になります。 getvalue() メソッドはこの文字列値を直接返します。 getvalue() の 2 つめの引数にオプションの値を与えると、リクエストされたキーが存在しない場合に返すデフォルトの値になります。

入力されたフォームデータに同じ名前のフィールドが二つ以上あれば、 form[key] で得られるオブジェクトは FieldStorage や MiniFieldStorage のインスタンスではなく、そうしたインスタンスのリストになります。この場合、 form.getvalue(key) も同様に、文字列からなるリストを返します。もしこうした状況が起きうると思うなら (HTML のフォームに同じ名前をもったフィールドが複数含まれているのなら) 、 getlist() メソッドを使ってください。これは常に値のリストを返します (単一要素のケースを特別扱いする必要はありません)。例えば、以下のコードは任意の数のユーザ名フィールドを結合し、コンマで分割された文字列にします:

value = form.getlist("username")
usernames = ",".join(value)
フィールドがアップロードされたファイルを表している場合、 value 属性や getvalue() メソッドを使ってフィールドの値にアクセスすると、ファイルの内容をすべてメモリ上にバイト列として読み込みます。これは場合によっては望ましい動作ではないかもしれません。アップロードされたファイルがあるかどうかは filename 属性および file 属性のいずれかで調べられます。そして、 FieldStorage インスタンスのガベージコレクションの一部として自動的に閉じられるまでの間に、 file 属性から以下のようにデータを読み込むことができます (read() および readline() メソッドはバイト列を返します):

fileitem = form["userfile"]
if fileitem.file:
    # It's an uploaded file; count lines
    linecount = 0
    while True:
        line = fileitem.file.readline()
        if not line: break
        linecount = linecount + 1
FieldStorage オブジェクトは with 文での使用にも対応しています。 with 文を使用した場合、オブジェクトは終了時に自動的に閉じられます。

アップロードされたファイルの内容を取得している間にエラーが発生した場合 (例えば、ユーザーが戻るボタンやキャンセルボタンで submit を中断した場合)、そのフィールドのオブジェクトの done 属性には -1 が設定されます。

現在ドラフトとなっているファイルアップロードの標準仕様では、一つのフィールドから (再帰的な multipart/* エンコーディングを使って) 複数のファイルがアップロードされる可能性を受け入れています。この場合、アイテムは辞書形式の FieldStorage アイテムとなります。複数ファイルかどうかは type 属性が multipart/form-data (または multipart/* にマッチする他の MIME 型) になっているかどうかを調べれば判別できます。この場合、トップレベルのフォームオブジェクトと同様にして再帰的に個別処理できます。

フォームが「古い」形式で入力された場合 (クエリ文字列または単一の application/x-www-form-urlencoded データで入力された場合)、データ要素の実体は MiniFieldStorage クラスのインスタンスになります。この場合、 list 、 file 、および filename 属性は常に None になります。

フォームがPOSTによって送信され、クエリー文字列も持っていた場合、 FieldStorage と MiniFieldStorage の両方が含まれます。

バージョン 3.4 で変更: file 属性は、それを作成した FieldStorage インスタンスのガベージコレクションによって自動的に閉じられます。

バージョン 3.5 で変更: FieldStorage クラスにコンテキスト管理プロトコルのサポートが追加されました。

高水準インターフェース
前節では CGI フォームデータを FieldStorage クラスを使って読み出す方法について解説しました。この節では、フォームデータを分かりやすく直感的な方法で読み出せるようにするために追加された、より高水準のインターフェースについて記述します。このインターフェースは前節で説明した技術を撤廃するものではありません --- 例えば、前節の技術は依然としてファイルのアップロードを効率的に行う上で便利です。

このインターフェースは 2 つの単純なメソッドからなります。このメソッドを使えば、一般的な方法でフォームデータを処理でき、ある名前のフィールドに入力された値が一つなのかそれ以上なのかを心配する必要がなくなります。

前節では、一つのフィールド名に対して二つ以上の値が入力されるかもしれない場合には、常に以下のようなコードを書くよう学びました:

item = form.getvalue("item")
if isinstance(item, list):
    # The user is requesting more than one item.
else:
    # The user is requesting only one item.
こういった状況は、例えば以下のように、同じ名前を持った複数のチェックボックスからなるグループがフォームに入っているような場合によく起きます:

<input type="checkbox" name="item" value="1" />
<input type="checkbox" name="item" value="2" />
しかしながら、ほとんどの場合、あるフォーム中で特定の名前を持ったコントロールはただ一つしかないので、その名前に関連付けられた値はただ一つしかないはずだと考えるでしょう。そこで、スクリプトには例えば以下のようなコードを書くでしょう:

user = form.getvalue("user").upper()
このコードの問題点は、クライアントがスクリプトにとって常に有効な入力を提供するとは期待できないところにあります。例えば、もし好奇心旺盛なユーザがもう一つの user=foo ペアをクエリ文字列に追加したら、 getvalue("user") メソッドは文字列ではなくリストを返すため、このスクリプトはクラッシュするでしょう。リストに対して upper() メソッドを呼び出すと、引数が有効でない (リスト型はその名前のメソッドを持っていない) ため、例外 AttributeError を送出します。

従って、フォームデータの値を読み出しには、得られた値が単一の値なのか値のリストなのかを常に調べるコードを使うのが適切でした。これでは煩わしく、より読みにくいスクリプトになってしまいます。

ここで述べる高水準のインターフェースで提供している getfirst() や getlist() メソッドを使うと、もっと便利にアプローチできます。

FieldStorage.getfirst(name, default=None)
フォームフィールド name に関連付けられた値をつねに一つだけ返す軽量メソッドです。同じ名前で 1 つ以上の値がポストされている場合、このメソッドは最初の値だけを返します。フォームから値を受信する際の値の並び順はブラウザ間で異なる可能性があり、特定の順番であるとは期待できないので注意してください。1 指定したフォームフィールドや値がない場合、このメソッドはオプションの引数 default を返します。このパラメタを指定しない場合、標準の値は None に設定されます。

FieldStorage.getlist(name)
このメソッドはフォームフィールド name に関連付けられた値を常にリストにして返します。name に指定したフォームフィールドや値が存在しない場合、このメソッドは空のリストを返します。値が一つだけ存在する場合、要素を一つだけ含むリストを返します。

これらのメソッドを使うことで、以下のようにナイスでコンパクトにコードを書けます:

import cgi
form = cgi.FieldStorage()
user = form.getfirst("user", "").upper()    # This way it's safe.
for item in form.getlist("item"):
    do_something(item)
関数
より細かく CGI をコントロールしたり、このモジュールで実装されているアルゴリズムを他の状況で利用したい場合には、以下の関数が便利です。

cgi.parse(fp=None, environ=os.environ, keep_blank_values=False, strict_parsing=False, separator="&")
Parse a query in the environment or from a file (the file defaults to sys.stdin). The keep_blank_values, strict_parsing and separator parameters are passed to urllib.parse.parse_qs() unchanged.

cgi.parse_multipart(fp, pdict, encoding="utf-8", errors="replace", separator="&")
Parse input of type multipart/form-data (for file uploads). Arguments are fp for the input file, pdict for a dictionary containing other parameters in the Content-Type header, and encoding, the request encoding.

Returns a dictionary just like urllib.parse.parse_qs(): keys are the field names, each value is a list of values for that field. For non-file fields, the value is a list of strings.

This is easy to use but not much good if you are expecting megabytes to be uploaded --- in that case, use the FieldStorage class instead which is much more flexible.

バージョン 3.7 で変更: Added the encoding and errors parameters. For non-file fields, the value is now a list of strings, not bytes.

バージョン 3.9.2 で変更: Added the separator parameter.

cgi.parse_header(string)
(Content-Type のような) MIME ヘッダを解釈し、ヘッダの主要値と各パラメタからなる辞書にします。

cgi.test()
メインプログラムから利用できる堅牢性テストを行う CGI スクリプトです。最小の HTTP ヘッダと、HTML フォームからスクリプトに供給された全ての情報を書式化して出力します。

cgi.print_environ()
シェル変数を HTML に書式化して出力します。

cgi.print_form(form)
フォームを HTML に初期化して出力します。

cgi.print_directory()
現在のディレクトリを HTML に書式化して出力します。

cgi.print_environ_usage()
意味のある (CGI の使う) 環境変数を HTML で出力します。

セキュリティへの配慮
重要なルールが一つあります: (関数 os.system() または os.popen() 、またはその他の同様の機能によって) 外部プログラムを呼び出すなら、クライアントから受信した任意の文字列をシェルに渡していないことをよく確かめてください。これはよく知られているセキュリティホールであり、これによって Web のどこかにいる悪賢いハッカーが、だまされやすい CGI スクリプトに任意のシェルコマンドを実行させてしまえます。URL の一部やフィールド名でさえも信用してはいけません。CGI へのリクエストはあなたの作ったフォームから送信されるとは限らないからです！

安全な方法をとるために、フォームから入力された文字をシェルに渡す場合、文字列に入っているのが英数文字、ダッシュ、アンダースコア、およびピリオドだけかどうかを確認してください。

CGI スクリプトを Unix システムにインストールする
あなたの使っている HTTP サーバのドキュメントを読んでください。そしてローカルシステムの管理者と一緒にどのディレクトリに CGI スクリプトをインストールすべきかを調べてください; 通常これはサーバのファイルシステムツリー内の cgi-bin ディレクトリです。

あなたのスクリプトが "others" によって読み取り可能および実行可能であることを確認してください; Unix ファイルモードは 8 進表記で 0o755 です (chmod 0755 filename を使ってください)。スクリプトの最初の行の 1 カラム目が、#! で開始し、その後に Python インタプリタへのパス名が続いていることを確認してください。例えば:

#!/usr/local/bin/python
Python インタプリタが存在し、"others" によって実行可能であることを確かめてください。

あなたのスクリプトが読み書きしなければならないファイルが全て "others" によって読み出しや書き込み可能であることを確かめてください --- 読み出し可能のファイルモードは 0o644 で、書き込み可能のファイルモードは 0o666 になるはずです。これは、セキュリティ上の理由から、 HTTP サーバがあなたのスクリプトを特権を全く持たないユーザ "nobody" の権限で実行するからです。この権限下では、誰でもが読める (書ける、実行できる) ファイルしか読み出し (書き込み、実行) できません。スクリプト実行時のディレクトリや環境変数のセットもあなたがログインしたときの設定と異なります。特に、実行ファイルに対するシェルの検索パス (PATH) や Python のモジュール検索パス (PYTHONPATH)が何らかの値に設定されていると期待してはいけません。

モジュールを Python の標準設定におけるモジュール検索パス上にないディレクトリからロードする必要がある場合、他のモジュールを取り込む前にスクリプト内で検索パスを変更できます。例えば:

import sys
sys.path.insert(0, "/usr/home/joe/lib/python")
sys.path.insert(0, "/usr/local/lib/python")
(この方法では、最後に挿入されたディレクトリが最初に検索されます！)

非 Unix システムにおける説明は変わるでしょう; あなたの使っている HTTP サーバのドキュメントを調べてください (普通は CGI スクリプトに関する節があります)。

CGI スクリプトをテストする
残念ながら、CGI スクリプトは普通、コマンドラインから起動しようとしても動きません。また、コマンドラインから起動した場合には完璧に動作するスクリプトが、不思議なことにサーバからの起動では失敗することがあります。しかし、スクリプトをコマンドラインから実行してみなければならない理由が一つあります: もしスクリプトが文法エラーを含んでいれば、Python インタプリタはそのプログラムを全く実行しないため、HTTP サーバはほとんどの場合クライアントに謎めいたエラーを送信するからです。

スクリプトが構文エラーを含まないのにうまく動作しないなら、次の節に読み進むしかありません。

CGI スクリプトをデバッグする
何よりもまず、些細なインストール関連のエラーでないか確認してください --- 上の CGI スクリプトのインストールに関する節を注意深く読めば時間を大いに節約できます。もしインストールの手続きを正しく理解しているか不安なら、このモジュールのファイル (cgi.py) をコピーして、CGI スクリプトとしてインストールしてみてください。このファイルはスクリプトとして呼び出すと、スクリプトの実行環境とフォームの内容を HTML 形式で出力します。ファイルに正しいモードを設定するなどして、リクエストを送ってみてください。標準的な cgi-bin ディレクトリにインストールされていれば、以下のような URL をブラウザに入力してリクエストを送信できるはずです:

http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&addr=At+Home
もしタイプ 404 のエラーになるなら、サーバはスクリプトを発見できないでいます -- おそらくあなたはスクリプトを別のディレクトリに入れる必要があるのでしょう。他のエラーになるなら、先に進む前に解決しなければならないインストール上の問題があります。もし実行環境の情報とフォーム内容 (この例では、各フィールドはフィールド名 "addr" に対して値 "At Home"、およびフィールド名 "name" に対して "Joe Blow") が綺麗にフォーマットされて表示されるなら、 cgi.py スクリプトは正しくインストールされています。同じ操作をあなたの自作スクリプトに対して行えば、スクリプトをデバッグできるようになるはずです。

次のステップでは cgi モジュールの test() 関数を呼び出すことになります: メインプログラムコードを以下の 1 文と置き換えてください

cgi.test()
この操作で cgi.py ファイル自体をインストールした時と同じ結果を出力するはずです。

通常の Python スクリプトが例外を処理しきれずに送出した場合 (様々な理由: モジュール名のタイプミス、ファイルが開けなかった、など)、Python インタプリタはナイスなトレースバックを出力して終了します。Python インタプリタはあなたの CGI スクリプトが例外を送出した場合にも同様に振舞うので、トレースバックは大抵HTTP サーバのいずれかのログファイルに残るかまったく無視されるかです。

幸運なことに、あなたが自作のスクリプトで 何らかの コードを実行できるようになったら、 cgitb モジュールを使って簡単にトレースバックをブラウザに送信できます。まだそうでないなら、以下の2行:

import cgitb
cgitb.enable()
をスクリプトの先頭に追加してください。そしてスクリプトを再度走らせます; 問題が発生すれば、クラッシュの原因を見出せるような詳細な報告を読めます。

cgitb モジュールのインポートに問題がありそうだと思うなら、(組み込みモジュールだけを使った) もっと堅牢なアプローチを取れます:

import sys
sys.stderr = sys.stdout
print("Content-Type: text/plain")
print()
...your code here...
このコードは Python インタプリタがトレースバックを出力することに依存しています。出力のコンテント型はプレーンテキストに設定されており、全ての HTML 処理を無効にしています。スクリプトがうまく動作する場合、生の HTML コードがクライアントに表示されます。スクリプトが例外を送出する場合、最初の 2 行が出力された後、トレースバックが表示されます。HTML の解釈は行われないので、トレースバックを読めるはずです。

よくある問題と解決法
ほとんどの HTTP サーバはスクリプトの実行が完了するまで CGI からの出力をバッファします。このことは、スクリプトの実行中にクライアントが進捗状況報告を表示できないことを意味します。

上のインストールに関する説明を調べましょう。

HTTP サーバのログファイルを調べましょう。(別のウィンドウで tail -f logfile を実行すると便利かもしれません！)

常に python script.py などとして、スクリプトが構文エラーでないか調べましょう。

スクリプトに構文エラーがないなら、import cgitb; cgitb.enable() をスクリプトの先頭に追加してみましょう。

外部プログラムを起動するときには、スクリプトがそのプログラムを見つけられるようにしましょう。これは通常、絶対パス名を使うことを意味します --- PATH は普通、あまり CGI スクリプトにとって便利でない値に設定されています。

外部のファイルを読み書きする際には、CGI スクリプトを動作させるときに使われる userid でファイルを読み書きできるようになっているか確認しましょう: userid は通常、Web サーバを動作させている userid か、Web サーバの suexec 機能で明示的に指定している userid になります。

CGI スクリプトを set-uid モードにしてはいけません。これはほとんどのシステムで動作せず、セキュリティ上の信頼性もありません。

脚注

1
最近のバージョンの HTML 仕様ではフィールドの値を供給する順番を取り決めてはいますが、ある HTTP リクエストがその取り決めに準拠したブラウザから受信したものかどうか、そもそもブラウザから送信されたものかどうかの判別は退屈で間違いやすいので注意してください。

cgitb --- CGI スクリプトのトレースバック管理機構¶
ソースコード: Lib/cgitb.py

cgitb モジュールでは、Python スクリプトのための特殊な例外処理を提供します。(実はこの説明は少し的外れです。このモジュールはもともと徹底的なトレースバック情報を CGI スクリプトで生成した HTML 内に表示するための設計されました。その後この情報を平文テキストでも表示できるように一般化されています。) このモジュールの有効化後に捕捉されない例外が生じた場合、詳細で書式化された報告が Web ブラウザに送信されます。この報告には各レベルにおけるソースコードの抜粋が示されたトレースバックと、現在動作している関数の引数やローカルな変数が収められており、問題のデバッグを助けます。オプションとして、この情報をブラウザに送信する代わりにファイルに保存することもできます。

この機能を有効化するためには、単に自作の CGI スクリプトの最初に以下の2行を追加します:

import cgitb
cgitb.enable()
enable() 関数のオプションは、報告をブラウザに表示するかどうかと、後で解析するためにファイルに報告をログ記録するかどうかを制御します。

cgitb.enable(display=1, logdir=None, context=5, format="html")
この関数は、 sys.excepthook を設定することで、インタプリタの標準の例外処理を cgitb モジュールに肩代わりさせるようにします。

オプションの引数 display は標準で 1 になっており、この値は 0 にしてトレースバックをブラウザに送らないように抑制することもできます。引数 logdir が存在すれば、トレースバックレポートはそのファイルに書き込まれます。logdir の値はログファイルを配置するディレクトリです。オプション引数 context は、トレースバックの中で現在の行の周辺の何行を表示するかです; この値は標準で 5 です。オプション引数 format が "html" の場合、出力は HTML に書式化されます。その他の値を指定すると平文テキストの出力を強制します。デフォルトの値は "html" です。

cgitb.text(info, context=5)
この関数は info (sys.exc_info() の結果を含む 3 タプル) に記述されている例外を取り扱い、 テキストとしてトレースバックをフォーマットし、結果を文字列として返します。 オプションの引数 context は、トレースバックにおいてソースコード行の前後のコンテキストを表示する行数です。デフォルトは 5 です。

cgitb.html(info, context=5)
この関数は info (sys.exc_info() の結果を含む 3 タプル) に記述されている例外を取り扱い、 HTML としてトレースバックをフォーマットし、結果を文字列として返します。 オプションの引数 context は、トレースバックにおいてソースコード行の前後のコンテキストを表示する行数です。デフォルトは 5 です。

cgitb.handler(info=None)
この関数は標準の設定 (ブラウザに報告を表示しますがファイルにはログを書き込みません) を使って例外を処理します。この関数は、例外を捕捉した際に cgitb を使って報告したい場合に使うことができます。オプションの info 引数は、例外の型、例外の値、トレースバックオブジェクトからなる 3 要素のタプルでなければなりません。これは sys.exc_info() によって返される値と全く同じです。 info 引数が与えられていない場合、現在の例外は sys.exc_info() から取得されます。

wsgiref --- WSGI ユーティリティとリファレンス実装¶
Web Server Gateway Interface (WSGI) は、Web サーバソフトウェアと Python で記述された Web アプリケーションとの標準インターフェースです。標準インターフェースを持つことで、WSGI をサポートするアプリケーションを幾つもの異なる Web サーバで使うことが容易になります。

Web サーバとプログラミングフレームワークの作者だけが、WSGI デザインのあらゆる細部や特例などを知る必要があります。WSGI アプリケーションをインストールしたり、既存のフレームワークを使ったアプリケーションを記述するだけの皆さんは、すべてについて理解する必要はありません。

wsgiref は WSGI 仕様のリファレンス実装で、これは Web サーバやフレームワークに WSGI サポートを加えるのに利用できます。これは WSGI 環境変数やレスポンスヘッダを操作するユーティリティ、 WSGI サーバ実装時のベースクラス、WSGI アプリケーションを提供する デモ用 HTTP サーバ、それと WSGI サーバとアプリケーションの WSGI 仕様 (PEP 3333) 準拠のバリデーションツールを提供します。

See wsgi.readthedocs.io for more information about WSGI, and links to tutorials and other resources.

wsgiref.util -- WSGI 環境のユーティリティ
このモジュールは WSGI 環境で使う様々なユーティリティ関数を提供します。 WSGI 環境は PEP 3333 で記述されているような HTTP リクエスト変数を含む辞書です。すべての environ パラメータを取る関数は WSGI 準拠の辞書を与えられることを期待しています; 細かい仕様については PEP 3333 を参照してください。

wsgiref.util.guess_scheme(environ)
environ 辞書の HTTPS 環境変数を調べることで wsgi.url_scheme が "http" か "https" のどちらであるべきか推測し、その結果を返します。戻り値は文字列です。

This function is useful when creating a gateway that wraps CGI or a CGI-like protocol such as FastCGI. Typically, servers providing such protocols will include a HTTPS variable with a value of "1", "yes", or "on" when a request is received via SSL. So, this function returns "https" if such a value is found, and "http" otherwise.

wsgiref.util.request_uri(environ, include_query=True)
リクエスト URI 全体 (オプションでクエリ文字列を含む) を、 PEP 3333 の "URL 再構築(URL Reconstruction)" にあるアルゴリズムを使って返します。 include_query が false の場合、クエリ文字列は結果となる文字列には含まれません。

wsgiref.util.application_uri(environ)
PATH_INFO と QUERY_STRING 変数が無視されることを除けば request_uri() に似ています。結果はリクエストによって指定されたアプリケーションオブジェクトのベース URI です。

wsgiref.util.shift_path_info(environ)
PATH_INFO から SCRIPT_NAME に一つの名前をシフトしてその名前を返します。environ 辞書は 変更されます 。PATH_INFO や SCRIPT_NAME のオリジナルをそのまま残したい場合にはコピーを使ってください。

PATH_INFO にパスセグメントが何も残っていなければ、None が返されます。

典型的なこのルーチンの使い方はリクエスト URI のそれぞれの要素の処理で、例えばパスを一連の辞書のキーとして取り扱う場合です。このルーチンは、渡された環境を、ターゲット URL で示される別の WSGI アプリケーションの呼び出しに合うように調整します。例えば、 /foo に WSGI アプリケーションがあったとして、そしてリクエスト URL パスが /foo/bar/baz で、 /foo の WSGI アプリケーションが shift_path_info() を呼んだ場合、これは "bar" 文字列を受け取り、 environ は /foo/bar の WSGI アプリケーションへの受け渡しに適するように更新されます。つまり、 SCRIPT_NAME は /foo から /foo/bar に変わって、 PATH_INFO は /bar/baz から /baz に変化するのです。

PATH_INFO が単に "/" の場合、このルーチンは空の文字列を返し、SCRIPT_NAME の末尾にスラッシュを加えます、これはたとえ空のパスセグメントが通常は無視され、そして SCRIPT_NAME は通常スラッシュで終わる事が無かったとしてもです。これは意図的な振る舞いで、このルーチンでオブジェクト巡回(object traversal) をした場合に /x で終わる URI と /x/ で終わるものをアプリケーションが識別できることを保証するためのものです。

wsgiref.util.setup_testing_defaults(environ)
environ をテスト用に自明なデフォルト値で更新します。

このルーチンは WSGI に必要な様々なパラメータを追加します。そのようなパラメータとして HTTP_HOST 、 SERVER_NAME 、 SERVER_PORT 、 REQUEST_METHOD 、 SCRIPT_NAME 、 PATH_INFO 、そして PEP 3333 で定義されている wsgi.* 変数群が含まれます。このルーチンはデフォルト値を提供するだけで、これらの変数の既存設定は一切置きかえません。

このルーチンは、ダミー環境をセットアップすることによって WSGI サーバとアプリケーションのユニットテストを容易にすることを意図しています。これは実際の WSGI サーバやアプリケーションで使うべきではありません。なぜならこのデータは偽物なのです！

使用例:

from wsgiref.util import setup_testing_defaults
from wsgiref.simple_server import make_server

# A relatively simple WSGI application. It's going to print out the
# environment dictionary after being updated by setup_testing_defaults
def simple_app(environ, start_response):
    setup_testing_defaults(environ)

    status = '200 OK'
    headers = [('Content-type', 'text/plain; charset=utf-8')]

    start_response(status, headers)

    ret = [("%s: %s\n" % (key, value)).encode("utf-8")
           for key, value in environ.items()]
    return ret

with make_server('', 8000, simple_app) as httpd:
    print("Serving on port 8000...")
    httpd.serve_forever()
上記の環境用関数に加えて、 wsgiref.util モジュールも以下のようなその他のユーティリティを提供します:

wsgiref.util.is_hop_by_hop(header_name)
Return True if 'header_name' is an HTTP/1.1 "Hop-by-Hop" header, as defined by RFC 2616.

class wsgiref.util.FileWrapper(filelike, blksize=8192)
ファイル風オブジェクトを イテレータ に変換するラッパです。結果のオブジェクトは __getitem__() と __iter__() 両方をサポートしますが、これは Python 2.1 と Jython の互換性のためです。オブジェクトがイテレートされる間、オプションの blksize パラメータがくり返し filelike オブジェクトの read() メソッドに渡されて受け渡すバイト文字列を取得します。 read() が空バイト文字列を返した場合、イテレーションは終了して再開されることはありません。

filelike に close() メソッドがある場合、返されたオブジェクトも close() メソッドを持ち、これが呼ばれた場合には filelike オブジェクトの close() メソッドを呼び出します。

使用例:

from io import StringIO
from wsgiref.util import FileWrapper

# We're using a StringIO-buffer for as the file-like object
filelike = StringIO("This is an example file-like object"*10)
wrapper = FileWrapper(filelike, blksize=5)

for chunk in wrapper:
    print(chunk)
バージョン 3.8 で非推奨: Support for sequence protocol is deprecated.

wsgiref.headers -- WSGI レスポンスヘッダツール群
このモジュールは単一のクラス、 Headers を提供し、WSGI レスポンスヘッダの操作をマップに似たインターフェースで便利にします。

class wsgiref.headers.Headers([headers])
headers をラップするマップ風オブジェクトを生成します。これは PEP 3333 に定義されるようなヘッダの名前／値のタプルのリストです。 headers のデフォルト値は空のリストです。

Headers オブジェクトは典型的なマッピング操作をサポートし、これには __getitem__() 、 get() 、 __setitem__() 、 setdefault() 、 __delitem__() 、 __contains__() を含みます。これらメソッドのそれぞれにおいて、キーはヘッダ名で（大文字小文字は区別しません）、値はそのヘッダ名に関連づけられた最初の値です。ヘッダを設定すると既存のヘッダ値は削除され、ラップされたヘッダのリストの末尾に新しい値が加えられます。既存のヘッダの順番は一般に維持され、ラップされたリストの最後に新しいヘッダが追加されます。

辞書とは違って、 Headers オブジェクトはラップされたヘッダリストに存在しないキーを取得または削除しようとした場合にもエラーを発生しません。単に、存在しないヘッダの取得は None を返し、存在しないヘッダの削除は何もしません。

Headers オブジェクトは keys() 、 values() 、 items() メソッドもサポートします。複数の値を持つヘッダがある場合には、 keys() と items() で返されるリストは同じキーを一つ以上含むことがあります。 Headers オブジェクトの len() は、その items() の長さと同じであり、ラップされたヘッダリストの長さと同じです。実際、 items() メソッドは単にラップされたヘッダリストのコピーを返しているだけです。

Headers オブジェクトに対して bytes() を呼ぶと、HTTP レスポンスヘッダとして送信するのに適した形に整形されたバイト文字列を返します。それぞれのヘッダはコロンとスペースで区切られた値と共に一列に並んでいます。それぞれの行はキャリッジリターンとラインフィードで終了し、バイト文字列は空行で終了しています。

これらのマッピングインターフェースと整形機能に加えて、 Headers オブジェクトは複数の値を持つヘッダの取得と追加、MIME パラメータでヘッダを追加するための以下のようなメソッド群も持っています:

get_all(name)
指定されたヘッダのすべての値のリストを返します。

返されるリストは、元々のヘッダリストに現れる順、またはこのインスタンスに追加された順に並んでいて、重複を含む場合があります。削除されて加えられたフィールドはすべてヘッダリストの末尾に付きます。与えられた name に対するフィールドが何もなければ、空のリストが返ります。

add_header(name, value, **_params)
(複数の値を持つ可能性のある) ヘッダを、キーワード引数を通じて指定するオプションの MIME パラメータと共に追加します。

name は追加するヘッダフィールドです。このヘッダフィールドに MIME パラメータを設定するためにキーワード引数を使うことができます。それぞれのパラメータは文字列か None でなければいけません。パラメータ中のアンダースコアはダッシュ (-) に変換されます。これは、ダッシュが Python の識別子としては不正なのですが、多くの MIME パラメータはダッシュを含むためです。パラメータ値が文字列の場合、これはヘッダ値のパラメータに name="value" の形で追加されます。この値がもし None の場合、パラメータ名だけが追加されます。（これは値なしの MIME パラメータの場合に使われます。）使い方の例は:

h.add_header('content-disposition', 'attachment', filename='bud.gif')
上記はこのようなヘッダを追加します:

Content-Disposition: attachment; filename="bud.gif"
バージョン 3.5 で変更: headers 引数が任意になりました。

wsgiref.simple_server -- シンプルな WSGI HTTP サーバ
このモジュールは WSGI アプリケーションを提供するシンプルな HTTP サーバです (http.server がベースです)。個々のサーバインスタンスは単一の WSGI アプリケーションを、特定のホストとポート上で提供します。もし一つのホストとポート上で複数のアプリケーションを提供したいならば、 PATH_INFO をパースして個々のリクエストでどのアプリケーションを呼び出すか選択するような WSGI アプリケーションを作る必要があります。（例えば、 wsgiref.util から shift_path_info() を利用します。）

wsgiref.simple_server.make_server(host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler)
host と port 上で待機し、 app へのコネクションを受け付ける WSGI サーバを作成します。戻り値は与えられた server_class のインスタンスで、指定された handler_class を使ってリクエストを処理します。 app は PEP 3333 で定義されるところの WSGI アプリケーションでなければいけません。

使用例:

from wsgiref.simple_server import make_server, demo_app

with make_server('', 8000, demo_app) as httpd:
    print("Serving HTTP on port 8000...")

    # Respond to requests until process is killed
    httpd.serve_forever()

    # Alternative: serve one request, then exit
    httpd.handle_request()
wsgiref.simple_server.demo_app(environ, start_response)
この関数は小規模ながら完全な WSGI アプリケーションで、 "Hello world!" メッセージと、 environ パラメータに提供されているキー／値のペアを含むテキストページを返します。これは WSGI サーバ (wsgiref.simple_server のような) がシンプルな WSGI アプリケーションを正しく実行できるかを確かめるのに便利です。

class wsgiref.simple_server.WSGIServer(server_address, RequestHandlerClass)
WSGIServer インスタンスを作成します。 server_address は (host,port) のタプル、そして RequestHandlerClass はリクエストの処理に使われる http.server.BaseHTTPRequestHandler のサブクラスでなければいけません。

make_server() が細かい調整をやってくれるので、通常はこのコンストラクタを呼ぶ必要はありません。

WSGIServer は http.server.HTTPServer のサブクラスなので、そのすべてのメソッド (serve_forever() や handle_request() のような) が利用できます。 WSGIServer も以下のような WSGI 固有メソッドを提供します:

set_app(application)
呼び出し可能 (callable) な application をリクエストを受け取る WSGI アプリケーションとして設定します。

get_app()
現在設定されている呼び出し可能 (callable) アプリケーションを返します。

しかしながら、通常はこれらの追加されたメソッドを使う必要はありません。 set_app() は普通は make_server() によって呼ばれ、 get_app() は主にリクエストハンドラインスタンスの便宜上存在するからです。

class wsgiref.simple_server.WSGIRequestHandler(request, client_address, server)
与えられた request （すなわちソケット）の HTTP ハンドラ、 client_address ((host,port) のタプル)、 server (WSGIServer インスタンス) の HTTP ハンドラを作成します。

このクラスのインスタンスを直接生成する必要はありません; これらは必要に応じて WSGIServer オブジェクトによって自動的に生成されます。しかしながら、このクラスをサブクラス化し、 make_server() 関数に handler_class として与えることは可能でしょう。サブクラスにおいてオーバーライドする意味のありそうなものは:

get_environ()
リクエストに対する WSGI 環境を含む辞書を返します。デフォルト実装では WSGIServer オブジェクトの base_environ 辞書属性のコンテンツをコピーし、それから HTTP リクエスト由来の様々なヘッダを追加しています。このメソッド呼び出し毎に、 PEP 3333 に指定されている関連する CGI 環境変数をすべて含む新規の辞書を返さなければいけません。

get_stderr()
wsgi.errors ストリームとして使われるオブジェクトを返します。デフォルト実装では単に sys.stderr を返します。

handle()
HTTP リクエストを処理します。デフォルト実装では実際の WGI アプリケーションインターフェースを実装するのに wsgiref.handlers クラスを使ってハンドラインスタンスを作成します。

wsgiref.validate --- WSGI 準拠チェッカー
WSGI アプリケーションのオブジェクト、フレームワーク、サーバまたはミドルウェアの作成時には、その新規のコードを wsgiref.validate を使って準拠の検証をすると便利です。このモジュールは WSGI サーバやゲートウェイと WSGI アプリケーションオブジェクト間の通信を検証する WSGI アプリケーションオブジェクトを作成する関数を提供し、双方のプロトコル準拠をチェックします。

このユーティリティは完全な PEP 3333 準拠を保証するものでないことは注意してください; このモジュールでエラーが出ないことは必ずしもエラーが存在しないことを意味しません。しかしこのモジュールがエラーを出したならば、ほぼ確実にサーバかアプリケーションのどちらかが 100% 準拠ではありません。

このモジュールは lan Bicking の "Python Paste" ライブラリの paste.lint モジュールをベースにしています。

wsgiref.validate.validator(application)
Wrap application and return a new WSGI application object. The returned application will forward all requests to the original application, and will check that both the application and the server invoking it are conforming to the WSGI specification and to RFC 2616.

何らかの非準拠が検出されると、 AssertionError 例外が送出されます; しかし、このエラーがどう扱われるかはサーバ依存であることに注意してください。例えば、 wsgiref.simple_server とその他 wsgiref.handlers ベースのサーバ（エラー処理メソッドが他のことをするようにオーバライドしていないもの）は単純にエラーが発生したというメッセージとトレースバックのダンプを sys.stderr やその他のエラーストリームに出力します。

このラッパは、疑わしいものの実際には PEP 3333 で禁止されていないかもしれない挙動を指摘するために warnings モジュールを使って出力を生成します。これらは Python のコマンドラインオプションや warnings API で抑制されなければ、 sys.stderr (wsgi.errors では ありません 。ただし、たまたま同一のオブジェクトだった場合を除く)に書き出されます。

使用例:

from wsgiref.validate import validator
from wsgiref.simple_server import make_server

# Our callable object which is intentionally not compliant to the
# standard, so the validator is going to break
def simple_app(environ, start_response):
    status = '200 OK'  # HTTP Status
    headers = [('Content-type', 'text/plain')]  # HTTP Headers
    start_response(status, headers)

    # This is going to break because we need to return a list, and
    # the validator is going to inform us
    return b"Hello World"

# This is the application wrapped in a validator
validator_app = validator(simple_app)

with make_server('', 8000, validator_app) as httpd:
    print("Listening on port 8000....")
    httpd.serve_forever()
wsgiref.handlers -- サーバ／ゲートウェイのベースクラス
このモジュールは WSGI サーバとゲートウェイ実装のベースハンドラクラスを提供します。これらのベースクラスは、CGI 風の環境と、それに加えて入力、出力そしてエラーストリームが与えられることで、WSGI アプリケーションとの通信の大部分を処理します。

class wsgiref.handlers.CGIHandler
sys.stdin、sys.stdout、sys.stderr そして os.environ 経由での CGI ベースの呼び出しです。これは、もしあなたが WSGI アプリケーションを持っていて、これを CGI スクリプトとして実行したい場合に有用です。単に CGIHandler().run(app) を起動してください。app はあなたが起動したい WSGI アプリケーションオブジェクトです。

このクラスは BaseCGIHandler のサブクラスで、これは wsgi.run_once を true、 wsgi.multithread を false、そして wsgi.multiprocess を true にセットし、常に sys と os を、必要な CGI ストリームと環境を取得するために使用します。

class wsgiref.handlers.IISCGIHandler
(IIS 7 以降の) 設定オプションの allowPathInfo や (IIS 7 より前の) メタベースの allowPathInfoForScriptMappings を設定せずに Microsoft の IIS Web サーバにデプロイするときに使う、 CGIHandler クラス以外の専用の選択肢です。

By default, IIS gives a PATH_INFO that duplicates the SCRIPT_NAME at the front, causing problems for WSGI applications that wish to implement routing. This handler strips any such duplicated path.

IIS can be configured to pass the correct PATH_INFO, but this causes another bug where PATH_TRANSLATED is wrong. Luckily this variable is rarely used and is not guaranteed by WSGI. On IIS<7, though, the setting can only be made on a vhost level, affecting all other script mappings, many of which break when exposed to the PATH_TRANSLATED bug. For this reason IIS<7 is almost never deployed with the fix (Even IIS7 rarely uses it because there is still no UI for it.).

There is no way for CGI code to tell whether the option was set, so a separate handler class is provided. It is used in the same way as CGIHandler, i.e., by calling IISCGIHandler().run(app), where app is the WSGI application object you wish to invoke.

バージョン 3.2 で追加.

class wsgiref.handlers.BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)
CGIHandler に似ていますが、 sys と os モジュールを使う代わりに CGI 環境と I/O ストリームを明示的に指定します。 multithread と multiprocess の値は、ハンドラインスタンスにより実行されるアプリケーションの wsgi.multithread と wsgi.multiprocess フラグの設定に使われます。

このクラスは SimpleHandler のサブクラスで、HTTP の "本サーバ" でないソフトウェアと使うことを意図しています。もしあなたが Status: ヘッダを HTTP ステータスを送信するのに使うようなゲートウェイプロトコルの実装（CGI、FastCGI、SCGIなど）を書いている場合、おそらく SimpleHandler ではなくこのクラスをサブクラス化するとよいでしょう。

class wsgiref.handlers.SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)
BaseCGIHandler と似ていますが、HTTP の本サーバと使うためにデザインされています。もしあなたが HTTP サーバ実装を書いている場合、おそらく BaseCGIHandler ではなくこのクラスをサブクラス化するとよいでしょう。

このクラスは BaseHandler のサブクラスです。これは __init__() 、 get_stdin() 、 get_stderr() 、 add_cgi_vars() 、 _write() 、 _flush() をオーバーライドして、コンストラクタから明示的に環境とストリームを設定するようにしています。与えられた環境とストリームは stdin 、 stdout 、 stderr それに environ 属性に保存されています。

The write() method of stdout should write each chunk in full, like io.BufferedIOBase.

class wsgiref.handlers.BaseHandler
これは WSGI アプリケーションを実行するための抽象ベースクラスです。それぞれのインスタンスは一つの HTTP リクエストを処理します。しかし原理上は複数のリクエスト用に再利用可能なサブクラスを作成することができます。

BaseHandler インスタンスは外部から利用されるたった一つのメソッドを持ちます:

run(app)
指定された WSGI アプリケーション、app を実行します。

その他のすべての BaseHandler のメソッドはアプリケーション実行プロセスでこのメソッドから呼ばれます。したがって、それらは主にそのプロセスのカスタマイズのために存在しています。

以下のメソッドはサブクラスでオーバーライドされなければいけません:

_write(data)
バイト列の data をクライアントへの転送用にバッファします。このメソッドが実際にデータを転送しても OK です: 下部システムが実際にそのような区別をしている場合に効率をより良くするために、 BaseHandler は書き出しとフラッシュ操作を分けているからです。

_flush()
バッファされたデータをクライアントに強制的に転送します。このメソッドは何もしなくても OK です（すなわち、 _write() が実際にデータを送る場合）。

get_stdin()
現在処理中のリクエストの wsgi.input としての利用に適当な入力ストリームオブジェクトを返します。

get_stderr()
現在処理中のリクエストの wsgi.errors としての利用に適当な出力ストリームオブジェクトを返します。

add_cgi_vars()
現在のリクエストの CGI 変数を environ 属性に追加します。

オーバーライドされることの多いメソッド及び属性を以下に挙げます。しかし、このリストは単にサマリであり、オーバーライド可能なすべてのメソッドは含んでいません。カスタマイズした BaseHandler サブクラスを作成しようとする前に docstring やソースコードでさらなる情報を調べてください。

WSGI 環境のカスタマイズのための属性とメソッド:

wsgi_multithread
wsgi.multithread 環境変数で使われる値。 BaseHandler ではデフォルトが true ですが、別のサブクラスではデフォルトで（またはコンストラクタによって設定されて）異なる値を持つことがあります。

wsgi_multiprocess
wsgi.multiprocess 環境変数で使われる値。 BaseHandler ではデフォルトが true ですが、別のサブクラスではデフォルトで（またはコンストラクタによって設定されて）異なる値を持つことがあります。

wsgi_run_once
wsgi.run_once 環境変数で使われる値。 BaseHandler ではデフォルトが false ですが、 CGIHandler はデフォルトでこれを true に設定します。

os_environ
すべてのリクエストの WSGI 環境に含まれるデフォルトの環境変数。デフォルトでは wsgiref.handlers がインポートされた時点の os.environ のコピーですが、サブクラスはクラスまたはインスタンスレベルでそれら自身のものを作ることができます。デフォルト値は複数のクラスとインスタンスで共有されるため、この辞書は読み出し専用と考えるべきだという点に注意してください。

server_software
origin_server 属性が設定されている場合、この属性の値がデフォルトの SERVER_SOFTWARE WSGI 環境変数の設定や HTTP レスポンス中のデフォルトの Server: ヘッダの設定に使われます。これは (BaseCGIHandler や CGIHandler のような) HTTP オリジンサーバでないハンドラでは無視されます。

バージョン 3.3 で変更: "Python" という語は "CPython" や "Jython" などのような個別実装の語に置き換えられました。

get_scheme()
現在のリクエストで使われている URL スキームを返します。デフォルト実装は wsgiref.util の guess_scheme() を使い、現在のリクエストの environ 変数に基づいてスキームが"http" か "https" かを推測します。

setup_environ()
environ 属性を、フル実装 (fully-populated) の WSGI 環境に設定します。デフォルトの実装は、上記すべてのメソッドと属性、加えて get_stdin() 、 get_stderr() 、 add_cgi_vars() メソッドと wsgi_file_wrapper 属性を利用します。これは、キーが存在せず、 origin_server 属性が true 値で server_software 属性も設定されている場合に SERVER_SOFTWARE を挿入します。

例外処理のカスタマイズのためのメソッドと属性:

log_exception(exc_info)
exc_info タプルをサーバログに記録します。exc_info は (type, value, traceback) のタプルです。デフォルトの実装は単純にトレースバックをリクエストの wsgi.errors ストリームに書き出してフラッシュします。サブクラスはこのメソッドをオーバーライドしてフォーマットを変更したり出力先の変更、トレースバックを管理者にメールしたりその他適切と思われるいかなるアクションも取ることができます。

traceback_limit
デフォルトの log_exception() メソッドで出力されるトレースバック出力に含まれる最大のフレーム数です。 None ならば、すべてのフレームが含まれます。

error_output(environ, start_response)
このメソッドは、ユーザに対してエラーページを出力する WSGI アプリケーションです。これはクライアントにヘッダが送出される前にエラーが発生した場合にのみ呼び出されます。

このメソッドは sys.exc_info() を使って現在のエラー情報にアクセスでき、その情報はこれを呼ぶときに start_response に渡すべきです (PEP 3333 の "Error Handling" セクションに記述があります)。

デフォルト実装は単に error_status 、 error_headers 、 error_body 属性を出力ページの生成に使います。サブクラスではこれをオーバーライドしてもっと動的なエラー出力をすることができます。

しかし、セキュリティの観点からは診断をあらゆるユーザに吐き出すことは推奨されないことに気をつけてください; 理想的には、診断的な出力を有効にするには何らかの特別なことをする必要があるようにすべきで、これがデフォルト実装では何も含まれていない理由です。

error_status
エラーレスポンスで使われる HTTP ステータスです。これは PEP 3333 で定義されているステータス文字列です; デフォルトは 500 コードとメッセージです。

error_headers
エラーレスポンスで使われる HTTP ヘッダです。これは PEP 3333 で述べられているような、 WSGI レスポンスヘッダ ((name, value) タプル) のリストであるべきです。デフォルトのリストはコンテントタイプを text/plain にセットしているだけです。

error_body
エラーレスポンスボディ。これは HTTP レスポンスのボディバイト文字列であるべきです。これはデフォルトではプレーンテキストで "A server error occurred. Please contact the administrator." です。

PEP 3333 の "オプションのプラットフォーム固有のファイルハンドリング" 機能のためのメソッドと属性:

wsgi_file_wrapper
wsgi.file_wrapper ファクトリ、または None です。この属性のデフォルト値は wsgiref.util.FileWrapper クラスです。

sendfile()
オーバーライドしてプラットフォーム固有のファイル転送を実装します。このメソッドはアプリケーションの戻り値が wsgi_file_wrapper 属性で指定されたクラスのインスタンスの場合にのみ呼ばれます。これはファイルの転送が成功できた場合には true を返して、デフォルトの転送コードが実行されないようにするべきです。このデフォルトの実装は単に false 値を返します。

その他のメソッドと属性:

origin_server
この属性はハンドラの _write() と _flush() が、特別に Status: ヘッダに HTTP ステータスを求めるような CGI 風のゲートウェイプロトコル経由でなく、クライアントと直接通信をするような場合には true 値に設定されているべきです。

この属性のデフォルト値は BaseHandler では true ですが、 BaseCGIHandler と CGIHandler では false です。

http_version
origin_server が true の場合、この文字列属性はクライアントへのレスポンスセットの HTTP バージョンの設定に使われます。デフォルトは "1.0" です。

wsgiref.handlers.read_environ()
Transcode CGI variables from os.environ to PEP 3333 "bytes in unicode" strings, returning a new dictionary. This function is used by CGIHandler and IISCGIHandler in place of directly using os.environ, which is not necessarily WSGI-compliant on all platforms and web servers using Python 3 -- specifically, ones where the OS's actual environment is Unicode (i.e. Windows), or ones where the environment is bytes, but the system encoding used by Python to decode it is anything other than ISO-8859-1 (e.g. Unix systems using UTF-8).

If you are implementing a CGI-based handler of your own, you probably want to use this routine instead of just copying values out of os.environ directly.

バージョン 3.2 で追加.

使用例
これは動作する "Hello World" WSGIアプリケーションです:

from wsgiref.simple_server import make_server

# Every WSGI application must have an application object - a callable
# object that accepts two arguments. For that purpose, we're going to
# use a function (note that you're not limited to a function, you can
# use a class for example). The first argument passed to the function
# is a dictionary containing CGI-style environment variables and the
# second variable is the callable object.
def hello_world_app(environ, start_response):
    status = '200 OK'  # HTTP Status
    headers = [('Content-type', 'text/plain; charset=utf-8')]  # HTTP Headers
    start_response(status, headers)

    # The returned object is going to be printed
    return [b"Hello World"]

with make_server('', 8000, hello_world_app) as httpd:
    print("Serving on port 8000...")

    # Serve until process is killed
    httpd.serve_forever()
Example of a WSGI application serving the current directory, accept optional directory and port number (default: 8000) on the command line:

#!/usr/bin/env python3
'''
Small wsgiref based web server. Takes a path to serve from and an
optional port number (defaults to 8000), then tries to serve files.
Mime types are guessed from the file names, 404 errors are raised
if the file is not found. Used for the make serve target in Doc.
'''
import sys
import os
import mimetypes
from wsgiref import simple_server, util

def app(environ, respond):

    fn = os.path.join(path, environ['PATH_INFO'][1:])
    if '.' not in fn.split(os.path.sep)[-1]:
        fn = os.path.join(fn, 'index.html')
    type = mimetypes.guess_type(fn)[0]

    if os.path.exists(fn):
        respond('200 OK', [('Content-Type', type)])
        return util.FileWrapper(open(fn, "rb"))
    else:
        respond('404 Not Found', [('Content-Type', 'text/plain')])
        return [b'not found']

if __name__ == '__main__':
    path = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000
    httpd = simple_server.make_server('', port, app)
    print("Serving {} on port {}, control-C to stop".format(path, port))
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("Shutting down.")
        httpd.server_close()

urllib --- URL を扱うモジュール群¶
ソースコード: Lib/urllib/

urllib は URL を扱う幾つかのモジュールを集めたパッケージです:

urllib.request は URL を開いて読むためのモジュールです

urllib.error は urllib.request が発生させる例外を持っています

urllib.parse は URL をパースするためのモジュールです

urllib.robotparser は robots.txt ファイルをパースするためのモジュールです

urllib.request --- URL を開くための拡張可能なライブラリ¶
ソースコード: Lib/urllib/request.py

urllib.request モジュールは基本的な認証、暗号化認証、リダイレクション、Cookie、その他の介在する複雑なアクセス環境において (大抵は HTTP で) URL を開くための関数とクラスを定義します。

参考 より高水準のHTTPクライアントインターフェースとして Requests package <https://requests.readthedocs.io/en/master/> がお奨めです。
urllib.request モジュールでは以下の関数を定義しています:

urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)
URL url を開きます。 url は文字列でも Request オブジェクトでもかまいません。

data はサーバーに送信する追加データを指定するオブジェクトであるか None である必要があります。詳細は Request を確認してください。

urllib.request モジュールは HTTP/1.1 を使用し、その HTTP リクエストに Connection:close ヘッダーを含みます。

任意引数 timeout には接続開始などのブロックする操作におけるタイムアウト時間を秒数で指定します (指定されなかった場合、グローバルのデフォルトタイムアウト時間が利用されます)。この引数は、 HTTP, HTTPS, FTP 接続でのみ有効です。

context を指定する場合は、様々な SSL オプションを記述する ssl.SSLContext インスタンスでなければなりません。 詳細は HTTPSConnection を参照してください。

任意引数 cafile および capath には HTTPS リクエストのための CA 証明書のセットを指定します。cafile には CA 証明書のリストを含む 1 個のファイルを指定し、capath にはハッシュ化された証明書ファイルが格納されたディレクトリを指定しなければなりません。より詳しい情報は ssl.SSLContext.load_verify_locations() を参照してください。

cadefault 引数は無視されます。

この関数は常にプロパティ url、 headers、および status を持ち、 コンテキストマネージャ として動作するオブジェクトを返します。これらのプロパティに関する詳細は urllib.response.addinfourl を確認してください。

HTTP および HTTPS URL の場合、この関数は、わずかに修正された http.client.HTTPResponse オブジェクトを返します。上記の3つの新しいメソッドに加えて、 msg 属性が HTTPResponse のドキュメンテーションで指定されているレスポンスヘッダーの代わりに reason 属性 --- サーバーから返された reason フレーズ --- と同じ情報を含んでいます。

FTP 、ファイルおよびデータ URL 、レガシーな URLopener や FancyURLopener によって明示的に扱われるリクエストの場合、この関数は urllib.response.addinfourl オブジェクトを返します。

プロトコルエラー発生時は URLError を送出します。

どのハンドラもリクエストを処理しなかった場合には None を返すことがあるので注意してください (デフォルトでインストールされる グローバルハンドラの OpenerDirector は、 UnknownHandler を使って上記の問題が起きないようにしています)。

さらに、プロキシ設定が検出された場合(例えば http_proxy のような *_proxy 環境変数がセットされているなど)には ProxyHandler がデフォルトでインストールされ、これがプロキシを通してリクエストを処理するようにしています。

Python 2.6 以前のレガシーな urllib.urlopen 関数は廃止されました。urllib.request.urlopen() が過去の urllib2.urlopen に相当します。urllib.urlopen において辞書型オブジェクトで渡していたプロキシの扱いは、ProxyHandler オブジェクトを使用して取得できます。

The default opener raises an auditing event urllib.Request with arguments fullurl, data, headers, method taken from the request object.

バージョン 3.2 で変更: cafile および capath が追加されました。

バージョン 3.2 で変更: HTTPS バーチャルホストがサポートされました (ssl.HAS_SNI が真の場合のみ)。

バージョン 3.2 で追加: data にイテラブルなオブジェクトを指定できるようになりました。

バージョン 3.3 で変更: cadefault が追加されました。

バージョン 3.4.3 で変更: context が追加されました。

バージョン 3.6 で非推奨: cafile, capath and cadefault are deprecated in favor of context. Please use ssl.SSLContext.load_cert_chain() instead, or let ssl.create_default_context() select the system's trusted CA certificates for you.

urllib.request.install_opener(opener)
指定された OpenerDirector のインスタンスを、デフォルトで利用されるグローバルの opener としてインストールします。 opener のインストールは、 urlopen にその opener を使って欲しいとき以外必要ありません。普段は単に urlopen() の代わりに OpenerDirector.open() を利用してください。この関数は引数が本当に OpenerDirector のインスタンスであるかどうかはチェックしません。適切なインタフェースを持った任意のクラスを利用することができます。

urllib.request.build_opener([handler, ...])
与えられた順番に URL ハンドラを連鎖させる OpenerDirector のインスタンスを返します。 handler は BaseHandler または BaseHandler のサブクラスのインスタンスのどちらかです (どちらの場合も、コンストラクトは引数無しで呼び出せるようになっていなければなりません) 。クラス ProxyHandler (proxy 設定が検出された場合), UnknownHandler, HTTPHandler, HTTPDefaultErrorHandler, HTTPRedirectHandler, FTPHandler, FileHandler, HTTPErrorProcessor については、そのクラスのインスタンスか、そのサブクラスのインスタンスが handler に含まれていない限り、 handler よりも先に連鎖します。

Python が SSL をサポートするように設定してインストールされている場合 (すなわち、 ssl モジュールを import できる場合) HTTPSHandler も追加されます。

BaseHandler サブクラスでも handler_order メンバー変数を変更して、ハンドラーリスト内での場所を変更できます。

urllib.request.pathname2url(path)
ローカルシステムにおける記法で表されたパス名 path をURL におけるパス部分の形式に変換します。これは完全な URL を生成するわけではありません。戻り値は quote() 関数によってクオートされています。

urllib.request.url2pathname(path)
URL の、パーセントエンコードされたパス部分 path をローカルシステムの記法に変換します。これは完全な URL を受け付けません。path のデコードには unquote() 関数を使用します。

urllib.request.getproxies()
このヘルパー関数はスキーマからプロキシサーバーのURLへのマッピングを行う辞書を返します。この関数はまず、どのOSでも最初に <scheme>_proxy という名前の環境変数を大文字小文字を区別せずにスキャンします。そこで見つからなかった場合、 Max OS X の場合は Mac OSX システム環境設定を、 Windows の場合はシステムレジストリを参照します。もし小文字と大文字の環境変数が両方存在する (そして値が一致しない) なら、小文字の環境変数が優先されます。

注釈 もし環境変数 REQUEST_METHOD が設定されていたら (これは通常スクリプトが CGI 環境で動いていることを示しています)、環境変数 HTTP_PROXY (大文字の _PROXY) は無視されます。その理由は、クライアントが "Proxy:" HTTP ヘッダーを使ってこの環境変数を注入できるからです。もし CGI 環境で HTTP プロキシを使う必要があれば、 ProxyHandler を明示的に使用するか、環境変数名を小文字にしてください (あるいは、少なくともサフィックスを _proxy にしてください) 。
以下のクラスが提供されています:

class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)
このクラスは URL リクエストを抽象化したものです。

url は有効な URL を指す文字列でなくてはなりません。

data must be an object specifying additional data to send to the server, or None if no such data is needed. Currently HTTP requests are the only ones that use data. The supported object types include bytes, file-like objects, and iterables of bytes-like objects. If no Content-Length nor Transfer-Encoding header field has been provided, HTTPHandler will set these headers according to the type of data. Content-Length will be used to send bytes objects, while Transfer-Encoding: chunked as specified in RFC 7230, Section 3.3.1 will be used to send files and other iterables.

For an HTTP POST request method, data should be a buffer in the standard application/x-www-form-urlencoded format. The urllib.parse.urlencode() function takes a mapping or sequence of 2-tuples and returns an ASCII string in this format. It should be encoded to bytes before being used as the data parameter.

headers は辞書でなければなりません。この辞書は add_header() を辞書のキーおよび値を引数として呼び出した時と同じように扱われます。この引数は、多くの場合ブラウザーが何であるかを特定する User-Agent ヘッダーの値を "偽装" するために用いられます。これは一部の HTTP サーバーが、スクリプトからのアクセスを禁止するために一般的なブラウザーの User-Agent ヘッダーしか許可しないためです。例えば、 Mozilla Firefox は User-Agent に "Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11" のように設定し、 urllib はデフォルトで "Python-urllib/2.6" (Python 2.6の場合) と設定します。

An appropriate Content-Type header should be included if the data argument is present. If this header has not been provided and data is not None, Content-Type: application/x-www-form-urlencoded will be added as a default.

The next two arguments are only of interest for correct handling of third-party HTTP cookies:

origin_req_host は、 RFC 2965 で定義されている元のトランザクションにおけるリクエストホスト (request-host of the origin transaction) です。デフォルトの値は http.cookiejar.request_host(self) です。この値は、ユーザーによって開始された元々のリクエストにおけるホスト名や IP アドレスです。例えば、もしリクエストがある HTML ドキュメント内の画像を指していれば、この値は画像を含んでいるページへのリクエストにおけるリクエストホストになるはずです。

unverifiable should indicate whether the request is unverifiable, as defined by RFC 2965. It defaults to False. An unverifiable request is one whose URL the user did not have the option to approve. For example, if the request is for an image in an HTML document, and the user had no option to approve the automatic fetching of the image, this should be true.

method should be a string that indicates the HTTP request method that will be used (e.g. 'HEAD'). If provided, its value is stored in the method attribute and is used by get_method(). The default is 'GET' if data is None or 'POST' otherwise. Subclasses may indicate a different default method by setting the method attribute in the class itself.

注釈 The request will not work as expected if the data object is unable to deliver its content more than once (e.g. a file or an iterable that can produce the content only once) and the request is retried for HTTP redirects or authentication. The data is sent to the HTTP server right away after the headers. There is no support for a 100-continue expectation in the library.
バージョン 3.3 で変更: 引数 Request.method が Request クラスに追加されました。

バージョン 3.4 で変更: Request.method のデフォルト値はクラスレベルで指定されることがあります。

バージョン 3.6 で変更: Do not raise an error if the Content-Length has not been provided and data is neither None nor a bytes object. Fall back to use chunked transfer encoding instead.

class urllib.request.OpenerDirector
OpenerDirector クラスは、 BaseHandler の連鎖的に呼び出して URL を開きます。このクラスはハンドラをどのように連鎖させるか、またどのようにエラーをリカバリするかを管理します。

class urllib.request.BaseHandler
このクラスはハンドラ連鎖に登録される全てのハンドラがベースとしているクラスです -- このクラスでは登録のための単純なメカニズムだけを扱います。

class urllib.request.HTTPDefaultErrorHandler
HTTP エラーレスポンスのデフォルトハンドラーを定義するクラスです; すべてのレスポンスは HTTPError 例外に変換されます。

class urllib.request.HTTPRedirectHandler
リダイレクションを扱うクラスです。

class urllib.request.HTTPCookieProcessor(cookiejar=None)
HTTP Cookie を扱うためのクラスです。

class urllib.request.ProxyHandler(proxies=None)
Cause requests to go through a proxy. If proxies is given, it must be a dictionary mapping protocol names to URLs of proxies. The default is to read the list of proxies from the environment variables <protocol>_proxy. If no proxy environment variables are set, then in a Windows environment proxy settings are obtained from the registry's Internet Settings section, and in a Mac OS X environment proxy information is retrieved from the OS X System Configuration Framework.

自動検出されたproxyを無効にするには、空の辞書を渡してください。

no_proxy 環境変数は、proxyを利用せずにアクセスするべきホストを指定するために利用されます。設定する場合は、カンマ区切りの、ホストネーム suffix のリストで、オプションとして :port を付けることができます。例えば、 cern.ch,ncsa.uiuc.edu,some.host:8080.

注釈 変数 REQUEST_METHOD が設定されている場合、 HTTP_PROXY は無視されます; getproxies() のドキュメンテーションを参照してください。
class urllib.request.HTTPPasswordMgr
(realm, uri) -> (user, password) の対応付けデータベースを保持します。

class urllib.request.HTTPPasswordMgrWithDefaultRealm
(realm, uri) -> (user, password) の対応付けデータベースを保持します。レルム None はその他諸々のレルムを表し、他のレルムが該当しない場合に検索されます。

class urllib.request.HTTPPasswordMgrWithPriorAuth
uri -> is_authenticated マッピングのデータベースも持つ HTTPPasswordMgrWithDefaultRealm のバリエーションです。最初に 401 レスポンスを待つのではなく直ちに認証情報を送るときの条件を判断するために、 BasicAuth ハンドラによって使われます。

バージョン 3.5 で追加.

class urllib.request.AbstractBasicAuthHandler(password_mgr=None)
これは、リモートホストとプロキシの両方に対して HTTP 認証を行うことを助ける mixin クラスです。 password_mgr は、もし与えられたら HTTPPasswordMgr と互換性のあるオブジェクトでなければなりません; サポートすべきインタフェースに関する情報は HTTPPasswordMgr オブジェクト 節を参照してください。もし passwd_mgr が is_authenticated と update_authenticated メソッドも提供するなら (HTTPPasswordMgrWithPriorAuth オブジェクト を参照)、ハンドラは与えられた URI に対する is_authenticated の結果を用いてリクエストにおいて認証情報を送るかどうかを決定します。もし is_authenticated がその URI に対して True を返すなら、認証情報が送られます。 is_authenticated が False なら認証情報は送られません。そして、もし 401 レスポンスを受け取ったら、認証情報を付けて改めてリクエストが送信されます。もし認証が成功したら、それ以降その URI またはその親 URI に対して行われるリクエストが認証情報を自動的に含むように、 URI に対して is_authenticated を True に設定するために update_authenticated が呼ばれます。

バージョン 3.5 で追加: is_authenticated サポートが追加されました。

class urllib.request.HTTPBasicAuthHandler(password_mgr=None)
遠隔ホストとの間での認証を扱います。 password_mgr を与える場合、 HTTPPasswordMgr と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション HTTPPasswordMgr オブジェクト を参照してください。HTTPBasicAuthHandler は、間違った認証スキーマが与えられると ValueError を送出します。

class urllib.request.ProxyBasicAuthHandler(password_mgr=None)
プロキシとの間での認証を扱います。 password_mgr を与える場合、 HTTPPasswordMgr と互換性が なければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション HTTPPasswordMgr オブジェクト を参照してください。

class urllib.request.AbstractDigestAuthHandler(password_mgr=None)
このクラスはHTTP 認証を補助するための混ぜ込みクラス (mixin class) です。遠隔ホストとプロキシの両方に対応しています。 password_mgr を与える場合、 HTTPPasswordMgr と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション HTTPPasswordMgr オブジェクト を参照してください。

class urllib.request.HTTPDigestAuthHandler(password_mgr=None)
リモートホストとの認証を扱います。password_mgr を与える場合、HTTPPasswordMgr と互換性のあるものでなければなりません。サポートしなければならないインターフェースについての情報は HTTPPasswordMgr オブジェクト 節を参照してください。Digest 認証ハンドラーと Basic 認証ハンドラーの両方が追加された場合、常に Digest 認証を先に試みます。Digest 認証が 40x のレスポンスを再び返すと、Basic 認証ハンドラーに送信されます。このハンドラーメソッドは、Digest および Basic 以外の認証スキームが存在する場合は ValueError を送出します。

バージョン 3.3 で変更: 未サポートの認証スキームでは ValueError を送出するようになりました。

class urllib.request.ProxyDigestAuthHandler(password_mgr=None)
プロキシとの間での認証を扱います。 password_mgr を与える場合、 HTTPPasswordMgr と互換性が なければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション HTTPPasswordMgr オブジェクト を参照してください。

class urllib.request.HTTPHandler
HTTP の URL を開きます。

class urllib.request.HTTPSHandler(debuglevel=0, context=None, check_hostname=None)
HTTPS で URL を開きます。context および check_hostname は http.client.HTTPSConnection のものと同じ意味です。

バージョン 3.2 で変更: context および check_hostname が追加されました。

class urllib.request.FileHandler
ローカルファイルを開きます。

class urllib.request.DataHandler
data URL を開きます。

バージョン 3.4 で追加.

class urllib.request.FTPHandler
FTP の URL を開きます。

class urllib.request.CacheFTPHandler
FTP の URL を開きます。遅延を最小限にするために、開かれている FTP 接続に対するキャッシュを保持します。

class urllib.request.UnknownHandler
その他諸々のためのクラスで、未知のプロトコルの URL を開きます。

class urllib.request.HTTPErrorProcessor
HTTP エラー応答の処理をします。

Request オブジェクト
以下のメソッドは Request の公開インターフェースについて説明しています。これらはすべてサブクラスでオーバーライドできます。また、解析したリクエストを調査するためにクライアントで使用するいくつかの属性も定義します。

Request.full_url
コンストラクターに渡されたオリジナルの URL です。

バージョン 3.4 で変更.

Request.full_url は、 setter, getter, deleter を持つプロパティです。もし存在すれば、 full_url はオリジナルのリクエスト URL フラグメント付きで返します。

Request.type
URI スキームです。

Request.host
URI オーソリティです。通常はホスト名ですが、コロンで区切られたポート番号が付随することもあります。

Request.origin_req_host
リクエストしたオリジナルのホスト名です。ポート番号はつきません。

Request.selector
URI パスです。Request がプロキシを使用する場合、セレクターはプロキシに渡される完全な URL になります。

Request.data
リクエストのエンティティボディか、指定されない場合は None になります。

バージョン 3.4 で変更: Request.data の値が変更されると、もしそれ以前に "Content-Length" ヘッダーの値が設定または計算されていたらヘッダーが削除されるようになりました。

Request.unverifiable
boolean, indicates whether the request is unverifiable as defined by RFC 2965.

Request.method
HTTP リクエストで使うメソッドです。 デフォルト値は None で、このときは使うメソッドを get_method() が通常の方法で決定するということになります。 この値を設定する (従って get_method() のデフォルトの決定を上書きする) 方法は、 Request サブクラスでのクラスレベルの設定処理でデフォルト値を提供するか、 Request のコンストラクタの method 引数へ値を渡すかです。

バージョン 3.3 で追加.

バージョン 3.4 で変更: サブクラスでデフォルト値が設定できるようになりました; 以前はコンストラクタ引数からしか設定できませんでした。

Request.get_method()
HTTP リクエストメソッドを示す文字列を返します。Request.method が None でなければその値を返します。そうでない場合、Request.data が None なら 'GET' を、そうでなければ 'POST' を返します。これは HTTP リクエストに対してのみ意味を持ちます。

バージョン 3.3 で変更: get_method は Request.method の値を参照するようになりました。

Request.add_header(key, val)
リクエストに新たなヘッダーを追加します。ヘッダーは HTTP ハンドラ以外のハンドラでは無視されます。HTTP ハンドラでは、引数はサーバに送信される ヘッダーのリストに追加されます。同じ名前を持つヘッダを 2 つ以上持つことはできず、 key の衝突が生じた場合、後で追加したヘッダーが前に 追加したヘッダーを上書きします。現時点では、この機能は HTTP の機能を損ねることはありません。というのは、複数回呼び出したときに意味を 持つようなヘッダーには、どれもただ一つのヘッダーを使って同じ機能を果たすための (ヘッダー特有の) 方法があるからです。

Request.add_unredirected_header(key, header)
リダイレクトされたリクエストには追加されないヘッダーを追加します。

Request.has_header(header)
インスタンスが名前つきヘッダーであるかどうかを (通常のヘッダーと非リダイレクトヘッダの両方を調べて) 返します。

Request.remove_header(header)
リクエストインスタンス (の通常のヘッダーと非リダイレクトヘッダーの両方) から名前つきヘッダーを削除します。

バージョン 3.4 で追加.

Request.get_full_url()
コンストラクタで与えられた URL を返します。

バージョン 3.4 で変更.

Request.full_url を返します。

Request.set_proxy(host, type)
リクエストがプロキシサーバを経由するように準備します。 host および type はインスタンスのもとの設定と置き換えられ ます。インスタンスのセレクタはコンストラクタに与えたもともとの URL になります。

Request.get_header(header_name, default=None)
指定されたヘッダーの値を返します。ヘッダーがない場合は、 default の値を返します。

Request.header_items()
リクエストヘッダーの値を、タプル (header_name, header_value) のリストで返します。

バージョン 3.4 で変更: 3.3 から非推奨だった Request オブジェクトのメソッド add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host, is_unverifiable が削除されました。

OpenerDirector オブジェクト
OpenerDirector インスタンスは以下のメソッドを持っています:

OpenerDirector.add_handler(handler)
handler should be an instance of BaseHandler. The following methods are searched, and added to the possible chains (note that HTTP errors are a special case). Note that, in the following, protocol should be replaced with the actual protocol to handle, for example http_response() would be the HTTP protocol response handler. Also type should be replaced with the actual HTTP code, for example http_error_404() would handle HTTP 404 errors.

<protocol>_open() --- signal that the handler knows how to open protocol URLs.

See BaseHandler.<protocol>_open() for more information.

http_error_<type>() --- signal that the handler knows how to handle HTTP errors with HTTP error code type.

See BaseHandler.http_error_<nnn>() for more information.

<protocol>_error() --- signal that the handler knows how to handle errors from (non-http) protocol.

<protocol>_request() --- signal that the handler knows how to pre-process protocol requests.

See BaseHandler.<protocol>_request() for more information.

<protocol>_response() --- signal that the handler knows how to post-process protocol responses.

See BaseHandler.<protocol>_response() for more information.

OpenerDirector.open(url, data=None[, timeout])
与えられた url (リクエストオブジェクトでも文字列でもかまいません) を開きます。オプションとして data を与えることができます。 引数、戻り値、および送出される例外は urlopen() と同じです (urlopen() の場合、標準でインストールされている グローバルな OpenerDirector の open() メソッドを呼び出します) 。 オプションの timeout 引数は、接続開始のようなブロックする処理におけるタイムアウト時間を 秒数で指定します。(指定しなかった場合は、グローバルのデフォルト設定が利用されます) タイムアウト機能は、 HTTP, HTTPS, FTP 接続でのみ有効です。

OpenerDirector.error(proto, *args)
Handle an error of the given protocol. This will call the registered error handlers for the given protocol with the given arguments (which are protocol specific). The HTTP protocol is a special case which uses the HTTP response code to determine the specific error handler; refer to the http_error_<type>() methods of the handler classes.

戻り値および送出される例外は urlopen() と同じものです。

OpenerDirector オブジェクトは、以下の 3 つのステージに分けて URL を開きます:

各ステージで OpenerDirector オブジェクトのメソッドがどのような順で呼び出されるかは、ハンドラインスタンスの並び方で決まります。

Every handler with a method named like <protocol>_request() has that method called to pre-process the request.

Handlers with a method named like <protocol>_open() are called to handle the request. This stage ends when a handler either returns a non-None value (ie. a response), or raises an exception (usually URLError). Exceptions are allowed to propagate.

In fact, the above algorithm is first tried for methods named default_open(). If all such methods return None, the algorithm is repeated for methods named like <protocol>_open(). If all such methods return None, the algorithm is repeated for methods named unknown_open().

これらのメソッドの実装には、親となる OpenerDirector インスタンスの open() や error() といったメソッド呼び出しが入る場合があるので注意してください。

Every handler with a method named like <protocol>_response() has that method called to post-process the response.

BaseHandler オブジェクト
BaseHandler オブジェクトは直接的に役に立つ 2 つのメソッドと、その他として派生クラスで使われることを想定したメソッドを 提供します。以下は直接的に使うためのメソッドです:

BaseHandler.add_parent(director)
親オブジェクトとして、 director を追加します。

BaseHandler.close()
全ての親オブジェクトを削除します。

以下の属性およびメソッドは BaseHandler から派生したクラスでのみ使われます。

注釈 The convention has been adopted that subclasses defining <protocol>_request() or <protocol>_response() methods are named *Processor; all others are named *Handler.
BaseHandler.parent
有効な OpenerDirector です。この値は違うプロトコルを使って URL を開く場合やエラーを処理する際に使われます。

BaseHandler.default_open(req)
このメソッドは BaseHandler では定義されて いません 。しかし、全ての URL をキャッチさせたいなら、サブクラスで定義する 必要があります。

このメソッドが実装されていれば、OpenerDirector の親クラスによって呼び出されます。これは OpenerDirector の open() の戻り値で表されるファイルライクオブジェクトか、または None を返さなければならず、真に想定外の事態が発生した場合を除き、URLError を送出しなければなりません (例えば、MemoryError は URLError にマップしてはなりません)。

このメソッドはプロトコル固有のオープンメソッドが呼び出される前に呼び出されます。

BaseHandler.<protocol>_open(req)
このメソッドは BaseHandler では定義されて いません 。しかしプロトコルの URL をキャッチしたいなら、サブクラスで定義する必要があります。

このメソッドが定義されていた場合、 OpenerDirector から呼び出されます。戻り値は default_open() と同じでなければなりません。

BaseHandler.unknown_open(req)
このメソッドは BaseHandler では定義されて いません 。しかし URL を開くための特定のハンドラが登録されていないような URL をキャッチしたいなら、サブクラスで定義する必要があります。

このメソッドが定義されていた場合、 OpenerDirector から呼び出されます。戻り値は default_open() と同じでなければなりません。

BaseHandler.http_error_default(req, fp, code, msg, hdrs)
このメソッドは BaseHandler では定義されて いません 。しかしその他の処理されなかった HTTP エラーを処理する機能をもたせたいなら、サブクラスで定義する必要があります。このメソッドはエラーに遭遇した OpenerDirector から自動的に呼び出されます。その他の状況では普通呼び出すべきではありません。

req は Request オブジェクトで、 fp は HTTP エラー本体を読み出せるようなファイル類似のオブジェクトに なります。 code は 3 桁の 10 進数からなるエラーコードで、 msg ユーザ向けのエラーコード解説です。 hdrs は エラー応答のヘッダーをマップしたオブジェクトです。

返される値および送出される例外は urlopen() と同じものでなければなりません。

BaseHandler.http_error_<nnn>(req, fp, code, msg, hdrs)
nnn は 3 桁の 10 進数からなる HTTP エラーコードでなくてはなりません。このメソッドも BaseHandler では定義されていませんが、サブクラスのインスタンスで定義されていた場合、エラーコード nnn の HTTP エラーが発生した際に呼び出されます。

特定の HTTP エラーに対する処理を行うためには、このメソッドをサブクラスでオーバライドする必要があります。

引数、返される値、および送出される例外は http_error_default() と同じものでなければなりません。

BaseHandler.<protocol>_request(req)
このメソッドは BaseHandler では 定義されていません が、サブクラスで特定のプロトコルのリクエストのプリプロセスを行いたい場合には定義する必要があります。

このメソッドが定義されていると、親となる OpenerDirector から呼び出されます。その際、 req は Request オブジェクトになります。戻り値は Request オブジェクトでなければなりません。

BaseHandler.<protocol>_response(req, response)
このメソッドは BaseHandler では 定義されていません が、サブクラスで特定のプロトコルのリクエストのポストプロセスを行いたい場合には定義する必要があります。

このメソッドが定義されていると、親となる OpenerDirector から呼び出されます。その際、 req は Request オブジェクトになります。 response は urlopen() の戻り値と同じインタフェースを 実装したオブジェクトになります。戻り値もまた、 urlopen() の戻り値と同じインタフェースを実装したオブジェクトでなければなりません。

HTTPRedirectHandler オブジェクト
注釈 一部の HTTP リクエストはこのモジュールのクライアントモードからの操作を要求します。その場合、HTTPError が送出されます。さまざまなリダイレクションコードの正確な意味についての詳細は RFC 2616 を参照してください。
セキュリティ上の配慮として、HTTPRedirectHandler に HTTP、HTTPS、あるいは FTP の URL ではないリダイレクトされた URL が存在した場合、HTTPError 例外が送出されます。

HTTPRedirectHandler.redirect_request(req, fp, code, msg, hdrs, newurl)
リダイレクトへのレスポンスの Request または None を返します。これはサーバーからリダイレクションを受信した時に http_error_30*() メソッドのデフォルトの実装によって呼び出されます。リダイレクションを行わなければならない場合、newurl へのリダイレクトを実行するための http_error_30*() を許可する新しい Request を返します。その他の場合、この URL を扱うその他のハンドラーがない場合は HTTPError を、他のハンドラーでできそうな場合は None を返します。

注釈 このメソッドのデフォルトの実装は、 RFC 2616 に厳密に従ったものではありません。 RFC 2616 では、 POST リクエストに対する 301 および 302 応答が、ユーザの承認なく自動的にリダイレクトされてはならないと述べています。現実には、ブラウザは POST を GET に変更することで、これらの応答に対して自動的にリダイレクトを行えるようにしています。デフォルトの実装でも、この挙動を再現しています。
HTTPRedirectHandler.http_error_301(req, fp, code, msg, hdrs)
Location: か URI: のURL にリダイレクトします。このメソッドは HTTP における 'moved permanently' レスポンスを取得した際に 親オブジェクトとなる OpenerDirector によって呼び出されます。

HTTPRedirectHandler.http_error_302(req, fp, code, msg, hdrs)
http_error_301() と同じですが、'found' レスポンスに対して呼び出されます。

HTTPRedirectHandler.http_error_303(req, fp, code, msg, hdrs)
http_error_301() と同じですが、'see other' レスポンスに対して呼び出されます。

HTTPRedirectHandler.http_error_307(req, fp, code, msg, hdrs)
http_error_301() と同じですが、'temporary redirect' レスポンスに対して呼び出されます。

HTTPCookieProcessor オブジェクト
HTTPCookieProcessor インスタンスは属性をひとつだけ持ちます:

HTTPCookieProcessor.cookiejar
Cookie の入っている http.cookiejar.CookieJar オブジェクトです。

ProxyHandler オブジェクト
ProxyHandler.<protocol>_open(request)
The ProxyHandler will have a method <protocol>_open() for every protocol which has a proxy in the proxies dictionary given in the constructor. The method will modify requests to go through the proxy, by calling request.set_proxy(), and call the next handler in the chain to actually execute the protocol.

HTTPPasswordMgr オブジェクト
以下のメソッドは HTTPPasswordMgr および HTTPPasswordMgrWithDefaultRealm オブジェクトで利用できます。

HTTPPasswordMgr.add_password(realm, uri, user, passwd)
uri は単一の URI でも複数の URI からなるシーケンスでもかまいません。 realm 、 user および passwd は文字列でなくてはなりません。このメソッドによって、 realm と与えられた URI の上位 URI に対して (user, passwd) が認証トークンとして使われるようになります。

HTTPPasswordMgr.find_user_password(realm, authuri)
与えられたレルムおよび URI に対するユーザ名またはパスワードがあればそれを取得します。該当するユーザ名／パスワードが存在しない場合、このメソッドは (None, None) を返します。

HTTPPasswordMgrWithDefaultRealm オブジェクトでは、与えられた realm に対して該当するユーザ名/パスワードが存在しない場合、レルム None が検索されます。

HTTPPasswordMgrWithPriorAuth オブジェクト
このパスワードマネージャは HTTPPasswordMgrWithDefaultRealm を継承して、認証の証明書を常に送らないといけない URI を追跡する機能をサポートしています。

HTTPPasswordMgrWithPriorAuth.add_password(realm, uri, user, passwd, is_authenticated=False)
realm, uri, user, passwd は HTTPPasswordMgr.add_password() のものと同じです。 is_authenticated は、与えられた URI や URI のリストの is_authenticated フラグの初期値に設定されます。 is_authenticated に True を指定した場合は、 realm は無視されます。

HTTPPasswordMgrWithPriorAuth.find_user_password(realm, authuri)
HTTPPasswordMgrWithDefaultRealm オブジェクトに対する同名のメソッドと同じです。

HTTPPasswordMgrWithPriorAuth.update_authenticated(self, uri, is_authenticated=False)
与えられた url や URI のリストの is_authenticated フラグを更新します。

HTTPPasswordMgrWithPriorAuth.is_authenticated(self, authuri)
与えられた URI の is_authenticated フラグの現在の状態を返します。

AbstractBasicAuthHandler オブジェクト
AbstractBasicAuthHandler.http_error_auth_reqed(authreq, host, req, headers)
ユーザ名／パスワードを取得し、再度サーバへのリクエストを試みることで、サーバからの認証リクエストを処理します。 authreq はリクエストにおいて レルムに関する情報が含まれているヘッダーの名前、 host は認証を行う対象の URL とパスを指定します、 req は (失敗した) Request オブジェクト、そして headers はエラーヘッダーでなくてはなりません。

host は、オーソリティ (例 "python.org") か、オーソリティコンポーネントを含む URL (例 "http://python.org") です。どちらの場合も、オーソリティはユーザ情報コンポーネントを含んではいけません (なので、 "python.org" や "python.org:80" は正しく、 "joe:password@python.org" は不正です) 。

HTTPBasicAuthHandler オブジェクト
HTTPBasicAuthHandler.http_error_401(req, fp, code, msg, hdrs)
認証情報がある場合、認証情報付きで再度リクエストを試みます。

ProxyBasicAuthHandler オブジェクト
ProxyBasicAuthHandler.http_error_407(req, fp, code, msg, hdrs)
認証情報がある場合、認証情報付きで再度リクエストを試みます。

AbstractDigestAuthHandler オブジェクト
AbstractDigestAuthHandler.http_error_auth_reqed(authreq, host, req, headers)
authreq はリクエストにおいてレルムに関する情報が含まれているヘッダーの名前、 host は認証を行う対象のホスト名、 req は (失敗した) Request オブジェクト、そして headers はエラーヘッダーでなくてはなりません。

HTTPDigestAuthHandler オブジェクト
HTTPDigestAuthHandler.http_error_401(req, fp, code, msg, hdrs)
認証情報がある場合、認証情報付きで再度リクエストを試みます。

ProxyDigestAuthHandler オブジェクト
ProxyDigestAuthHandler.http_error_407(req, fp, code, msg, hdrs)
認証情報がある場合、認証情報付きで再度リクエストを試みます。

HTTPHandler オブジェクト
HTTPHandler.http_open(req)
HTTP リクエストを送ります。 req.has_data() に応じて、 GET または POST のどちらでも送ることができます。

HTTPSHandler オブジェクト
HTTPSHandler.https_open(req)
HTTPS リクエストを送ります。 req.has_data() に応じて、 GET または POST のどちらでも送ることができます。

FileHandler オブジェクト
FileHandler.file_open(req)
ホスト名がない場合、またはホスト名が 'localhost' の場合にファイルをローカルでオープンします。

バージョン 3.2 で変更: このメソッドはローカルのホスト名に対してのみ適用可能です。リモートホスト名が与えられた場合、URLError が送出されます。

DataHandler オブジェクト
DataHandler.data_open(req)
Read a data URL. This kind of URL contains the content encoded in the URL itself. The data URL syntax is specified in RFC 2397. This implementation ignores white spaces in base64 encoded data URLs so the URL may be wrapped in whatever source file it comes from. But even though some browsers don't mind about a missing padding at the end of a base64 encoded data URL, this implementation will raise an ValueError in that case.

FTPHandler オブジェクト
FTPHandler.ftp_open(req)
req で表されるファイルを FTP 越しにオープンします。ログインは常に空のユーザネームおよびパスワードで行われます。

CacheFTPHandler オブジェクト
CacheFTPHandler オブジェクトは FTPHandler オブジェクトに以下のメソッドを追加したものです:

CacheFTPHandler.setTimeout(t)
接続のタイムアウトを t 秒に設定します。

CacheFTPHandler.setMaxConns(m)
キャッシュ付き接続の最大接続数を m に設定します。

UnknownHandler オブジェクト
UnknownHandler.unknown_open()
URLError 例外を送出します。

HTTPErrorProcessor オブジェクト
HTTPErrorProcessor.http_response(request, response)
HTTP エラー応答の処理をします。

エラーコード 200 の場合、レスポンスオブジェクトを即座に返します。

For non-200 error codes, this simply passes the job on to the http_error_<type>() handler methods, via OpenerDirector.error(). Eventually, HTTPDefaultErrorHandler will raise an HTTPError if no other handler handles the error.

HTTPErrorProcessor.https_response(request, response)
HTTPS エラー応答の処理をします。

振る舞いは http_response() と同じです。

使用例
以下の例の他に urllib パッケージを使ってインターネット上のリソースを取得するには に多くの例があります。

以下の例では、python.org のメインページを取得して、その最初の 300 バイト分を表示します。

>>>
>>> import urllib.request
>>> with urllib.request.urlopen('http://www.python.org/') as f:
...     print(f.read(300))
...
b'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n\n\n<html
xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">\n\n<head>\n
<meta http-equiv="content-type" content="text/html; charset=utf-8" />\n
<title>Python Programming '
urlopen は bytes オブジェクトを返すことに注意してください。これは urlopen が、HTTP サーバーから受信したバイトストリームのエンコーディングを自動的に決定できないためです。一般に、返された bytes オブジェクトを文字列にデコードするためのエンコーディングの決定あるいは推測はプログラム側が行います。

以下の W3C ドキュメント https://www.w3.org/International/O-charsetには (X)HTML や XML ドキュメントでそのエンコーディング情報を指定するさまざまな方法の一覧があります。

python.org ウェブサイトでは utf-8 エンコーディングを使用しており、それをその meta タグで指定していますので、bytes オブジェクトのデコードも同様に行います。

>>>
>>> with urllib.request.urlopen('http://www.python.org/') as f:
...     print(f.read(100).decode('utf-8'))
...
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtm
コンテキストマネージャー を使用しないアプローチでも同様の結果を得ることができます。

>>>
>>> import urllib.request
>>> f = urllib.request.urlopen('http://www.python.org/')
>>> print(f.read(100).decode('utf-8'))
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtm
以下の例では、データストリームを CGI の標準入力へ送信し、返されたデータを読み込みます。この例は Python が SSL をサポートするように設定してインストールされている場合のみ動作します。

>>>
>>> import urllib.request
>>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',
...                       data=b'This data is passed to stdin of the CGI')
>>> with urllib.request.urlopen(req) as f:
...     print(f.read().decode('utf-8'))
...
Got Data: "This data is passed to stdin of the CGI"
上の例で使われているサンプルの CGI は以下のようになっています:

#!/usr/bin/env python
import sys
data = sys.stdin.read()
print('Content-type: text/plain\n\nGot Data: "%s"' % data)
これは Request を使った PUT リクエストの例です:

import urllib.request
DATA = b'some data'
req = urllib.request.Request(url='http://localhost:8080', data=DATA,method='PUT')
with urllib.request.urlopen(req) as f:
    pass
print(f.status)
print(f.reason)
以下はベーシック HTTP 認証の例です:

import urllib.request
# Create an OpenerDirector with support for Basic HTTP Authentication...
auth_handler = urllib.request.HTTPBasicAuthHandler()
auth_handler.add_password(realm='PDQ Application',
                          uri='https://mahler:8092/site-updates.py',
                          user='klem',
                          passwd='kadidd!ehopper')
opener = urllib.request.build_opener(auth_handler)
# ...and install it globally so it can be used with urlopen.
urllib.request.install_opener(opener)
urllib.request.urlopen('http://www.example.com/login.html')
build_opener() はデフォルトで沢山のハンドラを提供しており、その中に ProxyHandler があります。デフォルトでは、 ProxyHandler は <scheme>_proxy という環境変数を使います。 ここで <scheme> は URL スキームです。例えば、 HTTP プロキシの URL を得るには、環境変数 http_proxy を読み出します。

この例では、デフォルトの ProxyHandler を置き換えてプログラム的に作成したプロキシ URL を使うようにし、 ProxyBasicAuthHandler でプロキシ認証サポートを追加します。

proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})
proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password('realm', 'host', 'username', 'password')

opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
# This time, rather than install the OpenerDirector, we use it directly:
opener.open('http://www.example.com/login.html')
以下は HTTP ヘッダーを追加する例です:

headers 引数を使って Request コンストラクタを呼び出す方法の他に、以下のようにできます:

import urllib.request
req = urllib.request.Request('http://www.example.com/')
req.add_header('Referer', 'http://www.python.org/')
# Customize the default User-Agent header value:
req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')
r = urllib.request.urlopen(req)
OpenerDirector は全ての Request に User-Agent ヘッダーを自動的に追加します。これを変更するには以下のようにします:

import urllib.request
opener = urllib.request.build_opener()
opener.addheaders = [('User-agent', 'Mozilla/5.0')]
opener.open('http://www.example.com/')
また、 Request が urlopen() (や OpenerDirector.open())に渡される際には、いくつかの標準ヘッダー (Content-Length, Content-Type および Host) も追加されることを忘れないでください。

以下は GET メソッドを使ってパラメータを含む URL を取得するセッションの例です:

>>>
>>> import urllib.request
>>> import urllib.parse
>>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
>>> url = "http://www.musi-cal.com/cgi-bin/query?%s" % params
>>> with urllib.request.urlopen(url) as f:
...     print(f.read().decode('utf-8'))
...
以下の例では、POST メソッドを使用しています。urlencode から出力されたパラメーターは urlopen にデータとして渡される前に bytes にエンコードされていることに注意してください:

>>>
>>> import urllib.request
>>> import urllib.parse
>>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
>>> data = data.encode('ascii')
>>> with urllib.request.urlopen("http://requestb.in/xrbl82xr", data) as f:
...     print(f.read().decode('utf-8'))
...
以下の例では、環境変数による設定内容に対して上書きする形で HTTP プロキシを明示的に設定しています:

>>>
>>> import urllib.request
>>> proxies = {'http': 'http://proxy.example.com:8080/'}
>>> opener = urllib.request.FancyURLopener(proxies)
>>> with opener.open("http://www.python.org") as f:
...     f.read().decode('utf-8')
...
以下の例では、環境変数による設定内容に対して上書きする形で、まったくプロキシを使わないよう設定しています:

>>>
>>> import urllib.request
>>> opener = urllib.request.FancyURLopener({})
>>> with opener.open("http://www.python.org/") as f:
...     f.read().decode('utf-8')
...
レガシーインターフェース
以下の関数およびクラスは、Python 2 のモジュール urllib (urllib2 ではありません) から移植されたものです。これらは将来的に廃止されるかもしれません。

urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)
URL で表されるネットワークオブジェクトをローカルファイルにコピーします。 URL がローカルファイルを示している場合は、ファイル名が与えられない限りオブジェクトはコピーされません。戻り値はタプル (filename, headers) になり、 filename はオブジェクトが保存されたローカルファイル名、 headers は (リモートオブジェクトに対しては) urlopen() が返したオブジェクトの info() メソッドが返すものすべてになります。例外は urlopen() のものと同じになります。

The second argument, if present, specifies the file location to copy to (if absent, the location will be a tempfile with a generated name). The third argument, if present, is a callable that will be called once on establishment of the network connection and once after each block read thereafter. The callable will be passed three arguments; a count of blocks transferred so far, a block size in bytes, and the total size of the file. The third argument may be -1 on older FTP servers which do not return a file size in response to a retrieval request.

以下は最も一般的な使用例です:

>>>
>>> import urllib.request
>>> local_filename, headers = urllib.request.urlretrieve('http://python.org/')
>>> html = open(local_filename)
>>> html.close()
url が http: スキーム識別子を使用していた場合、任意の引数 data は POST リクエストの指定に使用される場合があります (通常のリクエストタイプは GET です)。引数 data は標準 application/x-www-form-urlencoded 形式のバイトオブジェクトでなければなりません。 urllib.parse.urlencode() 関数を参照してください。

urlretrieve() は、予想 (これは Content-Length ヘッダーにより通知されるサイズです) よりも取得できるデータ量が少ないことを検知した場合、 ContentTooShortError を発生します。これは、例えば、ダウンロードが中断された場合などに発生します。

Content-Length はデータ量の下限です: 読み込むデータ量がこれを超えている場合 urlretrieve はそれらも読み込みますが、利用できるデータがこれを下回った場合、例外が送出されます。

このような場合にもダウンロードされたデータを取得することは可能で、これは exception インスタンスの content 属性に保存されています。

Content-Length ヘッダーが与えられなれけば urlretrieve はダウンロードしたデータのサイズをチェックできません。この場合ダウンロードは正常に完了したとみなすしかありません。

urllib.request.urlcleanup()
以前の urlretrieve() 呼び出し後に残っているかもしれない一時ファイルをクリーンアップします。

class urllib.request.URLopener(proxies=None, **x509)
バージョン 3.3 で非推奨.

URL をオープンし、読み出すためのクラスの基底クラスです。http:, ftp:, file: 以外のスキームを使ったオブジェクトのオープンをサポートしたいのでないかぎり、FancyURLopener を使おうと思うことになるでしょう。

デフォルトでは、 URLopener クラスは User-Agent ヘッダーとして urllib/VVV を送信します。ここで VVV は urllib のバージョン番号です。アプリケーションで独自の User-Agent ヘッダーを送信したい場合は、 URLopener かまたは FancyURLopener のサブクラスを作成し、サブクラス定義においてクラス属性 version を適切な文字列値に設定することで行うことができます。

オプションのパラメーター proxies はスキーム名をプロキシの URL にマップする辞書でなければなりません。空の辞書はプロキシ機能を完全にオフにします。デフォルトの値は None で、この場合、 urlopen() の定義で述べたように、プロキシを設定する環境変数が存在するならそれを使います。

追加のキーワードパラメーターは x509 に集められますが、これは https: スキームを使った際のクライアント認証に使われることがあります。キーワード引数 key_file および cert_file が SSL 鍵と証明書を設定するためにサポートされています; クライアント認証をするには両方が必要です。

URLopener オブジェクトはサーバーがエラーコードを返した場合に OSError 例外を送出します。

open(fullurl, data=None)
適切なプロトコルを使って fullurl を開きます。このメソッドはキャッシュとプロキシ情報を設定し、その後適切な open メソッドを入力引数つきで呼び出します。認識できないスキームが与えられた場合、 open_unknown() が呼び出されます。 data 引数は urlopen() の引数 data と同じ意味を持っています。

This method always quotes fullurl using quote().

open_unknown(fullurl, data=None)
オーバライド可能な、未知のタイプの URL を開くためのインタフェースです。

retrieve(url, filename=None, reporthook=None, data=None)
url の内容を取得し、filename に保存します。戻り値は、ローカルファイル名と、レスポンスヘッダーが含まれる email.message.Message (リモート URL の場合) か None (ローカル URL の場合) からなるタプルになります。呼び出し側は、その後 filename を開いてその内容を読み込まなければなりません。filename が与えられず、URL がローカルファイルを参照している場合、入力ファイル名が返されます。URL がローカルでなく、filename が与えられていない場合、ファイル名は入力 URL のパスの最後の構成要素のサフィックスとマッチするサフィックスを持つ tempfile.mktemp() の出力になります。reporthook が与えられている場合、3 つの数値 (チャンク数、読み込んだチャンクの最大サイズ、および総ダウンロードサイズ --- 不明の場合は -1) の引数を受け取る関数でなければなりません。これは開始時に 1 回と、ネットワークからデータのチャンクを読み込む度に呼び出されます。reporthook はローカル URL に対しては無視されます。

url が http: スキーム識別子を使用していた場合、任意の引数 data は POST リクエストの指定に使用される場合があります (通常のリクエストタイプは GET です)。引数 data は標準 application/x-www-form-urlencoded 形式でなければなりません。urllib.parse.urlencode() 関数を参照してください。

version
URL をオープンするオブジェクトのユーザエージェントを指定する変数です。 urllib を特定のユーザエージェントであるとサーバに通知するには、サブクラスの中でこの値をクラス変数として値を設定するか、コンストラクタの中でベースクラスを呼び出す前に値を設定してください。

class urllib.request.FancyURLopener(...)
バージョン 3.3 で非推奨.

FancyURLopener は URLopener のサブクラスで、以下の HTTP レスポンスコード: 301、302、303、 307、および 401 を取り扱う機能を提供します。レスポンスコード 30x に対しては、 Location ヘッダーを使って実際の URL を取得します。レスポンスコード 401 (認証が要求されていることを示す) に対しては、BASIC認証 (basic HTTP authintication) が行われます。レスポンスコード 30x に対しては、最大で maxtries 属性に指定された数だけ再帰呼び出しを行うようになっています。この値はデフォルトで 10 です。

その他のレスポンスコードについては、 http_error_default() が呼ばれます。これはサブクラスでエラーを適切に処理するようにオーバーライドすることができます。

注釈 RFC 2616 によると、 POST 要求に対する 301 および 302 応答はユーザの承認無しに自動的にリダイレクトしてはなりません。実際は、これらの応答に対して自動リダイレクトを許すブラウザでは POST を GET に変更しており、 urllib でもこの動作を再現します。
コンストラクタに与えるパラメーターは URLopener と同じです。

注釈 基本的な HTTP 認証を行う際、 FancyURLopener インスタンスは prompt_user_passwd() メソッドを呼び出します。このメソッドはデフォルトでは実行を制御している端末上で認証に必要な情報を要求するように実装されています。必要ならば、このクラスのサブクラスにおいてより適切な動作をサポートするために prompt_user_passwd() メソッドをオーバライドしてもかまいません。
FancyURLopener クラスはオーバライド可能な追加のメソッドを提供しており、適切な振る舞いをさせることができます:

prompt_user_passwd(host, realm)
指定されたセキュリティ領域 (security realm) 下にある与えられたホストにおいて、ユーザー認証に必要な情報を返すための関数です。この関数が返す値は (user, password) からなるタプルでなければなりません。値は Basic 認証で使われます。

このクラスでの実装では、端末に情報を入力するようプロンプトを出します; ローカルの環境において適切な形で対話型モデルを使うには、このメソッドをオーバライドしなければなりません。

urllib.request の制限事項
現在、次のプロトコルのみサポートされています: HTTP (バージョン 0.9 および 1.0)、FTP、ローカルファイル、およびデータ URL

バージョン 3.4 で変更: データ URL サポートが追加されました。

urlretrieve() のキャッシュ機能は、誰かが Expiration time ヘッダーの正しい処理をハックする時間を見つけるまで無効にされています。

ある URL がキャッシュにあるかどうか調べるような関数があればと思っています。

後方互換性のため、 URL がローカルシステム上のファイルを指しているように見えるにも関わらずファイルを開くことができなければ、 URL は FTP プロトコルを使って再解釈されます。この機能は時として混乱を招くエラーメッセージを引き起こします。

関数 urlopen() および urlretrieve() は、ネットワーク接続が確立されるまでの間、一定でない長さの遅延を引き起こすことがあります。このことは、これらの関数を使ってインタラクティブな Web クライアントを構築するのはスレッドなしには難しいことを意味します。

urlopen() あるいは urlretrieve() が返すデータはサーバーから返された生データです。これは (画像のような) バイナリ、プレーンテキスト、あるいは (例えば) HTML などになります。HTTP プロトコルはレスポンスヘッダー内でタイプ情報を提供しており、Content-Type ヘッダーを見ることで調査できます。返されたデータが HTML の場合、モジュール html.parser を使用してこれを解析できます。

FTP プロトコルを扱うコードでは、ファイルとディレクトリを区別できません。このことから、アクセスできないファイルを指している URL からデータを読み出そうとすると、予期しない動作を引き起こす場合があります。 URL が / で終わっていれば、ディレクトリを指しているものとみなして、それに適した処理を行います。しかし、ファイルの読み出し操作が 550 エラー (URL が存在しないか、主にパーミッションの理由でアクセスできない) になった場合、 URL がディレクトリを指していて、末尾の / を忘れたケースを処理するため、パスをディレクトリとして扱います。このために、パーミッションのためにアクセスできないファイルを fetch しようとすると、FTP コードはそのファイルを開こうとして 550 エラーに陥り、次にディレクトリ一覧を表示しようとするため、誤解を生むような結果を引き起こす可能性があるのです。よく調整された制御が必要なら、 ftplib モジュールを使うか、 FancyURLopener をサブクラス化するか、 _urlopener を変更して目的に合わせるよう検討してください。

urllib.parse --- URL を解析して構成要素にする¶
ソースコード: Lib/urllib/parse.py

このモジュールでは URL (Uniform Resource Locator) 文字列をその構成要素 (アドレススキーム、ネットワーク上の位置、パスその他) に分解したり、構成要素を URL に組みなおしたり、 "相対 URL (relative URL)" を指定した "基底 URL (base URL)" に基づいて絶対 URL に変換するための標準的なインタフェースを定義しています。

このモジュールは Relative Uniform Resource Locators (相対 URL) に関するインターネット RFC に適合するよう設計されており、次の URL スキームをサポートしています: file, ftp, gopher, hdl, http, https, imap, mailto, mms, news, nntp, prospero, rsync, rtsp, rtspu, sftp, shttp, sip, sips, snews, svn, svn+ssh, telnet, wais, ws, wss

urllib.parse モジュールは、大きく分けると URL の解析を行う関数と URL のクオートを行う関数を定義しています。以下にこれらの詳細を説明します。

URL の解析
URL 解析関数は、URL 文字列を各構成要素に分割するか、あるいは URL の構成要素を組み合わせて URL 文字列を生成します。

urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)
Parse a URL into six components, returning a 6-item named tuple. This corresponds to the general structure of a URL: scheme://netloc/path;parameters?query#fragment. Each tuple item is a string, possibly empty. The components are not broken up into smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the path component, which is retained if present. For example:

>>>
from urllib.parse import urlparse
o = urlparse('http://www.cwi.nl:80/%7Eguido/Python.html')
o   
ParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
o.scheme
'http'
o.port
80
o.geturl()
'http://www.cwi.nl:80/%7Eguido/Python.html'
RFC 1808 にある文法仕様に基づき、urlparse は '//' で始まる場合にのみ netloc を認識します。それ以外の場合は、入力は相対URLであると推定され、path 部分で始まることになります。

>>> from urllib.parse import urlparse
>>> urlparse('//www.cwi.nl:80/%7Eguido/Python.html')
ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
>>> urlparse('www.cwi.nl/%7Eguido/Python.html')
ParseResult(scheme='', netloc='', path='www.cwi.nl/%7Eguido/Python.html',
            params='', query='', fragment='')
>>> urlparse('help/Python.html')
ParseResult(scheme='', netloc='', path='help/Python.html', params='',
            query='', fragment='')
scheme 引数によってデフォルトのアドレススキームを与えると、アドレススキームを指定していない URL のみに使用されます。常に許されるデフォルトの '' (b'' に自動変換出来る)を除き、 urlstring と同じ型(テキストもしくはバイト列)であるべきです。

引数 allow_fragments が false の場合、フラグメント識別子は認識されません。その代わり、それはパス、パラメータ、またはクエリ要素の一部として解析され、戻り値の fragment は空文字に設定されます。

戻り値は 名前付きタプル です。これは、インデックス指定もしくは以下のような名前属性で要素にアクセスできることを意味します:

属性

インデックス

値

指定されなかった場合の値

scheme

0

URL スキーム

scheme パラメータ

netloc

1

ネットワーク上の位置

空文字列

path

2

階層的パス

空文字列

params

3

最後のパス要素に対するパラメータ

空文字列

query

4

クエリ要素

空文字列

fragment

5

フラグメント識別子

空文字列

username

ユーザ名

None

password

パスワード

None

hostname

ホスト名 (小文字)

None

port

ポート番号を表わす整数 (もしあれば)

None

URL中で不正なポートが指定されている場合、 port 属性を読みだすと、ValueError を送出します。結果オブジェクトのより詳しい情報は 構造化された解析結果 節を参照してください。

netloc 属性にマッチしなかった角括弧があると ValueError を送出します。

Characters in the netloc attribute that decompose under NFKC normalization (as used by the IDNA encoding) into any of /, ?, #, @, or : will raise a ValueError. If the URL is decomposed before parsing, no error will be raised.

As is the case with all named tuples, the subclass has a few additional methods and attributes that are particularly useful. One such method is _replace(). The _replace() method will return a new ParseResult object replacing specified fields with new values.

>>> from urllib.parse import urlparse
>>> u = urlparse('//www.cwi.nl:80/%7Eguido/Python.html')
>>> u
ParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
>>> u._replace(scheme='http')
ParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',
            params='', query='', fragment='')
バージョン 3.2 で変更: IPv6 URL の解析も行えるようになりました。

バージョン 3.3 で変更: RFC 3986 に従い、fragment はすべての URL スキームに対して解析されるようになりました (allow_fragment が偽の場合は除く)。

バージョン 3.6 で変更: 範囲外のポート番号を指定すると、 None を返す代わりに、ValueError を送出するようになりました。

バージョン 3.8 で変更: Characters that affect netloc parsing under NFKC normalization will now raise ValueError.

urllib.parse.parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')
文字列引数として渡されたクエリ文字列 (application/x-www-form-urlencoded 型のデータ) を解析します。解析されたデータを辞書として返します。辞書のキーは一意なクエリ変数名で、値は各変数名に対する値からなるリストです。

任意の引数 keep_blank_values は、パーセントエンコードされたクエリの中の値が入っていないクエリの値を空白文字列と見なすかどうかを示すフラグです。値が真であれば、値の入っていないフィールドは空文字列のままになります。標準では偽で、値の入っていないフィールドを無視し、そのフィールドはクエリに含まれていないものとして扱います。

任意の引数 strict_parsing はパース時のエラーをどう扱うかを決めるフラグです。値が偽なら (デフォルトの設定です)、エラーは暗黙のうちに無視します。値が真なら ValueError 例外を送出します。

任意のパラメータ encoding および errors はパーセントエンコードされたシーケンスを Unicode 文字にデコードする方法を指定します。これは bytes.decode() メソッドに渡されます。

The optional argument max_num_fields is the maximum number of fields to read. If set, then throws a ValueError if there are more than max_num_fields fields read.

The optional argument separator is the symbol to use for separating the query arguments. It defaults to &.

このような辞書をクエリ文字列に変換するには urllib.parse.urlencode() 関数を (doseq パラメータに True を指定して) 使用します。

バージョン 3.2 で変更: encoding および errors パラメータが追加されました。

バージョン 3.8 で変更: Added max_num_fields parameter.

バージョン 3.9.2 で変更: Added separator parameter with the default value of &. Python versions earlier than Python 3.9.2 allowed using both ; and & as query parameter separator. This has been changed to allow only a single separator key, with & as the default separator.

urllib.parse.parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')
文字列引数として渡されたクエリ文字列 (application/x-www-form-urlencoded 型のデータ) を解析します。解析されたデータは名前と値のペアからなるリストです。

任意の引数 keep_blank_values は、パーセントエンコードされたクエリの中の値が入っていないクエリの値を空白文字列と見なすかどうかを示すフラグです。値が真であれば、値の入っていないフィールドは空文字列のままになります。標準では偽で、値の入っていないフィールドを無視し、そのフィールドはクエリに含まれていないものとして扱います。

任意の引数 strict_parsing はパース時のエラーをどう扱うかを決めるフラグです。値が偽なら (デフォルトの設定です)、エラーは暗黙のうちに無視します。値が真なら ValueError 例外を送出します。

任意のパラメータ encoding および errors はパーセントエンコードされたシーケンスを Unicode 文字にデコードする方法を指定します。これは bytes.decode() メソッドに渡されます。

The optional argument max_num_fields is the maximum number of fields to read. If set, then throws a ValueError if there are more than max_num_fields fields read.

The optional argument separator is the symbol to use for separating the query arguments. It defaults to &.

ペアのリストからクエリ文字列を生成する場合には urllib.parse.urlencode() 関数を使用します。

バージョン 3.2 で変更: encoding および errors パラメータが追加されました。

バージョン 3.8 で変更: Added max_num_fields parameter.

バージョン 3.9.2 で変更: Added separator parameter with the default value of &. Python versions earlier than Python 3.9.2 allowed using both ; and & as query parameter separator. This has been changed to allow only a single separator key, with & as the default separator.

urllib.parse.urlunparse(parts)
urlparse() が返すような形式のタプルから URL を構築します。parts 引数は任意の 6 要素イテラブルです。解析された元の URL が、不要な区切り文字を持っていた場合には、多少違いはあるが等価な URL になるかもしれません (例えばクエリ内容が空の ? のようなもので、RFC はこれらを等価だと述べています)。

urllib.parse.urlsplit(urlstring, scheme='', allow_fragments=True)
This is similar to urlparse(), but does not split the params from the URL. This should generally be used instead of urlparse() if the more recent URL syntax allowing parameters to be applied to each segment of the path portion of the URL (see RFC 2396) is wanted. A separate function is needed to separate the path segments and parameters. This function returns a 5-item named tuple:

(addressing scheme, network location, path, query, fragment identifier).
The return value is a named tuple, its items can be accessed by index or as named attributes:

属性

インデックス

値

指定されなかった場合の値

scheme

0

URL スキーム

scheme パラメータ

netloc

1

ネットワーク上の位置

空文字列

path

2

階層的パス

空文字列

query

3

クエリ要素

空文字列

fragment

4

フラグメント識別子

空文字列

username

ユーザ名

None

password

パスワード

None

hostname

ホスト名 (小文字)

None

port

ポート番号を表わす整数 (もしあれば)

None

URL中で不正なポートが指定されている場合、 port 属性を読みだすと、ValueError を送出します。結果オブジェクトのより詳しい情報は 構造化された解析結果 節を参照してください。

netloc 属性にマッチしなかった角括弧があると ValueError を送出します。

Characters in the netloc attribute that decompose under NFKC normalization (as used by the IDNA encoding) into any of /, ?, #, @, or : will raise a ValueError. If the URL is decomposed before parsing, no error will be raised.

バージョン 3.6 で変更: 範囲外のポート番号を指定すると、 None を返す代わりに、ValueError を送出するようになりました。

バージョン 3.8 で変更: Characters that affect netloc parsing under NFKC normalization will now raise ValueError.

urllib.parse.urlunsplit(parts)
urlsplit() が返すような形式のタプル中のエレメントを組み合わせて、文字列の完全な URL にします。 parts 引数は任意の 5 要素イテラブルです。解析された元の URL が、不要な区切り文字を持っていた場合には、多少違いはあるが等価な URL になるかもしれません (例えばクエリ内容が空の ? のようなもので、RFC はこれらを等価だと述べています)。

urllib.parse.urljoin(base, url, allow_fragments=True)
"基底 URL"(base)と別のURL(url)を組み合わせて、完全な URL ("絶対 URL") を構成します。くだけて言えば、この関数は相対 URL にない要素を提供するために基底 URL の要素、特にアドレススキーム、ネットワーク上の位置、およびパス (の一部) を使います。例えば:

>>>
from urllib.parse import urljoin
urljoin('http://www.cwi.nl/%7Eguido/Python.html', 'FAQ.html')
'http://www.cwi.nl/%7Eguido/FAQ.html'
allow_fragments 引数は urlparse() における引数と同じ意味とデフォルトを持ちます。

注釈 If url is an absolute URL (that is, it starts with // or scheme://), the url's hostname and/or scheme will be present in the result. For example:
>>> urljoin('http://www.cwi.nl/%7Eguido/Python.html',
...         '//www.python.org/%7Eguido')
'http://www.python.org/%7Eguido'
もしこの動作が望みのものでない場合は、 url を urlsplit() と urlunsplit() で先に処理して、 scheme と netloc を削除してください。

バージョン 3.5 で変更: Behavior updated to match the semantics defined in RFC 3986.

urllib.parse.urldefrag(url)
url がフラグメント識別子を含む場合、フラグメント識別子を持たないバージョンに修正された url と、別の文字列に分割されたフラグメント識別子を返します。url 中にフラグメント識別子がない場合、そのままの url と空文字列を返します。

The return value is a named tuple, its items can be accessed by index or as named attributes:

属性

インデックス

値

指定されなかった場合の値

url

0

フラグメントのない URL

空文字列

fragment

1

フラグメント識別子

空文字列

結果オブジェクトのより詳しい情報は 構造化された解析結果 節を参照してください。

バージョン 3.2 で変更: 結果はシンプルな 2 要素のタプルから構造化オブジェクトに変更されました。

urllib.parse.unwrap(url)
Extract the url from a wrapped URL (that is, a string formatted as <URL:scheme://host/path>, <scheme://host/path>, URL:scheme://host/path or scheme://host/path). If url is not a wrapped URL, it is returned without changes.

ASCII エンコードバイト列の解析
URL を解析する関数は元々文字列のみ操作するよう設計されていました。実際のところ、それは URL が正しくクオートされエンコードされた ASCII バイト列を操作できた方が有用でした。結果的にこのモジュールの URL 解析関数はすべて bytes および bytearray オブジェクトに加えて str オブジェクトでも処理するようになりました。

str データが渡された場合、戻り値は str データのみを含んだものになります。bytes あるいは bytearray が渡された場合、戻り値は bytes データのみを含んだものになります。

単一の関数を呼び出す時に bytes または bytearray が混在した str を渡した場合、TypeError が、非 ASCII バイト値が渡された場合 UnicodeDecodeError が送出されます。

str と bytes 間で容易に変換を行えるよう、すべての URL 解析関数は encode() メソッド (結果に str データが含まれる時用) か decode() メソッド (結果に bytes データが含まれる時用) のどちらかを提供しています。これらメソッドの動作は対応する str と bytes メソッドが持つものと同じです (ただしデフォルトのエンコーディングは 'utf-8' ではなく 'ascii' になります)。それぞれは encode() メソッドを持つ bytes データか decode() メソッドを持つ str データのどちらかに対応した型を生成します。

非 ASCII データを含むなど、不適切にクオートされた URL を操作する可能性のあるアプリケーションでは、URL 解析メソッドを呼び出す前に独自にバイト列から文字列にデコードする必要があります。

この項で説明された挙動は URL 解析関数にのみ該当します。URL クオート関数でバイトシーケンスを生成もしくは消化する際には、別にURL クオート関数の項で詳説されている通りのルールに従います。

バージョン 3.2 で変更: URL 解析関数は ASCII エンコードバイトシーケンスも受け付けるようになりました

構造化された解析結果
urlparse()、urlsplit()、および urldefrag() 関数が返すオブジェクトは tuple 型のサブクラスになります。これらサブクラスにはそれぞれの関数で説明されている属性が追加されており、前述のとおりエンコーディングとデコーディングをサポートしています:

urllib.parse.SplitResult.geturl()
オリジナルの URL を再結合した場合は文字列で返されます。これはスキームが小文字に正規化されていたり、空の構成要素が除去されるなど、オリジナルの URL とは異なる場合があります。特に、空のパラメータ、クエリ、およびフラグメント識別子は削除されます。

urldefrag() の戻り値では、空のフラグメント識別子のみ削除されます。urlsplit() および urlparse() の戻り値では、このメソッドが返す URL には説明されているすべての変更が加えられます。

加えた解析関数を逆に行えばこのメソッドの戻り値は元の URL になります:

>>>
from urllib.parse import urlsplit
url = 'HTTP://www.Python.org/doc/#'
r1 = urlsplit(url)
r1.geturl()
'http://www.Python.org/doc/'
r2 = urlsplit(r1.geturl())
r2.geturl()
'http://www.Python.org/doc/'
以下のクラスは str オブジェクトを操作した場合、構造化された解析結果の実装を提供します:

class urllib.parse.DefragResult(url, fragment)
urldefrag() の具象クラスの結果には str データが含まれます。encode() メソッドは DefragResultBytes インスタンスを返します。

バージョン 3.2 で追加.

class urllib.parse.ParseResult(scheme, netloc, path, params, query, fragment)
urlparse() の具象クラスの結果には str データが含まれます。encode() メソッドは ParseResultBytes インスタンスを返します。

class urllib.parse.SplitResult(scheme, netloc, path, query, fragment)
urlsplit() の具象クラスの結果には str データが含まれます。encode() メソッドは SplitResultBytes インスタンスを返します。

以下のクラスは bytes または bytearray オブジェクトを操作した時に解析結果の実装を提供します:

class urllib.parse.DefragResultBytes(url, fragment)
urldefrag() の具象クラスの結果には bytes データが含まれます。decode() メソッドは DefragResult インスタンスを返します。

バージョン 3.2 で追加.

class urllib.parse.ParseResultBytes(scheme, netloc, path, params, query, fragment)
urlparse() の具象クラスの結果には bytes が含まれます。decode() メソッドは ParseResult インスタンスを返します。

バージョン 3.2 で追加.

class urllib.parse.SplitResultBytes(scheme, netloc, path, query, fragment)
urlsplit() の具象クラスの結果には bytes データが含まれます。decode() メソッドは SplitResult インスタンスを返します。

バージョン 3.2 で追加.

URL のクオート
URL クオート関数は、プログラムデータを取り URL 構成要素として使用できるよう特殊文字をクオートしたり非 ASCII 文字を適切にエンコードすることに焦点を当てています。これらは上述の URL 解析関数でカバーされていない URL 構成要素からオリジナルデータの再作成もサポートしています。

urllib.parse.quote(string, safe='/', encoding=None, errors=None)
Replace special characters in string using the %xx escape. Letters, digits, and the characters '_.-~' are never quoted. By default, this function is intended for quoting the path section of a URL. The optional safe parameter specifies additional ASCII characters that should not be quoted --- its default value is '/'.

string may be either a str or a bytes object.

バージョン 3.7 で変更: Moved from RFC 2396 to RFC 3986 for quoting URL strings. "~" is now included in the set of unreserved characters.

任意のパラメータ encoding と errors は str.encode() で受け付けられる非 ASCII 文字への対処法を指定します。encoding のデフォルトは 'utf-8'、errors のデフォルトは 'strict' で、非サポート文字があると UnicodeEncodeError を送出します。string が bytes の場合 encoding と errors を指定してはいけません。指定すると TypeError が送出されます。

quote(string, safe, encoding, errors) は quote_from_bytes(string.encode(encoding, errors), safe) と等価であることに留意してください。

例: quote('/El Niño/') は '/El%20Ni%C3%B1o/' を返します。

urllib.parse.quote_plus(string, safe='', encoding=None, errors=None)
Like quote(), but also replace spaces with plus signs, as required for quoting HTML form values when building up a query string to go into a URL. Plus signs in the original string are escaped unless they are included in safe. It also does not have safe default to '/'.

例: quote_plus('/El Niño/') は '%2FEl+Ni%C3%B1o%2F' を返します。

urllib.parse.quote_from_bytes(bytes, safe='/')
quote() と似ていますが、str ではなく bytes オブジェクトを取り、文字列からバイト列へのエンコードを行いません。

例: quote_from_bytes(b'a&\xef') は 'a%26%EF' を返します。

urllib.parse.unquote(string, encoding='utf-8', errors='replace')
Replace %xx escapes with their single-character equivalent. The optional encoding and errors parameters specify how to decode percent-encoded sequences into Unicode characters, as accepted by the bytes.decode() method.

string may be either a str or a bytes object.

encoding のデフォルトは 'utf-8'、errors のデフォルトは 'replace' で、不正なシーケンスはプレースホルダー文字に置き換えられます。

例: unquote('/El%20Ni%C3%B1o/') は '/El Niño/' を返します。

バージョン 3.9 で変更: string parameter supports bytes and str objects (previously only str).

urllib.parse.unquote_plus(string, encoding='utf-8', errors='replace')
Like unquote(), but also replace plus signs with spaces, as required for unquoting HTML form values.

string は str でなければなりません。

例: unquote_plus('/El+Ni%C3%B1o/') は '/El Niño/' を返します。

urllib.parse.unquote_to_bytes(string)
Replace %xx escapes with their single-octet equivalent, and return a bytes object.

string may be either a str or a bytes object.

str だった場合、string 内のエスケープされていない非 ASCII 文字は UTF-8 バイト列にエンコードされます。

例: unquote_to_bytes('a%26%EF') は b'a&\xef' を返します。

urllib.parse.urlencode(query, doseq=False, safe='', encoding=None, errors=None, quote_via=quote_plus)
マッピング型オブジェクトまたは 2 個の要素からなるタプルのシーケンス (str か bytes オブジェクトが含まれているかもしれません) を、パーセントエンコードされた ASCII 文字列に変換します。戻り値の文字列が urlopen() 関数での POST 操作の data で使用される場合はバイト列にエンコードしなければなりません。そうでない場合は TypeError が送出されます。

戻り値は '&' 文字で区切られた key=value のペアからなる一組の文字列になります。 key と value は quote_via を使用してクオートされます。デフォルトで、値をクォートするために quote_plus() が使用されます。つまり、スペースは '+' 文字に、 '/' 文字は %2F にクォートされます。これは GET リクエストの標準に準拠します (application/x-www-form-urlencoded)。 quote_via として渡すことができる別の関数は quote() です。それはスペースを %20 にエンコードし、 '/' をエンコードしません。何がクォートされるかを最大限コントロールしたければ、 quote を使って safe に値を指定してください。

When a sequence of two-element tuples is used as the query argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter doseq evaluates to True, individual key=value pairs separated by '&' are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.

safe, encoding, および errors パラメータは quote_via にそのまま渡されます (クエリ要素が str の場合は、 encoding と errors パラメータだけが渡されます)。

このエンコード処理の逆を行うには、このモジュールで提供されている parse_qs() と parse_qsl() を使用して、クエリ文字列を Python データ構造に変換できます。

Refer to urllib examples to find out how the urllib.parse.urlencode() method can be used for generating the query string of a URL or data for a POST request.

バージョン 3.2 で変更: query supports bytes and string objects.

バージョン 3.5 で追加: quote_via 引数。

参考
RFC 3986 - Uniform Resource Identifiers
これが現在の標準規格 (STD66) です。urllib.parse モジュールに対するすべての変更はこの規格に準拠していなければなりませんが、若干の逸脱はありえます。これは主には後方互換性のため、また主要なブラウザで一般的に見られる、URL を解析する上でのいくつかの事実上の要件を満たすためです。

RFC 2732 - Format for Literal IPv6 Addresses in URL's.
この規格は IPv6 の URL を解析するときの要求事項を記述しています。

RFC 2396 - Uniform Resource Identifiers (URI): Generic Syntax
この RFC では Uniform Resource Name (URN) と Uniform Resource Locator (URL) の両方に対する一般的な文法的要求事項を記述しています。

RFC 2368 - The mailto URL scheme.
mailto URL スキームに対する文法的要求事項です。

RFC 1808 - Relative Uniform Resource Locators
この RFC には絶対 URL と相対 URL を結合するための規則がボーダケースの取扱い方を決定する "異常な例" つきで収められています。

RFC 1738 - Uniform Resource Locators (URL)
この RFC では絶対 URL の形式的な文法と意味付けを仕様化しています。

urllib.error --- urllib.request が投げる例外¶
ソースコード: Lib/urllib/error.py

urllib.error は urllib.request によって投げられる例外を定義しています。基底クラスは URLError です。

urllib.error は必要に応じて以下の例外が送出します:

exception urllib.error.URLError
ハンドラが何らかの問題に遭遇した場合、この例外 (またはこの例外から派生した例外)を送出します。この例外は OSError のサブクラスです。

reason
このエラーの理由。メッセージ文字列あるいは他の例外インスタンスです。

バージョン 3.3 で変更: URLError は IOError の代わりに OSError のサブクラスになりました。

exception urllib.error.HTTPError
HTTPError は例外 (URLError のサブクラス) ですが、同時に例外ではない file-like な戻り値を返す関数でもあります (urlopen() の戻り値と同じです)。これは、例えばサーバからの認証リクエストのように、変わった HTTP エラーを処理するのに役立ちます。

code
RFC 2616 に定義されているHTTPステータスコード。 この数値型の値は、 http.server.BaseHTTPRequestHandler.responses の辞書に登録されているコードに対応します。

reason
これは通常、このエラーの原因を説明する文字列です。

headers
HTTPError の原因となった HTTP リクエストの HTTP レスポンスヘッダ。

バージョン 3.4 で追加.

exception urllib.error.ContentTooShortError(msg, content)
この例外は urlretrieve() 関数が、ダウンロードされたデータの量が予期した量 (Content-Length ヘッダで与えられる) よりも少ないことを検知した際に発生します。 content 属性には (恐らく途中までの) ダウンロードされたデータが格納されています。

urllib.robotparser --- robots.txt のためのパーザ¶
ソースコード: Lib/urllib/robotparser.py

このモジュールでは単一のクラス、 RobotFileParser を提供します。このクラスは、特定のユーザエージェントが robots.txt ファイルを公開している Web サイトのある URL を取得可能かどうかの質問に答えます。 robots.txt ファイルの構造に関する詳細は http://www.robotstxt.org/orig.html を参照してください。

class urllib.robotparser.RobotFileParser(url='')
url の robots.txt に対し読み込み、パーズ、応答するメソッドを提供します。

set_url(url)
robots.txt ファイルを参照するための URL を設定します。

read()
robots.txt URL を読み出し、パーザに入力します。

parse(lines)
引数 lines の内容を解釈します。

can_fetch(useragent, url)
解釈された robots.txt ファイル中に記載された規則に従ったとき、 useragent が url を取得してもよい場合には True を返します。

mtime()
robots.txt ファイルを最後に取得した時刻を返します。この値は、定期的に新たな robots.txt をチェックする必要がある、長時間動作する Web スパイダープログラムを実装する際に便利です。

modified()
robots.txt ファイルを最後に取得した時刻を現在の時刻に設定します。

crawl_delay(useragent)
Returns the value of the Crawl-delay parameter from robots.txt for the useragent in question. If there is no such parameter or it doesn't apply to the useragent specified or the robots.txt entry for this parameter has invalid syntax, return None.

バージョン 3.6 で追加.

request_rate(useragent)
Returns the contents of the Request-rate parameter from robots.txt as a named tuple RequestRate(requests, seconds). If there is no such parameter or it doesn't apply to the useragent specified or the robots.txt entry for this parameter has invalid syntax, return None.

バージョン 3.6 で追加.

site_maps()
Returns the contents of the Sitemap parameter from robots.txt in the form of a list(). If there is no such parameter or the robots.txt entry for this parameter has invalid syntax, return None.

バージョン 3.8 で追加.

The following example demonstrates basic use of the RobotFileParser class:

>>>
>>> import urllib.robotparser
>>> rp = urllib.robotparser.RobotFileParser()
>>> rp.set_url("http://www.musi-cal.com/robots.txt")
>>> rp.read()
>>> rrate = rp.request_rate("*")
>>> rrate.requests
3
>>> rrate.seconds
20
>>> rp.crawl_delay("*")
6
>>> rp.can_fetch("*", "http://www.musi-cal.com/cgi-bin/search?city=San+Francisco")
False
>>> rp.can_fetch("*", "http://www.musi-cal.com/")
True

http --- HTTP モジュール群
ソースコード: Lib/http/__init__.py

http パッケージはハイパーテキスト転送プロトコルを扱うための幾つかのモジュールを集めたものです:

http.client は低水準のHTTPプロトコルのクライアントです。高水準の URL を開く操作には urllib.request を使ってください

http.server は socketserver をベースにした基礎的な HTTP サーバーを実装しています

http.cookies は cookie の状態管理を実装するためのユーティリティーを提供しています

http.cookiejar は cookie の永続化機能を提供しています

http は http.HTTPStatus 列挙子で 多くの HTTP ステータスコードと関連するメッセージを定義しているモジュールでもあります。

class http.HTTPStatus
バージョン 3.5 で追加.

一連の HTTP ステータスコード、理由の表現、英語で書かれた長い記述を定義した enum.IntEnum のサブクラスです。

使い方:

>>>
>>> from http import HTTPStatus
>>> HTTPStatus.OK
<HTTPStatus.OK: 200>
>>> HTTPStatus.OK == 200
True
>>> HTTPStatus.OK.value
200
>>> HTTPStatus.OK.phrase
'OK'
>>> HTTPStatus.OK.description
'Request fulfilled, document follows'
>>> list(HTTPStatus)
[<HTTPStatus.CONTINUE: 100>, <HTTPStatus.SWITCHING_PROTOCOLS: 101>, ...]
HTTP ステータスコード
サポートされている IANA に登録された http.HTTPStatus で利用可能なステータスコード:

コード

列挙名

詳細

100

CONTINUE

HTTP/1.1 RFC 7231, Section 6.2.1

101

SWITCHING_PROTOCOLS

HTTP/1.1 RFC 7231, Section 6.2.2

102

PROCESSING

WebDAV RFC 2518, Section 10.1

103

EARLY_HINTS

An HTTP Status Code for Indicating Hints RFC 8297

200

OK

HTTP/1.1 RFC 7231, Section 6.3.1

201

CREATED

HTTP/1.1 RFC 7231, Section 6.3.2

202

ACCEPTED

HTTP/1.1 RFC 7231, Section 6.3.3

203

NON_AUTHORITATIVE_INFORMATION

HTTP/1.1 RFC 7231, Section 6.3.4

204

NO_CONTENT

HTTP/1.1 RFC 7231, Section 6.3.5

205

RESET_CONTENT

HTTP/1.1 RFC 7231, Section 6.3.6

206

PARTIAL_CONTENT

HTTP/1.1 RFC 7233, Section 4.1

207

MULTI_STATUS

WebDAV RFC 4918, Section 11.1

208

ALREADY_REPORTED

WebDAV Binding Extensions RFC 5842, Section 7.1 (Experimental)

226

IM_USED

Delta Encoding in HTTP RFC 3229, Section 10.4.1

300

MULTIPLE_CHOICES

HTTP/1.1 RFC 7231, Section 6.4.1

301

MOVED_PERMANENTLY

HTTP/1.1 RFC 7231, Section 6.4.2

302

FOUND

HTTP/1.1 RFC 7231, Section 6.4.3

303

SEE_OTHER

HTTP/1.1 RFC 7231, Section 6.4.4

304

NOT_MODIFIED

HTTP/1.1 RFC 7232, Section 4.1

305

USE_PROXY

HTTP/1.1 RFC 7231, Section 6.4.5

307

TEMPORARY_REDIRECT

HTTP/1.1 RFC 7231, Section 6.4.7

308

PERMANENT_REDIRECT

Permanent Redirect RFC 7238, Section 3 (Experimental)

400

BAD_REQUEST

HTTP/1.1 RFC 7231, Section 6.5.1

401

UNAUTHORIZED

HTTP/1.1 Authentication RFC 7235, Section 3.1

402

PAYMENT_REQUIRED

HTTP/1.1 RFC 7231, Section 6.5.2

403

FORBIDDEN

HTTP/1.1 RFC 7231, Section 6.5.3

404

NOT_FOUND

HTTP/1.1 RFC 7231, Section 6.5.4

405

METHOD_NOT_ALLOWED

HTTP/1.1 RFC 7231, Section 6.5.5

406

NOT_ACCEPTABLE

HTTP/1.1 RFC 7231, Section 6.5.6

407

PROXY_AUTHENTICATION_REQUIRED

HTTP/1.1 Authentication RFC 7235, Section 3.2

408

REQUEST_TIMEOUT

HTTP/1.1 RFC 7231, Section 6.5.7

409

CONFLICT

HTTP/1.1 RFC 7231, Section 6.5.8

410

GONE

HTTP/1.1 RFC 7231, Section 6.5.9

411

LENGTH_REQUIRED

HTTP/1.1 RFC 7231, Section 6.5.10

412

PRECONDITION_FAILED

HTTP/1.1 RFC 7232, Section 4.2

413

REQUEST_ENTITY_TOO_LARGE

HTTP/1.1 RFC 7231, Section 6.5.11

414

REQUEST_URI_TOO_LONG

HTTP/1.1 RFC 7231, Section 6.5.12

415

UNSUPPORTED_MEDIA_TYPE

HTTP/1.1 RFC 7231, Section 6.5.13

416

REQUESTED_RANGE_NOT_SATISFIABLE

HTTP/1.1 Range Requests RFC 7233, Section 4.4

417

EXPECTATION_FAILED

HTTP/1.1 RFC 7231, Section 6.5.14

418

IM_A_TEAPOT

HTCPCP/1.0 RFC 2324, Section 2.3.2

421

MISDIRECTED_REQUEST

HTTP/2 RFC 7540, Section 9.1.2

422

UNPROCESSABLE_ENTITY

WebDAV RFC 4918, Section 11.2

423

LOCKED

WebDAV RFC 4918, Section 11.3

424

FAILED_DEPENDENCY

WebDAV RFC 4918, Section 11.4

425

TOO_EARLY

Using Early Data in HTTP RFC 8470

426

UPGRADE_REQUIRED

HTTP/1.1 RFC 7231, Section 6.5.15

428

PRECONDITION_REQUIRED

Additional HTTP Status Codes RFC 6585

429

TOO_MANY_REQUESTS

Additional HTTP Status Codes RFC 6585

431

REQUEST_HEADER_FIELDS_TOO_LARGE

Additional HTTP Status Codes RFC 6585

451

UNAVAILABLE_FOR_LEGAL_REASONS

An HTTP Status Code to Report Legal Obstacles RFC 7725

500

INTERNAL_SERVER_ERROR

HTTP/1.1 RFC 7231, Section 6.6.1

501

NOT_IMPLEMENTED

HTTP/1.1 RFC 7231, Section 6.6.2

502

BAD_GATEWAY

HTTP/1.1 RFC 7231, Section 6.6.3

503

SERVICE_UNAVAILABLE

HTTP/1.1 RFC 7231, Section 6.6.4

504

GATEWAY_TIMEOUT

HTTP/1.1 RFC 7231, Section 6.6.5

505

HTTP_VERSION_NOT_SUPPORTED

HTTP/1.1 RFC 7231, Section 6.6.6

506

VARIANT_ALSO_NEGOTIATES

Transparent Content Negotiation in HTTP RFC 2295, Section 8.1 (Experimental)

507

INSUFFICIENT_STORAGE

WebDAV RFC 4918, Section 11.5

508

LOOP_DETECTED

WebDAV Binding Extensions RFC 5842, Section 7.2 (Experimental)

510

NOT_EXTENDED

An HTTP Extension Framework RFC 2774, Section 7 (Experimental)

511

NETWORK_AUTHENTICATION_REQUIRED

Additional HTTP Status Codes RFC 6585, Section 6

後方互換性を保つために列挙値は http.client にも定数という形で存在します。 列挙名は定数名と同じです (すなわち http.HTTPStatus.OK は http.client.OK としても利用可能です)。

バージョン 3.7 で変更: Added 421 MISDIRECTED_REQUEST status code.

バージョン 3.8 で追加: Added 451 UNAVAILABLE_FOR_LEGAL_REASONS status code.

バージョン 3.9 で追加: Added 103 EARLY_HINTS, 418 IM_A_TEAPOT and 425 TOO_EARLY status codes.

http.client --- HTTP プロトコルクライアント¶
ソースコード: Lib/http/client.py

このモジュールでは HTTP および HTTPS プロトコルのクライアントサイドを実装しているクラスを定義しています。通常、このモジュールは直接使いません --- urllib.request モジュールが HTTP や HTTPS を使った URL を扱う上でこのモジュールを使います。

参考 より高水準のHTTPクライアントインターフェースとして Requests package <https://requests.readthedocs.io/en/master/> がお奨めです。
注釈 HTTPS のサポートは、Python が SSL サポート付きでコンパイルされている場合にのみ利用できます (ssl モジュールによって)。
このモジュールでは以下のクラスを提供しています:

class http.client.HTTPConnection(host, port=None, [timeout, ]source_address=None, blocksize=8192)
HTTPConnection インスタンスは、HTTP サーバとの一回のトランザクションを表現します。 インスタンスの生成はホスト名とオプションのポート番号を与えて行います。 ポート番号を指定しなかった場合、ホスト名文字列が host:port の形式であれば、ホスト名からポート番号を抽出し、そうでない場合には標準の HTTP ポート番号 (80) を使います。 オプションの引数 timeout が渡された場合、ブロックする処理 (コネクション接続など) のタイムアウト時間(秒数)として利用されます (渡されなかった場合は、グローバルのデフォルトタイムアウト設定が利用されます)。 オプションの引数 source_address を (host, port) という形式のタプルにすると HTTP 接続の接続元アドレスとして使用します。 オプションの blocksize 引数は、送信するファイル類メッセージボディのバッファサイズをバイト単位で設定します。

例えば、以下の呼び出しは全て同じサーバの同じポートに接続するインスタンスを生成します:

>>>
>>> h1 = http.client.HTTPConnection('www.python.org')
>>> h2 = http.client.HTTPConnection('www.python.org:80')
>>> h3 = http.client.HTTPConnection('www.python.org', 80)
>>> h4 = http.client.HTTPConnection('www.python.org', 80, timeout=10)
バージョン 3.2 で変更: source_address が追加されました。

バージョン 3.4 で変更: strict パラメータは廃止されました。HTTP 0.9 の "シンプルなレスポンス" のような形式はもはやサポートされません。

バージョン 3.7 で変更: blocksize 引数が追加されました。

class http.client.HTTPSConnection(host, port=None, key_file=None, cert_file=None, [timeout, ]source_address=None, *, context=None, check_hostname=None, blocksize=8192)
HTTPConnection のサブクラスはセキュア・サーバとやりとりする為の SSL を使う場合に用います。デフォルトのポート番号は 443 です。context が指定されれば、それは様々な SSL オプションを記述する ssl.SSLContext インスタンスでなければなりません。

ベストプラクティスに関するより良い情報が セキュリティで考慮すべき点 にありますのでお読みください。

バージョン 3.2 で変更: source_address、context そして check_hostname が追加されました。

バージョン 3.2 で変更: このクラスは現在、可能であれば(つまり ssl.HAS_SNI が真の場合) HTTPS のバーチャルホストをサポートしています。

バージョン 3.4 で変更: strict パラメータは廃止されました。HTTP 0.9 の "シンプルなレスポンス" のような形式はもはやサポートされません。

バージョン 3.4.3 で変更: このクラスは今や全ての必要な証明書とホスト名の検証をデフォルトで行うようになりました。昔の、検証を行わない振る舞いに戻したければ、 context に ssl._create_unverified_context() を渡すことで出来ます。

バージョン 3.8 で変更: This class now enables TLS 1.3 ssl.SSLContext.post_handshake_auth for the default context or when cert_file is passed with a custom context.

バージョン 3.6 で非推奨: key_file and cert_file are deprecated in favor of context. Please use ssl.SSLContext.load_cert_chain() instead, or let ssl.create_default_context() select the system's trusted CA certificates for you.

The check_hostname parameter is also deprecated; the ssl.SSLContext.check_hostname attribute of context should be used instead.

class http.client.HTTPResponse(sock, debuglevel=0, method=None, url=None)
コネクションに成功したときに、このクラスのインスタンスが返されます。ユーザーから直接利用されることはありません。

バージョン 3.4 で変更: strict パラメータは廃止されました。HTTP 0.9 の "シンプルなレスポンス" のような形式はもはやサポートされません。

This module provides the following function:

http.client.parse_headers(fp)
Parse the headers from a file pointer fp representing a HTTP request/response. The file has to be a BufferedIOBase reader (i.e. not text) and must provide a valid RFC 2822 style header.

This function returns an instance of http.client.HTTPMessage that holds the header fields, but no payload (the same as HTTPResponse.msg and http.server.BaseHTTPRequestHandler.headers). After returning, the file pointer fp is ready to read the HTTP body.

注釈 parse_headers() does not parse the start-line of a HTTP message; it only parses the Name: value lines. The file has to be ready to read these field lines, so the first line should already be consumed before calling the function.
状況に応じて、以下の例外が送出されます:

exception http.client.HTTPException
このモジュールにおける他の例外クラスの基底クラスです。 Exception のサブクラスです。

exception http.client.NotConnected
HTTPException サブクラスです。

exception http.client.InvalidURL
HTTPException のサブクラスです。ポート番号を指定したものの、その値が数字でなかったり空のオブジェクトであった場合に送出されます。

exception http.client.UnknownProtocol
HTTPException サブクラスです。

exception http.client.UnknownTransferEncoding
HTTPException サブクラスです。

exception http.client.UnimplementedFileMode
HTTPException サブクラスです。

exception http.client.IncompleteRead
HTTPException サブクラスです。

exception http.client.ImproperConnectionState
HTTPException サブクラスです。

exception http.client.CannotSendRequest
ImproperConnectionState のサブクラスです。

exception http.client.CannotSendHeader
ImproperConnectionState のサブクラスです。

exception http.client.ResponseNotReady
ImproperConnectionState のサブクラスです。

exception http.client.BadStatusLine
HTTPException のサブクラスです。サーバが理解できない HTTP 状態コードで応答した場合に送出されます。

exception http.client.LineTooLong
A subclass of HTTPException. Raised if an excessively long line is received in the HTTP protocol from the server.

exception http.client.RemoteDisconnected
A subclass of ConnectionResetError and BadStatusLine. Raised by HTTPConnection.getresponse() when the attempt to read the response results in no data read from the connection, indicating that the remote end has closed the connection.

バージョン 3.5 で追加: Previously, BadStatusLine('') was raised.

このモジュールで定義されている定数は以下の通りです:

http.client.HTTP_PORT
HTTP プロトコルの標準のポート (通常は 80) です。

http.client.HTTPS_PORT
HTTPS プロトコルの標準のポート (通常は 443) です。

http.client.responses
このディクショナリは、HTTP 1.1ステータスコードをW3Cの名前にマップしたものです。

例: http.client.responses[http.client.NOT_FOUND] は 'Not Found' を示します。

See HTTP ステータスコード for a list of HTTP status codes that are available in this module as constants.

HTTPConnection オブジェクト
HTTPConnection インスタンスには以下のメソッドがあります:

HTTPConnection.request(method, url, body=None, headers={}, *, encode_chunked=False)
このメソッドは、HTTP 要求メソッド method およびセレクタ url を使って、要求をサーバに送ります。

If body is specified, the specified data is sent after the headers are finished. It may be a str, a bytes-like object, an open file object, or an iterable of bytes. If body is a string, it is encoded as ISO-8859-1, the default for HTTP. If it is a bytes-like object, the bytes are sent as is. If it is a file object, the contents of the file is sent; this file object should support at least the read() method. If the file object is an instance of io.TextIOBase, the data returned by the read() method will be encoded as ISO-8859-1, otherwise the data returned by read() is sent as is. If body is an iterable, the elements of the iterable are sent as is until the iterable is exhausted.

headers 引数は要求と同時に送信される拡張 HTTP ヘッダの内容からなるマップ型でなくてはなりません。

If headers contains neither Content-Length nor Transfer-Encoding, but there is a request body, one of those header fields will be added automatically. If body is None, the Content-Length header is set to 0 for methods that expect a body (PUT, POST, and PATCH). If body is a string or a bytes-like object that is not also a file, the Content-Length header is set to its length. Any other type of body (files and iterables in general) will be chunk-encoded, and the Transfer-Encoding header will automatically be set instead of Content-Length.

The encode_chunked argument is only relevant if Transfer-Encoding is specified in headers. If encode_chunked is False, the HTTPConnection object assumes that all encoding is handled by the calling code. If it is True, the body will be chunk-encoded.

注釈 Chunked transfer encoding has been added to the HTTP protocol version 1.1. Unless the HTTP server is known to handle HTTP 1.1, the caller must either specify the Content-Length, or must pass a str or bytes-like object that is not also a file as the body representation.
バージョン 3.2 で追加: body は iterable オブジェクトとして使用できます。

バージョン 3.6 で変更: If neither Content-Length nor Transfer-Encoding are set in headers, file and iterable body objects are now chunk-encoded. The encode_chunked argument was added. No attempt is made to determine the Content-Length for file objects.

HTTPConnection.getresponse()
サーバに対して HTTP 要求を送り出した後に呼び出されなければりません。要求に対する応答を取得します。 HTTPResponse インスタンスを返します。

注釈 すべての応答を読み込んでからでなければ新しい要求をサーバに送ることはできないことに注意しましょう。
バージョン 3.5 で変更: If a ConnectionError or subclass is raised, the HTTPConnection object will be ready to reconnect when a new request is sent.

HTTPConnection.set_debuglevel(level)
Set the debugging level. The default debug level is 0, meaning no debugging output is printed. Any value greater than 0 will cause all currently defined debug output to be printed to stdout. The debuglevel is passed to any new HTTPResponse objects that are created.

バージョン 3.1 で追加.

HTTPConnection.set_tunnel(host, port=None, headers=None)
HTTP トンネリング接続のホスト名とポート番号を設定します。これによりプロキシサーバを通しての接続を実行できます。

The host and port arguments specify the endpoint of the tunneled connection (i.e. the address included in the CONNECT request, not the address of the proxy server).

ヘッダのパラメータは CONNECT リクエストで送信するために他の HTTP ヘッダにマッピングされます。

For example, to tunnel through a HTTPS proxy server running locally on port 8080, we would pass the address of the proxy to the HTTPSConnection constructor, and the address of the host that we eventually want to reach to the set_tunnel() method:

>>>
>>> import http.client
>>> conn = http.client.HTTPSConnection("localhost", 8080)
>>> conn.set_tunnel("www.python.org")
>>> conn.request("HEAD","/index.html")
バージョン 3.2 で追加.

HTTPConnection.connect()
Connect to the server specified when the object was created. By default, this is called automatically when making a request if the client does not already have a connection.

HTTPConnection.close()
サーバへの接続を閉じます。

HTTPConnection.blocksize
Buffer size in bytes for sending a file-like message body.

バージョン 3.7 で追加.

上で説明した request() メソッドを使うかわりに、以下の4つの関数を使用して要求をステップバイステップで送信することもできます。

HTTPConnection.putrequest(method, url, skip_host=False, skip_accept_encoding=False)
This should be the first call after the connection to the server has been made. It sends a line to the server consisting of the method string, the url string, and the HTTP version (HTTP/1.1). To disable automatic sending of Host: or Accept-Encoding: headers (for example to accept additional content encodings), specify skip_host or skip_accept_encoding with non-False values.

HTTPConnection.putheader(header, argument[, ...])
RFC 822 形式のヘッダをサーバに送ります。この処理では、 header 、コロンとスペース、そして最初の引数からなる 1 行をサーバに送ります。追加の引数を指定した場合、継続して各行にタブ一つと引数の入った引数行が送信されます。

HTTPConnection.endheaders(message_body=None, *, encode_chunked=False)
Send a blank line to the server, signalling the end of the headers. The optional message_body argument can be used to pass a message body associated with the request.

If encode_chunked is True, the result of each iteration of message_body will be chunk-encoded as specified in RFC 7230, Section 3.3.1. How the data is encoded is dependent on the type of message_body. If message_body implements the buffer interface the encoding will result in a single chunk. If message_body is a collections.abc.Iterable, each iteration of message_body will result in a chunk. If message_body is a file object, each call to .read() will result in a chunk. The method automatically signals the end of the chunk-encoded data immediately after message_body.

注釈 Due to the chunked encoding specification, empty chunks yielded by an iterator body will be ignored by the chunk-encoder. This is to avoid premature termination of the read of the request by the target server due to malformed encoding.
バージョン 3.6 で追加: Chunked encoding support. The encode_chunked parameter was added.

HTTPConnection.send(data)
サーバにデータを送ります。このメソッドは endheaders() が呼び出された直後で、かつ getresponse() が呼び出される前に使わなければなりません。

HTTPResponse オブジェクト
HTTPResponse インスタンスはサーバからのHTTPレスポンスをラップします。これを使用してリクエストヘッダとエンティティボディへアクセスすることができます。レスポンスはイテレート可能なオブジェクトであるので、with文と使うことが可能です。

バージョン 3.5 で変更: The io.BufferedIOBase interface is now implemented and all of its reader operations are supported.

HTTPResponse.read([amt])
応答の本体全体か、amt バイトまで読み出して返します。

HTTPResponse.readinto(b)
バッファ b にレスポンスボディの次のデータを最大 len(b) バイト読み込みます。何バイト読んだかを返します。

バージョン 3.3 で追加.

HTTPResponse.getheader(name, default=None)
Return the value of the header name, or default if there is no header matching name. If there is more than one header with the name name, return all of the values joined by ', '. If 'default' is any iterable other than a single string, its elements are similarly returned joined by commas.

HTTPResponse.getheaders()
(header, value) のタプルからなるリストを返します。

HTTPResponse.fileno()
ソケットの fileno を返します。

HTTPResponse.msg
A http.client.HTTPMessage instance containing the response headers. http.client.HTTPMessage is a subclass of email.message.Message.

HTTPResponse.version
サーバが使用した HTTP プロトコルバージョンです。10 は HTTP/1.0 を、11 は HTTP/1.1 を表します。

HTTPResponse.url
URL of the resource retrieved, commonly used to determine if a redirect was followed.

HTTPResponse.headers
Headers of the response in the form of an email.message.EmailMessage instance.

HTTPResponse.status
サーバから返される状態コードです。

HTTPResponse.reason
サーバから返される応答の理由文です。

HTTPResponse.debuglevel
A debugging hook. If debuglevel is greater than zero, messages will be printed to stdout as the response is read and parsed.

HTTPResponse.closed
ストリームが閉じている場合 True となります。

HTTPResponse.geturl()
バージョン 3.9 で非推奨: Deprecated in favor of url.

HTTPResponse.info()
バージョン 3.9 で非推奨: Deprecated in favor of headers.

HTTPResponse.getstatus()
バージョン 3.9 で非推奨: Deprecated in favor of status.

使用例
以下は GET リクエストの送信方法を示した例です:

>>>
>>> import http.client
>>> conn = http.client.HTTPSConnection("www.python.org")
>>> conn.request("GET", "/")
>>> r1 = conn.getresponse()
>>> print(r1.status, r1.reason)
200 OK
>>> data1 = r1.read()  # This will return entire content.
>>> # The following example demonstrates reading data in chunks.
>>> conn.request("GET", "/")
>>> r1 = conn.getresponse()
>>> while chunk := r1.read(200):
...     print(repr(chunk))
b'<!doctype html>\n<!--[if"...
...
>>> # Example of an invalid request
>>> conn = http.client.HTTPSConnection("docs.python.org")
>>> conn.request("GET", "/parrot.spam")
>>> r2 = conn.getresponse()
>>> print(r2.status, r2.reason)
404 Not Found
>>> data2 = r2.read()
>>> conn.close()
次の例のセッションでは、HEAD メソッドを利用しています。HEAD メソッドは全くデータを返さないことに注目してください。

>>>
>>> import http.client
>>> conn = http.client.HTTPSConnection("www.python.org")
>>> conn.request("HEAD", "/")
>>> res = conn.getresponse()
>>> print(res.status, res.reason)
200 OK
>>> data = res.read()
>>> print(len(data))
0
>>> data == b''
True
以下は POST リクエストの送信方法を示した例です:

>>>
>>> import http.client, urllib.parse
>>> params = urllib.parse.urlencode({'@number': 12524, '@type': 'issue', '@action': 'show'})
>>> headers = {"Content-type": "application/x-www-form-urlencoded",
...            "Accept": "text/plain"}
>>> conn = http.client.HTTPConnection("bugs.python.org")
>>> conn.request("POST", "", params, headers)
>>> response = conn.getresponse()
>>> print(response.status, response.reason)
302 Found
>>> data = response.read()
>>> data
b'Redirecting to <a href="http://bugs.python.org/issue12524">http://bugs.python.org/issue12524</a>'
>>> conn.close()
Client side HTTP PUT requests are very similar to POST requests. The difference lies only the server side where HTTP server will allow resources to be created via PUT request. It should be noted that custom HTTP methods are also handled in urllib.request.Request by setting the appropriate method attribute. Here is an example session that shows how to send a PUT request using http.client:

>>>
>>> # This creates an HTTP message
>>> # with the content of BODY as the enclosed representation
>>> # for the resource http://localhost:8080/file
...
>>> import http.client
>>> BODY = "***filecontents***"
>>> conn = http.client.HTTPConnection("localhost", 8080)
>>> conn.request("PUT", "/file", BODY)
>>> response = conn.getresponse()
>>> print(response.status, response.reason)
200, OK
HTTPMessage オブジェクト
http.client.HTTPMessage のインスタンスは HTTP レスポンスヘッダを格納します。 email.message.Message クラスを利用して実装されています。

ftplib --- FTPプロトコルクライアント¶
ソースコード: Lib/ftplib.py

This module defines the class FTP and a few related items. The FTP class implements the client side of the FTP protocol. You can use this to write Python programs that perform a variety of automated FTP jobs, such as mirroring other FTP servers. It is also used by the module urllib.request to handle URLs that use FTP. For more information on FTP (File Transfer Protocol), see Internet RFC 959.

The default encoding is UTF-8, following RFC 2640.

ftplib モジュールを使ったサンプルを以下に示します:

>>>
>>> from ftplib import FTP
>>> ftp = FTP('ftp.us.debian.org')  # connect to host, default port
>>> ftp.login()                     # user anonymous, passwd anonymous@
'230 Login successful.'
>>> ftp.cwd('debian')               # change into "debian" directory
>>> ftp.retrlines('LIST')           # list directory contents
-rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README
...
drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool
drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project
drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools
'226 Directory send OK.'
>>> with open('README', 'wb') as fp:
>>>     ftp.retrbinary('RETR README', fp.write)
'226 Transfer complete.'
>>> ftp.quit()
このモジュールは以下の項目を定義しています:

class ftplib.FTP(host='', user='', passwd='', acct='', timeout=None, source_address=None, *, encoding='utf-8')
Return a new instance of the FTP class. When host is given, the method call connect(host) is made. When user is given, additionally the method call login(user, passwd, acct) is made (where passwd and acct default to the empty string when not given). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if is not specified, the global default timeout setting will be used). source_address is a 2-tuple (host, port) for the socket to bind to as its source address before connecting. The encoding parameter specifies the encoding for directories and filenames.

FTP クラスは with 文をサポートしています。例えば:

>>>
from ftplib import FTP
with FTP("ftp1.at.proftpd.org") as ftp:
    ftp.login()
    ftp.dir()

'230 Anonymous login ok, restrictions apply.'
dr-xr-xr-x   9 ftp      ftp           154 May  6 10:43 .
dr-xr-xr-x   9 ftp      ftp           154 May  6 10:43 ..
dr-xr-xr-x   5 ftp      ftp          4096 May  6 10:43 CentOS
dr-xr-xr-x   3 ftp      ftp            18 Jul 10  2008 Fedora
>>>
バージョン 3.2 で変更: with 構文のサポートが追加されました。

バージョン 3.3 で変更: source_address 引数が追加されました。

バージョン 3.9 で変更: If the timeout parameter is set to be zero, it will raise a ValueError to prevent the creation of a non-blocking socket. The encoding parameter was added, and the default was changed from Latin-1 to UTF-8 to follow RFC 2640.

class ftplib.FTP_TLS(host='', user='', passwd='', acct='', keyfile=None, certfile=None, context=None, timeout=None, source_address=None, *, encoding='utf-8')
RFC 4217 に記述されている TLS サポートを FTP に加えた FTP のサブクラスです。認証の前に FTP コントロール接続を暗黙にセキュアにし、通常通りに port 21 に接続します。データ接続をセキュアにするには、ユーザが prot_p() メソッドを呼び出してそれを明示的に要求しなければなりません。 context は SSL 設定オプション、証明書、秘密鍵を一つの(潜在的に長生きの)構造にまとめた ssl.SSLContext オブジェクトです。ベストプラクティスについての セキュリティで考慮すべき点 をお読みください。

keyfile と certfile は context のレガシー版です -- これらは、SSL 接続のための、 PEM フォーマットの秘密鍵と証明書チェーンファイル名(前者が keyfile 、後者が certfile )を含むことができます。

バージョン 3.2 で追加.

バージョン 3.3 で変更: source_address 引数が追加されました。

バージョン 3.4 で変更: このクラスは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

バージョン 3.6 で非推奨: keyfile および certfile は非推奨となったので、 context を使ってください。 代わりに ssl.SSLContext.load_cert_chain() を使うか、または ssl.create_default_context() にシステムが信頼する CA 証明書を選んでもらうかしてください。

バージョン 3.9 で変更: If the timeout parameter is set to be zero, it will raise a ValueError to prevent the creation of a non-blocking socket. The encoding parameter was added, and the default was changed from Latin-1 to UTF-8 to follow RFC 2640.

FTP_TLS クラスを使ったサンプルセッションはこちらです:

>>>
>>> ftps = FTP_TLS('ftp.pureftpd.org')
>>> ftps.login()
'230 Anonymous user logged in'
>>> ftps.prot_p()
'200 Data protection level set to "private"'
>>> ftps.nlst()
['6jack', 'OpenBSD', 'antilink', 'blogbench', 'bsdcam', 'clockspeed', 'djbdns-jedi', 'docs', 'eaccelerator-jedi', 'favicon.ico', 'francotone', 'fugu', 'ignore', 'libpuzzle', 'metalog', 'minidentd', 'misc', 'mysql-udf-global-user-variables', 'php-jenkins-hash', 'php-skein-hash', 'php-webdav', 'phpaudit', 'phpbench', 'pincaster', 'ping', 'posto', 'pub', 'public', 'public_keys', 'pure-ftpd', 'qscan', 'qtc', 'sharedance', 'skycache', 'sound', 'tmp', 'ucarp']
exception ftplib.error_reply
サーバから想定外の応答があったときに送出される例外。

exception ftplib.error_temp
一時的エラーを表すエラーコード(400--499の範囲の応答コード)を受け取った時に発生する例外。

exception ftplib.error_perm
永久エラーを表すエラーコード(500--599の範囲の応答コード)を受け取った時に発生する例外。

exception ftplib.error_proto
File Transfer Protocol の応答仕様に適合しない、すなわち1--5の数字で始まらない応答コードをサーバから受け取った時に発生する例外。

ftplib.all_errors
The set of all exceptions (as a tuple) that methods of FTP instances may raise as a result of problems with the FTP connection (as opposed to programming errors made by the caller). This set includes the four exceptions listed above as well as OSError and EOFError.

参考
netrc モジュール
.netrc ファイルフォーマットのパーザ。 .netrc ファイルは、 FTPクライアントがユーザにプロンプトを出す前に、ユーザ認証情報をロードするのによく使われます。

FTP オブジェクト
いくつかのコマンドは２つのタイプについて実行します：１つはテキストファイルで、もう１つはバイナリファイルを扱います。これらのメソッドのテキストバージョンでは lines 、バイナリバージョンでは binary の語がメソッド名の終わりについています。

FTP インスタンスには以下のメソッドがあります:

FTP.set_debuglevel(level)
インスタンスのデバッグレベルを設定します。この設定によってデバッグ時に出力される量を調節します。デフォルトは 0 で、何も出力されません。 1 なら、一般的に１つのコマンドあたり１行の適当な量のデバッグ出力を行います。 2 以上なら、コントロール接続で受信した各行を出力して、最大のデバッグ出力をします。

FTP.connect(host='', port=0, timeout=None, source_address=None)
Connect to the given host and port. The default port number is 21, as specified by the FTP protocol specification. It is rarely needed to specify a different port number. This function should be called only once for each instance; it should not be called at all if a host was given when the instance was created. All other methods can only be used after a connection has been made. The optional timeout parameter specifies a timeout in seconds for the connection attempt. If no timeout is passed, the global default timeout setting will be used. source_address is a 2-tuple (host, port) for the socket to bind to as its source address before connecting.

Raises an auditing event ftplib.connect with arguments self, host, port.

バージョン 3.3 で変更: source_address 引数が追加されました。

FTP.getwelcome()
サーバに最初に接続した際に送信される応答中のウェルカムメッセージを返します。(このメッセージには時に、ユーザにとって重要な免責事項や ヘルプ情報が入っています。)

FTP.login(user='anonymous', passwd='', acct='')
与えられた user でログインします。 passwd と acct のパラメータは省略可能で、デフォルトでは空文字列です。もし user が指定されないなら、デフォルトで 'anonymous' になります。もし user が 'anonymous' なら、デフォルトの passwd は 'anonymous@' になります。この関数は各インスタンスについて一度だけ、接続が確立した後に呼び出さなければなりません。インスタンスが作られた時にホスト名とユーザ名が与えられていたら、このメソッドを実行すべきではありません。ほとんどのFTPコマンドはクライアントがログインした後に実行可能になります。 acct 引数は "accounting information" を提供します。ほとんどのシステムはこれを実装していません。

FTP.abort()
実行中のファイル転送を中止します。これはいつも機能するわけではありませんが、やってみる価値はあります。

FTP.sendcmd(cmd)
シンプルなコマンド文字列をサーバに送信して、受信した文字列を返します。

Raises an auditing event ftplib.sendcmd with arguments self, cmd.

FTP.voidcmd(cmd)
シンプルなコマンド文字列をサーバに送信して、その応答を扱います。応答コードが成功に関係するもの(200--299の範囲にあるコード)なら何も返しません。それ以外は error_reply を発生します。

Raises an auditing event ftplib.sendcmd with arguments self, cmd.

FTP.retrbinary(cmd, callback, blocksize=8192, rest=None)
Retrieve a file in binary transfer mode. cmd should be an appropriate RETR command: 'RETR filename'. The callback function is called for each block of data received, with a single bytes argument giving the data block. The optional blocksize argument specifies the maximum chunk size to read on the low-level socket object created to do the actual transfer (which will also be the largest size of the data blocks passed to callback). A reasonable default is chosen. rest means the same thing as in the transfercmd() method.

FTP.retrlines(cmd, callback=None)
Retrieve a file or directory listing in the encoding specified by the encoding parameter at initialization. cmd should be an appropriate RETR command (see retrbinary()) or a command such as LIST or NLST (usually just the string 'LIST'). LIST retrieves a list of files and information about those files. NLST retrieves a list of file names. The callback function is called for each line with a string argument containing the line with the trailing CRLF stripped. The default callback prints the line to sys.stdout.

FTP.set_pasv(val)
Enable "passive" mode if val is true, otherwise disable passive mode. Passive mode is on by default.

FTP.storbinary(cmd, fp, blocksize=8192, callback=None, rest=None)
Store a file in binary transfer mode. cmd should be an appropriate STOR command: "STOR filename". fp is a file object (opened in binary mode) which is read until EOF using its read() method in blocks of size blocksize to provide the data to be stored. The blocksize argument defaults to 8192. callback is an optional single parameter callable that is called on each block of data after it is sent. rest means the same thing as in the transfercmd() method.

バージョン 3.2 で変更: rest パラメタが追加されました。

FTP.storlines(cmd, fp, callback=None)
Store a file in line mode. cmd should be an appropriate STOR command (see storbinary()). Lines are read until EOF from the file object fp (opened in binary mode) using its readline() method to provide the data to be stored. callback is an optional single parameter callable that is called on each line after it is sent.

FTP.transfercmd(cmd, rest=None)
データ接続中に転送を初期化します。もし転送中なら、EPRT あるいは PORT コマンドと、cmd で指定したコマンドを送信し、接続を続けます。サーバがパッシブなら、EPSV あるいは PASV コマンドを送信して接続し、転送コマンドを開始します。どちらの場合も、接続のためのソケットを返します。

If optional rest is given, a REST command is sent to the server, passing rest as an argument. rest is usually a byte offset into the requested file, telling the server to restart sending the file's bytes at the requested offset, skipping over the initial bytes. Note however that the transfercmd() method converts rest to a string with the encoding parameter specified at initialization, but no check is performed on the string's contents. If the server does not recognize the REST command, an error_reply exception will be raised. If this happens, simply call transfercmd() without a rest argument.

FTP.ntransfercmd(cmd, rest=None)
transfercmd() と同様ですが、データと予想されるサイズとのタプルを返します。もしサイズが計算できないなら、サイズの代わりに None が返されます。 cmd と rest は transfercmd() のものと同じです。

FTP.mlsd(path="", facts=[])
List a directory in a standardized format by using MLSD command (RFC 3659). If path is omitted the current directory is assumed. facts is a list of strings representing the type of information desired (e.g. ["type", "size", "perm"]). Return a generator object yielding a tuple of two elements for every file found in path. First element is the file name, the second one is a dictionary containing facts about the file name. Content of this dictionary might be limited by the facts argument but server is not guaranteed to return all requested facts.

バージョン 3.3 で追加.

FTP.nlst(argument[, ...])
NLST コマンドで返されるファイル名のリストを返します。省略可能な argument は、リストアップするディレクトリです（デフォルトではサーバのカレントディレクトリです）。 NLST コマンドに非標準である複数の引数を渡すことができます。

注釈 If your server supports the command, mlsd() offers a better API.
FTP.dir(argument[, ...])
LIST コマンドで返されるディレクトリ内のリストを作り、標準出力へ出力します。省略可能な argument は、リストアップするディレクトリです（デフォルトではサーバのカレントディレクトリです）。 LIST コマンドに非標準である複数の引数を渡すことができます。もし最後の引数が関数なら、 retrlines() のように callback として使われます; デフォルトでは sys.stdout に印字します。このメソッドは None を返します。

注釈 If your server supports the command, mlsd() offers a better API.
FTP.rename(fromname, toname)
サーバ上のファイルのファイル名 fromname を toname へ変更します。

FTP.delete(filename)
サーバからファイル filename を削除します。成功したら応答のテキストを返し、そうでないならパーミッションエラーでは error_perm を、他のエラーでは error_reply を返します。

FTP.cwd(pathname)
サーバのカレントディレクトリを設定します。

FTP.mkd(pathname)
サーバ上に新たにディレクトリを作ります。

FTP.pwd()
サーバ上のカレントディレクトリのパスを返します。

FTP.rmd(dirname)
サーバ上のディレクトリ dirname を削除します。

FTP.size(filename)
サーバ上のファイル filename のサイズを尋ねます。成功したらファイルサイズが整数で返され、そうでないなら None が返されます。 SIZE コマンドは標準化されていませんが、多くの普通のサーバで実装されていることに注意して下さい。

FTP.quit()
サーバに QUIT コマンドを送信し、接続を閉じます。これは接続を閉じるのに"礼儀正しい"方法ですが、 QUIT コマンドに反応してサーバの例外が発生するかもしれません。この例外は、 close() メソッドによって FTP インスタンスに対するその後のコマンド使用が不可になっていることを示しています（下記参照）。

FTP.close()
接続を一方的に閉じます。既に閉じた接続に対して実行すべきではありません（例えば quit() を呼び出して成功した後など）。この実行の後、 FTP インスタンスはもう使用すべきではありません（ close() あるいは quit() を呼び出した後で、 login() メソッドをもう一度実行して再び接続を開くことはできません）。

FTP_TLS オブジェクト
FTP_TLS クラスは FTP を継承し、さらにオブジェクトを定義します:

FTP_TLS.ssl_version
使用する SSL のバージョン (デフォルトは ssl.PROTOCOL_SSLv23) です。

FTP_TLS.auth()
Set up a secure control connection by using TLS or SSL, depending on what is specified in the ssl_version attribute.

バージョン 3.4 で変更: このメソッドは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

FTP_TLS.ccc()
Revert control channel back to plaintext. This can be useful to take advantage of firewalls that know how to handle NAT with non-secure FTP without opening fixed ports.

バージョン 3.3 で追加.

FTP_TLS.prot_p()
セキュアデータ接続をセットアップします。

FTP_TLS.prot_c()
平文データ接続をセットアップします。

poplib --- POP3 プロトコルクライアント¶
ソースコード: Lib/poplib.py

このモジュールはクラス POP3 を定義しています。 POP3 はPOP3 サーバへの接続をカプセル化し、RFC 1939 で定義されているプロトコルを実装しています。 POP3 クラスは RFC 1939 の最小限のコマンドセットとオプションのコマンドセットをサポートしています。 既に確立されている接続で暗号化された通信を行うために、RFC 2595 で導入された STLS コマンドもサポートされています。

加えて、このモジュールはクラス POP3_SSL を提供しています。 POP3_SSL は SSL を下層のプロトコルレイヤーとして使う POP3 サーバへの接続をサポートしています。

POP3についての注意事項は、それが広くサポートされているにもかかわらず、既に時代遅れだということです。幾つも実装されているPOP3サーバーの品質は、貧弱なものが多数を占めています。もし、お使いのメールサーバーがIMAPをサポートしているなら、 imaplib.IMAP4 クラスが使えます。 IMAPサーバーは、より良く実装されている傾向があります。

poplib モジュールは二つのクラスを提供します:

class poplib.POP3(host, port=POP3_PORT[, timeout])
このクラスが、実際にPOP3プロトコルを実装します。インスタンスが初期化されるときに、コネクションが作成されます。 port が省略されると、POP3標準のポート(110)が使われます。オプションの timeout 引数は、接続時のタイムアウト時間を秒数で指定します (指定されなかった場合は、グローバルのデフォルトタイムアウト設定が利用されます)。

引数 self, host, port 付きで 監査イベント poplib.connect を送出します。

引数 self, line を指定して 監査イベント poplib.putline を送出します。

バージョン 3.9 で変更: timeout パラメータが0に設定されている場合、非ブロッキングソケットの作成を防ぐために ValueError を送出します。

class poplib.POP3_SSL(host, port=POP3_SSL_PORT, keyfile=None, certfile=None, timeout=None, context=None)
POP3 クラスのサブクラスで、SSL でカプセル化されたソケットによる POP サーバへの接続を提供します。 port が指定されていない場合、 POP3-over-SSL 標準の 995 番ポートが使われます。timeout については POP3 クラスのコンストラクタの引数と同じです。 context は SSL の設定、証明書、秘密鍵を一つの (POP3_SSL オブジェクトよりも長く存在し続けうる) 構造にまとめた ssl.SSLContext オブジェクトで、省略可能です。ベストプラクティスについては セキュリティで考慮すべき点 を参照してください。

keyfile と certfile は context のレガシー版です - これらは、SSL 接続のための、 PEM フォーマットの秘密鍵と証明書チェーンファイル名(前者が keyfile 、後者が certfile )を含むことができます。

引数 self, host, port 付きで 監査イベント poplib.connect を送出します。

引数 self, line を指定して 監査イベント poplib.putline を送出します。

バージョン 3.2 で変更: context 引数が追加されました。

バージョン 3.4 で変更: このクラスは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

バージョン 3.6 で非推奨: keyfile および certfile は非推奨となったので、 context を使ってください。 代わりに ssl.SSLContext.load_cert_chain() を使うか、または ssl.create_default_context() にシステムが信頼する CA 証明書を選んでもらうかしてください。

バージョン 3.9 で変更: timeout パラメータが0に設定されている場合、非ブロッキングソケットの作成を防ぐために ValueError を送出します。

1つの例外が、 poplib モジュールのアトリビュートとして定義されています:

exception poplib.error_proto
このモジュール内で起こったあらゆるエラーで送出される例外です (socket モジュールからのエラーは捕捉されません)。例外の理由は文字列としてコンストラクタに渡されます。

参考
モジュール imaplib
標準 Python IMAP モジュールです。

Frequently Asked Questions About Fetchmail
POP/IMAPクライアント fetchmail のFAQ。POPプロトコルをベースにしたアプリケーションを書くときに有用な、POP3サーバの種類や RFCへの適合度といった情報を収集しています。

POP3 オブジェクト
POP3コマンドはすべて、それと同じ名前のメソッドとしてlower-caseで表現されます。そしてそのほとんどは、サーバからのレスポンスとなるテキストを返します。

POP3 クラスのインスタンスは以下のメソッドを持ちます:

POP3.set_debuglevel(level)
インスタンスのデバッグレベルを設定します。この設定によってデバッグ時に出力される量を調節します。デフォルトは 0 で、何も出力されません。 1 なら、一般的に１つのコマンドあたり１行の適当な量のデバッグ出力を行います。 2 以上なら、コントロール接続で受信した各行を出力して、最大のデバッグ出力をします。

POP3.getwelcome()
POP3サーバーから送られるグリーティングメッセージを返します。

POP3.capa()
RFC 2449 で規定されている機能についてサーバに問い合わせます。{'name': ['param'...]} という形の辞書を返します。

バージョン 3.4 で追加.

POP3.user(username)
userコマンドを送出します。応答はパスワード要求を表示します。

POP3.pass_(password)
パスワードを送出します。応答は、メッセージ数とメールボックスのサイズを含みます。注意：サーバー上のメールボックスは quit() が呼ばれるまでロックされます。

POP3.apop(user, secret)
POP3サーバーにログオンするのに、よりセキュアなAPOP認証を使用します。

POP3.rpop(user)
POP3サーバーにログオンするのに、（UNIXのr-コマンドと同様の）RPOP認証を使用します。

POP3.stat()
メールボックスの状態を得ます。結果は2つのintegerからなるタプルとなります。 (message count, mailbox size).

POP3.list([which])
メッセージのリストを要求します。結果は (response, ['mesg_num octets', ...], octets) という形式で表されます。 which が与えられると、それによりメッセージを指定します。

POP3.retr(which)
which 番のメッセージ全体を取り出し、そのメッセージに既読フラグを立てます。結果は (response, ['line', ...], octets) という形式で表されます。

POP3.dele(which)
which 番のメッセージに削除のためのフラグを立てます。ほとんどのサーバで、QUITコマンドが実行されるまでは実際の削除は行われません（もっとも良く知られた例外は Eudora QPOPで、その配送メカニズムはRFCに違反しており、どんな切断状況でも削除操作を未解決にしています）。

POP3.rset()
メールボックスの削除マークすべてを取り消します。

POP3.noop()
何もしません。接続保持のために使われます。

POP3.quit()
サインオフ: 変更をコミットし、メールボックスをアンロックして、接続を破棄します。

POP3.top(which, howmuch)
メッセージヘッダと howmuch で指定した行数のメッセージを、 which で指定したメッセージ分取り出します。結果は以下のような形式となります。 (response, ['line', ...], octets).

このメソッドはPOP3のTOPコマンドを利用し、RETRコマンドのように、メッセージに既読フラグをセットしません。残念ながら、TOPコマンドはRFCでは貧弱な仕様しか定義されておらず、しばしばノーブランドのサーバーでは（その仕様が）守られていません。このメソッドを信用してしまう前に、実際に使用するPOPサーバーでテストをしてください。

POP3.uidl(which=None)
（ユニークIDによる）メッセージダイジェストのリストを返します。 which が設定されている場合、結果はユニークIDを含みます。それは 'response mesgnum uid という形式のメッセージ、または (response, ['mesgnum uid', ...], octets) という形式のリストとなります。

POP3.utf8()
UTF-8 モードへの切り替えを試行します。成功した場合はサーバの応答を返し、失敗した場合は error_proto を送出します。RFC 6856 で規定されています。

バージョン 3.5 で追加.

POP3.stls(context=None)
アクティブな接続にて RFC 2595 で定められた方法で TLS セッションを開始します。TLS セッションはユーザ認証を行う前に開始する必要があります。

context は SSL の設定、証明書、秘密鍵を一つの (POP3 オブジェクトよりも長く存在し続けうる) 構造にまとめた ssl.SSLContext オブジェクトです。ベストプラクティスについては セキュリティで考慮すべき点 を参照してください。

このメソッドは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

バージョン 3.4 で追加.

POP3_SSL クラスのインスタンスは追加のメソッドを持ちません。このサブクラスのインターフェイスは親クラスと同じです。

POP3 の例
以下にメールボックスを開き、全てのメッセージを取得して印刷する最小の (エラーチェックをしない) 使用例を示します:

import getpass, poplib

M = poplib.POP3('localhost')
M.user(getpass.getuser())
M.pass_(getpass.getpass())
numMessages = len(M.list()[1])
for i in range(numMessages):
    for j in M.retr(i+1)[1]:
        print(j)
モジュールの末尾に、より拡張的な使用例が収められたテストセクションがあります。

imaplib --- IMAP4 プロトコルクライアント
ソースコード: Lib/imaplib.py

このモジュールでは三つのクラス、 IMAP4, IMAP4_SSL と IMAP4_stream を定義します。これらのクラスは IMAP4 サーバへの接続をカプセル化し、 RFC 2060 に定義されている IMAP4rev1 クライアントプロトコルの大規模なサブセットを実装しています。このクラスは IMAP4 (RFC 1730) 準拠のサーバと後方互換性がありますが、 STATUS コマンドは IMAP4 ではサポートされていないので注意してください。

imaplib モジュール内では三つのクラスを提供しており、 IMAP4 は基底クラスとなります:

class imaplib.IMAP4(host='', port=IMAP4_PORT, timeout=None)
This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If host is not specified, '' (the local host) is used. If port is omitted, the standard IMAP4 port (143) is used. The optional timeout parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.

The IMAP4 class supports the with statement. When used like this, the IMAP4 LOGOUT command is issued automatically when the with statement exits. E.g.:

>>>
>>> from imaplib import IMAP4
>>> with IMAP4("domain.org") as M:
...     M.noop()
...
('OK', [b'Nothing Accomplished. d25if65hy903weo.87'])
バージョン 3.5 で変更: with 構文のサポートが追加されました。

バージョン 3.9 で変更: The optional timeout parameter was added.

例外は IMAP4 クラスの属性として定義されています:

exception IMAP4.error
何らかのエラー発生の際に送出される例外です。例外の理由は文字列としてコンストラクタに渡されます。

exception IMAP4.abort
IMAP4 サーバのエラーが生じると、この例外が送出されます。この例外は IMAP4.error のサブクラスです。通常、インスタンスを閉じ、新たなインスタンスを再び生成することで、この例外から復旧できます。

exception IMAP4.readonly
この例外は書き込み可能なメールボックスの状態がサーバによって変更された際に送出されます。この例外は IMAP4.error のサブクラスです。他の何らかのクライアントが現在書き込み権限を獲得しており、メールボックスを開きなおして書き込み権限を再獲得する必要があります。

このモジュールではもう一つ、安全 (secure) な接続を使ったサブクラスがあります:

class imaplib.IMAP4_SSL(host='', port=IMAP4_SSL_PORT, keyfile=None, certfile=None, ssl_context=None, timeout=None)
This is a subclass derived from IMAP4 that connects over an SSL encrypted socket (to use this class you need a socket module that was compiled with SSL support). If host is not specified, '' (the local host) is used. If port is omitted, the standard IMAP4-over-SSL port (993) is used. ssl_context is a ssl.SSLContext object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. Please read セキュリティで考慮すべき点 for best practices.

keyfile and certfile are a legacy alternative to ssl_context - they can point to PEM-formatted private key and certificate chain files for the SSL connection. Note that the keyfile/certfile parameters are mutually exclusive with ssl_context, a ValueError is raised if keyfile/certfile is provided along with ssl_context.

The optional timeout parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.

バージョン 3.3 で変更: ssl_context parameter was added.

バージョン 3.4 で変更: このクラスは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

バージョン 3.6 で非推奨: keyfile and certfile are deprecated in favor of ssl_context. Please use ssl.SSLContext.load_cert_chain() instead, or let ssl.create_default_context() select the system's trusted CA certificates for you.

バージョン 3.9 で変更: The optional timeout parameter was added.

さらにもう一つのサブクラスは、子プロセスで確立した接続を使用する場合に使用します:

class imaplib.IMAP4_stream(command)
IMAP4 から派生したサブクラスで、 command を subprocess.Popen() に渡して作成される stdin/stdout ディスクリプタと接続します。

以下のユーティリティ関数が定義されています:

imaplib.Internaldate2tuple(datestr)
Parse an IMAP4 INTERNALDATE string and return corresponding local time. The return value is a time.struct_time tuple or None if the string has wrong format.

imaplib.Int2AP(num)
Converts an integer into a bytes representation using characters from the set [A .. P].

imaplib.ParseFlags(flagstr)
IMAP4 FLAGS 応答を個々のフラグからなるタプルに変換します。

imaplib.Time2Internaldate(date_time)
Convert date_time to an IMAP4 INTERNALDATE representation. The return value is a string in the form: "DD-Mmm-YYYY HH:MM:SS +HHMM" (including double-quotes). The date_time argument can be a number (int or float) representing seconds since epoch (as returned by time.time()), a 9-tuple representing local time an instance of time.struct_time (as returned by time.localtime()), an aware instance of datetime.datetime, or a double-quoted string. In the last case, it is assumed to already be in the correct format.

IMAP4 メッセージ番号は、メールボックスに対する変更が行われた後には変化します; 特に、EXPUNGE 命令はメッセージの削除を行いますが、残ったメッセージには再度番号を振りなおします。従って、メッセージ番号ではなく、UID 命令を使い、その UID を利用するよう強く勧めます。

モジュールの末尾に、より拡張的な使用例が収められたテストセクションがあります。

参考 Documents describing the protocol, sources for servers implementing it, by the University of Washington's IMAP Information Center can all be found at (Source Code) https://github.com/uw-imap/imap (Not Maintained).
IMAP4 オブジェクト
全ての IMAP4rev1 命令は、同じ名前のメソッドで表されており、大文字のものも小文字のものもあります。

命令に対する引数は全て文字列に変換されます。例外は AUTHENTICATE の引数と APPEND の最後の引数で、これは IMAP4 リテラルとして渡されます。必要に応じて (IMAP4 プロトコルが感知対象としている文字が文字列に入っており、かつ丸括弧か二重引用符で囲われていなかった場合) 文字列はクオートされます。しかし、LOGIN 命令の password 引数は常にクオートされます。文字列がクオートされないようにしたい (例えば STORE 命令の flags 引数) 場合、文字列を丸括弧で囲んでください (例: r'(\Deleted)')。

Each command returns a tuple: (type, [data, ...]) where type is usually 'OK' or 'NO', and data is either the text from the command response, or mandated results from the command. Each data is either a bytes, or a tuple. If a tuple, then the first part is the header of the response, and the second part contains the data (ie: 'literal' value).

以下のコマンドにおける message_set オプションは、操作の対象となるひとつあるいは複数のメッセージを指す文字列です。単一のメッセージ番号 ('1') かメッセージ番号の範囲 ('2:4')、あるいは連続していないメッセージをカンマでつなげたもの ('1:3,6:9') となります。範囲指定でアスタリスクを使用すると、上限を無限とすることができます ('3:*')。

IMAP4 のインスタンスは以下のメソッドを持っています:

IMAP4.append(mailbox, flags, date_time, message)
指定された名前のメールボックスに message を追加します。

IMAP4.authenticate(mechanism, authobject)
認証命令です --- 応答の処理が必要です。

mechanism は利用する認証メカニズムを与えます。認証メカニズムはインスタンス変数 capabilities の中に AUTH=mechanism という形式で現れる必要があります。

authobject は呼び出し可能なオブジェクトである必要があります:

data = authobject(response)
It will be called to process server continuation responses; the response argument it is passed will be bytes. It should return bytes data that will be base64 encoded and sent to the server. It should return None if the client abort response * should be sent instead.

バージョン 3.5 で変更: string usernames and passwords are now encoded to utf-8 instead of being limited to ASCII.

IMAP4.check()
サーバ上のメールボックスにチェックポイントを設定します。

IMAP4.close()
現在選択されているメールボックスを閉じます。削除されたメッセージは書き込み可能メールボックスから除去されます。LOGOUT 前に実行することを勧めます。

IMAP4.copy(message_set, new_mailbox)
message_set で指定したメッセージ群を new_mailbox の末尾にコピーします。

IMAP4.create(mailbox)
mailbox と名づけられた新たなメールボックスを生成します。

IMAP4.delete(mailbox)
mailbox と名づけられた古いメールボックスを削除します。

IMAP4.deleteacl(mailbox, who)
mailbox における who についてのACLを削除(権限を削除)します。

IMAP4.enable(capability)
Enable capability (see RFC 5161). Most capabilities do not need to be enabled. Currently only the UTF8=ACCEPT capability is supported (see RFC 6855).

バージョン 3.5 で追加: The enable() method itself, and RFC 6855 support.

IMAP4.expunge()
選択されたメールボックスから削除された要素を永久に除去します。各々の削除されたメッセージに対して、EXPUNGE 応答を生成します。返されるデータには EXPUNGE メッセージ番号を受信した順番に並べたリストが入っています。

IMAP4.fetch(message_set, message_parts)
メッセージ (の一部) を取りよせます。message_parts はメッセージパートの名前を表す文字列を丸括弧で囲ったもので、例えば: "(UID BODY[TEXT])" のようになります。返されるデータはメッセージパートのエンベロープ情報とデータからなるタプルです。

IMAP4.getacl(mailbox)
mailbox に対する ACL を取得します。このメソッドは非標準ですが、Cyrus サーバでサポートされています。

IMAP4.getannotation(mailbox, entry, attribute)
mailbox に対する ANNOTATION を取得します。このメソッドは非標準ですが、Cyrus サーバでサポートされています。

IMAP4.getquota(root)
quota root により、リソース使用状況と制限値を取得します。このメソッドは RFC 2087 で定義されている IMAP4 QUOTA 拡張の一部です。

IMAP4.getquotaroot(mailbox)
mailbox に対して quota root を実行した結果のリストを取得します。このメソッドは RFC 2087 で定義されている IMAP4 QUOTA 拡張の一部です。

IMAP4.list([directory[, pattern]])
pattern にマッチする directory メールボックス名を列挙します。directory の標準の設定値は最上レベルのメールフォルダで、pattern は標準の設定では全てにマッチします。返されるデータには LIST 応答のリストが入っています。

IMAP4.login(user, password)
平文パスワードを使ってクライアントを照合します。password はクオートされます。

IMAP4.login_cram_md5(user, password)
パスワードの保護のため、クライアント認証時に CRAM-MD5 だけを使用します。これは、CAPABILITY レスポンスに AUTH=CRAM-MD5 が含まれる場合のみ有効です。

IMAP4.logout()
サーバへの接続を遮断します。サーバからの BYE 応答を返します。

バージョン 3.8 で変更: The method no longer ignores silently arbitrary exceptions.

IMAP4.lsub(directory='""', pattern='*')
購読しているメールボックス名のうち、ディレクトリ内でパターンにマッチするものを列挙します。directory の標準の設定値は最上レベルのメールフォルダで、pattern は標準の設定では全てにマッチします。返されるデータには返されるデータはメッセージパートエンベロープ情報とデータからなるタプルです。

IMAP4.myrights(mailbox)
mailboxにおける自分のACLを返します (すなわち自分がmailboxで持っている権限を返します)。

IMAP4.namespace()
Returns IMAP namespaces as defined in RFC 2342.

IMAP4.noop()
サーバに NOOP を送信します。

IMAP4.open(host, port, timeout=None)
Opens socket to port at host. The optional timeout parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used. Also note that if the timeout parameter is set to be zero, it will raise a ValueError to reject creating a non-blocking socket. This method is implicitly called by the IMAP4 constructor. The connection objects established by this method will be used in the IMAP4.read(), IMAP4.readline(), IMAP4.send(), and IMAP4.shutdown() methods. You may override this method.

Raises an auditing event imaplib.open with arguments self, host, port.

バージョン 3.9 で変更: The timeout parameter was added.

IMAP4.partial(message_num, message_part, start, length)
メッセージの後略された部分を取り寄せます。返されるデータはメッセージパートエンベロープ情報とデータからなるタプルです。

IMAP4.proxyauth(user)
user として認証されたものとします。認証された管理者がユーザの代理としてメールボックスにアクセスする際に使用します。

IMAP4.read(size)
遠隔のサーバから size バイト読み出します。このメソッドはオーバライドすることができます。

IMAP4.readline()
遠隔のサーバから一行読み出します。このメソッドはオーバライドすることができます。

IMAP4.recent()
サーバに更新を促します。新たなメッセージがない場合応答は None になり、そうでない場合 RECENT 応答の値になります。

IMAP4.rename(oldmailbox, newmailbox)
oldmailbox という名前のメールボックスを newmailbox に名称変更します。

IMAP4.response(code)
応答 code を受信していれば、そのデータを返し、そうでなければ None を返します。通常の形式 (usual type) ではなく指定したコードを返します。

IMAP4.search(charset, criterion[, ...])
Search mailbox for matching messages. charset may be None, in which case no CHARSET will be specified in the request to the server. The IMAP protocol requires that at least one criterion be specified; an exception will be raised when the server returns an error. charset must be None if the UTF8=ACCEPT capability was enabled using the enable() command.

以下はプログラム例です:

# M is a connected IMAP4 instance...
typ, msgnums = M.search(None, 'FROM', '"LDJ"')

# or:
typ, msgnums = M.search(None, '(FROM "LDJ")')
IMAP4.select(mailbox='INBOX', readonly=False)
メールボックスを選択します。返されるデータは mailbox 内のメッセージ数 (EXISTS 応答) です。標準の設定では mailbox は 'INBOX' です。readonly が設定された場合、メールボックスに対する変更はできません。

IMAP4.send(data)
遠隔のサーバに data を送信します。このメソッドはオーバライドすることができます。

Raises an auditing event imaplib.send with arguments self, data.

IMAP4.setacl(mailbox, who, what)
ACL を mailbox に設定します。このメソッドは非標準ですが、Cyrus サーバでサポートされています。

IMAP4.setannotation(mailbox, entry, attribute[, ...])
ANNOTATION を mailbox に設定します。このメソッドは非標準ですが、Cyrus サーバでサポートされています。

IMAP4.setquota(root, limits)
quota root のリソースを limits に設定します。このメソッドは RFC 2087 で定義されている IMAP4 QUOTA 拡張の一部です。

IMAP4.shutdown()
open で確立された接続を閉じます。 IMAP4.logout() は暗黙的にこのメソッドを呼び出します。このメソッドはオーバライドすることができます。

IMAP4.socket()
サーバへの接続に使われているソケットインスタンスを返します。

IMAP4.sort(sort_criteria, charset, search_criterion[, ...])
sort 命令は search に結果の並べ替え (sort) 機能をつけた変種です。返されるデータには、条件に合致するメッセージ番号をスペースで分割したリストが入っています。

sort 命令は search_criterion の前に二つの引数を持ちます; sort_criteria のリストを丸括弧で囲ったものと、検索時の charset です。search と違って、検索時の charset は必須です。uid sort 命令もあり、search に対する uid search と同じように sort 命令に対応します。sort 命令はまず、charset 引数の指定に従って searching criteria の文字列を解釈し、メールボックスから与えられた検索条件に合致するメッセージを探します。次に、合致したメッセージの数を返します。

IMAP4rev1 拡張命令です。

IMAP4.starttls(ssl_context=None)
Send a STARTTLS command. The ssl_context argument is optional and should be a ssl.SSLContext object. This will enable encryption on the IMAP connection. Please read セキュリティで考慮すべき点 for best practices.

バージョン 3.2 で追加.

バージョン 3.4 で変更: このメソッドは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

IMAP4.status(mailbox, names)
mailbox の指定ステータス名の状態情報を要求します。

IMAP4.store(message_set, command, flag_list)
メールボックス内のメッセージ群のフラグ設定を変更します。 command は RFC 2060 のセクション 6.4.6 で指定されているもので、 "FLAGS", "+FLAGS", あるいは "-FLAGS" のいずれかとなります。オプションで末尾に ".SILENT" がつくこともあります。

たとえば、すべてのメッセージに削除フラグを設定するには次のようにします:

typ, data = M.search(None, 'ALL')
for num in data[0].split():
   M.store(num, '+FLAGS', '\\Deleted')
M.expunge()
注釈 Creating flags containing ']' (for example: "[test]") violates RFC 3501 (the IMAP protocol). However, imaplib has historically allowed creation of such tags, and popular IMAP servers, such as Gmail, accept and produce such flags. There are non-Python programs which also create such tags. Although it is an RFC violation and IMAP clients and servers are supposed to be strict, imaplib nonetheless continues to allow such tags to be created for backward compatibility reasons, and as of Python 3.6, handles them if they are sent from the server, since this improves real-world compatibility.
IMAP4.subscribe(mailbox)
新たなメールボックスを購読 (subscribe) します。

IMAP4.thread(threading_algorithm, charset, search_criterion[, ...])
thread コマンドは search にスレッドの概念を加えた変形版です。返されるデータは空白で区切られたスレッドメンバのリストを含んでいます。

各スレッドメンバは0以上のメッセージ番号からなり、空白で区切られており、親子関係を示しています。

thread コマンドは search_criterion 引数の前に2つの引数を持っています。threading_algorithm と charset です。search コマンドとは違い、charset は必須です。search に対する uid search と同様に、thread にも uid thread があります。thread コマンドはまずメールボックス中のメッセージを、charsetを用いた検索条件で検索します。その後マッチしたメッセージを指定されたスレッドアルゴリズムでスレッド化して返します.

IMAP4rev1 拡張命令です。

IMAP4.uid(command, arg[, ...])
command args を、メッセージ番号ではなく UID で指定されたメッセージ群に対して実行します。命令内容に応じた応答を返します。少なくとも一つの引数を与えなくてはなりません; 何も与えない場合、サーバはエラーを返し、例外が送出されます。

IMAP4.unsubscribe(mailbox)
古いメールボックスの購読を解除 (unsubscribe) します。

IMAP4.unselect()
imaplib.IMAP4.unselect() frees server's resources associated with the selected mailbox and returns the server to the authenticated state. This command performs the same actions as imaplib.IMAP4.close(), except that no messages are permanently removed from the currently selected mailbox.

バージョン 3.9 で追加.

IMAP4.xatom(name[, ...])
サーバから CAPABILITY 応答で通知された単純な拡張命令を許容 (allow) します。

以下の属性が IMAP4 のインスタンス上で定義されています:

IMAP4.PROTOCOL_VERSION
サーバから返された CAPABILITY 応答にある、サポートされている最新のプロトコルです。

IMAP4.debug
デバッグ出力を制御するための整数値です。初期値はモジュール変数 Debug から取られます。3 以上の値にすると各命令をトレースします。

IMAP4.utf8_enabled
Boolean value that is normally False, but is set to True if an enable() command is successfully issued for the UTF8=ACCEPT capability.

バージョン 3.5 で追加.

IMAP4 の使用例
以下にメールボックスを開き、全てのメッセージを取得して印刷する最小の (エラーチェックをしない) 使用例を示します:

import getpass, imaplib

M = imaplib.IMAP4()
M.login(getpass.getuser(), getpass.getpass())
M.select()
typ, data = M.search(None, 'ALL')
for num in data[0].split():
    typ, data = M.fetch(num, '(RFC822)')
    print('Message %s\n%s\n' % (num, data[0][1]))
M.close()
M.logout()


クイック検索
  |
nntplib --- NNTP プロトコルクライアント
ソースコード: Lib/nntplib.py

This module defines the class NNTP which implements the client side of the Network News Transfer Protocol. It can be used to implement a news reader or poster, or automated news processors. It is compatible with RFC 3977 as well as the older RFC 977 and RFC 2980.

以下にこのモジュールの使い方の小さな例を二つ示します。ニュースグループに関する統計情報を列挙し、最新 10 件の記事を出力するには以下のようにします:

>>>
>>> s = nntplib.NNTP('news.gmane.io')
>>> resp, count, first, last, name = s.group('gmane.comp.python.committers')
>>> print('Group', name, 'has', count, 'articles, range', first, 'to', last)
Group gmane.comp.python.committers has 1096 articles, range 1 to 1096
>>> resp, overviews = s.over((last - 9, last))
>>> for id, over in overviews:
...     print(id, nntplib.decode_header(over['subject']))
...
1087 Re: Commit privileges for Łukasz Langa
1088 Re: 3.2 alpha 2 freeze
1089 Re: 3.2 alpha 2 freeze
1090 Re: Commit privileges for Łukasz Langa
1091 Re: Commit privileges for Łukasz Langa
1092 Updated ssh key
1093 Re: Updated ssh key
1094 Re: Updated ssh key
1095 Hello fellow committers!
1096 Re: Hello fellow committers!
>>> s.quit()
'205 Bye!'
バイナリファイルから記事を投稿するには、以下のようにします。 (この例では記事番号は有効な番号を指定していて、あなたがそのニュースグループに投稿する 権限を持っていると仮定しています)

>>>
>>> s = nntplib.NNTP('news.gmane.io')
>>> f = open('article.txt', 'rb')
>>> s.post(f)
'240 Article posted successfully.'
>>> s.quit()
'205 Bye!'
このモジュール自体では以下のクラスを定義しています:

class nntplib.NNTP(host, port=119, user=None, password=None, readermode=None, usenetrc=False[, timeout])
Return a new NNTP object, representing a connection to the NNTP server running on host host, listening at port port. An optional timeout can be specified for the socket connection. If the optional user and password are provided, or if suitable credentials are present in /.netrc and the optional flag usenetrc is true, the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server. If the optional flag readermode is true, then a mode reader command is sent before authentication is performed. Reader mode is sometimes necessary if you are connecting to an NNTP server on the local machine and intend to call reader-specific commands, such as group. If you get unexpected NNTPPermanentErrors, you might need to set readermode. The NNTP class supports the with statement to unconditionally consume OSError exceptions and to close the NNTP connection when done, e.g.:

>>>
from nntplib import NNTP
with NNTP('news.gmane.io') as n:
    n.group('gmane.comp.python.committers')

('211 1755 1 1755 gmane.comp.python.committers', 1755, 1, 1755, 'gmane.comp.python.committers')
>>>
Raises an auditing event nntplib.connect with arguments self, host, port.

All commands will raise an auditing event nntplib.putline with arguments self and line, where line is the bytes about to be sent to the remote host.

バージョン 3.2 で変更: usenetrc がデフォルトで False になりました。

バージョン 3.3 で変更: with 構文のサポートが追加されました。

バージョン 3.9 で変更: timeout パラメータが0に設定されている場合、非ブロッキングソケットの作成を防ぐために ValueError を送出します。

class nntplib.NNTP_SSL(host, port=563, user=None, password=None, ssl_context=None, readermode=None, usenetrc=False[, timeout])
Return a new NNTP_SSL object, representing an encrypted connection to the NNTP server running on host host, listening at port port. NNTP_SSL objects have the same methods as NNTP objects. If port is omitted, port 563 (NNTPS) is used. ssl_context is also optional, and is a SSLContext object. Please read セキュリティで考慮すべき点 for best practices. All other parameters behave the same as for NNTP.

Note that SSL-on-563 is discouraged per RFC 4642, in favor of STARTTLS as described below. However, some servers only support the former.

Raises an auditing event nntplib.connect with arguments self, host, port.

All commands will raise an auditing event nntplib.putline with arguments self and line, where line is the bytes about to be sent to the remote host.

バージョン 3.2 で追加.

バージョン 3.4 で変更: このクラスは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

バージョン 3.9 で変更: timeout パラメータが0に設定されている場合、非ブロッキングソケットの作成を防ぐために ValueError を送出します。

exception nntplib.NNTPError
標準の例外 Exception から派生しており、 nntplib モジュールが送出する全ての例外の基底クラスです。このクラスのインスタンスは以下の属性を持っています:

response
利用可能な場合サーバの応答です。str オブジェクトです。

exception nntplib.NNTPReplyError
サーバから想定外の応答があったときに送出される例外。

exception nntplib.NNTPTemporaryError
400--499の範囲の応答コードを受け取ったときに送出される例外。

exception nntplib.NNTPPermanentError
500--599の範囲の応答コードを受け取ったときに送出される例外。

exception nntplib.NNTPProtocolError
1--5の数字で始まらない応答コードをサーバから受け取ったときに送出される例外。

exception nntplib.NNTPDataError
応答データに何らかのエラーがあったときに送出される例外。

NNTP オブジェクト
接続されたとき NNTP および NNTP_SSL オブジェクトは以下のメソッドと属性をサポートします:

属性
NNTP.nntp_version
サーバがサポートしている NNTP プロトコルのバージョンを表す整数です。 実際のところ、この値は RFC 3977 準拠を通知しているサーバでは 2 で、他の場合は 1 のはずです。

バージョン 3.2 で追加.

NNTP.nntp_implementation
NNTP サーバのソフトウェア名とバージョンを記述する文字列です。 サーバが通知していない場合は None です。

バージョン 3.2 で追加.

メソッド
全てのメソッドにおける戻り値のタプルで最初の要素となる response は、サーバの応答です: この文字列は 3 桁の数字からなるコードで始まります。サーバの応答がエラーを示す場合、上記のいずれかの例外が送出されます。

smtplib --- SMTP プロトコルクライアント¶
ソースコード: Lib/smtplib.py

smtplib モジュールは、SMTPまたはESMTPのリスナーデーモンを備えた任意のインターネット上のホストにメールを送るために使用することができる SMTPクライアント・セッション・オブジェクトを定義します。 SMTPおよびESMTPオペレーションの詳細は、 RFC 821 (Simple Mail Transfer Protocol) や RFC 1869 (SMTP Service Extensions)を調べてください。

class smtplib.SMTP(host='', port=0, local_hostname=None, [timeout, ]source_address=None)
SMTP インスタンスはSMTP接続をカプセル化します。SMTPとESMTP操作の完全なレパートリーをサポートするメソッドがあります。オプションパラメータのhostおよびportが指定されている場合、SMTPの connect() メソッドは初期化中にこれらのパラメータを使って呼び出されます。 local_hostname を指定した場合、それはHELO/EHLOコマンドのローカルホストのFQDNとして使用されます。指定しない場合、ローカルホスト名は socket.getfqdn() を使用して検索されます。 connect() 呼び出しが成功コード以外を返すと、 SMTPConnectError が送出されます。オプションの timeout パラメータは、接続試行のようなブロッキング操作のタイムアウトを秒単位で指定します（指定されていない場合、グローバルなデフォルトのタイムアウト設定が使用されます）。タイムアウトが切れると、 socket.timeout が送出されます。オプションのsource_addressパラメータを使用すると、複数のネットワークインターフェースを持つマシンの特定の送信元アドレス、かつ（または）特定の送信元TCPポートにバインドできます。接続する前にソケットを送信元アドレスとしてバインドするためにタプル(host, port)が必要です。省略された場合（あるいは、hostまたはportがそれぞれ '' かつ/または0の場合）、OSのデフォルト動作が使用されます。

For normal use, you should only require the initialization/connect, sendmail(), and SMTP.quit() methods. An example is included below.

The SMTP class supports the with statement. When used like this, the SMTP QUIT command is issued automatically when the with statement exits. E.g.:

>>>
>>> from smtplib import SMTP
>>> with SMTP("domain.org") as smtp:
...     smtp.noop()
...
(250, b'Ok')
>>>
All commands will raise an auditing event smtplib.SMTP.send with arguments self and data, where data is the bytes about to be sent to the remote host.

バージョン 3.3 で変更: with 構文のサポートが追加されました。

バージョン 3.3 で変更: source_address 引数が追加されました。

バージョン 3.5 で追加: SMTPUTF8 拡張 (RFC 6531) がサポートされました。

バージョン 3.9 で変更: If the timeout parameter is set to be zero, it will raise a ValueError to prevent the creation of a non-blocking socket

class smtplib.SMTP_SSL(host='', port=0, local_hostname=None, keyfile=None, certfile=None, [timeout, ]context=None, source_address=None)
SMTP_SSL インスタンスは SMTP と全く同じように動作します。SMTP_SSL は、接続の始めからSSLが必要であり、 starttls() が適切でない状況で使用するべきです。 host が指定されていない場合、ローカルホストが使用されます。 port が0の場合、標準のSMTP-over-SSLポート（465）が使用されます。オプション引数 local_hostname, timeout, source_address は SMTP クラスと同じ意味を持ちます。 context オプションは SSLContext を含むことができ、安全な接続のさまざまな側面を設定することができます。ベストプラクティスについては セキュリティで考慮すべき点 を読んでください。

keyfile and certfile are a legacy alternative to context, and can point to a PEM formatted private key and certificate chain file for the SSL connection.

バージョン 3.3 で変更: context が追加されました。

バージョン 3.3 で変更: source_address 引数が追加されました。

バージョン 3.4 で変更: このクラスは ssl.SSLContext.check_hostname と Server Name Indication でホスト名のチェックをサポートしました。(ssl.HAS_SNI を参照してください)。

バージョン 3.6 で非推奨: keyfile および certfile は非推奨となったので、 context を使ってください。 代わりに ssl.SSLContext.load_cert_chain() を使うか、または ssl.create_default_context() にシステムが信頼する CA 証明書を選んでもらうかしてください。

バージョン 3.9 で変更: If the timeout parameter is set to be zero, it will raise a ValueError to prevent the creation of a non-blocking socket

class smtplib.LMTP(host='', port=LMTP_PORT, local_hostname=None, source_address=None[, timeout])
The LMTP protocol, which is very similar to ESMTP, is heavily based on the standard SMTP client. It's common to use Unix sockets for LMTP, so our connect() method must support that as well as a regular host:port server. The optional arguments local_hostname and source_address have the same meaning as they do in the SMTP class. To specify a Unix socket, you must use an absolute path for host, starting with a '/'.

認証は、通常のSMTP機構を利用してサポートされています。 Unixソケットを利用する場合、LMTPは通常認証をサポートしたり要求したりはしません。しかし、あなたが必要であれば、利用することができます。

バージョン 3.9 で変更: The optional timeout parameter was added.

このモジュールの例外には次のものがあります:

exception smtplib.SMTPException
OSError の派生クラスで、このモジュールが提供する他の全ての例外の基底クラスです。

バージョン 3.4 で変更: SMTPException が OSError の派生クラスになりました。

exception smtplib.SMTPServerDisconnected
この例外はサーバが突然接続が切断されるか、SMTP インスタンスを生成する前に接続しようとした場合に送出されます。

exception smtplib.SMTPResponseException
SMTPのエラーコードを含んだ例外のクラスです。これらの例外はSMTPサーバがエラーコードを返すときに生成されます。エラーコードは smtp_code 属性に格納されます。また、 smtp_error 属性にはエラーメッセージが格納されます。

exception smtplib.SMTPSenderRefused
送信者のアドレスが弾かれたときに送出される例外です。全ての SMTPResponseException 例外に、 SMTPサーバが弾いた 'sender' アドレスの文字列がセットされます。

exception smtplib.SMTPRecipientsRefused
全ての受取人アドレスが弾かれたときに送出される例外です。各受取人のエラーは属性 recipients によってアクセス可能で、 SMTP.sendmail() が返す辞書と同じ並びの辞書になっています。

exception smtplib.SMTPDataError
SMTPサーバが、メッセージのデータを受け入れることを拒絶したときに送出される例外です。

exception smtplib.SMTPConnectError
サーバへの接続時にエラーが発生したときに送出される例外です。

exception smtplib.SMTPHeloError
サーバーが HELO メッセージを弾いたときに送出される例外です。

exception smtplib.SMTPNotSupportedError
試行したコマンドやオプションはサーバにサポートされていません。

バージョン 3.5 で追加.

exception smtplib.SMTPAuthenticationError
SMTP 認証が失敗しました。最もあり得るのは、サーバーがユーザ名/パスワードのペアを受け付なかった事です。

参考
RFC 821 - Simple Mail Transfer Protocol
SMTP のプロトコル定義です。このドキュメントでは SMTP のモデル、操作手順、プロトコルの詳細についてカバーしています。

RFC 1869 - SMTP Service Extensions
SMTP に対する ESMTP 拡張の定義です。このドキュメントでは、新たな命令による SMTP の拡張、サーバによって提供される命令を動的に発見する機能のサポート、およびいくつかの追加命令定義について記述しています。

SMTP オブジェクト
SMTP クラスインスタンスは次のメソッドを提供します:

SMTP.set_debuglevel(level)
デバッグ出力レベルを設定します。level が 1 や True の場合、接続ならびにサーバとの送受信のメッセージがデバッグメッセージとなります。level が 2 の場合、それらのメッセージにタイムスタンプが付きます。

バージョン 3.5 で変更: デバッグレベル2が追加されました。

SMTP.docmd(cmd, args='')
サーバへコマンド cmd を送信します。オプション引数 args はスペース文字でコマンドに連結します。戻り値は、整数値のレスポンスコードと、サーバからの応答の値をタプルで返します (サーバからの応答が数行に渡る場合でも一つの大きな文字列で返します)。

数値応答コードと実際の応答行 (複数の応答は 1 つの長い行に結合されます) からなる 2 値タプルを返します。

通常、このメソッドを明示的に使う必要はありません。他のメソッドを実装するのに使い、自分で拡張したものをテストするのに役立つかもしれません。

応答待ちのときにサーバへの接続が切れると SMTPServerDisconnected が送出されます。

SMTP.connect(host='localhost', port=0)
ホスト名とポート番号をもとに接続します。デフォルトはlocalhostの標準的なSMTPポート(25番)に接続します。もしホスト名の末尾がコロン(':')で、後に番号がついている場合は、「ホスト名:ポート番号」として扱われます。このメソッドはコンストラクタにホスト名及びポート番号が指定されている場合、自動的に呼び出されます。戻り値は、この接続の応答内でサーバによって送信された応答コードとメッセージの2要素タプルです。

Raises an auditing event smtplib.connect with arguments self, host, port.

SMTP.helo(name='')
SMTPサーバに HELO コマンドで身元を示します。デフォルトではhostname引数はローカルホストを指します。サーバーが返したメッセージは、オブジェクトの helo_resp 属性に格納されます。

通常は sendmail() が呼びだすため、これを明示的に呼び出す必要はありません。

SMTP.ehlo(name='')
EHLO を利用し、ESMTPサーバに身元を明かします。デフォルトではhostname引数はローカルホストのFQDNです。また、ESMTPオプションのために応答を調べたものは、 has_extn() に備えて保存されます。また、幾つかの情報を属性に保存します: サーバーが返したメッセージは ehlo_resp 属性に、 does_esmtp 属性はサーバーがESMTPをサポートしているかどうかによって true か false に、 esmtp_features 属性は辞書で、サーバーが対応しているSMTP サービス拡張の名前と、もしあればそのパラメータを格納します。

メールを送信する前に has_extn() を使おうとしない限り、このメソッドを明示的に呼ぶ必要はないはずです。必要な場合は sendmail() に暗黙的に呼ばれます。

SMTP.ehlo_or_helo_if_needed()
This method calls ehlo() and/or helo() if there has been no previous EHLO or HELO command this session. It tries ESMTP EHLO first.

SMTPHeloError
サーバーが HELO に正しく返答しませんでした。

SMTP.has_extn(name)
name が拡張SMTPサービスセットに含まれている場合には True を返し、そうでなければ False を返します。大小文字は区別されません。

SMTP.verify(address)
VRFY を利用してSMTPサーバにアドレスの妥当性をチェックします。妥当である場合はコード250と完全な RFC 822 アドレス (人名を含む) のタプルを返します。それ以外の場合は、400以上のエラーコードとエラー文字列を返します。

注釈 ほとんどのサイトはスパマーの裏をかくためにSMTPの VRFY は使用不可になっています。
SMTP.login(user, password, *, initial_response_ok=True)
認証が必要なSMTPサーバにログインします。認証に使用する引数はユーザ名とパスワードです。まだセッションが無い場合は、 EHLO または HELO コマンドでセッションを作ります。ESMTPの場合は EHLO が先に試されます。認証が成功した場合は通常このメソッドは戻りますが、例外が起こった場合は以下の例外が上がります:

SMTPHeloError
サーバーが HELO に正しく返答しませんでした。

SMTPAuthenticationError
サーバがユーザ名/パスワードでの認証に失敗しました。

SMTPNotSupportedError
AUTH コマンドはサーバにサポートされていません。

SMTPException
適当な認証方法が見付かりませんでした。

Each of the authentication methods supported by smtplib are tried in turn if they are advertised as supported by the server. See auth() for a list of supported authentication methods. initial_response_ok is passed through to auth().

オプションのキーワード引数 initial_response_ok は、それをサポートする認証方法に対して、チャレンジ/レスポンスを要求するのではなく、 "AUTH"コマンドとともに RFC 4954 で指定された"初期応答"を送信できるかどうかを指定します。

バージョン 3.5 で変更: SMTPNotSupportedError が送出される場合があります。initial_response_ok 引数が追加されました。

SMTP.auth(mechanism, authobject, *, initial_response_ok=True)
Issue an SMTP AUTH command for the specified authentication mechanism, and handle the challenge response via authobject.

mechanism specifies which authentication mechanism is to be used as argument to the AUTH command; the valid values are those listed in the auth element of esmtp_features.

authobject must be a callable object taking an optional single argument:

data = authobject(challenge=None)

If optional keyword argument initial_response_ok is true, authobject() will be called first with no argument. It can return the RFC 4954 "initial response" ASCII str which will be encoded and sent with the AUTH command as below. If the authobject() does not support an initial response (e.g. because it requires a challenge), it should return None when called with challenge=None. If initial_response_ok is false, then authobject() will not be called first with None.

If the initial response check returns None, or if initial_response_ok is false, authobject() will be called to process the server's challenge response; the challenge argument it is passed will be a bytes. It should return ASCII str data that will be base64 encoded and sent to the server.

The SMTP class provides authobjects for the CRAM-MD5, PLAIN, and LOGIN mechanisms; they are named SMTP.auth_cram_md5, SMTP.auth_plain, and SMTP.auth_login respectively. They all require that the user and password properties of the SMTP instance are set to appropriate values.

User code does not normally need to call auth directly, but can instead call the login() method, which will try each of the above mechanisms in turn, in the order listed. auth is exposed to facilitate the implementation of authentication methods not (or not yet) supported directly by smtplib.

バージョン 3.5 で追加.

SMTP.starttls(keyfile=None, certfile=None, context=None)
TLS (Transport Layer Security) モードで SMTP 接続します。続く全てのSMTP コマンドは暗号化されます。その後、もう一度 ehlo() を呼んでください。

If keyfile and certfile are provided, they are used to create an ssl.SSLContext.

Optional context parameter is an ssl.SSLContext object; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be None.

もしまだ EHLO か HELO コマンドが実行されていない場合、このメソッドは ESMTP EHLO を先に試します。

バージョン 3.6 で非推奨: keyfile および certfile は非推奨となったので、 context を使ってください。 代わりに ssl.SSLContext.load_cert_chain() を使うか、または ssl.create_default_context() にシステムが信頼する CA 証明書を選んでもらうかしてください。

SMTPHeloError
サーバーが HELO に正しく返答しませんでした。

SMTPNotSupportedError
サーバーが STARTTLS 拡張に対応していません。

RuntimeError
実行中の Python インタプリタで、SSL/TLS サポートが利用できません。

バージョン 3.3 で変更: context が追加されました。

バージョン 3.4 で変更: The method now supports hostname check with SSLContext.check_hostname and Server Name Indicator (see HAS_SNI).

バージョン 3.5 で変更: The error raised for lack of STARTTLS support is now the SMTPNotSupportedError subclass instead of the base SMTPException.

SMTP.sendmail(from_addr, to_addrs, msg, mail_options=(), rcpt_options=())
メールを送信します。必要な引数は RFC 822 のfromアドレス文字列、 RFC 822 のtoアドレス文字列またはアドレス文字列のリスト、メッセージ文字列です。送信側は MAIL FROM コマンドで使用される mail_options の ESMTPオプション(8bitmime のような)のリストを得るかもしれません。全ての RCPT コマンドで使われるべきESMTPオプション (例えば DSN コマンド)は、 rcpt_options を通して利用することができます。(もし送信先別にESMTPオプションを使う必要があれば、メッセージを送るために mail() 、 rcpt() 、 data() といった下位レベルのメソッドを使う必要があります。)

注釈 配送エージェントは from_addr、to_addrs 引数を使い、メッセージのエンベロープを構成します。sendmail はメッセージヘッダを修正しません。
msg may be a string containing characters in the ASCII range, or a byte string. A string is encoded to bytes using the ascii codec, and lone \r and \n characters are converted to \r\n characters. A byte string is not modified.

まだセッションが無い場合は、 EHLO または HELO コマンドでセッションを作ります。ESMTPの場合は EHLO が先に試されます。また、サーバがESMTP対応ならば、メッセージサイズとそれぞれ指定されたオプションも渡します。(featureオプションがあればサーバの広告をセットします) EHLO が失敗した場合は、ESMTPオプションの無い HELO が試されます。

このメソッドは最低でも1人の受信者にメールが受け取られたときは正常に戻ります。そうでない場合は例外を投げます。つまり、このメソッドが例外を送出しないときは誰かが送信したメールを受け取ったはずです。また、例外を送出しない場合は拒絶された受信者ごとに項目のある辞書を返します。各項目はサーバーが送ったSMTPエラーコードと付随するエラーメッセージのタプルを持ちます。

If SMTPUTF8 is included in mail_options, and the server supports it, from_addr and to_addrs may contain non-ASCII characters.

このメソッドは次の例外を送出することがあります:

SMTPRecipientsRefused
全ての受信を拒否され、誰にもメールが届けられませんでした。例外オブジェクトの recipients 属性は、受信拒否についての情報の入った辞書オブジェクトです。 (辞書は少なくとも一つは受信されたときに似ています)。

SMTPHeloError
サーバーが HELO に正しく返答しませんでした。

SMTPSenderRefused
サーバが from_addr を受理しませんでした。

SMTPDataError
サーバが予期しないエラーコードを返しました (受信拒否以外)。

SMTPNotSupportedError
mail_options に SMTPUTF8 が与えられましたが、サーバがサポートしていません。

また、この他の注意として、例外が上がった後もコネクションは開いたままになっています。

バージョン 3.2 で変更: msg はバイト文字列でも構いません。

バージョン 3.5 で変更: SMTPUTF8 のサポートが追加されました。SMTPUTF8 が与えられたが、サーバがサポートしていない場合は SMTPNotSupportedError が送出されます。

SMTP.send_message(msg, from_addr=None, to_addrs=None, mail_options=(), rcpt_options=())
This is a convenience method for calling sendmail() with the message represented by an email.message.Message object. The arguments have the same meaning as for sendmail(), except that msg is a Message object.

If from_addr is None or to_addrs is None, send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322: from_addr is set to the Sender field if it is present, and otherwise to the From field. to_addrs combines the values (if any) of the To, Cc, and Bcc fields from msg. If exactly one set of Resent-* headers appear in the message, the regular headers are ignored and the Resent-* headers are used instead. If the message contains more than one set of Resent-* headers, a ValueError is raised, since there is no way to unambiguously detect the most recent set of Resent- headers.

send_message serializes msg using BytesGenerator with \r\n as the linesep, and calls sendmail() to transmit the resulting message. Regardless of the values of from_addr and to_addrs, send_message does not transmit any Bcc or Resent-Bcc headers that may appear in msg. If any of the addresses in from_addr and to_addrs contain non-ASCII characters and the server does not advertise SMTPUTF8 support, an SMTPNotSupported error is raised. Otherwise the Message is serialized with a clone of its policy with the utf8 attribute set to True, and SMTPUTF8 and BODY=8BITMIME are added to mail_options.

バージョン 3.2 で追加.

バージョン 3.5 で追加: 国際化アドレスのサポート (SMTPUTF8)。

SMTP.quit()
SMTPセッションを終了し、接続を閉じます。SMTP QUIT コマンドの結果を返します。

下位レベルのメソッドは標準SMTP/ESMTPコマンド HELP 、 RSET 、 NOOP 、 MAIL 、 RCPT 、 DATA に対応しています。通常これらは直接呼ぶ必要はなく、また、ドキュメントもありません。詳細はモジュールのコードを調べてください。

SMTP 使用例
次の例は最低限必要なメールアドレス('To' と 'From')を含んだメッセージを送信するものです。この例では RFC 822 ヘッダの加工もしていません。メッセージに含まれるヘッダは、メッセージに含まれる必要があり、特に、明確な 'To'、と 'From' アドレスはメッセージヘッダに含まれている必要があります。

import smtplib

def prompt(prompt):
    return input(prompt).strip()

fromaddr = prompt("From: ")
toaddrs  = prompt("To: ").split()
print("Enter message, end with ^D (Unix) or ^Z (Windows):")

# Add the From: and To: headers at the start!
msg = ("From: %s\r\nTo: %s\r\n\r\n"
       % (fromaddr, ", ".join(toaddrs)))
while True:
    try:
        line = input()
    except EOFError:
        break
    if not line:
        break
    msg = msg + line

print("Message length is", len(msg))

server = smtplib.SMTP('localhost')
server.set_debuglevel(1)
server.sendmail(fromaddr, toaddrs, msg)
server.quit()
注釈 多くの場合、 email パッケージの機能を使って email メッセージを構築し、それを、 send_message() で送信する、という手順を用います。 email: 使用例 を参照してください。

smtpd --- SMTP サーバー¶
ソースコード: Lib/smtpd.py

このモジュールは SMTP (email) サーバを実装するためのいくつかのクラスを提供しています。

参考 The aiosmtpd package is a recommended replacement for this module. It is based on asyncio and provides a more straightforward API. smtpd should be considered deprecated.
サーバの実装がいくつかあります。一つはジェネリックで何もしない実装で、オーバーライドすることが出来ます。他の二つは特定のメール送信方策を提供しています。

また、SMTPChannel を拡張して SMTP クライアントとの特定の相互作用挙動を実装することができます。

コードは RFC 5321 に加え、RFC 1870 SIZE と RFC 6531 SMTPUTF8 拡張をサポートしています。

SMTPServer オブジェクト
class smtpd.SMTPServer(localaddr, remoteaddr, data_size_limit=33554432, map=None, enable_SMTPUTF8=False, decode_data=False)
新たな SMTPServer オブジェクトを作成し、それをローカルのアドレス localaddr に関連づけ (bind) ます。 このオブジェクトは remoteaddr を上流の SMTP リレー先とします。 localaddr と remoteaddr のどちらも (host, port) タプルである必要があります。 このクラスは asyncore.dispatcher を継承しており、インスタンス化時に自身を asyncore のイベントループに登録します。

data_size_limit には DATA コマンドが受け取る最大のバイト数を指定します。 None や 0 の場合上限はありません。

map is the socket map to use for connections (an initially empty dictionary is a suitable value). If not specified the asyncore global socket map is used.

enable_SMTPUTF8 determines whether the SMTPUTF8 extension (as defined in RFC 6531) should be enabled. The default is False. When True, SMTPUTF8 is accepted as a parameter to the MAIL command and when present is passed to process_message() in the kwargs['mail_options'] list. decode_data and enable_SMTPUTF8 cannot be set to True at the same time.

decode_data specifies whether the data portion of the SMTP transaction should be decoded using UTF-8. When decode_data is False (the default), the server advertises the 8BITMIME extension (RFC 6152), accepts the BODY=8BITMIME parameter to the MAIL command, and when present passes it to process_message() in the kwargs['mail_options'] list. decode_data and enable_SMTPUTF8 cannot be set to True at the same time.

process_message(peer, mailfrom, rcpttos, data, **kwargs)
Raise a NotImplementedError exception. Override this in subclasses to do something useful with this message. Whatever was passed in the constructor as remoteaddr will be available as the _remoteaddr attribute. peer is the remote host's address, mailfrom is the envelope originator, rcpttos are the envelope recipients and data is a string containing the contents of the e-mail (which should be in RFC 5321 format).

decode_data コンストラクタ引数が True の場合、 data 引数はユニコード文字列です。False の場合は bytes オブジェクトです。

kwargs is a dictionary containing additional information. It is empty if decode_data=True was given as an init argument, otherwise it contains the following keys:

mail_options:
MAIL コマンドが受け取る全ての引数のリストです (要素は大文字の文字列です; 例えば ['BODY=8BITMIME', 'SMTPUTF8'])。

rcpt_options:
RCPT コマンドのものである点以外は mail_options と同じです。今のところ RCPT TO オプションはサポートされていないため、これは常に空のリストです。

将来の仕様改善によって kwargs 辞書にキーが追加される可能性があるため、 process_message の実装で追加のキーワード引数を受け取るには **kwargs シグニチャを使うべきです。

通常の 250 Ok 応答には None を返します。そうでない場合求められる応答を RFC 5321 形式の文字列で返します。

channel_class
これを派生クラスでオーバーライドすることで、SMTP クライアントを管理するのにカスタムの SMTPChannel を使います。

バージョン 3.4 で追加: map コンストラクタ引数。

バージョン 3.5 で変更: localaddr および remoteaddr は IPv6 アドレスを持てるようになりました。

バージョン 3.5 で追加: The decode_data and enable_SMTPUTF8 constructor parameters, and the kwargs parameter to process_message() when decode_data is False.

バージョン 3.6 で変更: decode_data is now False by default.

DebuggingServer オブジェクト
class smtpd.DebuggingServer(localaddr, remoteaddr)
新たなデバッグ用サーバを生成します。引数は SMTPServer と同じです。メッセージが届いても無視し、標準出力に出力します。

PureProxy オブジェクト
class smtpd.PureProxy(localaddr, remoteaddr)
新たな単純プロキシ (pure proxy) サーバを生成します。引数は SMTPServer と同じです。全てのメッセージを remoteaddr にリレーします。このオブジェクトを動作させるとオープンリレーを作成してしまう可能性が多分にあります。注意してください。

MailmanProxy Objects
class smtpd.MailmanProxy(localaddr, remoteaddr)
Deprecated since version 3.9, will be removed in version 3.11: MailmanProxy is deprecated, it depends on a Mailman module which no longer exists and therefore is already broken.

新たな単純プロキシサーバを生成します。引数は SMTPServer と同じです。全てのメッセージを remoteaddr にリレーしますが、 ローカルの mailman の設定に remoteaddr がある場合には mailman を使って処理します。このオブジェクトを動作させるとオープンリレーを 作成してしまう可能性が多分にあります。注意してください。

SMTPChannel オブジェクト
class smtpd.SMTPChannel(server, conn, addr, data_size_limit=33554432, map=None, enable_SMTPUTF8=False, decode_data=False)
サーバと一つの SMTP クライアント間の通信を管理する SMTPChannel オブジェクトを新たに生成します。

conn and addr are as per the instance variables described below.

data_size_limit には DATA コマンドが受け取る最大のバイト数を指定します。 None や 0 の場合上限はありません。

enable_SMTPUTF8 determines whether the SMTPUTF8 extension (as defined in RFC 6531) should be enabled. The default is False. decode_data and enable_SMTPUTF8 cannot be set to True at the same time.

A dictionary can be specified in map to avoid using a global socket map.

decode_data specifies whether the data portion of the SMTP transaction should be decoded using UTF-8. The default is False. decode_data and enable_SMTPUTF8 cannot be set to True at the same time.

To use a custom SMTPChannel implementation you need to override the SMTPServer.channel_class of your SMTPServer.

バージョン 3.5 で変更: The decode_data and enable_SMTPUTF8 parameters were added.

バージョン 3.6 で変更: decode_data is now False by default.

SMTPChannel は以下のインスタンス変数を持っています:

smtp_server
このチャンネルを生成した SMTPServer を保持します。

conn
クライアントに接続しているソケットオブジェクトを保持します。

addr
Holds the address of the client, the second value returned by socket.accept

received_lines
Holds a list of the line strings (decoded using UTF-8) received from the client. The lines have their "\r\n" line ending translated to "\n".

smtp_state
Holds the current state of the channel. This will be either COMMAND initially and then DATA after the client sends a "DATA" line.

seen_greeting
Holds a string containing the greeting sent by the client in its "HELO".

mailfrom
Holds a string containing the address identified in the "MAIL FROM:" line from the client.

rcpttos
Holds a list of strings containing the addresses identified in the "RCPT TO:" lines from the client.

received_data
Holds a string containing all of the data sent by the client during the DATA state, up to but not including the terminating "\r\n.\r\n".

fqdn
Holds the fully-qualified domain name of the server as returned by socket.getfqdn().

peer
Holds the name of the client peer as returned by conn.getpeername() where conn is conn.

The SMTPChannel operates by invoking methods named smtp_<command> upon reception of a command line from the client. Built into the base SMTPChannel class are methods for handling the following commands (and responding to them appropriately):

コマンド

行う動作

HELO

クライアントのグリーティングを受け取り seen_greeting に格納します。サーバを基本コマンドモードに設定します。

EHLO

クライアントのグリーティングを受け取り seen_greeting に格納します。サーバを拡張コマンドモードに設定します。

NOOP

何もしません。

QUIT

接続をきれいに閉じます。

MAIL

"MAIL FROM:" シンタックスを受け取り提供されたアドレスを mailfrom として保存します。拡張コマンドモードでは RFC 1870 SIZE 属性を受け取り data_size_limit の値に基づき適切に応答します。

RCPT

"RCPT TO:" シンタックスを受け取り提供されたアドレスを rcpttos リストに格納します。

RSET

mailfrom, rcpttos, received_data をリセットしますが、グリーティングはリセットしません。

DATA

内部状態を DATA に設定し、クライアントからの残りの行を終端子 "\r\n.\r\n" を受け取るまで received_data に格納します。

HELP

最小の情報をコマンドシンタックスで返します。

VRFY

コード 252 (サーバはアドレスが有効か分かりません) を返します。

EXPN

コマンドが実装されていないことを報告します。

telnetlib --- Telnet クライアント¶
ソースコード: Lib/telnetlib.py

telnetlib モジュールでは、Telnet プロトコルを実装している Telnet クラスを提供します。Telnet プロトコルについての詳細は RFC 854 を参照してください。加えて、このモジュールでは Telnet プロトコルにおける制御文字 (下を参照してください) と、telnet オプションに対するシンボル定数を提供しています。telnet オプションに対するシンボル名は arpa/telnet.h の TELOPT_ がない状態での定義に従います。伝統的に arpa/telnet.h に含められていない telnet オプションのシンボル名については、このモジュールのソースコード自体を参照してください。

telnet コマンドのシンボル定数は、IAC、DONT、DO、WONT、WILL、SE (サブネゴシエーション終了)、NOP (何もしない)、DM (データマーク)、BRK (ブレーク)、IP (プロセス中断)、AO (出力停止)、AYT (応答確認)、EC (文字削除)、EL (行削除)、GA (進め)、SB (サブネゴシエーション開始) です。

class telnetlib.Telnet(host=None, port=0[, timeout])
Telnet は Telnet サーバへの接続を表現します。デフォルトでは、 Telnet クラスのインスタンスは最初はサーバに接続していません。接続を確立するには open() を使わなければなりません。別の方法として、コンストラクタにホスト名とオプションのポート番号を渡すこともできます。この場合はコンストラクタの呼び出しが返る以前にサーバへの接続が確立されます。オプション引数の timeout が渡された場合、コネクション接続時のタイムアウト時間を秒数で指定します (指定されなかった場合は、グローバルのデフォルトタイムアウト設定が利用されます)。

すでに接続の開かれているンスタンスを再度開いてはいけません。

このクラスは多くの read_*() メソッドを持っています。これらのメソッドのいくつかは、接続の終端を示す文字を読み込んだ場合に EOFError を送出するので注意してください。例外を送出するのは、これらの関数が終端に到達しなくても空の文字列を返す可能性があるからです。詳しくは下記の個々の説明を参照してください。

Telnet オブジェクトはコンテキストマネージャであり、 with 文で使えます。 with ブロックから抜けるとき、 close() メソッドが呼び出されます:

>>>
>>> from telnetlib import Telnet
>>> with Telnet('localhost', 23) as tn:
...     tn.interact()
...
バージョン 3.6 で変更: コンテキストマネージャーサポートが追加されました。

参考
RFC 854 - Telnet プロトコル仕様
Telnet プロトコルの定義。

Telnet オブジェクト
Telnet インスタンスは以下のメソッドを持っています:

Telnet.read_until(expected, timeout=None)
expected で指定されたバイト文字列を読み込むか、timeout で指定された秒数が経過するまで読み込みます。

与えられた文字列に一致する部分が見つからなかった場合、読み込むことができたもの全てを返します。これは空のバイト列になる可能性があります。接続が閉じられ、転送処理済みのデータが得られない場合には EOFError が送出されます。

Telnet.read_all()
EOFに到達するまでの全てのデータをバイト列として読み込みます; 接続が閉じられるまでブロックします。

Telnet.read_some()
EOF に到達しない限り、少なくとも 1 バイトの転送処理済みデータを読み込みます。EOF に到達した場合は b'' を返します。すぐに読み出せるデータが存在しない場合にはブロックします。

Telnet.read_very_eager()
I/O によるブロックを起こさずに読み出せる全てのデータを読み込みます (eager モード)。

接続が閉じられており、転送処理済みのデータとして読み出せるものがない場合には EOFError が送出されます。それ以外の場合で、単に読み出せるデータがない場合には b'' を返します。 IAC シーケンス操作中でないかぎりブロックしません。

Telnet.read_eager()
現在すぐに読み出せるデータを読み出します。

接続が閉じられており、転送処理済みのデータとして読み出せるものがない場合には EOFError が送出されます。それ以外の場合で、単に読み出せるデータがない場合には b'' を返します。 IAC シーケンス操作中でないかぎりブロックしません。

Telnet.read_lazy()
すでにキューに入っているデータを処理して返します (lazy モード)。

接続が閉じられており、読み出せるデータがない場合には EOFError を送出します。それ以外の場合で、転送処理済みのデータで読み出せるものがない場合には b'' を返します。 IAC シーケンス操作中でないかぎりブロックしません。

Telnet.read_very_lazy()
すでに処理済みキューに入っているデータを処理して返します (very lazy モード)。

接続が閉じられており、読み出せるデータがない場合には EOFError を送出します。それ以外の場合で、転送処理済みのデータで読み出せるものがない場合には b'' を返します。このメソッドは決してブロックしません。

Telnet.read_sb_data()
SB/SE ペア (サブオプション開始／終了) の間に収集されたデータを返します。 SE コマンドによって起動されたコールバック関数はこれらのデータにアクセスしなければなりません。このメソッドはけっしてブロックしません。

Telnet.open(host, port=0[, timeout])
サーバホストに接続します。第二引数はオプションで、ポート番号を指定します。標準の値は通常の Telnet ポート番号 (23) です。オプション引数の timeout が渡された場合、コネクション接続時などのブロックする操作のタイムアウト時間を秒数で指定します (指定されなかった場合は、グローバルのデフォルトタイムアウト設定が利用されます)。

すでに接続しているインスタンスで再接続を試みてはいけません。

引数 self, host, port 付きで 監査イベント telnetlib.Telnet.open を送出します。

Telnet.msg(msg, *args)
デバッグレベルが > 0 のとき、デバッグ用のメッセージを出力します。追加の引数が存在する場合、標準の文字列書式化演算子 % を使って msg 中の書式指定子に代入されます。

Telnet.set_debuglevel(debuglevel)
デバッグレベルを設定します。 debuglevel が大きくなるほど、 (sys.stdout に) デバッグメッセージがたくさん出力されます。

Telnet.close()
コネクションをクローズします。

Telnet.get_socket()
内部的に使われているソケットオブジェクトです。

Telnet.fileno()
内部的に使われているソケットオブジェクトのファイル記述子です。

Telnet.write(buffer)
ソケットにバイト文字列を書き込みます。このとき IAC 文字については 2 度送信します。接続がブロックした場合、書き込みがブロックする可能性があります。接続が閉じられた場合、 OSError が送出されるかもしれません。

引数 self, buffer 付きで 監査イベント telnetlib.Telnet.write を送出します。

バージョン 3.3 で変更: このメソッドは以前は socket.error を投げていましたが、これは現在では OSError の別名になっています。

Telnet.interact()
非常に低機能の telnet クライアントをエミュレートする対話関数です。

Telnet.mt_interact()
interact() のマルチスレッド版です。

Telnet.expect(list, timeout=None)
正規表現のリストのうちどれか一つにマッチするまでデータを読みます。

第一引数は正規表現のリストです。コンパイルされたもの (regex オブジェクト) でも、コンパイルされていないもの (バイト文字列) でもかまいません。オプションの第二引数はタイムアウトで、単位は秒です。標準の値は無期限に設定されています。

3 つの要素からなるタプル: 最初にマッチした正規表現のインデクス; 返されたマッチオブジェクト; マッチ部分を含む、マッチするまでに読み込まれたバイト列、を返します。

ファイル終了子が見つかり、かつ何もバイト列が読み込まれなかった場合、 EOFError が送出されます。そうでない場合で何もマッチしなかった場合には (-1, None, data) が返されます。ここで data はこれまで受信したバイト列です (タイムアウトが発生した場合には空のバイト列になる場合もあります)。

正規表現の末尾が (.* のような) 貪欲マッチングになっている場合や、入力に対して 1 つ以上の正規表現がマッチする場合には、その結果は決定不能で、I/O のタイミングに依存するでしょう。

Telnet.set_option_negotiation_callback(callback)
telnet オプションが入力フローから読み込まれるたびに、 callback が (設定されていれば) 以下の引数形式: callback(telnet socket, command (DO/DONT/WILL/WONT), option) で呼び出されます。その後 telnet オプションに対しては telnetlib は何も行いません。

Telnet Example
典型的な使用例のサンプルコード:

import getpass
import telnetlib

HOST = "localhost"
user = input("Enter your remote account: ")
password = getpass.getpass()

tn = telnetlib.Telnet(HOST)

tn.read_until(b"login: ")
tn.write(user.encode('ascii') + b"\n")
if password:
    tn.read_until(b"Password: ")
    tn.write(password.encode('ascii') + b"\n")

tn.write(b"ls\n")
tn.write(b"exit\n")

print(tn.read_all().decode('ascii'))

uuid --- RFC 4122 に基づくUUID オブジェクト
ソースコード: Lib/uuid.py

このモジュールでは immutable (変更不能) な UUID オブジェクト (UUID クラス) と RFC 4122 の定めるバージョン 1、3、4、5 の UUID を生成するための uuid1(), uuid3(), uuid4(), uuid5(), が提供されています。

もしユニークな ID が必要なだけであれば、おそらく uuid1() か uuid4() を呼び出せば良いでしょう。 uuid1() はコンピュータのネットワークアドレスを含む UUID を生成するためにプライバシーを侵害するかもしれない点に注意してください。 uuid4() はランダムな UUID を生成します。

使用しているプラットフォームによっては、uuid1() 関数は安全でないUUID を返す可能性があります。ここでいう「安全な」UUID とは、同期的に生成され、異なるプロセスに同じUUID が与えられることがないものを言います。UUID のすべてのインスタンスは:attr:is_safe 属性を持ち、次の項目を使用します:

class uuid.SafeUUID
バージョン 3.7 で追加.

safe
UUID は並列処理に対して安全なプラットフォームで生成された

unsafe
UUID は並列処理に対して安全なプラットフォームで生成されなかった

unknown
プラットフォームは、UUID が安全に生成されたかどうかの情報を提供しなかった

class uuid.UUID(hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=SafeUUID.unknown)
32 桁の 16 進数文字列、bytes に 16 バイトのビッグエンディアンの文字列、bytes_le 引数に 16 バイトのリトルエンディアンの文字列、fields 引数に 6 つの整数のタプル（32ビット time_low, 16 ビット time_mid, 16ビット time_hi_version, 8ビット clock_seq_hi_variant, 8ビット clock_seq_low, 48ビット node ）、または int に一つの 128 ビット整数のいずれかから UUID を生成します。16 進数が与えられた時、波括弧、ハイフン、それと URN 接頭辞は無視されます。例えば、これらの表現は全て同じ UUID を払い出します:

UUID('{12345678-1234-5678-1234-567812345678}')
UUID('12345678123456781234567812345678')
UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
UUID(bytes=b'\x12\x34\x56\x78'*4)
UUID(bytes_le=b'\x78\x56\x34\x12\x34\x12\x78\x56' +
              b'\x12\x34\x56\x78\x12\x34\x56\x78')
UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
UUID(int=0x12345678123456781234567812345678)
hex, bytes, bytes_le, fields, または int のうち、どれかただ一つだけが与えられなければいけません。version 引数はオプションです; 与えられた場合、結果の UUID は与えられた hex, bytes, bytes_le, fields, または int をオーバーライドして、RFC 4122 に準拠した variant と version ナンバーのセットを持つことになります。bytes_le, fields, or int.

2つのUUIDオブジェクトの比較は、UUID.int 属性の比較によって行われます。UUIDではないオブジェクトとの比較は、 TypeError を送出します。

str(uuid) は 32桁の16進でUUIDを表す``12345678-1234-5678-1234-567812345678`` 形式の文字列を返します。

UUID インスタンスは以下の読み出し専用属性を持ちます:

UUID.bytes
16 バイト文字列（バイトオーダーがビッグエンディアンの 6 つの整数フィールドを持つ）のUUID。

UUID.bytes_le
16 バイト文字列（ time_low, time_mid, time_hi_version をリトルエンディアンで持つ）の UUID。

UUID.fields
UUID の 6 つの整数フィールドを持つタプルで、これは 6 つの個別の属性と 2 つの派生した属性としても取得可能です:

フィールド

意味

time_low

UUID の最初の 32 ビット

time_mid

UUID の次の 16 ビット

time_hi_version

UUID の次の 16 ビット

clock_seq_hi_variant

UUID の次の 8 ビット

clock_seq_low

UUID の次の 8 ビット

node

UUID の最後の 48 ビット

time

60 ビットのタイムスタンプ

clock_seq

14 ビットのシーケンス番号

UUID.hex
32 文字の 16 進数文字列での UUID。

UUID.int
128 ビット整数での UUID。

UUID.urn
RFC 4122 で規定される URN での UUID。

UUID.variant
UUID の内部レイアウトを決定する UUID の variant。これは定数 RESERVED_NCS, RFC_4122, RESERVED_MICROSOFT, RESERVED_FUTURE のいずれかです。

UUID.version
UUID の version 番号（1 から 5、variant が RFC_4122 である場合だけ意味があります）。

UUID.is_safe
SafeUUID の列挙で、UUID は並列処理に対して安全なプラットフォームで生成されたかを示す。

バージョン 3.7 で追加.

The uuid モジュールには以下の関数があります:

uuid.getnode()
48 ビットの正の整数としてハードウェアアドレスを取得します。最初にこれを起動すると、別個のプログラムが立ち上がって非常に遅くなることがあります。もしハードウェアを取得する試みが全て失敗すると、ランダムな 48 ビットを、RFC 4122 で推奨されているように、マルチキャストビット (最初のオクテットの最下位ビット) を 1 に設定して使います。"ハードウェアアドレス" とはネットワークインターフェースの MAC アドレスを指します。複数のネットワークインターフェースを持つマシンの場合、全域管理されたMACアドレス (最初のオクテットの下位より2番目のビットが 設定されていない MACアドレス) が、他の個別管理アドレスよりも優先的に使用されます。この優先順序は保証されません。

バージョン 3.7 で変更: 全域管理されたMACアドレスは、グローバルに固有であると保証されるため、固有である保証のない個別管理アドレスよりも好ましいです。

uuid.uuid1(node=None, clock_seq=None)
UUID をホスト ID、シーケンス番号、現在時刻から生成します。 node が与えられなければ、 getnode() がハードウェアアドレス取得のために使われます。 clock_seq が与えられると、これはシーケンス番号として使われます; さもなくば 14 ビットのランダムなシーケンス番号が選ばれます。

uuid.uuid3(namespace, name)
UUID を名前空間識別子 (UUID) と名前 (文字列) の MD5 ハッシュから生成します。

uuid.uuid4()
ランダムな UUID を生成します。

uuid.uuid5(namespace, name)
名前空間識別子(これは UUID です)と名前(文字列です)の SHA-1 ハッシュからUUIDを生成します。

uuid モジュールは uuid3() または uuid5() で利用するために次の名前空間識別子を定義しています。

uuid.NAMESPACE_DNS
この名前空間が指定された場合、name 文字列は完全修飾ドメイン名です。

uuid.NAMESPACE_URL
この名前空間が指定された場合、name 文字列は URL です。

uuid.NAMESPACE_OID
この名前空間が指定された場合、name 文字列は ISO OID です。

uuid.NAMESPACE_X500
この名前空間が指定された場合、name 文字列は X.500 DN の DER またはテキスト出力形式です。

The uuid モジュールは以下の定数を variant 属性が取りうる値として定義しています:

uuid.RESERVED_NCS
NCS 互換性のために予約されています。

uuid.RFC_4122
RFC 4122 で与えられた UUID レイアウトを指定します。

uuid.RESERVED_MICROSOFT
Microsoft の互換性のために予約されています。

uuid.RESERVED_FUTURE
将来のために予約されています。

参考
RFC 4122 - Universally Unique IDentifier (UUID) の URN 名前空間
この仕様は UUID のための Uniform Resource Name 名前空間、UUID の内部フォーマットと UUID の生成方法を定義しています。

使用例
典型的な uuid モジュールの利用方法を示します:

>>>
>>> import uuid

>>> # make a UUID based on the host ID and current time
>>> uuid.uuid1()
UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')

>>> # make a UUID using an MD5 hash of a namespace UUID and a name
>>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')
UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')

>>> # make a random UUID
>>> uuid.uuid4()
UUID('16fd2706-8baf-433b-82eb-8c7fada847da')

>>> # make a UUID using a SHA-1 hash of a namespace UUID and a name
>>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')
UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')

>>> # make a UUID from a string of hex digits (braces and hyphens ignored)
>>> x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')

>>> # convert a UUID to a string of hex digits in standard form
>>> str(x)
'00010203-0405-0607-0809-0a0b0c0d0e0f'

>>> # get the raw 16 bytes of the UUID
>>> x.bytes
b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'

>>> # make a UUID from a 16-byte string
>>> uuid.UUID(bytes=x.bytes)
UUID('00010203-0405-0607-0809-0a0b0c0d0e0f')

http.cookies --- HTTPの状態管理¶
ソースコード: Lib/http/cookies.py

http.cookies モジュールはHTTPの状態管理機能であるcookieの概念を抽象化、定義しているクラスです。単純な文字列のみで構成されるcookieのほか、シリアル化可能なあらゆるデータ型でクッキーの値を保持するための機能も備えています。

このモジュールは元々 RFC 2109 と RFC 2068 に定義されている構文解析の規則を厳密に守っていました。しかし、MSIE 3.0x がこれらの RFC で定義された文字の規則に従っていないことが判明し、また、現代の多くのブラウザとサーバも Cookie の処理に緩い解析をしており、結局、やや厳密さを欠く構文解析規則にせざるを得ませんでした。

文字集合 string.ascii_letters 、 string.digits 、 !#$%&'*+-.^_`|~: を、このモジュールは Cookie 名 (key) として有効と認めています。

バージョン 3.3 で変更: ':' が有効な Cookie 名の文字として認められました。

注釈 不正な cookie に遭遇した場合、 CookieError 例外を送出します。そのため、ブラウザから持ってきた cookie データをパースするときには常に不正なデータに備え CookieError 例外を捕捉してください。
exception http.cookies.CookieError
属性や Set-Cookie ヘッダが正しくないなど、 RFC 2109 に合致していないときに発生する例外です。

class http.cookies.BaseCookie([input])
このクラスはキーが文字列、値が Morsel インスタンスで構成される辞書風オブジェクトです。値に対するキーを設定するときは、値がキーと値を含む Morsel に変換されることに注意してください。

input が与えられたときは、そのまま load() メソッドへ渡されます。

class http.cookies.SimpleCookie([input])
This class derives from BaseCookie and overrides value_decode() and value_encode(). SimpleCookie supports strings as cookie values. When setting the value, SimpleCookie calls the builtin str() to convert the value to a string. Values received from HTTP are kept as strings.

参考
モジュール http.cookiejar
Web クライアント 向けの HTTP クッキー処理です。 http.cookiejar と http.cookies は互いに独立しています。

RFC 2109 - HTTP State Management Mechanism
このモジュールが実装しているHTTPの状態管理に関する規格です。

Cookieオブジェクト
BaseCookie.value_decode(val)
Return a tuple (real_value, coded_value) from a string representation. real_value can be any type. This method does no decoding in BaseCookie --- it exists so it can be overridden.

BaseCookie.value_encode(val)
Return a tuple (real_value, coded_value). val can be any type, but coded_value will always be converted to a string. This method does no encoding in BaseCookie --- it exists so it can be overridden.

通常 value_encode() と value_decode() はともに value_decode の処理内容から逆算した範囲に収まっていなければなりません。

BaseCookie.output(attrs=None, header='Set-Cookie:', sep='\r\n')
HTTPヘッダ形式の文字列表現を返します。 attrs と header はそれぞれ Morsel の output() メソッドに送られます。 sep はヘッダの連結に用いられる文字で、デフォルトは '\r\n' (CRLF)となっています。

BaseCookie.js_output(attrs=None)
ブラウザがJavaScriptをサポートしている場合、HTTPヘッダを送信した場合と同様に動作する埋め込み可能なJavaScript snippetを返します。

attrs の意味は output() と同じです。

BaseCookie.load(rawdata)
rawdata が文字列であれば、 HTTP_COOKIE として処理し、その値を Morsel として追加します。辞書の場合は次と同様の処理をおこないます。

for k, v in rawdata.items():
    cookie[k] = v
Morselオブジェクト
class http.cookies.Morsel
RFC 2109 の属性をキーと値で保持するabstractクラスです。

Morselは辞書風のオブジェクトで、キーは次のような RFC 2109 準拠の定数となっています。

expires

path

comment

domain

max-age

secure

version

httponly

samesite

httponly 属性は、 cookie が HTTP リクエストでのみ送信されて、 JavaScript からのはアクセスできない事を示します。これはいくつかのクロスサイトスクリプティングの脅威を和らげることを意図しています。

The attribute samesite specifies that the browser is not allowed to send the cookie along with cross-site requests. This helps to mitigate CSRF attacks. Valid values for this attribute are "Strict" and "Lax".

キーの大小文字は区別されません。そのデフォルト値は '' です。

バージョン 3.5 で変更: __eq__() は key 及び value を考慮するようになりました。

バージョン 3.7 で変更: Attributes key, value and coded_value are read-only. Use set() for setting them.

バージョン 3.8 で変更: Added support for the samesite attribute.

Morsel.value
クッキーの値。

Morsel.coded_value
実際に送信する形式にエンコードされたcookieの値。

Morsel.key
cookieの名前。

Morsel.set(key, value, coded_value)
属性 key 、 value 、 coded_value に値をセットします。

Morsel.isReservedKey(K)
K が Morsel のキーであるかどうかを判定します。

Morsel.output(attrs=None, header='Set-Cookie:')
MoselをHTTPヘッダ形式の文字列表現にして返します。 attrs を指定しない場合、デフォルトですべての属性を含めます。 attrs を指定する場合、属性をリストで渡さなければなりません。 header のデフォルトは "Set-Cookie:" です。

Morsel.js_output(attrs=None)
ブラウザがJavaScriptをサポートしている場合、HTTPヘッダを送信した場合と同様に動作する埋め込み可能なJavaScript snippetを返します。

attrs の意味は output() と同じです。

Morsel.OutputString(attrs=None)
Moselの文字列表現をHTTPやJavaScriptで囲まずに出力します。

attrs の意味は output() と同じです。

Morsel.update(values)
Morsel 辞書の値を辞書 values の値で更新します。values 辞書のキーのいずれかが有効な RFC 2109 属性でない場合エラーを送出します。

バージョン 3.5 で変更: 不正なキーではエラーが送出されます。

Morsel.copy(value)
Morsel オブジェクトの浅いコピーを返します。

バージョン 3.5 で変更: 辞書ではなく Morsel オブジェクトを返します。

Morsel.setdefault(key, value=None)
キーが有効な RFC 2109 属性でない場合エラーを送出します。そうでない場合は dict.setdefault() と同じように振る舞います。

使用例
次の例は http.cookies の使い方を示したものです。

>>> from http import cookies
>>> C = cookies.SimpleCookie()
>>> C["fig"] = "newton"
>>> C["sugar"] = "wafer"
>>> print(C) # generate HTTP headers
Set-Cookie: fig=newton
Set-Cookie: sugar=wafer
>>> print(C.output()) # same thing
Set-Cookie: fig=newton
Set-Cookie: sugar=wafer
>>> C = cookies.SimpleCookie()
>>> C["rocky"] = "road"
>>> C["rocky"]["path"] = "/cookie"
>>> print(C.output(header="Cookie:"))
Cookie: rocky=road; Path=/cookie
>>> print(C.output(attrs=[], header="Cookie:"))
Cookie: rocky=road
>>> C = cookies.SimpleCookie()
>>> C.load("chips=ahoy; vienna=finger") # load from a string (HTTP header)
>>> print(C)
Set-Cookie: chips=ahoy
Set-Cookie: vienna=finger
>>> C = cookies.SimpleCookie()
>>> C.load('keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";')
>>> print(C)
Set-Cookie: keebler="E=everybody; L=\"Loves\"; fudge=\012;"
>>> C = cookies.SimpleCookie()
>>> C["oreo"] = "doublestuff"
>>> C["oreo"]["path"] = "/"
>>> print(C)
Set-Cookie: oreo=doublestuff; Path=/
>>> C = cookies.SimpleCookie()
>>> C["twix"] = "none for you"
>>> C["twix"].value
'none for you'
>>> C = cookies.SimpleCookie()
>>> C["number"] = 7 # equivalent to C["number"] = str(7)
>>> C["string"] = "seven"
>>> C["number"].value
'7'
>>> C["string"].value
'seven'
>>> print(C)
Set-Cookie: number=7
Set-Cookie: string=seven

http.cookiejar --- HTTP クライアント用の Cookie 処理¶
ソースコード: Lib/http/cookiejar.py

http.cookiejar モジュールは HTTP クッキーの自動処理をおこなうクラスを定義します。これは小さなデータの断片 -- クッキー -- を要求する web サイトにアクセスする際に有用です。クッキーとは web サーバの HTTP レスポンスによってクライアントのマシンに設定され、のちの HTTP リクエストをおこなうさいにサーバに返されるものです。

標準的な Netscape クッキープロトコルおよび RFC 2965 で定義されているプロトコルの両方を処理できます。RFC 2965 の処理はデフォルトではオフになっています。 RFC 2109 のクッキーは Netscape クッキーとして解析され、のちに有効な 'ポリシー' に従って Netscapeまたは RFC 2965 クッキーとして処理されます。但し、インターネット上の大多数のクッキーは Netscapeクッキーです。 http.cookiejar はデファクトスタンダードの Netscape クッキープロトコル (これは元々 Netscape が策定した仕様とはかなり異なっています) に従うようになっており、RFC 2109 で導入された max-age や port などのクッキー属性にも注意を払います。

注釈 Set-Cookie や Set-Cookie2 ヘッダに現れる多種多様なパラメータの名前 (domain や expires など) は便宜上 属性 と呼ばれますが、ここでは Python の属性と区別するため、かわりに クッキー属性 と呼ぶことにします。
このモジュールは以下の例外を定義しています:

exception http.cookiejar.LoadError
この例外は FileCookieJar インスタンスがファイルからクッキーを読み込むのに失敗した場合に発生します。 LoadError は OSError のサブクラスです。

バージョン 3.3 で変更: LoadError was made a subclass of OSError instead of IOError.

以下のクラスが提供されています:

class http.cookiejar.CookieJar(policy=None)
policy は CookiePolicy インターフェイスを実装するオブジェクトです。

CookieJar クラスには HTTP クッキーを保管します。これは HTTP リクエストに応じてクッキーを取り出し、それを HTTP レスポンスの中で返します。必要に応じて、 CookieJar インスタンスは保管されているクッキーを自動的に破棄します。このサブクラスは、クッキーをファイルやデータベースに格納したり取り出したりする操作をおこなう役割を負っています。

class http.cookiejar.FileCookieJar(filename, delayload=None, policy=None)
policy は CookiePolicy インターフェイスを実装するオブジェクトです。これ以外の引数については、該当する属性の説明を参照してください。

FileCookieJar はディスク上のファイルからのクッキーの読み込み、もしくは書き込みをサポートします。実際には、 load() または revert() のどちらかのメソッドが呼ばれるまでクッキーは指定されたファイルからはロード されません 。このクラスのサブクラスは FileCookieJar のサブクラスと web ブラウザとの連携 節で説明します。

バージョン 3.8 で変更: The filename parameter supports a path-like object.

class http.cookiejar.CookiePolicy
このクラスは、あるクッキーをサーバから受け入れるべきか、そしてサーバに返すべきかを決定する役割を負っています。

class http.cookiejar.DefaultCookiePolicy(blocked_domains=None, allowed_domains=None, netscape=True, rfc2965=False, rfc2109_as_netscape=None, hide_cookie2=False, strict_domain=False, strict_rfc2965_unverifiable=True, strict_ns_unverifiable=False, strict_ns_domain=DefaultCookiePolicy.DomainLiberal, strict_ns_set_initial_dollar=False, strict_ns_set_path=False, secure_protocols=("https", "wss"))
Constructor arguments should be passed as keyword arguments only. blocked_domains is a sequence of domain names that we never accept cookies from, nor return cookies to. allowed_domains if not None, this is a sequence of the only domains for which we accept and return cookies. secure_protocols is a sequence of protocols for which secure cookies can be added to. By default https and wss (secure websocket) are considered secure protocols. For all other arguments, see the documentation for CookiePolicy and DefaultCookiePolicy objects.

DefaultCookiePolicy implements the standard accept / reject rules for Netscape and RFC 2965 cookies. By default, RFC 2109 cookies (ie. cookies received in a Set-Cookie header with a version cookie-attribute of 1) are treated according to the RFC 2965 rules. However, if RFC 2965 handling is turned off or rfc2109_as_netscape is True, RFC 2109 cookies are 'downgraded' by the CookieJar instance to Netscape cookies, by setting the version attribute of the Cookie instance to 0. DefaultCookiePolicy also provides some parameters to allow some fine-tuning of policy.

class http.cookiejar.Cookie
This class represents Netscape, RFC 2109 and RFC 2965 cookies. It is not expected that users of http.cookiejar construct their own Cookie instances. Instead, if necessary, call make_cookies() on a CookieJar instance.

参考
urllib.request モジュール
クッキーの自動処理をおこない URL を開くモジュールです。

http.cookies モジュール
HTTP のクッキークラスで、基本的にはサーバサイドのコードで有用です。 http.cookiejar および http.cookies モジュールは互いに依存してはいません。

https://curl.haxx.se/rfc/cookie_spec.html
元祖 Netscape のクッキープロトコルの仕様です。今でもこれが主流のプロトコルですが、現在のメジャーなブラウザ (と http.cookiejar) が実装している「Netscape クッキープロトコル」は cookie_spec.html で述べられているものとおおまかにしか似ていません。

RFC 2109 - HTTP State Management Mechanism
Obsoleted by RFC 2965. Uses Set-Cookie with version=1.

RFC 2965 - HTTP State Management Mechanism
Netscape プロトコルのバグを修正したものです。 Set-Cookie のかわりに Set-Cookie2 を使いますが、普及してはいません。

http://kristol.org/cookie/errata.html
Unfinished errata to RFC 2965.

RFC 2964 - Use of HTTP State Management

CookieJar および FileCookieJar オブジェクト
CookieJar オブジェクトは保管されている Cookie オブジェクトをひとつずつ取り出すための、 イテレータ プロトコルをサポートしています。

CookieJar は以下のようなメソッドを持っています:

CookieJar.add_cookie_header(request)
request に正しい Cookie ヘッダを追加します。

ポリシーが許すようであれば (CookieJar の CookiePolicy インスタンスにある属性のうち、 rfc2965 および hide_cookie2 がそれぞれ真と偽であるような場合)、必要に応じて Cookie2 ヘッダも追加されます。

The request object (usually a urllib.request.Request instance) must support the methods get_full_url(), get_host(), get_type(), unverifiable(), has_header(), get_header(), header_items(), add_unredirected_header() and origin_req_host attribute as documented by urllib.request.

バージョン 3.3 で変更: request object needs origin_req_host attribute. Dependency on a deprecated method get_origin_req_host() has been removed.

CookieJar.extract_cookies(response, request)
HTTP response からクッキーを取り出し、ポリシーによって許可されていればこれを CookieJar 内に保管します。

CookieJar は response 引数の中から許可されている Set-Cookie および Set-Cookie2 ヘッダを探しだし、適切に (CookiePolicy.set_ok() メソッドの承認におうじて) クッキーを保管します。

The response object (usually the result of a call to urllib.request.urlopen(), or similar) should support an info() method, which returns an email.message.Message instance.

The request object (usually a urllib.request.Request instance) must support the methods get_full_url(), get_host(), unverifiable(), and origin_req_host attribute, as documented by urllib.request. The request is used to set default values for cookie-attributes as well as for checking that the cookie is allowed to be set.

バージョン 3.3 で変更: request object needs origin_req_host attribute. Dependency on a deprecated method get_origin_req_host() has been removed.

CookieJar.set_policy(policy)
使用する CookiePolicy インスタンスを指定します。

CookieJar.make_cookies(response, request)
response オブジェクトから得られた Cookie オブジェクトからなるシーケンスを返します。

response および request 引数で要求されるインスタンスについては、 extract_cookies() の説明を参照してください。

CookieJar.set_cookie_if_ok(cookie, request)
ポリシーが許すのであれば、与えられた Cookie を設定します。

CookieJar.set_cookie(cookie)
与えられた Cookie を、それが設定されるべきかどうかのポリシーのチェックを行わずに設定します。

CookieJar.clear([domain[, path[, name]]])
いくつかのクッキーを消去します。

引数なしで呼ばれた場合は、すべてのクッキーを消去します。引数がひとつ与えられた場合、その domain に属するクッキーのみを消去します。ふたつの引数が与えられた場合、指定された domain と URL path に属するクッキーのみを消去します。引数が 3つ与えられた場合、domain, path および name で指定されるクッキーが消去されます。

与えられた条件に一致するクッキーがない場合は KeyError を発生させます。

CookieJar.clear_session_cookies()
すべてのセッションクッキーを消去します。

保存されているクッキーのうち、 discard 属性が真になっているものすべてを消去します (通常これは max-age または expires のどちらのクッキー属性もないか、あるいは明示的に discard クッキー属性が指定されているものです)。対話的なブラウザの場合、セッションの終了はふつうブラウザのウィンドウを閉じることに相当します。

注意: ignore_discard 引数に真を指定しないかぎり、 save() メソッドはセッションクッキーは保存しません。

さらに FileCookieJar は以下のようなメソッドを実装しています:

FileCookieJar.save(filename=None, ignore_discard=False, ignore_expires=False)
クッキーをファイルに保存します。

この基底クラスは NotImplementedError を発生させます。サブクラスはこのメソッドを実装しないままにしておいてもかまいません。

filename はクッキーを保存するファイルの名前です。 filename が指定されない場合、 self.filename が使用されます (このデフォルト値は、それが存在する場合は、コンストラクタに渡されています)。 self.filename も None の場合は ValueError が発生します。

ignore_discard : 破棄されるよう指示されていたクッキーでも保存します。ignore_expires : 期限の切れたクッキーでも保存します。

ここで指定されたファイルがもしすでに存在する場合は上書きされるため、以前にあったクッキーはすべて消去されます。保存したクッキーはあとで load() または revert() メソッドを使って復元することができます。

FileCookieJar.load(filename=None, ignore_discard=False, ignore_expires=False)
ファイルからクッキーを読み込みます。

それまでのクッキーは新しいものに上書きされない限り残ります。

ここでの引数の値は save() と同じです。

The named file must be in the format understood by the class, or LoadError will be raised. Also, OSError may be raised, for example if the file does not exist.

バージョン 3.3 で変更: 以前は IOError が送出されました; それは現在 OSError のエイリアスです。

FileCookieJar.revert(filename=None, ignore_discard=False, ignore_expires=False)
すべてのクッキーを破棄し、保存されているファイルから読み込み直します。

revert() は load() と同じ例外を発生させる事ができます。失敗した場合、オブジェクトの状態は変更されません。

FileCookieJar インスタンスは以下のような公開の属性をもっています:

FileCookieJar.filename
クッキーを保存するデフォルトのファイル名を指定します。この属性には代入することができます。

FileCookieJar.delayload
真であれば、クッキーを読み込むさいにディスクから遅延読み込みします。この属性には代入することができません。この情報は単なるヒントであり、 (ディスク上のクッキーが変わらない限りは) インスタンスのふるまいには影響を与えず、パフォーマンスのみに影響します。 CookieJar オブジェクトはこの値を無視することもあります。標準ライブラリに含まれている FileCookieJar クラスで遅延読み込みをおこなうものはありません。

FileCookieJar のサブクラスと web ブラウザとの連携
クッキーの読み書きのために、以下の CookieJar サブクラスが提供されています。

class http.cookiejar.MozillaCookieJar(filename, delayload=None, policy=None)
Mozilla の cookies.txt ファイル形式 (この形式はまた Lynx と Netscape ブラウザによっても使われています) でディスクにクッキーを読み書きするための FileCookieJar です。

注釈 This loses information about RFC 2965 cookies, and also about newer or non-standard cookie-attributes such as port.
警告 もしクッキーの損失や欠損が望ましくない場合は、クッキーを保存する前にバックアップを取っておくようにしてください (ファイルへの読み込み / 保存をくり返すと微妙な変化が生じる場合があります)。
また、Mozilla の起動中にクッキーを保存すると、Mozilla によって内容が破壊されてしまうことにも注意してください。

class http.cookiejar.LWPCookieJar(filename, delayload=None, policy=None)
libwww-perl のライブラリである Set-Cookie3 ファイル形式でディスクにクッキーを読み書きするための FileCookieJar です。これはクッキーを人間に可読な形式で保存するのに向いています。

バージョン 3.8 で変更: The filename parameter supports a path-like object.

CookiePolicy オブジェクト
CookiePolicy インターフェイスを実装するオブジェクトは以下のようなメソッドを持っています:

CookiePolicy.set_ok(cookie, request)
クッキーがサーバから受け入れられるべきかどうかを表わす boolean 値を返します。

cookie は Cookie インスタンスです。 request は CookieJar.extract_cookies() の説明で定義されているインターフェイスを実装するオブジェクトです。

CookiePolicy.return_ok(cookie, request)
クッキーがサーバに返されるべきかどうかを表わす boolean 値を返します。

cookie は Cookie インスタンスです。 request は CookieJar.add_cookie_header() の説明で定義されているインターフェイスを実装するオブジェクトです。

CookiePolicy.domain_return_ok(domain, request)
Return False if cookies should not be returned, given cookie domain.

このメソッドは高速化のためのものです。これにより、すべてのクッキーをある特定のドメインに対してチェックする (これには多数のファイル読みこみを伴なう場合があります) 必要がなくなります。 domain_return_ok() および path_return_ok() の両方から true が返された場合、すべての決定は return_ok() に委ねられます。

もし、このクッキードメインに対して domain_return_ok() が true を返すと、つぎにそのクッキーのパス名に対して path_return_ok() が呼ばれます。そうでない場合、そのクッキードメインに対する path_return_ok() および return_ok() は決して呼ばれることはありません。 path_return_ok() が true を返すと、 return_ok() がその Cookie オブジェクト自身の全チェックのために呼ばれます。そうでない場合、そのクッキーパス名に対する return_ok() は決して呼ばれることはありません。

注意: domain_return_ok() は request ドメインだけではなく、すべての cookie ドメインに対して呼ばれます。たとえば request ドメインが "www.example.com" だった場合、この関数は ".example.com" および "www.example.com" の両方に対して呼ばれることがあります。同じことは path_return_ok() にもいえます。

request 引数は return_ok() で説明されているとおりです。

CookiePolicy.path_return_ok(path, request)
Return False if cookies should not be returned, given cookie path.

domain_return_ok() の説明を参照してください。

上のメソッドの実装にくわえて、 CookiePolicy インターフェイスの実装では以下の属性を設定する必要があります。これはどのプロトコルがどのように使われるべきかを示すもので、これらの属性にはすべて代入することが許されています。

CookiePolicy.netscape
Netscape プロトコルを実装していることを示します。

CookiePolicy.rfc2965
Implement RFC 2965 protocol.

CookiePolicy.hide_cookie2
Don't add Cookie2 header to requests (the presence of this header indicates to the server that we understand RFC 2965 cookies).

もっとも有用な方法は、 DefaultCookiePolicy をサブクラス化した CookiePolicy クラスを定義して、いくつか (あるいはすべて) のメソッドをオーバーライドすることでしょう。 CookiePolicy 自体はどのようなクッキーも受け入れて設定を許可する「ポリシー無し」ポリシーとして使うこともできます (これが役に立つことはあまりありませんが)。

DefaultCookiePolicy オブジェクト
クッキーを受けつけ、またそれを返す際の標準的なルールを実装します。

Both RFC 2965 and Netscape cookies are covered. RFC 2965 handling is switched off by default.

自分のポリシーを提供するいちばん簡単な方法は、このクラスを継承して、自分用の追加チェックの前にオーバーライドした元のメソッドを呼び出すことです:

import http.cookiejar
class MyCookiePolicy(http.cookiejar.DefaultCookiePolicy):
    def set_ok(self, cookie, request):
        if not http.cookiejar.DefaultCookiePolicy.set_ok(self, cookie, request):
            return False
        if i_dont_want_to_store_this_cookie(cookie):
            return False
        return True
CookiePolicy インターフェイスを実装するのに必要な機能に加えて、このクラスではクッキーを受けとったり設定したりするドメインを許可したり拒絶したりできるようになっています。ほかにも、 Netscape プロトコルのかなり緩い規則をややきつくするために、いくつかの厳密性のスイッチがついています (いくつかの良性クッキーをブロックする危険性もありますが)。

ドメインのブラックリスト機能やホワイトリスト機能も提供されています (デフォルトではオフになっています)。ブラックリストになく、(ホワイトリスト機能を使用している場合は) ホワイトリストにあるドメインのみがクッキーを設定したり返したりすることを許可されます。コンストラクタの引数 blocked_domains 、および blocked_domains() と set_blocked_domains() メソッドを使ってください (allowed_domains に関しても同様の対応する引数とメソッドがあります)。ホワイトリストを設定した場合は、それを None にすることでホワイトリスト機能をオフにすることができます。

ブラックリストあるいはホワイトリスト中にあるドメインのうち、ドット (.) で始まっていないものは、正確にそれと一致するドメインのクッキーにしか適用されません。たとえばブラックリスト中のエントリ "example.com" は、"example.com" にはマッチしますが、"www.example.com" にはマッチしません。一方ドット (.) で始まっているドメインは、より特化されたドメインともマッチします。たとえば、".example.com" は、"www.example.com" と "www.coyote.example.com" の両方にマッチします (が、"example.com" 自身にはマッチしません)。IP アドレスは例外で、つねに正確に一致する必要があります。たとえば、かりに blocked_domains が "192.168.1.2" と ".168.1.2" を含んでいたとして、192.168.1.2 はブロックされますが、193.168.1.2 はブロックされません。

DefaultCookiePolicy は以下のような追加メソッドを実装しています:

DefaultCookiePolicy.blocked_domains()
ブロックしているドメインのシーケンスを (タプルとして) 返します。

DefaultCookiePolicy.set_blocked_domains(blocked_domains)
ブロックするドメインを設定します。

DefaultCookiePolicy.is_blocked(domain)
domain がクッキーを授受しないブラックリストに載っているかどうかを返します。

DefaultCookiePolicy.allowed_domains()
None あるいは明示的に許可されているドメインを (タプルとして) 返します。

DefaultCookiePolicy.set_allowed_domains(allowed_domains)
許可するドメイン、あるいは None を設定します。

DefaultCookiePolicy.is_not_allowed(domain)
domain がクッキーを授受するホワイトリストに載っているかどうかを返します。

DefaultCookiePolicy インスタンスは以下の属性をもっています。これらはすべてコンストラクタから同じ名前の引数をつかって初期化することができ、代入してもかまいません。

DefaultCookiePolicy.rfc2109_as_netscape
If true, request that the CookieJar instance downgrade RFC 2109 cookies (ie. cookies received in a Set-Cookie header with a version cookie-attribute of 1) to Netscape cookies by setting the version attribute of the Cookie instance to 0. The default value is None, in which case RFC 2109 cookies are downgraded if and only if RFC 2965 handling is turned off. Therefore, RFC 2109 cookies are downgraded by default.

一般的な厳密性のスイッチ:

DefaultCookiePolicy.strict_domain
サイトに、国別コードとトップレベルドメインだけからなるドメイン名 (.co.uk, .gov.uk, .co.nz など) を設定させないようにします。これは完璧からはほど遠い実装であり、いつもうまくいくとは限りません!

RFC 2965 protocol strictness switches:

DefaultCookiePolicy.strict_rfc2965_unverifiable
Follow RFC 2965 rules on unverifiable transactions (usually, an unverifiable transaction is one resulting from a redirect or a request for an image hosted on another site). If this is false, cookies are never blocked on the basis of verifiability

Netscape プロトコルの厳密性に関するスイッチ:

DefaultCookiePolicy.strict_ns_unverifiable
Apply RFC 2965 rules on unverifiable transactions even to Netscape cookies.

DefaultCookiePolicy.strict_ns_domain
Netscape クッキーに対するドメインマッチングの規則をどの程度厳しくするかを指示するフラグです。とりうる値については下の説明を見てください。

DefaultCookiePolicy.strict_ns_set_initial_dollar
Set-Cookie: ヘッダで、'$' で始まる名前のクッキーを無視します。

DefaultCookiePolicy.strict_ns_set_path
要求した URI にパスがマッチしないクッキーの設定を禁止します。

strict_ns_domain はいくつかのフラグの集合です。これはいくつかの値を or することで構成します (たとえば DomainStrictNoDots|DomainStrictNonDomain は両方のフラグが設定されていることになります)。

DefaultCookiePolicy.DomainStrictNoDots
クッキーを設定するさい、ホスト名のプレフィクスにドットが含まれるのを禁止します (例: www.foo.bar.com は .bar.com のクッキーを設定することはできません、なぜなら www.foo はドットを含んでいるからです)。

DefaultCookiePolicy.DomainStrictNonDomain
domain クッキー属性を明示的に指定していないクッキーは、そのクッキーを設定したドメインと同一のドメインだけに返されます (例: example.com からのクッキーに domain クッキー属性がない場合、そのクッキーが spam.example.com に返されることはありません)。

DefaultCookiePolicy.DomainRFC2965Match
When setting cookies, require a full RFC 2965 domain-match.

以下の属性は上記のフラグのうちもっともよく使われる組み合わせで、便宜をはかるために提供されています:

DefaultCookiePolicy.DomainLiberal
0 と同じです (つまり、上述の Netscape のドメイン厳密性フラグがすべてオフにされます)。

DefaultCookiePolicy.DomainStrict
DomainStrictNoDots|DomainStrictNonDomain と同じです。

Cookieオブジェクト
Cookie instances have Python attributes roughly corresponding to the standard cookie-attributes specified in the various cookie standards. The correspondence is not one-to-one, because there are complicated rules for assigning default values, because the max-age and expires cookie-attributes contain equivalent information, and because RFC 2109 cookies may be 'downgraded' by http.cookiejar from version 1 to version 0 (Netscape) cookies.

CookiePolicy メソッド内でのごくわずかな例外を除けば、これらの属性に代入する必要はないはずです。このクラスは内部の一貫性を保つようにはしていないため、代入するのは自分のやっていることを理解している場合のみにしてください。

Cookie.version
Integer or None. Netscape cookies have version 0. RFC 2965 and RFC 2109 cookies have a version cookie-attribute of 1. However, note that http.cookiejar may 'downgrade' RFC 2109 cookies to Netscape cookies, in which case version is 0.

Cookie.name
クッキーの名前 (文字列)。

Cookie.value
クッキーの値 (文字列)、あるいは None 。

Cookie.port
ポートあるいはポートの集合をあらわす文字列 (例: '80' または '80,8080')、あるいは None 。

Cookie.path
クッキーのパス名 (文字列、例: '/acme/rocket_launchers')。

Cookie.secure
そのクッキーを返せるのがセキュアな接続のみならば True を返します。

Cookie.expires
クッキーの期限が切れる日時をあわらす整数 (エポックから経過した秒数)、あるいは None 。 is_expired() も参照してください。

Cookie.discard
これがセッションクッキーであれば True を返します。

Cookie.comment
このクッキーの働きを説明する、サーバからのコメント文字列、あるいは None 。

Cookie.comment_url
このクッキーの働きを説明する、サーバからのコメントのリンク URL、あるいは None 。

Cookie.rfc2109
True if this cookie was received as an RFC 2109 cookie (ie. the cookie arrived in a Set-Cookie header, and the value of the Version cookie-attribute in that header was 1). This attribute is provided because http.cookiejar may 'downgrade' RFC 2109 cookies to Netscape cookies, in which case version is 0.

Cookie.port_specified
サーバがポート、あるいはポートの集合を (Set-Cookie / Set-Cookie2 ヘッダ内で) 明示的に指定していれば True を返します。

Cookie.domain_specified
サーバにより明示的にドメインが指定されていれば True を返します。

Cookie.domain_initial_dot
サーバが明示的に指定したドメインがドット ('.') で始まっていれば True を返します。

クッキーは、オプションとして標準的でないクッキー属性を持つこともできます。これらは以下のメソッドでアクセスできます:

Cookie.has_nonstandard_attr(name)
Return True if cookie has the named cookie-attribute.

Cookie.get_nonstandard_attr(name, default=None)
クッキーが指定された名前のクッキー属性をもっていれば、その値を返します。そうでない場合は default を返します。

Cookie.set_nonstandard_attr(name, value)
指定された名前のクッキー属性を設定します。

Cookie クラスは以下のメソッドも定義しています:

Cookie.is_expired(now=None)
サーバが要求するクッキーの有効期限を過ぎていれば True を返します。 now が (エポックからの経過秒で) 指定されているときは、特定の時刻で期限切れかどうかを判定します。

使用例
The first example shows the most common usage of http.cookiejar:

import http.cookiejar, urllib.request
cj = http.cookiejar.CookieJar()
opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))
r = opener.open("http://example.com/")
以下の例では、URL を開く際に Netscape や Mozilla または Lynx のクッキーを使う方法を示しています (クッキーファイルの位置は Unix/Netscape の慣例にしたがうものと仮定しています):

import os, http.cookiejar, urllib.request
cj = http.cookiejar.MozillaCookieJar()
cj.load(os.path.join(os.path.expanduser("~"), ".netscape", "cookies.txt"))
opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))
r = opener.open("http://example.com/")
The next example illustrates the use of DefaultCookiePolicy. Turn on RFC 2965 cookies, be more strict about domains when setting and returning Netscape cookies, and block some domains from setting cookies or having them returned:

import urllib.request
from http.cookiejar import CookieJar, DefaultCookiePolicy
policy = DefaultCookiePolicy(
    rfc2965=True, strict_ns_domain=Policy.DomainStrict,
    blocked_domains=["ads.net", ".ads.net"])
cj = CookieJar(policy)
opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))
r = opener.open("http://example.com/")

xmlrpc --- XMLRPC サーバーとクライアントモジュール
XML-RPC は HTTP 経由の XML を使って遠隔手続き呼び出し (Remote Procedure Call) を実現する方法です。XML-RPC を使うと、クライアントはリモートサーバー (サーバーは URI で名前付けられます) 上のメソッドを引数付きで呼び出して、構造化されたデータを受け取る事ができます。

xmlrpc パッケージは XML-RPC のサーバーとクライアントを実装したモジュールを持っています。モジュール一覧:

xmlrpc.server --- 基本的なXML-RPCサーバー¶
ソースコード: Lib/xmlrpc/server.py

xmlrpc.server モジュールはPythonで記述された基本的なXML-RPC サーバーフレームワークを提供します。サーバーはスタンドアロンであるか、 SimpleXMLRPCServer を使うか、 CGIXMLRPCRequestHandler を使って CGI 環境に組み込まれるかの、いずれかです。

警告 xmlrpc.server モジュールは悪意を持って構築されたデータに対して安全ではありません。信頼できないデータや認証されていないデータを解析する必要がある場合は、 XML の脆弱性 を参照してください。
class xmlrpc.server.SimpleXMLRPCServer(addr, requestHandler=SimpleXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=False)
サーバーインスタンスを新たに作成します。 このクラスは XML-RPC プロトコルで呼ばれる関数の登録のためのメソッドを提供します。 引数 requestHandler にはリクエストハンドラーインスタンスのファクトリーを設定します。 デフォルトは SimpleXMLRPCRequestHandler です。 引数 addr と requestHandler は socketserver.TCPServer のコンストラクターに渡されます。 logRequests が真の場合 (デフォルト)、 リクエストはログに記録されます。 この引数を偽にするとはログは記録されません。 引数 allow_none と encoding は xmlrpc.client に渡され、サーバーが返す XML-RPC 応答を制御します。 bind_and_activate 引数はコンストラクタが直ちに server_bind() と server_activate() を呼ぶかどうかを制御します。デフォルトでは真です。 この引数に False を設定することで、アドレスを束縛する前に allow_reuse_address クラス変数を操作することが出来ます。 use_builtin_types 引数は loads() 関数に渡されます。 この引数は日付/時刻の値やバイナリデータを受け取ったときにどの型が処理されるかを制御します。デフォルトでは偽です。

バージョン 3.3 で変更: use_builtin_types フラグが追加されました。

class xmlrpc.server.CGIXMLRPCRequestHandler(allow_none=False, encoding=None, use_builtin_types=False)
CGI 環境における XML-RPC リクエストハンドラーを新たに作成します。 引数 allow_none と encoding は xmlrpc.client に渡され、サーバーが返す XML-RPC 応答を制御します。 use_builtin_types 引数は loads() 関数に渡されます。 この引数は日付/時刻の値やバイナリデータを受け取ったときにどの型が処理されるかを制御します。デフォルトは偽です。

バージョン 3.3 で変更: use_builtin_types フラグが追加されました。

class xmlrpc.server.SimpleXMLRPCRequestHandler
リクエストハンドラーインスタンスを新たに作成します。このリクエストハンドラーは POST リクエストをサポートし、 SimpleXMLRPCServer コンストラクターの引数 logRequests に従ってログ出力を行います。

SimpleXMLRPCServer オブジェクト
SimpleXMLRPCServer クラスは socketserver.TCPServer のサブクラスで、基本的なスタンドアロンの XML-RPC サーバーを作成する手段を提供します。

SimpleXMLRPCServer.register_function(function=None, name=None)
Register a function that can respond to XML-RPC requests. If name is given, it will be the method name associated with function, otherwise function.__name__ will be used. name is a string, and may contain characters not legal in Python identifiers, including the period character.

This method can also be used as a decorator. When used as a decorator, name can only be given as a keyword argument to register function under name. If no name is given, function.__name__ will be used.

バージョン 3.7 で変更: register_function() can be used as a decorator.

SimpleXMLRPCServer.register_instance(instance, allow_dotted_names=False)
オブジェクトを登録します。 オブジェクトは register_function() を使用して登録されていないメソッド名を公開するのに使われます。 instance に _dispatch() メソッドがあった場合、リクエストされたメソッド名と引数で _dispatch() を呼び出します。 API は def _dispatch(self, method, params) (params 可変引数リストではないことに注意) です。 タスクを実行するのに下層の関数を呼び出す場合、その関数は func(*params) のように引数リストを展開して呼び出されます。 _dispatch() の返り値は結果としてクライアントに返されます。 instance に _dispatch() メソッドがない場合、リクエストされたメソッド名にマッチする属性を検索します。

オプション引数 allow_dotted_names が真でインスタンスに _dispatch() メソッドがない場合、リクエストされたメソッド名がピリオドを含むなら、メソッド名の各要素が個々に検索され、簡単な階層的検索が行われます。 その検索で発見された値をリクエストの引数で呼び出し、クライアントに返り値を返します。

警告 allow_dotted_names オプションを有効にすると、侵入者はあなたのモジュールのグローバル変数にアクセスすることができ、あなたのマシンで任意のコードを実行できる可能性があります。このオプションは閉じた安全なネットワークでのみお使い下さい。
SimpleXMLRPCServer.register_introspection_functions()
XML-RPC のイントロスペクション関数、 system.listMethods 、 system.methodHelp 、 system.methodSignature を登録します。

SimpleXMLRPCServer.register_multicall_functions()
XML-RPC における複数の要求を処理する関数 system.multicall を登録します。

SimpleXMLRPCRequestHandler.rpc_paths
この属性値はXML-RPCリクエストを受け付けるURLの有効なパス部分をリストするタプルでなければなりません。これ以外のパスへのリクエストは404「そのようなページはありません」 HTTPエラーになります。このタプルが空の場合は全てのパスが有効であると見なされます。デフォルト値は ('/', '/RPC2') です。

SimpleXMLRPCServer の例
サーバーのコード:

from xmlrpc.server import SimpleXMLRPCServer
from xmlrpc.server import SimpleXMLRPCRequestHandler

# Restrict to a particular path.
class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/RPC2',)

# Create server
with SimpleXMLRPCServer(('localhost', 8000),
                        requestHandler=RequestHandler) as server:
    server.register_introspection_functions()

    # Register pow() function; this will use the value of
    # pow.__name__ as the name, which is just 'pow'.
    server.register_function(pow)

    # Register a function under a different name
    def adder_function(x, y):
        return x + y
    server.register_function(adder_function, 'add')

    # Register an instance; all the methods of the instance are
    # published as XML-RPC methods (in this case, just 'mul').
    class MyFuncs:
        def mul(self, x, y):
            return x * y

    server.register_instance(MyFuncs())

    # Run the server's main loop
    server.serve_forever()
以下のクライアントコードは上のサーバーで使えるようになったメソッドを呼び出します:

import xmlrpc.client

s = xmlrpc.client.ServerProxy('http://localhost:8000')
print(s.pow(2,3))  # Returns 2**3 = 8
print(s.add(2,3))  # Returns 5
print(s.mul(5,2))  # Returns 5*2 = 10

# Print list of available methods
print(s.system.listMethods())
register_function() can also be used as a decorator. The previous server example can register functions in a decorator way:

from xmlrpc.server import SimpleXMLRPCServer
from xmlrpc.server import SimpleXMLRPCRequestHandler

class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/RPC2',)

with SimpleXMLRPCServer(('localhost', 8000),
                        requestHandler=RequestHandler) as server:
    server.register_introspection_functions()

    # Register pow() function; this will use the value of
    # pow.__name__ as the name, which is just 'pow'.
    server.register_function(pow)

    # Register a function under a different name, using
    # register_function as a decorator. *name* can only be given
    # as a keyword argument.
    @server.register_function(name='add')
    def adder_function(x, y):
        return x + y

    # Register a function under function.__name__.
    @server.register_function
    def mul(x, y):
        return x * y

    server.serve_forever()
Lib/xmlrpc/server.py モジュール内にある以下の例はドット付名前を許容し複数呼び出し関数を登録するサーバです。

警告 allow_dotted_names オプションを有効にすると、侵入者はあなたのモジュールのグローバル変数にアクセスすることができ、あなたのマシンで任意のコードを実行できる可能性があります。この例は閉じた安全なネットワークでのみお使い下さい。
import datetime

class ExampleService:
    def getData(self):
        return '42'

    class currentTime:
        @staticmethod
        def getCurrentTime():
            return datetime.datetime.now()

with SimpleXMLRPCServer(("localhost", 8000)) as server:
    server.register_function(pow)
    server.register_function(lambda x,y: x+y, 'add')
    server.register_instance(ExampleService(), allow_dotted_names=True)
    server.register_multicall_functions()
    print('Serving XML-RPC on localhost port 8000')
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nKeyboard interrupt received, exiting.")
        sys.exit(0)
この ExampleService デモはコマンドラインから起動することができます。

python -m xmlrpc.server
上記のサーバとやりとりするクライアントは Lib/xmlrpc/client.py にあります:

server = ServerProxy("http://localhost:8000")

try:
    print(server.currentTime.getCurrentTime())
except Error as v:
    print("ERROR", v)

multi = MultiCall(server)
multi.getData()
multi.pow(2,9)
multi.add(1,2)
try:
    for response in multi():
        print(response)
except Error as v:
    print("ERROR", v)
デモ XMLRPC サーバとやりとりするクライアントは以下のように呼び出します:

python -m xmlrpc.client
CGIXMLRPCRequestHandler
The CGIXMLRPCRequestHandler class can be used to handle XML-RPC requests sent to Python CGI scripts.

CGIXMLRPCRequestHandler.register_function(function=None, name=None)
Register a function that can respond to XML-RPC requests. If name is given, it will be the method name associated with function, otherwise function.__name__ will be used. name is a string, and may contain characters not legal in Python identifiers, including the period character.

This method can also be used as a decorator. When used as a decorator, name can only be given as a keyword argument to register function under name. If no name is given, function.__name__ will be used.

バージョン 3.7 で変更: register_function() can be used as a decorator.

CGIXMLRPCRequestHandler.register_instance(instance)
オブジェクトを登録します。 オブジェクトは register_function() を使用して登録されていないメソッド名を公開するのに使われます。 instance に _dispatch() メソッドがあった場合、リクエストされたメソッド名と引数で _dispatch() を呼び出します。 返り値は結果としてクライアントに返されます。 instance に _dispatch() メソッドがなかった場合、リクエストされたメソッド名にマッチする属性を検索します。 リクエストされたメソッド名がピリオドを含む場合、モジュール名の各要素が個々に検索され、簡単な階層的検索が実行されます。 その検索で発見された値をリクエストの引数で呼び出し、クライアントに返り値を返します。

CGIXMLRPCRequestHandler.register_introspection_functions()
XML-RPC のイントロスペクション関数、 system.listMethods 、 system.methodHelp 、 system.methodSignature を登録します。

CGIXMLRPCRequestHandler.register_multicall_functions()
XML-RPC マルチコール関数 system.multicall を登録します。

CGIXMLRPCRequestHandler.handle_request(request_text=None)
XML-RPC リクエストを処理します。 与えられた場合、 request_text はHTTP サーバが提供する POST データでなければなりません。 そうでない場合、標準入力の内容が使われます。

以下はプログラム例です:

class MyFuncs:
    def mul(self, x, y):
        return x * y


handler = CGIXMLRPCRequestHandler()
handler.register_function(pow)
handler.register_function(lambda x,y: x+y, 'add')
handler.register_introspection_functions()
handler.register_instance(MyFuncs())
handler.handle_request()
XMLRPC サーバの文書化
これらのクラスは HTTP GET 要求への応答内で HTML 文書となるよう上記クラスを拡張します。 サーバは独立していても CGI 環境に埋め込まれていてもかまいません。 前者では DocXMLRPCServer を、後者では DocCGIXMLRPCRequestHandler を使用します。

class xmlrpc.server.DocXMLRPCServer(addr, requestHandler=DocXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=True)
サーバ・インスタンスを新たに生成します。全ての引数の意味は SimpleXMLRPCServer のものと同じですが、 requestHandler のデフォルトは DocXMLRPCRequestHandler になっています。

バージョン 3.3 で変更: use_builtin_types フラグが追加されました。

class xmlrpc.server.DocCGIXMLRPCRequestHandler
CGI環境で XMR-RPC リクエストを処理するインスタンスを新たに生成します。

class xmlrpc.server.DocXMLRPCRequestHandler
リクエスト・ハンドラのインスタンスを新たに生成します。このリクエスト・ハンドラは XML-RPC POST 要求とドキュメントの GET 要求をサポートし、 DocXMLRPCServer コンストラクタに与えられた引数 logRequests を優先するためにロギングを変更します。

DocXMLRPCServer オブジェクト
DocXMLRPCServer は SimpleXMLRPCServer の派生クラスで、自己文書化するスタンドアローン XML-RPC サーバの作成手段を提供します。 HTTP POST リクエストは XML-RPC メソッドの呼び出しとして処理されます。 HTTP GET リクエストは pydoc スタイルの HTML 文書の生成に処理されます。 これによりサーバは自身の web ベースの文書を提供できます。

DocXMLRPCServer.set_server_title(server_title)
生成する HTML 文書で使用されるタイトルを設定します。このタイトルは HTML の title 要素内で使われます。

DocXMLRPCServer.set_server_name(server_name)
生成する HTML 文書内で使用される名前を設定します。この名前は生成した文書冒頭の h1 要素内で使われます。

DocXMLRPCServer.set_server_documentation(server_documentation)
生成する HTML 文書内で使用される説明を設定します。この説明は文書中のサーバ名の下にパラグラフとして出力されます。

DocCGIXMLRPCRequestHandler
DocCGIXMLRPCRequestHandler は CGIXMLRPCRequestHandler の派生クラスで、自己文書化する XML-RPC CGI スクリプトの作成手段を提供します。 HTTP POST リクエストは XML-RCP メソッドの呼び出しとして処理されます。 HTTP GET リクエストは pydoc スタイルの HTML 文書の生成に処理されます。 これによりサーバは自身の web ベースの文書を提供できます。

DocCGIXMLRPCRequestHandler.set_server_title(server_title)
生成する HTML 文書で使用されるタイトルを設定します。このタイトルは HTML の title 要素内で使われます。

DocCGIXMLRPCRequestHandler.set_server_name(server_name)
生成する HTML 文書内で使用される名前を設定します。この名前は生成した文書冒頭の h1 要素内で使われます。

DocCGIXMLRPCRequestHandler.set_server_documentation(server_documentation)
生成する HTML 文書内で使用される説明を設定します。この説明は文書中のサーバ名の下にパラグラフとして出力されます。
