tkinter --- Tcl/Tk の Python インタフェース¶
ソースコード: Lib/tkinter/__init__.py

tkinter パッケージ ("Tk インタフェース") は、 Tk GUI ツールキットに対する標準の Python インタフェースです。 Tk と tkinter はほとんどの Unix プラットフォームの他、 Windows システム上でも利用できます。 (Tk 自体は Python の一部ではありません。 Tk は ActiveState で保守されています。)

コマンドラインから python -m tkinter を実行すると簡素な Tk インターフェースを表示するウィンドウが開き、システムに tkinter が正しくインストールされたことが分かり、さらにインストールされた Tcl/Tk がどのバーションなのかが表示されるので、そのバージョンの Tcl/Tk ドキュメントを選んで読めます。

参考 Tkinter ドキュメント:
Python Tkinter Resources
Python Tkinter Topic Guide では、Tk を Python から利用する上での情報と、その他の Tk にまつわる情報源を数多く提供しています。

TKDocs
豊富なチュートリアルといくつかのウィジットについてのよりフレンドリなページ。

Tkinter 8.5 reference: a GUI for Python
オンラインリファレンス資料です。

Tkinter docs from effbot
effbot.org が提供している tkinter のオンラインリファレンスです。

Programming Python
マーク・ルッツによる書籍で、Tkinter についても広く取り上げています。

Modern Tkinter for Busy Python Developers
Mark Roseman による書籍で、Python と Tkinter を使用した魅力的でモダンなグラフィカルユーザーインターフェースの構築方法を説明しています。

Python and Tkinter Programming
John Graysonによる解説書 (ISBN 1-884777-81-3) です。

Tcl/Tk ドキュメント:

Tk commands
ほとんどのコマンドは tkinter あるいは tkinter.ttk クラスから利用可能です。 手元のインストールされている Tcl/Tk のバージョンに合うように '8.6' の部分を読み替えてください。

Tcl/Tk の最近の man pages
www.tcl.tk の最近の Tcl/Tk マニュアルです。

ActiveState Tcl ホームページ
Tk/Tcl の開発は ActiveState で大々的に行われています。

Tcl and the Tk Toolkit
Tcl の発明者である John Ousterhout による本です。

Practical Programming in Tcl and Tk
Brent Welch の百科事典のような本です。

Tkinter モジュール
ほとんどの場合、本当に必要となるのは tkinter モジュールだけですが、他にもいくつかの追加モジュールを利用できます。Tk インタフェース自体はバイナリモジュール _tkinter 内にあります。このモジュールに入っているのは Tk への低レベルインタフェースであり、アプリケーションプログラマが直接使ってはなりません。_tkinter は通常共有ライブラリ (や DLL) になっていますが、Python インタプリタに静的にリンクされていることもあります。

Tk インタフェースモジュールの他にも tkinter には数多くの Python モジュールが入っています。その中でも tkinter.constants は最も重要なモジュールの一つですが、tkinter をインポートすると tkinter.constants は自動的にインポートされるので、以下のように tkinter をインポートするだけで Tkinter を使えるようになります:

import tkinter
あるいは、よく使うやり方で以下のようにします:

from tkinter import *
class tkinter.Tk(screenName=None, baseName=None, className='Tk', useTk=1)
Tk クラスは引数なしでインスタンス化します。これは Tk のトップレベルウィジェットを生成します。通常、トップレベルウィジェットはアプリケーションのメインウィンドウになります。それぞれのインスタンスごとに固有の Tcl インタプリタが関連づけられます。

tkinter.Tcl(screenName=None, baseName=None, className='Tk', useTk=0)
Tcl() はファクトリ関数で、 Tk クラスで生成するオブジェクトとよく似たオブジェクトを生成します。ただし Tk サブシステムを初期化しません。この関数は、余分なトップレベルウィンドウを作る必要がなかったり、 (X サーバを持たない Unix/Linux システムなどのように) 作成できない環境において Tcl インタプリタを駆動したい場合に便利です。 Tcl() で生成したオブジェクトに対して loadtk() メソッドを呼び出せば、トップレベルウィンドウを作成 (して、Tk サブシステムを初期化) します。

Tk をサポートしているモジュールには、他にも以下のようなモジュールがあります:

tkinter.colorchooser
ユーザに色を選択させるためのダイアログです。

tkinter.commondialog
このリストの他のモジュールが定義しているダイアログの基底クラスです。

tkinter.filedialog
ユーザが開きたいファイルや保存したいファイルを指定できるようにする共通のダイアログです。

tkinter.font
フォントの扱いを補助するためのユーティリティです。

tkinter.messagebox
標準的な Tk のダイアログボックスにアクセスします。

tkinter.scrolledtext
垂直スクロールバー付きのテキストウィジェットです。

tkinter.simpledialog
基本的なダイアログと便宜関数 (convenience function) です。

tkinter.dnd
tkinter 用のドラッグアンドドロップのサポートです。実験的なサポートで、Tk DND に置き替わった時点で撤廃されるはずです。

turtle
Tk ウィンドウ上でタートルグラフィックスを実現します。

Tkinter お助け手帳
この節は、 Tk や Tkinter を全て網羅したチュートリアルを目指しているわけではありません。むしろ、Tkinter のシステムを学ぶ上での指針を示すための、その場しのぎ的なマニュアルです。

謝辞:

Tk は John Ousterhout が Berkeley の在籍中に作成しました。

Tkinter は Steen Lumholt と Guido van Rossum が作成しました。

この Life Preserver は Virginia 大学の Matt Conway 他が執筆しました。

HTML レンダリングやたくさんの編集は、Ken Manheimer が FrameMaker 版から行いました。

Fredrik Lundh はクラスインタフェース詳細な説明を書いたり内容を改訂したりして、現行の Tk 4.2 に合うようにしました。

Mike Clarkson はドキュメントを LaTeX 形式に変換し、リファレンスマニュアルのユーザインタフェースの章をコンパイルしました。

この節の使い方
この節は二つの部分で構成されています: 前半では、背景となることがらを (大雑把に) 網羅しています。後半は、キーボードの横に置けるような手軽なリファレンスになっています。

「○○するにはどうしたらよいですか」という形の問いに答えようと思うなら、まず Tk で「○○する」方法を調べてから、このドキュメントに戻ってきてその方法に対応する tkinter の関数呼び出しに変換するのが多くの場合最善の方法になります。Python プログラマが Tk ドキュメンテーションを見れば、たいてい正しい Python コマンドの見当をつけられます。従って、Tkinter を使うには Tk についてほんの少しだけ知っていればよいということになります。このドキュメントではその役割を果たせないので、次善の策として、すでにある最良のドキュメントについていくつかヒントを示しておくことにしましょう:

Tk の man ページのコピーを手に入れるよう強く勧めます。とりわけ最も役立つのは manN ディレクトリ内にあるマニュアルです。man3 のマニュアルページは Tk ライブラリに対する C インタフェースについての説明なので、スクリプト書きにとって取り立てて役に立つ内容ではありません。

Addison-Wesley は John Ousterhout の書いた Tcl and the Tk Toolkit (ISBN 0-201-63337-X) という名前の本を出版しています。この本は初心者向けの Tcl と Tk の良い入門書です。内容は網羅的ではなく、詳細の多くは man ページ任せにしています。

たいていの場合、tkinter/__init__.py は参照先としての最後の手段ですが、それ以外の手段で調べても分からない場合には救いの地になるかもしれません。

簡単な Hello World プログラム
import tkinter as tk

class Application(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.master = master
        self.pack()
        self.create_widgets()

    def create_widgets(self):
        self.hi_there = tk.Button(self)
        self.hi_there["text"] = "Hello World\n(click me)"
        self.hi_there["command"] = self.say_hi
        self.hi_there.pack(side="top")

        self.quit = tk.Button(self, text="QUIT", fg="red",
                              command=self.master.destroy)
        self.quit.pack(side="bottom")

    def say_hi(self):
        print("hi there, everyone!")

root = tk.Tk()
app = Application(master=root)
app.mainloop()
Tcl/Tk を (本当に少しだけ) 見渡してみる
クラス階層は複雑に見えますが、実際にプログラムを書く際には、アプリケーションプログラマはほとんど常にクラス階層の最底辺にあるクラスしか参照しません。

注釈:

クラスのいくつかは、特定の関数を一つの名前空間下にまとめるために提供されています。こうしたクラスは個別にインスタンス化するためのものではありません。

Tk クラスはアプリケーション内で一度だけインスタンス化するようになっています。アプリケーションプログラマが明示的にインスタンス化する必要はなく、他のクラスがインスタンス化されると常にシステムが作成します。

Widget クラスもまた、インスタンス化して使うようにはなっていません。このクラスはサブクラス化して「実際の」ウィジェットを作成するためのものです。(C++ で言うところの、 '抽象クラス (abstract class)' です)。

このリファレンス資料を活用するには、Tk の短いプログラムを読んだり、 Tk コマンドの様々な側面を知っておく必要がままあるでしょう。(下の説明の tkinter 版は、基本的な Tk プログラムと Tkinter との対応関係 節を参照してください。)

Tk スクリプトは Tcl プログラムです。全ての Tcl プログラムに同じく、 Tk スクリプトはトークンをスペースで区切って並べます。 Tk ウィジェットとは、ウィジェットの クラス 、ウィジェットの設定を行う オプション 、そしてウィジェットに役立つことをさせる アクション を組み合わせたものに過ぎません。

Tk でウィジェットを作るには、常に次のような形式のコマンドを使います:

classCommand newPathname options
classCommand
どの種類のウィジェット (ボタン、ラベル、メニュー、...) を作るかを表します。

newPathname
作成するウィジェットにつける新たな名前です。Tk 内の全ての名前は一意になっていなければなりません。一意性を持たせる助けとして、 Tk 内のウィジェットは、ファイルシステムにおけるファイルと同様、 パス名 (pathname) を使って名づけられます。トップレベルのウィジェット、すなわち ルート は . (ピリオド) という名前になり、その子ウィジェット階層もピリオドで区切ってゆきます。ウィジェットの名前は、例えば .myApp.controlPanel.okButton のようになります。

options
ウィジェットの見た目を設定します。場合によってはウィジェットの挙動も設定します。オプションはフラグと値がリストになった形式をとります。 Unix のシェルコマンドのフラグと同じように、フラグの前には '-' がつき、複数の単語からなる値はクオートで囲まれます。

例えば:

button   .fred   -fg red -text "hi there"
   ^       ^     \______________________/
   |       |                |
 class    new            options
command  widget  (-opt val -opt val ...)
ウィジェットを作成すると、ウィジェットへのパス名は新しいコマンドになります。この新たな widget command は、プログラマが新たに作成したウィジェットに action を実行させる際のハンドル (handle) になります。C では someAction(fred, someOptions) と表し、 C++ では fred.someAction(someOptions) と表すでしょう。Tkでは:

.fred someAction someOptions
のようにします。オブジェクト名 .fred はドットから始まっている点に注意してください。

読者の想像の通り、 someAction に指定できる値はウィジェットのクラスに依存しています: fred がボタンなら .fred disable はうまくいきます (fred はグレーになります) が、fred がラベルならうまくいきません (Tkではラベルの無効化をサポートしていないからです)。

someOptions に指定できる値はアクションの内容に依存しています。 disable のようなアクションは引数を必要としませんが、テキストエントリボックスの delete コマンドのようなアクションにはテキストを削除する範囲を指定するための引数が必要になります。

基本的な Tk プログラムと Tkinter との対応関係
Tk のクラスコマンドは、Tkinter のクラスコンストラクタに対応しています。

button .fred                =====>  fred = Button()
オブジェクトの親 (master) は、オブジェクトの作成時に指定した新たな名前から非明示的に決定されます。Tkinter では親を明示的に指定します。

button .panel.fred          =====>  fred = Button(panel)
Tk の設定オプションは、ハイフンをつけたタグと値の組からなるリストで指定します。Tkinter では、オプションはキーワード引数にしてインスタンスのコンストラクタに指定したり、 config() にキーワード引数を指定して呼び出したり、インデクス指定を使ってインスタンスに代入したりして設定します。オプションの設定については オプションの設定 節を参照してください。

button .fred -fg red        =====>  fred = Button(panel, fg="red")
.fred configure -fg red     =====>  fred["fg"] = red
                            OR ==>  fred.config(fg="red")
Tk でウィジェットにアクションを実行させるには、ウィジェット名をコマンドにして、その後にアクション名を続け、必要に応じて引数 (オプション) を続けます。Tkinter では、クラスインスタンスのメソッドを呼び出して、ウィジェットのアクションを呼び出します。あるウィジェットがどんなアクション (メソッド) を実行できるかは、tkinter/__init__.py モジュール内にリストされています。

.fred invoke                =====>  fred.invoke()
Tk でウィジェットを packer (ジオメトリマネージャ) に渡すには、pack コマンドをオプション引数付きで呼び出します。Tkinter では Pack クラスがこの機能すべてを握っていて、様々な pack の形式がメソッドとして実装されています。tkinter のウィジェットはすべて packer からサブクラス化されているため、pack 操作にまつわるすべてのメソッドを継承しています。Form ジオメトリマネージャに関する詳しい情報については tkinter.tix モジュールのドキュメントを参照してください。

pack .fred -side left       =====>  fred.pack(side="left")
Tk と Tkinter はどのように関わっているのか
上から下に、呼び出しの階層構造を説明してゆきます:

あなたのアプリケーション (Python)
まず、Python アプリケーションが tkinter を呼び出します。

tkinter (Python パッケージ)
上記の呼び出し (例えば、ボタンウィジェットの作成) は、tkinter パッケージ内で実装されており、Python で書かれています。この Python で書かれた関数は、コマンドと引数を解析して変換し、あたかもコマンドが Python スクリプトではなく Tk スクリプトから来たようにみせかけます。

_tkinter (C)
上記のコマンドと引数は _tkinter (先頭にアンダースコアです) 拡張モジュール内の C 関数に渡されます。

Tk ウィジェット (C および Tcl)
上記の C 関数は、Tk ライブラリを構成する C 関数の入った別の C モジュールへの呼び出しを行えるようになっています。Tk は C と少しの Tcl を使って実装されています。Tk ウィジェットの Tcl 部分は、ウィジェットのデフォルト動作をバインドするために使われ、Python tkinter パッケージがインポートされた時に一度だけ実行されます (ユーザがこの過程を目にすることはありません)。

Tk (C)
Tk ウィジェットの Tk 部分で実装されている最終的な対応付け操作によって...

Xlib (C)
Xlib ライブラリがスクリーン上にグラフィックスを描きます。

簡単なリファレンス
オプションの設定
オプションは、色やウィジェットの境界線幅などを制御します。オプションの設定には三通りの方法があります:

オブジェクト生成時、キーワード引数を使用する
fred = Button(self, fg="red", bg="blue")
オブジェクト生成後、オプション名を辞書インデックスのように扱う
fred["fg"] = "red"
fred["bg"] = "blue"
オブジェクト生成後に、config()メソッドを使って複数の属性を更新する
fred.config(fg="red", bg="blue")
オプションとその振る舞いに関する詳細な説明は、該当するウィジェットの Tk の man ページを参照してください。

man ページには、各ウィジェットの "STANDARD OPTIONS (標準オプション)" と "WIDGET SPECIFIC OPTIONS (ウィジェット固有のオプション)" がリストされていることに注意してください。前者は多くのウィジェットに共通のオプションのリストで、後者は特定のウィジェットに特有のオプションです。標準オプションの説明は man ページの options(3) にあります。

このドキュメントでは、標準オプションとウィジェット固有のオプションを区別していません。オプションによっては、ある種のウィジェットに適用できません。あるウィジェットがあるオプションに対応しているかどうかは、ウィジェットのクラスによります。例えばボタンには command オプションがありますが、ラベルにはありません。

あるウィジェットがどんなオプションをサポートしているかは、ウィジェットの man ページにリストされています。また、実行時にウィジェットの config() メソッドを引数なしで呼び出したり、 keys() メソッドを呼び出したりして問い合わせることもできます。メソッド呼び出しを行うと辞書型の値を返します。この辞書は、オプションの名前がキー (例えば 'relief') になっていて、値が 5 要素のタプルになっています。

bg のように、いくつかのオプションはより長い名前を持つ共通のオプションに対する同義語になっています (bg は "background" を短縮したものです)。短縮形のオプション名を config() に渡すと、 5 要素ではなく 2 要素のタプルを返します。このタプルには、同義語の名前と「本当の」オプション名が入っています (例えば ('bg', 'background'))。

インデックス

意味

使用例

0

オプション名

'relief'

1

データベース検索用のオプション名

'relief'

2

データベース検索用のオプションクラス

'Relief'

3

デフォルト値

'raised'

4

現在の値

'groove'

以下はプログラム例です:

>>>
>>> print(fred.config())
{'relief': ('relief', 'relief', 'Relief', 'raised', 'groove')}
もちろん、実際に出力される辞書には利用可能なオプションが全て表示されます。上の表示例は単なる例にすぎません。

Packer
The packer is one of Tk's geometry-management mechanisms. Geometry managers are used to specify the relative positioning of widgets within their container - their mutual master. In contrast to the more cumbersome placer (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - above, to the left of, filling, etc - and works everything out to determine the exact placement coordinates for you.

どんな マスタ ウィジェットでも、大きさは内部の "スレイブ (slave) ウィジェット" の大きさで決まります。 packer は、スレイブウィジェットを pack 先のマスタウィジェット中のどこに配置するかを制御するために使われます。望みのレイアウトを達成するには、ウィジェットをフレームにパックし、そのフレームをまた別のフレームにパックできます。さらに、一度パックを行うと、それ以後の設定変更に合わせて動的に並べ方を調整します。

ジオメトリマネージャがウィジェットのジオメトリを確定するまで、ウィジェットは表示されないので注意してください。初心者のころにはよくジオメトリの確定を忘れてしまい、ウィジェットを生成したのに何も表示されず驚くことになります。ウィジェットは、(例えば packer の pack() メソッドを適用して) ジオメトリを確定した後で初めて表示されます。

pack() メソッドは、キーワード引数つきで呼び出せます。キーワード引数は、ウィジェットをコンテナ内のどこに表示するか、メインのアプリケーションウィンドウをリサイズしたときにウィジェットがどう振舞うかを制御します。以下に例を示します:

fred.pack()                     # defaults to side = "top"
fred.pack(side="left")
fred.pack(expand=1)
Packer のオプション
packer と packer の取りえるオプションについての詳細は、man ページや John Ousterhout の本の183ページを参照してください。

anchor
アンカーの型です。 packer が区画内に各スレイブを配置する位置を示します。

expand
ブール値で、 0 または 1 になります。

fill
指定できる値は 'x' 、 'y' 、 'both' 、 'none' です。

ipadx および ipady
スレイブウィジェットの各側面の内側に行うパディング幅を表す長さを指定します。

padx および pady
スレイブウィジェットの各側面の外側に行うパディング幅を表す長さを指定します。

side
指定できる値は 'left', 'right', 'top', 'bottom' です。

ウィジェット変数を関連付ける
ウィジェットによっては、(テキスト入力ウィジェットのように) 特殊なオプションを使って、現在設定されている値をアプリケーション内の変数に直接関連付けできます。このようなオプションには variable, textvariable, onvalue, offvalue および value があります。この関連付けは双方向に働きます: 変数の値が何らかの理由で変更されると、関連付けされているウィジェットも更新され、新しい値を反映します。

残念ながら、現在の tkinter の実装では、variable や textvariable オプションでは任意の Python の値をウィジェットに渡せません。この関連付け機能がうまく働くのは、tkinter 内で Variable というクラスからサブクラス化されている変数によるオプションだけです。

Variable には、 StringVar, IntVar, DoubleVar, BooleanVar といった便利なサブクラスがすでにすでに数多く定義されています。こうした変数の現在の値を読み出したければ、 get() メソッドを呼び出します。また、値を変更したければ set() メソッドを呼び出します。このプロトコルに従っている限り、それ以上なにも手を加えなくてもウィジェットは常に現在値に追従します。

例えば:

import tkinter as tk

class App(tk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.pack()

        self.entrythingy = tk.Entry()
        self.entrythingy.pack()

        # Create the application variable.
        self.contents = tk.StringVar()
        # Set it to some value.
        self.contents.set("this is a variable")
        # Tell the entry widget to watch this variable.
        self.entrythingy["textvariable"] = self.contents

        # Define a callback for when the user hits return.
        # It prints the current value of the variable.
        self.entrythingy.bind('<Key-Return>',
                             self.print_contents)

    def print_contents(self, event):
        print("Hi. The current entry content is:",
              self.contents.get())

root = tk.Tk()
myapp = App(root)
myapp.mainloop()
ウィンドウマネージャ
Tk には、ウィンドウマネジャとやり取りするための wm というユーティリティコマンドがあります。wm コマンドにオプションを指定すると、タイトルや配置、アイコンビットマップなどを操作できます。tkinter では、こうしたコマンドは Wm クラスのメソッドとして実装されています。トップレベルウィジェットは Wm クラスからサブクラス化されているので、Wm のメソッドを直接呼び出せます。

あるウィジェットの入っているトップレベルウィンドウを取得したい場合、大抵は単にウィジェットのマスタを参照するだけですみます。とはいえ、ウィジェットがフレーム内にパックされている場合、マスタはトップレベルウィンドウではありません。任意のウィジェットの入っているトップレベルウィンドウを知りたければ _root() メソッドを呼び出してください。このメソッドはアンダースコアがついていますが、これはこの関数が Tkinter の実装の一部であり、Tk の機能に対するインタフェースではないことを示しています。

以下に典型的な使い方の例をいくつか挙げます:

import tkinter as tk

class App(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.pack()

# create the application
myapp = App()

#
# here are method calls to the window manager class
#
myapp.master.title("My Do-Nothing Application")
myapp.master.maxsize(1000, 400)

# start the program
myapp.mainloop()
Tk オプションデータ型
anchor
指定できる値はコンパスの方位です: "n" 、 "ne" 、 "e" 、 "se" 、 "s" 、 "sw" 、 "w" 、 "nw" 、および "center" 。

bitmap
八つの組み込み、名前付きビットマップ: 'error' 、 'gray25' 、 'gray50' 、 'hourglass' 、 'info' 、 'questhead' 、 'question' 、 'warning' 。 X ビットマップファイル名を指定するために、 "@/usr/contrib/bitmap/gumby.bit" のような @ を先頭に付けたファイルへの完全なパスを与えてください。

boolean
整数 0 または 1 、あるいは、文字列 "yes" または "no" を渡すことができます。

callback
これは引数を取らない Python 関数ならどれでも構いません。例えば:

def print_it():
    print("hi there")
fred["command"] = print_it
color
色は rgb.txt ファイルの X カラーの名前か、または RGB 値を表す文字列として与えられます。 RGB 値を表す文字列は、4ビット: "#RGB", 8 bit: "#RRGGBB", 12 bit: "#RRRGGGBBB", あるいは、16 bit "#RRRRGGGGBBBB" の範囲を取ります。ここでは、R,G,B は適切な十六進数ならどんなものでも表します。詳細は、Ousterhout の本の160ページを参照してください。

cursor
cursorfont.h の標準Xカーソル名を、接頭語 XC_ 無しで使うことができます。例えば、handカーソル(XC_hand2)を得るには、文字列 "hand2" を使ってください。あなた自身のビットマップとマスクファイルを指定することもできます。 Ousterhout の本の179ページを参照してください。

distance
スクリーン上の距離をピクセルか絶対距離のどちらかで指定できます。ピクセルは数値として与えられ、絶対距離は文字列として与えられます。絶対距離を表す文字列は、単位を表す終了文字 (センチメートルには c 、インチには i 、ミリメートルには m 、プリンタのポイントには p)を伴います。例えば、3.5インチは "3.5i" と表現します。

font
Tkはフォント名の形式に {courier 10 bold} のようなリストを使います。正の数のフォントサイズはポイント単位で使用され、負の数のサイズはピクセル単位と見なされます。

geometry
これは widthxheight 形式の文字列です。ここでは、ほとんどのウィジェットに対して幅と高さピクセル単位で (テキストを表示するウィジェットに対しては文字単位で)表されます。例えば: fred["geometry"] = "200x100" 。

justify
指定できる値は文字列です: "left" 、 "center" 、 "right" 、そして "fill" 。

region
これは空白で区切られた四つの要素をもつ文字列です。各要素は指定可能な距離です(以下を参照)。例えば: "2 3 4 5" と "3i 2i 4.5i 2i" と "3c 2c 4c 10.43c" は、すべて指定可能な範囲です。

relief
ウィジェットのボーダのスタイルが何かを決めます。指定できる値は: "raised" 、 "sunken" 、 "flat" 、 "groove" 、と "ridge" 。

scrollcommand
これはほとんどの場合スクロールバーウィジェットの set() メソッドですが、1 個の引数を取るあらゆるウィジェットにもなりえます。

wrap
次の中の一つでなければなりません: "none" 、 "char" 、あるいは "word" 。

バインドとイベント
ウィジェットコマンドからの bind メソッドによって、あるイベントを待つことと、そのイベント型が起きたときにコールバック関数を呼び出すことができるようになります。 bind メソッドの形式は:

def bind(self, sequence, func, add=''):
ここでは:

sequence
は対象とするイベントの型を示す文字列です (詳細については、bind の man ページと John Ousterhout の本の201ページを参照してください)。

func
は一引数を取り、イベントが起きるときに呼び出される Python 関数です。イベント・インスタンスが引数として渡されます。 (このように実施される関数は、一般に callbacks として知られています。)

add
はオプションで、 '' か '+' のどちらかです。空文字列を渡すことは、このイベントが関係する他のどんなバインドをもこのバインドが置き換えることを意味します。 '+' を使う仕方は、この関数がこのイベント型にバインドされる関数のリストに追加されることを意味しています。

例えば:

def turn_red(self, event):
    event.widget["activeforeground"] = "red"

self.button.bind("<Enter>", self.turn_red)
イベントのウィジェットフィールドが turn_red() コールバック内でどのようにアクセスされているかに注目してください。このフィールドは X イベントを捕らえたウィジェットを含んでいます。以下の表はアクセスできる他のイベントフィールドとそれらの Tk での表現方法の一覧です。Tk man ページを参照するときに役に立つでしょう。

Tk

Tkinter イベントフィールド

Tk

Tkinter イベントフィールド

%f

focus

%A

char

%h

高さ

%E

send_event

%k

keycode

%K

keysym

%s

state

%N

keysym_num

%t

time

%T

type

%w

幅

%W

widget

%x

x

%X

x_root

%y

y

%Y

y_root

index パラメータ
多くのウィジェットにはパラメータ "index" を渡す必要があります。これらはテキストウィジェット内の特定の位置や、エントリウィジェット内の特定の文字、あるいはメニューウィジェット内の特定のメニューアイテムを指定するために使用されます。

エントリウィジェットのインデックス(インデックス、ビューインデックスなど)
エントリウィジェットは表示されているテキスト内の文字位置を参照するオプションを持っています。テキストウィジェットにおけるこれらの特別な位置にアクセスするために、次の tkinter 関数を使うことができます:

テキストウィジェットのインデックス
テキストウィジェットに対するインデックス記法はとても機能が豊富で、 Tk manページでよく説明されています。

メニューのインデックス(menu.invoke()、menu.entryconfig()など)
メニューに対するいくつかのオプションとメソッドは特定のメニュー項目を操作します。メニューインデックスはオプションまたはパラメータのために必要とされるときはいつでも、以下のものを渡すことができます:

ウィジェット内の数字の先頭からの位置を指す整数。先頭は 0。

文字列 "active"。現在カーソルがあるメニューの位置を指します。

文字列 "last" 。最後のメニューを指します。

@6 のような @ が前に来る整数。ここでは、整数がメニューの座標系における y ピクセル座標として解釈されます。

文字列 "none"。どんなメニューエントリもまったく指しておらず、ほとんどの場合、すべてのエントリの動作を停止させるために menu.activate() と一緒に使われます。そして、最後に、

メニューの先頭から一番下までスキャンしたときに、メニューエントリのラベルに一致したパターンであるテキスト文字列。このインデックス型は他すべての後に考慮されることに注意してください。その代わりに、それは last 、 active または none とラベル付けされたメニュー項目への一致は上のリテラルとして解釈されることを意味します。

画像
様々な形式の画像を、それに対応する tkinter.Image のサブクラスを使って作成できます:

XBM 形式の画像のための BitmapImage 。

PGM, PPM, GIF, PNG 形式の画像のための PhotoImage 。 最後のは Tk 8.6 からサポートされるようになりました。

画像のどちらの型でも file または data オプションを使って作られます (その上、他のオプションも利用できます)。

image オプションがウィジェットにサポートされるところならどこでも、画像オブジェクトを使うことができます (例えば、ラベル、ボタン、メニュー)。これらの場合では、Tk は画像への参照を保持しないでしょう。画像オブジェクトへの最後の Python の参照が削除されたときに、画像データも削除されます。そして、どこで画像が使われていようとも、Tk は空の箱を表示します。

参考 Pillow パッケージにより、 BMP, JPEG, TIFF, WebP などの形式のサポートが追加されました。
ファイルハンドラ
Tk を使うとコールバック関数の登録や解除ができ、ファイルディスクリプタに対する入出力が可能なときに、Tk のメインループからその関数が呼ばれます。 ファイルディスクリプタ1つにつき、1つだけハンドラは登録されます。コード例です:

import tkinter
widget = tkinter.Tk()
mask = tkinter.READABLE | tkinter.WRITABLE
widget.tk.createfilehandler(file, mask, callback)
...
widget.tk.deletefilehandler(file)
これらの機能は Windows では利用できません。

読み込みに使えるバイト数は分からないので、 BufferedIOBase クラスや TextIOBase クラスの read() メソッドおよび readline() メソッドを使おうとしないでください。これらは読み込みの際に、あらかじめ決められたバイト数を要求するのです。ソケットには、 recv() や recvfrom() メソッドを使うといいです。その他のファイルには、 raw 読み込みか os.read(file.fileno(), maxbytecount) を使ってください。

Widget.tk.createfilehandler(file, mask, func)
ファイルハンドラであるコールバック関数 func を登録します。 file 引数は、 (ファイルやソケットオブジェクトのような) fileno() メソッドを持つオブジェクトか、整数のファイルディスクリプタとなります。 mask 引数は、以下にある3つの定数の組み合わせの OR を取ったものです。コールバックは次のように呼ばれます:

callback(file, mask)
Widget.tk.deletefilehandler(file)
ファイルハンドラの登録を解除します。

tkinter.READABLE
tkinter.WRITABLE
tkinter.EXCEPTION
mask 引数で使う定数です。

tkinter.scrolledtext --- スクロールするテキストウィジェット¶
ソースコード: Lib/tkinter/scrolledtext.py

The tkinter.scrolledtext module provides a class of the same name which implements a basic text widget which has a vertical scroll bar configured to do the "right thing." Using the ScrolledText class is a lot easier than setting up a text widget and scroll bar directly.

テキストウィジェットとスクロールバーは Frame の中に一緒にpackされ、 Grid と Pack ジオメトリマネジャのメソッドはFrame オブジェクトから得られます。これによって、もっとも標準的なジオメトリマネジャの振る舞いにするために、直接 ScrolledText ウィジェットを使えるようになります。

特定の制御が必要ならば、以下の属性が利用できます:

class tkinter.scrolledtext.ScrolledText(master=None, **kw)
frame
テキストとスクロールバーウィジェットを取り囲むフレーム。

vbar
スクロールバーウィジェット。

tkinter.ttk --- Tk のテーマ付きウィジェット¶
ソースコード: Lib/tkinter/ttk.py

tkinter.ttk モジュールは Tk 8.5 で導入された Tk のテーマ付きウィジェットへのアクセスを提供します。 Tk 8.5 が無い環境で Python がコンパイルされていた場合でも、 Tile がインストールされていればこのモジュールにアクセスできます。前者のメソッドは Tk 8.5 を使うことで X11 上のフォントのアンチエイリアスや透過ウィンドウ (X11 ではコンポジションウィンドウマネージャが必要です) など、恩恵が増えます。

tkinter.ttk の基本的なアイディアは、拡張可能性のためにウィジェットの動作を実装するコードと見た目を記述するコードを分離することです。

参考
Tk Widget Styling Support
Tk のテーマサポートを紹介するドキュメント

Ttk を使う
Ttk を使い始めるために、モジュールをインポートします:

from tkinter import ttk
基本的な Tk ウィジェットを上書きするため、次のように Tk のインポートに続けてインポートを行います:

from tkinter import *
from tkinter.ttk import *
このように書くと、いくつかの tkinter.ttk ウィジェット (Button, Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale, Scrollbar) は自動的に Tk ウィジェットを置き換えます。

これにはプラットフォームをまたいでより良い見た目を得られるという、直接的な利益がありますが、ウィジェットは完全な互換性を持っているわけではありません。一番の違いは "fg" や "bg" やその他のスタイルに関係するウィジェットのオプションが Ttk ウィジェットから無くなっていることです。同じ (もしくはより良い) 見た目にするためには ttk.Style を使ってください。

参考
Converting existing applications to use Tile widgets
アプリケーションを移行して新しいウィジェットを使用する際に出くわす典型的な差異について (Tcl の用語を使って) 書かれている研究論文

Ttk ウィジェット
Ttk comes with 18 widgets, twelve of which already existed in tkinter: Button, Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale, Scrollbar, and Spinbox. The other six are new: Combobox, Notebook, Progressbar, Separator, Sizegrip and Treeview. And all them are subclasses of Widget.

Ttk ウィジェットを使用すると、アプリケーションの見た目と使いやすさが向上します。上述の通り、書式をコーディングする方法は異なります。

Tk のコード

l1 = tkinter.Label(text="Test", fg="black", bg="white")
l2 = tkinter.Label(text="Test", fg="black", bg="white")
Ttk のコード:

style = ttk.Style()
style.configure("BW.TLabel", foreground="black", background="white")

l1 = ttk.Label(text="Test", style="BW.TLabel")
l2 = ttk.Label(text="Test", style="BW.TLabel")
TtkStyling についての詳細は Style クラスの文書を読んでください。

ウィジェット
ttk.Widget はTk のテーマ付きウィジェットがサポートしている標準のオプションやメソッドを定義するもので、これを直接インスタンス化するものではありません。

標準オプション
全ての ttk ウィジェットは以下のオプションを受け付けます:

オプション

説明

クラス

ウィンドウクラスを指定します。このクラスはオプションデータベースにウィンドウの他のオプションについて問い合わせを行うときに使われ、これによりウィンドウのデフォルトのバインドタグを決定したり、ウィジェットのデフォルトのレイアウトやスタイルを選択します。このオプションは読み出し専用で、ウィンドウが作成されるときにのみ指定できます。

cursor

このウィジェットで使うマウスカーソルを指定します。空文字列 (デフォルト) が設定されている場合は、カーソルは親ウィジェットのものを引き継ぎます。

takefocus

キーボードによる移動のときにウィンドウがフォーカスを受け入れるかを決定します。0、1、空文字列のいずれかを返します。0 が返されると、キーボードによる移動でそのウィンドウは常にスキップされます。1 なら、そのウィンドウが表示されているときに限り入力フォーカスを受け入れます。そして空文字列は、移動スクリプトによってウィンドウにフォーカスを当てるかどうかが決まることを意味します。

style

独自のウィジェットスタイルを指定するのに使われます。

スクロール可能ウィジェットのオプション
以下のオプションはスクロールバーで操作されるウィジェットが持っているオプションです。

オプション

説明

xscrollcommand

水平方向のスクロールバーとのやり取りに使われます。

ウィジェットのウィンドウが再描画されたとき, ウィジェットは scrollcommand に基いて Tcl コマンドを生成します。

通常このオプションにはあるスクロールバーのメソッド Scrollbar.set() が設定されます。こうすると、ウィンドウの見た目が変わったときにスクロールバーの状態も更新されます。

yscrollcommand

垂直方向のスクロールバーとのやり取りに使われます。詳しくは、上記を参照してください。

ラベルオプション
以下のオプションはラベルやボタンやボタンに類似したウィジェットが持っているオプションです。

オプション

説明

text

ウィジェットに表示される文字列を指定します。

textvariable

text オプションの代わりに使う値の変数名を指定します。

underline

このオプションを設定すると、文字列の中で下線を引く文字のインデックス (0 基点) を指定します。下線が引かれた文字はショートカットとして使われます。

image

表示する画像を指定します。これは 1 つ以上の要素を持つリストです。先頭の要素はデフォルトの画像名です。残りの要素は Style.map() で定義されているような状態名と値のペアの並びで、ウィジェットがある状態、もしくはある状態の組み合わせにいるときに使用する別の画像を指定します。このリストにある全ての画像は同じサイズでなればなりません。

compound

text オプションと image オプションが両方とも指定されていた場合に、テキストに対して画像をどう配置するかを指定します。適当な値は:

text: テキストのみ表示する

image: 画像のみ表示する

top, bottom, left, right: それぞれ画像をテキストの上、下、左、右に配置する。

none: デフォルト。もしあれば画像を表示し、そうでなければテキストを表示する。

幅

0 より大きい場合、テキストラベルを作成するのにどれくらいのスペースを使うかを文字の幅で指定します。0 より小さい場合、最小の幅が指定されます。0 もしくは無指定の場合、テキストラベルに対して自然な幅が使われます。

互換性オプション
オプション

説明

state

"normal" か "disabled" に設定され、 "disabled" 状態のビットをコントロールします。これは書き込み専用のオプションです: これを設定するとウィジェットの状態を変更できますが、 Widget.state() メソッドはこのオプションに影響を及ぼしません。

ウィジェットの状態
ウィジェットの状態は独立した状態フラグのビットマップです。

Flag

説明

active

マウスカーソルがウィジェットの上にあり、マウスのボタンをクリックすることで何らかの動作をさせられます

disabled

プログラムによってウィジェットは無効化されています

focus

ウィジェットにキーボードフォーカスがあります

pressed

ウィジェットは押されています

selected

チェックボタンやラジオボタンのようなウィジェットでの "オン" や "チェック有" や "選択中" に当たります

background

Windows と Mac には "アクティブな" もしくは最前面のウィンドウという概念があります。背面のウィンドウにあるウィジェットには background 状態が設定され、最前面のウィンドウにあるウィジェットでは解除されます

readonly

ウィジェットはユーザからの変更を受け付けません

alternate

ウィジェット特有の切り替え表示になっています

invalid

ウィジェットの値が不正です

状態仕様は状態名の並びになっていて、状態名の先頭にはビットがオフになっていることを示す感嘆符が付くことがあります。

ttk.Widget
以下に書かれているメソッドに加えて、 ttk.Widget は tkinter.Widget.cget() メソッドと tkinter.Widget.configure() メソッドをサポートしています。

class tkinter.ttk.Widget
identify(x, y)
x y の位置にある要素の名前、もしくはその位置に要素が無ければ空文字列を返します。

x と y はウィジェットに対するピクセル単位の座標です。

instate(statespec, callback=None, *args, **kw)
ウィジェットの状態をチェックします。コールバックが指定されていない場合、ウィジェットの状態が statespec に一致していれば True 、そうでなければ False を返します。コールバックが指定されていて、ウィジェットの状態が statespec に一致している場合、引数に args を指定してそのコールバックを呼び出します。

state(statespec=None)
ウィジェットの状態を変更したり、取得したりします。statespec が指定されている場合、それに応じてウィジェットの状態を設定し、どのフラグが変更されたかを示す新しい statespec を返します。statespec が指定されていない場合、現在の状態フラグを返します。

通常 statespec はリストもしくはタプルです。

コンボボックス
ttk.Combobox ウィジェットはテキストフィールドと値のポップダウンリストを結び付けます。このウィジェットは Entry の子クラスです。

Widget から継承したメソッド (Widget.cget(), Widget.configure(), Widget.identify(), Widget.instate(), Widget.state()) と以下の Entry から継承したメソッド (Entry.bbox(), Entry.delete(), Entry.icursor(), Entry.index(), Entry.insert(), Entry.selection(), Entry.xview()) に加え、このクラスには ttk.Combobox で説明するメソッドがあります。

オプション
このウィジェットは以下の固有のオプションを受け付けます:

オプション

説明

exportselection

真偽値を取る。設定されている場合、ウィジェットの選択はウィンドウマネージャの選択とリンクしています (例えば、Misc.selection_get を実行することで得られます)。

justify

ウィジェットの中でテキストをどう配置するかを指定します。 "left", "center", "right" のうちのどれか 1 つです。

高さ

ポップダウンリストの高さを行数で指定します。

postcommand

コンボボックスの値を表示する直前に呼び出される、(Misc.register などで登録した) スクリプトです。どの値を表示するかについても指定できます。

state

"normal", "readonly", "disabled" のどれか 1 つです。"readonly" 状態では、直接入力値を編集することはできず、ユーザはドロップダウンリストから値を 1 つ選ぶことしかできません。"normal" 状態では、テキストフィールドは直接編集できます。"disabled" 状態では、コンボボックスは一切反応しません。

textvariable

コンボボックスの値とリンクさせる変数名を指定します。その変数の値が変更されたとき、ウィジェットの値は更新されます。ウィジェットの値が更新されたときも同様です。 tkinter.StringVar を参照してください。

values

ドロップダウンリストに表示する値のリストを指定します。

幅

入力ウィンドウに必要な幅をウィジェットのフォントの平均的なサイズの文字で測った、文字数を指定します。

仮想イベント
コンボボックスウィジェットは、ユーザが値のリストから1つ選んだときに仮想イベント <<ComboboxSelected>> を生成します。

ttk.Combobox
class tkinter.ttk.Combobox
current(newindex=None)
newindex が指定されている場合、コンボボックスの値がドロップダウンリストの newindex の位置にある値に設定されます。そうでない場合、現在の値のインデックスを、もしくは現在の値がリストに含まれていないなら -1 を返します。

get()
コンボボックスの現在の値を返します。

set(value)
コンボボックスの値を value に設定します。

Spinbox
The ttk.Spinbox widget is a ttk.Entry enhanced with increment and decrement arrows. It can be used for numbers or lists of string values. This widget is a subclass of Entry.

Besides the methods inherited from Widget: Widget.cget(), Widget.configure(), Widget.identify(), Widget.instate() and Widget.state(), and the following inherited from Entry: Entry.bbox(), Entry.delete(), Entry.icursor(), Entry.index(), Entry.insert(), Entry.xview(), it has some other methods, described at ttk.Spinbox.

オプション
このウィジェットは以下の固有のオプションを受け付けます:

オプション

説明

from

Float value. If set, this is the minimum value to which the decrement button will decrement. Must be spelled as from_ when used as an argument, since from is a Python keyword.

to

Float value. If set, this is the maximum value to which the increment button will increment.

increment

Float value. Specifies the amount which the increment/decrement buttons change the value. Defaults to 1.0.

values

Sequence of string or float values. If specified, the increment/decrement buttons will cycle through the items in this sequence rather than incrementing or decrementing numbers.

wrap

Boolean value. If True, increment and decrement buttons will cycle from the to value to the from value or the from value to the to value, respectively.

format

String value. This specifies the format of numbers set by the increment/decrement buttons. It must be in the form "%W.Pf", where W is the padded width of the value, P is the precision, and '%' and 'f' are literal.

command

Python callable. Will be called with no arguments whenever either of the increment or decrement buttons are pressed.

仮想イベント
The spinbox widget generates an <<Increment>> virtual event when the user presses <Up>, and a <<Decrement>> virtual event when the user presses <Down>.

ttk.Spinbox
class tkinter.ttk.Spinbox
get()
Returns the current value of the spinbox.

set(value)
Sets the value of the spinbox to value.

ノートブック
ノートブックウィジェットは複数のウィンドウを管理し、同時に 1 つのウィンドウを表示します。それぞれの子ウィンドウはタブの関連付けられていて、ユーザはそれを選択して表示されているウィンドウを切り替えます。

オプション
このウィジェットは以下の固有のオプションを受け付けます:

オプション

説明

高さ

0 より大きな値が設定されている場合、 (内部のパディングやタブを含まない) ペイン領域に必要な高さを指定します。設定されていない場合、全てのペインの高さの最大値が使われます。

padding

ノートブックの外周に付け足す追加の領域の量を指定します。パディングは最大 4 個の長さ指定のリストです: 左、上、右、下の順で指定します。4 個より少ない場合、デフォルトで下は上と、右は左と、上は左と同じ値が、それぞれ使われます。

幅

0 より大きな値が指定されている場合、(内部のパディングを含まない) ペイン領域に必要な幅を指定します。設定されていない場合、全てのペインの幅の最大値が使われます。

タブオプション
タブ用のオプションもあります:

オプション

説明

state

"normal", "disabled", "hidden" のうちどれか 1 つです。 "disabled" の場合、タブは選択することができません。 "hidden" の場合、タブは表示されません。

sticky

ペイン領域の中に子ウィンドウがどう置かれるかを指定します。指定する値は "n", "s", "e", "w" からなる 0 文字以上の文字列です。配置マネージャの grid() と同様に、それぞれの文字は子ウィンドウが (北、南、東、西の) どの辺に対して追随するかに対応しています。

padding

ノートブックとこのペインの間に付け足す追加の領域の量を指定します。文法はこのウィジェットの padding オプションと同じです。

text

タブに表示するテキストを指定します。

image

タブに表示する画像を指定します。 Widget のオプション image の説明を参照してください。

compound

text オプションと image オプションが両方指定されているときにテキストに対して画像をどう表示するかを指定します。指定する値については Label Options を参照してください。

underline

テキスト中の下線を引く文字のインデックス (0 基点) を指定します。 Notebook.enable_traversal() が呼ばれていた場合、下線が引かれた文字はショートカットとして使われます。

タブ識別子
ttk.Notebook のいくつかのメソッドにある tab_id は以下の形式を取ります:

0 からタブの数の間の整数

子ウィンドウの名前

タブを指し示す "@x,y" という形式の位置指定

現在選択されているタブを指し示すリテラル文字列 "current"

タブ数を返すリテラル文字列 "end" (Notebook.index() でのみ有効)

仮想イベント
このウィジェットは新しいタブが選択された後に仮想イベント <<NotebookTabChanged>> を生成します。

ttk.Notebook
class tkinter.ttk.Notebook
add(child, **kw)
ノートブックに新しいタブを追加します。

ウィンドウが現在ノートブックによって管理されているが隠れている場合、以前の位置に復元します。

利用可能なオプションのリストについては Tab Options を参照してください。

forget(tab_id)
tab_id で指定されたタブを削除します。関連付けられていたウィンドウは切り離され、管理対象でなくなります。

hide(tab_id)
tab_id で指定されたタブを隠します。

タブは表示されませんが、関連付いているウィンドウはノートブックによって保持されていて、その設定も記憶されています。隠れたタブは add() コマンドで復元できます。

identify(x, y)
x y の位置にあるタブの名前を、そこにタブが無ければ空文字列を返します。

index(tab_id)
tab_id で指定されたタブのインデックスを、 tab_id が文字列の "end" だった場合はタブの総数を返します。

insert(pos, child, **kw)
指定された位置にペインを挿入します。

pos は文字列の "end" か整数のインデックスか管理されている子ウィンドウの名前です。 child が既にノートブックの管理対象だった場合、指定された場所に移動させます。

利用可能なオプションのリストについては Tab Options を参照してください。

select(tab_id=None)
指定された tab_id を選択します。

関連付いている子ウィンドウは表示され、直前に選択されていたウィンドウは (もし異なれば) 表示されなくなります。 tab_id が指定されていない場合は、現在選択されているペインのウィジェット名を返します。

tab(tab_id, option=None, **kw)
指定された tab_id のオプションを問い合わせたり、変更したりします。

kw が与えられなかった場合、タブのオプション値の辞書を返します。 option が指定されていた場合、その option の値を返します。それ以外の場合は、オプションに対応する値が設定されます。

tabs()
ノートブックに管理されているウィンドウのリストを返します。

enable_traversal()
このノートブックを含む最上位にあるウィンドウでのキーボード移動を可能にします。

これによりノートブックを含んだ最上位にあるウィンドウに対し、以下のキーバインディングが追加されます:

Control-Tab: 現在選択されているタブの 1 つ次のタブを選択します。

Shift-Control-Tab: 現在選択されているタブの 1 つ前のタブを選択します。

Alt-K: K があるタブの (下線が引かれた) ショートカットキーだとして、そのタブを選択します。

ネストしたノートブックも含め、1 つのウィンドウの最上位にある複数のノートブックのキーボード移動が可能になることもあります。しかしノートブック上の移動は、全てのペインが同じノートブックを親としているときのみ正しく動作します。

プログレスバー
ttk.Progressbar ウィジェットは長く走る処理の状態を表示します。このウィジェットは 2 つのモードで動作します: 1) 決定的モードでは、全ての処理の総量のうち完了した量を表示します。 2) 非決定的モードでは、今作業が進んでいることをユーザに示します。

オプション
このウィジェットは以下の固有のオプションを受け付けます:

オプション

説明

orient

"horizontal" もしくは "vertical" のいずれかです。プログレスバーの方向を指定します。

length

プログレスバーの長さを指定します。 (水平方向の場合は幅、垂直方向の場合は高さです)

mode

"determinate" か "indeterminate" のいずれかです。

maximum

最大値を数値で指定します。デフォルトは 100 です。

value

プログレスバーの現在値です。決定的 ("determinate") モードでは、完了した処理の量を表します。非決定的 ("indeterminate") モードでは、 maximum を法として解釈され、値が maximum に達したときにプログレスバーは 1 "サイクル" を完了したことになります。

variable

value オプションとリンクさせる変数名です。指定されている場合、変数の値が変更されるとプログレスバーの値は自動的にその値に設定されます。

phase

読み出し専用のオプションです。このウィジェットの値が 0 より大きく、かつ決定的モードでは最大値より小さいときに、ウィジェットが定期的にこのオプションの値を増加させます。このオプションは現在の画面テーマが追加のアニメーション効果を出すのに使います。

ttk.Progressbar
class tkinter.ttk.Progressbar
start(interval=None)
自動増加モードを開始します: interval ミリ秒ごとに Progressbar.step() を繰り返し呼び出すタイマーイベントを設定します。引数で指定しない場合は、 interval はデフォルトで 50 ミリ秒になります。

step(amount=None)
プログレスバーの値を amount だけ増加させます。

引数で指定しない場合は、 amount はデフォルトで 1.0 になります。

stop()
自動増加モードを停止します: このプログレスバーの Progressbar.start() で開始された繰り返しのタイマーイベントを全てキャンセルします。

セパレータ
ttk.Separator ウィジェットは水平もしくは垂直のセパレータを表示します。

ttk.Widget から継承したメソッド以外にメソッドを持ちません。

オプション
このウィジェットは次の特定のオプションを受け付けます。

オプション

説明

orient

"horizontal" か "vertical" のいずれかです。セパレータの方向を指定します。

サイズグリップ
(グローボックスとしても知られる) ttk.Sizegrip ウィジェットを使用すると、つまみ部分を押してドラッグすることで、このウィジェットを含む最上位のウィンドウのサイズを変更できます。

このウィジェットは ttk.Widget から継承したもの以外のオプションとメソッドを持ちません。

プラットフォーム固有のメモ
Mac OS X (訳注: 今後はmacOSと呼ばれます) では、最上位のウィンドウにはデフォルトで組み込みのサイズグリップが含まれています。組み込みのグリップが Sizegrip を隠してしまうので、 Sizegrip を追加しても問題ありません。

バグ
このウィジェットを含む最上位のウィンドウの位置がスクリーンの右端や下端に対して相対的に指定されている場合 (例: ....) 、 Sizegrip ウィジェットはウィンドウのサイズ変更をしません。

このウィジェットは "南東" 方向のサイズ変更しかサポートしていません。

ツリービュー
ttk.Treeview ウィジェットは階層のある要素 (アイテム) の集まりを表示します。それぞれの要素はテキストラベル、オプションの画像、オプションのデータのリストを持っています。データはラベルの後に続くカラムに表示されます。

データが表示される順序はウィジェットの displaycolumns オプションで制御されます。ツリーウィジェットはカラムヘッダを表示することもできます。カラムには数字もしくはウィジェットの columns オプションにある名前でアクセスできます。 Column Identifiers を参照してください。

それぞれの要素は一意な名前で識別されます。要素の作成時に識別子が与えられなかった場合、ウィジェットが要素の識別子を生成します。このウィジェットには {} という名前の特別なルート要素があります。ルート要素自身は表示されません; その子要素たちが階層の最上位に現れます。

それぞれの要素はタグのリストも持っていて、イベントバインディングと個別の要素を関連付け、要素の見た目を管理するのに使えます。

ツリービューウィジェットは水平方向と垂直方向のスクロールをサポートしていて、 Scrollable Widget Options に記述してあるオプションと Treeview.xview() メソッドおよび Treeview.yview() メソッドが使えます。

オプション
このウィジェットは以下の固有のオプションを受け付けます:

オプション

説明

columns

カラム数とその名前を指定するカラム識別子のリストです。

displaycolumns

どのデータカラムをどの順序で表示するかを指定する、 (名前もしくは整数のインデックスの) カラム識別子のリストか、文字列 "#all" です。

高さ

表示する行数を指定します。メモ: 表示に必要な幅はカラム幅の合計から決定されます。

padding

ウィジェットの内部のパディングのサイズを指定します。パディングは最大 4 個の長さ指定のリストです。

selectmode

組み込みのクラスバインディングが選択状態をどう管理するかを指定します。設定する値は "extended", "browse", "none" のどれか 1 つです。 "extended" に設定した場合 (デフォルト)、複数の要素が選択できます。 "browse" に設定した場合、同時に 1 つの要素しか選択できません。 "none" に設定した場合、選択を変更することはできません。

このオプションの値によらず、アプリケーションのコードと関連付けられているタグからは好きなように選択状態を設定できます。

show

ツリーのどの要素を表示するかを指定する、以下にある値を 0 個以上含むリストです。

tree: カラム #0 にツリーのラベルを表示します。

headings: ヘッダ行を表示します。

デフォルトは "tree headings" 、つまり全ての要素を表示します。

メモ: show="tree" が指定されていない場合でも、カラム #0 は常にツリーカラムを参照します。

要素オプション
以下の要素オプションは、ウィジェットの insert コマンドと item コマンドで要素に対して指定できます。

オプション

説明

text

アイテムに表示するテキストラベルです。

image

ラベルの左に表示される Tk 画像です。

values

要素に関連付けられている値のリストです。

それぞれの要素はウィジェットの columns オプションと同じ数の値を持たなければいけません。 columns オプションより少ない場合、残りの値は空として扱われます。 columns オプションより多い場合、余計な値は無視されます。

open

True/False value indicating whether the item's children should be displayed or hidden.

tags

この要素に関連付いているタグのリストです。

タグオプション
以下のオプションはタグに対して設定できます:

オプション

説明

foreground

テキストの色を指定します。

background

セルや要素の背景色を指定します。

font

テキストを描画するときに使うフォントを指定します。

image

要素の image オプションが空だった場合に使用する画像を指定します。

カラム識別子
カラム識別子は以下のいずれかの形式を取ります:

columns オプションのリストにある名前。

n 番目のデータカラムを指し示す整数 n 。

n を整数として n 番目の表示されているカラムを指し示す #n という形式の文字列。

注釈:

要素のオプション値は実際に格納されている順序とは違った順序で表示されることがあります。

show="tree" が指定されていない場合でも、カラム #0 は常にツリーカラムを指しています。

データカラムを指す数字は、要素の values オプションのリストのインデックスです; 表示カラムを指す数字は、値が表示されているツリーのカラム番号です。ツリーラベルはカラム #0 に表示されます。 displaycolumns オプションが設定されていない場合は、 n 番目のデータカラムはカラム #n+1 に表示されます。再度言っておくと、 カラム #0 は常にツリーカラムを指します 。

仮想イベント
ツリービューは以下の仮想イベントを生成します。

Event

説明

<<TreeviewSelect>>

選択状態が変更されたときに生成されます。

<<TreeviewOpen>>

フォーカスが当たっている要素に open=True が設定される直前に生成されます。

<<TreeviewClose>>

フォーカスが当たっている要素に open=False が設定された直後に生成されます。

Treeview.focus() メソッドと Treeview.selection() メソッドは変更を受けた要素を判別するのに使えます。

ttk.Treeview
class tkinter.ttk.Treeview
bbox(item, column=None)
(ツリービューウィジェットのウィンドウを基準として) 指定された item のバウンディングボックス情報を (x 座標, y 座標, 幅, 高さ) の形式で返します。

column が指定されている場合は、セルのバウンディングボックスを返します。 (例えば、閉じた状態の要素の子供であったり、枠外にスクロールされていて) item が見えなくなっている場合は、空文字列が返されます。

get_children(item=None)
item の子要素のリストを返します。

item が指定されていなかった場合は、ルート要素の子供が返されます。

set_children(item, *newchildren)
item の子要素を newchildren で置き換えます。

item にいる子供のうち newchildren にないものはツリーから切り離されます。 newchildren にあるどの要素も item の祖先であってはいけません。 newchildren を指定しなかった場合は、 item の子要素が全て切り離されることに注意してください。

column(column, option=None, **kw)
指定した column のオプションを問い合わせたり、変更したりします。

kw が与えられなかった場合は、カラムのオプション値の辞書が返されます。 option が指定されていた場合は、その option の値が返されます。それ以外の場合は、オプションに値を設定します。

設定できるオプションとその値は次の通りです:

id
カラム名を返します。これは読み出し専用のオプションです。

anchor: 標準の Tk anchor の値
このカラムでセルに対してテキストをどう配置するかを指定します。

minwidth: 幅
カラムの最小幅をピクセル単位で表したものです。ツリービューウィジェットは、ウィジェットのサイズが変更されたりカラムをユーザがドラッグして移動させたりしたときに、このオプションで指定した幅より狭くすることはありません。

stretch: True/False
ウィジェットがサイズ変更されたとき、カラムの幅をそれに合わせるかどうかを指定します。

width: 幅
カラムの幅をピクセル単位で表したものです。

ツリーカラムの設定を行うには、 column = "#0" を付けてこのメソッドを呼び出してください。

delete(*items)
指定された items とその子孫たち全てを削除します。

ルート要素は削除されません。

detach(*items)
指定された items を全てツリーから切り離します。

その要素と子孫たちは依然として存在していて、ツリーの別の場所に再度挿入することができますが、隠された状態になり表示はされません。

ルート要素は切り離されません。

exists(item)
指定された item がツリーの中にあれば True を返します。

focus(item=None)
item が指定されていた場合は、 item にフォーカスを当てます。そうでない場合は、現在フォーカスが当たっている要素が、どの要素にもフォーカスが当たっていない場合は '' が返されます。

heading(column, option=None, **kw)
指定された column の heading のオプションを問い合わせたり、変更したりします。

kw が与えられなかった場合は、見出しのオプション値の辞書が返されます。 option が指定されている場合は、 option の値が返されます。それ以外の場合は、オプションに値を設定します。

設定できるオプションとその値は次の通りです:

text: テキスト
カラムの見出しに表示するテキスト。

image: 画像名
カラムの見出しの右に表示する画像を指定します。

anchor: anchor
見出しのテキストをどう配置するかを指定します。標準の Tk anchor の値です。

command: コールバック
見出しラベルがクリックされたときに実行されるコールバックです。

ツリーカラムの見出しの設定を行うには、 column = "#0" を付けてこのメソッドを呼び出してください。

identify(component, x, y)
x y で与えられた場所にある指定された component の説明を返します。その場所に指定された component が無い場合は空文字列を返します。 (訳注: component には "region", "item", "column", "row", "element" が指定でき、それぞれ "cell", "heading" などの場所の名前、要素の識別子、 #n という形式のカラム名、その行にある要素の識別子、 "text", "padding" などの画面構成要素の名前を返します。)

identify_row(y)
y 座標が y の位置にある要素の識別子を返します。

identify_column(x)
x 座標が x の位置にあるセルのデータカラムの識別子を返します。

ツリーカラムは #0 という識別子を持ちます。

identify_region(x, y)
以下のうち 1 つを返します:

region

意味

heading

ツリーの見出し領域

separator

2 つのカラム見出しの間のスペース

tree

ツリーの領域

cell

データセル

使用可能バージョン: Tk 8.6

identify_element(x, y)
x y の位置にある画面構成要素の名前を返します。

使用可能バージョン: Tk 8.6

index(item)
親要素の子要素リストの中での item のインデックスを返します。

insert(parent, index, iid=None, **kw)
新しい要素を作り、その要素の識別子を返します。

parent は親となる要素の識別子で、空文字列にすると新しい要素を最上位に作成します。 index は整数もしくは "end" という値で、それによって親要素の子要素リストのどこに新しい要素を挿入するかを指定します。 index が 0 以下だった場合は、新しい要素は先頭に挿入されます; index が現在の子要素の数以上だった場合は末尾に挿入されます。 iid が指定された場合は、要素の識別子として使われます; iid はまだツリーに存在していないものに限ります。それ以外の場合は、一意な識別子が生成されます。

使用できるオプションのリストについては Item Options を参照してください。

item(item, option=None, **kw)
指定された item のオプションを問い合わせたり、変更したりします。

オプションが与えられなかった場合は、要素のオプションと値が辞書の形で返されます。 option が指定された場合は、そのオプションの値が返されます。それ以外の場合は、 kw で与えられたようにオプションに値が設定されます。

move(item, parent, index)
item を parent の子要素リストの index の位置に移動します。

要素を自身の子孫の下に移動させるのは許されていません。 index が 0 以下の場合、 item は先頭に移動されます; 子要素の数以上だった場合、末尾に移動されます。 item が切り離された状態の場合は、再度取り付けられます。

next(item)
item の 1 つ下の兄弟の識別子を、 item が親にとって一番下の子供だった場合 '' を返します。

parent(item)
item の親の識別子を、 item が階層の最上位にいた場合 '' を返します。

prev(item)
item の 1 つ上の兄弟の識別子を、 item が親にとって一番上の子供だった場合 '' を返します。

reattach(item, parent, index)
Treeview.move() のエイリアスです。

see(item)
item を見える状態にします。

item の全ての子孫の open オプションを True にし、必要であれば item がツリーの見える範囲に来るようにウィジェットをスクロールさせます。

selection()
Returns a tuple of selected items.

バージョン 3.8 で変更: selection() no longer takes arguments. For changing the selection state use the following selection methods.

selection_set(*items)
新しく選択状態の要素が items になります。

バージョン 3.6 で変更: items は 1 つのタプルとしてだけでなく、別々の引数としても渡せます。

selection_add(*items)
選択状態の要素として items を追加します。

バージョン 3.6 で変更: items は 1 つのタプルとしてだけでなく、別々の引数としても渡せます。

selection_remove(*items)
選択状態の要素から items を取り除きます。

バージョン 3.6 で変更: items は 1 つのタプルとしてだけでなく、別々の引数としても渡せます。

selection_toggle(*items)
items のそれぞれの要素の選択状態を入れ替えます。

バージョン 3.6 で変更: items は 1 つのタプルとしてだけでなく、別々の引数としても渡せます。

set(item, column=None, value=None)
1 引数で呼び出された場合、指定された item のカラムと値のペアからなる辞書を返します。 2 引数で呼び出された場合、指定された column の現在の値を返します。 3 引数で呼び出された場合、与えられた item の column を指定された値 value に設定します。

tag_bind(tagname, sequence=None, callback=None)
与えられたイベント sequence 用のコールバックをタグ tagname にバインドします。イベントが要素に渡ってきたときに、要素の tags オプションのそれぞれのコールバックが呼び出されます。

tag_configure(tagname, option=None, **kw)
指定された tagname のオプションを問い合わせたり、変更したりします。

kw が与えられなかった場合、 tagname のオプション設定を辞書の形で返します。 option が指定された場合、指定された tagname の option の値を返します。それ以外の場合、与えられた tagname のオプションに値を設定します。

tag_has(tagname, item=None)
item が指定されていた場合、指定された item が与えられた tagname を持っているかどうかに従って 1 または 0 が返されます。そうでない場合、指定されたタグを持つ全ての要素のリストを返します。

使用可能バージョン: Tk 8.6

xview(*args)
ツリービューの水平方向の位置を問い合わせたり、変更したりします。

yview(*args)
ツリービューの垂直方向の位置を問い合わせたり、変更したりします。

Ttk スタイル
ttk のそれぞれのウィジェットにはスタイルが関連付けられていて、それと動的もしくはデフォルトで設定される要素のオプションによってウィジェットを構成する要素とその配置を指定します。デフォルトではスタイル名はウィジェットのクラス名と同じですが、ウィジェットの style オプションで上書きすることができます。ウィジェットのクラス名が分からない場合は、 Misc.winfo_class() (somewidget.winfo_class()) メソッドを使ってください。

参考
Tcl'2004 conference のプレゼンテーション
この文書ではテーマエンジンがどう動くかを説明しています

class tkinter.ttk.Style
このクラスはスタイルデータベースを操作するために使われます。

configure(style, query_opt=None, **kw)
style の指定されたオプションのデフォルト値を問い合わせたり、設定したりします。

kw のそれぞれのキーはオプション名で値はそのオプションの値の文字列です。

例えば、全てのデフォルトのボタンをパディングのある平らな見た目にし、背景の色を変更するには以下のようにします:

from tkinter import ttk
import tkinter

root = tkinter.Tk()

ttk.Style().configure("TButton", padding=6, relief="flat",
   background="#ccc")

btn = ttk.Button(text="Sample")
btn.pack()

root.mainloop()
map(style, query_opt=None, **kw)
style の指定されたオプションの動的な値を問い合わせたり、設定したりします。

kw のそれぞれのキーはオプション名で、値はタプルやリストや何か他のお好みのものでグループ化された状態仕様 (statespec) を要素とするリストやタプルです。状態仕様は 1 つもしくは複数の状態と値の組み合わせです。

以下のように、例を示す方がわかりやすいでしょう:

import tkinter
from tkinter import ttk

root = tkinter.Tk()

style = ttk.Style()
style.map("C.TButton",
    foreground=[('pressed', 'red'), ('active', 'blue')],
    background=[('pressed', '!disabled', 'black'), ('active', 'white')]
    )

colored_btn = ttk.Button(text="Test", style="C.TButton").pack()

root.mainloop()
あるオプションに対する状態と値の組 (states, value) の並び順はスタイルに影響を与えることに注意してください。例えば、foreground オプションの順序を [('active', 'blue'), ('pressed', 'red')] に変更した場合、ウィジェットがアクティブもしくは押された状態のとき前面が青くなります。

lookup(style, option, state=None, default=None)
style の指定された option の値を返します。

state を指定する場合は、1 つ以上の状態名の並びである必要があります。 default 引数が指定されていた場合は、オプション指定が見付からなかったときに代わりに返される値として使われます。

デフォルトでボタンがどのフォントを使うかを調べるには、以下のように実行します:

from tkinter import ttk

print(ttk.Style().lookup("TButton", "font"))
layout(style, layoutspec=None)
与えられた style でのウィジェットのレイアウトを定義します。 layoutspec が省略されていた場合は、与えられたスタイルのレイアウト仕様を返します。

layoutspec を指定する場合は、リストもしくは (文字列を除いた) 何か他のシーケンス型である必要があります。それぞれの要素はタプルで、レイアウト名を 1 番目の要素とし、2 番目の要素は Layouts で説明されているフォーマットである必要があります。

フォーマットを理解するために以下の例を見てください (何かを使い易くするための例ではありません):

from tkinter import ttk
import tkinter

root = tkinter.Tk()

style = ttk.Style()
style.layout("TMenubutton", [
   ("Menubutton.background", None),
   ("Menubutton.button", {"children":
       [("Menubutton.focus", {"children":
           [("Menubutton.padding", {"children":
               [("Menubutton.label", {"side": "left", "expand": 1})]
           })]
       })]
   }),
])

mbtn = ttk.Menubutton(text='Text')
mbtn.pack()
root.mainloop()
element_create(elementname, etype, *args, **kw)
与えられた etype ("image", "from", "vsapi" のいずれか) の現在のテーマに新しい要素を作成します。最後の "vsapi" は Windows XP と Vista の Tk 8.6a のみで使用可能でここでは説明しません。

"image" が使われた場合、 args はデフォルトの画像名の後ろに状態仕様と値のペア (これが画像仕様です) を並べたものである必要があります。 kw には以下のオプションが指定できます:

border=padding
padding は 4 個以下の整数のリストで、それぞれ左、上、右、下の縁の幅を指定します。

height=height
要素の最小の高さを指定します。0 より小さい場合は、画像の高さをデフォルトとして使用します。

padding=padding
要素の内部のパディングを指定します。指定されない場合は、 border の値がデフォルトとして使われます。

sticky=spec
1 つ外側の枠に対し画像をどう配置するかを指定します。 spec は "n", "s", "w", "e" の文字を 0 個以上含みます。

width=width
要素の最小の幅を指定します。0 より小さい場合は、画像の幅をデフォルトとして使用します。

etype の値として "from" が使われた場合は、 element_create() が現在の要素を複製します。 args は要素の複製元のテーマの名前と、オプションで複製する要素を含んでいる必要があります。複製元の要素が指定されていなかった場合、空要素が使用され、 kw は破棄されます。

element_names()
現在のテーマに定義されている要素のリストを返します。

element_options(elementname)
elementname のオプションのリストを返します。

theme_create(themename, parent=None, settings=None)
新しいテーマを作成します。

themename が既に存在していた場合はエラーになります。 parent が指定されていた場合は、新しいテーマは親テーマからスタイルや要素やレイアウトを継承します。 settings が指定された場合は、 theme_settings() で使われるのと同じ形式である必要があります。

theme_settings(themename, settings)
一時的に現在のテーマを themename に設定し、指定された settings を適用した後、元のテーマを復元します。

settings のそれぞれのキーはスタイル名で値はさらに 'configure', 'map', 'layout', 'element create' をキーとして持ち、その値はそれぞれ Style.configure(), Style.map(), Style.layout(), Style.element_create() メソッドで指定するのと同じ形式である必要があります。

例として、コンボボックスの default テーマを少し変更してみましょう

from tkinter import ttk
import tkinter

root = tkinter.Tk()

style = ttk.Style()
style.theme_settings("default", {
   "TCombobox": {
       "configure": {"padding": 5},
       "map": {
           "background": [("active", "green2"),
                          ("!disabled", "green4")],
           "fieldbackground": [("!disabled", "green3")],
           "foreground": [("focus", "OliveDrab1"),
                          ("!disabled", "OliveDrab2")]
       }
   }
})

combo = ttk.Combobox().pack()

root.mainloop()
theme_names()
全ての既存のテーマのリストを返します。

theme_use(themename=None)
themename が与えられなかった場合は、現在使用中のテーマ名を返します。そうでない場合は、現在のテーマを themename に設定し、全てのウィジェットを再描画し、 <<ThemeChanged>> イベントを発生させます。

レイアウト
レイアウトはオプションを取らない場合はただの None にできますし、そうでない場合は要素をどう配置するかを指定するオプションの辞書になります。 レイアウト機構は単純化したジオメトリマネージャを使っています: 最初に空間が与えられ、それぞれの要素に分割された空間が配分されます。 設定できるオプションと値は次の通りです:

side: 辺の名前
要素を空間のどちら側に配置するかを指定します; top, right, bottom, left のどれか 1 つです。省略された場合は、要素は空間全体を占めます。

sticky: n, s, w, e から 0 個以上
配分された空間の内部に要素をどう配置するかを指定します。

unit: 0 か 1
1 に設定されると、 Widget.identify() などには要素とその子で単一の要素として扱われます。これは、グリップのついたスクロールバーサムのようなものに使われます。

children: [内部レイアウト... ]
要素の内部に配置する要素のリストを指定します。リストのそれぞれの要素はタプル (もしくは他のシーケンス型) で、それの 1 番目の要素はレイアウト名でそれ以降は Layout です。

tkinter.tix --- Tkの拡張ウィジェット¶
ソースコード: Lib/tkinter/tix.py

バージョン 3.6 で非推奨: この Tk 拡張は保守されておらず、新しいコードでは使うべきではありません。 その代わりに tkinter.ttk を使ってください。

tkinter.tix (Tk Interface Extension) モジュールは豊富な追加ウィジェットを提供します。標準 Tk ライブラリには多くの有用なウィジェットがありますが、決して完全ではありません。 tkinter.tix ライブラリは、HList 、 ComboBox 、 Control (別名SpinBox) および各種のスクロール可能なウィジェットなど、標準 Tk にはないが、一般的に必要とされるウィジェットの大部分を提供します。 tkinter.tix には、class:NoteBook 、 FileEntry 、 PanedWindow など、一般的に幅広い用途に役に立つたくさんのウィジェットも含まれています。それらは40以上あります。

これら多くの新しいウィジェットと使うと、より便利でより直感的なユーザインタフェースを作成し、新しい相互作用テクニックをアプリケーションに導入することができます。アプリケーションとユーザに特有の要求に合うように、最も適切なアプリケーションウィジェットを選んでアプリケーションを設計できます。

参考
Tix Homepage
Tix のホームページ。ここには追加ドキュメントとダウンロードへのリンクがあります。

Tix Man Pages
manページと参考資料のオンライン版。

Tix Programming Guide
プログラマ用参考資料のオンライン版。

Tix Development Applications
Tix と Tkinter プログラムの開発のための Tix アプリケーション。 Tideアプリケーションは Tk または Tkinter に基づいて動作します。また、リモートで Tix/Tk/Tkinter アプリケーションを変更やデバッグするためのインスペクタ TixInspect が含まれます。

Tixを使う
class tkinter.tix.Tk(screenName=None, baseName=None, className='Tix')
主にアプリケーションのメインウィンドウを表すTixのトップレベルウィジェット。Tcl インタープリタが関連付けられます。

tkinter.tix モジュールのクラスは tkinter モジュールのクラスをサブクラス化します。前者は後者をインポートするので、モジュールを一つインポートするだけで tkinter.tix を Tkinter と一緒に使うことができます。一般的に、 tkinter.tix をインポートし、トップレベルでの tkinter.Tk への呼び出しは tix.Tk に置き換えるだけで済みます。次に例を示します:

from tkinter import tix
from tkinter.constants import *
root = tix.Tk()
tkinter.tix を使うためには、通常 Tk ウィジェットのインストールと平行して、Tix ウィジェットをインストールしなければなりません。インストールをテストするために、次のことを試してください:

from tkinter import tix
root = tix.Tk()
root.tk.eval('package require Tix')
Tixウィジェット
Tix は40個以上のウィジェットクラスを tkinter のレパートリーに導入します。

基本ウィジェット
class tkinter.tix.Balloon
ヘルプを提示するためにウィジェット上にポップアップする Balloon。ユーザがカーソルをBalloonウィジェットが束縛されているウィジェット内部へ移動させたとき、説明のメッセージが付いた小さなポップアップウィンドウがスクリーン上に表示されます。

class tkinter.tix.ButtonBox
ButtonBox ウィジェットは、Ok Cancel のためだけに普通は使われるようなボタンボックスを作成します。

class tkinter.tix.ComboBox
ComboBox ウィジェットはMS Windowsのコンボボックスコントロールに似ています。ユーザはエントリ・サブウィジェットでタイプするか、リストボックス・サブウィジェットから選択するかのどちらかで選択肢を選びます。

class tkinter.tix.Control
Control ウィジェットは SpinBox ウィジェットとしても知られています。ユーザは二つの矢印ボタンを押すか、またはエントリに直接値を入力して値を調整します。新しい値をユーザが定義した上限と下限に対してチェックします。

class tkinter.tix.LabelEntry
LabelEntry ウィジェットはエントリウィジェットとラベルを一つのメガウィジェットにまとめたものです。"記入形式"型のインタフェースの作成を簡単に行うために使うことができます。

class tkinter.tix.LabelFrame
LabelFrame ウィジェットはフレームウィジェットとラベルを一つのメガウィジェットにまとめたものです。LabelFrameウィジェット内部にウィジェットを作成するためには、 frame サブウィジェットに対して新しいウィジェットを作成し、それらを frame サブウィジェット内部で取り扱います。

class tkinter.tix.Meter
Meter ウィジェットは実行に時間のかかるバックグラウンド・ジョブの進み具合を表示するために使用できます。

class tkinter.tix.OptionMenu
OptionMenu はオプションのメニューボタンを作成します。

class tkinter.tix.PopupMenu
PopupMenu ウィジェットは tk_popup コマンドの代替品として使用できます。 Tix PopupMenu ウィジェットの利点は、操作に必要なアプリケーション・コードが少ないことです。

class tkinter.tix.Select
Select ウィジェットはボタン・サブウィジェットのコンテナです。ユーザに対する選択オプションのラジオボックスまたはチェックボックス形式を提供するために利用することができます。

class tkinter.tix.StdButtonBox
StdButtonBox ウィジェットは、Motif に似たダイアログボックスのための標準的なボタンのグループです。

ファイルセレクタ
class tkinter.tix.DirList
DirList ウィジェットは、ディレクトリのリストビュー (上の階層のディレクトリとサブディレクトリ) を表示します。ユーザはリスト内に表示されたディレクトリの一つを選択したり、他のディレクトリへ変更したりできます。

class tkinter.tix.DirTree
DirTree ウィジェットはディレクトリのツリービュー (上の階層のディレクトリとそのサブディレクトリ) を表示します。ユーザはリスト内に表示されたディレクトリの一つを選択したり、他のディレクトリへ変更したりできます。

class tkinter.tix.DirSelectDialog
DirSelectDialog ウィジェットは、ダイアログウィンドウにファイルシステム内のディレクトリを提示します。ユーザはこのダイアログウィンドウを使用して、ファイルシステム内を移動して目的のディレクトリを選択することができます。

class tkinter.tix.DirSelectBox
DirSelectBox は標準 Motif(TM) ディレクトリ選択ボックスに似ています。ユーザがディレクトリを選択するために一般的に使われます。DirSelectBox は主に最近 ComboBox ウィジェットに選択されたディレクトリを保存し、すばやく再選択できるようにします。

class tkinter.tix.ExFileSelectBox
ExFileSelectBox ウィジェットは、たいてい tixExFileSelectDialog ウィジェット内に組み込まれます。ユーザがファイルを選択するのに便利なメソッドを提供します。 ExFileSelectBox ウィジェットのスタイルは、MS Windows 3.1 の標準ファイルダイアログにとてもよく似ています。

class tkinter.tix.FileSelectBox
FileSelectBox は標準的な Motif(TM) ファイル選択ボックスに似ています。通常、ユーザがファイルを選択するために使われます。FileSelectBox は、直近に ComboBox ウィジェットに選択されたファイルを保存し、素早く再選択できるようにします。

class tkinter.tix.FileEntry
FileEntry ウィジェットは、ファイル名を入力するために使うことができます。ユーザはファイル名を手入力できます。その代わりに、エントリの横に並んでいるボタンウィジェットを押すと表示されるファイル選択ダイアログを使用することもできます。

階層的リストボックス
class tkinter.tix.HList
HList ウィジェットは階層構造をもつどんなデータ(例えば、ファイルシステムディレクトリツリー)でも表示するために使用できます。リストエントリは字下げされ、階層のそれぞれの場所に応じて分岐線で接続されます。

class tkinter.tix.CheckList
CheckList ウィジェットは、ユーザが選ぶ項目のリストを表示します。CheckList は Tk のチェックリストやラジオボタンより多くの項目を扱うことができることを除いて、チェックボタンあるいはラジオボタンウィジェットと同じように動作します。

class tkinter.tix.Tree
Tree ウィジェットは階層的なデータをツリー形式で表示するために使うことができます。ユーザはツリーの一部を開いたり閉じたりすることによって、ツリーの見えを調整できます。

表的リストボックス
class tkinter.tix.TList
TList ウィジェットは、表形式でデータを表示するために使うことができます。 TList ウィジェットのリスト・エントリは、Tkのリストボックス・ウィジェットのエントリに似ています。主な差は、(1) TList ウィジェットはリスト・エントリを二次元形式で表示でき、(2) リスト・エントリに対して複数の色やフォントだけでなく画像も使うことができるということです。

管理ウィジェット
class tkinter.tix.PanedWindow
PanedWindow ウィジェットは、ユーザがいくつかのペインのサイズを対話的に操作できるようにします。ペインは垂直または水平のどちらかに配置されます。ユーザは二つのペインの間でリサイズ・ハンドルをドラッグしてペインの大きさを変更します。

class tkinter.tix.ListNoteBook
ListNoteBook ウィジェットは、 TixNoteBook ウィジェットにとてもよく似ています。ノートのメタファを使って限られた空間をに多くのウィンドウを表示するために使われます。ノートはたくさんのページ(ウィンドウ)に分けられています。ある時には、これらのページの一つしか表示できません。ユーザは hlist サブウィジェットの中の望みのページの名前を選択することによって、これらのページを切り替えることができます。

class tkinter.tix.NoteBook
NoteBook ウィジェットは、ノートのメタファを多くのウィンドウを表示することができます。ノートはたくさんのページに分けられています。ある時には、これらのページの一つしか表示できません。ユーザは NoteBook ウィジェットの一番上にある目に見える"タブ"を選択することで、これらのページを切り替えることができます。

画像タイプ
tkinter.tix モジュールは次のものを追加します:

全ての tkinter.tix と tkinter ウィジェットに対して XPM ファイルからカラー画像を作成する pixmap 機能。

Compound 画像タイプは複数の水平方向の線から構成される画像を作成するために使うことができます。それぞれの線は左から右に並べられた一連のアイテム(テキスト、ビットマップ、画像あるいは空白)から作られます。例えば、Tk のButton ウィジェットの中にビットマップとテキスト文字列を同時に表示するためにcompound画像は使うことができます。

その他のウィジェット
class tkinter.tix.InputOnly
InputOnly ウィジェットは、ユーザから入力を受け付けます。それは、bind コマンドを使って行われます(Unixのみ)。

ジオメトリマネジャを作る
加えて、 tkinter.tix は次のものを提供することで tkinter を補強します:

class tkinter.tix.Form
すべての Tk ウィジェットに対する接続ルールに基づいた Form ジオメトリマネジャ。

Tixコマンド
class tkinter.tix.tixCommand
tixコマンド は Tix の内部状態と Tix アプリケーション・コンテキストのいろいろな要素へのアクセスを提供します。これらのメソッドによって操作される情報の大部分は、特定のウィンドウというよりむしろアプリケーション全体かスクリーンあるいはディスプレイに関するものです。

現在の設定を見るための一般的な方法は:

from tkinter import tix
root = tix.Tk()
print(root.tix_configure())
tixCommand.tix_configure(cnf=None, **kw)
Tix アプリケーション・コンテキストの設定オプションを問い合わせたり、変更したりします。オプションが指定されなければ、利用可能なオプションすべてのディクショナリを返します。オプションが値なしで指定された場合は、メソッドは指定されたオプションを説明するリストを返します(このリストはオプションが指定されていない場合に返される値に含まれている、指定されたオプションに対応するサブリストと同一です)。一つ以上のオプション-値のペアが指定された場合は、メソッドは与えられたオプションが与えられた値を持つように変更します。この場合は、メソッドは空文字列を返します。オプションは設定オプションのどれでも構いません。

tixCommand.tix_cget(option)
option によって与えられた設定オプションの現在の値を返します。オプションは設定オプションのどれでも構いません。

tixCommand.tix_getbitmap(name)
ビットマップディレクトリの一つの中の name.xpm または name と言う名前のビットマップファイルの場所を見つけ出します (tix_addbitmapdir() メソッドを参照してください)。 tix_getbitmap() を使うことで、アプリケーションにビットマップファイルのパス名をハードコーディングすることを避けることができます。成功すれば、文字 @ を先頭に付けたビットマップファイルの完全なパス名を返します。戻り値をTkとTixウィジェットの bitmap オプションを設定するために使うことができます。

tixCommand.tix_addbitmapdir(directory)
Tix は tix_getimage() と tix_getbitmap() メソッドが画像ファイルを検索する検索先ディレクトリのリストを保持しています。標準ビットマップディレクトリは $TIX_LIBRARY/bitmaps です。 tix_addbitmapdir() メソッドは directory をこのリストに追加します。そのメソッドを使うことによって、tix_getimage() または tix_getbitmap() メソッドを使ってアプリケーションの画像ファイルも見つけることができます。

tixCommand.tix_filedialog([dlgclass])
このアプリケーションからの異なる呼び出しの間で共有される可能性があるファイル選択ダイアログを返します。最初に呼ばれた時に、このメソッドはファイル選択ダイアログ・ウィジェットを作成します。このダイアログはその後のすべての tix_filedialog() への呼び出しで返されます。オプションの dlgclass パラメータは、要求されているファイル選択ダイアログ・ウィジェットの型を指定するために文字列として渡されます。指定可能なオプションは tix 、 FileSelectDialog あるいは tixExFileSelectDialog です。

tixCommand.tix_getimage(self, name)
ビットマップディレクトリの一つの中の name.xpm 、 name.xbm または name.ppm という名前の画像ファイルの場所を見つけ出します(上の tix_addbitmapdir() メソッドを参照してください)。同じ名前(だが異なる拡張子)のファイルが一つ以上ある場合は、画像のタイプがXディスプレイの深さに応じて選択されます。xbm画像はモノクロディスプレイの場合に選択され、カラー画像はカラーディスプレイの場合に選択されます。 tix_getimage() を使うことによって、アプリケーションに画像ファイルのパス名をハードコーディングすることを避けられます。成功すれば、このメソッドは新たに作成した画像の名前を返し、Tk と Tix ウィジェットの image オプションを設定するためにそれを使うことができます。

tixCommand.tix_option_get(name)
Tixのスキーム・メカニズムによって保持されているオプションを得ます。

tixCommand.tix_resetoptions(newScheme, newFontSet[, newScmPrio])
Tix アプリケーションのスキームとフォントセットをそれぞれ newScheme と newFontSet に再設定します。この設定は、この呼び出し後に作成されたウィジェットだけに影響します。そのため、Tix アプリケーションのどのウィジェットを作成する前にも resetoptions メソッドを呼び出すのが良い方法です。

オプション・パラメータ newScmPrio を、Tix スキームによって設定される Tk オプションの優先度レベルを再設定するために与えることができます。

Tk が X オプションデータベースを扱う方法のため、Tix がインポートされ初期化された後に、カラースキームとフォントセットを tix_config() メソッドを使って再設定することはできません。したがって、 tix_resetoptions() メソッドを代わりに使わなければならないのです。
