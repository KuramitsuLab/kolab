os --- 雑多なオペレーティングシステムインタフェース
ソースコード: Lib/os.py

このモジュールは、 OS 依存の機能を利用するポータブルな方法を提供します。単純なファイルの読み書きについては、 open() を参照してください。パス操作については、 os.path モジュールを参照してください。コマンドラインに与えられたすべてのファイルから行を読み込んでいくには、 fileinput モジュールを参照してください。一時ファイルや一時ディレクトリの作成については、 tempfile モジュールを参照してください。高水準のファイルとディレクトリの操作については、 shutil モジュールを参照してください。

利用可能性に関する注意 :

Python の、すべての OS 依存モジュールの設計方針は、可能な限り同一のインタフェースで同一の機能を利用できるようにする、というものです。例えば、 os.stat(path) は path に関する stat 情報を、 (POSIX を元にした ) 同じフォーマットで返します。

特定のオペレーティングシステム固有の拡張も os を介して利用することができますが、これらの利用はもちろん、可搬性を脅かします。

パスやファイル名を受け付けるすべての関数は、バイト列型および文字列型両方のオブジェクトを受け付け、パスやファイル名を返す時は、同じ型のオブジェクトを返します。

VxWorks では、os.fork, os.execv および os.spawn*p* はサポートされていません。

注釈 このモジュール内のすべての関数は、間違った、あるいはアクセス出来ないファイル名やファイルパス、その他型が合っていても OS が受理しない引数に対して、 OSError (またはそのサブクラス)を送出します。
exception os.error
組み込みの OSError 例外に対するエイリアスです。

os.name
import されているオペレーティングシステムに依存するモジュールの名前です。現在次の名前が登録されています: 'posix', 'nt', 'java'。

参考 sys.platform はより細かな粒度を持っています。 os.uname() はシステム依存のバージョン情報を提供します。
platform モジュールはシステムの詳細な識別情報をチェックする機能を提供しています。

ファイル名、コマンドライン引数、および環境変数
Python では、ファイル名、コマンドライン引数、および環境変数を表すのに文字列型を使用します。一部のシステムでは、これらをオペレーティングシステムに渡す前に、文字列からバイト列へ、またはその逆のデコードが必要です。Python はこの変換を行うためにファイルシステムのエンコーディングを使用します (sys.getfilesystemencoding() 参照)。

バージョン 3.1 で変更: 一部のシステムでは、ファイルシステムのエンコーディングを使用して変換すると失敗する場合があります。この場合、Python は surrogateescape エンコーディングエラーハンドラー を使用します。これは、デコード時にデコードできないバイト列は Unicode 文字 U+DCxx に置き換えられ、それらはエンコード時に再び元のバイト列に変換されることを意味します。

ファイルシステムのエンコーディングでは、すべてが 128 バイト以下に正常にデコードされることが保証されなくてはなりません。ファイルシステムのエンコーディングでこれが保証されなかった場合は、API 関数が UnicodeError を送出します。

プロセスのパラメーター
これらの関数とデータアイテムは、現在のプロセスおよびユーザーに対する情報提供および操作のための機能を提供しています。

os.ctermid()
プロセスの制御端末に対応するファイル名を返します。

利用可能な環境: Unix。

os.environ
文字列の環境を表す マップ型 オブジェクトです。例えば、 environ['HOME'] は (一部のプラットフォームでは) ホームディレクトリのパス名であり、 C における getenv("HOME") と等価です。

このマップ型の内容は、 os モジュールの最初の import の時点、通常は Python の起動時に site.py が処理される中で取り込まれます。それ以後に変更された環境変数は os.environ を直接変更しない限り os.environ には反映されません。

このマップ型オブジェクトは環境変数に対する変更に使うこともできます。 putenv() はマップ型オブジェクトが修正される時に、自動的に呼ばれることになります。

Unix では、キーと値に sys.getfilesystemencoding()、エラーハンドラーに 'surrogateescape' を使用します。異なるエンコーディングを使用したい場合は environb を使用します。

注釈 putenv() を直接呼び出しても os.environ の内容は変わらないので、 os.environ を直接変更する方が良いです。
注釈 FreeBSD と Mac OS X を含む一部のプラットフォームでは、 environ の値を変更するとメモリリークの原因になる場合があります。システムの putenv() に関するドキュメントを参照してください。
このマップ型オブジェクトからアイテムを削除することで環境変数を消すことができます。 unsetenv() は os.environ からアイテムが取り除かれた時に自動的に呼ばれます。 pop() または clear() が呼ばれた時も同様です。

バージョン 3.9 で変更: 更新され PEP 584 の合成演算子 (|) と更新演算子 (|=) がサポートされました。

os.environb
environ のバイト列版です。環境変数をバイト文字列で表す マップ型 オブジェクトです。environ と environb は同期されます。(environb を変更すると environ が更新され、逆の場合も同様に更新されます)。

environb は supports_bytes_environ が True の場合のみ利用可能です。

バージョン 3.2 で追加.

バージョン 3.9 で変更: 更新され PEP 584 の合成演算子 (|) と更新演算子 (|=) がサポートされました。

os.chdir(path)
os.fchdir(fd)
os.getcwd()
これらの関数は、 ファイルとディレクトリ 節で説明されています。

os.fsencode(filename)
path-like な filename をファイルシステムのエンコーディングにエンコードします。エラーハンドラーに 'surrogateescape' (Windows の場合は 'strict') が指定されます; 未変更の bytes オブジェクトを返します。

fsdecode() はこの逆変換を行う関数です。

バージョン 3.2 で追加.

バージョン 3.6 で変更: os.PathLike インタフェースを実装したオブジェクトを受け入れるようになりました。

os.fsdecode(filename)
ファイルシステムのエンコーディングから path-like な filename にデコードします。エラーハンドラーに 'surrogateescape' (Windows の場合は 'strict') が指定されます; 未変更の bytes オブジェクトを返します。

fsencode() はこの逆変換を行う関数です。

バージョン 3.2 で追加.

バージョン 3.6 で変更: os.PathLike インタフェースを実装したオブジェクトを受け入れるようになりました。

os.fspath(path)
path のファイルシステム表現を返します。

もし str か bytes: のオブジェクトが渡された場合は、変更せずにそのまま返します。さもなければ、 __fspath__() が呼び出され、その戻り値が str か bytes のオブジェクトであれば、その値を返します。他のすべてのケースでは TypeError が送出されます。

バージョン 3.6 で追加.

class os.PathLike
ファイルシステムパスを表すオブジェクト(例: pathlib.PurePath) 向けの abstract base class です。

バージョン 3.6 で追加.

abstractmethod __fspath__()
このオブジェクトが表現するファイルシステムパスを返します。

このメソッドは str か bytes のオブジェクトのみを返す必要があります(str が好まれます)。

os.getenv(key, default=None)
環境変数 key が存在すればその値を返し、存在しなければ default を返します。key、default、および返り値は文字列です。

Unix では、キーと値は sys.getfilesystemencoding()、エラーハンドラー 'surrogateescape' でデコードされます。異なるエンコーディングを使用したい場合は os.getenvb() を使用します。

利用できる環境: 主なUnix互換環境、 Windows。

os.getenvb(key, default=None)
環境変数 key が存在すればその値を返し、存在しなければ default を返します。key、default、および返り値はバイト列型です。

getenvb() は supports_bytes_environ が ``True``の場合のみ利用可能です。

利用できる環境: 主なUnix互換環境。

バージョン 3.2 で追加.

os.get_exec_path(env=None)
プロセスを起動する時に名前付き実行ファイルを検索するディレクトリのリストを返します。 env が指定されると、それを環境変数の辞書とみなし、その辞書からキー PATH の値を探します。 デフォルトでは env は None であり、environ が使用されます。

バージョン 3.2 で追加.

os.getegid()
現在のプロセスの実効グループ id を返します。この id は現在のプロセスで実行されているファイルの "set id" ビットに対応します。

利用可能な環境: Unix。

os.geteuid()
現在のプロセスの実効ユーザー id を返します。

利用可能な環境: Unix。

os.getgid()
現在のプロセスの実グループ id を返します。

利用可能な環境: Unix。

os.getgrouplist(user, group)
user が所属するグループ id のリストを返します。group がリストにない場合、それを追加します。通常、group にはユーザー user のパスワードレコードに書かれているグループ ID を指定します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.getgroups()
現在のプロセスに関連付けられた従属グループ id のリストを返します。

利用可能な環境: Unix。

注釈 Mac OS X では getgroups() の挙動は他の Unix プラットフォームとはいくぶん異なります。 Python のインタープリタが 10.5 以前の Deployment Target でビルドされている場合、 getgroups() は現在のユーザープロセスに関連付けられている実効グループ id を返します。このリストはシステムで定義されたエントリ数 ( 通常は 16) に制限され、適切な特権があれば setgroups() の呼び出しによって変更することができます。 10.5 より新しい Deployment Target でビルドされている場合、 getgroups() はプロセスの実効ユーザー id に関連付けられたユーザーの現在のグループアクセスリストを返します。このグループアクセスリストは、プロセスのライフタイムで変更される可能性があり、 setgroups() の呼び出しの影響を受けず、長さ 16 の制限を受けません。 Deployment Target の値 MACOSX_DEPLOYMENT_TARGET は、 sysconfig.get_config_var() で取得することができます。
os.getlogin()
プロセスの制御端末にログインしているユーザー名を返します。ほとんどの場合、getpass.getuser() を使う方が便利です。なぜなら、getpass.getuser() は、ユーザーを見つけるために、環境変数 LOGNAME や USERNAME を調べ、さらには pwd.getpwuid(os.getuid())[0] まで調べに行くからです。

Availability: Unix, Windows。

os.getpgid(pid)
プロセス id pid のプロセスのプロセスグループ id を返します。 pid が 0 の場合、現在のプロセスのプロセスグループ id を返します。

利用可能な環境: Unix。

os.getpgrp()
現在のプロセスグループの id を返します。

利用可能な環境: Unix。

os.getpid()
現在のプロセス id を返します。

os.getppid()
親プロセスのプロセス id を返します。親プロセスが終了していた場合、Unix では init プロセスの id (1) が返され、Windows では親のプロセス id だったもの (別のプロセスで再利用されているかもしれない) がそのまま返されます。

Availability: Unix, Windows。

バージョン 3.2 で変更: Windows サポートが追加されました。

os.getpriority(which, who)
プログラムのスケジューリング優先度を取得します。which の値は PRIO_PROCESS、PRIO_PGRP、あるいは PRIO_USER のいずれか一つで、who の値は which に応じて解釈されます (PRIO_PROCESS であればプロセス識別子、PRIO_PGRP であればプロセスグループ識別子、そして PRIO_USER であればユーザー ID)。who の値がゼロの場合、呼び出したプロセス、呼び出したプロセスのプロセスグループ、および呼び出したプロセスの実ユーザー id を (それぞれ) 意味します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.PRIO_PROCESS
os.PRIO_PGRP
os.PRIO_USER
getpriority() と setpriority() 用のパラメータです。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.getresuid()
現在のプロセスの実ユーザー id 、実効ユーザー id 、および保存ユーザー id を示す、 (ruid, euid, suid) のタプルを返します。

利用可能な環境: Unix。

バージョン 3.2 で追加.

os.getresgid()
現在のプロセスの実グループ id 、実効グループ id 、および保存グループ id を示す、 (rgid, egid, sgid) のタプルを返します。

利用可能な環境: Unix。

バージョン 3.2 で追加.

os.getuid()
現在のプロセスの実ユーザー id を返します。

利用可能な環境: Unix。

os.initgroups(username, gid)
システムの initgroups() を呼び出し、指定された username がメンバーである全グループと gid で指定されたグループでグループアクセスリストを初期化します。

利用可能な環境: Unix。

バージョン 3.2 で追加.

os.putenv(key, value)
key という名前の環境変数に文字列 value を設定します。このような環境変数の変更は、os.system()、popen()、または fork() と execv() で起動されたサブプロセスに影響を与えます。

os.environ のアイテムに対する代入を行うと、自動的に putenv() の対応する呼び出しに変換されます。直接 putenv() を呼び出した場合 os.environ は更新されないため、実際には os.environ のアイテムに代入する方が望ましい操作です。

注釈 FreeBSD と Mac OS X を含む一部のプラットフォームでは、 environ の値を変更するとメモリリークの原因になる場合があります。システムの putenv() に関するドキュメントを参照してください。
引数 key, value を指定して 監査イベント os.putenv を送出します。

バージョン 3.9 で変更: 常に利用出来るようになりました。

os.setegid(egid)
現在のプロセスに実効グループ id をセットします。

利用可能な環境: Unix。

os.seteuid(euid)
現在のプロセスに実効ユーザー id をセットします。

利用可能な環境: Unix。

os.setgid(gid)
現在のプロセスにグループ id をセットします。

利用可能な環境: Unix。

os.setgroups(groups)
現在のグループに関連付けられた従属グループ id のリストを groups に設定します。 groups はシーケンス型でなくてはならず、各要素はグループを特定する整数でなくてはなりません。通常、この操作はスーパユーザーしか利用できません。

利用可能な環境: Unix。

注釈 Mac OS X では、 groups の長さはシステムで定義された実効グループ id の最大数 ( 通常は 16) を超えない場合があります。 setgroups() 呼び出しで設定されたものと同じグループリストが返されないケースについては、 getgroups() のドキュメントを参照してください。
os.setpgrp()
システムコール setpgrp() か setpgrp(0, 0) のどちらか(実装されているもの)を呼び出します。機能については UNIX マニュアルを参照して下さい。

利用可能な環境: Unix。

os.setpgid(pid, pgrp)
システムコール setpgid() を呼び出してプロセス id pid のプロセスのプロセスグループ id を pgrp に設定します。この動作に関しては Unix のマニュアルを参照してください。

利用可能な環境: Unix。

os.setpriority(which, who, priority)
プログラムのスケジューリング優先度を設定します。which は PRIO_PROCESS、PRIO_PGRP、あるいは PRIO_USER のいずれか一つで、who の値は which に応じて解釈されます (PRIO_PROCESS であればプロセス識別子、PRIO_PGRP であればプロセスグループ識別子、そして PRIO_USER であればユーザー ID)。who の値がゼロの場合、呼び出したプロセス、呼び出したプロセスのプロセスグループ、および呼び出したプロセスの実ユーザー id を (それぞれ) 意味します。priority は -20 から 19 の整数値で、デフォルトの優先度は 0 です。小さい数値ほど優先されるスケジューリングとなります。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.setregid(rgid, egid)
現在のプロセスの実グループ id および実効グループ id を設定します。

利用可能な環境: Unix。

os.setresgid(rgid, egid, sgid)
現在のプロセスの、実グループ id 、実効グループ id 、および保存グループ id を設定します。

利用可能な環境: Unix。

バージョン 3.2 で追加.

os.setresuid(ruid, euid, suid)
現在のプロセスの実ユーザー id 、実効ユーザー id 、および保存ユーザー id を設定します。

利用可能な環境: Unix。

バージョン 3.2 で追加.

os.setreuid(ruid, euid)
現在のプロセスの実ユーザー id および実効ユーザー id を設定します。

利用可能な環境: Unix。

os.getsid(pid)
getsid() システムコールを呼び出します。機能については Unix のマニュアルを参照してください。

利用可能な環境: Unix。

os.setsid()
setsid() システムコールを呼び出します。機能については Unix のマニュアルを参照してください。

利用可能な環境: Unix。

os.setuid(uid)
現在のプロセスのユーザー id を設定します。

利用可能な環境: Unix。

os.strerror(code)
エラーコード code に対応するエラーメッセージを返します。未知のエラーコードの対して strerror() が NULL を返すプラットフォームでは、 ValueError が送出されます。

os.supports_bytes_environ
環境のネイティブ OS タイプがバイト型の場合、 True です (例: Windows では、 False です)。

バージョン 3.2 で追加.

os.umask(mask)
現在の数値 umask を設定し、以前の umask 値を返します。

os.uname()
現在のオペレーティングシステムを識別する情報を返します。返り値は 5 個の属性を持つオブジェクトです:

sysname - OS の名前

nodename - (実装時に定義された) ネットワーク上でのマシン名

release - OS のリリース

version - OS のバージョン

machine - ハードウェア識別子

後方互換性のため、このオブジェクトはイテラブルでもあり、sysname、nodename、release、version、および machine の 5 個の要素をこの順序で持つタプルのように振る舞います。

一部のシステムでは、nodename はコンポーネントを読み込むために 8 文字または先頭の要素だけに切り詰められます; ホスト名を取得する方法としては、socket.gethostname() を使う方がよいでしょう。あるいは socket.gethostbyaddr(socket.gethostname()) でもかまいません。

利用できる環境: 最近のUnix互換環境。

バージョン 3.3 で変更: 返り値の型が、タプルから属性名のついたタプルライクオブジェクトに変更されました。

os.unsetenv(key)
key という名前の環境変数を unset (削除) します。このような環境変数の変更は、os.system()、popen()、または fork() と execv() で起動されたサブプロセスに影響を与えます。

os.environ のアイテムの削除を行うと、自動的に unsetenv() の対応する呼び出しに変換されます。直接 unsetenv() を呼び出した場合 os.environ は更新されないため、実際には os.environ のアイテムを削除する方が望ましい操作です。

引数 key を指定して 監査イベント os.unsetenv を送出します。

バージョン 3.9 で変更: 常に関数は利用出来るようになりました。

ファイルオブジェクトの生成
以下の関数は新しい ファイルオブジェクト を作成します。(ファイル記述子のオープンについては open() も参照してください)

os.fdopen(fd, *args, **kwargs)
ファイル記述子 fd に接続し、オープンしたファイルオブジェクトを返します。これは組み込み関数 open() の別名であり、同じ引数を受け取ります。唯一の違いは fdopen() の第一引数が常に整数でなければならないことです。

ファイル記述子の操作
これらの関数は、ファイル記述子を使って参照されている I/O ストリームを操作します。

ファイル記述子とは現在のプロセスで開かれたファイルに対応する小さな整数です。例えば、標準入力のファイル記述子は通常 0 で、標準出力は 1 、標準エラーは 2 です。プロセスから開かれたその他のファイルには 3 、 4 、 5 と割り振られていきます。「ファイル記述子」という名称は少し誤解を与えるものかもしれません。Unix プラットフォームでは、ソケットやパイプもファイル記述子によって参照されます。

fileno() メソッドを使用して、必要な場合に file object に関連付けられているファイル記述子を取得することができます。ファイル記述子を直接使用すると、ファイルオブジェクトのメソッドが使用されないため、データの内部バッファなどの性質は無視されることに注意してください。

os.close(fd)
ファイル記述子 fd をクローズします。

注釈 この関数は低水準の I/O 向けのもので、 os.open() や pipe() が返すファイル記述子に対して使用しなければなりません。 組み込み関数 open() や popen() 、 fdopen() が返す "ファイルオブジェクト" を閉じるには、オブジェクトの close() メソッドを使用してください。
os.closerange(fd_low, fd_high)
fd_low 以上 fd_high 未満のすべてのファイル記述子をエラーを無視してクローズします。以下のコードと等価です:

for fd in range(fd_low, fd_high):
    try:
        os.close(fd)
    except OSError:
        pass
os.copy_file_range(src, dst, count, offset_src=None, offset_dst=None)
ファイル記述子 src の offset_src から count バイトを、ファイル記述子 dst の offset_dst にコピーします。もし offset_src が None の場合は src は現在の位置から読まれます。 offset_dst についても同様です。src および dst のファイルは同じファイルシステム上になければなりません。違う場合には errno を errno.EXDEV として OSError が送出されます。

このコピーは、カーネルからユーザースペースにデータを転送した後カーネルに戻すという追加のコスト無しに完了します。 加えて、追加の最適化ができるファイルシステムもあります。 このコピーはファイルが両方ともバイナリファイルとして開かれたかのように行われます。

返り値はコピーされたバイトの量です。 この値は、要求した量より少なくなることもあります。

Availability: Linux kernel >= 4.5 または glibc >= 2.27。

バージョン 3.8 で追加.

os.device_encoding(fd)
fd に関連付けられたデバイスが端末 (ターミナル) に接続されている場合に、そのデバイスのエンコーディングを表す文字列を返します。端末に接続されていない場合、 None を返します。

os.dup(fd)
ファイル記述子 fd の複製を返します。新しいファイル記述子は 継承不可 です。

Windows では、標準ストリーム (0: 標準入力、1: 標準出力、2: 標準エラー出力) を複製する場合、新しいファイル記述子は 継承可能 です。

バージョン 3.4 で変更: 新しいファイル記述子が継承不可になりました。

os.dup2(fd, fd2, inheritable=True)
ファイル記述子 fd を fd2 に複製し、必要な場合には後者を先に閉じます。 fd2 が返ります。 新しいファイル記述子はデフォルトでは 継承可能 で、inheritable が False の場合は継承不可です。

バージョン 3.4 で変更: オプションの inheritable 引数が追加されました。

バージョン 3.7 で変更: 成功したときは fd2 が返ります。 以前は常に None が返っていました。

os.fchmod(fd, mode)
fd で指定されたファイルのモードを mode に変更します。mode に指定できる値については、chmod() のドキュメントを参照してください。Python 3.3 以降では os.chmod(fd, mode) と等価です。

引数 path, mode, dir_fd を指定して 監査イベント os.chmod を送出します。

利用可能な環境: Unix。

os.fchown(fd, uid, gid)
fd で指定されたファイルの所有者 id およびグループ id を数値 uid および gid に変更します。いずれかの id を変更せずにおくにはその値として -1 を指定します。chown() を参照してください。Python 3.3 以降では os.chown(fd, uid, gid) と等価です。

引数 path, uid, gid, dir_fd を指定して 監査イベント os.chown を送出します。

利用可能な環境: Unix。

os.fdatasync(fd)
ファイル記述子 fd を持つファイルのディスクへの書き込みを強制します。メタデータの更新は強制しません。

利用可能な環境: Unix。

注釈 この関数は MacOS では利用できません。
os.fpathconf(fd, name)
開いているファイルに関連するシステム設定情報を返します。 name は取得する設定名を指定します。これは、いくつかの標準 (POSIX.1 、 Unix 95 、 Unix 98 その他 ) で定義された定義済みのシステム値名の文字列である場合があります。プラットフォームによっては別の名前も定義されています。ホストオペレーティングシステムの関知する名前は pathconf_names 辞書で与えられています。このマップ型オブジェクトに含まれていない構成変数については、 name に整数を渡してもかまいません。

name が不明の文字列である場合、 ValueError を送出します。 name の特定の値がホストシステムでサポートされていない場合、 pathconf_names に含まれていたとしても、 errno.EINVAL をエラー番号として OSError を送出します。

Python 3.3 以降では os.pathconf(fd, name) と等価です。

利用可能な環境: Unix。

os.fstat(fd)
ファイル記述子 fd の状態を取得します。stat_result オブジェクトを返します。

Python 3.3 以降では os.stat(fd) と等価です。

参考 stat() 関数。
os.fstatvfs(fd)
statvfs() と同様に、ファイル記述子 fd に関連付けられたファイルが格納されているファイルシステムに関する情報を返します。Python 3.3 以降では os.statvfs(fd) と等価です。

利用可能な環境: Unix。

os.fsync(fd)
ファイル記述子 fd を持つファイルのディスクへの書き込みを強制します。 Unix では、ネイティブの fsync() 関数を、 Windows では _commit() 関数を呼び出します。

Python の ファイルオブジェクト f を使う場合、f の内部バッファを確実にディスクに書き込むために、まず f.flush() を、その後 os.fsync(f.fileno()) を実行してください。

Availability: Unix, Windows。

os.ftruncate(fd, length)
ファイル記述子 fd に対応するファイルを、サイズが最長で length バイトになるように切り詰めます。Python 3.3 以降では os.truncate(fd, length) と等価です。

引数 fd, length を指定して 監査イベント os.truncate を送出します。

Availability: Unix, Windows。

バージョン 3.5 で変更: Windows サポートを追加しました。

os.get_blocking(fd)
記述子のブロッキングモードを取得します。 O_NONBLOCK フラグが設定されている場合は False で、フラグがクリアされている場合は True です。

set_blocking() および socket.socket.setblocking() も参照してください。

利用可能な環境: Unix。

バージョン 3.5 で追加.

os.isatty(fd)
ファイル記述子 fd がオープンされていて、 tty (のような) デバイスに接続されている場合、 True を返します。そうでない場合は False を返します。

os.lockf(fd, cmd, len)
オープンされたファイル記述子に対して、POSIX ロックの適用、テスト、解除を行います。fd はオープンされたファイル記述子です。cmd には使用するコマンド (F_LOCK、F_TLOCK、F_ULOCK、あるいは F_TEST のいずれか一つ) を指定します。len にはロックするファイルのセクションを指定します。

引数 fd, cmd, len を指定して 監査イベント os.lockf を送出します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.F_LOCK
os.F_TLOCK
os.F_ULOCK
os.F_TEST
lockf() がとる動作を指定するフラグです。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.lseek(fd, pos, how)
ファイル記述子 fd の現在の位置を pos に設定します。 pos の意味は how で次のように修飾されます。ファイルの先頭からの相対位置には SEEK_SET か 0 を、現在の位置からの相対位置には SEEK_CUR か 1 を、ファイルの末尾からの相対位置には SEEK_END か 2 を設定します。戻り値は、新しいカーソル位置のファイルの先頭からのバイト数です。

os.SEEK_SET
os.SEEK_CUR
os.SEEK_END
lseek() 関数に渡すパラメーター。値は順に 0, 1, 2 です。

バージョン 3.3 で追加: 一部のオペレーティングシステムは os.SEEK_HOLE や os.SEEK_DATA など、追加の値をサポートすることがあります。

os.open(path, flags, mode=0o777, *, dir_fd=None)
ファイル path を開き、flag に従って様々なフラグを設定し、可能なら mode に従ってファイルモードを設定します。mode を計算する際、まず現在の umask 値でマスクされます。新たに開いたファイルのファイル記述子を返します。新しいファイル記述子は 継承不可 です。

フラグとファイルモードの値についての詳細は C ランタイムのドキュメントを参照してください; (O_RDONLY や O_WRONLY のような) フラグ定数は os モジュールでも定義されています。特に、Windows ではバイナリモードでファイルを開く時に O_BINARY を加える必要があります。

この関数は dir_fd パラメタで ディレクトリ記述子への相対パス をサポートしています。

引数 path, mode, flags を指定して 監査イベント open を送出します。

バージョン 3.4 で変更: 新しいファイル記述子が継承不可になりました。

注釈 この関数は低水準の I/O 向けのものです。 通常の利用では、組み込み関数 open() を使用してください。 open() は read() や write() (そしてさらに多くの) メソッドを持つ ファイルオブジェクト を返します。 ファイル記述子をファイルオブジェクトでラップするには fdopen() を使用してください。
バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.5 で変更: システムコールが中断されシグナルハンドラが例外を送出しなかった場合、この関数は InterruptedError 例外を送出する代わりにシステムコールを再試行するようになりました (論拠については PEP 475 を参照してください)。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

以下の定数は open() 関数の flags 引数に利用します。これらの定数は、ビット単位に OR 演算子 | で組み合わせることができます。一部、すべてのプラットフォームでは使用できない定数があります。利用可能かどうかや使い方については、Unix では open(2)、Windows では MSDN を参照してください。

os.O_RDONLY
os.O_WRONLY
os.O_RDWR
os.O_APPEND
os.O_CREAT
os.O_EXCL
os.O_TRUNC
上記の定数は Unix および Windows で利用可能です。

os.O_DSYNC
os.O_RSYNC
os.O_SYNC
os.O_NDELAY
os.O_NONBLOCK
os.O_NOCTTY
os.O_CLOEXEC
上記の定数は Unix でのみ利用可能です。

バージョン 3.3 で変更: 定数 O_CLOEXEC が追加されました。

os.O_BINARY
os.O_NOINHERIT
os.O_SHORT_LIVED
os.O_TEMPORARY
os.O_RANDOM
os.O_SEQUENTIAL
os.O_TEXT
上記の定数は Windows でのみ利用可能です。

os.O_ASYNC
os.O_DIRECT
os.O_DIRECTORY
os.O_NOFOLLOW
os.O_NOATIME
os.O_PATH
os.O_TMPFILE
os.O_SHLOCK
os.O_EXLOCK
上記の定数は拡張仕様であり、Cライブラリで定義されていない場合は利用できません。

バージョン 3.4 で変更: O_PATH を、それをサポートするシステムで追加しました。また、 O_TMPFILE を追加しました (Linux Kernel 3.11 以降でのみ利用可能です)。

os.openpty()
新しい擬似端末のペアを開きます。pty および tty を表すファイル記述子のペア (master, slave) を返します。新しいファイル記述子は 継承不可 です。(若干) 可搬性の高いアプローチには pty を使用してください。

利用できる環境: 一部の Unix 互換環境。

バージョン 3.4 で変更: 新しいファイル記述子が継承不可になりました。

os.pipe()
パイプを作成します。読み込み、書き込みに使うことの出来るファイル記述子のペア (r, w) を返します。新しいファイル記述子は 継承不可 です。

Availability: Unix, Windows。

バージョン 3.4 で変更: 新しいファイル記述子が継承不可になりました。

os.pipe2(flags)
flags を設定したパイプをアトミックに作成します。flags には値 O_NONBLOCK と O_CLOEXEC を一つ以上論理和指定できます。読み込み、書き込みに使うことの出来るファイル記述子のペア (r, w) を返します。

利用できる環境: 一部の Unix 互換環境。

バージョン 3.3 で追加.

os.posix_fallocate(fd, offset, len)
fd で指定されたファイルに対し、開始位置 offset から len バイト分割り当てるに十分なディスクスペースを確保します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.posix_fadvise(fd, offset, len, advice)
データへアクセスする意思を、パターンを指定して宣言します。これによりカーネルが最適化を行えるようになります。advice は fd で指定されたファイルに対し、開始位置 offset から len バイト分の領域に適用されます。advice には POSIX_FADV_NORMAL、POSIX_FADV_SEQUENTIAL、POSIX_FADV_RANDOM、POSIX_FADV_NOREUSE、POSIX_FADV_WILLNEED、または POSIX_FADV_DONTNEED のいずれか一つを指定します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.POSIX_FADV_NORMAL
os.POSIX_FADV_SEQUENTIAL
os.POSIX_FADV_RANDOM
os.POSIX_FADV_NOREUSE
os.POSIX_FADV_WILLNEED
os.POSIX_FADV_DONTNEED
posix_fadvise() において、使われるであろうアクセスパターンを指定する advice に使用できるフラグです。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.pread(fd, n, offset)
ファイル記述子の位置 offset から最大で n バイトを読み出します。 ファイルオフセットは変化しません。

読み込んだバイト分のバイト列を返します。 fd が参照しているファイルの終端に達した場合、空のバイト列が返されます。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.preadv(fd, buffers, offset, flags=0)
ファイル記述子 fd の offset の位置から、可変な bytes-like オブジェクト buffers にオフセットを変更せずに読み込みます。 データをそれぞれのバッファがいっぱいになるまで移し、いっぱいになったらシーケンスの次のバッファに処理を移し、残りのデータを読み込ませます。

flags 引数にはゼロあるいは次のフラグのバイトごとの OR を取った結果が保持されています。

RWF_HIPRI

RWF_NOWAIT

Return the total number of bytes actually read which can be less than the total capacity of all the objects.

オペレーティングシステムは、使用可能なバッファの個数に基づいて上限 (sysconf() の 'SC_IOV_MAX' の値) を設定することがあります。

Combine the functionality of os.readv() and os.pread().

Availability: Linux 2.6.30 and newer, FreeBSD 6.0 and newer, OpenBSD 2.7 and newer, AIX 7.1 and newer. Using flags requires Linux 4.6 or newer.

バージョン 3.7 で追加.

os.RWF_NOWAIT
Do not wait for data which is not immediately available. If this flag is specified, the system call will return instantly if it would have to read data from the backing storage or wait for a lock.

If some data was successfully read, it will return the number of bytes read. If no bytes were read, it will return -1 and set errno to errno.EAGAIN.

利用可能な環境: Linux 4.14以上。

バージョン 3.7 で追加.

os.RWF_HIPRI
High priority read/write. Allows block-based filesystems to use polling of the device, which provides lower latency, but may use additional resources.

Currently, on Linux, this feature is usable only on a file descriptor opened using the O_DIRECT flag.

利用可能な環境: Linux 4.6以上。

バージョン 3.7 で追加.

os.pwrite(fd, str, offset)
Write the bytestring in str to file descriptor fd at position of offset, leaving the file offset unchanged.

Return the number of bytes actually written.

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.pwritev(fd, buffers, offset, flags=0)
Write the buffers contents to file descriptor fd at a offset offset, leaving the file offset unchanged. buffers must be a sequence of bytes-like objects. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.

flags 引数にはゼロあるいは次のフラグのバイトごとの OR を取った結果が保持されています。

RWF_DSYNC

RWF_SYNC

実際に書き込まれた合計バイト数を返します。

オペレーティングシステムは、使用可能なバッファの個数に基づいて上限 (sysconf() の 'SC_IOV_MAX' の値) を設定することがあります。

Combine the functionality of os.writev() and os.pwrite().

Availability: Linux 2.6.30 and newer, FreeBSD 6.0 and newer, OpenBSD 2.7 and newer, AIX 7.1 and newer. Using flags requires Linux 4.7 or newer.

バージョン 3.7 で追加.

os.RWF_DSYNC
Provide a per-write equivalent of the O_DSYNC open(2) flag. This flag effect applies only to the data range written by the system call.

利用可能な環境: Linux 4.7以上。

バージョン 3.7 で追加.

os.RWF_SYNC
Provide a per-write equivalent of the O_SYNC open(2) flag. This flag effect applies only to the data range written by the system call.

利用可能な環境: Linux 4.7以上。

バージョン 3.7 で追加.

os.read(fd, n)
Read at most n bytes from file descriptor fd.

読み込んだバイト分のバイト列を返します。 fd が参照しているファイルの終端に達した場合、空のバイト列が返されます。

注釈 この関数は低水準の I/O 向けのもので、 os.open() や pipe() が返すファイル記述子に対して使用されなければなりません。 組み込み関数 open() や popen() 、 fdopen() 、あるいは sys.stdin が返す "ファイルオブジェクト" を読み込むには、オブジェクトの read() か readline() メソッドを使用してください。
バージョン 3.5 で変更: システムコールが中断されシグナルハンドラが例外を送出しなかった場合、この関数は InterruptedError 例外を送出する代わりにシステムコールを再試行するようになりました (論拠については PEP 475 を参照してください)。

os.sendfile(out_fd, in_fd, offset, count)
os.sendfile(out_fd, in_fd, offset, count, headers=(), trailers=(), flags=0)
Copy count bytes from file descriptor in_fd to file descriptor out_fd starting at offset. Return the number of bytes sent. When EOF is reached return 0.

前者の関数表記は sendfile() が定義されているすべてのプラットフォームでサポートされています。

Linux では、offset に None が与えられると、バイト列は in_fd の現在の位置から読み込まれ、in_fd の位置は更新されます。

後者は Mac OS X および FreeBSD で使用される場合があります。headers および trailers は任意のバッファのシーケンス型オブジェクトで、in_fd からのデータが書き出される前と後に書き出されます。返り値は前者と同じです。

Mac OS X と FreeBSD では、count の値に 0 を指定すると、 in_fd の末尾に達するまで送信します。

全てのプラットフォームはソケットをファイル記述子 out_fd としてサポートし、あるプラットフォームは他の種類 (例えば、通常のファイル、パイプ) も同様にサポートします。

クロスプラットフォームのアプリケーションは headers、trailers ならびに flags 引数を使用するべきではありません。

利用可能な環境: Unix。

注釈 sendfile() のより高水準のラッパについては socket.socket.sendfile() を参照してください。
バージョン 3.3 で追加.

バージョン 3.9 で変更: Parameters out and in was renamed to out_fd and in_fd.

os.set_blocking(fd, blocking)
指定されたファイル記述子のブロッキングモードを設定します。 ブロッキングが False の場合 O_NONBLOCK フラグを設定し、そうでない場合はクリアします。

get_blocking() および socket.socket.setblocking() も参照してください。

利用可能な環境: Unix。

バージョン 3.5 で追加.

os.SF_NODISKIO
os.SF_MNOWAIT
os.SF_SYNC
実装がサポートしている場合 sendfile() 関数に渡すパラメーターです。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.readv(fd, buffers)
Read from a file descriptor fd into a number of mutable bytes-like objects buffers. Transfer data into each buffer until it is full and then move on to the next buffer in the sequence to hold the rest of the data.

Return the total number of bytes actually read which can be less than the total capacity of all the objects.

オペレーティングシステムは、使用可能なバッファの個数に基づいて上限 (sysconf() の 'SC_IOV_MAX' の値) を設定することがあります。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.tcgetpgrp(fd)
fd (os.open() が返すオープンしたファイル記述子 ) で与えられる端末に関連付けられたプロセスグループを返します。

利用可能な環境: Unix。

os.tcsetpgrp(fd, pg)
fd (os.open() が返すオープンしたファイル記述子 ) で与えられる端末に関連付けられたプロセスグループを pg に設定します。

利用可能な環境: Unix。

os.ttyname(fd)
ファイル記述子 fd に関連付けられている端末デバイスを特定する文字列を返します。 fd が端末に関連付けられていない場合、例外が送出されます。

利用可能な環境: Unix。

os.write(fd, str)
str のバイト列をファイル記述子 fd に書き出します。

Return the number of bytes actually written.

注釈 この関数は低水準の I/O 向けのもので、 os.open() や pipe() が返すファイル記述子に対して使用しなければなりません。 組み込み関数 open() や popen() 、 fdopen() 、あるいは sys.stdout や sys.stderr が返す "ファイルオブジェクト" に書き込むには、オブジェクトの write() メソッドを使用してください。
バージョン 3.5 で変更: システムコールが中断されシグナルハンドラが例外を送出しなかった場合、この関数は InterruptedError 例外を送出する代わりにシステムコールを再試行するようになりました (論拠については PEP 475 を参照してください)。

os.writev(fd, buffers)
buffers の内容をファイル記述子 fd へ書き出します。 buffers は bytes-like オブジェクト のシーケンスでなければなりません。バッファは配列の順番で処理されます。最初のバッファの内容全体は 2 番目のバッファに進む前に書き込まれ、その次も同様です。

実際に書き込まれた合計バイト数を返します。

オペレーティングシステムは、使用可能なバッファの個数に基づいて上限 (sysconf() の 'SC_IOV_MAX' の値) を設定することがあります。

利用可能な環境: Unix。

バージョン 3.3 で追加.

ターミナルのサイズの問い合わせ
バージョン 3.3 で追加.

os.get_terminal_size(fd=STDOUT_FILENO)
ターミナル (端末) のサイズ (columns, lines) を、terminal_size 型のタプルで返します。

オプションの引数 fd には問い合わせるファイル記述子を指定します (デフォルトは STDOUT_FILENO、または標準出力)。

ファイル記述子が接続されていなかった場合、 OSError が送出されます。

通常は高水準関数である shutil.get_terminal_size() を使用してください。os.get_terminal_size は低水準の実装です。

Availability: Unix, Windows。

class os.terminal_size
ターミナルウィンドウのサイズ (columns, lines) を保持するタプルのサブクラスです。

columns
ターミナルウィンドウの横幅 (文字数) です。

lines
ターミナルウィンドウの高さ (文字数) です。

ファイル記述子の継承
バージョン 3.4 で追加.

ファイル記述子には「継承可能 (inheritable)」フラグというものがあって、これにより子プロセスにファイル記述子が引き継がれるかどうかが決定されます。Python 3.4 より、 Python によって作成されるファイル記述子はデフォルトで継承不可 (non-inheritable) となりました。

UNIX の場合、継承不可のファイル記述子は新規プロセス実行時にクローズされ、そうでないファイル記述子は引き継がれます。

Windows の場合は、標準ストリームを除き、継承不可のハンドルと継承不可のファイル記述子は子プロセスでクローズされます。標準ストリーム (ファイル記述子の 0, 1, 2: 標準入力, 標準出力, 標準エラー出力) は常に引き継がれます。 spawn* 関数を使う場合、全ての継承可能なハンドルと全ての継承可能なファイル記述子は引き継がれます。 subprocess モジュールを使う場合、標準ストリームを除く全てのファイル記述子はクローズされ、継承可能なハンドルは close_fds 引数が False の場合にのみ引き継がれます。

os.get_inheritable(fd)
指定したファイル記述子の「継承可能 (inheritable)」フラグを取得します (boolean)。

os.set_inheritable(fd, inheritable)
指定したファイル記述子の「継承可能 (inheritable)」フラグをセットします。

os.get_handle_inheritable(handle)
指定したハンドルの「継承可能 (inheritable)」フラグを取得します (boolean)。

利用可能な環境: Windows 。

os.set_handle_inheritable(handle, inheritable)
指定したハンドルの「継承可能 (inheritable)」フラグをセットします。

利用可能な環境: Windows 。

ファイルとディレクトリ
一部の Unix プラットフォームでは、このセクションの関数の多くが以下の機能を一つ以上サポートしています。

specifying a file descriptor: Normally the path argument provided to functions in the os module must be a string specifying a file path. However, some functions now alternatively accept an open file descriptor for their path argument. The function will then operate on the file referred to by the descriptor. (For POSIX systems, Python will call the variant of the function prefixed with f (e.g. call fchdir instead of chdir).)

You can check whether or not path can be specified as a file descriptor for a particular function on your platform using os.supports_fd. If this functionality is unavailable, using it will raise a NotImplementedError.

その関数が引数に dir_fd または follow_symlinks もサポートしている場合、path にファイル記述子を指定した時にそれらのいずれかを指定するとエラーになります。

paths relative to directory descriptors: If dir_fd is not None, it should be a file descriptor referring to a directory, and the path to operate on should be relative; path will then be relative to that directory. If the path is absolute, dir_fd is ignored. (For POSIX systems, Python will call the variant of the function with an at suffix and possibly prefixed with f (e.g. call faccessat instead of access).

You can check whether or not dir_fd is supported for a particular function on your platform using os.supports_dir_fd. If it's unavailable, using it will raise a NotImplementedError.

not following symlinks: If follow_symlinks is False, and the last element of the path to operate on is a symbolic link, the function will operate on the symbolic link itself rather than the file pointed to by the link. (For POSIX systems, Python will call the l... variant of the function.)

そのプラットフォーム上で特別な関数に follow_symlinks がサポートされているかどうかは、os.supports_follow_symlinks で確認できます。利用できない場合 NotImplementedError が送出されます。

os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)
実 uid/gid を使って path に対するアクセスが可能か調べます。ほとんどのオペレーティングシステムは実効 uid/gid を使うため、このルーチンは suid/sgid 環境において、プログラムを起動したユーザーが path に対するアクセス権をもっているかを調べるために使われます。 path が存在するかどうかを調べるには mode を F_OK にします。ファイルアクセス権限 ( パーミッション ) を調べるには、 R_OK, W_OK, X_OK から一つまたはそれ以上のフラグを論理和指定でとることもできます。アクセスが許可されている場合 True を、そうでない場合 False を返します。詳細は access(2) の Unix マニュアルページを参照してください。

この関数は ディレクトリ記述子への相対パス および シンボリックリンクをたどらない をサポートしています。

effective_ids が True の場合、access() は実 uid/gid ではなく実効 uid/gid を使用してアクセス権を調べます。プラットフォームによっては effective_ids がサポートされていない場合があります; サポートされているかどうかは os.supports_effective_ids で確認できます。利用できない場合 NotImplementedError が送出されます。

注釈 ユーザーが、例えばファイルを開く権限を持っているかどうかを調べるために実際に open() を行う前に access() を使用することはセキュリティホールの原因になります。なぜなら、調べた時点とオープンした時点との時間差を利用してそのユーザーがファイルを不当に操作してしまうかもしれないからです。その場合は EAFP テクニックを利用するのが望ましいやり方です。例えば
if os.access("myfile", os.R_OK):
    with open("myfile") as fp:
        return fp.read()
return "some default data"
このコードは次のように書いたほうが良いです

try:
    fp = open("myfile")
except PermissionError:
    return "some default data"
else:
    with fp:
        return fp.read()
注釈 I/O 操作は access() が成功を示した時でも失敗することがあります。特にネットワークファイルシステムが通常の POSIX のパーミッションビットモデルをはみ出すアクセス権限操作を備える場合にはそのようなことが起こりえます。
バージョン 3.3 で変更: 引数 dir_fd、effective_ids、および follow_symlinks が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.F_OK
os.R_OK
os.W_OK
os.X_OK
access() で path をテストする時に mode 引数に渡す値です。上からそれぞれ、ファイルの存在、読み込み許可、書き込み許可、および実行許可になります。

os.chdir(path)
現在の作業ディレクトリを path に設定します。

この関数は ファイル記述子の指定 をサポートしています。記述子は、オープンしているファイルではなく、オープンしているディレクトリを参照していなければなりません。

This function can raise OSError and subclasses such as FileNotFoundError, PermissionError, and NotADirectoryError.

引数 path を指定して 監査イベント os.chdir を送出します。

バージョン 3.3 で追加: 一部のプラットフォームで、path にファイル記述子の指定をサポートしました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.chflags(path, flags, *, follow_symlinks=True)
path のフラグを flags に変更します。 flags は、以下の値 (stat モジュールで定義されているもの ) をビット単位の論理和で組み合わせることができます :

stat.UF_NODUMP

stat.UF_IMMUTABLE

stat.UF_APPEND

stat.UF_OPAQUE

stat.UF_NOUNLINK

stat.UF_COMPRESSED

stat.UF_HIDDEN

stat.SF_ARCHIVED

stat.SF_IMMUTABLE

stat.SF_APPEND

stat.SF_NOUNLINK

stat.SF_SNAPSHOT

この関数は シンボリックリンクをたどらない をサポートしています。

Raises an auditing event os.chflags with arguments path, flags.

利用可能な環境: Unix。

バージョン 3.3 で追加: 引数 follow_symlinks を追加しました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True)
path のモードを数値 mode に変更します。 mode は、 (stat モジュールで定義されている ) 以下の値のいずれかまたはビット単位の論理和で組み合わせた値を取り得ます :

stat.S_ISUID

stat.S_ISGID

stat.S_ENFMT

stat.S_ISVTX

stat.S_IREAD

stat.S_IWRITE

stat.S_IEXEC

stat.S_IRWXU

stat.S_IRUSR

stat.S_IWUSR

stat.S_IXUSR

stat.S_IRWXG

stat.S_IRGRP

stat.S_IWGRP

stat.S_IXGRP

stat.S_IRWXO

stat.S_IROTH

stat.S_IWOTH

stat.S_IXOTH

この関数は ファイル記述子の指定 、 ディレクトリ記述子への相対パス 、および シンボリックリンクをたどらない をサポートしています。

注釈 Windows は chmod() をサポートしていますが、ファイルの読み出し専用フラグを (stat.S_IWRITE および stat.S_IREAD 定数または対応する整数値によって) 設定できるだけです。その他のビットはすべて無視されます。
引数 path, mode, dir_fd を指定して 監査イベント os.chmod を送出します。

バージョン 3.3 で追加: path にオープンしているファイル記述子の指定のサポート、および引数 dir_fd と follow_symlinks を追加しました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)
path の所有者 id およびグループ id を、数値 uid および gid に変更します。いずれかの id を変更せずにおくには、その値として -1 を指定します。

この関数は ファイル記述子の指定 、 ディレクトリ記述子への相対パス 、および シンボリックリンクをたどらない をサポートしています。

数値 id の他に名前でも受け取る高水準関数の shutil.chown() を参照してください。

引数 path, uid, gid, dir_fd を指定して 監査イベント os.chown を送出します。

利用可能な環境: Unix。

バージョン 3.3 で追加: path にオープンしているファイル記述子の指定のサポート、および引数 dir_fd と follow_symlinks を追加しました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.chroot(path)
現在のプロセスのルートディレクトリを path に変更します。

利用可能な環境: Unix。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.fchdir(fd)
現在の作業ディレクトリをファイル記述子 fd が表すディレクトリに変更します。記述子はオープンしているファイルではなく、オープンしたディレクトリを参照していなければなりません。Python 3.3 以降では os.chdir(fd) と等価です。

引数 path を指定して 監査イベント os.chdir を送出します。

利用可能な環境: Unix。

os.getcwd()
現在の作業ディレクトリを表す文字列を返します。

os.getcwdb()
現在の作業ディレクトリを表すバイト列を返します。

バージョン 3.8 で変更: The function now uses the UTF-8 encoding on Windows, rather than the ANSI code page: see PEP 529 for the rationale. The function is no longer deprecated on Windows.

os.lchflags(path, flags)
path のフラグを数値 flags に設定します。chflags() に似ていますが、シンボリックリンクをたどりません。Python 3.3 以降では os.chflags(path, flags, follow_symlinks=False) と等価です。

Raises an auditing event os.chflags with arguments path, flags.

利用可能な環境: Unix。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.lchmod(path, mode)
path のモードを数値 mode に変更します。パスがシンボリックリンクの場合はそのリンク先ではなくシンボリックリンクそのものに対して作用します。mode に指定できる値については chmod() のドキュメントを参照してください。Python 3.3 以降では os.chmod(path, mode, follow_symlinks=False) と等価です。

引数 path, mode, dir_fd を指定して 監査イベント os.chmod を送出します。

利用可能な環境: Unix。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.lchown(path, uid, gid)
path の所有者 id およびグループ id を、数値 uid および gid に変更します。この関数はシンボリックリンクをたどりません。Python 3.3 以降では os.chown(path, uid, gid, follow_symlinks=False) と等価です。

引数 path, uid, gid, dir_fd を指定して 監査イベント os.chown を送出します。

利用可能な環境: Unix。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)
src を指し示すハードリンク dst を作成します。

この関数は src_dir_fd と dst_dir_fd の両方またはどちらかに対し ディレクトリ記述子への相対パス および シンボリックリンクをたどらない をサポートしています。

Raises an auditing event os.link with arguments src, dst, src_dir_fd, dst_dir_fd.

Availability: Unix, Windows。

バージョン 3.2 で変更: Windows サポートを追加しました。

バージョン 3.3 で追加: 引数 src_dir_fd、dst_dir_fd、および follow_symlinks を追加しました。

バージョン 3.6 で変更: src と dst が path-like object を受け付けるようになりました。

os.listdir(path='.')
Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order, and does not include the special entries '.' and '..' even if they are present in the directory. If a file is removed from or added to the directory during the call of this function, whether a name for that file be included is unspecified.

path may be a path-like object. If path is of type bytes (directly or indirectly through the PathLike interface), the filenames returned will also be of type bytes; in all other circumstances, they will be of type str.

この関数は ファイル記述子の指定 もサポートしています; ファイル記述子はディレクトリを参照していなくてはなりません。

引数 path を指定して 監査イベント os.listdir を送出します。

注釈 文字列型 のファイル名を バイト列型 にエンコードするには、fsencode() を使用します。
参考 ディレクトリエントリに加えてファイル属性情報も返す scandir() 関数の方が、多くの一般的な用途では使い勝手が良くなります。
バージョン 3.2 で変更: 引数 path は任意になりました。

バージョン 3.3 で追加: Added support for specifying path as an open file descriptor.

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.lstat(path, *, dir_fd=None)
与えられたパスに対して lstat() システムコールと同じ処理を行います。stat() と似ていますが、シンボリックリンクをたどりません。 stat_result オブジェクトを返します。

シンボリックリンクをサポートしていないプラットフォームでは stat() の別名です。

Python 3.3 以降では os.stat(path, dir_fd=dir_fd, follow_symlinks=False) と等価です。

この関数は ディレクトリ記述子への相対パス もサポートすることができます。

参考 stat() 関数。
バージョン 3.2 で変更: Windows 6.0 (Vista) のシンボリックリンクをサポートしました。

バージョン 3.3 で変更: 引数 dir_fd を追加しました。

バージョン 3.6 で変更: src と dst が path-like object を受け付けるようになりました。

バージョン 3.8 で変更: On Windows, now opens reparse points that represent another path (name surrogates), including symbolic links and directory junctions. Other kinds of reparse points are resolved by the operating system as for stat().

os.mkdir(path, mode=0o777, *, dir_fd=None)
ディレクトリ path を数値モード mode で作成します。

すでにディレクトリが存在したら、 FileExistsError が上げられます。

いくつかのシステムにおいては mode は無視されます。それが使われる時には、最初に現在の umask 値でマスクされます。もし最後の 9 ビット (つまり mode の8進法表記の最後の3桁) を除いたビットが設定されていたら、それらの意味はプラットフォームに依存します。いくつかのプラットフォームではそれらは無視され、それらを設定するためには明示的に chmod() を呼ぶ必要があるでしょう。

この関数は ディレクトリ記述子への相対パス もサポートすることができます。

一時ディレクトリを作成することもできます : tempfile モジュールの tempfile.mkdtemp() 関数を参照してください。

Raises an auditing event os.mkdir with arguments path, mode, dir_fd.

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.makedirs(name, mode=0o777, exist_ok=False)
再帰的にディレクトリを作成する関数です。mkdir() と似ていますが、末端ディレクトリを作成するために必要なすべての中間ディレクトリも作成します。

The mode parameter is passed to mkdir() for creating the leaf directory; see the mkdir() description for how it is interpreted. To set the file permission bits of any newly-created parent directories you can set the umask before invoking makedirs(). The file permission bits of existing parent directories are not changed.

If exist_ok is False (the default), an FileExistsError is raised if the target directory already exists.

注釈 作成するパス要素に pardir (UNIX では "..") が含まれる場合、makedirs() は混乱します。
この関数は UNC パスを正しく扱えるようになりました。

Raises an auditing event os.mkdir with arguments path, mode, dir_fd.

バージョン 3.2 で追加: 引数 exist_ok が追加されました。

バージョン 3.4.1 で変更: Python 3.4.1 より前、 exist_ok が True でそのディレクトリが既存の場合でも、 makedirs() は mode が既存ディレクトリのモードと合わない場合にはエラーにしようとしていました。このモードチェックの振る舞いを安全に実装することが出来なかったため、 Python 3.4.1 でこのチェックは削除されました。 bpo-21082 を参照してください。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

バージョン 3.7 で変更: The mode argument no longer affects the file permission bits of newly-created intermediate-level directories.

os.mkfifo(path, mode=0o666, *, dir_fd=None)
FIFO (名前付きパイプ) path を数値モード mode で作成します。先に現在の umask 値でマスクされます。

この関数は ディレクトリ記述子への相対パス もサポートすることができます。

FIFO は通常のファイルのようにアクセスできるパイプです。 FIFO は ( 例えば os.unlink() を使って ) 削除されるまで存在しつづけます。一般的に、 FIFO は " クライアント " と " サーバー " 形式のプロセス間でランデブーを行うために使われます : この時、サーバーは FIFO を読み込み用に、クライアントは書き出し用にオープンします。 mkfifo() は FIFO をオープンしない --- 単にランデブーポイントを作成するだけ --- なので注意してください。

利用可能な環境: Unix。

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.mknod(path, mode=0o600, device=0, *, dir_fd=None)
path という名前で、ファイルシステムノード (ファイル、デバイス特殊ファイル、または名前つきパイプ) を作成します。mode は、作成するノードのアクセス権限とタイプの両方を stat.S_IFREG、stat.S_IFCHR、stat.S_IFBLK、および stat.S_IFIFO の組み合わせ (ビット単位の論理和) で指定します (これらの定数は stat で利用可能です)。stat.S_IFCHR と stat.S_IFBLK を指定した場合、devide は新しく作成されたデバイス特殊ファイルを (おそらく os.makedev() を使って) 定義し、それ以外の定数を指定した場合は無視されます。

この関数は ディレクトリ記述子への相対パス もサポートすることができます。

利用可能な環境: Unix。

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.major(device)
RAW デバイス番号から、デバイスのメジャー番号を取り出します ( 通常 stat の st_dev か st_rdev フィールドです ) 。

os.minor(device)
RAW デバイス番号から、デバイスのマイナー番号を取り出します ( 通常 stat の st_dev か st_rdev フィールドです ) 。

os.makedev(major, minor)
メジャーおよびマイナーデバイス番号から、新しく RAW デバイス番号を作成します。

os.pathconf(path, name)
名前付きファイルに関連するシステム設定情報を返します。 name には取得したい設定名を指定します ; これは定義済みのシステム値名の文字列で、多くの標準 (POSIX.1 、 Unix 95 、 Unix 98 その他 ) で定義されています。プラットフォームによっては別の名前も定義しています。ホストオペレーティングシステムの関知する名前は pathconf_names 辞書で与えられています。このマップ型オブジェクトに入っていない設定変数については、 name に整数を渡してもかまいません。

name が不明の文字列である場合、 ValueError を送出します。 name の特定の値がホストシステムでサポートされていない場合、 pathconf_names に含まれていたとしても、 errno.EINVAL をエラー番号として OSError を送出します。

この関数は ファイル記述子の指定 をサポートしています。

利用可能な環境: Unix。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.pathconf_names
pathconf() および fpathconf() が受理するシステム設定名を、ホストオペレーティングシステムで定義されている整数値に対応付けている辞書です。この辞書はシステムでどの設定名が定義されているかを知るために利用できます。

利用可能な環境: Unix。

os.readlink(path, *, dir_fd=None)
シンボリックリンクが指しているパスを表す文字列を返します。返される値は絶対パスにも、相対パスにもなり得ます ; 相対パスの場合、 os.path.join(os.path.dirname(path), result) を使って絶対パスに変換することができます。

If the path is a string object (directly or indirectly through a PathLike interface), the result will also be a string object, and the call may raise a UnicodeDecodeError. If the path is a bytes object (direct or indirectly), the result will be a bytes object.

この関数は ディレクトリ記述子への相対パス もサポートすることができます。

When trying to resolve a path that may contain links, use realpath() to properly handle recursion and platform differences.

Availability: Unix, Windows。

バージョン 3.2 で変更: Windows 6.0 (Vista) のシンボリックリンクをサポートしました。

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: Accepts a path-like object on Unix.

バージョン 3.8 で変更: Accepts a path-like object and a bytes object on Windows.

バージョン 3.8 で変更: Added support for directory junctions, and changed to return the substitution path (which typically includes \\?\ prefix) rather than the optional "print name" field that was previously returned.

os.remove(path, *, dir_fd=None)
Remove (delete) the file path. If path is a directory, an IsADirectoryError is raised. Use rmdir() to remove directories.

この関数は ディレクトリ記述子への相対パス をサポートしています。

Windows では、使用中のファイルを削除しようとすると例外を送出します; Unixでは、ディレクトリエントリは削除されますが、記憶装置上に割り当てられたファイル領域は元のファイルが使われなくなるまで残されます。

この関数は意味論的に unlink() と同一です。

Raises an auditing event os.remove with arguments path, dir_fd.

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.removedirs(name)
再帰的なディレクトリ削除関数です。 rmdir() と同じように動作しますが、末端ディレクトリがうまく削除できるかぎり、 removedirs() は path に現れる親ディレクトリをエラーが送出されるまで ( このエラーは通常、指定したディレクトリの親ディレクトリが空でないことを意味するだけなので無視されます ) 順に削除することを試みます。例えば、 os.removedirs('foo/bar/baz') では最初にディレクトリ 'foo/bar/baz' を削除し、次に 'foo/bar' さらに 'foo' をそれらが空ならば削除します。末端のディレクトリが削除できなかった場合には OSError が送出されます。

Raises an auditing event os.remove with arguments path, dir_fd.

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)
Rename the file or directory src to dst. If dst exists, the operation will fail with an OSError subclass in a number of cases:

On Windows, if dst exists a FileExistsError is always raised.

On Unix, if src is a file and dst is a directory or vice-versa, an IsADirectoryError or a NotADirectoryError will be raised respectively. If both are directories and dst is empty, dst will be silently replaced. If dst is a non-empty directory, an OSError is raised. If both are files, dst it will be replaced silently if the user has permission. The operation may fail on some Unix flavors if src and dst are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement).

この関数は src_dir_fd と dst_dir_fd のどちらかまたは両方の指定に ディレクトリ記述子への相対パス をサポートしています。

対象の上書きがクロスプラットフォームになる場合は replace() を使用してください。

Raises an auditing event os.rename with arguments src, dst, src_dir_fd, dst_dir_fd.

バージョン 3.3 で追加: 引数 src_dir_fd および dst_dir_fd が追加されました。

バージョン 3.6 で変更: src と dst が path-like object を受け付けるようになりました。

os.renames(old, new)
再帰的にディレクトリやファイル名を変更する関数です。 rename() のように動作しますが、新たなパス名を持つファイルを配置するために必要な途中のディレクトリ構造をまず作成しようと試みます。名前変更の後、元のファイル名のパス要素は removedirs() を使って右側から順に削除されます。

注釈 この関数はコピー元の末端のディレクトリまたはファイルを削除する権限がない場合には失敗します。
Raises an auditing event os.rename with arguments src, dst, src_dir_fd, dst_dir_fd.

バージョン 3.6 で変更: old と new が path-like object を受け付けるようになりました。

os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)
ファイルまたはディレクトリ src の名前を dst へ変更します。dst がディレクトリの場合 OSError が送出されます。dst が存在し、かつファイルの場合、ユーザーの権限がある限り暗黙のうちに置き換えられます。src と dst が異なるファイルシステム上にあると失敗することがあります。ファイル名の変更が成功する場合はアトミック操作となります (これは POSIX 要求仕様です)。

この関数は src_dir_fd と dst_dir_fd のどちらかまたは両方の指定に ディレクトリ記述子への相対パス をサポートしています。

Raises an auditing event os.rename with arguments src, dst, src_dir_fd, dst_dir_fd.

バージョン 3.3 で追加.

バージョン 3.6 で変更: src と dst が path-like object を受け付けるようになりました。

os.rmdir(path, *, dir_fd=None)
Remove (delete) the directory path. If the directory does not exist or is not empty, an FileNotFoundError or an OSError is raised respectively. In order to remove whole directory trees, shutil.rmtree() can be used.

この関数は ディレクトリ記述子への相対パス をサポートしています。

Raises an auditing event os.rmdir with arguments path, dir_fd.

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.scandir(path='.')
Return an iterator of os.DirEntry objects corresponding to the entries in the directory given by path. The entries are yielded in arbitrary order, and the special entries '.' and '..' are not included. If a file is removed from or added to the directory after creating the iterator, whether an entry for that file be included is unspecified.

listdir() の代わりに scandir() を使用すると、ファイルタイプや属性情報も必要とするコードのパフォーマンスが大幅に向上します。これは、オペレーティングシステムがディレクトリのスキャン中にこの情報を提供した場合、os.DirEntry オブジェクトがその情報を公開するからです。すべての os.DirEntry メソッドはシステムコールを実行する場合がありますが、is_dir() と is_file() は、通常はシンボリックリンクにしかシステムコールを必要としません。os.DirEntry.stat() は、Unix 上では常にシステムコールを必要としますが、Windows ではシンボリックリンク用にシステムコールを一つ必要とするだけです。

path may be a path-like object. If path is of type bytes (directly or indirectly through the PathLike interface), the type of the name and path attributes of each os.DirEntry will be bytes; in all other circumstances, they will be of type str.

この関数は ファイル記述子の指定 もサポートしています; ファイル記述子はディレクトリを参照していなくてはなりません。

Raises an auditing event os.scandir with argument path.

scandir() イテレータは、 コンテキストマネージャ プロトコルをサポートし、次のメソッドを持ちます。

scandir.close()
イテレータを閉じ、獲得した資源を開放します。

この関数は、イテレータがすべて消費されるか、ガーベージコレクトされた、もしくはイテレート中にエラーが発生した際に自動的に呼び出されます。しかし、 with 文を用いるか、明示的に呼び出すことを推奨します。

バージョン 3.6 で追加.

次の単純な例では、scandir() を使用して、指定した path 内の先頭が '.' でないすべてのファイル (ディレクトリを除く) をすべて表示します。entry.is_file() を呼び出しても、通常は追加のシステムコールは行われません:

with os.scandir(path) as it:
    for entry in it:
        if not entry.name.startswith('.') and entry.is_file():
            print(entry.name)
注釈 On Unix-based systems, scandir() uses the system's opendir() and readdir() functions. On Windows, it uses the Win32 FindFirstFileW and FindNextFileW functions.
バージョン 3.5 で追加.

バージョン 3.6 で追加: Added support for the context manager protocol and the close() method. If a scandir() iterator is neither exhausted nor explicitly closed a ResourceWarning will be emitted in its destructor.

関数が path-like object を受け入れるようになりました。

バージョン 3.7 で変更: Added support for file descriptors on Unix.

class os.DirEntry
ディレクトリエントリのファイルパスとその他のファイル属性を公開するために、scandir() が yield するオブジェクトです。

scandir() は、追加のシステムコールを実行することなく、この情報をできるだけ多く提供します。stat() または lstat() システムコールが実行された場合、os.DirEntry オブジェクトは結果をキャッシュします。

os.DirEntry インスタンスは、寿命の長いデータ構造に保存されることは想定されていません。ファイルメタデータが変更された場合や、 scandir() が呼び出されてから長時間が経過した場合は、 os.stat(entry.path) を呼び出して最新の情報を取得してください。

os.DirEntry のメソッドはオペレーティングシステムコールを実行する場合があるため、それらは OSError も送出する場合があります。エラーを細かく制御する必要がある場合、 os.DirEntry のメソッドの一つの呼び出し時に OSError を捕捉して、適切な処理を行うことができます。

To be directly usable as a path-like object, os.DirEntry implements the PathLike interface.

os.DirEntry インスタンスの属性とメソッドは以下の通りです:

name
scandir() の path 引数に対して相対的な、エントリのベースファイル名です。

The name attribute will be bytes if the scandir() path argument is of type bytes and str otherwise. Use fsdecode() to decode byte filenames.

path
The entry's full path name: equivalent to os.path.join(scandir_path, entry.name) where scandir_path is the scandir() path argument. The path is only absolute if the scandir() path argument was absolute. If the scandir() path argument was a file descriptor, the path attribute is the same as the name attribute.

The path attribute will be bytes if the scandir() path argument is of type bytes and str otherwise. Use fsdecode() to decode byte filenames.

inode()
項目の inode 番号を返します。

結果は os.DirEntry オブジェクトにキャッシュされます。最新の情報を取得するには os.stat(entry.path, follow_symlinks=False).st_ino を使用してください。

Windows 上では、最初のキャッシュされていない呼び出しでシステムコールが必要ですが、 Unix 上では必要ありません。

is_dir(*, follow_symlinks=True)
この項目がディレクトリまたはディレクトリへのシンボリックリンクである場合、 True を返します。項目がそれ以外のファイルやそれ以外のファイルへのシンボリックリンクである場合や、もはや存在しない場合は False を返します。

follow_symlinks が False の場合、項目がディレクトリ (シンボリックリンクはたどりません) の場合にのみ True を返します。項目がディレクトリ以外のファイルである場合や、項目がもはや存在しない場合は False を返します。

結果は os.DirEntry オブジェクトにキャッシュされます。follow_symlinks が True の場合と False の場合とでは、別のオブジェクトにキャッシュされます。最新の情報を取得するには stat.S_ISDIR() と共に os.stat() を呼び出してください。

多くの場合、最初のキャッシュされない呼び出しでは、システムコールは必要とされません。具体的には、シンボリックリンク以外では、Windows も Unix もシステムコールを必要としません。ただし、dirent.d_type == DT_UNKNOWN を返す、ネットワークファイルシステムなどの特定の Unix ファイルシステムは例外です。項目がシンボリックリンクの場合、follow_symlinks が False の場合を除き、シンボリックリンクをたどるためにシステムコールが必要となります。

このメソッドは PermissionError のような OSError を送出することがありますが、 FileNotFoundError は捕捉され送出されません。

is_file(*, follow_symlinks=True)
この項目がファイルまたはファイルへのシンボリックリンクである場合、 True を返します。項目がディレクトリやファイル以外の項目へのシンボリックリンクである場合や、もはや存在しない場合は False を返します。

follow_symlinks が False の場合、項目がファイル (シンボリックリンクはたどりません) の場合にのみ True を返します。項目がディレクトリやその他のファイル以外の項目である場合や、項目がもはや存在しない場合は False を返します。

結果は os.DirEntry オブジェクトにキャッシュされます。キャッシュ、システムコール、例外は、is_dir() と同様に行われます。

is_symlink()
この項目がシンボリックリンクの場合 (たとえ破損していても)、True を返します。項目がディレクトリやあらゆる種類のファイルの場合、またはもはや存在しない場合は False を返します。

結果は os.DirEntry オブジェクトにキャッシュされます。 最新の情報をフェッチするには os.path.islink() を呼び出してください。

多くの場合、最初のキャッシュされない呼び出しでは、システムコールは必要とされません。具体的には、Windows も Unix もシステムコールを必要としません。ただし、dirent.d_type == DT_UNKNOWN を返す、ネットワークファイルシステムなどの特定の Unix ファイルシステムは例外です。

このメソッドは PermissionError のような OSError を送出することがありますが、 FileNotFoundError は捕捉され送出されません。

stat(*, follow_symlinks=True)
この項目の stat_result オブジェクトを返します。このメソッドは、デフォルトでシンボリックリンクをたどります。シンボリックリンクを開始するには、 follow_symlinks=False 引数を追加します。

On Unix, this method always requires a system call. On Windows, it only requires a system call if follow_symlinks is True and the entry is a reparse point (for example, a symbolic link or directory junction).

Windows では、stat_result の st_ino 、 st_dev 、 st_nlink 属性は常にゼロに設定されます。これらの属性を取得するには、 os.stat() を呼び出します。

結果は os.DirEntry オブジェクトにキャッシュされます。follow_symlinks が True の場合と False の場合とでは、別のオブジェクトにキャッシュされます。最新の情報を取得するには、 os.stat() を呼び出してください。

os.DirEntry と pathlib.Path では、いくつかの属性やメソッドがよい対応関係にあります。特に、 name 属性は同じ意味を持ちます。is_dir() 、 is_file() 、 is_symlink() 、 stat() メソッドも同じ意味を持ちます。

バージョン 3.5 で追加.

バージョン 3.6 で変更: PathLike インターフェースをサポートしました。Windowsで:class:bytes パスをサポートしました。

os.stat(path, *, dir_fd=None, follow_symlinks=True)
Get the status of a file or a file descriptor. Perform the equivalent of a stat() system call on the given path. path may be specified as either a string or bytes -- directly or indirectly through the PathLike interface -- or as an open file descriptor. Return a stat_result object.

この関数は通常はシンボリックリンクをたどります。シンボリックリンクに対して stat したい場合は follow_symlinks=False とするか、 lstat() を利用してください。

この関数は ファイル記述子の指定 および シンボリックリンクをたどらない をサポートしています。

On Windows, passing follow_symlinks=False will disable following all name-surrogate reparse points, which includes symlinks and directory junctions. Other types of reparse points that do not resemble links or that the operating system is unable to follow will be opened directly. When following a chain of multiple links, this may result in the original link being returned instead of the non-link that prevented full traversal. To obtain stat results for the final path in this case, use the os.path.realpath() function to resolve the path name as far as possible and call lstat() on the result. This does not apply to dangling symlinks or junction points, which will raise the usual exceptions.

以下はプログラム例です:

>>>
>>> import os
>>> statinfo = os.stat('somefile.txt')
>>> statinfo
os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,
st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,
st_mtime=1297230027, st_ctime=1297230027)
>>> statinfo.st_size
264
参考 fstat() と lstat()。
バージョン 3.3 で追加: dir_fd, follow_symlinks 引数の追加、ファイル記述子の指定の追加。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

バージョン 3.8 で変更: On Windows, all reparse points that can be resolved by the operating system are now followed, and passing follow_symlinks=False disables following all name surrogate reparse points. If the operating system reaches a reparse point that it is not able to follow, stat now returns the information for the original path as if follow_symlinks=False had been specified instead of raising an error.

class os.stat_result
おおむね stat 構造体のメンバーに対応する属性を持つオブジェクトです。os.stat() 、 os.fstat() 、 os.lstat() の結果に使用されます。

属性:

st_mode
ファイルモード。ファイルタイプとファイルモードのビット （権限）。

st_ino
Platform dependent, but if non-zero, uniquely identifies the file for a given value of st_dev. Typically:

the inode number on Unix,

the file index on Windows

st_dev
このファイルが存在するデバイスの識別子。

st_nlink
ハードリンクの数。

st_uid
ファイル所有者のユーザ識別子。

st_gid
ファイル所有者のグループ識別子。

st_size
ファイルが通常のファイルまたはシンボリックリンクの場合、そのファイルのバイト単位でのサイズです。シンボリックリンクのサイズは、含まれるパス名の長さで、null バイトで終わることはありません。

タイムスタンプ:

st_atime
秒で表した最終アクセス時刻。

st_mtime
秒で表した最終内容更新時刻。

st_ctime
プラットフォーム依存:

Unix ではメタデータの最終更新時刻

Windows では作成時刻、単位は秒

st_atime_ns
ナノ秒 (整数) で表した最終アクセス時刻。

st_mtime_ns
ナノ秒 (整数) で表した最終内容更新時刻。

st_ctime_ns
プラットフォーム依存:

Unix ではメタデータの最終更新時刻

Windows で、ナノ秒 (整数) で表した作成時刻。

注釈 st_atime 、 st_mtime 、および st_ctime 属性の厳密な意味や精度はオペレーティングシステムやファイルシステムによって変わります。例えば、 FAT や FAT32 ファイルシステムを使用している Windows システムでは、 st_mtime の精度は 2 秒であり、 st_atime の精度は 1 日に過ぎません。詳しくはお使いのオペレーティングシステムのドキュメントを参照してください。
同じように、st_atime_ns、st_mtime_ns、および st_ctime_ns は常にナノ秒で表されますが、多くのシステムではナノ秒単位の精度では提供していません。ナノ秒単位の精度を提供するシステムであっても、st_atime、st_mtime、および st_ctime についてはそれらが格納される浮動小数点オブジェクトがそのすべてを保持できず、それ自体が少々不正確です。正確なタイムスタンプが必要な場合は、st_atime_ns、st_mtime_ns、および st_ctime_ns を使用するべきです。

(Linux のような ) 一部の Unix システムでは、以下の属性が利用できる場合があります :

st_blocks
ファイルに対して割り当てられている 512 バイトのブロックの数です。ファイルにホール (hole) が含まれている場合、st_size/512 より小さくなる場合があります。

st_blksize
効率的なファイルシステム I/O のための「推奨される」ブロックサイズです。ファイルに、これより小さいチャンクで書き込むと、非効率的な読み込み、編集、再書き込みが起こる場合があります。

st_rdev
inode デバイスの場合デバイスタイプ

st_flags
ファイルのユーザ定義フラグ

他の (FreeBSD のような ) Unix システムでは、以下の属性が利用できる場合があります ( ただし root ユーザ以外が使うと値が入っていない場合があります ):

st_gen
ファイル生成番号

st_birthtime
ファイル作成時刻

On Solaris and derivatives, the following attributes may also be available:

st_fstype
String that uniquely identifies the type of the filesystem that contains the file.

Mac OS システムでは、以下の属性も利用できる場合があります:

st_rsize
ファイルの実際のサイズ

st_creator
ファイルの作成者

st_type
ファイルタイプ

On Windows systems, the following attributes are also available:

st_file_attributes
Windows のファイルの属性。GetFileInformationByHandle() の返す BY_HANDLE_FILE_INFORMATION 構造の dwFileAttributes メンバーです。stat モジュールの FILE_ATTRIBUTE_* 定数を参照してください。

st_reparse_tag
When st_file_attributes has the FILE_ATTRIBUTE_REPARSE_POINT set, this field contains the tag identifying the type of reparse point. See the IO_REPARSE_TAG_* constants in the stat module.

標準モジュール stat は stat 構造体からの情報の取り出しに役立つ関数と定数を定義しています。 (Windows では、一部のアイテムにダミー値が入ります )

後方互換性のため、stat_result インスタンスには、 stat 構造体の最も重要な (そして移植性の高い) メンバーを表す少なくとも 10 個の整数からなるタプルとしてもアクセス可能です。このタプルは、 st_mode、st_ino、st_dev、st_nlink、st_uid、st_gid、st_size、st_atime、st_mtime、st_ctime の順になります。実装によってはそれ以上のアイテムが末尾に追加されます。古いバージョンの Python との互換性のため、 stat_result にタプルとしてアクセスすると、常に整数を返します。

バージョン 3.3 で追加: st_atime_ns、st_mtime_ns、st_ctime_ns メンバが追加されました。

バージョン 3.5 で追加: Windows において st_file_attributes メンバが追加されました。

バージョン 3.5 で変更: Windows now returns the file index as st_ino when available.

バージョン 3.7 で追加: Added the st_fstype member to Solaris/derivatives.

バージョン 3.8 で追加: Added the st_reparse_tag member on Windows.

バージョン 3.8 で変更: On Windows, the st_mode member now identifies special files as S_IFCHR, S_IFIFO or S_IFBLK as appropriate.

os.statvfs(path)
Perform a statvfs() system call on the given path. The return value is an object whose attributes describe the filesystem on the given path, and correspond to the members of the statvfs structure, namely: f_bsize, f_frsize, f_blocks, f_bfree, f_bavail, f_files, f_ffree, f_favail, f_flag, f_namemax, f_fsid.

f_flag 属性のビットフラグ用に 2 つのモジュールレベル定数が定義されています: ST_RDONLY が設定されるとファイルシステムは読み出し専用でマウントされ、ST_NOSUID が設定されると setuid/setgid ビットの動作は無効になるか、サポートされません。

GNU/glibc ベースのシステム用に、追加のモジュールレベルの定数が次のように定義されています。 ST_NODEV (デバイス特殊ファイルへのアクセスを許可しない) 、 ST_NOEXEC (プログラムの実行を許可しない) 、 ST_SYNCHRONOUS (書き込みが一度に同期される) 、ST_MANDLOCK (ファイルシステムで強制的なロックを許可する) 、 ST_WRITE (ファイル/ディレクトリ/シンボリックリンクに書き込む) 、 ST_APPEND (追記のみのファイル) 、ST_IMMUTABLE (変更不能なファイル) 、 ST_NOATIME (アクセス時刻を更新しない) 、ST_NODIRATIME (ディレクトリアクセス時刻を更新しない) 、ST_RELATIME (mtime/ctimeに対して相対的に atime を更新する)。

この関数は ファイル記述子の指定 をサポートしています。

利用可能な環境: Unix。

バージョン 3.2 で変更: 定数 ST_RDONLY および ST_NOSUID が追加されました。

バージョン 3.3 で追加: Added support for specifying path as an open file descriptor.

バージョン 3.4 で変更: ST_NODEV, ST_NOEXEC, ST_SYNCHRONOUS, ST_MANDLOCK, ST_WRITE, ST_APPEND, ST_IMMUTABLE, ST_NOATIME, ST_NODIRATIME, ST_RELATIME 定数が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

バージョン 3.7 で追加: Added f_fsid.

os.supports_dir_fd
A set object indicating which functions in the os module accept an open file descriptor for their dir_fd parameter. Different platforms provide different features, and the underlying functionality Python uses to implement the dir_fd parameter is not available on all platforms Python supports. For consistency's sake, functions that may support dir_fd always allow specifying the parameter, but will throw an exception if the functionality is used when it's not locally available. (Specifying None for dir_fd is always supported on all platforms.)

To check whether a particular function accepts an open file descriptor for its dir_fd parameter, use the in operator on supports_dir_fd. As an example, this expression evaluates to True if os.stat() accepts open file descriptors for dir_fd on the local platform:

os.stat in os.supports_dir_fd
現在 dir_fd 引数は Unix プラットフォームでのみ動作します。Windows で動作する関数はありません。

バージョン 3.3 で追加.

os.supports_effective_ids
A set object indicating whether os.access() permits specifying True for its effective_ids parameter on the local platform. (Specifying False for effective_ids is always supported on all platforms.) If the local platform supports it, the collection will contain os.access(); otherwise it will be empty.

This expression evaluates to True if os.access() supports effective_ids=True on the local platform:

os.access in os.supports_effective_ids
Currently effective_ids is only supported on Unix platforms; it does not work on Windows.

バージョン 3.3 で追加.

os.supports_fd
A set object indicating which functions in the os module permit specifying their path parameter as an open file descriptor on the local platform. Different platforms provide different features, and the underlying functionality Python uses to accept open file descriptors as path arguments is not available on all platforms Python supports.

To determine whether a particular function permits specifying an open file descriptor for its path parameter, use the in operator on supports_fd. As an example, this expression evaluates to True if os.chdir() accepts open file descriptors for path on your local platform:

os.chdir in os.supports_fd
バージョン 3.3 で追加.

os.supports_follow_symlinks
A set object indicating which functions in the os module accept False for their follow_symlinks parameter on the local platform. Different platforms provide different features, and the underlying functionality Python uses to implement follow_symlinks is not available on all platforms Python supports. For consistency's sake, functions that may support follow_symlinks always allow specifying the parameter, but will throw an exception if the functionality is used when it's not locally available. (Specifying True for follow_symlinks is always supported on all platforms.)

To check whether a particular function accepts False for its follow_symlinks parameter, use the in operator on supports_follow_symlinks. As an example, this expression evaluates to True if you may specify follow_symlinks=False when calling os.stat() on the local platform:

os.stat in os.supports_follow_symlinks
バージョン 3.3 で追加.

os.symlink(src, dst, target_is_directory=False, *, dir_fd=None)
src を指し示すシンボリックリンク dst を作成します。

On Windows, a symlink represents either a file or a directory, and does not morph to the target dynamically. If the target is present, the type of the symlink will be created to match. Otherwise, the symlink will be created as a directory if target_is_directory is True or a file symlink (the default) otherwise. On non-Windows platforms, target_is_directory is ignored.

この関数は ディレクトリ記述子への相対パス をサポートしています。

注釈 On newer versions of Windows 10, unprivileged accounts can create symlinks if Developer Mode is enabled. When Developer Mode is not available/enabled, the SeCreateSymbolicLinkPrivilege privilege is required, or the process must be run as an administrator.
この関数が特権を持たないユーザーに呼び出されると、OSError が送出されます。

Raises an auditing event os.symlink with arguments src, dst, dir_fd.

Availability: Unix, Windows。

バージョン 3.2 で変更: Windows 6.0 (Vista) のシンボリックリンクをサポートしました。

バージョン 3.3 で追加: 引数 dir_fd が追加され、非 Windows プラットフォームでの target_is_directory 指定がサポートされました。

バージョン 3.6 で変更: src と dst が path-like object を受け付けるようになりました。

バージョン 3.8 で変更: Added support for unelevated symlinks on Windows with Developer Mode.

os.sync()
ディスクキャッシュのディスクへの書き出しを強制します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.truncate(path, length)
path に対応するファイルを、サイズが最大で length バイトになるよう切り詰めます。

この関数は ファイル記述子の指定 をサポートしています。

Raises an auditing event os.truncate with arguments path, length.

Availability: Unix, Windows。

バージョン 3.3 で追加.

バージョン 3.5 で変更: Windows サポートを追加しました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.unlink(path, *, dir_fd=None)
ファイル path を削除します。意味上は remove() と等価です。 unlink の名前は伝統的な Unix の関数名です。詳細は remove() のドキュメントを参照してください。

Raises an auditing event os.remove with arguments path, dir_fd.

バージョン 3.3 で追加: 引数 dir_fd が追加されました。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.utime(path, times=None, *, [ns, ]dir_fd=None, follow_symlinks=True)
path で指定されたファイルに最終アクセス時刻および最終修正時刻を設定します。

utime() は 2 つの任意引数 times と ns をとります。これらは path に設定する時刻を指定し、以下のように使用されます:

ns を指定する場合、ナノ秒を表す整数値をメンバーとして使用して、 (atime_ns, mtime_ns) の形式の 2 要素タプルを指定する必要があります。

times が None ではない場合、(atime, mtime) の形式で各メンバーは単位を秒で表す整数か浮動小数点値のタプルを指定しなければなりません。

times が None で、 ns が指定されていない場合、これは両方の時間を現在時刻として ns=(atime_ns, mtime_ns) を指定することと等価です。

times と ns の両方にタプルが指定されるとエラーになります。

Note that the exact times you set here may not be returned by a subsequent stat() call, depending on the resolution with which your operating system records access and modification times; see stat(). The best way to preserve exact times is to use the st_atime_ns and st_mtime_ns fields from the os.stat() result object with the ns parameter to utime.

この関数は ファイル記述子の指定 、 ディレクトリ記述子への相対パス 、および シンボリックリンクをたどらない をサポートしています。

Raises an auditing event os.utime with arguments path, times, ns, dir_fd.

バージョン 3.3 で追加: Added support for specifying path as an open file descriptor, and the dir_fd, follow_symlinks, and ns parameters.

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.walk(top, topdown=True, onerror=None, followlinks=False)
ディレクトリツリー以下のファイル名を、ツリーをトップダウンもしくはボトムアップに走査することで作成します。ディレクトリ top を根に持つディレクトリツリーに含まれる、各ディレクトリ (top 自身を含む ) ごとに、タプル (dirpath, dirnames, filenames) を yield します。

dirpath is a string, the path to the directory. dirnames is a list of the names of the subdirectories in dirpath (excluding '.' and '..'). filenames is a list of the names of the non-directory files in dirpath. Note that the names in the lists contain no path components. To get a full path (which begins with top) to a file or directory in dirpath, do os.path.join(dirpath, name). Whether or not the lists are sorted depends on the file system. If a file is removed from or added to the dirpath directory during generating the lists, whether a name for that file be included is unspecified.

オプション引数 topdown が True であるか、指定されなかった場合、各ディレクトリからタプルを生成した後で、サブディレクトリからタプルを生成します。 ( ディレクトリはトップダウンで生成 ) 。 topdown が False の場合、ディレクトリに対応するタプルは、そのディレクトリ以下の全てのサブディレクトリに対応するタプルの後で ( ボトムアップで ) 生成されます。 topdown の値によらず、サブディレクトリのリストは、ディレクトリとそのサブディレクトリのタプルを生成する前に取り出されます。

topdown が True のとき、呼び出し側は dirnames リストを、インプレースで ( たとえば、 del やスライスを使った代入で ) 変更でき、 walk() は dirnames に残っているサブディレクトリ内のみを再帰します。これにより、検索を省略したり、特定の訪問順序を強制したり、呼び出し側が walk() を再開する前に、呼び出し側が作った、または名前を変更したディレクトリを、 walk() に知らせたりすることができます。 topdown が False のときに dirnames を変更しても効果はありません。ボトムアップモードでは dirpath 自身が生成される前に dirnames 内のディレクトリの情報が生成されるからです。

By default, errors from the scandir() call are ignored. If optional argument onerror is specified, it should be a function; it will be called with one argument, an OSError instance. It can report the error to continue with the walk, or raise the exception to abort the walk. Note that the filename is available as the filename attribute of the exception object.

デフォルトでは、 walk() はディレクトリへのシンボリックリンクをたどりません。 followlinks に True を指定すると、ディレクトリへのシンボリックリンクをサポートしているシステムでは、シンボリックリンクの指しているディレクトリを走査します。

注釈 followlinks に True を指定すると、シンボリックリンクが親ディレクトリを指していた場合に、無限ループになることに注意してください。 walk() はすでにたどったディレクトリを管理したりはしません。
注釈 相対パスを渡した場合、 walk() が再開されるまでの間に現在の作業ディレクトリを変更しないでください。 walk() はカレントディレクトリを変更しませんし、呼び出し側もカレントディレクトリを変更しないと仮定しています。
以下の例では、最初のディレクトリ以下にある各ディレクトリに含まれる、非ディレクトリファイルのバイト数を表示します。ただし、 CVS サブディレクトリ以下は見に行きません

import os
from os.path import join, getsize
for root, dirs, files in os.walk('python/Lib/email'):
    print(root, "consumes", end=" ")
    print(sum(getsize(join(root, name)) for name in files), end=" ")
    print("bytes in", len(files), "non-directory files")
    if 'CVS' in dirs:
        dirs.remove('CVS')  # don't visit CVS directories
次の例 (shutil.rmtree() の単純な実装) では、ツリーをボトムアップで走査することが不可欠になります; rmdir() はディレクトリが空になるまで削除を許さないからです:

# Delete everything reachable from the directory named in "top",
# assuming there are no symbolic links.
# CAUTION:  This is dangerous!  For example, if top == '/', it
# could delete all your disk files.
import os
for root, dirs, files in os.walk(top, topdown=False):
    for name in files:
        os.remove(os.path.join(root, name))
    for name in dirs:
        os.rmdir(os.path.join(root, name))
Raises an auditing event os.walk with arguments top, topdown, onerror, followlinks.

バージョン 3.5 で変更: この関数は、今では os.listdir() ではなく os.scandir() を呼び出します。これにより、 os.stat() の呼び出し回数を削減でき、動作が高速化します。

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.fwalk(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)
挙動は walk() と同じですが、dir_fd をサポートし、タプル (dirpath, dirnames, filenames, dirfd) を yield します。

dirpath、dirnames、および filenames は walk() の出力と同じで、dirfd は dirpath を参照するファイル記述子です。

この関数は常に ディレクトリ記述子への相対パス および シンボリックリンクをたどらない をサポートしています。ただし、他の関数と異なり、fwalk() での follow_symlinks のデフォルト値は False になることに注意してください。

注釈 fwalk() はファイル記述子を yield するため、それらが有効なのは次のイテレートステップまでです。それ以後も保持したい場合は dup() などを使って複製して使用してください。
以下の例では、最初のディレクトリ以下にある各ディレクトリに含まれる、非ディレクトリファイルのバイト数を表示します。ただし、 CVS サブディレクトリ以下は見に行きません

import os
for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):
    print(root, "consumes", end="")
    print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),
          end="")
    print("bytes in", len(files), "non-directory files")
    if 'CVS' in dirs:
        dirs.remove('CVS')  # don't visit CVS directories
次の例では、ツリーをボトムアップで走査することが不可欠になります ; rmdir() はディレクトリが空になるまで削除を許さないからです

# Delete everything reachable from the directory named in "top",
# assuming there are no symbolic links.
# CAUTION:  This is dangerous!  For example, if top == '/', it
# could delete all your disk files.
import os
for root, dirs, files, rootfd in os.fwalk(top, topdown=False):
    for name in files:
        os.unlink(name, dir_fd=rootfd)
    for name in dirs:
        os.rmdir(name, dir_fd=rootfd)
Raises an auditing event os.fwalk with arguments top, topdown, onerror, follow_symlinks, dir_fd.

利用可能な環境: Unix。

バージョン 3.3 で追加.

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

バージョン 3.7 で変更: Added support for bytes paths.

os.memfd_create(name[, flags=os.MFD_CLOEXEC])
Create an anonymous file and return a file descriptor that refers to it. flags must be one of the os.MFD_* constants available on the system (or a bitwise ORed combination of them). By default, the new file descriptor is non-inheritable.

The name supplied in name is used as a filename and will be displayed as the target of the corresponding symbolic link in the directory /proc/self/fd/. The displayed name is always prefixed with memfd: and serves only for debugging purposes. Names do not affect the behavior of the file descriptor, and as such multiple files can have the same name without any side effects.

Availability: Linux 3.17 or newer with glibc 2.27 or newer.

バージョン 3.8 で追加.

os.MFD_CLOEXEC
os.MFD_ALLOW_SEALING
os.MFD_HUGETLB
os.MFD_HUGE_SHIFT
os.MFD_HUGE_MASK
os.MFD_HUGE_64KB
os.MFD_HUGE_512KB
os.MFD_HUGE_1MB
os.MFD_HUGE_2MB
os.MFD_HUGE_8MB
os.MFD_HUGE_16MB
os.MFD_HUGE_32MB
os.MFD_HUGE_256MB
os.MFD_HUGE_512MB
os.MFD_HUGE_1GB
os.MFD_HUGE_2GB
os.MFD_HUGE_16GB
These flags can be passed to memfd_create().

Availability: Linux 3.17 or newer with glibc 2.27 or newer. The MFD_HUGE* flags are only available since Linux 4.14.

バージョン 3.8 で追加.

Linux 拡張属性
バージョン 3.3 で追加.

以下の関数はすべて Linux でのみ使用可能です。

os.getxattr(path, attribute, *, follow_symlinks=True)
Return the value of the extended filesystem attribute attribute for path. attribute can be bytes or str (directly or indirectly through the PathLike interface). If it is str, it is encoded with the filesystem encoding.

この関数は ファイル記述子の指定 および シンボリックリンクをたどらない をサポートしています。

Raises an auditing event os.getxattr with arguments path, attribute.

バージョン 3.6 で変更: path と attribute が path-like object を受け付けるようになりました。

os.listxattr(path=None, *, follow_symlinks=True)
path の拡張ファイルシステム属性のリストを返します。リスト内の属性はファイルシステムのエンコーディングでデコードされた文字列で表されます。path が None の場合、listxattr() はカレントディレクトリを調べます。

この関数は ファイル記述子の指定 および シンボリックリンクをたどらない をサポートしています。

Raises an auditing event os.listxattr with argument path.

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.removexattr(path, attribute, *, follow_symlinks=True)
Removes the extended filesystem attribute attribute from path. attribute should be bytes or str (directly or indirectly through the PathLike interface). If it is a string, it is encoded with the filesystem encoding.

この関数は ファイル記述子の指定 および シンボリックリンクをたどらない をサポートしています。

Raises an auditing event os.removexattr with arguments path, attribute.

バージョン 3.6 で変更: path と attribute が path-like object を受け付けるようになりました。

os.setxattr(path, attribute, value, flags=0, *, follow_symlinks=True)
Set the extended filesystem attribute attribute on path to value. attribute must be a bytes or str with no embedded NULs (directly or indirectly through the PathLike interface). If it is a str, it is encoded with the filesystem encoding. flags may be XATTR_REPLACE or XATTR_CREATE. If XATTR_REPLACE is given and the attribute does not exist, EEXISTS will be raised. If XATTR_CREATE is given and the attribute already exists, the attribute will not be created and ENODATA will be raised.

この関数は ファイル記述子の指定 および シンボリックリンクをたどらない をサポートしています。

注釈 Linux カーネル 2.6.39 以前では、バグのため一部のファイルシステムで引数 flags が無視されます。
Raises an auditing event os.setxattr with arguments path, attribute, value, flags.

バージョン 3.6 で変更: path と attribute が path-like object を受け付けるようになりました。

os.XATTR_SIZE_MAX
拡張属性の値にできる最大サイズです。現在、Linux では 64 キロバイトです。

os.XATTR_CREATE
setxattr() の引数 flags に指定できる値です。その操作で属性を作成しなければならないことを意味します。

os.XATTR_REPLACE
setxattr() の引数 flags に指定できる値です。その操作で既存の属性を置き換えなければならないことを意味します。

プロセス管理
以下の関数はプロセスの生成や管理に利用できます。

さまざまな exec* 関数は、プロセス内にロードされる新しいプログラムに与えるための、引数のリストを取ります。どの関数の場合でも、新しいプログラムに渡されるリストの最初の引数は、ユーザがコマンドラインで入力する引数ではなく、そのプログラム自体の名前です。 C プログラマならば、プログラムの main() に渡される argv[0] だと考えれば良いでしょう。たとえば、 os.execv('/bin/echo', ['foo', 'bar']) が標準出力に出力するのは bar だけで、 foo は無視されたかのように見えることになります。

os.abort()
SIGABRT シグナルを現在のプロセスに対して生成します。 Unix では、デフォルトの動作はコアダンプの生成です ; Windows では、プロセスは即座に終了コード 3 を返します。この関数の呼び出しは signal.signal() を使って SIGABRT に対し登録された Python シグナルハンドラーを呼び出さないことに注意してください。

os.add_dll_directory(path)
Add a path to the DLL search path.

This search path is used when resolving dependencies for imported extension modules (the module itself is resolved through sys.path), and also by ctypes.

Remove the directory by calling close() on the returned object or using it in a with statement.

See the Microsoft documentation for more information about how DLLs are loaded.

Raises an auditing event os.add_dll_directory with argument path.

利用可能な環境: Windows 。

バージョン 3.8 で追加: Previous versions of CPython would resolve DLLs using the default behavior for the current process. This led to inconsistencies, such as only sometimes searching PATH or the current working directory, and OS functions such as AddDllDirectory having no effect.

In 3.8, the two primary ways DLLs are loaded now explicitly override the process-wide behavior to ensure consistency. See the porting notes for information on updating libraries.

os.execl(path, arg0, arg1, ...)
os.execle(path, arg0, arg1, ..., env)
os.execlp(file, arg0, arg1, ...)
os.execlpe(file, arg0, arg1, ..., env)
os.execv(path, args)
os.execve(path, args, env)
os.execvp(file, args)
os.execvpe(file, args, env)
これらの関数はすべて、現在のプロセスを置き換える形で新たなプログラムを実行します ; 現在のプロセスは返り値を返しません。 Unix では、新たに実行される実行コードは現在のプロセス内に読み込まれ、呼び出し側と同じプロセス ID を持つことになります。エラーは OSError 例外として報告されます。

現在のプロセスは瞬時に置き換えられます。開かれているファイルオブジェクトやファイル記述子はフラッシュされません。そのため、バッファ内にデータが残っているかもしれない場合、 exec* 関数を実行する前に sys.stdout.flush() か os.fsync() を利用してバッファをフラッシュしておく必要があります。

"l" および "v" のついた exec* 関数は、コマンドライン引数をどのように渡すかが異なります。 "l" 型は、コードを書くときにパラメタ数が決まっている場合に、おそらくもっとも簡単に利用できます。個々のパラメタは単に execl*() 関数の追加パラメタとなります。 "v" 型は、パラメタの数が可変の時に便利で、リストかタプルの引数が args パラメタとして渡されます。どちらの場合も、子プロセスに渡す引数は動作させようとしているコマンドの名前から始まるべきですが、これは強制されません。

末尾近くに "p" をもつ型 (execlp(), execlpe(), execvp(), および execvpe()) は、プログラム file を探すために環境変数 PATH を利用します。環境変数が ( 次の段で述べる exec*e 型関数で ) 置き換えられる場合、環境変数は PATH を決定する上の情報源として使われます。その他の型、 execl(), execle(), execv(), および execve() では、実行コードを探すために PATH を使いません。 path には適切に設定された絶対パスまたは相対パスが入っていなくてはなりません。

execle() 、 execlpe() 、 execve() 、および execvpe() (すべて末尾に "e" がついています) では、 env 引数は新たなプロセスで利用される環境変数を定義するためのマップ型でなくてはなりません ( 現在のプロセスの環境変数の代わりに利用されます ); execl() 、 execlp() 、 execv() 、および execvp() では、すべて新たなプロセスは現在のプロセスの環境を引き継ぎます。

一部のプラットフォームの execve() では、path はオープンしているファイル記述子で指定することもできます。この機能をサポートしていないプラットフォームもあります; os.supports_fd を使うことで利用可能かどうか調べることができます。利用できない場合、NotImplementedError が送出されます。

Raises an auditing event os.exec with arguments path, args, env.

Availability: Unix, Windows。

バージョン 3.3 で追加: Added support for specifying path as an open file descriptor for execve().

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os._exit(n)
終了ステータス n でプロセスを終了します。この時クリーンアップハンドラーの呼び出しや、標準入出力バッファのフラッシュなどは行いません。

注釈 終了する標準的な方法は sys.exit(n) です。 _exit() は通常、 fork() された後の子プロセスでのみ使われます。
以下の終了コードは必須ではありませんが _exit() で使うことができます。一般に、メールサーバーの外部コマンド配送プログラムのような、 Python で書かれたシステムプログラムに使います。

注釈 いくつかのバリエーションがあって、これらのすべてがすべての Unix プラットフォームで使えるわけではありません。以下の定数は下層のプラットフォームで定義されていれば定義されます。
os.EX_OK
エラーが起きなかったことを表す終了コード。

利用可能な環境: Unix。

os.EX_USAGE
誤った個数の引数が渡された時など、コマンドが間違って使われたことを表す終了コード。

利用可能な環境: Unix。

os.EX_DATAERR
入力データが誤っていたことを表す終了コード。

利用可能な環境: Unix。

os.EX_NOINPUT
入力ファイルが存在しなかった、または、読み込み不可だったことを表す終了コード。

利用可能な環境: Unix。

os.EX_NOUSER
指定されたユーザーが存在しなかったことを表す終了コード。

利用可能な環境: Unix。

os.EX_NOHOST
指定されたホストが存在しなかったことを表す終了コード。

利用可能な環境: Unix。

os.EX_UNAVAILABLE
要求されたサービスが利用できないことを表す終了コード。

利用可能な環境: Unix。

os.EX_SOFTWARE
内部ソフトウェアエラーが検出されたことを表す終了コード。

利用可能な環境: Unix。

os.EX_OSERR
fork できない、 pipe の作成ができないなど、オペレーティングシステムのエラーが検出されたことを表す終了コード。

利用可能な環境: Unix。

os.EX_OSFILE
システムファイルが存在しなかった、開けなかった、あるいはその他のエラーが起きたことを表す終了コード。

利用可能な環境: Unix。

os.EX_CANTCREAT
ユーザーには作成できない出力ファイルを指定したことを表す終了コード。

利用可能な環境: Unix。

os.EX_IOERR
ファイルの I/O を行っている途中にエラーが発生した時の終了コード。

利用可能な環境: Unix。

os.EX_TEMPFAIL
一時的な失敗が発生したことを表す終了コード。これは、再試行可能な操作の途中に、ネットワークに接続できないというような、実際にはエラーではないかも知れないことを意味します。

利用可能な環境: Unix。

os.EX_PROTOCOL
プロトコル交換が不正、不適切、または理解不能なことを表す終了コード。

利用可能な環境: Unix。

os.EX_NOPERM
操作を行うために十分な許可がなかった（ファイルシステムの問題を除く）ことを表す終了コード。

利用可能な環境: Unix。

os.EX_CONFIG
設定エラーが起こったことを表す終了コード。

利用可能な環境: Unix。

os.EX_NOTFOUND
"an entry was not found" のようなことを表す終了コード。

利用可能な環境: Unix。

os.fork()
子プロセスを fork します。子プロセスでは 0 が返り、親プロセスでは子プロセスの id が返ります。エラーが発生した場合は、 OSError を送出します。

Note that some platforms including FreeBSD <= 6.3 and Cygwin have known issues when using fork() from a thread.

Raises an auditing event os.fork with no arguments.

バージョン 3.8 で変更: Calling fork() in a subinterpreter is no longer supported (RuntimeError is raised).

警告 SSL モジュールを fork() とともに使うアプリケーションについて、 ssl を参照して下さい。
利用可能な環境: Unix。

os.forkpty()
子プロセスを fork します。この時新しい擬似端末を子プロセスの制御端末として使います。親プロセスでは (pid, fd) からなるペアが返り、 fd は擬似端末のマスター側のファイル記述子となります。可搬性のあるアプローチを取るには、 pty モジュールを利用してください。エラーが発生した場合は、 OSError を送出します。

Raises an auditing event os.forkpty with no arguments.

バージョン 3.8 で変更: Calling forkpty() in a subinterpreter is no longer supported (RuntimeError is raised).

利用できる環境: 一部の Unix 互換環境。

os.kill(pid, sig)
プロセス pid にシグナル sig を送ります。ホストプラットフォームで利用可能なシグナルを特定する定数は signal モジュールで定義されています。

Windows: signal.CTRL_C_EVENT と signal.CTRL_BREAK_EVENT は、同じコンソールウィンドウを共有しているコンソールプロセス ( 例 : 子プロセス ) にだけ送ることができる特別なシグナルです。その他の値を sig に与えると、そのプロセスが無条件に TerminateProcess API によって kill され、終了コードが sig に設定されます。 Windows の kill() は kill するプロセスのハンドルも受け取ります。

signal.pthread_kill() も参照してください。

Raises an auditing event os.kill with arguments pid, sig.

バージョン 3.2 で追加: Windows をサポートしました。

os.killpg(pgid, sig)
プロセスグループ pgid にシグナル sig を送ります。

Raises an auditing event os.killpg with arguments pgid, sig.

利用可能な環境: Unix。

os.nice(increment)
プロセスの "nice 値 " に increment を加えます。新たな nice 値を返します。

利用可能な環境: Unix。

os.pidfd_open(pid, flags=0)
Return a file descriptor referring to the process pid. This descriptor can be used to perform process management without races and signals. The flags argument is provided for future extensions; no flag values are currently defined.

See the pidfd_open(2) man page for more details.

Availability: Linux 5.3+

バージョン 3.9 で追加.

os.plock(op)
プログラムのセグメントをメモリ内にロックします。 op (<sys/lock.h> で定義されています ) にはどのセグメントをロックするかを指定します。

利用可能な環境: Unix。

os.popen(cmd, mode='r', buffering=-1)
コマンド cmd への、または cmd からのパイプ入出力を開きます。戻り値はパイプに接続されている開かれたファイルオブジェクトで、 mode が 'r' (デフォルト) または 'w' かによって読み出しまたは書き込みを行うことができます。引数 bufsize は、組み込み関数 open() における対応する引数と同じ意味を持ちます。 返されるファイルオブジェクトは、バイトではなくテキスト文字列を読み書きします。

close メソッドは、サブプロセスが正常に終了した場合は None を返し、エラーが発生した場合にはサブプロセスの返りコードを返します。POSIX システムでは、返りコードが正の場合、そのコードは1バイト左にシフトしてプロセスが終了したことを示します。返りコードが負の場合、プロセスは返りコードの符号を変えた信号により終了します 。 (例えば、サブプロセスが kill された場合、返り値は - signal.SIGKILL となる場合があります。) Windows システムでは、返り値には子プロセスからの符号のついた整数の返りコードを含まれます。

On Unix, waitstatus_to_exitcode() can be used to convert the close method result (exit status) into an exit code if it is not None. On Windows, the close method result is directly the exit code (or None).

これは、subprocess.Popen を使用して実装されています。サブプロセスを管理し、サブプロセスと通信を行うためのより強力な方法については、クラスのドキュメンテーションを参照してください。

os.posix_spawn(path, argv, env, *, file_actions=None, setpgroup=None, resetids=False, setsid=False, setsigmask=(), setsigdef=(), scheduler=None)
Wraps the posix_spawn() C library API for use from Python.

Most users should use subprocess.run() instead of posix_spawn().

The positional-only arguments path, args, and env are similar to execve().

The path parameter is the path to the executable file. The path should contain a directory. Use posix_spawnp() to pass an executable file without directory.

The file_actions argument may be a sequence of tuples describing actions to take on specific file descriptors in the child process between the C library implementation's fork() and exec() steps. The first item in each tuple must be one of the three type indicator listed below describing the remaining tuple elements:

os.POSIX_SPAWN_OPEN
(os.POSIX_SPAWN_OPEN, fd, path, flags, mode)

Performs os.dup2(os.open(path, flags, mode), fd).

os.POSIX_SPAWN_CLOSE
(os.POSIX_SPAWN_CLOSE, fd)

Performs os.close(fd).

os.POSIX_SPAWN_DUP2
(os.POSIX_SPAWN_DUP2, fd, new_fd)

Performs os.dup2(fd, new_fd).

These tuples correspond to the C library posix_spawn_file_actions_addopen(), posix_spawn_file_actions_addclose(), and posix_spawn_file_actions_adddup2() API calls used to prepare for the posix_spawn() call itself.

The setpgroup argument will set the process group of the child to the value specified. If the value specified is 0, the child's process group ID will be made the same as its process ID. If the value of setpgroup is not set, the child will inherit the parent's process group ID. This argument corresponds to the C library POSIX_SPAWN_SETPGROUP flag.

If the resetids argument is True it will reset the effective UID and GID of the child to the real UID and GID of the parent process. If the argument is False, then the child retains the effective UID and GID of the parent. In either case, if the set-user-ID and set-group-ID permission bits are enabled on the executable file, their effect will override the setting of the effective UID and GID. This argument corresponds to the C library POSIX_SPAWN_RESETIDS flag.

If the setsid argument is True, it will create a new session ID for posix_spawn. setsid requires POSIX_SPAWN_SETSID or POSIX_SPAWN_SETSID_NP flag. Otherwise, NotImplementedError is raised.

The setsigmask argument will set the signal mask to the signal set specified. If the parameter is not used, then the child inherits the parent's signal mask. This argument corresponds to the C library POSIX_SPAWN_SETSIGMASK flag.

The sigdef argument will reset the disposition of all signals in the set specified. This argument corresponds to the C library POSIX_SPAWN_SETSIGDEF flag.

The scheduler argument must be a tuple containing the (optional) scheduler policy and an instance of sched_param with the scheduler parameters. A value of None in the place of the scheduler policy indicates that is not being provided. This argument is a combination of the C library POSIX_SPAWN_SETSCHEDPARAM and POSIX_SPAWN_SETSCHEDULER flags.

Raises an auditing event os.posix_spawn with arguments path, argv, env.

バージョン 3.8 で追加.

利用可能な環境: Unix。

os.posix_spawnp(path, argv, env, *, file_actions=None, setpgroup=None, resetids=False, setsid=False, setsigmask=(), setsigdef=(), scheduler=None)
Wraps the posix_spawnp() C library API for use from Python.

Similar to posix_spawn() except that the system searches for the executable file in the list of directories specified by the PATH environment variable (in the same way as for execvp(3)).

Raises an auditing event os.posix_spawn with arguments path, argv, env.

バージョン 3.8 で追加.

Availability: See posix_spawn() documentation.

os.register_at_fork(*, before=None, after_in_parent=None, after_in_child=None)
Register callables to be executed when a new child process is forked using os.fork() or similar process cloning APIs. The parameters are optional and keyword-only. Each specifies a different call point.

before is a function called before forking a child process.

after_in_parent is a function called from the parent process after forking a child process.

after_in_child is a function called from the child process.

These calls are only made if control is expected to return to the Python interpreter. A typical subprocess launch will not trigger them as the child is not going to re-enter the interpreter.

Functions registered for execution before forking are called in reverse registration order. Functions registered for execution after forking (either in the parent or in the child) are called in registration order.

Note that fork() calls made by third-party C code may not call those functions, unless it explicitly calls PyOS_BeforeFork(), PyOS_AfterFork_Parent() and PyOS_AfterFork_Child().

There is no way to unregister a function.

利用可能な環境: Unix。

バージョン 3.7 で追加.

os.spawnl(mode, path, ...)
os.spawnle(mode, path, ..., env)
os.spawnlp(mode, file, ...)
os.spawnlpe(mode, file, ..., env)
os.spawnv(mode, path, args)
os.spawnve(mode, path, args, env)
os.spawnvp(mode, file, args)
os.spawnvpe(mode, file, args, env)
新たなプロセス内でプログラム path を実行します。

(subprocess モジュールが、新しいプロセスを実行して結果を取得するための、より強力な機能を提供しています。この関数の代わりに subprocess モジュールを利用することが推奨されています。 subprocess モジュールのドキュメントの、 古い関数を subprocess モジュールで置き換える セクションを参照してください )

mode が P_NOWAIT の場合、この関数は新たなプロセスのプロセス ID を返します ; mode が P_WAIT の場合、子プロセスが正常に終了するとその終了コードが返ります。そうでない場合にはプロセスを kill したシグナル signal に対して -signal が返ります。 Windows では、プロセス ID は実際にはプロセスハンドル値になるので、 waitpid() 関数で使えます。

Note on VxWorks, this function doesn't return -signal when the new process is killed. Instead it raises OSError exception.

"l" および "v" のついた spawn* 関数は、コマンドライン引数をどのように渡すかが異なります。 "l" 型は、コードを書くときにパラメタ数が決まっている場合に、おそらくもっとも簡単に利用できます。個々のパラメタは単に spawnl*() 関数の追加パラメタとなります。 "v" 型は、パラメタの数が可変の時に便利で、リストかタプルの引数が args パラメタとして渡されます。どちらの場合も、子プロセスに渡す引数は動作させようとしているコマンドの名前から始まらなければなりません。

末尾近くに "p" をもつ型 (spawnlp(), spawnlpe(), spawnvp(), spawnvpe()) は、プログラム file を探すために環境変数 PATH を利用します。環境変数が ( 次の段で述べる spawn*e 型関数で ) 置き換えられる場合、環境変数は PATH を決定する上の情報源として使われます。その他の型、 spawnl(), spawnle(), spawnv(), および spawnve() では、実行コードを探すために PATH を使いません。 path には適切に設定された絶対パスまたは相対パスが入っていなくてはなりません。

spawnle(), spawnlpe(), spawnve(), および spawnvpe() (すべて末尾に "e" がついています) では、 env 引数は新たなプロセスで利用される環境変数を定義するためのマップ型でなくてはなりません ; spawnl() 、 spawnlp() 、 spawnv() 、および spawnvp() では、すべて新たなプロセスは現在のプロセスの環境を引き継ぎます。 env 辞書のキーと値はすべて文字列である必要があります。不正なキーや値を与えると関数が失敗し、 127 を返します。

例えば、以下の spawnlp() および spawnvpe() 呼び出しは等価です

import os
os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')

L = ['cp', 'index.html', '/dev/null']
os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)
Raises an auditing event os.spawn with arguments mode, path, args, env.

Availability: Unix, Windows. spawnlp(), spawnlpe(), spawnvp() and spawnvpe() are not available on Windows. spawnle() and spawnve() are not thread-safe on Windows; we advise you to use the subprocess module instead.

バージョン 3.6 で変更: path-like object を受け入れるようになりました。

os.P_NOWAIT
os.P_NOWAITO
spawn* 関数ファミリに対する mode パラメタとして取れる値です。この値のいずれかを mode として与えた場合、 spawn*() 関数は新たなプロセスが生成されるとすぐに、プロセスの ID を戻り値として返ります。

Availability: Unix, Windows。

os.P_WAIT
spawn* 関数ファミリに対する mode パラメタとして取れる値です。この値を mode として与えた場合、 spawn*() 関数は新たなプロセスを起動して完了するまで返らず、プロセスがうまく終了した場合には終了コードを、シグナルによってプロセスが kill された場合には -signal を返します。

Availability: Unix, Windows。

os.P_DETACH
os.P_OVERLAY
spawn* 関数ファミリに対する mode パラメタとして取れる値です。これらの値は上の値よりもやや可搬性において劣っています。 P_DETACH は P_NOWAIT に似ていますが、新たなプロセスは呼び出しプロセスのコンソールから切り離され (detach) ます。 P_OVERLAY が使われた場合、現在のプロセスは置き換えられます。したがって spawn* は返りません。

利用可能な環境: Windows 。

os.startfile(path[, operation])
ファイルを関連付けられたアプリケーションを使ってスタートします。

operation が指定されないか、または 'open' である時、この動作は、 Windows の Explorer 上でのファイルをダブルクリックした、あるいはコマンドプロンプト上でファイル名を start コマンドの引数としての実行した場合と等価です : ファイルは拡張子が関連付けされているアプリケーション ( が存在する場合 ) を使って開かれます。

他の operation が与えられる場合、それはファイルに対して何がなされるべきかを表す "command verb" ( コマンドを表す動詞 ) でなければなりません。 Microsoft が文書化している動詞は、 'print' と 'edit' ( ファイルに対して ) および 'explore' と 'find' ( ディレクトリに対して ) です。

startfile() は関連付けされたアプリケーションが起動すると同時に返ります。アプリケーションが閉じるまで待機させるためのオプションはなく、アプリケーションの終了状態を取得する方法もありません。引数 path はカレントディレクトリからの相対パスです。絶対パスで指定したい場合は、最初の文字はスラッシュ ('/') ではないので注意してください。最初の文字がスラッシュの場合、下層の Win32 ShellExecute() 関数は動作しません。 os.path.normpath() 関数を使って、 Win32 用に正しくコード化されたパスになるようにしてください。

インタープリタの起動時のオーバーヘッドを削減するため、この関数が最初に呼ばれるまで、Win32 ShellExecute() 関数は決定されません。関数を決定できない場合、 NotImplementedError が送出されます。

Raises an auditing event os.startfile with arguments path, operation.

利用可能な環境: Windows 。

os.system(command)
サブシェル内でコマンド (文字列) を実行します。この関数は標準 C 関数 system() を使って実装されており、system() と同じ制限があります。sys.stdin などに対する変更を行っても、実行されるコマンドの環境には反映されません。command が何らかの出力を生成した場合、インタープリターの標準出力ストリームに送られます。

Unix では、返り値はプロセスの終了ステータスで、 wait() で定義されている書式にコード化されています。 POSIX は system() 関数の返り値の意味について定義していないので、 Python の system() における返り値はシステム依存となることに注意してください。

Windows では、返り値は command を実行した後にシステムシェルから返される値です。シェルは通常 cmd.exe であり、返す値は実行したコマンドの終了ステータスになります。シェルの種類は Windows の環境変数 COMSPEC: に指定されています。ネイティブでないシェルを使用している場合は、そのドキュメントを参照してください。

subprocess モジュールは、新しいプロセスを実行して結果を取得するためのより強力な機能を提供しています。この関数の代わりに subprocess モジュールを利用することが推奨されています。 subprocess モジュールのドキュメントの 古い関数を subprocess モジュールで置き換える 節のレシピを参考にして下さい。

On Unix, waitstatus_to_exitcode() can be used to convert the result (exit status) into an exit code. On Windows, the result is directly the exit code.

Raises an auditing event os.system with argument command.

Availability: Unix, Windows。

os.times()
現在の全体的なプロセス時間を返します。返り値は 5 個の属性を持つオブジェクトになります:

user - ユーザー時間

system - システム時間

children_user - すべての子プロセスのユーザー時間

children_system - すべての子プロセスのシステム時間

elapsed - 去のある固定時点からの経過実時間

後方互換性のため、このオブジェクトは 5 個のアイテム user 、 system 、 children_user 、 children_system 、および elapsed を持つタプルのようにも振る舞います。

See the Unix manual page times(2) and times(3) manual page on Unix or the GetProcessTimes MSDN on Windows. On Windows, only user and system are known; the other attributes are zero.

Availability: Unix, Windows。

バージョン 3.3 で変更: 返り値の型が、タプルから属性名のついたタプルライクオブジェクトに変更されました。

os.wait()
子プロセスの実行完了を待機し、子プロセスの pid と終了コードインジケーター --- 16 ビットの数値で、下位バイトがプロセスを kill したシグナル番号、上位バイトが終了ステータス ( シグナル番号がゼロの場合 ) --- の入ったタプルを返します ; コアダンプファイルが生成された場合、下位バイトの最上桁ビットが立てられます。

waitstatus_to_exitcode() can be used to convert the exit status into an exit code.

利用可能な環境: Unix。

参考 waitpid() can be used to wait for the completion of a specific child process and has more options.
os.waitid(idtype, id, options)
Wait for the completion of one or more child processes. idtype can be P_PID, P_PGID, P_ALL, or P_PIDFD on Linux. id specifies the pid to wait on. options is constructed from the ORing of one or more of WEXITED, WSTOPPED or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT. The return value is an object representing the data contained in the siginfo_t structure, namely: si_pid, si_uid, si_signo, si_status, si_code or None if WNOHANG is specified and there are no children in a waitable state.

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.P_PID
os.P_PGID
os.P_ALL
waitid() の idtype に指定できる値です。これらは id がどう解釈されるかに影響します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.P_PIDFD
This is a Linux-specific idtype that indicates that id is a file descriptor that refers to a process.

Availability: Linux 5.4+

バージョン 3.9 で追加.

os.WEXITED
os.WSTOPPED
os.WNOWAIT
waitid() の options で使用できるフラグです。子プロセスのどのシグナルを待機するかを指定します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

os.CLD_EXITED
os.CLD_KILLED
os.CLD_DUMPED
os.CLD_TRAPPED
os.CLD_STOPPED
os.CLD_CONTINUED
waitid() の返り値の si_code に設定され得る値です。

利用可能な環境: Unix。

バージョン 3.3 で追加.

バージョン 3.9 で変更: Added CLD_KILLED and CLD_STOPPED values.

os.waitpid(pid, options)
この関数の詳細は Unix と Windows で異なります。

Unix の場合 : プロセス id pid で与えられた子プロセスの完了を待機し、子プロセスのプロセス id と (wait() と同様にコード化された ) 終了ステータスインジケーターからなるタプルを返します。この関数の動作は options によって変わります。通常の操作では 0 にします。

pid が 0 よりも大きい場合、 waitpid() は特定のプロセスのステータス情報を要求します。 pid が 0 の場合、現在のプロセスグループ内の任意の子プロセスの状態に対する要求です。 pid が -1 の場合、現在のプロセスの任意の子プロセスに対する要求です。 pid が -1 よりも小さい場合、プロセスグループ -pid ( すなわち pid の絶対値 ) 内の任意のプロセスに対する要求です。

システムコールが -1 を返した時、 OSError を errno と共に送出します。

Windows では、プロセスハンドル pid を指定してプロセスの終了を待って、 pid と、終了ステータスを 8bit 左シフトした値のタプルを返します。 ( シフトは、この関数をクロスプラットフォームで利用しやすくするために行われます ) 0 以下の pid は Windows では特別な意味を持っておらず、例外を発生させます。 options の値は効果がありません。 pid は、子プロセスで無くても、プロセス ID を知っているどんなプロセスでも参照することが可能です。 spawn* 関数を P_NOWAIT と共に呼び出した場合、適切なプロセスハンドルが返されます。

waitstatus_to_exitcode() can be used to convert the exit status into an exit code.

バージョン 3.5 で変更: システムコールが中断されシグナルハンドラが例外を送出しなかった場合、この関数は InterruptedError 例外を送出する代わりにシステムコールを再試行するようになりました (論拠については PEP 475 を参照してください)。

os.wait3(options)
waitpid() に似ていますが、プロセス id を引数に取らず、子プロセス id 、終了ステータスインジケータ、リソース使用情報の 3 要素からなるタプルを返します。リソース使用情報の詳しい情報は resource. getrusage() を参照してください。 オプション引数は waitpid() および wait4() と同じです。

waitstatus_to_exitcode() can be used to convert the exit status into an exitcode.

利用可能な環境: Unix。

os.wait4(pid, options)
waitpid() に似ていますが、子プロセス id 、終了ステータスインジケータ、リソース使用情報の 3 要素からなるタプルを返します。リソース使用情報の詳しい情報は resource. getrusage() を参照してください。 wait4() の引数は waitpid() に与えられるものと同じです。

waitstatus_to_exitcode() can be used to convert the exit status into an exitcode.

利用可能な環境: Unix。

os.waitstatus_to_exitcode(status)
Convert a wait status to an exit code.

On Unix:

If the process exited normally (if WIFEXITED(status) is true), return the process exit status (return WEXITSTATUS(status)): result greater than or equal to 0.

If the process was terminated by a signal (if WIFSIGNALED(status) is true), return -signum where signum is the number of the signal that caused the process to terminate (return -WTERMSIG(status)): result less than 0.

Otherwise, raise a ValueError.

On Windows, return status shifted right by 8 bits.

On Unix, if the process is being traced or if waitpid() was called with WUNTRACED option, the caller must first check if WIFSTOPPED(status) is true. This function must not be called if WIFSTOPPED(status) is true.

参考 WIFEXITED(), WEXITSTATUS(), WIFSIGNALED(), WTERMSIG(), WIFSTOPPED(), WSTOPSIG() functions.
バージョン 3.9 で追加.

os.WNOHANG
子プロセス状態がすぐに取得できなかった場合に直ちに終了するようにするための waitpid() のオプションです。この場合、関数は (0, 0) を返します。

利用可能な環境: Unix。

os.WCONTINUED
このオプションによって子プロセスは前回状態が報告された後にジョブ制御による停止状態から実行を再開された場合に報告されるようになります。

Availability: some Unix systems.

os.WUNTRACED
このオプションによって子プロセスは停止されていながら停止されてから状態が報告されていない場合に報告されるようになります。

利用可能な環境: Unix。

以下の関数は system() 、 wait() 、あるいは waitpid() が返すプロセス状態コードを引数にとります。これらの関数はプロセスの配置を決めるために利用できます。

os.WCOREDUMP(status)
プロセスに対してコアダンプが生成されていた場合には True を、それ以外の場合は False を返します。

This function should be employed only if WIFSIGNALED() is true.

利用可能な環境: Unix。

os.WIFCONTINUED(status)
Return True if a stopped child has been resumed by delivery of SIGCONT (if the process has been continued from a job control stop), otherwise return False.

See WCONTINUED option.

利用可能な環境: Unix。

os.WIFSTOPPED(status)
Return True if the process was stopped by delivery of a signal, otherwise return False.

WIFSTOPPED() only returns True if the waitpid() call was done using WUNTRACED option or when the process is being traced (see ptrace(2)).

利用可能な環境: Unix。

os.WIFSIGNALED(status)
Return True if the process was terminated by a signal, otherwise return False.

利用可能な環境: Unix。

os.WIFEXITED(status)
Return True if the process exited terminated normally, that is, by calling exit() or _exit(), or by returning from main(); otherwise return False.

利用可能な環境: Unix。

os.WEXITSTATUS(status)
Return the process exit status.

This function should be employed only if WIFEXITED() is true.

利用可能な環境: Unix。

os.WSTOPSIG(status)
プロセスを停止させたシグナル番号を返します。

This function should be employed only if WIFSTOPPED() is true.

利用可能な環境: Unix。

os.WTERMSIG(status)
Return the number of the signal that caused the process to terminate.

This function should be employed only if WIFSIGNALED() is true.

利用可能な環境: Unix。

スケジューラーへのインターフェイス
以下の関数は、オペレーティングシステムがプロセスに CPU 時間を割り当てる方法を制御します。これらは一部の Unix プラットフォームでのみ利用可能です。詳しくは Unix マニュアルページを参照してください。

バージョン 3.3 で追加.

次のスケジューリングポリシーは、オペレーティングシステムでサポートされていれば公開されます。

os.SCHED_OTHER
デフォルトのスケジューリングポリシーです。

os.SCHED_BATCH
常にCPUに負荷のかかる (CPU-intensive) プロセス用のポリシーです。他の対話式プロセスなどの応答性を維持するよう試みます。

os.SCHED_IDLE
非常に優先度の低いバックグラウンドタスク用のスケジューリングポリシーです。

os.SCHED_SPORADIC
散発的なサーバープログラム用のスケジューリングポリシーです。

os.SCHED_FIFO
FIFO (First In, First Out) 型のスケジューリングポリシーです。

os.SCHED_RR
ラウンドロビン型のスケジューリングポリシーです。

os.SCHED_RESET_ON_FORK
このフラグは他のスケジューリングポリシーとともに論理和指定できます。このフラグが与えられたプロセスが fork されると、その子プロセスのスケジューリングポリシーおよび優先度はデフォルトにリセットされます。

class os.sched_param(sched_priority)
このクラスは、sched_setparam()、sched_setscheduler()、および sched_getparam() で使用される、調節可能なスケジューリングパラメーターを表します。これはイミュータブルです。

現在、一つの引数のみ指定できます:

sched_priority
スケジューリングポリシーのスケジューリング優先度です。

os.sched_get_priority_min(policy)
policy の最小優先度値を取得します。policy には上記のスケジューリングポリシー定数の一つを指定します。

os.sched_get_priority_max(policy)
policy の最大優先度値を取得します。policy には上記のスケジューリングポリシー定数の一つを指定します。

os.sched_setscheduler(pid, policy, param)
PID pid のプロセスのスケジューリングポリシーを設定します。pid が 0 の場合、呼び出しプロセスを意味します。policy には上記のスケジューリングポリシー定数の一つを指定します。param は sched_param のインスタンスです。

os.sched_getscheduler(pid)
PID pid のプロセスのスケジューリングポリシーを返します。pid が 0 の場合、呼び出しプロセスを意味します。返り値は上記のスケジューリングポリシー定数の一つになります。

os.sched_setparam(pid, param)
PID pid のプロセスのスケジュールパラメーターを設定します。pid が 0 の場合、呼び出しプロセスを意味します。param は sched_param のインスタンスです。

os.sched_getparam(pid)
PID pid のプロセスのスケジューリングパラメーターを sched_param のインスタンスとして返します。pid が 0 の場合、呼び出しプロセスを意味します。

os.sched_rr_get_interval(pid)
PID pid のプロセスのラウンドロビンクォンタム (秒) を返します。pid が 0 の場合、呼び出しプロセスを意味します。

os.sched_yield()
自発的に CPU を解放します。

os.sched_setaffinity(pid, mask)
PID pid のプロセス (0 であれば現在のプロセス) を CPU の集合に制限します。mask はプロセスを制限する CPU の集合を表す整数のイテラブルなオブジェクトです。

os.sched_getaffinity(pid)
PID pid のプロセス (0 の場合、現在のプロセス) が制限されている CPU の集合を返します。

雑多なシステム情報
os.confstr(name)
システム設定値を文字列で返します。 name には取得したい設定名を指定します ; この値は定義済みのシステム値名を表す文字列にすることができます ; 名前は多くの標準 (POSIX.1 、 Unix 95 、 Unix 98 その他 ) で定義されています。ホストオペレーティングシステムの関知する名前は confstr_names 辞書のキーとして与えられています。このマップ型オブジェクトに入っていない設定変数については、 name に整数を渡してもかまいません。

name に指定された設定値が定義されていない場合、 None を返します。

name が文字列で、かつ不明の場合、 ValueError を送出します。 name の指定値がホストシステムでサポートされておらず、 confstr_names にも入っていない場合、 errno.EINVAL をエラー番号として OSError を送出します。

利用可能な環境: Unix。

os.confstr_names
confstr() が受理する名前を、ホストオペレーティングシステムで定義されている整数値に対応付けている辞書です。この辞書はシステムでどの設定名が定義されているかを決定するために利用できます。

利用可能な環境: Unix。

os.cpu_count()
システムの CPU 数を返します。未定の場合は None を返します。

この数は現在のプロセスが使える CPU 数と同じものではありません。 使用可能な CPU 数は len(os.sched_getaffinity(0)) で取得できます。

バージョン 3.4 で追加.

os.getloadavg()
過去 1 分、 5 分、および 15 分間の、システムの実行キューの平均プロセス数を返します。平均負荷が得られない場合には OSError を送出します。

利用可能な環境: Unix。

os.sysconf(name)
整数値のシステム設定値を返します。 name で指定された設定値が定義されていない場合、 -1 が返されます。 name に関するコメントとしては、 confstr() で述べた内容が同様に当てはまります ; 既知の設定名についての情報を与える辞書は sysconf_names で与えられています。

利用可能な環境: Unix。

os.sysconf_names
sysconf() が受理する名前を、ホストオペレーティングシステムで定義されている整数値に対応付けている辞書です。この辞書はシステムでどの設定名が定義されているかを決定するために利用できます。

利用可能な環境: Unix。

以下のデータ値はパス名編集操作をサポートするために利用されます。これらの値はすべてのプラットフォームで定義されています。

パス名に対する高水準の操作は os.path モジュールで定義されています。

os.curdir
現在のディレクトリ参照するためにオペレーティングシステムで使われる文字列定数です。 POSIX と Windows では '.' になります。 os.path からも利用できます。

os.pardir
親ディレクトリを参照するためにオペレーティングシステムで使われる文字列定数です。 POSIX と Windows では '..' になります。 os.path からも利用できます。

os.sep
パス名を要素に分割するためにオペレーティングシステムで利用されている文字です。例えば POSIX では '/' で、 Windows では '\\' です。しかし、このことを知っているだけではパス名を解析したり、パス名同士を結合したりするには不十分です --- こうした操作には os.path.split() や os.path.join() を使用してください --- が、たまに便利なこともあります。 os.path からも利用できます。

os.altsep
文字パス名を要素に分割する際にオペレーティングシステムで利用されるもう一つの文字で、分割文字が一つしかない場合には None になります。この値は sep がバックスラッシュとなっている DOS や Windows システムでは '/' に設定されています。 os.path からも利用できます。

os.extsep
ベースのファイル名と拡張子を分ける文字です。例えば、 os.py であれば '.' です。 os.path からも利用できます。

os.pathsep
(PATH のような ) サーチパス内の要素を分割するためにオペレーティングシステムが慣習的に用いる文字で、 POSIX における ':' や DOS および Windows における ';' に相当します。 os.path からも利用できます。

os.defpath
exec*p* や spawn*p* において、環境変数辞書内に 'PATH' キーがない場合に使われる標準設定のサーチパスです。 os.path からも利用できます。

os.linesep
現在のプラットフォーム上で行を分割 ( あるいは終端 ) するために用いられている文字列です。この値は例えば POSIX での '\n' や Mac OS での '\r' のように、単一の文字にもなりますし、例えば Windows での '\r\n' のように複数の文字列にもなります。テキストモードで開いたファイルに書き込む時には、 os.linesep を利用しないでください。すべてのプラットフォームで、単一の '\n' を使用してください。

os.devnull
ヌルデバイスのファイルパスです。例えば POSIX では '/dev/null' で、 Windows では 'nul' です。この値は os.path からも利用できます。

os.RTLD_LAZY
os.RTLD_NOW
os.RTLD_GLOBAL
os.RTLD_LOCAL
os.RTLD_NODELETE
os.RTLD_NOLOAD
os.RTLD_DEEPBIND
setdlopenflags() 関数と getdlopenflags() 関数と一緒に使用するフラグ。それぞれのフラグの意味については、Unix マニュアルの dlopen(3) ページを参照してください。

バージョン 3.3 で追加.

乱数
os.getrandom(size, flags=0)
最大で size バイトからなるランダムなバイト列を返します。この関数は要求されたバイト数よりも少ないバイト数を返すことがあります。

バイト列は、ユーザー空間の乱数生成器や暗号目的ののシードとして利用できます。

getrandom() はデバイスドライバや他の環境ノイズ源から収集されたエントロピーに頼っています。不必要な大量のデータの読出しは、/dev/random と /dev/urandom デバイスの他のユーザーに負の影響を与えるでしょう。

The flags argument is a bit mask that can contain zero or more of the following values ORed together: os.GRND_RANDOM and GRND_NONBLOCK.

Linux getrandom() manual page も参照してください。

Availability: Linux 3.17 and newer.

バージョン 3.6 で追加.

os.urandom(size)
暗号に関する用途に適した size バイトからなるランダムな文字列を返します。

この関数は OS 固有の乱数発生源からランダムなバイト列を生成して返します。この関数の返すデータは暗号を用いたアプリケーションで十分利用できる程度に予測不能ですが、実際のクオリティは OS の実装によって異なります。

On Linux, if the getrandom() syscall is available, it is used in blocking mode: block until the system urandom entropy pool is initialized (128 bits of entropy are collected by the kernel). See the PEP 524 for the rationale. On Linux, the getrandom() function can be used to get random bytes in non-blocking mode (using the GRND_NONBLOCK flag) or to poll until the system urandom entropy pool is initialized.

On a Unix-like system, random bytes are read from the /dev/urandom device. If the /dev/urandom device is not available or not readable, the NotImplementedError exception is raised.

Windowsで、 CryptGenRandom() を使用します。

参考 The secrets module provides higher level functions. For an easy-to-use interface to the random number generator provided by your platform, please see random.SystemRandom.
バージョン 3.6.0 で変更: Linuxで、 セキュリティを高めるために、getrandom() をブロッキングモードで使用するようになりました。

バージョン 3.5.2 で変更: Linux において、 getrandom() システムコールがブロックするなら (urandom エントロピープールが初期化されていなければ) 、 /dev/urandom を読む方法にフォールバックします。

バージョン 3.5 で変更: Linux 3.17 以降では、使用可能な場合に getrandom() システムコールが使用されるようになりました。OpenBSD 5.6 以降では、C getentropy() 関数が使用されるようになりました。これらの関数は、内部ファイル記述子を使用しません。

os.GRND_NONBLOCK
By default, when reading from /dev/random, getrandom() blocks if no random bytes are available, and when reading from /dev/urandom, it blocks if the entropy pool has not yet been initialized.

If the GRND_NONBLOCK flag is set, then getrandom() does not block in these cases, but instead immediately raises BlockingIOError.

バージョン 3.6 で追加.

os.GRND_RANDOM
If this bit is set, then random bytes are drawn from the /dev/random pool instead of the /dev/urandom pool.

バージョン 3.6 で追加.

io --- ストリームを扱うコアツール
ソースコード: Lib/io.py

概要
io モジュールは様々な種類の I/O を扱う Python の主要な機能を提供しています。 I/O には主に3つの種類があります; テキスト I/O, バイナリ I/O, raw I/O です。これらは汎用的なカテゴリで、各カテゴリには様々なストレージが利用されます。これらのいずれかのカテゴリに属する具象オブジェクトは全て file object と呼ばれます。他によく使われる用語として ストリーム と file-like オブジェクト があります。

それぞれの具象ストリームオブジェクトは、カテゴリに応じた機能を持ちます。ストリームは読み込み専用、書き込み専用、読み書き可能のいずかになります。任意のランダムアクセス（前方、後方の任意の場所にシークする）が可能かもしれませんし、シーケンシャルアクセスしかできないかもしれません（例えばソケットやパイプなど）。

全てのストリームは、与えられたデータの型に対して厳密です。例えば、バイナリストリームの write() メソッドに対して str オブジェクトを渡すと TypeError 例外を発生させます。テキストストリームの write() メソッドに bytes オブジェクトを渡しても同じです。

バージョン 3.3 で変更: 以前 IOError を送出していた操作が OSError を送出するようになりました。 IOError は今は OSError の別名です。

テキスト I/O
テキスト I/O は、 str オブジェクトを受け取り、生成します。すなわち、背後にあるストレージがバイト列 (例えばファイルなど) を格納するときは常に、透過的にデータのエンコード・デコードを行ない、オプションでプラットフォーム依存の改行文字変換を行います。

テキストストリームを作る一番簡単な方法は、オプションでエンコーディングを指定して、 open() を利用することです:

f = open("myfile.txt", "r", encoding="utf-8")
StringIO オブジェクトはインメモリーのテキストストリームです:

f = io.StringIO("some initial text data")
テキストストリームの API は TextIOBase のドキュメントで詳しく解説します。

バイナリ I/O
バイナリー I/O (buffered I/O とも呼ばれます) は bytes-like オブジェクト を受け取り bytes オブジェクトを生成します。エンコード、デコード、改行文字変換は一切行いません。このカテゴリのストリームは全ての非テキストデータや、テキストデータの扱いを手動で管理したい場合に利用することができます。

バイナリーストリームを生成する一番簡単な方法は、 open() の mode 文字列に 'b' を指定することです:

f = open("myfile.jpg", "rb")
BytesIO はインメモリーのバイナリストリームです:

f = io.BytesIO(b"some initial binary data: \x00\x01")
バイナリーストリーム API は BufferedIOBase のドキュメントで詳しく解説します。

他のライブラリモジュールが、別のテキスト・バイナリーストリームを生成する方法を提供しています。例えば socket.socket.makefile() などです。

Raw I/O
Raw I/O (unbuffered I/O とも呼ばれます) は、バイナリーストリームやテキストストリームの低水準の部品としてよく利用されます。ユーザーコードで直接 raw ストリームを扱うべき場面は滅多にありません。とはいえ、バッファリングを無効にしてファイルをバイナリーモードで開くことで raw ストリームを作ることができます:

f = open("myfile.jpg", "rb", buffering=0)
raw ストリーム API は RawIOBase のドキュメントで詳しく解説します。

高水準のモジュールインターフェイス
io.DEFAULT_BUFFER_SIZE
このモジュールの buffered I/O クラスで利用されるデフォルトのバッファーサイズを表す整数です。可能であれば、open() は file の blksize (os.stat() で取得される) を利用します。

io.open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
組み込みの open() 関数のエイリアスです。

引数 path, mode, flags を指定して 監査イベント open を送出します。

io.open_code(path)
Opens the provided file with mode 'rb'. This function should be used when the intent is to treat the contents as executable code.

path should be a str and an absolute path.

The behavior of this function may be overridden by an earlier call to the PyFile_SetOpenCodeHook(). However, assuming that path is a str and an absolute path, open_code(path) should always behave the same as open(path, 'rb'). Overriding the behavior is intended for additional validation or preprocessing of the file.

バージョン 3.8 で追加.

exception io.BlockingIOError
互換性のための、組み込みの BlockingIOError 例外のエイリアスです。

exception io.UnsupportedOperation
OSError と ValueError を継承した例外です。ストリームがサポートしていない操作を行おうとした時に送出されます。

インメモリー ストリーム
str や bytes-like オブジェクト を、読み書き可能なファイルのように扱うことができます。 StringIO は文字列に対して、テキストモードで開かれたファイルのように使うことができます。 BytesIO はバイナリーモードで開いたファイルのように扱うことができます。この2つのクラスは、読み書き可能で、ランダムアクセス可能です。

参考
sys
標準 IO ストリームを持っています: sys.stdin, sys.stdout, sys.stderr。

クラス階層
I/O ストリームの実装はクラス階層に分けて整理されています。まずストリームのカテゴリを分類するための 抽象基底クラス (ABC) があり、続いて標準のストリーム実装を行う具象クラス群があります。

注釈 抽象基底クラス群は、具象ストリームクラスの実装を助けるために、いくつかのデフォルトの実装を提供しています。例えば、 BufferedIOBase は readinto() と readline() の最適化されていない実装を提供しています。
I/O 階層の最上位には抽象基底クラスの IOBase があります。 IOBase ではストリームに対して基本的なインタフェースを定義しています。 しかしながら、ストリームに対する読み込みと書き込みが分離されていないことに注意してください。 実装においては与えられた操作をサポートしない場合は UnsupportedOperation を送出することが許されています。

RawIOBase ABC は IOBase を拡張します。このクラスはストリームからの bytes の読み書きを扱います。 FileIO は、 RawIOBase を継承してマシンのファイルシステム中のファイルへのインタフェースを提供します。

The BufferedIOBase ABC extends IOBase. It deals with buffering on a raw binary stream (RawIOBase). Its subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer raw binary streams that are readable, writable, and both readable and writable, respectively. BufferedRandom provides a buffered interface to seekable streams. Another BufferedIOBase subclass, BytesIO, is a stream of in-memory bytes.

The TextIOBase ABC extends IOBase. It deals with streams whose bytes represent text, and handles encoding and decoding to and from strings. TextIOWrapper, which extends TextIOBase, is a buffered text interface to a buffered raw stream (BufferedIOBase). Finally, StringIO is an in-memory stream for text.

引数名は規約に含まれていません。 そして open() の引数だけがキーワード引数として用いられることが意図されています。

次のテーブルは io モジュールが提供する ABC の概要です:

ABC

継承元

スタブメソッド

Mixin するメソッドとプロパティ

IOBase

fileno, seek, truncate

close, closed, __enter__, __exit__, flush, isatty, __iter__, __next__, readable, readline, readlines, seekable, tell, writable, writelines

RawIOBase

IOBase

readinto, write

IOBase から継承したメソッド、 read, readall

BufferedIOBase

IOBase

detach, read, read1, write

IOBase から継承したメソッド、 readinto, readinto1

TextIOBase

IOBase

detach, read, readline, write

IOBase から継承したメソッド、 encoding, errors, newlines

I/O 基底クラス
class io.IOBase
すべての I/O クラスの抽象基底クラスです。バイトストリームへの操作を行います。パブリックなコンストラクタはありません。

継承先のクラスが選択的にオーバライドできるように、このクラスは多くのメソッドに空の抽象実装をしています。デフォルトの実装では、読み込み、書き込み、シークができないファイルを表現します。

IOBase では read(), write() が宣言されていませんが、これはシグナチャが変化するためで、実装やクライアントはこれらのメソッドをインタフェースの一部として考えるべきです。 また、実装はサポートしていない操作を呼び出されたときは ValueError (または UnsupportedOperation) を発生させるかもしれません。

ファイルへのバイナリデータの読み書きに用いられる基本型は bytes です。 他の bytes-like オブジェクト もメソッドの引数として受け付けられます。 テキスト I/O クラスは str データを扱います。

閉じられたストリームに対するメソッド呼び出しは (問い合わせであっても) 未定義です。この場合、実装は ValueError を送出することがあります。

IOBase (とそのサブクラス) はイテレータプロトコルをサポートします。 IOBase オブジェクトをイテレートすると、ストリーム内の行が yield されます。ストリーム内の行の定義は、そのストリームが (バイト列を yield する) バイナリストリームか (文字列を yield する) テキストストリームかによって、 少し異なります。下の readline() を参照してください。

IOBase はコンテキストマネージャでもあります。そのため with 構文をサポートします。 次の例では、 with 構文が終わった後で---たとえ例外が発生した場合でも、 file は閉じられます。

with open('spam.txt', 'w') as file:
    file.write('Spam and eggs!')
IOBase は以下のデータ属性とメソッドを提供します:

close()
このストリームをフラッシュして閉じます。このメソッドはファイルが既に閉じられていた場合は特に何の効果もありません。いったんファイルが閉じられると、すべてのファイルに対する操作 (例えば読み込みや書き込み) で ValueError が発生します。

利便性のためにこのメソッドを複数回呼ぶことは許されています。しかし、効果があるのは最初の1回だけです。

closed
ストリームが閉じられていた場合 True になります。

fileno()
ストリームが保持しているファイル記述子 (整数値) が存在する場合はそれを返します。もし IO オブジェクトがファイル記述子を使っていない場合は OSError が発生します。

flush()
適用可能であればストリームの書き込みバッファをフラッシュします。読み出し専用や非ブロッキングストリームでは何もしません。

isatty()
ストリームが対話的であれば (つまりターミナルや tty デバイスにつながっている場合) True を返します。

readable()
ストリームが読み込める場合 True を返します。 False の場合は read() は OSError を発生させます。

readline(size=-1)
ストリームから 1 行読み込んで返します。もし size が指定された場合、最大で size バイトが読み込まれます。

バイナリファイルでは行末文字は常に b'\n' となります。テキストファイルでは、認識される行末文字を選択するために open() に対する newline 引数が使われます。

readlines(hint=-1)
ストリームから行のリストを読み込んで返します。 hint を指定することで、読み込む行数を制御できます。もし読み込んだすべての行のサイズ (バイト数、もしくは文字数) が hint の値を超えた場合、読み込みをそこで終了します。

ただし、 file.readlines() を呼びださなくても for line in file: ... のように file オブジェクトを直接イテレートすることができます。

seek(offset, whence=SEEK_SET)
ストリーム位置を指定された offset バイトに変更します。offset は whence で指定された位置からの相対位置として解釈されます。 whence のデフォルト値は SEEK_SET です。 whence に指定できる値は:

SEEK_SET または 0 -- ストリームの先頭 (デフォルト)。 offset は 0 もしくは正の値でなければなりません。

SEEK_CUR または 1 -- 現在のストリーム位置。 offset は負の値も可能です。

SEEK_END または 2 -- ストリームの末尾。 offset は通常負の値です。

新しい絶対位置を返します。

バージョン 3.1 で追加: SEEK_* 定数.

バージョン 3.3 で追加: 一部のオペレーティングシステムは os.SEEK_HOLE や os.SEEK_DATA など、追加の値をサポートすることがあります。ファイルに対して利用できる値は、そのファイルがテキストモードで開かれたかバイナリモードで開かれたかに依存します。

seekable()
ストリームがランダムアクセスをサポートしている場合、 True を返します。 False の場合、 seek()、 tell()、 truncate() を使用すると OSError を発生させます。

tell()
現在のストリーム位置を返します。

truncate(size=None)
ストリームのサイズを、指定された size バイト (または size が指定されていない場合、現在位置) に変更します。現在のストリーム位置は変更されません。このサイズ変更により、現在のファイルサイズを拡大または縮小させることができます。拡大の場合には、新しいファイル領域の内容はプラットホームによって異なります (ほとんどのシステムでは、追加のバイトが 0 で埋められます)。新しいファイルサイズが返されます。

バージョン 3.5 で変更: Windows で、拡大時に追加領域を 0 で埋めるようになりました。

writable()
ストリームが書き込みをサポートしている場合 True を返します。 False の場合は write()、 truncate() は OSError を返します。

writelines(lines)
ストリームに行のリストを書き込みます。行区切り文字は追加されないので、書き込む各行の行末に行区切り文字を含ませるのが一般的です。

__del__()
オブジェクトの破壊の用意をします。このメソッドはインスタンスの close() メソッドを呼びます。 IOBase はこのメソッドのデフォルトの実装を提供します

class io.RawIOBase
Base class for raw binary streams. It inherits IOBase. There is no public constructor.

Raw binary streams typically provide low-level access to an underlying OS device or API, and do not try to encapsulate it in high-level primitives (this functionality is done at a higher-level in buffered binary streams and text streams, described later in this page).

RawIOBase provides these methods in addition to those from IOBase:

read(size=-1)
オブジェクトを size バイトまで読み込み、それを返します。 簡単のため、 size が指定されていないか -1 の場合は、 EOF までの全てのバイトを返します。 そうでない場合は、システムコール呼び出しが一度だけ行われます。 オペレーティングシステムコールから返ってきたものが size バイトより少なければ、 size バイトより少ない返り値になることがあります。

size が 0 でないのに 0 バイトが返った場合、それはファイルの終端を表します。オブジェクトがノンブロッキングモードで、1 バイトも読み込めなければ、None が返されます。

デフォルトの実装は readall() と readinto() に従います。

readall()
EOF までストリームからすべてのバイトを読み込みます。必要な場合はストリームに対して複数の呼び出しをします。

readinto(b)
あらかじめ確保された書き込み可能な bytes 類オブジェクト b にバイト列を読み込み、読み込んだバイト数を返します。 例えば、 b は bytearray です。 オブジェクトがノンブロッキングモードで、 1 バイトも読み込めなければ、 None が返されます。

write(b)
与えられた bytes-like オブジェクト b を生ストリームに書き込み、書き込んだバイト数を返します。これは、根底の生ストリームの性質や、特にノンブロッキングである場合に、 b のバイト数より小さくなることがあります。生ストリームがブロックされないように設定されていて、かつ1バイトも即座に書き込むことができなければ、 None が返されます。このメソッドから返った後で呼び出し元は b を解放したり変更したりするかもしれないので、実装はメソッド呼び出しの間だけ b にアクセスすべきです。

class io.BufferedIOBase
何らかのバッファリングをサポートするバイナリストリームの基底クラスです。 IOBase を継承します。パブリックなコンストラクタはありません。

RawIOBase との主な違いは、メソッド read()、 readinto() および write() は 、ことによると複数回のシステムコールを行って、(それぞれ) 要求されただけの入力を読み込もうとしたり与えられた出力の全てを消費しようとしたりする点です。

加えて、元になる生ストリームが非ブロッキングモードでかつ準備ができていない場合に、これらのメソッドは、 BlockingIOError を送出するかもしれません。対応する RawIOBase バージョンと違って、 None を返すことはありません。

さらに、 read() メソッドは、 readinto() に従うデフォルト実装を持ちません。

通常の BufferedIOBase 実装は RawIOBase 実装を継承せずに、 BufferedWriter と BufferedReader がするようにこれをラップすべきです。

BufferedIOBase provides or overrides these data attributes and methods in addition to those from IOBase:

raw
BufferedIOBase が扱う根底の生ストリーム (RawIOBase インスタンス) を返します。これは BufferedIOBase API には含まれず、よって実装に含まれないことがあります。

detach()
根底の生ストリームをバッファから分離して返します。

生ストリームが取り外された後、バッファは使用不能状態になります。

バッファには、 BytesIO など、このメソッドで返される単体のストリームという概念を持たないものがあります。これらは UnsupportedOperation を送出します。

バージョン 3.1 で追加.

read(size=-1)
最大で size バイト読み込んで返します。 引数が省略されるか、 None か、または負の値であった場合、 データは EOF に到達するまで読み込まれます。 ストリームが既に EOF に到達していた場合は空の bytes オブジェクトが返されます。

引数が正で、元になる生ストリームが対話的でなければ、必要なバイト数を満たすように複数回の生 read が発行されるかもしれません (先に EOF に到達しない限りは)。対話的な場合は、最大で一回の raw read しか発行されず、短い結果でも EOF に達したことを意味しません。

元になる生ストリームがノンブロッキングモードで、呼び出された時点でデータを持っていなければ、 BlockingIOError が送出されます。

read1([size])
根底の raw ストリームの read() (または readinto() ) メソッドを高々 1 回呼び出し、最大で size バイト読み込み、返します。これは、 BufferedIOBase オブジェクトの上に独自のバッファリングを実装するときに便利です。

size に ``-1``（デフォルト値)を指定すると任意バイト長を返します（EOFに到達していなければ返されるバイト数は 0 より大きくなります）

readinto(b)
あらかじめ確保された書き込み可能な bytes 類オブジェクト b にバイト列を読み込み、読み込んだバイト数を返します。 例えば、 b は bytearray です。

read() と同様に、下層の raw ストリームが対話的でない限り、複数の読み込みは下層の raw ストリームに与えられるかもしれません。

元になる生ストリームがノンブロッキングモードで、呼び出された時点でデータを持っていなければ、 BlockingIOError が送出されます。

readinto1(b)
根底の raw ストリームの read() (または readinto()) メソッドを高々 1 回呼び出し、あらかじめ確保された書き込み可能な bytes-like オブジェクト b にバイト列を読み込みます。読み込んだバイト数を返します。

元になる生ストリームがノンブロッキングモードで、呼び出された時点でデータを持っていなければ、 BlockingIOError が送出されます。

バージョン 3.5 で追加.

write(b)
与えられた bytes-like オブジェクト b を書き込み、書き込んだバイト数を返します (これは常に b のバイト数と等しくなります。なぜなら、もし書き込みに失敗した場合は OSError が発生するからです)。実際の実装に依存して、これらのバイト列は根底のストリームに即座に書き込まれることもあれば、パフォーマンスやレイテンシの関係でバッファに保持されることもあります。

ノンブロッキングモードであるとき、バッファが満杯で根底の生ストリームが書き込み時点でさらなるデータを受け付けられない場合 BlockingIOError が送出されます。

このメソッドが戻った後で、呼び出し元は b を解放、または変更するかもしれないので、実装はメソッド呼び出しの間だけ b にアクセスすべきです。

生ファイルI/O
class io.FileIO(name, mode='r', closefd=True, opener=None)
A raw binary stream representing an OS-level file containing bytes data. It inherits RawIOBase.

name は、次の 2 つのいずれかです。

開くファイルへのパスを表す文字列または bytes オブジェクト。 この場合、closefd は True (デフォルト) でなければなりません。 True でない場合、エラーが送出されます。

結果の FileIO オブジェクトがアクセスを与える、既存の OS レベルファイル記述子の数を表す整数。FileIO オブジェクトが閉じられると、closefd が False に設定されていない場合、この fd も閉じられます。

mode は 読み込み（デフォルト）、書き込み、排他的作成、追記に対し 'r' 、 'w' 、 'x' 、 'a' です。ファイルは書き込みや追記で開かれたときに存在しない場合作成されます。書き込みのときにファイルの内容は破棄されます。作成時に既に存在する場合は FileExistsError が送出されます。作成のためにファイルを開くのは暗黙的に書き込みなので、このモードは 'w' と同じように振る舞います。読み込みと書き込みを同時に許可するにはモードに '+' を加えてください。

このクラスの read() (正の引数で呼び出されたとき), readinto() および write() メソッドは、単にシステムコールを一度呼び出します。

呼び出し可能オブジェクトを opener として与えることで、カスタムのオープナーが使えます。そしてファイルオブジェクトの基底のファイルディスクリプタは、opener を (name, flags) で呼び出して得られます。opener は開いたファイルディスクリプタを返さなければなりません。 (os.open を opener として渡すと、None を渡したのと同様の機能になります。)

新たに作成されたファイルは 継承不可 です。

opener 引数を使う例については open() 組み込み関数を参照してください。

バージョン 3.3 で変更: opener 引数が追加されました。'x' モードが追加されました。

バージョン 3.4 で変更: ファイルが継承不可になりました。

FileIO provides these data attributes in addition to those from RawIOBase and IOBase:

mode
コンストラクタに渡されたモードです。

name
ファイル名。コンストラクタに名前が渡されなかったときはファイル記述子になります。

バッファ付きストリーム
バッファ付き I/O ストリームは、I/O デバイスに生 I/O より高レベルなインタフェースを提供します。

class io.BytesIO([initial_bytes])
A binary stream using an in-memory bytes buffer. It inherits BufferedIOBase. The buffer is discarded when the close() method is called.

省略可能な引数 initial_bytes は、初期データを含んだ bytes-like オブジェクト です。

BytesIO は BufferedIOBase または IOBase からのメソッドに加えて、以下のメソッドを提供もしくはオーバーライドします:

getbuffer()
バッファの内容をコピーすることなく、その内容の上に、読み込み及び書き込みが可能なビューを返します。また、このビューを変更すると、バッファの内容は透過的に更新されます:

>>>
>>> b = io.BytesIO(b"abcdef")
>>> view = b.getbuffer()
>>> view[2:4] = b"56"
>>> b.getvalue()
b'ab56ef'
注釈 ビューが存在する限り、BytesIO オブジェクトはリサイズやクローズされません。
バージョン 3.2 で追加.

getvalue()
バッファの全内容を含む bytes を返します。

read1([size])
BytesIO においては、このメソッドは read() と同じです。

バージョン 3.7 で変更: size 引数が任意になりました。

readinto1(b)
BytesIO においては、このメソッドは readinto() と同じです。

バージョン 3.5 で追加.

class io.BufferedReader(raw, buffer_size=DEFAULT_BUFFER_SIZE)
A buffered binary stream providing higher-level access to a readable, non seekable RawIOBase raw binary stream. It inherits BufferedIOBase.

When reading data from this object, a larger amount of data may be requested from the underlying raw stream, and kept in an internal buffer. The buffered data can then be returned directly on subsequent reads.

このコンストラクタは与えられた raw ストリームと buffer_size に対し BufferedReader を生成します。 buffer_size が省略された場合、代わりに DEFAULT_BUFFER_SIZE が使われます。

BufferedReader は BufferedIOBase または IOBase からのメソッドに加えて、以下のメソッドを提供もしくはオーバーライドします:

peek([size])
位置を進めずにストリームからバイト列を返します。これを果たすために生ストリームに対して行われる read は高々一度だけです。返されるバイト数は、要求より少ないかもしれませんし、多いかもしれません。

read([size])
size バイトを読み込んで返します。size が与えられないか負の値ならば、EOF まで、または非ブロッキングモード中で read 呼び出しがブロックされるまでを返します。

read1([size])
raw ストリームに対しただ一度の呼び出しで最大 size バイトを読み込んで返します。少なくとも 1 バイトがバッファされていれば、バッファされているバイト列だけが返されます。それ以外の場合は raw ストリームの読み込みが一回呼び出されます。

バージョン 3.7 で変更: size 引数が任意になりました。

class io.BufferedWriter(raw, buffer_size=DEFAULT_BUFFER_SIZE)
A buffered binary stream providing higher-level access to a writeable, non seekable RawIOBase raw binary stream. It inherits BufferedIOBase.

When writing to this object, data is normally placed into an internal buffer. The buffer will be written out to the underlying RawIOBase object under various conditions, including:

保留中の全データに対してバッファが足りなくなったとき;

flush() が呼び出されたとき;

seek() が (BufferedRandom オブジェクトに対して) 呼び出されたとき;

BufferedWriter オブジェクトが閉じられたり破棄されたりしたとき。

このコンストラクタは与えられた書き込み可能な raw ストリームに対し BufferedWriter を生成します。 buffer_size が省略された場合、 DEFAULT_BUFFER_SIZE がデフォルトになります。

BufferedWriter は BufferedIOBase または IOBase からのメソッドに加えて、以下のメソッドを提供もしくはオーバーライドします:

flush()
バッファに保持されたバイト列を生ストリームに強制的に流し込みます。生ストリームがブロックした場合 BlockingIOError が送出されます。

write(b)
bytes-like オブジェクト b を書き込み、書き込んだバイト数を返します。ノンブロッキング時、バッファが書き込まれるべきなのに生ストリームがブロックした場合 BlockingIOError が送出されます。

class io.BufferedRandom(raw, buffer_size=DEFAULT_BUFFER_SIZE)
A buffered binary stream providing higher-level access to a seekable RawIOBase raw binary stream. It inherits BufferedReader and BufferedWriter.

このコンストラクタは第一引数として与えられるシーク可能な生ストリームに対し、リーダーおよびライターを作成します。 buffer_size が省略された場合、 DEFAULT_BUFFER_SIZE がデフォルトになります。

BufferedRandom is capable of anything BufferedReader or BufferedWriter can do. In addition, seek() and tell() are guaranteed to be implemented.

class io.BufferedRWPair(reader, writer, buffer_size=DEFAULT_BUFFER_SIZE)
A buffered binary stream providing higher-level access to two non seekable RawIOBase raw binary streams---one readable, the other writeable. It inherits BufferedIOBase.

reader と writer はそれぞれ読み込み可能、書き込み可能な RawIOBase オブジェクトです。 buffer_size が省略された場合 DEFAULT_BUFFER_SIZE がデフォルトになります。

BufferedRWPair は、 UnsupportedOperation を送出する detach() を除く、 BufferedIOBase の全てのメソッドを実装します。

警告 BufferedRWPair は下層の生ストリームのアクセスを同期しようとはしません。同じオブジェクトをリーダとライタとして渡してはいけません。その場合は代わりに BufferedRandom を使用してください。
テキスト I/O
class io.TextIOBase
Base class for text streams. This class provides a character and line based interface to stream I/O. It inherits IOBase. There is no public constructor.

IOBase から継承した属性とメソッドに加えて、 TextIOBase は以下のデータ属性とメソッドを提供しています:

encoding
エンコーディング名で、ストリームのバイト列を文字列にデコードするとき、また文字列をバイト列にエンコードするときに使われます。

errors
このエンコーダやデコーダのエラー設定です。

newlines
文字列、文字列のタプル、または None で、改行がどのように読み換えられるかを指定します。実装や内部コンストラクタのフラグに依って、これは利用できないことがあります。

buffer
TextIOBase が扱う根底のバイナリバッファ (BufferedIOBase インスタンス) です。これは TextIOBase API には含まれず、よって実装に含まれない場合があります。

detach()
根底のバイナリバッファを TextIOBase から分離して返します。

根底のバッファが取り外された後、 TextIOBase は使用不能状態になります。

TextIOBase 実装には、 StringIO など、根底のバッファという概念を持たないものがあります。これらを呼び出すと UnsupportedOperation を送出します。

バージョン 3.1 で追加.

read(size=-1)
最大 size 文字をストリームから読み込み、一つの str にして返します。 size が負の値または None ならば、 EOF まで読みます。

readline(size=-1)
改行または EOF まで読み込み、一つの str を返します。ストリームが既に EOF に到達している場合、空文字列が返されます。

size が指定された場合、最大 size 文字が読み込まれます。

seek(offset, whence=SEEK_SET)
指定された offset にストリーム位置を変更します。 挙動は whence 引数によります。 whence のデフォルト値は SEEK_SET です。:

SEEK_SET または 0: ストリームの先頭からシークします (デフォルト)。 offset は TextIOBase.tell() が返す数か0のどちらかでなければなりません。それ以外の offset 値は未定義の挙動を起こします。

SEEK_CUR または 1: 現在の位置に "シークします"。 offset は 0 でなければなりません。つまり何もしません (他の値はサポートされていません)。

SEEK_END または 2: ストリーム終端へシークします。 offset は 0 でなければなりません (他の値はサポートされていません)．

新しい絶対位置を、不透明な数値で返します。

バージョン 3.1 で追加: SEEK_* 定数.

tell()
ストリームの現在位置を不透明な数値で返します。この値は根底のバイナリストレージ内でのバイト数を表すとは限りません。

write(s)
文字列 s をストリームに書き出し、書き出された文字数を返します。

class io.TextIOWrapper(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)
A buffered text stream providing higher-level access to a BufferedIOBase buffered binary stream. It inherits TextIOBase.

encoding はストリームがエンコードやデコードされるエンコード名です。デフォルトは locale.getpreferredencoding(False) です。

errors はオプションの文字列で、エンコードやデコードの際のエラーをどのように扱うかを指定します。エンコードエラーがあったときに ValueError 例外を送出させるには 'strict' を渡します (デフォルトの None でも同じです)。エラーを無視させるには 'ignore' を渡します。 (エンコーディングエラーを無視するとデータを喪失する可能性があることに注意してください。) 'replace' は不正な形式の文字の代わりにマーカ (たとえば '?') を挿入させます。'backslashreplace' を指定すると、不正な形式のデータをバックスラッシュ付きのエスケープシーケンスに置換します。書き込み時には 'xmlcharrefreplace' (適切な XML 文字参照に置換) や 'namereplace' (\N{...} エスケープシーケンスに置換) も使えます。他にも codecs.register_error() で登録されたエラー処理名が有効です。

newline は行末をどのように処理するかを制御します 。None, '', '\n', '\r', '\r\n' のいずれかです。これは以下のように動作します:

When reading input from the stream, if newline is None, universal newlines mode is enabled. Lines in the input can end in '\n', '\r', or '\r\n', and these are translated into '\n' before being returned to the caller. If newline is '', universal newlines mode is enabled, but line endings are returned to the caller untranslated. If newline has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.

ストリームへの出力の書き込み時、newline が None の場合、全ての '\n' 文字はシステムのデフォルトの行セパレータ os.linesep に変換されます。 newline が '' または '\n' の場合は変換されません。newline がその他の正当な値の場合、全ての '\n' 文字は与えられた文字列に変換されます。

line_buffering が True の場合、 write への呼び出しが改行文字もしくはキャリッジリターンを含んでいれば、暗黙的に flush() が呼び出されます。

write_through が True の場合、write() の呼び出しはバッファされないことが保証されます。 TextIOWrapper オブジェクトに書かれた全てのデータは直ちに下層のバイナリ buffer に処理されます。

バージョン 3.3 で変更: write_through 引数が追加されました。

バージョン 3.3 で変更: encoding の規定値が locale.getpreferredencoding() から locale.getpreferredencoding(False) になりました。 locale.setlocale() を用いてロケールのエンコーディングを一時的に変更してはいけません。ユーザが望むエンコーディングではなく現在のロケールのエンコーディングを使用してください。

TextIOWrapper provides these data attributes and methods in addition to those from TextIOBase and IOBase:

line_buffering
行バッファリングが有効かどうか。

write_through
書き込みが、根柢のバイナリバッファに即座に渡されるかどうか。

バージョン 3.7 で追加.

reconfigure(*[, encoding][, errors][, newline][, line_buffering][, write_through])
このテキストストリームを encoding, errors, newline, line_buffering と write_through を新しい設定として再設定します。

encoding が指定されており、errors が指定されていないときに、 errors='strict' が使われている場合を除き、指定されなかったパラメータは現在の設定が保持されます。

ストリームからすでにデータが読み出されていた場合、encodingとnewlineは変更できません。一方で、書き込み後にencodingを変更することはできます。

このメソッドは、新しい設定を適用するまえにストリームをフラッシュします。

バージョン 3.7 で追加.

class io.StringIO(initial_value='', newline='\n')
A text stream using an in-memory text buffer. It inherits TextIOBase.

The text buffer is discarded when the close() method is called.

バッファの初期値を initial_value で与えることが出来ます。改行変換を有効にすると、改行コードは write() によってエンコードされます。ストリームはバッファの開始位置に配置されます。

The newline argument works like that of TextIOWrapper, except that when writing output to the stream, if newline is None, newlines are written as \n on all platforms.

StringIO provides this method in addition to those from TextIOBase and IOBase:

getvalue()
バッファの全内容を含む str を返します。改行コードのデコードは read() によって行われますが、これによるストリーム位置の変更は起こりません。

使用例:

import io

output = io.StringIO()
output.write('First line.\n')
print('Second line.', file=output)

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()
class io.IncrementalNewlineDecoder
改行を universal newlines モードにデコードするヘルパーコーデックです。 codecs.IncrementalDecoder を継承しています。

性能
このセクションでは与えられた具体的な I/O 実装の性能について議論します。

バイナリ I/O
バッファ付き I/O は、ユーザが 1 バイトだけ要求した場合でさえ、データを大きな塊でのみ読み書きします。これにより、オペレーティングシステムのバッファ無し I/O ルーチンを呼び出して実行する非効率性はすべて隠されます。その成果は、OS と、実行される I/O の種類によって異なります。例えば、Linux のような現行の OS では、バッファ無しディスク I/O がバッファ付き I/O と同じくらい早いことがあります。しかし、どのプラットフォームとデバイスにおいても、バッファ付き I/O は最低でも予測可能なパフォーマンスを提供します。ですから、バイナリデータに対しては、バッファ無し I/O を使用するより、バッファ付きの I/O を使用するほうが望ましい場合がほとんどです。

テキスト I/O
(ファイルなどの) バイナリストレージ上のテキスト I/O は、同じストレージ上のバイナリ I/O より非常に遅いです。なぜならこれには、文字コーデックを使った Unicode とバイナリデータ間の変換を必要とするからです。これは大量のテキストデータ、例えば大きなログファイルを扱うときに顕著に成り得ます。同様に、 TextIOWrapper.tell() や TextIOWrapper.seek() はどちらも、使われている復元アルゴリズムのために遅くなります。

しかし StringIO は、ネイティブなインメモリ Unicode コンテナで、 BytesIO と同程度の速度を示します。

マルチスレッディング
(Unix における read(2) のような) オペレーティングシステムコールの、それがラッピングするものがスレッドセーフであるような範囲内では、 FileIO オブジェクトもまた、スレッドセーフです。

バイナリバッファ付きオブジェクト (BufferedReader, BufferedWriter, BufferedRandom および BufferedRWPair のインスタンス) は、その内部構造をロックを使って保護します。このため、これらを複数のスレッドから同時に呼び出しても安全です。

TextIOWrapper オブジェクトはスレッドセーフではありません。

リエントラント性
バイナリバッファ付きオブジェクト (BufferedReader, BufferedWriter, BufferedRandom および BufferedRWPair のインスタンス) は、リエントラント (再入可能) ではありません。リエントラントな呼び出しは普通の状況では起こりませんが、 I/O を signal ハンドラで行なっているときに起こりえます。スレッドが、すでにアクセスしているバッファ付きオブジェクトに再び入ろうとすると RuntimeError が送出されます。これは、バッファ付きオブジェクトに複数のスレッドから入ることを禁止するわけではありません。

The above implicitly extends to text files, since the open() function will wrap a buffered object inside a TextIOWrapper. This includes standard streams and therefore affects the built-in print() function as well.

time --- 時刻データへのアクセスと変換
このモジュールでは、時刻に関するさまざまな関数を提供します。関連した機能について、datetime, calendar モジュールも参照してください。

このモジュールは常に利用可能ですが、すべての関数がすべてのプラットフォームで利用可能なわけではありません。このモジュールで定義されているほとんどの関数は、プラットフォーム上の同名の C ライブラリ関数を呼び出します。これらの関数に対する意味付けはプラットフォーム間で異なるため、プラットフォーム提供のドキュメントを読んでおくと便利でしょう。

まずいくつかの用語の説明と慣習について整理します。

エポック (epoch) は時刻の起点のことで、これはプラットフォーム依存です。 Unix では、エポックは (UTC で) 1970 年 1 月 1 日 0 時 0 分 0 秒です。 与えられたプラットフォームでエポックが何なのかを知るには、 time.gmtime(0) の値を見てください。

エポック秒 (seconds since the epoch) は、エポックからの総経過秒数を示していますが、たいていはうるう秒 (leap seconds) は含まれていません。 全ての POSIX 互換のプラットフォームで、うるう秒はこの総秒数には含まれません。

このモジュールの中の関数は、エポック以前あるいは遠い未来の日付や時刻を扱うことができません。将来カットオフ（関数が正しく日付や時刻を扱えなくなる）が起きる時点は、C ライブラリによって決まります。32-bit システムではカットオフは通常 2038 年です。

Function strptime() can parse 2-digit years when given %y format code. When 2-digit years are parsed, they are converted according to the POSIX and ISO C standards: values 69--99 are mapped to 1969--1999, and values 0--68 are mapped to 2000--2068.

UTC は協定世界時 (Coordinated Universal Time) のことです (以前はグリニッジ標準時または GMT として知られていました)。UTC の頭文字の並びは誤りではなく、英仏の妥協によるものです。

DST は夏時間 (Daylight Saving Time) のことで、一年のうちの一定期間に 1 時間タイムゾーンを修正することです。DST のルールは不可思議で (地域ごとに法律で定められています)、年ごとに変わることもあります。C ライブラリはローカルルールを記したテーブルを持っており (柔軟に対応するため、たいていはシステムファイルから読み込まれます)、この点に関しては唯一の真実の知識の源です。

多くの現時刻を返す関数 (real-time functions) の精度は、値や引数を表現するために使う単位から想像されるよりも低いかも知れません。例えば、ほとんどの Unix システムにおいて、クロックの 1 ティックの精度は 50 から 100 分の 1 秒に過ぎません。

一方、time() および sleep() は Unix の同等の関数よりましな精度を持っています。時刻は浮動小数点数で表され、time() は可能なかぎり最も正確な時刻を (Unix の gettimeofday() があればそれを使って) 返します。また sleep() にはゼロでない端数を与えることができます (Unix の select() があれば、それを使って実装しています)。

gmtime(), localtime(), strptime() が返す時刻値、および asctime(), mktime(), strftime() がとる時刻値は 9 個の整数からなるシーケンスです。gmtime(), localtime(), strptime() の戻り値は個々の値を属性名で取得することもできます。

これらのオブジェクトについての解説は struct_time を参照してください。

バージョン 3.3 で変更: struct_time オブジェクトは、プラットフォームが、対応する struct tm メンバーをサポートしている場合、tm_gmtoff および tm_zone 属性が拡張されるようになりました。

バージョン 3.6 で変更: struct_time の属性 tm_gmtoff および tm_zone が全てのプラットフォームで利用できるようになりました。

時間の表現を変換するには、以下の関数を利用してください:

対象

変換先

関数

エポックからの秒数

UTC の struct_time

gmtime()

エポックからの秒数

ローカル時間の struct_time

localtime()

UTC の struct_time

エポックからの秒数

calendar.timegm()

ローカル時間の struct_time

エポックからの秒数

mktime()

関数
time.asctime([t])
Convert a tuple or struct_time representing a time as returned by gmtime() or localtime() to a string of the following form: 'Sun Jun 20 23:21:05 1993'. The day field is two characters long and is space padded if the day is a single digit, e.g.: 'Wed Jun  9 04:26:40 1993'.

If t is not provided, the current time as returned by localtime() is used. Locale information is not used by asctime().

注釈 同名の C の関数と違って、asctime() は末尾に改行文字を加えません。
time.pthread_getcpuclockid(thread_id)
Return the clk_id of the thread-specific CPU-time clock for the specified thread_id.

Use threading.get_ident() or the ident attribute of threading.Thread objects to get a suitable value for thread_id.

警告 Passing an invalid or expired thread_id may result in undefined behavior, such as segmentation fault.
利用可能な環境: Unix (更なる情報については pthread_getcpuclockid(3) の man を参照してください)。

バージョン 3.7 で追加.

time.clock_getres(clk_id)
指定された clk_id クロックの分解能(精度)を返します。 clk_id として受け付けられる値の一覧は Clock ID Constants を参照してください。

利用可能な環境: Unix。

バージョン 3.3 で追加.

time.clock_gettime(clk_id) → float
指定された clk_id クロックの時刻を返します。 clk_id として受け付けられる値の一覧は Clock ID Constants を参照してください。

利用可能な環境: Unix。

バージョン 3.3 で追加.

time.clock_gettime_ns(clk_id) → int
clock_gettime() に似ていますが、ナノ秒単位の時刻を返します。

利用可能な環境: Unix。

バージョン 3.7 で追加.

time.clock_settime(clk_id, time: float)
指定された clk_id クロックの時刻を設定します。 現在、 CLOCK_REALTIME は clk_id が受け付ける唯一の値です。

利用可能な環境: Unix。

バージョン 3.3 で追加.

time.clock_settime_ns(clk_id, time: int)
clock_settime() に似ていますが、ナノ秒単位の時刻を設定します。

利用可能な環境: Unix。

バージョン 3.7 で追加.

time.ctime([secs])
Convert a time expressed in seconds since the epoch to a string of a form: 'Sun Jun 20 23:21:05 1993' representing local time. The day field is two characters long and is space padded if the day is a single digit, e.g.: 'Wed Jun  9 04:26:40 1993'.

If secs is not provided or None, the current time as returned by time() is used. ctime(secs) is equivalent to asctime(localtime(secs)). Locale information is not used by ctime().

time.get_clock_info(name)
指定されたクロックの情報を名前空間オブジェクトとして取得します。サポートされているクロック名およびそれらの値を取得する関数は以下の通りです:

'monotonic': time.monotonic()

'perf_counter': time.perf_counter()

'process_time': time.process_time()

'thread_time': time.thread_time()

'time': time.time()

結果は以下の属性をもちます:

adjustable: 自動 (NTP デーモンによるなど) またはシステム管理者による手動で変更できる場合は True、それ以外の場合は False になります。

implementation: クロック値を取得するために内部で使用している C 関数の名前です。 使える値については Clock ID Constants を参照してください。

monotonic: クロック値が後戻りすることがない場合 True が、そうでない場合は False になります。

resolution: クロックの分解能を秒 (float) で表します。

バージョン 3.3 で追加.

time.gmtime([secs])
エポックからの経過時間で表現された時刻を、UTC で struct_time に変換します。このとき dst フラグは常にゼロとして扱われます。secs を指定しないか None を指定した場合、time() が返す値を現在の時刻として使用します。秒の端数は無視されます。struct_time オブジェクトについては前述の説明を参照してください。calendar.timegm() はこの関数と逆の変換を行います。

time.localtime([secs])
gmtime() に似ていますが、ローカル時間に変換します。secs を指定しないか None を指定した場合、time() が返す値を現在の時刻として使用します。DST が適用されている場合は dst フラグには 1 が設定されます。

time.mktime(t)
localtime() の逆を行う関数です。引数は struct_time か 9 個の要素すべての値を持つ完全なタプル (dst フラグも必要です; 時刻に DST が適用されるか不明の場合は -1 を使用してください) で、UTC ではなく ローカル 時間を指定します。戻り値は time() との互換性のために浮動小数点数になります。入力した値を正しい時刻として表現できない場合、例外 OverflowError または ValueError が送出されます (どちらが送出されるかは、無効な値を受け取ったのが Python と下層の C ライブラリのどちらなのかによって決まります)。この関数で時刻を生成できる最も古い日付はプラットフォームに依存します。

time.monotonic() → float
Return the value (in fractional seconds) of a monotonic clock, i.e. a clock that cannot go backwards. The clock is not affected by system clock updates. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid.

バージョン 3.3 で追加.

バージョン 3.5 で変更: この関数は、常に利用でき、常にシステム全域で使えるようになりました。

time.monotonic_ns() → int
monotonic() に似ていますが、ナノ秒単位の時刻を返します。

バージョン 3.7 で追加.

time.perf_counter() → float
Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid.

バージョン 3.3 で追加.

time.perf_counter_ns() → int
perf_counter() に似ていますが、ナノ秒単位の時刻を返します。

バージョン 3.7 で追加.

time.process_time() → float
Return the value (in fractional seconds) of the sum of the system and user CPU time of the current process. It does not include time elapsed during sleep. It is process-wide by definition. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid.

バージョン 3.3 で追加.

time.process_time_ns() → int
process_time() に似ていますが、ナノ秒単位の時刻を返します。

バージョン 3.7 で追加.

time.sleep(secs)
与えられた秒数の間、呼び出したスレッドの実行を停止します。より精度の高い実行停止時間を指定するために、引数は浮動小数点にしてもかまいません。何らかのシステムシグナルがキャッチされた場合、それに続いてシグナル処理ルーチンが実行され、sleep() を停止します。従って実際の実行停止時間は要求した時間よりも短くなるかもしれません。また、システムが他の処理をスケジュールするために、実行停止時間が要求した時間よりも多少長い時間になることもあります。

バージョン 3.5 で変更: スリープがシグナルに中断されてもシグナルハンドラが例外を送出しない限り、少なくとも secs だけスリープするようになりました (論拠については PEP 475 を参照してください)。

time.strftime(format[, t])
gmtime() や localtime() が返す時刻値タプルまたは struct_time を、format で指定した文字列形式に変換します。t が与えられていない場合、localtime() が返す値を現在の時刻として使用します。format は文字列でなくてはなりません。t のいずれかのフィールドが許容範囲外の数値であった場合、ValueError を送出します。

0 は時刻タプル内のいずれの位置の引数にも使用できます; それが一般に不正な値であれば、正しい値に強制的に置き換えられます。

format 文字列には以下のディレクティブ (指示語) を埋め込むことができます。これらはフィールド長や精度のオプションを付けずに表され、strftime() の結果の対応する文字列に置き換えられます:

ディレクティブ

意味

注釈

%a

ロケールの短縮された曜日名になります。

%A

ロケールの曜日名になります。

%b

ロケールの短縮された月名になります。

%B

ロケールの月名になります。

%c

ロケールの日時を適切な形式で表します。

%d

月中の日にちの 10 進表記になります [01,31]。

%H

時 (24 時間表記) の 10 進表記になります [00,23]。

%I

時 (12 時間表記) の 10 進表記になります [01,12]。

%j

年中の日にちの 10 進表記になります [001,366]。

%m

月の 10 進表記になります [01,12]。

%M

分の 10 進表記になります [00,59]。

%p

ロケールの AM もしくは PM と等価な文字列になります。

(1)

%S

秒の 10 進表記になります [00,61]。

(2)

%U

年の初めから何週目か (日曜を週の始まりとします) を表す 10 進数になります [00,53]。年が明けてから最初の日曜日までのすべての曜日は 0 週目に属すると見なされます。

(3)

%w

曜日の 10 進表記になります [0 (日曜日),6]。

%W

年の初めから何週目か (月曜を週の始まりとします) を表す 10 進数になります [00,53]。年が明けてから最初の月曜日までの全ての曜日は 0 週目に属すると見なされます。

(3)

%x

ロケールの日付を適切な形式で表します。

%X

ロケールの時間を適切な形式で表します。

%y

西暦の下 2 桁の 10 進表記になります [00,99]。

%Y

西暦 ( 4桁) の 10 進表記を表します。

%z

タイムゾーンと UTC/GMT との時差を表す正または負の時間を +HHMM、-HHMM で表します。H は時間の、M は分の 10 進表記になります [-23:59, +23:59]。

%Z

タイムゾーンの名前を表します (タイムゾーンがない場合には空文字列)。

%%

文字 '%' を表します。

注釈:

strptime() 関数で使う場合、%p ディレクティブが出力結果の時刻フィールドに影響を及ぼすのは、時刻を解釈するために %I を使ったときのみです。

値の幅は実際に 0 から 61 です; 60 は うるう秒<leap seconds> を表し、 61 は歴史的理由によりサポートされています。

strptime() 関数で使う場合、%U および %W を計算に使うのは曜日と年を指定したときだけです。

以下に RFC 2822 インターネット電子メール標準で定義されている日付表現と互換の書式の例を示します。 1

>>>
>>> from time import gmtime, strftime
>>> strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
'Thu, 28 Jun 2001 14:17:15 +0000'
一部のプラットフォームではさらにいくつかのディレクティブがサポートされていますが、標準 ANSI C で意味のある値はここで列挙したものだけです。あなたのプラットフォームでサポートされている書式コードの全一覧については、strftime(3) のドキュメントを参照してください。

一部のプラットフォームでは、フィールドの幅や精度を指定するオプションがディレクティブの先頭の文字 '%' の直後に付けられるようになっていました; この機能も移植性はありません。フィールドの幅は通常 2 ですが、%j は例外で 3 です。

time.strptime(string[, format])
時刻を表現する文字列を書式に従って解釈します。返される値は gmtime() や localtime() が返すような struct_time です。

format パラメーターは strftime() で使うものと同じディレクティブを使います; このパラメーターの値はデフォルトでは "%a %b %d %H:%M:%S %Y" で、ctime() が返すフォーマットに一致します。string が format に従って解釈できなかった場合、例外 ValueError が送出されます。解析しようとする string が解析後に余分なデータを持っていた場合、ValueError が送出されます。欠落したデータについて、適切な値を推測できない場合はデフォルトの値で埋められ、その値は (1900, 1, 1, 0, 0, 0, 0, 1, -1) です。string も format も文字列でなければなりません。

例えば:

>>>
import time
time.strptime("30 Nov 00", "%d %b %y")   
time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0,
                 tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)
%Z ディレクティブへのサポートは tzname に収められている値と daylight が真かどうかで決められます。このため、常に既知の (かつ夏時間でないと考えられている) UTC や GMT を認識する時以外はプラットフォーム固有の動作になります。

ドキュメント内で説明されているディレクティブだけがサポートされています。strftime() はプラットフォームごとに実装されているので、説明されていないディレクティブも利用できるかもしれません。しかし、strptime() はプラットフォーム非依存なので、ドキュメント内でサポートされているとされているディレクティブ以外は利用できません。

class time.struct_time
gmtime(), localtime() および strptime() が返す時刻値シーケンスの型です。これは 名前付きタプル のインタフェースをもったオブジェクトです。値はインデックスでも属性名でもアクセス可能です。以下の値があります:

インデックス

属性

値

0

tm_year

(例えば 1993)

1

tm_mon

[1,12] の間の数

2

tm_mday

[1,31] の間の数

3

tm_hour

[0,23] の間の数

4

tm_min

[0,59] の間の数

5

tm_sec

[0,61] の間の数 strftime() の説明にある (2) を読んで下さい

6

tm_wday

[0,6] の間の数、月曜が 0 になります

7

tm_yday

[1,366] の間の数

8

tm_isdst

0, 1 または -1; 以下を参照してください

N/A

tm_zone

タイムゾーンの短縮名

N/A

tm_gmtoff

UTC から東方向へのオフセット (秒)

C の構造体とは異なり、月の値は [0, 11] ではなく [1, 12] であることに注意してください。

mktime() の呼び出し時に、tm_isdst は夏時間が有効な場合は 1、そうでない場合は 0 に設定されることがあります。 値が -1 の場合は夏時間について不明なことを表していて、普通 tm_isdst は正しい状態に設定されます。

struct_time を引数とする関数に正しくない長さの struct_time や要素の型が正しくない struct_time を与えた場合には、 TypeError が送出されます。

time.time() → float
エポック からの秒数を浮動小数点数で返します。 エポックの具体的な日付とうるう秒 (leap seconds) の扱いはプラットフォーム依存です。 Windows とほとんどの Unix システムでは、エポックは (UTC で) 1970 年 1 月 1 日 0 時 0 分 0 秒で、うるう秒はエポック秒の時間の勘定には入りません。 これは一般に Unix 時間 と呼ばれています。 与えられたプラットフォームでエポックが何なのかを知るには、 time.gmtime(0) の値を見てください。

時刻は常に浮動小数点数で返されますが、すべてのシステムが 1 秒より高い精度で時刻を提供するとは限らないので注意してください。 この関数が返す値は通常減少していくことはありませんが、この関数を 2 回呼び出し、その呼び出しの間にシステムクロックの時刻を巻き戻して設定した場合には、以前の呼び出しよりも低い値が返ることがあります。

time() が返す数値は、 gmtime() 関数に渡されて UTC の、あるいは localtime() 関数に渡されて現地時間の、より一般的な時間のフォーマット (つまり、年、月、日、時間など) に変換されているかもしれません。 どちらの場合でも struct_time オブジェクトが返され、このオブジェクトの属性としてカレンダー日付の構成要素へアクセスできます。

time.thread_time() → float
Return the value (in fractional seconds) of the sum of the system and user CPU time of the current thread. It does not include time elapsed during sleep. It is thread-specific by definition. The reference point of the returned value is undefined, so that only the difference between the results of two calls in the same thread is valid.

利用可能な環境: Windows, Linux, CLOCK_THREAD_CPUTIME_ID をサポートしている Unix システム。

バージョン 3.7 で追加.

time.thread_time_ns() → int
thread_time() に似ていますが、ナノ秒単位の時刻を返します。

バージョン 3.7 で追加.

time.time_ns() → int
time() に似ていますが、時刻を epoch を基点としたナノ秒単位の整数で返します。

バージョン 3.7 で追加.

time.tzset()
Reset the time conversion rules used by the library routines. The environment variable TZ specifies how this is done. It will also set the variables tzname (from the TZ environment variable), timezone (non-DST seconds West of UTC), altzone (DST seconds west of UTC) and daylight (to 0 if this timezone does not have any daylight saving time rules, or to nonzero if there is a time, past, present or future when daylight saving time applies).

利用可能な環境: Unix。

注釈 多くの場合、環境変数 TZ を変更すると、 tzset() を呼ばない限り localtime() のような関数の出力に影響を及ぼすため、値が信頼できなくなってしまいます。
TZ 環境変数には空白文字を含めてはなりません。

環境変数 TZ の標準的な書式は以下の通りです (分かりやすいように空白を入れています):

std offset [dst [offset [,start[/time], end[/time]]]]
各値は以下のようになっています:

std と dst
三文字またはそれ以上の英数字で、タイムゾーンの略称を与えます。この値は time.tzname になります。

offset
オフセットは形式: ± hh[:mm[:ss]] をとります。この表現は、UTC 時刻にするためにローカルな時間に加算する必要のある時間値を示します。'-' が先頭につく場合、そのタイムゾーンは本初子午線 (Prime Meridian) より東側にあります。それ以外の場合は本初子午線の西側です。オフセットが dst の後ろに続かない場合、夏時間は標準時より一時間先行しているものと仮定します。

start[/time], end[/time]
いつ DST に移動し、DST から戻ってくるかを示します。開始および終了日時の形式は以下のいずれかです:

Jn
ユリウス日 (Julian day) n (1 <= n <= 365) を表します。うるう日は計算に含められないため、2 月 28 日は常に 59 で、3 月 1 日は 60 になります。

n
ゼロから始まるユリウス日 (0 <= n <= 365) です。うるう日は計算に含められるため、2 月 29 日を参照することができます。

Mm.n.d
m 月の週 n における d 番目の日 (0 <= d <= 6, 1 <= n <= 5, 1 <= m <= 12) を表します。週 5 は月 m における最終週の d 番目の日を表し、第 4 週か第 5 週のどちらかになります。週 1 は日 d が最初に現れる日を指します。日 0 は日曜日です。

time は offset とほぼ同じで、先頭に符号 ('-' や '+') を付けてはいけないところだけが違います。時刻が指定されていなければ、デフォルトの値 02:00:00 になります。

>>>
>>> os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
>>> time.tzset()
>>> time.strftime('%X %x %Z')
'02:07:36 05/08/03 EDT'
>>> os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
>>> time.tzset()
>>> time.strftime('%X %x %Z')
'16:08:12 05/08/03 AEST'
多くの Unix システム (*BSD, Linux, Solaris, および Darwin を含む) では、システムの zoneinfo (tzfile(5)) データベースを使ったほうが、タイムゾーンごとの規則を指定する上で便利です。これを行うには、必要なタイムゾーンデータファイルへのパスをシステムの 'zoneinfo' タイムゾーンデータベースからの相対で表した値を環境変数 TZ に設定します。システムの 'zoneinfo' は通常 /usr/share/zoneinfo にあります。例えば、 'US/Eastern' 、 'Australia/Melbourne' 、 'Egypt' ないし 'Europe/Amsterdam' と指定します。

>>>
>>> os.environ['TZ'] = 'US/Eastern'
>>> time.tzset()
>>> time.tzname
('EST', 'EDT')
>>> os.environ['TZ'] = 'Egypt'
>>> time.tzset()
>>> time.tzname
('EET', 'EEST')
Clock ID Constants
These constants are used as parameters for clock_getres() and clock_gettime().

time.CLOCK_BOOTTIME
Identical to CLOCK_MONOTONIC, except it also includes any time that the system is suspended.

This allows applications to get a suspend-aware monotonic clock without having to deal with the complications of CLOCK_REALTIME, which may have discontinuities if the time is changed using settimeofday() or similar.

Availability: Linux 2.6.39 or later.

バージョン 3.7 で追加.

time.CLOCK_HIGHRES
The Solaris OS has a CLOCK_HIGHRES timer that attempts to use an optimal hardware source, and may give close to nanosecond resolution. CLOCK_HIGHRES is the nonadjustable, high-resolution clock.

Availability: Solaris.

バージョン 3.3 で追加.

time.CLOCK_MONOTONIC
設定不可で、モノトニック時刻 (不特定のエポックからの単調増加な時刻) を表します。

利用可能な環境: Unix。

バージョン 3.3 で追加.

time.CLOCK_MONOTONIC_RAW
CLOCK_MONOTONIC と似ていますが、NTP の影響を受けていない、ハードウェアベースの時刻へのアクセスを提供します。

Availability: Linux 2.6.28 and newer, macOS 10.12 and newer.

バージョン 3.3 で追加.

time.CLOCK_PROCESS_CPUTIME_ID
CPU による高分解能のプロセスごとのタイマーです。

利用可能な環境: Unix。

バージョン 3.3 で追加.

time.CLOCK_PROF
CPU による高分解能のプロセスごとのタイマーです。

Availability: FreeBSD, NetBSD 7 or later, OpenBSD.

バージョン 3.7 で追加.

time.CLOCK_TAI
International Atomic Time

The system must have a current leap second table in order for this to give the correct answer. PTP or NTP software can maintain a leap second table.

Availability: Linux.

バージョン 3.9 で追加.

time.CLOCK_THREAD_CPUTIME_ID
スレッド固有の CPU タイムクロックです。

利用可能な環境: Unix。

バージョン 3.3 で追加.

time.CLOCK_UPTIME
Time whose absolute value is the time the system has been running and not suspended, providing accurate uptime measurement, both absolute and interval.

Availability: FreeBSD, OpenBSD 5.5 or later.

バージョン 3.7 で追加.

time.CLOCK_UPTIME_RAW
Clock that increments monotonically, tracking the time since an arbitrary point, unaffected by frequency or time adjustments and not incremented while the system is asleep.

Availability: macOS 10.12 and newer.

バージョン 3.8 で追加.

The following constant is the only parameter that can be sent to clock_settime().

time.CLOCK_REALTIME
システム全体のリアルタイムクロックです。このクロックを設定するには適切な権限が必要です。

利用可能な環境: Unix。

バージョン 3.3 で追加.

Timezone Constants
time.altzone
The offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if daylight is nonzero. See note below.

time.daylight
Nonzero if a DST timezone is defined. See note below.

time.timezone
The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, positive in the US, zero in the UK). See note below.

time.tzname
A tuple of two strings: the first is the name of the local non-DST timezone, the second is the name of the local DST timezone. If no DST timezone is defined, the second string should not be used. See note below.

注釈 For the above Timezone constants (altzone, daylight, timezone, and tzname), the value is determined by the timezone rules in effect at module load time or the last time tzset() is called and may be incorrect for times in the past. It is recommended to use the tm_gmtoff and tm_zone results from localtime() to obtain timezone information.
参考
datetime モジュール
日付と時刻に対する、よりオブジェクト指向のインタフェースです。

locale モジュール
国際化サービスです。ロケールの設定は strftime() および strptime() の多くの書式指定子の解釈に影響を及ぼします。

calendar モジュール
一般的なカレンダーに関する関数群です。timegm() はこのモジュールの gmtime() の逆を行う関数です。

脚注

1
%Z の使用は現在非推奨です。ただし、ここで実現したい時間および分オフセットへの展開を行ってくれる %z エスケープはすべての ANSI C ライブラリでサポートされているわけではありません。また、1982 年に提出されたオリジナルの RFC 822 標準では西暦の表現を 2 桁とするよう要求している (%Y でなく%y ) ものの、実際には 2000 年になるだいぶ以前から 4 桁の西暦表現に移行しています。その後 RFC 822 は撤廃され、4 桁の西暦表現は RFC 1123 で初めて勧告され、RFC 2822 において義務付けられました。

argparse --- コマンドラインオプション、引数、サブコマンドのパーサー
バージョン 3.2 で追加.

ソースコード: Lib/argparse.py

チュートリアル

このページは API のリファレンス情報が記載しています。argparse チュートリアル では、コマンドラインの解析についてより優しく説明しています。

argparse モジュールはユーザーフレンドリなコマンドラインインターフェースの作成を簡単にします。プログラムがどんな引数を必要としているのかを定義すると、argparse が sys.argv からそのオプションを解析する方法を見つけ出します。argparse モジュールは自動的にヘルプと使用方法メッセージを生成し、ユーザーが不正な引数をプログラムに指定したときにエラーを発生させます。

使用例
次のコードは、整数のリストを受け取って合計か最大値を返す Python プログラムです:

import argparse

parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument('integers', metavar='N', type=int, nargs='+',
                    help='an integer for the accumulator')
parser.add_argument('--sum', dest='accumulate', action='store_const',
                    const=sum, default=max,
                    help='sum the integers (default: find the max)')

args = parser.parse_args()
print(args.accumulate(args.integers))
上の Python コードが prog.py という名前のファイルに保存されたと仮定します。コマンドラインから便利なヘルプメッセージを表示できます:

$ python prog.py -h
usage: prog.py [-h] [--sum] N [N ...]

Process some integers.

positional arguments:
 N           an integer for the accumulator

optional arguments:
 -h, --help  show this help message and exit
 --sum       sum the integers (default: find the max)
適切な引数を与えて実行した場合、このプログラムはコマンドライン引数の整数列の合計か最大値を表示します:

$ python prog.py 1 2 3 4
4

$ python prog.py 1 2 3 4 --sum
10
不正な引数が与えられた場合、エラーを発生させます:

$ python prog.py a b c
usage: prog.py [-h] [--sum] N [N ...]
prog.py: error: argument N: invalid int value: 'a'
以降の節では、この例をひと通り説明して行きます。

パーサーを作る
argparse を使うときの最初のステップは、ArgumentParser オブジェクトを生成することです:

>>>
>>> parser = argparse.ArgumentParser(description='Process some integers.')
ArgumentParser オブジェクトはコマンドラインを解析して Python データ型にするために必要なすべての情報を保持します。

引数を追加する
ArgumentParser にプログラム引数の情報を与えるために、add_argument() メソッドを呼び出します。一般的に、このメソッドの呼び出しは ArgumentParser に、コマンドラインの文字列を受け取ってそれをオブジェクトにする方法を教えます。この情報は保存され、parse_args() が呼び出されたときに利用されます。例えば:

>>>
>>> parser.add_argument('integers', metavar='N', type=int, nargs='+',
...                     help='an integer for the accumulator')
>>> parser.add_argument('--sum', dest='accumulate', action='store_const',
...                     const=sum, default=max,
...                     help='sum the integers (default: find the max)')
あとで parse_args() を呼び出すと、integers と accumulate という2つの属性を持ったオブジェクトを返します。integers 属性は1つ以上の整数のリストで、accumulate 属性はコマンドラインから --sum が指定された場合は sum() 関数に、それ以外の場合は max() 関数になります。

引数を解析する
ArgumentParser は引数を parse_args() メソッドで解析します。このメソッドはコマンドラインを調べ、各引数を正しい型に変換して、適切なアクションを実行します。ほとんどの場合、これはコマンドラインの解析結果から、シンプルな Namespace オブジェクトを構築することを意味します:

>>>
>>> parser.parse_args(['--sum', '7', '-1', '42'])
Namespace(accumulate=<built-in function sum>, integers=[7, -1, 42])
スクリプト内では、parse_args() は通常引数なしで呼び出され、ArgumentParser は自動的に sys.argv からコマンドライン引数を取得します。

ArgumentParser オブジェクト
class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True, exit_on_error=True)
新しい ArgumentParser オブジェクトを生成します。すべての引数はキーワード引数として渡すべきです。各引数についてはあとで詳しく説明しますが、簡単に言うと:

prog - プログラム名 (デフォルト: sys.argv[0])

usage - プログラムの利用方法を記述する文字列 (デフォルト: パーサーに追加された引数から生成されます)

description - 引数のヘルプの前に表示されるテキスト (デフォルト: none)

epilog - 引数のヘルプの後で表示されるテキスト (デフォルト: none)

parents - ArgumentParser オブジェクトのリストで、このオブジェクトの引数が追加されます

formatter_class - ヘルプ出力をカスタマイズするためのクラス

prefix_chars - オプションの引数の prefix になる文字集合 (デフォルト: '-')

fromfile_prefix_chars - 追加の引数を読み込むファイルの prefix になる文字集合 (デフォルト: None)

argument_default - 引数のグローバルなデフォルト値 (デフォルト: None)

conflict_handler - 衝突するオプションを解決する方法 (通常は不要)

add_help - -h/--help オプションをパーサーに追加する (デフォルト: True)

allow_abbrev - 長いオプションが先頭の 1 文字に短縮可能 (先頭の文字が一意) である場合に短縮指定を許可する。(デフォルト: True)

exit_on_error - Determines whether or not ArgumentParser exits with error info when an error occurs. (default: True)

バージョン 3.5 で変更: allow_abbrev 引数が追加されました。

バージョン 3.8 で変更: 以前のバージョンでは、 allow_abbrev は、-vv が -v -v と等価になるような、短いフラグのグループ化を無効にしていました。

バージョン 3.9 で変更: exit_on_error 引数が追加されました。

以下の節では各オプションの利用方法を説明します。

prog
デフォルトでは、ArgumentParser オブジェクトはヘルプメッセージ中に表示するプログラム名を sys.argv[0] から取得します。 このデフォルトの動作は、プログラムがコマンドライン上の起動方法に合わせてヘルプメッセージを作成するため、ほとんどの場合望ましい挙動になります。 例えば、myprogram.py という名前のファイルに次のコードがあるとします:

import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--foo', help='foo help')
args = parser.parse_args()
このプログラムのヘルプは、プログラム名として (プログラムがどこから起動されたのかに関わらず) myprogram.py を表示します:

$ python myprogram.py --help
usage: myprogram.py [-h] [--foo FOO]

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO   foo help
$ cd ..
$ python subdir/myprogram.py --help
usage: myprogram.py [-h] [--foo FOO]

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO   foo help
このデフォルトの動作を変更するには、ArgumentParser の prog= 引数に他の値を指定します:

>>>
>>> parser = argparse.ArgumentParser(prog='myprogram')
>>> parser.print_help()
usage: myprogram [-h]

optional arguments:
 -h, --help  show this help message and exit
プログラム名は、sys.argv[0] から取られた場合でも prog= 引数で与えられた場合でも、ヘルプメッセージ中では %(prog)s フォーマット指定子で利用できます。

>>>
>>> parser = argparse.ArgumentParser(prog='myprogram')
>>> parser.add_argument('--foo', help='foo of the %(prog)s program')
>>> parser.print_help()
usage: myprogram [-h] [--foo FOO]

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO   foo of the myprogram program
usage
デフォルトでは、 ArgumentParser は使用法メッセージを、保持している引数から生成します:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--foo', nargs='?', help='foo help')
>>> parser.add_argument('bar', nargs='+', help='bar help')
>>> parser.print_help()
usage: PROG [-h] [--foo [FOO]] bar [bar ...]

positional arguments:
 bar          bar help

optional arguments:
 -h, --help   show this help message and exit
 --foo [FOO]  foo help
デフォルトのメッセージは usage= キーワード引数で変更できます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')
>>> parser.add_argument('--foo', nargs='?', help='foo help')
>>> parser.add_argument('bar', nargs='+', help='bar help')
>>> parser.print_help()
usage: PROG [options]

positional arguments:
 bar          bar help

optional arguments:
 -h, --help   show this help message and exit
 --foo [FOO]  foo help
%(prog)s フォーマット指定子を、使用法メッセージ内でプログラム名として利用できます。

description
多くの場合、ArgumentParser のコンストラクターを呼び出すときに description= キーワード引数が使用されます。この引数はプログラムが何をしてどう動くのかについての短い説明になります。ヘルプメッセージで、この説明がコマンドラインの利用法と引数のヘルプメッセージの間に表示されます:

>>>
>>> parser = argparse.ArgumentParser(description='A foo that bars')
>>> parser.print_help()
usage: argparse.py [-h]

A foo that bars

optional arguments:
 -h, --help  show this help message and exit
デフォルトでは、説明は与えられたスペースに合わせて折り返されます。この挙動を変更するには、formatter_class 引数を参照してください。

epilog
いくつかのプログラムは、プログラムについての追加の説明を引数の説明の後に表示します。このテキストは ArgumentParser の epilog= 引数に指定できます:

>>>
>>> parser = argparse.ArgumentParser(
...     description='A foo that bars',
...     epilog="And that's how you'd foo a bar")
>>> parser.print_help()
usage: argparse.py [-h]

A foo that bars

optional arguments:
 -h, --help  show this help message and exit

And that's how you'd foo a bar
description 引数と同じく、epilog= テキストもデフォルトで折り返され、ArgumentParser の formatter_class 引数で動作を調整できます。

parents
ときどき、いくつかのパーサーが共通の引数セットを共有することがあります。それらの引数を繰り返し定義する代わりに、すべての共通引数を持ったパーサーを ArgumentParser の parents= 引数に渡すことができます。 parents= 引数は ArgumentParser オブジェクトのリストを受け取り、すべての位置アクションとオプションのアクションをそれらから集め、そのアクションを構築中の ArgumentParser オブジェクトに追加します:

>>>
>>> parent_parser = argparse.ArgumentParser(add_help=False)
>>> parent_parser.add_argument('--parent', type=int)

>>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])
>>> foo_parser.add_argument('foo')
>>> foo_parser.parse_args(['--parent', '2', 'XXX'])
Namespace(foo='XXX', parent=2)

>>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])
>>> bar_parser.add_argument('--bar')
>>> bar_parser.parse_args(['--bar', 'YYY'])
Namespace(bar='YYY', parent=None)
一番親になるパーサーに add_help=False を指定していることに注目してください。こうしないと、ArgumentParser は2つの -h/--help オプションを与えられる (1つは親から、もうひとつは子から) ことになり、エラーを発生します。

注釈 parents= に渡す前にパーサーを完全に初期化する必要があります。子パーサーを作成してから親パーサーを変更した場合、その変更は子パーサーに反映されません。
formatter_class
ArgumentParser オブジェクトは代わりのフォーマットクラスを指定することでヘルプのフォーマットをカスタマイズできます。現在、4つのフォーマットクラスがあります:

class argparse.RawDescriptionHelpFormatter
class argparse.RawTextHelpFormatter
class argparse.ArgumentDefaultsHelpFormatter
class argparse.MetavarTypeHelpFormatter
RawDescriptionHelpFormatter と RawTextHelpFormatter はどのようにテキストの説明を表示するかを指定できます。デフォルトでは ArgumentParser オブジェクトはコマンドラインヘルプの中の description と epilog を折り返して表示します:

>>>
>>> parser = argparse.ArgumentParser(
...     prog='PROG',
...     description='''this description
...         was indented weird
...             but that is okay''',
...     epilog='''
...             likewise for this epilog whose whitespace will
...         be cleaned up and whose words will be wrapped
...         across a couple lines''')
>>> parser.print_help()
usage: PROG [-h]

this description was indented weird but that is okay

optional arguments:
 -h, --help  show this help message and exit

likewise for this epilog whose whitespace will be cleaned up and whose words
will be wrapped across a couple lines
formatter_class= に RawDescriptionHelpFormatter を渡した場合、 description と epilog は整形済みとされ改行されません:

>>>
>>> parser = argparse.ArgumentParser(
...     prog='PROG',
...     formatter_class=argparse.RawDescriptionHelpFormatter,
...     description=textwrap.dedent('''\
...         Please do not mess up this text!
...         --------------------------------
...             I have indented it
...             exactly the way
...             I want it
...         '''))
>>> parser.print_help()
usage: PROG [-h]

Please do not mess up this text!
--------------------------------
   I have indented it
   exactly the way
   I want it

optional arguments:
 -h, --help  show this help message and exit
RawTextHelpFormatter は引数の説明を含めてすべての種類のヘルプテキストで空白を維持します。例外として、複数の空行はひとつにまとめられます。複数の空白行を保ちたい場合には、行に空白を含めるようにして下さい。

ArgumentDefaultsHelpFormatter は各引数のデフォルト値を自動的にヘルプに追加します:

>>>
>>> parser = argparse.ArgumentParser(
...     prog='PROG',
...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
>>> parser.add_argument('--foo', type=int, default=42, help='FOO!')
>>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')
>>> parser.print_help()
usage: PROG [-h] [--foo FOO] [bar ...]

positional arguments:
 bar         BAR! (default: [1, 2, 3])

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO   FOO! (default: 42)
MetavarTypeHelpFormatter は、各引数の値の表示名に type 引数の値を使用します (通常は dest の値が使用されます):

>>>
>>> parser = argparse.ArgumentParser(
...     prog='PROG',
...     formatter_class=argparse.MetavarTypeHelpFormatter)
>>> parser.add_argument('--foo', type=int)
>>> parser.add_argument('bar', type=float)
>>> parser.print_help()
usage: PROG [-h] [--foo int] float

positional arguments:
  float

optional arguments:
  -h, --help  show this help message and exit
  --foo int
prefix_chars
ほとんどのコマンドラインオプションは、-f/--foo のように接頭辞に - を使います。+f や /foo のような、他の、あるいは追加の接頭辞文字をサポートしなければならない場合、ArgumentParser のコンストラクターに prefix_chars= 引数を使って指定します:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')
>>> parser.add_argument('+f')
>>> parser.add_argument('++bar')
>>> parser.parse_args('+f X ++bar Y'.split())
Namespace(bar='Y', f='X')
prefix_chars= 引数のデフォルトは '-' です。- を含まない文字セットを指定すると、-f/--foo オプションが使用できなくなります。

fromfile_prefix_chars
ときどき、例えば非常に長い引数リストを扱う場合に、その引数リストを毎回コマンドラインにタイプする代わりにファイルに置いておきたい場合があります。ArgumentParser のコンストラクターに fromfile_prefix_chars= 引数が渡された場合、指定された文字のいずれかで始まる引数はファイルとして扱われ、そのファイルに含まれる引数リストに置換されます。例えば:

>>>
>>> with open('args.txt', 'w') as fp:
...     fp.write('-f\nbar')
>>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
>>> parser.add_argument('-f')
>>> parser.parse_args(['-f', 'foo', '@args.txt'])
Namespace(f='bar')
ファイルから読み込まれる引数は、デフォルトでは1行に1つ (ただし、convert_arg_line_to_args() も参照してください) で、コマンドライン上でファイルを参照する引数があった場所にその引数があったものとして扱われます。このため、上の例では、['-f', 'foo', '@args.txt'] は ['-f', 'foo', '-f', 'bar'] と等価になります。

fromfile_prefix_chars= 引数のデフォルト値は None で、引数がファイル参照として扱われることがないことを意味しています。

argument_default
一般的には、引数のデフォルト値は add_argument() メソッドにデフォルト値を渡すか、set_defaults() メソッドに名前と値のペアを渡すことで指定します。しかしまれに、1つのパーサー全体に適用されるデフォルト引数が便利なことがあります。これを行うには、 ArgumentParser に argument_default= キーワード引数を渡します。例えば、全体で parse_args() メソッド呼び出しの属性の生成を抑制するには、argument_default=SUPPRESS を指定します:

>>>
>>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
>>> parser.add_argument('--foo')
>>> parser.add_argument('bar', nargs='?')
>>> parser.parse_args(['--foo', '1', 'BAR'])
Namespace(bar='BAR', foo='1')
>>> parser.parse_args([])
Namespace()
allow_abbrev
通常、ArgumentParser の parse_args() に引数のリストを渡すとき、長いオプションは 短縮しても認識されます。

この機能は、allow_abbrev に False を指定することで無効にできます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)
>>> parser.add_argument('--foobar', action='store_true')
>>> parser.add_argument('--foonley', action='store_false')
>>> parser.parse_args(['--foon'])
usage: PROG [-h] [--foobar] [--foonley]
PROG: error: unrecognized arguments: --foon
バージョン 3.5 で追加.

conflict_handler
ArgumentParser オブジェクトは同じオプション文字列に対して複数のアクションを許可していません。 デフォルトでは、ArgumentParser オブジェクトは、すでに利用されているオプション文字列を使って新しい引数をつくろうとしたときに例外を送出します:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-f', '--foo', help='old foo help')
>>> parser.add_argument('--foo', help='new foo help')
Traceback (most recent call last):
 ..
ArgumentError: argument --foo: conflicting option string(s): --foo
ときどき (例えば parents を利用する場合など)、古い引数を同じオプション文字列で上書きするほうが便利な場合があります。この動作をするには、ArgumentParser の conflict_handler= 引数に 'resolve' を渡します:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')
>>> parser.add_argument('-f', '--foo', help='old foo help')
>>> parser.add_argument('--foo', help='new foo help')
>>> parser.print_help()
usage: PROG [-h] [-f FOO] [--foo FOO]

optional arguments:
 -h, --help  show this help message and exit
 -f FOO      old foo help
 --foo FOO   new foo help
ArgumentParser オブジェクトは、すべてのオプション文字列が上書きされた場合にだけアクションを削除することに注目してください。上の例では、 --foo オプション文字列だけが上書きされているので、古い -f/--foo アクションは -f アクションとして残っています。

add_help
デフォルトでは、ArgumentParser オブジェクトはシンプルにパーサーのヘルプメッセージを表示するオプションを自動的に追加します。例えば、以下のコードを含む myprogram.py ファイルについて考えてください:

import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--foo', help='foo help')
args = parser.parse_args()
コマンドラインに -h か --help が指定された場合、ArgumentParser の help が表示されます:

$ python myprogram.py --help
usage: myprogram.py [-h] [--foo FOO]

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO   foo help
必要に応じて、この help オプションを無効にする場合があります。これは ArgumentParser の add_help= 引数に False を渡すことで可能です:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> parser.add_argument('--foo', help='foo help')
>>> parser.print_help()
usage: PROG [--foo FOO]

optional arguments:
 --foo FOO  foo help
ヘルプオプションは通常 -h/--help です。例外は prefix_chars= が指定されてその中に - が無かった場合で、その場合は -h と --help は有効なオプションではありません。この場合、prefix_chars の最初の文字がヘルプオプションの接頭辞として利用されます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')
>>> parser.print_help()
usage: PROG [+h]

optional arguments:
  +h, ++help  show this help message and exit
exit_on_error
Normally, when you pass an invalid argument list to the parse_args() method of an ArgumentParser, it will exit with error info.

If the user would like catch errors manually, the feature can be enable by setting exit_on_error to False:

>>>
>>> parser = argparse.ArgumentParser(exit_on_error=False)
>>> parser.add_argument('--integers', type=int)
_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
>>> try:
...     parser.parse_args('--integers a'.split())
... except argparse.ArgumentError:
...     print('Catching an argumentError')
...
Catching an argumentError
バージョン 3.9 で追加.

add_argument() メソッド
ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])
1つのコマンドライン引数がどう解析されるかを定義します。各引数についての詳細は後述しますが、簡単に言うと:

name または flags - 名前か、あるいはオプション文字列のリスト (例: foo や -f, --foo)。

action - コマンドラインにこの引数があったときのアクション。

nargs - 受け取るべきコマンドライン引数の数。

const - 一部の action と nargs の組み合わせで利用される定数。

default - The value produced if the argument is absent from the command line and if it is absent from the namespace object.

type - コマンドライン引数が変換されるべき型。

choices - 引数として許される値のコンテナー。

required - コマンドラインオプションが省略可能かどうか (オプション引数のみ)。

help - 引数が何なのかを示す簡潔な説明。

metavar - 使用法メッセージの中で使われる引数の名前。

dest - parse_args() が返すオブジェクトに追加される属性名。

以下の節では各オプションの利用方法を説明します。

name または flags
add_argument() メソッドは、指定されている引数が -f や --foo のようなオプション引数なのか、ファイル名リストなどの位置引数なのかを知る必要があります。 そのため、 add_argument() に初めに渡される引数は、一連のフラグか、単一の引数名のどちらかになります。 例えば、オプション引数は次のようにして作成されます:

>>>
>>> parser.add_argument('-f', '--foo')
一方、位置引数は次のように作成します:

>>>
>>> parser.add_argument('bar')
parse_args() が呼ばれたとき、オプション引数は接頭辞 - により識別され、それ以外の引数は位置引数として扱われます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-f', '--foo')
>>> parser.add_argument('bar')
>>> parser.parse_args(['BAR'])
Namespace(bar='BAR', foo=None)
>>> parser.parse_args(['BAR', '--foo', 'FOO'])
Namespace(bar='BAR', foo='FOO')
>>> parser.parse_args(['--foo', 'FOO'])
usage: PROG [-h] [-f FOO] bar
PROG: error: the following arguments are required: bar
action
ArgumentParser オブジェクトはコマンドライン引数にアクションを割り当てます。このアクションは、割り当てられたコマンドライン引数に関してどんな処理でもできますが、ほとんどのアクションは単に parse_args() が返すオブジェクトに属性を追加するだけです。action キーワード引数は、コマンドライン引数がどう処理されるかを指定します。提供されているアクションは:

'store' - これは単に引数の値を格納します。これはデフォルトのアクションです。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.parse_args('--foo 1'.split())
Namespace(foo='1')
'store_const' - このアクションは const キーワード引数で指定された値を格納します。'store_const' アクションは、何かの種類のフラグを指定するオプション引数によく使われます。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_const', const=42)
>>> parser.parse_args(['--foo'])
Namespace(foo=42)
'store_true', 'store_false' - これらは 'store_const' の、それぞれ True と False を格納する特別版になります。加えて、これらはそれぞれデフォルト値を順に False と True にします。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_true')
>>> parser.add_argument('--bar', action='store_false')
>>> parser.add_argument('--baz', action='store_false')
>>> parser.parse_args('--foo --bar'.split())
Namespace(foo=True, bar=False, baz=True)
'append' - このアクションはリストを格納して、各引数の値をそのリストに追加します。このアクションは複数回指定を許可したいオプションに便利です。利用例:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='append')
>>> parser.parse_args('--foo 1 --foo 2'.split())
Namespace(foo=['1', '2'])
'append_const' - このアクションはリストを格納して、const キーワード引数に与えられた値をそのリストに追加します (const キーワード引数のデフォルト値はあまり役に立たない None であることに注意)。'append_const' アクションは、定数を同じリストに複数回格納する場合に便利です。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--str', dest='types', action='append_const', const=str)
>>> parser.add_argument('--int', dest='types', action='append_const', const=int)
>>> parser.parse_args('--str --int'.split())
Namespace(types=[<class 'str'>, <class 'int'>])
'count' - このアクションはキーワード引数の数を数えます。例えば、verboseレベルを上げるのに役立ちます:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--verbose', '-v', action='count', default=0)
>>> parser.parse_args(['-vvv'])
Namespace(verbose=3)
default は明示的に 0 と指定されない場合は None であることに注意してください。

'help' - このアクションは現在のパーサー中のすべてのオプションのヘルプメッセージを表示し、終了します。出力の生成方法の詳細については ArgumentParser を参照してください。

'version' - このアクションは add_argument() の呼び出しに version= キーワード引数を期待します。指定されたときはバージョン情報を表示して終了します:

>>>
>>> import argparse
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')
>>> parser.parse_args(['--version'])
PROG 2.0
'extend' - このアクションはリストを格納して、各引数の値でそのリストを拡張します。利用例:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument("--foo", action="extend", nargs="+", type=str)
>>> parser.parse_args(["--foo", "f1", "--foo", "f2", "f3", "f4"])
Namespace(foo=['f1', 'f2', 'f3', 'f4'])
バージョン 3.8 で追加.

You may also specify an arbitrary action by passing an Action subclass or other object that implements the same interface. The BooleanOptionalAction is available in argparse and adds support for boolean actions such as --foo and --no-foo:

>>>
>>> import argparse
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)
>>> parser.parse_args(['--no-foo'])
Namespace(foo=False)
The recommended way to create a custom action is to extend Action, overriding the __call__ method and optionally the __init__ and format_usage methods.

カスタムアクションの例です:

>>>
>>> class FooAction(argparse.Action):
...     def __init__(self, option_strings, dest, nargs=None, **kwargs):
...         if nargs is not None:
...             raise ValueError("nargs not allowed")
...         super(FooAction, self).__init__(option_strings, dest, **kwargs)
...     def __call__(self, parser, namespace, values, option_string=None):
...         print('%r %r %r' % (namespace, values, option_string))
...         setattr(namespace, self.dest, values)
...
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action=FooAction)
>>> parser.add_argument('bar', action=FooAction)
>>> args = parser.parse_args('1 --foo 2'.split())
Namespace(bar=None, foo=None) '1' None
Namespace(bar='1', foo=None) '2' '--foo'
>>> args
Namespace(bar='1', foo='2')
詳細は Action を参照してください。

nargs
ArgumentParser オブジェクトは通常1つのコマンドライン引数を1つのアクションに渡します。nargs キーワード引数は1つのアクションにそれ以外の数のコマンドライン引数を割り当てます。指定できる値は:

N (整数) -- N 個の引数がコマンドラインから集められ、リストに格納されます。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', nargs=2)
>>> parser.add_argument('bar', nargs=1)
>>> parser.parse_args('c --foo a b'.split())
Namespace(bar=['c'], foo=['a', 'b'])
nargs=1 は1要素のリストを作ることに注意してください。これはデフォルトの、要素がそのまま属性になる動作とは異なります。

'?' -- 可能なら1つの引数がコマンドラインから取られ、1つのアイテムを作ります。コマンドライン引数が存在しない場合、default の値が生成されます。オプション引数の場合、さらにオプション引数が指定され、その後にコマンドライン引数がないというケースもありえます。この場合は const の値が生成されます。この動作の例です:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', nargs='?', const='c', default='d')
>>> parser.add_argument('bar', nargs='?', default='d')
>>> parser.parse_args(['XX', '--foo', 'YY'])
Namespace(bar='XX', foo='YY')
>>> parser.parse_args(['XX', '--foo'])
Namespace(bar='XX', foo='c')
>>> parser.parse_args([])
Namespace(bar='d', foo='d')
nargs='?' のよくある利用例の1つは、入出力ファイルの指定オプションです:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
...                     default=sys.stdin)
>>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),
...                     default=sys.stdout)
>>> parser.parse_args(['input.txt', 'output.txt'])
Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,
          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)
>>> parser.parse_args([])
Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,
          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)
'*' -- すべてのコマンドライン引数がリストに集められます。複数の位置引数が nargs='*' を持つことにあまり意味はありませんが、複数のオプション引数が nargs='*' を持つことはありえます。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', nargs='*')
>>> parser.add_argument('--bar', nargs='*')
>>> parser.add_argument('baz', nargs='*')
>>> parser.parse_args('a b --foo x y --bar 1 2'.split())
Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])
'+' -- '*' と同じように、すべてのコマンドライン引数をリストに集めます。加えて、最低でも1つのコマンドライン引数が存在しない場合にエラーメッセージを生成します。例えば:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('foo', nargs='+')
>>> parser.parse_args(['a', 'b'])
Namespace(foo=['a', 'b'])
>>> parser.parse_args([])
usage: PROG [-h] foo [foo ...]
PROG: error: the following arguments are required: foo
nargs キーワード引数が指定されない場合、受け取る引数の数は action によって決定されます。通常これは、1つのコマンドライン引数は1つのアイテムになる (リストにはならない) ことを意味します。

const
add_argument() の const 引数は、コマンドライン引数から読み込まれないけれども ArgumentParser のいくつかのアクションで必要とされる値のために使われます。この引数のよくある2つの使用法は:

add_argument() が action='store_const' か action='append_const' で呼び出されたとき、これらのアクションは const の値を parse_args() が返すオブジェクトの属性に追加します。サンプルは action の説明を参照してください。

add_argument() がオプション文字列 (-f や --foo) と nargs='?' で呼び出された場合。この場合0個か1つのコマンドライン引数を取るオプション引数が作られます。オプション引数にコマンドライン引数が続かなかった場合、 const の値が代わりに利用されます。サンプルは nargs の説明を参照してください。

'store_const' と 'append_const' アクションでは、 const キーワード引数を与える必要があります。他のアクションでは、デフォルトは None になります。

default
すべてのオプション引数といくつかの位置引数はコマンドライン上で省略されることがあります。 add_argument() の default キーワード引数 (デフォルト: None) は、コマンドライン引数が存在しなかった場合に利用する値を指定します。オプション引数では、オプション文字列がコマンドライン上に存在しなかったときに default の値が利用されます:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default=42)
>>> parser.parse_args(['--foo', '2'])
Namespace(foo='2')
>>> parser.parse_args([])
Namespace(foo=42)
If the target namespace already has an attribute set, the action default will not over write it:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default=42)
>>> parser.parse_args([], namespace=argparse.Namespace(foo=101))
Namespace(foo=101)
default の値が文字列の場合、パーサーは値をコマンドライン引数のように解析します。具体的には、パーサーは返り値 Namespace の属性を設定する前に、type 変換引数が与えられていればそれらを適用します。そうでない場合、パーサーは値をそのまま使用します:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--length', default='10', type=int)
>>> parser.add_argument('--width', default=10.5, type=int)
>>> parser.parse_args()
Namespace(length=10, width=10.5)
nargs が ? か * である位置引数では、コマンドライン引数が指定されなかった場合 default の値が使われます。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('foo', nargs='?', default=42)
>>> parser.parse_args(['a'])
Namespace(foo='a')
>>> parser.parse_args([])
Namespace(foo=42)
default=argparse.SUPPRESS を渡すと、コマンドライン引数が存在しないときに属性の追加をしなくなります:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default=argparse.SUPPRESS)
>>> parser.parse_args([])
Namespace()
>>> parser.parse_args(['--foo', '1'])
Namespace(foo='1')
type
By default, the parser reads command-line arguments in as simple strings. However, quite often the command-line string should instead be interpreted as another type, such as a float or int. The type keyword for add_argument() allows any necessary type-checking and type conversions to be performed.

If the type keyword is used with the default keyword, the type converter is only applied if the default is a string.

The argument to type can be any callable that accepts a single string. If the function raises ArgumentTypeError, TypeError, or ValueError, the exception is caught and a nicely formatted error message is displayed. No other exception types are handled.

Common built-in types and functions can be used as type converters:

import argparse
import pathlib

parser = argparse.ArgumentParser()
parser.add_argument('count', type=int)
parser.add_argument('distance', type=float)
parser.add_argument('street', type=ascii)
parser.add_argument('code_point', type=ord)
parser.add_argument('source_file', type=open)
parser.add_argument('dest_file', type=argparse.FileType('w', encoding='latin-1'))
parser.add_argument('datapath', type=pathlib.Path)
User defined functions can be used as well:

>>> def hyphenated(string):
...     return '-'.join([word[:4] for word in string.casefold().split()])
...
>>> parser = argparse.ArgumentParser()
>>> _ = parser.add_argument('short_title', type=hyphenated)
>>> parser.parse_args(['"The Tale of Two Cities"'])
Namespace(short_title='"the-tale-of-two-citi')
The bool() function is not recommended as a type converter. All it does is convert empty strings to False and non-empty strings to True. This is usually not what is desired.

In general, the type keyword is a convenience that should only be used for simple conversions that can only raise one of the three supported exceptions. Anything with more interesting error-handling or resource management should be done downstream after the arguments are parsed.

For example, JSON or YAML conversions have complex error cases that require better reporting than can be given by the type keyword. An JSONDecodeError would not be well formatted and a FileNotFound exception would not be handled at all.

Even FileType has its limitations for use with the type keyword. If one argument uses FileType and then a subsequent argument fails, an error is reported but the file is not automatically closed. In this case, it would be better to wait until after the parser has run and then use the with-statement to manage the files.

For type checkers that simply check against a fixed set of values, consider using the choices keyword instead.

choices
コマンドライン引数をいくつかの選択肢の中から選ばせたい場合があります。 これは add_argument() に choices キーワード引数を渡すことで可能です。コマンドラインを解析するとき、引数の値がチェックされ、その値が選択肢の中に含まれていない場合はエラーメッセージを表示します:

>>>
>>> parser = argparse.ArgumentParser(prog='game.py')
>>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
>>> parser.parse_args(['rock'])
Namespace(move='rock')
>>> parser.parse_args(['fire'])
usage: game.py [-h] {rock,paper,scissors}
game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',
'paper', 'scissors')
choices コンテナーに含まれているかどうかのチェックは、type による型変換が実行された後であることに注意してください。このため、choices に格納するオブジェクトの型は指定された type にマッチしている必要があります:

>>>
>>> parser = argparse.ArgumentParser(prog='doors.py')
>>> parser.add_argument('door', type=int, choices=range(1, 4))
>>> print(parser.parse_args(['3']))
Namespace(door=3)
>>> parser.parse_args(['4'])
usage: doors.py [-h] {1,2,3}
doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)
任意のコンテナを choices に渡すことができます。すなわち、list 、 set、カスタムコンテナなどはすべてサポートされています。

Use of enum.Enum is not recommended because it is difficult to control its appearance in usage, help, and error messages.

Formatted choices overrides the default metavar which is normally derived from dest. This is usually what you want because the user never sees the dest parameter. If this display isn't desirable (perhaps because there are many choices), just specify an explicit metavar.

required
通常 argparse モジュールは、-f や --bar といったフラグは 任意 の引数 (オプション引数) だと仮定し、コマンドライン上になくても良いものとして扱います。フラグの指定を 必須 にするには、add_argument() の required= キーワード引数に True を指定します:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', required=True)
>>> parser.parse_args(['--foo', 'BAR'])
Namespace(foo='BAR')
>>> parser.parse_args([])
usage: [-h] --foo FOO
: error: the following arguments are required: --foo
上の例のように、引数が required と指定されると、parse_args() はそのフラグがコマンドラインに存在しないときにエラーを表示します。

注釈 ユーザーは、通常 フラグ の指定は 任意 であると認識しているため、必須にするのは一般的には悪いやり方で、できる限り避けるべきです。
help
help の値はその引数の簡潔な説明を含む文字列です。ユーザーが (コマンドライン上で -h か --help を指定するなどして) ヘルプを要求したとき、この help の説明が各引数に表示されます:

>>>
>>> parser = argparse.ArgumentParser(prog='frobble')
>>> parser.add_argument('--foo', action='store_true',
...                     help='foo the bars before frobbling')
>>> parser.add_argument('bar', nargs='+',
...                     help='one of the bars to be frobbled')
>>> parser.parse_args(['-h'])
usage: frobble [-h] [--foo] bar [bar ...]

positional arguments:
 bar     one of the bars to be frobbled

optional arguments:
 -h, --help  show this help message and exit
 --foo   foo the bars before frobbling
help 文字列には、プログラム名や引数の default などを繰り返し記述するのを避けるためのフォーマット指定子を含めることができます。利用できる指定子には、プログラム名 %(prog)s と、 %(default)s や %(type)s など add_argument() のキーワード引数の多くが含まれます:

>>>
>>> parser = argparse.ArgumentParser(prog='frobble')
>>> parser.add_argument('bar', nargs='?', type=int, default=42,
...                     help='the bar to %(prog)s (default: %(default)s)')
>>> parser.print_help()
usage: frobble [-h] [bar]

positional arguments:
 bar     the bar to frobble (default: 42)

optional arguments:
 -h, --help  show this help message and exit
ヘルプ文字列は %-フォーマットをサポートしているので、ヘルプ文字列内にリテラル % を表示したい場合は %% のようにエスケープしなければなりません。

argparse は help に argparse.SUPPRESS を設定することで、特定のオプションをヘルプに表示させないことができます:

>>>
>>> parser = argparse.ArgumentParser(prog='frobble')
>>> parser.add_argument('--foo', help=argparse.SUPPRESS)
>>> parser.print_help()
usage: frobble [-h]

optional arguments:
  -h, --help  show this help message and exit
metavar
ArgumentParser がヘルプメッセージを出力するとき、各引数に対してなんらかの参照方法が必要です。デフォルトでは、 ArgumentParser オブジェクトは各オブジェクトの "名前" として dest を利用します。デフォルトでは、位置引数には dest の値をそのまま 利用し、オプション引数については dest の値を大文字に変換して利用します。このため、1つの dest='bar' である位置引数は bar として参照されます。 1つのオプション引数 --foo が1つのコマンドライン引数を要求するときは、その引数は FOO として参照されます。以下に例を示します:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.add_argument('bar')
>>> parser.parse_args('X --foo Y'.split())
Namespace(bar='X', foo='Y')
>>> parser.print_help()
usage:  [-h] [--foo FOO] bar

positional arguments:
 bar

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO
代わりの名前を、metavar として指定できます:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', metavar='YYY')
>>> parser.add_argument('bar', metavar='XXX')
>>> parser.parse_args('X --foo Y'.split())
Namespace(bar='X', foo='Y')
>>> parser.print_help()
usage:  [-h] [--foo YYY] XXX

positional arguments:
 XXX

optional arguments:
 -h, --help  show this help message and exit
 --foo YYY
metavar は 表示される 名前だけを変更することに注意してください。parse_args() の返すオブジェクトの属性名は dest の値のままです。

nargs を指定した場合、metavar が複数回利用されるかもしれません。metavar にタプルを渡すと、各引数に対して異なる名前を指定できます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-x', nargs=2)
>>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))
>>> parser.print_help()
usage: PROG [-h] [-x X X] [--foo bar baz]

optional arguments:
 -h, --help     show this help message and exit
 -x X X
 --foo bar baz
dest
ほとんどの ArgumentParser のアクションは parse_args() が返すオブジェクトに対する属性として値を追加します。この属性の名前は add_argument() の dest キーワード引数によって決定されます。位置引数のアクションについては、 dest は通常 add_argument() の第一引数として渡します:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('bar')
>>> parser.parse_args(['XXX'])
Namespace(bar='XXX')
オプション引数のアクションについては、 dest の値は通常オプション文字列から生成されます。 ArgumentParser は最初の長いオプション文字列を選択し、先頭の -- を除去することで dest の値を生成します。長いオプション文字列が指定されていない場合、最初の短いオプション文字列から先頭の - 文字を除去することで dest を生成します。先頭以外のすべての - 文字は、妥当な属性名になるように _ 文字へ変換されます。次の例はこの動作を示しています:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('-f', '--foo-bar', '--foo')
>>> parser.add_argument('-x', '-y')
>>> parser.parse_args('-f 1 -x 2'.split())
Namespace(foo_bar='1', x='2')
>>> parser.parse_args('--foo 1 -y 2'.split())
Namespace(foo_bar='1', x='2')
dest にカスタムの属性名を与えることも可能です:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', dest='bar')
>>> parser.parse_args('--foo XXX'.split())
Namespace(bar='XXX')
Action クラス
Acrtion クラスは Action API、すなわちコマンドラインからの引数を処理する呼び出し可能オブジェクトを返す呼び出し可能オブジェクトを実装します。この API に従うあらゆるオブジェクトは action 引数として add_argument() に渡すことができます。

class argparse.Action(option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)
Action オブジェクトは、コマンドラインからの一つ以上の文字列から単一の引数を解析するのに必要とされる情報を表現するために ArgumentParser によって使われます。Action クラス 2 つの位置引数と、action それ自身を除く ArgumentParser.add_argument() に渡されるすべてのキーワード引数を受け付けなければなりません。

Action のインスタンス (あるいは action 引数に渡す任意の呼び出し可能オブジェクトの返り値) は、属性 "dest", "option_strings", "default", "type", "required", "help", などを定義しなければなりません。これらの属性を定義するのを確実にするためにもっとも簡単な方法は、Action.__init__ を呼び出すことです。

Action インスタンスは呼び出し可能でなければならず、したがって、サブクラスは 4 つの引数を受け取る __call__ メソッドをオーバライドしなければなりません:

parser - このアクションを持っている ArgumentParser オブジェクト。

namespace - parse_args() が返す Namespace オブジェクト。ほとんどのアクションはこのオブジェクトに属性を setattr() を使って追加します。

values - 型変換が適用された後の、関連付けられたコマンドライン引数。型変換は add_argument() メソッドの type キーワード引数で指定されます。

option_string - このアクションを実行したオプション文字列。option_string 引数はオプションで、アクションが位置引数に関連付けられた場合は渡されません。

__call__ メソッドでは任意のアクションを行えますが、 典型的にはそれは dest, values に基づく namespace に属性をセットすることでしょう。

Action subclasses can define a format_usage method that takes no argument and return a string which will be used when printing the usage of the program. If such method is not provided, a sensible default will be used.

parse_args() メソッド
ArgumentParser.parse_args(args=None, namespace=None)
引数の文字列をオブジェクトに変換し、namespace オブジェクトの属性に代入します。結果の namespace オブジェクトを返します。

事前の add_argument() メソッドの呼び出しにより、どのオブジェクトが生成されてどう代入されるかが決定されます。詳細は add_argument() のドキュメントを参照してください。

args - 解析する文字列のリスト。デフォルトでは sys.argv から取得されます。

namespace - 属性を代入するオブジェクト。デフォルトでは、新しい空の Namespace オブジェクトです。

オプション値の文法
parse_args() メソッドは、オプションの値がある場合、そのオプションの値の指定に複数の方法をサポートしています。もっとも単純な場合には、オプションとその値は次のように2つの別々の引数として渡されます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-x')
>>> parser.add_argument('--foo')
>>> parser.parse_args(['-x', 'X'])
Namespace(foo=None, x='X')
>>> parser.parse_args(['--foo', 'FOO'])
Namespace(foo='FOO', x=None)
長いオプション (1文字よりも長い名前を持ったオプション) では、オプションとその値は次のように = で区切られた1つのコマンドライン引数として渡すこともできます:

>>>
>>> parser.parse_args(['--foo=FOO'])
Namespace(foo='FOO', x=None)
短いオプション (1文字のオプション) では、オプションとその値は次のように連結して渡すことができます:

>>>
>>> parser.parse_args(['-xX'])
Namespace(foo=None, x='X')
最後の1つのオプションだけが値を要求する場合、または値を要求するオプションがない場合、複数の短いオプションは次のように1つの接頭辞 - だけで連結できます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-x', action='store_true')
>>> parser.add_argument('-y', action='store_true')
>>> parser.add_argument('-z')
>>> parser.parse_args(['-xyzZ'])
Namespace(x=True, y=True, z='Z')
不正な引数
parse_args() は、コマンドラインの解析中に、曖昧なオプション、不正な型、不正なオプション、位置引数の数の不一致などのエラーを検証します。それらのエラーが発生した場合、エラーメッセージと使用法メッセージを表示して終了します:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--foo', type=int)
>>> parser.add_argument('bar', nargs='?')

>>> # invalid type
>>> parser.parse_args(['--foo', 'spam'])
usage: PROG [-h] [--foo FOO] [bar]
PROG: error: argument --foo: invalid int value: 'spam'

>>> # invalid option
>>> parser.parse_args(['--bar'])
usage: PROG [-h] [--foo FOO] [bar]
PROG: error: no such option: --bar

>>> # wrong number of arguments
>>> parser.parse_args(['spam', 'badger'])
usage: PROG [-h] [--foo FOO] [bar]
PROG: error: extra arguments found: badger
- を含む引数
parse_args() メソッドは、ユーザーが明らかなミスをした場合はエラーを表示しますが、いくつか本質的に曖昧な場面があります。例えば、コマンドライン引数 -1 は、オプションの指定かもしれませんし位置引数かもしれません。parse_args() メソッドはこれを次のように扱います: 負の数として解釈でき、パーサーに負の数のように解釈できるオプションが存在しない場合にのみ、- で始まる位置引数になりえます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-x')
>>> parser.add_argument('foo', nargs='?')

>>> # no negative number options, so -1 is a positional argument
>>> parser.parse_args(['-x', '-1'])
Namespace(foo=None, x='-1')

>>> # no negative number options, so -1 and -5 are positional arguments
>>> parser.parse_args(['-x', '-1', '-5'])
Namespace(foo='-5', x='-1')

>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-1', dest='one')
>>> parser.add_argument('foo', nargs='?')

>>> # negative number options present, so -1 is an option
>>> parser.parse_args(['-1', 'X'])
Namespace(foo=None, one='X')

>>> # negative number options present, so -2 is an option
>>> parser.parse_args(['-2'])
usage: PROG [-h] [-1 ONE] [foo]
PROG: error: no such option: -2

>>> # negative number options present, so both -1s are options
>>> parser.parse_args(['-1', '-1'])
usage: PROG [-h] [-1 ONE] [foo]
PROG: error: argument -1: expected one argument
- で始まる位置引数があって、それが負の数として解釈できない場合、ダミーの引数 '--' を挿入して、parse_args() にそれ以降のすべてが位置引数だと教えることができます:

>>>
>>> parser.parse_args(['--', '-f'])
Namespace(foo='-f', one=None)
引数の短縮形 (先頭文字でのマッチング)
parse_args() メソッドは、デフォルトで、長いオプションに曖昧さがない (先頭の文字が一意である) かぎり、先頭の一文字に短縮して指定できます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-bacon')
>>> parser.add_argument('-badger')
>>> parser.parse_args('-bac MMM'.split())
Namespace(bacon='MMM', badger=None)
>>> parser.parse_args('-bad WOOD'.split())
Namespace(bacon=None, badger='WOOD')
>>> parser.parse_args('-ba BA'.split())
usage: PROG [-h] [-bacon BACON] [-badger BADGER]
PROG: error: ambiguous option: -ba could match -badger, -bacon
先頭の文字が同じ引数が複数ある場合に短縮指定を行うとエラーを発生させます。この機能は allow_abbrev に False を指定することで無効にできます。

sys.argv 以外
ArgumentParser が sys.argv 以外の引数を解析できると役に立つ場合があります。その場合は文字列のリストを parse_args() に渡します。これはインタラクティブプロンプトからテストするときに便利です:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument(
...     'integers', metavar='int', type=int, choices=range(10),
...     nargs='+', help='an integer in the range 0..9')
>>> parser.add_argument(
...     '--sum', dest='accumulate', action='store_const', const=sum,
...     default=max, help='sum the integers (default: find the max)')
>>> parser.parse_args(['1', '2', '3', '4'])
Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])
>>> parser.parse_args(['1', '2', '3', '4', '--sum'])
Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])
Namespace オブジェクト
class argparse.Namespace
parse_args() が属性を格納して返すためのオブジェクトにデフォルトで使用されるシンプルなクラスです。

デフォルトでは、 parse_args() は Namespace の新しいオブジェクトに必要な属性を設定して返します。このクラスはシンプルに設計されており、単に読みやすい文字列表現を持った object のサブクラスです。もし属性を辞書のように扱える方が良ければ、標準的な Python のイディオム vars() を利用できます:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> args = parser.parse_args(['--foo', 'BAR'])
>>> vars(args)
{'foo': 'BAR'}
ArgumentParser が、新しい Namespace オブジェクトではなく、既存のオブジェクトに属性を設定する方が良い場合があります。これは namespace= キーワード引数を指定することで可能です:

>>>
>>> class C:
...     pass
...
>>> c = C()
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)
>>> c.foo
'BAR'
その他のユーティリティ
サブコマンド
ArgumentParser.add_subparsers([title][, description][, prog][, parser_class][, action][, option_string][, dest][, required][, help][, metavar])
多くのプログラムは、その機能をサブコマンドへと分割します。 例えば svn プログラムは svn checkout, svn update, svn commit などのサブコマンドを利用できます。 機能をサブコマンドに分割するのは、プログラムがいくつかの異なった機能を持っていて、 それぞれが異なるコマンドライン引数を必要とする場合には良いアイデアです。 ArgumentParser は add_subparsers() メソッドによりサブコマンドを サポートしています。 add_subparsers() メソッドは通常引数なしに呼び出され、 特殊なアクションオブジェクトを返します。このオブジェクトには1つのメソッド add_parser() があり、コマンド名と ArgumentParser コンストラクターの任意の引数を受け取り、通常の方法で操作できる ArgumentParser オブジェクトを返します。

引数の説明:

title - ヘルプ出力でのサブパーサーグループのタイトルです。デフォルトは、description が指定されている場合は "subcommands" に、指定されていない場合は位置引数のタイトルになります

description - ヘルプ出力に表示されるサブパーサーグループの説明です。デフォルトは None になります

prog - サブコマンドのヘルプに表示される使用方法の説明です。デフォルトではプログラム名と位置引数の後ろに、サブパーサーの引数が続きます

parser_class - サブパーサーのインスタンスを作成するときに使用されるクラスです。デフォルトでは現在のパーサーのクラス (例: ArgumentParser) になります

action - コマンドラインにこの引数があったときの基本のアクション。

dest - サブコマンド名を格納する属性の名前です。デフォルトは None で値は格納されません

required - サブコマンドが必須であるかどうかを指定し、デフォルトは False です。(3.7 より追加)

help - ヘルプ出力に表示されるサブパーサーグループのヘルプです。デフォルトは None です

metavar - 利用可能なサブコマンドをヘルプ内で表示するための文字列です。デフォルトは None で、サブコマンドを {cmd1, cmd2, ..} のような形式で表します

いくつかの使用例:

>>>
>>> # create the top-level parser
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--foo', action='store_true', help='foo help')
>>> subparsers = parser.add_subparsers(help='sub-command help')
>>>
>>> # create the parser for the "a" command
>>> parser_a = subparsers.add_parser('a', help='a help')
>>> parser_a.add_argument('bar', type=int, help='bar help')
>>>
>>> # create the parser for the "b" command
>>> parser_b = subparsers.add_parser('b', help='b help')
>>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')
>>>
>>> # parse some argument lists
>>> parser.parse_args(['a', '12'])
Namespace(bar=12, foo=False)
>>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])
Namespace(baz='Z', foo=True)
parse_args() が返すオブジェクトにはメインパーサーとコマンドラインで選択されたサブパーサーによる属性だけが設定されており、選択されなかったサブコマンドのパーサーの属性が設定されていないことに注意してください。このため、上の例では、a コマンドが指定されたときは foo, bar 属性だけが存在し、b コマンドが指定されたときは foo, baz 属性だけが存在しています。

同じように、サブパーサーにヘルプメッセージが要求された場合は、そのパーサーに対するヘルプだけが表示されます。ヘルプメッセージには親パーサーや兄弟パーサーのヘルプメッセージを表示しません。 (ただし、各サブパーサーコマンドのヘルプメッセージは、上の例にもあるように add_parser() の help= 引数によって指定できます)

>>>
>>> parser.parse_args(['--help'])
usage: PROG [-h] [--foo] {a,b} ...

positional arguments:
  {a,b}   sub-command help
    a     a help
    b     b help

optional arguments:
  -h, --help  show this help message and exit
  --foo   foo help

>>> parser.parse_args(['a', '--help'])
usage: PROG a [-h] bar

positional arguments:
  bar     bar help

optional arguments:
  -h, --help  show this help message and exit

>>> parser.parse_args(['b', '--help'])
usage: PROG b [-h] [--baz {X,Y,Z}]

optional arguments:
  -h, --help     show this help message and exit
  --baz {X,Y,Z}  baz help
add_subparsers() メソッドは title と description キーワード引数もサポートしています。どちらかが存在する場合、サブパーサーのコマンドはヘルプ出力でそれぞれのグループの中に表示されます。例えば:

>>>
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers(title='subcommands',
...                                    description='valid subcommands',
...                                    help='additional help')
>>> subparsers.add_parser('foo')
>>> subparsers.add_parser('bar')
>>> parser.parse_args(['-h'])
usage:  [-h] {foo,bar} ...

optional arguments:
  -h, --help  show this help message and exit

subcommands:
  valid subcommands

  {foo,bar}   additional help
さらに、add_parser は aliases 引数もサポートしており、同じサブパーサーに対して複数の文字列で参照することもできます。以下の例では svn のように checkout の短縮形として co を使用できるようにしています:

>>>
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers()
>>> checkout = subparsers.add_parser('checkout', aliases=['co'])
>>> checkout.add_argument('foo')
>>> parser.parse_args(['co', 'bar'])
Namespace(foo='bar')
サブコマンドを扱う1つの便利な方法は add_subparsers() メソッドと set_defaults() を組み合わせて、各サブパーサーにどの Python 関数を実行するかを教えることです。例えば:

>>>
>>> # sub-command functions
>>> def foo(args):
...     print(args.x * args.y)
...
>>> def bar(args):
...     print('((%s))' % args.z)
...
>>> # create the top-level parser
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers()
>>>
>>> # create the parser for the "foo" command
>>> parser_foo = subparsers.add_parser('foo')
>>> parser_foo.add_argument('-x', type=int, default=1)
>>> parser_foo.add_argument('y', type=float)
>>> parser_foo.set_defaults(func=foo)
>>>
>>> # create the parser for the "bar" command
>>> parser_bar = subparsers.add_parser('bar')
>>> parser_bar.add_argument('z')
>>> parser_bar.set_defaults(func=bar)
>>>
>>> # parse the args and call whatever function was selected
>>> args = parser.parse_args('foo 1 -x 2'.split())
>>> args.func(args)
2.0
>>>
>>> # parse the args and call whatever function was selected
>>> args = parser.parse_args('bar XYZYX'.split())
>>> args.func(args)
((XYZYX))
こうすると、parse_args() が引数の解析が終わってから適切な関数を呼び出すようになります。このように関数をアクションに関連付けるのは一般的にサブパーサーごとに異なるアクションを扱うもっとも簡単な方法です。ただし、実行されたサブパーサーの名前を確認する必要がある場合は、add_subparsers() を呼び出すときに dest キーワードを指定できます:

>>>
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers(dest='subparser_name')
>>> subparser1 = subparsers.add_parser('1')
>>> subparser1.add_argument('-x')
>>> subparser2 = subparsers.add_parser('2')
>>> subparser2.add_argument('y')
>>> parser.parse_args(['2', 'frobble'])
Namespace(subparser_name='2', y='frobble')
バージョン 3.7 で変更: 新しい required キーワード引数。

FileType オブジェクト
class argparse.FileType(mode='r', bufsize=-1, encoding=None, errors=None)
FileType ファクトリは ArgumentParser.add_argument() の type 引数に渡すことができるオブジェクトを生成します。 type が FileType オブジェクトである引数はコマンドライン引数を、指定されたモード、バッファーサイズ、エンコーディング、エラー処理でファイルとして開きます (詳細は open() 関数を参照してください。):

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))
>>> parser.add_argument('out', type=argparse.FileType('w', encoding='UTF-8'))
>>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])
Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, raw=<_io.FileIO name='raw.dat' mode='wb'>)
FileType オブジェクトは擬似引数 '-' を識別し、読み込み用の FileType であれば sys.stdin を、書き込み用の FileType であれば sys.stdout に変換します:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('infile', type=argparse.FileType('r'))
>>> parser.parse_args(['-'])
Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)
バージョン 3.4 で追加: encoding および errors キーワードが追加されました。

引数グループ
ArgumentParser.add_argument_group(title=None, description=None)
デフォルトでは、 ArgumentParser はヘルプメッセージを表示するときに、コマンドライン引数を "位置引数" と "オプション引数" にグループ化します。このデフォルトの動作よりも良い引数のグループ化方法がある場合、 add_argument_group() メソッドで適切なグループを作成できます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> group = parser.add_argument_group('group')
>>> group.add_argument('--foo', help='foo help')
>>> group.add_argument('bar', help='bar help')
>>> parser.print_help()
usage: PROG [--foo FOO] bar

group:
  bar    bar help
  --foo FOO  foo help
add_argument_group() メソッドは、通常の ArgumentParser と同じような add_argument() メソッドを持つ引数グループオブジェクトを返します。引数がグループに追加された時、パーサーはその引数を通常の引数のように扱いますが、ヘルプメッセージではその引数を分離されたグループの中に表示します。 add_argument_group() メソッドには、この表示をカスタマイズするための title と description 引数があります:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> group1 = parser.add_argument_group('group1', 'group1 description')
>>> group1.add_argument('foo', help='foo help')
>>> group2 = parser.add_argument_group('group2', 'group2 description')
>>> group2.add_argument('--bar', help='bar help')
>>> parser.print_help()
usage: PROG [--bar BAR] foo

group1:
  group1 description

  foo    foo help

group2:
  group2 description

  --bar BAR  bar help
ユーザー定義グループにないすべての引数は通常の "位置引数" と "オプション引数" セクションに表示されます。

相互排他
ArgumentParser.add_mutually_exclusive_group(required=False)
相互排他グループを作ります。argparse は相互排他グループの中でただ1つの引数のみが存在することを確認します:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> group = parser.add_mutually_exclusive_group()
>>> group.add_argument('--foo', action='store_true')
>>> group.add_argument('--bar', action='store_false')
>>> parser.parse_args(['--foo'])
Namespace(bar=True, foo=True)
>>> parser.parse_args(['--bar'])
Namespace(bar=False, foo=False)
>>> parser.parse_args(['--foo', '--bar'])
usage: PROG [-h] [--foo | --bar]
PROG: error: argument --bar: not allowed with argument --foo
add_mutually_exclusive_group() メソッドの引数 required に True 値を指定すると、その相互排他引数のどれか 1つを選ぶことが要求さます:

>>>
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> group = parser.add_mutually_exclusive_group(required=True)
>>> group.add_argument('--foo', action='store_true')
>>> group.add_argument('--bar', action='store_false')
>>> parser.parse_args([])
usage: PROG [-h] (--foo | --bar)
PROG: error: one of the arguments --foo --bar is required
現在のところ、相互排他引数グループは add_argument_group() の title と description 引数をサポートしていません。

パーサーのデフォルト値
ArgumentParser.set_defaults(**kwargs)
ほとんどの場合、 parse_args() が返すオブジェクトの属性はコマンドライン引数の内容と引数のアクションによってのみ決定されます。 set_defaults() を使うと与えられたコマンドライン引数の内容によらず追加の属性を決定することが可能です:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('foo', type=int)
>>> parser.set_defaults(bar=42, baz='badger')
>>> parser.parse_args(['736'])
Namespace(bar=42, baz='badger', foo=736)
パーサーレベルのデフォルト値は常に引数レベルのデフォルト値を上書きします:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default='bar')
>>> parser.set_defaults(foo='spam')
>>> parser.parse_args([])
Namespace(foo='spam')
パーサーレベルの default は、複数のパーサーを扱うときに特に便利です。このタイプの例については add_subparsers() メソッドを参照してください。

ArgumentParser.get_default(dest)
add_argument() か set_defaults() によって指定された、 namespace の属性のデフォルト値を取得します:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default='badger')
>>> parser.get_default('foo')
'badger'
ヘルプの表示
ほとんどの典型的なアプリケーションでは、parse_args() が使用法やエラーメッセージのフォーマットと表示について面倒を見ます。しかし、いくつかのフォーマットメソッドが利用できます:

ArgumentParser.print_usage(file=None)
ArgumentParser がコマンドラインからどう実行されるべきかの短い説明を表示します。 file が None の時は、 sys.stdout に出力されます。

ArgumentParser.print_help(file=None)
プログラムの使用法と ArgumentParser に登録された引数についての情報を含むヘルプメッセージを表示します。 file が None の時は、 sys.stdout に出力されます。

これらのメソッドの、表示する代わりにシンプルに文字列を返すバージョンもあります:

ArgumentParser.format_usage()
ArgumentParser がコマンドラインからどう実行されるべきかの短い説明を格納した文字列を返します。

ArgumentParser.format_help()
プログラムの使用法と ArgumentParser に登録された引数についての情報を含むヘルプメッセージを格納した文字列を返します。

部分解析
ArgumentParser.parse_known_args(args=None, namespace=None)
ときどき、スクリプトがコマンドライン引数のいくつかだけを解析し、残りの引数は別のスクリプトやプログラムに渡すことがあります。こういった場合、 parse_known_args() メソッドが便利です。これは parse_args() と同じように動作しますが、余分な引数が存在してもエラーを生成しません。代わりに、評価された namespace オブジェクトと、残りの引数文字列のリストからなる2要素タプルを返します。

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_true')
>>> parser.add_argument('bar')
>>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])
(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])
警告 先頭文字でのマッチング ルールは parse_known_args() にも適用されます。たとえ既知のオプションの先頭文字に過ぎない場合でも、パーサは引数リストに残さずに、オプションを受け取る場合があります。
ファイル解析のカスタマイズ
ArgumentParser.convert_arg_line_to_args(arg_line)
ファイルから引数を読み込む場合 (ArgumentParser コンストラクターの fromfile_prefix_chars キーワード引数を参照)、1行につき1つの引数を読み込みます。 convert_arg_line_to_args() を変更することでこの動作をカスタマイズできます。

このメソッドは、引数ファイルから読まれた文字列である1つの引数 arg_line を受け取ります。そしてその文字列を解析した結果の引数のリストを返します。このメソッドはファイルから1行読みこむごとに、順番に呼ばれます。

このメソッドをオーバーライドすると便利なこととして、スペースで区切られた単語を 1 つの引数として扱えます。次の例でその方法を示します:

class MyArgumentParser(argparse.ArgumentParser):
    def convert_arg_line_to_args(self, arg_line):
        return arg_line.split()
終了メソッド
ArgumentParser.exit(status=0, message=None)
このメソッドはプログラムを、status のステータスで終了させ、指定された場合は message を終了前に表示します。ユーザは、この振る舞いを違うものにするために、メソッドをオーバーライドすることができます。

class ErrorCatchingArgumentParser(argparse.ArgumentParser):
    def exit(self, status=0, message=None):
        if status:
            raise Exception(f'Exiting because of an error: {message}')
        exit(status)
ArgumentParser.error(message)
このメソッドは message を含む使用法メッセージを標準エラーに表示して、終了ステータス 2 でプログラムを終了します。

混在した引数の解析
ArgumentParser.parse_intermixed_args(args=None, namespace=None)
ArgumentParser.parse_known_intermixed_args(args=None, namespace=None)
多くの Unix コマンドは、オプション引数と位置引数を混在させることを許しています。 parse_intermixed_args() と parse_known_intermixed_args() メソッドは、このような方法での解析をサポートしています。

このパーサーは、argparse のすべての機能をサポートしておらず、対応しない機能が使われた場合、例外を送出します。特に、サブパーサーや argparse.REMAINDER、位置引数とオプション引数を両方含むような相互排他的なグループは、サポートされていません。

この例は、parse_known_args() と parse_intermixed_args() の違いを表しています: 前者は ['2', '3'] を、解析されない引数として返し、後者は全ての位置引数を rest に入れて返しています:

>>>
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.add_argument('cmd')
>>> parser.add_argument('rest', nargs='*', type=int)
>>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())
(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])
>>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())
Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])
parse_known_intermixed_args() は、解析した内容を含む名前空間と、残りの引数を含んだリストの、2つの要素を持つタプルを返します。 parse_intermixed_args() は、解析されない引数が残された場合にはエラーを送出します。

バージョン 3.7 で追加.

optparse からのアップグレード
もともと、argparse モジュールは optparse モジュールとの互換性を保って開発しようと試みられました。しかし、特に新しい nargs= 指定子とより良い使用法メッセージのために必要な変更のために、optparse を透過的に拡張することは難しかったのです。optparse のほとんどすべてがコピーアンドペーストされたりモンキーパッチを当てられたりしたとき、もはや後方互換性を保とうとすることは現実的ではありませんでした。

argparse モジュールは標準ライブラリ optparse モジュールを、以下を含むたくさんの方法で改善しています:

位置引数を扱う

サブコマンドのサポート

+, / のような代替オプションプレフィクスを許容する

zero-or-more スタイル、one-or-more スタイルの引数を扱う

より有益な使用方法メッセージの生成

カスタム type, カスタム action のために遥かに簡単なインターフェイスを提供する

optparse から argparse への現実的なアップグレードパス:

すべての optparse.OptionParser.add_option() の呼び出しを、ArgumentParser.add_argument() の呼び出しに置き換える。

(options, args) = parser.parse_args() を args = parser.parse_args() に置き換え、位置引数のために必要に応じて ArgumentParser.add_argument() の呼び出しを追加する。これまで options と呼ばれていたものが、argparse では args と呼ばれていることに留意してください。

optparse.OptionParser.disable_interspersed_args() を、parse_args() ではなく parse_intermixed_args() で置き換える。

コールバック・アクションと callback_* キーワード引数を type や action 引数に置き換える。

type キーワード引数に渡していた文字列の名前を、それに応じたオブジェクト (例: int, float, complex, ...) に置き換える。

optparse.Values を Namespace に置き換え、optparse.OptionError と optparse.OptionValueError を ArgumentError に置き換える。

%default や %prog などの暗黙の引数を含む文字列を、%(default)s や %(prog)s などの、通常の Python で辞書を使う場合のフォーマット文字列に置き換える。

OptionParser のコンストラクターの version 引数を、parser.add_argument('--version', action='version', version='<the version>') に置き換える

getopt --- C 言語スタイルのコマンドラインオプションパーサ
ソースコード: Lib/getopt.py

注釈 getopt モジュールは、C 言語の getopt() 関数に慣れ親しんだ人ためにデザインされた API を持つコマンドラインオプションのパーサです。getopt() 関数に慣れ親しんでない人や、コードを少なくしてよりよいヘルプメッセージを表示させたい場合は、argparse モジュールの使用を検討してください。
このモジュールは sys.argv に入っているコマンドラインオプションの構文解析を支援します。'-' や '--' の特別扱いも含めて、Unix の getopt() と同じ記法をサポートしています。3番目の引数 (省略可能) を設定することで、GNU のソフトウェアでサポートされているような長形式のオプションも利用できます。

このモジュールは2つの関数と1つの例外を提供しています:

getopt.getopt(args, shortopts, longopts=[])
コマンドラインオプションとパラメータのリストを構文解析します。args は構文解析の対象になる引数のリストです。これは先頭のプログラム名を除いたもので、通常 sys.argv[1:] で与えられます。shortopts はスクリプトで認識させたいオプション文字と、引数が必要な場合にはコロン (':') をつけます。つまり Unix の getopt() と同じフォーマットになります。

注釈 GNU の getopt() とは違って、オプションでない引数の後は全てオプションではないと判断されます。これは GNUでない、Unix システムの挙動に近いものです。
longopts は長形式のオプションの名前を示す文字列のリストです。名前には、先頭の '--' は含めません。引数が必要な場合には名前の最後に等号 ('=') を入れます。オプション引数はサポートしていません。長形式のオプションだけを受けつけるためには、shortopts は空文字列である必要があります。長形式のオプションは、該当するオプションを一意に決定できる長さまで入力されていれば認識されます。たとえば、longopts が ['foo', 'frob'] の場合、--fo は --foo にマッチしますが、--f では一意に決定できないので、GetoptError が送出されます。

返り値は2つの要素から成っています: 最初は (option, value) のタプルのリスト、2つ目はオプションリストを取り除いたあとに残ったプログラムの引数リストです (args の末尾部分のスライスになります)。それぞれの引数と値のタプルの最初の要素は、短形式の時はハイフン 1つで始まる文字列 (例: '-x')、長形式の時はハイフン2つで始まる文字列 (例: '--long-option') となり、引数が2番目の要素になります。引数をとらない場合には空文字列が入ります。オプションは見つかった順に並んでいて、複数回同じオプションを指定できます。長形式と短形式のオプションは混在できます。

getopt.gnu_getopt(args, shortopts, longopts=[])
この関数はデフォルトで GNU スタイルのスキャンモードを使う以外は getopt() と同じように動作します。つまり、オプションとオプションでない引数とを混在させることができます。getopt() 関数はオプションでない引数を見つけると解析を停止します。

オプション文字列の最初の文字を '+' にするか、環境変数 POSIXLY_CORRECT を設定することで、オプションでない引数を見つけると解析を停止するように振舞いを変えることができます。

exception getopt.GetoptError
引数リストの中に認識できないオプションがあった場合か、引数が必要なオプションに引数が与えられなかった場合に発生します。例外の引数は原因を示す文字列です。長形式のオプションについては、不要な引数が与えられた場合にもこの例外が発生します。 msg 属性と opt 属性で、エラーメッセージと関連するオプションを取得できます。特に関係するオプションが無い場合には opt は空文字列となります。

exception getopt.error
GetoptError へのエイリアスです。後方互換性のために残されています。

Unix スタイルのオプションを使った例です:

>>>
import getopt
args = '-a -b -cfoo -d bar a1 a2'.split()
args
['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']
optlist, args = getopt.getopt(args, 'abc:d:')
optlist
[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]
args
['a1', 'a2']
長形式のオプションを使っても同様です:

>>>
s = '--condition=foo --testing --output-file abc.def -x a1 a2'
args = s.split()
args
['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']
optlist, args = getopt.getopt(args, 'x', [
    'condition=', 'output-file=', 'testing'])
optlist
[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]
args
['a1', 'a2']
スクリプト中での典型的な使い方は以下のようになります:

import getopt, sys

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err)  # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opts:
        if o == "-v":
            verbose = True
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-o", "--output"):
            output = a
        else:
            assert False, "unhandled option"
    # ...

if __name__ == "__main__":
    main()
argparse モジュールを使えば、より良いヘルプメッセージとエラーメッセージを持った同じコマンドラインインタフェースをより少ないコードで実現できます:

import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--output')
    parser.add_argument('-v', dest='verbose', action='store_true')
    args = parser.parse_args()
    # ... do something with args.output ...
    # ... do something with args.verbose ..
参考
argparse モジュール
別のコマンドラインオプションと引数の解析ライブラリ。

logging --- Python 用ロギング機能
ソースコード: Lib/logging/__init__.py

Important

このページには、リファレンス情報だけが含まれています。チュートリアルは、以下のページを参照してください

基本チュートリアル

上級チュートリアル

ロギングクックブック

このモジュールは、アプリケーションやライブラリのための柔軟なエラーログ記録 (logging) システムを実装するための関数やクラスを定義しています。

標準ライブラリモジュールとしてログ記録 API が提供される利点は、すべての Python モジュールがログ記録に参加できることであり、これによってあなたが書くアプリケーションのログにサードパーティーのモジュールが出力するメッセージを含ませることができます。

このモジュールは、多くの機能性と柔軟性を提供します。ロギングに慣れていないなら、つかむのに一番いいのはチュートリアルを読むことです (右のリンクを参照してください)。

モジュールで定義されている基本的なクラスと関数を、以下に列挙します。

ロガーは、アプリケーションコードが直接使うインタフェースを公開します。

ハンドラは、(ロガーによって生成された) ログ記録を適切な送信先に送ります。

フィルタは、どのログ記録を出力するかを決定する、きめ細かい機能を提供します。

フォーマッタは、ログ記録が最終的に出力されるレイアウトを指定します。

ロガーオブジェクト
ロガーには以下のような属性とメソッドがあります。 ロガーを直接インスタンス化することは 絶対に してはならず、常にモジュール関数 logging.getLogger(name) を介してインスタンス化することに注意してください。 同じ name で getLogger() を複数回呼び出すと、常に同じロガー・オブジェクトへの参照が返されます。

name は foo.bar.baz のようにピリオドで分割された (ただし単なるプレーンな foo もありえます) 潜在的に階層的な値です。階層リスト中でより下位のロガーは、上位のロガーの子です。例えば、foo という名前を持つロガーがあるとき、foo.bar, foo.bar.baz, foo.bam という名前を持つロガーはすべて foo の子孫です。ロガー名の階層は Python パッケージ階層と類似していて、推奨される構築方法 logging.getLogger(__name__) を使用してロガーをモジュール単位で構成すれば、Python パッケージ階層と同一になります。これは、モジュールの中では __name__ が Python パッケージ名前空間におけるモジュール名だからです。

class logging.Logger
propagate
この属性が真と評価された場合、このロガーに記録されたイベントは、このロガーに取り付けられた全てのハンドラに加え、上位 (祖先) ロガーのハンドラにも渡されます。 メッセージは、祖先ロガーのハンドラに直接渡されます - 今問題にしている祖先ロガーのレベルもフィルタも、どちらも考慮されません。

この値の評価結果が偽になる場合、ロギングメッセージは祖先ロガーのハンドラに渡されません。

コンストラクタはこの属性を True に設定します。

注釈 ハンドラを、あるロガー と その祖先のロガーに接続した場合、同一レコードが複数回発行される場合があります。一般的に、ハンドラを複数のロガーに接続する必要はありません。propagate 設定が True のままになっていれば、ロガーの階層において最上位にある適切なロガーにハンドラを接続するだけで、そのハンドラは全ての子孫ロガーが記録する全てのイベントを確認することができます。一般的なシナリオでは、ハンドラをルートロガーに対してのみ接続し、残りは propagate にすべて委ねます。
setLevel(level)
このロガーの閾値を level に設定します。 level よりも深刻でないログメッセージは無視されます; 深刻さが level 以上のログメッセージは、ハンドラのレベルが level より上に設定されていない限り、このロガーに取り付けられているハンドラによって投げられます。

ロガーが生成された際、レベルは NOTSET (これによりすべてのメッセージについて、ロガーがルートロガーであれば処理される、そうでなくてロガーが非ルートロガーの場合には親ロガーに委譲させる) に設定されます。 ルートロガーは WARNING レベルで生成されることに注意してください。

「親ロガーに委譲」という用語の意味は、もしロガーのレベルが NOTSET ならば、祖先ロガーの系列の中を NOTSET 以外のレベルの祖先を見つけるかルートに到達するまで辿っていく、ということです。

もし NOTSET 以外のレベルの祖先が見つかったなら、その祖先のレベルが探索を開始したロガーの実効レベルとして扱われ、ログイベントがどのように処理されるかを決めるのに使われます。

ルートに到達した場合、ルートのレベルが NOTSET ならばすべてのメッセージは処理されます。そうでなければルートのレベルが実効レベルとして使われます。

レベルの一覧については ロギングレベル を参照してください。

バージョン 3.2 で変更: level パラメータは、 INFO のような整数定数の代わりに 'INFO' のようなレベルの文字列表現も受け付けるようになりました。ただし、レベルは内部で整数として保存されますし、 getEffectiveLevel() や isEnabledFor() といったメソッドは、整数を返し、また渡されるものと期待します。

isEnabledFor(level)
Indicates if a message of severity level would be processed by this logger. This method checks first the module-level level set by logging.disable(level) and then the logger's effective level as determined by getEffectiveLevel().

getEffectiveLevel()
このロガーの実効レベルを示します。 NOTSET 以外の値が setLevel() で設定されていた場合、その値が返されます。そうでない場合、 NOTSET 以外の値が見つかるまでロガーの階層をルートロガーの方向に追跡します。見つかった場合、その値が返されます。返される値は整数で、典型的には logging.DEBUG, logging.INFO 等のうち一つです。

getChild(suffix)
このロガーの子であるロガーを、接頭辞によって決定し、返します。従って、logging.getLogger('abc').getChild('def.ghi') は、logging.getLogger('abc.def.ghi') によって返されるのと同じロガーを返すことになります。これは簡便なメソッドで、親ロガーがリテラルでなく __name__ などを使って名付けられているときに便利です。

バージョン 3.2 で追加.

debug(msg, *args, **kwargs)
Logs a message with level DEBUG on this logger. The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.) No % formatting operation is performed on msg when no args are supplied.

There are four keyword arguments in kwargs which are inspected: exc_info, stack_info, stacklevel and extra.

exc_info は、この値の評価値が false でない場合、例外情報がロギングメッセージに追加されます。もし例外情報をあらわすタプル(sys.exc_info() 関数によって戻されるフォーマットにおいて)、または、例外情報をあらわすインスタンスが与えられていれば、それが使用されることになります。それ以外の場合には、 sys.exc_info() を呼び出して例外情報を取得します。

2つ目の省略可能なキーワード引数は stack_info で、デフォルトは False です。真の場合、実際のロギング呼び出しを含むスタック情報がロギングメッセージに追加されます。これは exc_info 指定によって表示されるスタック情報と同じものではないことに注意してください: 前者はカレントスレッド内での、一番下からロギング呼び出しまでのスタックフレームですが、後者は例外に呼応して、例外ハンドラが見つかるところまで巻き戻されたスタックフレームの情報です。

exc_info とは独立に stack_info を指定することもできます (例えば、例外が上げられなかった場合でも、コード中のある地点にどのように到着したかを単に示すために)。スタックフレームは、次のようなヘッダー行に続いて表示されます:

Stack (most recent call last):
これは、例外フレームを表示する場合に使用される Traceback (most recent call last): を模倣します。

The third optional keyword argument is stacklevel, which defaults to 1. If greater than 1, the corresponding number of stack frames are skipped when computing the line number and function name set in the LogRecord created for the logging event. This can be used in logging helpers so that the function name, filename and line number recorded are not the information for the helper function/method, but rather its caller. The name of this parameter mirrors the equivalent one in the warnings module.

The fourth keyword argument is extra which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:

FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logger = logging.getLogger('tcpserver')
logger.warning('Protocol problem: %s', 'connection reset', extra=d)
これは以下のような出力を行います

2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
extra で渡される辞書のキーはロギングシステムで使われているものと衝突しないようにしなければなりません。 (どのキーがロギングシステムで使われているかについての詳細は Formatter のドキュメントを参照してください。)

If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the Formatter has been set up with a format string which expects 'clientip' and 'user' in the attribute dictionary of the LogRecord. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the extra dictionary with these keys.

このようなことは煩わしいかもしれませんが、この機能は限定された場面で使われるように意図しているものなのです。たとえば同じコードがいくつものコンテキストで実行されるマルチスレッドのサーバで、興味のある条件が現れるのがそのコンテキストに依存している (上の例で言えば、リモートのクライアント IP アドレスや認証されたユーザ名など)、というような場合です。そういった場面では、それ用の Formatter が特定の Handler と共に使われるというのはよくあることです。

バージョン 3.2 で変更: stack_info パラメータが追加されました。

バージョン 3.5 で変更: exc_info パラメータは例外インスタンスを受け入れることが可能です。

バージョン 3.8 で変更: The stacklevel parameter was added.

info(msg, *args, **kwargs)
レベル INFO のメッセージをこのロガーで記録します。引数は debug() と同じように解釈されます。

warning(msg, *args, **kwargs)
レベル WARNING のメッセージをこのロガーで記録します。引数は debug() と同じように解釈されます。

注釈 warning と機能的に等価な古いメソッド warn があります。warn は廃止予定なので使わないでください - 代わりに warning を使ってください。
error(msg, *args, **kwargs)
レベル ERROR のメッセージをこのロガーで記録します。引数は debug() と同じように解釈されます。

critical(msg, *args, **kwargs)
レベル CRITICAL のメッセージをこのロガーで記録します。引数は debug() と同じように解釈されます。

log(level, msg, *args, **kwargs)
Logs a message with integer level level on this logger. The other arguments are interpreted as for debug().

exception(msg, *args, **kwargs)
レベル ERROR のメッセージをこのロガーで記録します。引数は debug() と同じように解釈されます。例外情報がログメッセージに追加されます。このメソッドは例外ハンドラからのみ呼び出されるべきです。

addFilter(filter)
指定されたフィルタ filter をこのロガーに追加します。

removeFilter(filter)
指定されたフィルタ filter をこのロガーから取り除きます。

filter(record)
Apply this logger's filters to the record and return True if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be processed (passed to handlers). If one returns a false value, no further processing of the record occurs.

addHandler(hdlr)
指定されたハンドラ hdlr をこのロガーに追加します。

removeHandler(hdlr)
指定されたハンドラ hdlr をこのロガーから取り除きます。

findCaller(stack_info=False, stacklevel=1)
呼び出し元のソースファイル名と行番号を調べます。ファイル名と行番号、関数名、スタック情報を 4 要素のタプルで返します。stack_info が True でなければ、スタック情報は None が返されます。

The stacklevel parameter is passed from code calling the debug() and other APIs. If greater than 1, the excess is used to skip stack frames before determining the values to be returned. This will generally be useful when calling logging APIs from helper/wrapper code, so that the information in the event log refers not to the helper/wrapper code, but to the code that calls it.

handle(record)
レコードを、このロガーおよびその上位ロガー (ただし propagate の値が false になったところまで) に関連付けられているすべてのハンドラに渡して処理します。このメソッドは、ローカルで生成されたレコードだけでなく、ソケットから受信した unpickle されたレコードに対しても同様に用いられます。 filter() によって、ロガーレベルでのフィルタが適用されます。

makeRecord(name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)
このメソッドは、特殊な LogRecord インスタンスを生成するためにサブクラスでオーバライドできるファクトリメソッドです。

hasHandlers()
このロガーにハンドラが設定されているかどうかを調べます。 そのために、このロガーとロガー階層におけるその祖先についてハンドラ探していきます。 ハンドラが見つかれば True 、そうでなければ False を返します。 このメソッドは、'propagate' 属性が偽に設定されたロガーを見つけると、さらに上位の探索をやめます - そのロガーが、ハンドラが存在するかどうかチェックされる最後のロガー、という意味です。

バージョン 3.2 で追加.

バージョン 3.7 で変更: ロガーの pickle 化と unpickle 化ができるようになりました。

ロギングレベル
ログレベルの数値は以下の表のように与えられています。これらは基本的に自分でレベルを定義したい人のためのもので、定義するレベルを既存のレベルの間に位置づけるためには具体的な値が必要になります。もし数値が他のレベルと同じだったら、既存の値は上書きされその名前は失われます。

レベル

数値

CRITICAL

50

ERROR

40

WARNING

30

INFO

20

DEBUG

10

NOTSET

0

ハンドラオブジェクト
ハンドラ (Handler) は以下の属性とメソッドを持ちます。 Handler は直接インスタンス化されることはありません; このクラスはより便利なサブクラスの基底クラスとして働きます。しかしながら、サブクラスにおける __init__() メソッドでは、 Handler.__init__() を呼び出す必要があります。

class logging.Handler
__init__(level=NOTSET)
レベルを設定して、 Handler インスタンスを初期化します。空のリストを使ってフィルタを設定し、 I/O 機構へのアクセスを直列化するために (createLock() を使って) ロックを生成します。

createLock()
スレッドセーフでない背後の I/O 機能に対するアクセスを直列化するために用いられるスレッドロック (thread lock) を初期化します。

acquire()
createLock() で生成されたスレッドロックを獲得します。

release()
acquire() で獲得したスレッドロックを解放します。

setLevel(level)
このハンドラに対する閾値を level に設定します。 level よりも深刻でないログメッセージは無視されます。 ハンドラが生成された際、レベルは NOTSET (すべてのメッセージが処理される) に設定されます。

レベルの一覧については ロギングレベル を参照してください。

バージョン 3.2 で変更: level パラメータは、 INFO のような整数定数の代わりに 'INFO' のようなレベルの文字列表現も受け付けるようになりました。

setFormatter(fmt)
このハンドラのフォーマッタを fmt に設定します。

addFilter(filter)
指定されたフィルタ filter をこのハンドラに追加します。

removeFilter(filter)
指定されたフィルタ filter をこのハンドラから除去します。

filter(record)
Apply this handler's filters to the record and return True if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be emitted. If one returns a false value, the handler will not emit the record.

flush()
すべてのログ出力がフラッシュされるようにします。このクラスのバージョンではなにも行わず、サブクラスで実装するためのものです。

close()
ハンドラで使われているすべてのリソースの後始末を行います。このバージョンでは何も出力せず、 shutdown() が呼ばれたときに閉じられたハンドラを内部リストから削除します。サブクラスではオーバライドされた close() メソッドからこのメソッドが必ず呼ばれるようにしてください。

handle(record)
ハンドラに追加されたフィルタの条件に応じて、指定されたログレコードを出力します。このメソッドは I/O スレッドロックの獲得/解放を伴う実際のログ出力をラップします。

handleError(record)
このメソッドは emit() の呼び出し中に例外に遭遇した際にハンドラから呼び出されます。モジュールレベル属性 raiseExceptions が False の場合、例外は暗黙のまま無視されます。ほとんどの場合、これがロギングシステムの望ましい動作です - というのは、ほとんどのユーザはロギングシステム自体のエラーは気にせず、むしろアプリケーションのエラーに興味があるからです。しかしながら、望むならこのメソッドを自作のハンドラと置き換えることもできます。 record には、例外発生時に処理されていたレコードが入ります。 (raiseExceptions のデフォルト値は True です。これは開発中はその方が便利だからです)。

format(record)
レコードに対する書式化を行います - フォーマッタが設定されていれば、それを使います。そうでない場合、モジュールにデフォルト指定されたフォーマッタを使います。

emit(record)
指定されたログ記録レコードを実際にログ記録する際のすべての処理を行います。このメソッドはサブクラスで実装されることを意図しており、そのためこのクラスのバージョンは NotImplementedError を送出します。

標準として含まれているハンドラについては、 logging.handlers を参照してください。

フォーマッタオブジェクト
Formatter オブジェクトは以下の属性とメソッドを持っています。 Formatter は LogRecord を (通常は) 人間か外部のシステムで解釈できる文字列に変換する役割を担っています。基底クラスの Formatter では書式文字列を指定することができます。何も指定されなかった場合、ロギングコール中のメッセージ以外の情報だけを持つ '%(message)s' の値が使われます。フォーマットされた出力に情報の要素 (タイムスタンプなど) を追加したいなら、このまま読み進めてください。

Formatter は LogRecord 属性の知識を利用できるような書式文字列を用いて初期化することができます。例えば、上で言及したデフォルト値では、ユーザによるメッセージと引数はあらかじめフォーマットされて、 LogRecord の message 属性に入っていることを利用しています。この書式文字列は、 Python 標準の % を使った変換文字列で構成されます。文字列整形に関する詳細は printf 形式の文字列書式化 を参照してください。

LogRecord の便利なマッピングキーは、 LogRecord 属性 の節で与えられます。

class logging.Formatter(fmt=None, datefmt=None, style='%', validate=True)
Formatter クラスの新たなインスタンスを返します。インスタンスは全体としてのメッセージに対する書式文字列と、メッセージの日付/時刻部分のための書式文字列を伴って初期化されます。 fmt が指定されない場合、 '%(message)s' が使われます。 datefmt が指定されない場合、 formatTime() ドキュメントで解説されている書式が使われます。

The style parameter can be one of '%', '{' or '$' and determines how the format string will be merged with its data: using one of %-formatting, str.format() or string.Template. This only applies to the format string fmt (e.g. '%(message)s' or {message}), not to the actual log messages passed to Logger.debug etc; see 固有の書式化スタイルをアプリケーション全体で使う for more information on using {- and $-formatting for log messages.

バージョン 3.2 で変更: style パラメータが追加されました。

バージョン 3.8 で変更: The validate parameter was added. Incorrect or mismatched style and fmt will raise a ValueError. For example: logging.Formatter('%(asctime)s - %(message)s', style='{').

format(record)
レコードの属性辞書が、文字列を書式化する演算で被演算子として使われます。書式化された結果の文字列を返します。辞書を書式化する前に、二つの準備段階を経ます。レコードの message 属性が msg % args を使って処理されます。書式化された文字列が '(asctime)' を含むなら、 formatTime() が呼び出され、イベントの発生時刻を書式化します。例外情報が存在する場合、 formatException() を使って書式化され、メッセージに追加されます。ここで注意していただきたいのは、書式化された例外情報は exc_text にキャッシュされるという点です。これが有用なのは例外情報がピックル化されて回線上を送ることができるからですが、しかし二つ以上の Formatter サブクラスで例外情報の書式化をカスタマイズしている場合には注意が必要になります。この場合、フォーマッタが書式化を終えるごとにキャッシュをクリアして、次のフォーマッタがキャッシュされた値を使わずに新鮮な状態で再計算するようにしなければならないことになります。

スタック情報が利用可能な場合、(必要ならば formatStack() を使って整形した上で) スタック情報が例外情報の後に追加されます。

formatTime(record, datefmt=None)
このメソッドは、フォーマッタが書式化された時間を利用したい際に、 format() から呼び出されます。 このメソッドは特定の要求を提供するためにフォーマッタで上書きすることができますが、基本的な振る舞いは以下のようになります: datefmt (文字列) が指定された場合、レコードが生成された時刻を書式化するために time.strftime() で使われます。 そうでない場合、 '%Y-%m-%d %H:%M:%S,uuu' というフォーマットが使われます。 uuu 部分はミリ秒値で、それ以外の文字は time.strftime() ドキュメントに従います。 このフォーマットの時刻の例は 2003-01-23 00:29:50,411 です。 結果の文字列が返されます。

この関数は、ユーザが設定できる関数を使って、生成時刻をタプルに変換します。デフォルトでは、 time.localtime() が使われます。特定のフォーマッタインスタンスに対してこれを変更するには、 converter 属性を time.localtime() や time.gmtime() と同じ署名をもつ関数に設定してください。すべてのフォーマッタインスタンスに対してこれを変更するには、例えば全てのロギング時刻を GMT で表示するには、 Formatter クラスの converter 属性を設定してください。

バージョン 3.3 で変更: 以前は、デフォルトのフォーマットがこの例のようにハードコーディングされていました: 2010-09-06 22:38:15,292 ここで、コンマの前の部分は strptime フォーマット文字列 ('%Y-%m-%d %H:%M:%S') によって扱われる部分で、コンマの後の部分はミリ秒値です。strptime にミリ秒のフォーマットプレースホルダーがないので、ミリ秒値は別のフォーマット文字列 '%s,%03d' を使用して追加されます。そして、これらのフォーマット文字列は両方ともこのメソッドでハードコーディングされていました。変更後は、これらの文字列はクラスレベル属性として定義され、必要ならインスタンスレベルでオーバーライドすることができます。属性の名前は default_time_format (strptime 書式文字列用) と default_msec_format (ミリ秒値の追加用) です。

バージョン 3.9 で変更: The default_msec_format can be None.

formatException(exc_info)
指定された例外情報 (sys.exc_info() が返すような標準例外のタプル) を文字列として書式化します。デフォルトの実装は単に traceback.print_exception() を使います。結果の文字列が返されます。

formatStack(stack_info)
指定されたスタック情報を文字列としてフォーマットします (traceback.print_stack() によって返される文字列ですが、最後の改行が取り除かれています)。このデフォルト実装は、単に入力値をそのまま返します。

フィルタオブジェクト
フィルタ (Filter) は、ハンドラ や ロガー によって使われ、レベルによって提供されるのよりも洗練されたフィルタリングを実現します。基底のフィルタクラスは、ロガー階層構造内の特定地点の配下にあるイベントだけを許可します。例えば、'A.B' で初期化されたフィルタは、ロガー 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' 等によって記録されたイベントは許可しますが、'A.BB', 'B.A.B' などは許可しません。空の文字列で初期化された場合、すべてのイベントを通過させます。

class logging.Filter(name='')
Filter クラスのインスタンスを返します。 name が指定されていれば、 name はロガーの名前を表します。指定されたロガーとその子ロガーのイベントがフィルタを通過できるようになります。 name が指定されなければ、すべてのイベントを通過させます。

filter(record)
指定されたレコードがログされるべきか？no ならばばゼロを、yes ならばゼロでない値を返します。適切と判断されれば、このメソッドによってレコードはその場で修正されることがあります。

ハンドラに対するフィルタはハンドラがイベントを発行する前に試され、一方ではロガーに対するフィルタは、イベントが(debug(), info() などによって)ロギングされる際には、ハンドラにイベントが送信される前にはいつでも試されることに注意してください。そのフィルタがそれら子孫ロガーにも適用されていない限り、子孫ロガーによって生成されたイベントはロガーのフィルタ設定によってフィルタされることはありません。

実際には、Filter をサブクラス化する必要はありません。同じ意味の filter メソッドを持つ、すべてのインスタンスを通せます。

バージョン 3.2 で変更: 特殊な Filter クラスを作ったり、 filter メソッドを持つ他のクラスを使う必要はありません: 関数 (あるいは他の callable) をフィルタとして使用することができます。フィルタロジックは、フィルタオブジェクトが filter 属性を持っているかどうかチェックします: もし filter 属性を持っていたら、それは Filter であると仮定され、その filter() メソッドが呼び出されます。そうでなければ、それは callable であると仮定され、レコードを単一のパラメータとして呼び出されます。返される値は filter() によって返されるものと一致すべきです。

Although filters are used primarily to filter records based on more sophisticated criteria than levels, they get to see every record which is processed by the handler or logger they're attached to: this can be useful if you want to do things like counting how many records were processed by a particular logger or handler, or adding, changing or removing attributes in the LogRecord being processed. Obviously changing the LogRecord needs to be done with some care, but it does allow the injection of contextual information into logs (see Filter を使ったコンテキスト情報の伝達).

LogRecord オブジェクト
LogRecord インスタンスは、何かをログ記録するたびに Logger によって生成されます。また、 makeLogRecord() を通して (例えば、ワイヤを通して受け取られた pickle 化されたイベントから) 手動で生成することも出来ます。

class logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None)
ロギングされているイベントに適切なすべての情報を含みます。

基本的な情報は msg と args に渡され、レコードの message フィールドは msg % args による結合で生成されます。

パラメータ
name -- この LogRecord で表されるイベントをロギングするのに使われるロガーの名前です。ここで与える名前が、たとえ他の(祖先の)ロガーに結び付けられたハンドラによって発せられるとしても、与えたこの値のままであることに注意してください。

level -- このロギングイベントの数値のレベル (DEBUG, INFO などのいずれか) です。なお、これは LogRecord の 2つの 属性に変換されます。数値 levelno と、対応するレベル名 levelname です。

pathname -- ロギングの呼び出しが発せられたファイルの完全なパス名。

lineno -- ロギングの呼び出しが発せられたソース行番号。

msg -- イベント記述メッセージで、これは変数データのプレースホルダを持つフォーマット文字列になり得ます。

args -- msg 引数と組み合わせてイベント記述を得るための変数データです。

exc_info -- 現在の例外情報を含む例外タプルか、利用できる例外情報がない場合は None です。

func -- ロギングの呼び出しを行った関数またはメソッドの名前です。

sinfo -- 現在のスレッドのスタックベースからログ呼び出しまでの間のスタック情報を表わすテキスト文字列。

getMessage()
ユーザが提供した引数をメッセージに交ぜた後、この LogRecord インスタンスへのメッセージを返します。ユーザがロギングの呼び出しに与えた引数が文字列でなければ、その引数に str() が呼ばれ、文字列に変換されます。これにより、 __str__ メソッドが実際のフォーマット文字列を返せるようなユーザ定義のクラスをメッセージとして使えます。

バージョン 3.2 で変更: The creation of a LogRecord has been made more configurable by providing a factory which is used to create the record. The factory can be set using getLogRecordFactory() and setLogRecordFactory() (see this for the factory's signature).

This functionality can be used to inject your own values into a LogRecord at creation time. You can use the following pattern:

old_factory = logging.getLogRecordFactory()

def record_factory(*args, **kwargs):
    record = old_factory(*args, **kwargs)
    record.custom_attribute = 0xdecafbad
    return record

logging.setLogRecordFactory(record_factory)
このパターンでは複数のファクトリをつなぐこともできます。それらが互いの属性を上書きしたりせず、また上にリストされた標準属性を意図せず上書きしたりしない限り、驚くようなことは何も起こりません (there should be no surprises)。

LogRecord 属性
LogRecord には幾つかの属性があり、そのほとんどはコンストラクタの引数から得られます。(なお、LogRecord コンストラクタの引数と LogRecord 属性が常に厳密に対応するわけではありません。) これらの属性は、レコードからのデータをフォーマット文字列に統合するのに使えます。以下のテーブルに、属性名、意味、そして % 形式フォーマット文字列における対応するプレースホルダを (アルファベット順に) 列挙します。

{}-フォーマット (str.format()) を使用していれば、書式文字列の中でプレースホールダーとして {attrname} を使うことができます。 $-フォーマット (string.Template) を使用している場合は、 ${attrname} 形式にしてください。もちろん、両方の場合で attrname は使用したい実際の属性名に置き換えてください。

{}-フォーマットの場合には、属性名の後にフォーマットフラグを指定することができます。属性名とフォーマットフラグの間はコロンで分割します。例: プレースホールダー {msecs:03d} は、ミリセカンド値 4 を 004 としてフォーマットします。利用可能なオプション上の全詳細に関しては str.format() ドキュメンテーションを参照してください。

属性名

フォーマット

説明

args

このフォーマットを自分で使う必要はないでしょう。

msg に組み合わせて message を生成するための引数のタプル、または、マージに用いられる辞書(引数が一つしかなく、かつそれが辞書の場合)。

asctime

%(asctime)s

LogRecord が生成された時刻を人間が読める書式で表したもの。デフォルトでは "2003-07-08 16:49:45,896" 形式 (コンマ以降の数字は時刻のミリ秒部分) です。

created

%(created)f

LogRecord が生成された時刻 (time.time() によって返される形式で)。

exc_info

このフォーマットを自分で使う必要はないでしょう。

(sys.exc_info 風の) 例外タプルか、例外が起こっていない場合は None。

ファイル名

%(filename)s

pathname のファイル名部分。

funcName

%(funcName)s

ロギングの呼び出しを含む関数の名前。

levelname

%(levelname)s

メッセージのための文字のロギングレベル ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')。

levelno

%(levelno)s

メッセージのための数値のロギングレベル (DEBUG, INFO, WARNING, ERROR, CRITICAL)。

lineno

%(lineno)d

ロギングの呼び出しが発せられたソース行番号 (利用できる場合のみ)。

message

%(message)s

msg % args として求められた、ログメッセージ。 Formatter.format() が呼び出されたときに設定されます。

module

%(module)s

モジュール (filename の名前部分)。

msecs

%(msecs)d

LogRecord が生成された時刻のミリ秒部分。

msg

このフォーマットを自分で使う必要はないでしょう。

元のロギングの呼び出しで渡されたフォーマット文字列。 args と合わせて、 message 、または任意のオブジェクトを生成します (任意のオブジェクトをメッセージに使用する 参照)。

name

%(name)s

ロギングに使われたロガーの名前。

pathname

%(pathname)s

ロギングの呼び出しが発せられたファイルの完全なパス名 (利用できる場合のみ)。

process

%(process)d

プロセス ID (利用可能な場合のみ)。

processName

%(processName)s

プロセス名 (利用可能な場合のみ)。

relativeCreated

%(relativeCreated)d

logging モジュールが読み込まれた時刻に対する、LogRecord が生成された時刻を、ミリ秒で表したもの。

stack_info

このフォーマットを自分で使う必要はないでしょう。

現在のスレッドでのスタックの底からこのレコードの生成に帰着したログ呼び出しまでのスタックフレーム情報 (利用可能な場合)。

thread

%(thread)d

スレッド ID (利用可能な場合のみ)。

threadName

%(threadName)s

スレッド名 (利用可能な場合のみ)。

バージョン 3.1 で変更: processName が追加されました。

LoggerAdapter オブジェクト
LoggerAdapter インスタンスは文脈情報をログ記録呼び出しに渡すのを簡単にするために使われます。使い方の例は コンテキスト情報をログ記録出力に付加する を参照してください。

class logging.LoggerAdapter(logger, extra)
内部で使う Logger インスタンスと辞書風 (dict-like) オブジェクトで初期化した LoggerAdapter のインスタンスを返します。

process(msg, kwargs)
文脈情報を挿入するために、ログ記録呼び出しに渡されたメッセージおよび/またはキーワード引数に変更を加えます。ここでの実装は extra としてコンストラクタに渡されたオブジェクトを取り、'extra' キーを使って kwargs に加えます。返り値は (msg, kwargs) というタプルで、(変更されているはずの) 渡された引数を含みます。

LoggerAdapter は上記に加え Logger のメソッド debug(), info(), warning(), error(), exception(), critical(), log(), isEnabledFor(), getEffectiveLevel(), setLevel(), hasHandlers() をサポートします。これらは Logger の対応するメソッドと同じシグニチャを持つため、2つのインスタンスは区別せずに利用出来ます。

バージョン 3.2 で変更: isEnabledFor(), getEffectiveLevel(), setLevel(), hasHandlers() が LoggerAdapter に追加されました。これらメソッドは元のロガーに処理を委譲します。

スレッドセーフ性
logging モジュールは、クライアントで特殊な作業を必要としない限りスレッドセーフになっています。このスレッドセーフ性はスレッドロックによって達成されています; モジュールの共有データへのアクセスを直列化するためのロックが一つ存在し、各ハンドラでも背後にある I/O へのアクセスを直列化するためにロックを生成します。

signal モジュールを使用して非同期シグナルハンドラを実装している場合、そのようなハンドラからはログ記録を使用できないかもしれません。これは、 threading モジュールにおけるロック実装が常にリエントラントではなく、そのようなシグナルハンドラから呼び出すことができないからです。

モジュールレベルの関数
上で述べたクラスに加えて、いくつかのモジュールレベルの関数が存在します。

logging.getLogger(name=None)
指定された名前のロガーを返します。名前が None であれば、ロガー階層のルート (root) にあるロガーを返します。name を指定する場合には、通常は 'a', 'a.b', 'a.b.c.d' といったドット区切りの階層的な名前にします。名前の付け方はログ機能を使う開発者次第です。

与えられた名前に対して、この関数はどの呼び出しでも同じロガーインスタンスを返します。したがって、ロガーインスタンスをアプリケーションの各部でやりとりする必要はありません。

logging.getLoggerClass()
標準の Logger クラスか、最後に setLoggerClass() に渡したクラスを返します。この関数は、新たなクラス定義の中で呼び出して、カスタマイズした Logger クラスのインストールが既に他のコードで適用したカスタマイズを取り消さないことを保証するために使われることがあります。例えば以下のようにします:

class MyLogger(logging.getLoggerClass()):
    # ... override behaviour here
logging.getLogRecordFactory()
LogRecord を生成するのに使われる callable を返します。

バージョン 3.2 で追加: この関数は、ログイベントを表現する LogRecord の構築方法に関して開発者により多くのコントロールを与えるため、 setLogRecordFactory() とともに提供されました。

このファクトリがどのように呼ばれるかに関する詳細は setLogRecordFactory() を参照してください。

logging.debug(msg, *args, **kwargs)
レベル DEBUG のメッセージをルートロガーで記録します。 msg はメッセージの書式文字列で、 args は msg に文字列書式化演算子を使って取り込むための引数です。 (これは、書式文字列の中でキーワードを使い、引数として単一の辞書を渡すことができる、ということを意味します。)

キーワード引数 kwargs からは 3 つのキーワードが調べられます。一つ目は exc_info で、この値の評価値が false でない場合、例外情報をログメッセージに追加します。 (sys.exc_info() の返す形式の) 例外情報を表すタプルや例外インスタンスが与えられていれば、それをメッセージに使います。それ以外の場合には、 sys.exc_info() を呼び出して例外情報を取得します。

2つ目の省略可能なキーワード引数は stack_info で、デフォルトは False です。真の場合、実際のロギング呼び出しを含むスタック情報がロギングメッセージに追加されます。これは exc_info 指定によって表示されるスタック情報と同じものではないことに注意してください: 前者はカレントスレッド内での、一番下からロギング呼び出しまでのスタックフレームですが、後者は例外に呼応して、例外ハンドラが見つかるところまで巻き戻されたスタックフレームの情報です。

exc_info とは独立に stack_info を指定することもできます (例えば、例外が上げられなかった場合でも、コード中のある地点にどのように到着したかを単に示すために)。スタックフレームは、次のようなヘッダー行に続いて表示されます:

Stack (most recent call last):
これは、例外フレームを表示する場合に使用される Traceback (most recent call last): を模倣します。

3番目のキーワード引数は extra で、当該ログイベント用に作られる LogRecoed の __dict__ にユーザー定義属性を加えるのに使われる辞書を渡すために用いられます。これらの属性は好きなように使えます。たとえば、ログメッセージの一部にすることもできます。以下の例を見てください:

FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logging.warning('Protocol problem: %s', 'connection reset', extra=d)
これは以下のような出力を行います:

2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
extra で渡される辞書のキーはロギングシステムで使われているものと衝突しないようにしなければなりません。 (どのキーがロギングシステムで使われているかについての詳細は Formatter のドキュメントを参照してください。)

これらの属性をログメッセージに使うことにしたなら、少し注意が必要です。上の例では、 'clientip' と 'user' が LogRecord の属性辞書に含まれていることを期待した書式文字列で Formatter がセットアップされています。もしこれらが欠けていると、書式化例外が発生してしまうためメッセージはログに残りません。したがってこの場合、常にこれらのキーを含む extra 辞書を渡す必要があります。

このようなことは煩わしいかもしれませんが、この機能は限定された場面で使われるように意図しているものなのです。たとえば同じコードがいくつものコンテキストで実行されるマルチスレッドのサーバで、興味のある条件が現れるのがそのコンテキストに依存している (上の例で言えば、リモートのクライアント IP アドレスや認証されたユーザ名など)、というような場合です。そういった場面では、それ用の Formatter が特定の Handler と共に使われるというのはよくあることです。

バージョン 3.2 で変更: stack_info パラメータが追加されました。

logging.info(msg, *args, **kwargs)
レベル INFO のメッセージをルートロガーで記録します。引数は debug() と同じように解釈されます。

logging.warning(msg, *args, **kwargs)
レベル WARNING のメッセージをルートロガーで記録します。引数は debug() と同じように解釈されます。

注釈 warning と機能的に等価な古い関数 warn があります。warn は廃止予定なので使わないでください - 代わりに warning を使ってください。
logging.error(msg, *args, **kwargs)
レベル ERROR のメッセージをルートロガーで記録します。引数は debug() と同じように解釈されます。

logging.critical(msg, *args, **kwargs)
レベル CRITICAL のメッセージをルートロガーで記録します。引数は debug() と同じように解釈されます。

logging.exception(msg, *args, **kwargs)
レベル ERROR のメッセージをルートロガーで記録します。引数は debug() と同じように解釈されます。例外情報がログメッセージに追加されます。このメソッドは例外ハンドラからのみ呼び出されます。

logging.log(level, msg, *args, **kwargs)
レベル level のメッセージをルートロガーで記録します。その他の引数は debug() と同じように解釈されます。

注釈 上述の便利なルートロガーに処理を委譲するモジュールレベル関数は basicConfig() を呼び出して、少なくとも 1 つのハンドラが利用できることを保証します。これにより Python の 2.7.1 以前や 3.2 以前のバージョンでは、スレッドが開始される 前に 少なくともひとつのハンドラがルートロガーに加えられるのでない限り、スレッド内で使うべき ではありません 。以前のバージョンの Python では、 basicConfig() のスレッドセーフ性の欠陥により、(珍しい状況下とはいえ)ハンドラがルートロガーに複数回加えられることがあり、ログ内のメッセージが重複するという予期しない結果をもたらすことがあります。
logging.disable(level=CRITICAL)
Provides an overriding level level for all loggers which takes precedence over the logger's own level. When the need arises to temporarily throttle logging output down across the whole application, this function can be useful. Its effect is to disable all logging calls of severity level and below, so that if you call it with a value of INFO, then all INFO and DEBUG events would be discarded, whereas those of severity WARNING and above would be processed according to the logger's effective level. If logging.disable(logging.NOTSET) is called, it effectively removes this overriding level, so that logging output again depends on the effective levels of individual loggers.

Note that if you have defined any custom logging level higher than CRITICAL (this is not recommended), you won't be able to rely on the default value for the level parameter, but will have to explicitly supply a suitable value.

バージョン 3.7 で変更: The level parameter was defaulted to level CRITICAL. See bpo-28524 for more information about this change.

logging.addLevelName(level, levelName)
Associates level level with text levelName in an internal dictionary, which is used to map numeric levels to a textual representation, for example when a Formatter formats a message. This function can also be used to define your own levels. The only constraints are that all levels used must be registered using this function, levels should be positive integers and they should increase in increasing order of severity.

注釈 独自のレベルを定義したい場合、 カスタムレベル のセクションを参照してください。
logging.getLevelName(level)
Returns the textual or numeric representation of logging level level.

If level is one of the predefined levels CRITICAL, ERROR, WARNING, INFO or DEBUG then you get the corresponding string. If you have associated levels with names using addLevelName() then the name you have associated with level is returned. If a numeric value corresponding to one of the defined levels is passed in, the corresponding string representation is returned.

The level parameter also accepts a string representation of the level such as 'INFO'. In such cases, this functions returns the corresponding numeric value of the level.

If no matching numeric or string value is passed in, the string 'Level %s' % level is returned.

注釈 Levels are internally integers (as they need to be compared in the logging logic). This function is used to convert between an integer level and the level name displayed in the formatted log output by means of the %(levelname)s format specifier (see LogRecord 属性), and vice versa.
バージョン 3.4 で変更: Python 3.4以前のバージョンでは、この関数にはテキストのレベルも渡すことが出来、これは対応する数字レベルに読み替えられていました。このドキュメントされていなかった振る舞いは誤りであると判断され、Python 3.4 で一度削除されました。ただし後方互換性のために、これは 3.4.2 で元に戻されました。

logging.makeLogRecord(attrdict)
属性が attrdict で定義された、新しい LogRecord インスタンスを生成して返します。この関数は、 pickle された LogRecord 属性の辞書をソケットを介して送信し、受信端で LogRecord インスタンスとして再構成する場合に便利です。

logging.basicConfig(**kwargs)
デフォルトの Formatter を持つ StreamHandler を生成してルートロガーに追加し、ロギングシステムの基本的な環境設定を行います。関数 debug(), info(), warning(), error(), critical() は、ルートロガーにハンドラが定義されていない場合に自動的に basicConfig() を呼び出します。

This function does nothing if the root logger already has handlers configured, unless the keyword argument force is set to True.

注釈 この関数は、他のスレッドが開始される前にメインスレッドから呼び出されるべきです。Python の 2.7.1 や 3.2 以前のバージョンでは、この関数が複数のスレッドから呼ばれると(珍しい状況下とはいえ)ハンドラがルートロガーに複数回加えられることがあり、ログ内のメッセージが重複するという予期しない結果をもたらすことがあります。
以下のキーワード引数がサポートされます。

フォーマット

説明

filename

StreamHandler ではなく指定された名前で FileHandler が作られます。

filemode

filename が指定された場合、この モード でファイルが開かれます。 デフォルトは 'a' です。

format

Use the specified format string for the handler. Defaults to attributes levelname, name and message separated by colons.

datefmt

指定された日時の書式で time.strftime() が受け付けるものを使います。

style

format が指定された場合、書式文字列にこのスタイルを仕様します。 '%', '{', '$' のうち1つで、それぞれ printf-style, str.format(), string.Template に対応します。 デフォルトは '%' です。

level

ルートロガーのレベルを指定された レベル に設定します。

stream

指定されたストリームを StreamHandler の初期化に使います。 この引数は filename と同時には使えないことに注意してください。 両方が指定されたときには ValueError が送出されます。

handlers

もし指定されれば、 これは root ロガーに追加される既に作られたハンドラのイテラブルになります。まだフォーマッタがセットされていないすべてのハンドラは、この関数で作られたデフォルトフォーマッタが割り当てられることになります。この引数は filename や stream と互換性がないことに注意してください。両方が存在する場合 ValueError が上げられます。

force

If this keyword argument is specified as true, any existing handlers attached to the root logger are removed and closed, before carrying out the configuration as specified by the other arguments.

encoding

If this keyword argument is specified along with filename, its value is used when the FileHandler is created, and thus used when opening the output file.

errors

If this keyword argument is specified along with filename, its value is used when the FileHandler is created, and thus used when opening the output file. If not specified, the value 'backslashreplace' is used. Note that if None is specified, it will be passed as such to func:open, which means that it will be treated the same as passing 'errors'.

バージョン 3.2 で変更: style 引数が追加されました。

バージョン 3.3 で変更: 互換性のない引数が指定された状況 (例えば handlers が stream や filename と一緒に指定されたり、stream が filename と一緒に指定された場合) を捕捉するために、追加のチェックが加えられました。

バージョン 3.8 で変更: The force argument was added.

バージョン 3.9 で変更: The encoding and errors arguments were added.

logging.shutdown()
ロギングシステムに対して、バッファのフラッシュを行い、すべてのハンドラを閉じることで順次シャットダウンを行うように告知します。この関数はアプリケーションの終了時に呼ばれるべきであり、また呼び出し以降はそれ以上ロギングシステムを使ってはなりません。

When the logging module is imported, it registers this function as an exit handler (see atexit), so normally there's no need to do that manually.

logging.setLoggerClass(klass)
ロギングシステムに対して、ロガーをインスタンス化する際にクラス klass を使うように指示します。 指定するクラスは引数として名前だけをとるようなメソッド __init__() を定義していなければならず、 __init__() では Logger.__init__() を呼び出さなければなりません。 この関数が呼び出されるのはたいてい、独自の振る舞いをするロガーを使う必要のあるアプリケーションでロガーがインスタンス化される前です。 呼び出された後は、いつでもそのサブクラスを使ってロガーのインスタンス化をしてはいけません: 引き続き logging.getLogger() API を使用してロガーを取得してください。

logging.setLogRecordFactory(factory)
LogRecord を生成するのに使われる callable をセットします。

パラメータ
factory -- ログレコードを生成するファクトリとして振舞う callable。

バージョン 3.2 で追加: この関数は、ログイベントを表現する LogRecord の構築方法に関して開発者により多くのコントロールを与えるため、 getLogRecordFactory() とともに提供されました。

ファクトリは以下のようなシグネチャを持っています:

factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, **kwargs)

name
ロガーの名前。

level
ログレベル (数値)。

fn
ログ呼び出しが行われたファイルのフルパス名。

lno
ログ呼び出しが行われたファイルの行数。

msg
ログメッセージ。

args
ログメッセージに対する引数。

exc_info
例外タプルまたは None。

func
ログ呼び出しを起動した関数またはメソッドの名前。

sinfo
traceback.print_stack() で提供されるような、呼び出し階層を示すスタックトレースバック。

kwargs
追加のキーワード引数。

モジュールレベル属性
logging.lastResort
「最後の手段のハンドラ」が、この属性で利用可能です。これは StreamHandler が sys.stderr に WARNING レベルで書き出しているのがそうですし、ロギングの設定がなにか不在のロギングイベントを扱う場合に使われます。最終的な結果は、メッセージを単に sys.stderr に出力することです。これはかつて「logger XYZ についてのハンドラが見つかりません」と言っていたエラーメッセージを置き換えています。もしも何らかの理由でその昔の振る舞いが必要な場合は、 lastResort に None をセットすれば良いです。

バージョン 3.2 で追加.

warnings モジュールとの統合
captureWarnings() 関数を使って、 logging を warnings モジュールと統合できます。

logging.captureWarnings(capture)
この関数は、logging による警告の補足を、有効にまたは無効にします。

capture が True なら、 warnings モジュールに発せられた警告は、ロギングシステムにリダイレクトされるようになります。具体的には、警告が warnings.formatwarning() でフォーマット化され、結果の文字列が 'py.warnings' という名のロガーに、 WARNING の重大度でロギングされるようになります。

capture が False なら、警告のロギングシステムに対するリダイレクトは止められ、警告は元の (すなわち、captureWarnings(True) が呼び出される前に有効だった) 送信先にリダイレクトされるようになります。

参考
logging.config モジュール
logging モジュールの環境設定 API です。

logging.handlers モジュール
logging モジュールに含まれる、便利なハンドラです。

PEP 282 - ログシステム
この機能を Python 標準ライブラリに含めることを述べた提案です。

Original Python logging package
これは、 logging パッケージのオリジナルのソースです。このサイトから利用できるバージョンのパッケージは、 logging パッケージを標準ライブラリに含まない、 Python 1.5.2, 2.1.x および 2.2.x で使うのに適しています。

logging.config --- ロギングの環境設定
ソースコード: Lib/logging/config.py

Important

このページには、リファレンス情報だけが含まれています。チュートリアルは、以下のページを参照してください

基本チュートリアル

上級チュートリアル

ロギングクックブック

この節は、logging モジュールを設定するための API を解説します。

環境設定のための関数
以下の関数は logging モジュールの環境設定をします。これらの関数は、 logging.config にあります。これらの関数の使用はオプションです --- logging モジュールはこれらの関数を使うか、 (logging 自体で定義されている) 主要な API を呼び出し、 logging か logging.handlers で宣言されているハンドラを定義することで設定できます。

logging.config.dictConfig(config)
辞書からロギング環境設定を取得します。この辞書の内容は、以下の 環境設定辞書スキーマ で記述されています。

環境設定中にエラーに遭遇すると、この関数は適宜メッセージを記述しつつ ValueError, TypeError, AttributeError または ImportError を送出します。例外を送出する条件を (不完全かもしれませんが) 以下に列挙します:

文字列でなかったり、実際のロギングレベルと関係ない文字列であったりする level。

ブール値でない propagate の値。

対応する行き先を持たない id。

インクリメンタルな呼び出しの中で見つかった存在しないハンドラ id。

無効なロガー名。

内部や外部のオブジェクトに関わる不可能性。

解析は DictConfigurator クラスによって行われます。このクラスのコンストラクタは環境設定に使われる辞書に渡され、このクラスは configure() メソッドを持ちます。 logging.config モジュールは、呼び出し可能属性 dictConfigClass を持ち、これはまず DictConfigurator に設定されます。 dictConfigClass の値は適切な独自の実装で置き換えられます。

dictConfig() は dictConfigClass を、指定された辞書を渡して呼び出し、それから返されたオブジェクトの configure() メソッドを呼び出して、環境設定を作用させます:

def dictConfig(config):
    dictConfigClass(config).configure()
例えば、 DictConfigurator のサブクラスは、自身の __init__() で DictConfigurator.__init__() を呼び出し、それから続く configure() の呼び出しに使えるカスタムの接頭辞を設定できます。 dictConfigClass は、この新しいサブクラスに束縛され、そして dictConfig() はちょうどデフォルトの、カスタマイズされていない状態のように呼び出せます。

バージョン 3.2 で追加.

logging.config.fileConfig(fname, defaults=None, disable_existing_loggers=True)
ログ記録の環境設定を configparser 形式ファイルから読み出します。そのファイルの形式は 環境設定ファイルの書式 で記述されているとおりにしなければなりません。この関数はアプリケーションから何度も呼び出すことができ、これによって、 (設定を選択し、選択された設定を読み出す機構をデベロッパが提供していれば) 複数の準備済みの設定からエンドユーザが選択するようにできます。

パラメータ
fname -- ファイル名、あるいはファイルのようなオブジェクト、または RawConfigParser 派生のインスタンス。 RawConfigParser 派生のインスタンスが与えられれば、それはそのまま使われます。そうでない場合 Configparser がインスタンス化され、設定はそれを使って fname が指すオブジェクトから読み込まれます。それが readline() メソッドを持っていればそれはファイルのようなオブジェクトと仮定され、 read_file() で読み込まれます; そうでない場合、それはファイル名と仮定されて、 read() に渡されます。

defaults -- ConfigParser に渡されるデフォルト値をこの引数で指定することができます。

disable_existing_loggers -- If specified as False, loggers which exist when this call is made are left enabled. The default is True because this enables old behaviour in a backward-compatible way. This behaviour is to disable any existing non-root loggers unless they or their ancestors are explicitly named in the logging configuration.

バージョン 3.4 で変更: fname として RawConfigParser のサブクラスのインスタンスが渡せ得るようになっています。これによってこのようなことが容易になります:

ロギングの設定が、アプリケーション全体の設定における単なる一部であるような設定ファイルの使用。

ファイルから設定を読み込み、 fileConfig に通す前に(例えばコマンドラインパラメータやランタイム環境の他のなにかで)アプリケーションによって修正するようなこと。

logging.config.listen(port=DEFAULT_LOGGING_CONFIG_PORT, verify=None)
指定されたポートでソケットサーバを起動し、新しい設定を待ち受けます。ポートが指定されなかった場合は、モジュールのデフォルトの DEFAULT_LOGGING_CONFIG_PORT が使用されます。ロギング設定は dictConfig() あるいは fileConfig() で処理できるファイルとして送信されます。 Thread インスタンスを返し、このインスタンスの start() を呼び出してサーバを起動し、適切なところで join() を呼び出すことができます。サーバを停止するには、 stopListening() を呼び出します。

verify 引数を指定する場合は、これはソケットを通して受け取ったバイト文字列が妥当であるか、処理すべきであるかどうかを検査する callable である必要があります。ソケットを通じて、暗号化または署名あるいはその両方を受け取ることがあります。そのような場合に、 verify callable が署名の正当性検査または暗号化の復号あるいはその両方を実施することが出来ます。 verify callable は単一引数で呼び出されます - ソケットを通じて受け取ったバイト文字列です - そして処理すべきバイト文字列、または捨て去られるべきであることを示すための None を返す必要があります。返却されるバイト文字列は(たとえば正当性検査だけが行われて)渡されたものと同じかもしれませんし、あるいは(おそらく暗号化の復号が行われて)まったく異なるものかもしれません。

ソケットに設定を送るには、まず設定ファイルを読み、それを struct.pack('>L', n) を使って長さ 4 バイトのバイナリにパックしたものを前に付けたバイト列としてソケットに送ります。

注釈 設定の部分が eval() を通して渡されるので、この関数の使用はユーザに対してセキュリティリスクを公開してしまうかもしれません。この関数は単に localhost 上のソケットに接続してリモートマシンからは接続を受け付けませんが、 listen() を呼んだプロセスのアカウントで信頼されていないコードが実行されるシナリオが存在します。特に、 listen() を呼んだプロセスがユーザがお互いを信頼することができないマルチユーザのマシン上で実行される場合、悪意のあるユーザは、犠牲者のユーザのプロセスで本質的に任意のコードを実行するように細工することができます。単に犠牲者の listen() ソケットに接続して、犠牲者のプロセスで実行したいコードを実行するような設定を送るだけです。これは、特にデフォルトポートが使用されている場合に行うのがより簡単ですが、異なるポートが使用されていたとしてもそれほど難しくありません)。これが起こるリスクを避けるには、 listen() に verify 引数を使用して、認識されていない設定が適用されないようにしてください。
バージョン 3.4 で変更: verify 引数が追加されました。

注釈 If you want to send configurations to the listener which don't disable existing loggers, you will need to use a JSON format for the configuration, which will use dictConfig() for configuration. This method allows you to specify disable_existing_loggers as False in the configuration you send.
logging.config.stopListening()
listen() を呼び出して作成された、待ち受け中のサーバを停止します。通常 listen() の戻り値に対して join() が呼ばれる前に呼び出します。

環境設定辞書スキーマ
ロギング設定を記述するには、生成するさまざまなオブジェクトと、それらのつながりを列挙しなければなりません。例えば、 'console' という名前のハンドラを生成し、'startup' という名前のロガーがメッセージを 'console' ハンドラに送るというようなことを記述します。これらのオブジェクトは、 logging モジュールによって提供されるものに限らず、独自のフォーマッタやハンドラクラスを書くことも出来ます。このクラスへのパラメータは、 sys.stderr のような外部オブジェクトを必要とすることもあります。これらのオブジェクトとつながりを記述する構文は、以下の オブジェクトの接続 で定義されています。

辞書スキーマの詳細
dictConfig() に渡される辞書は、以下のキーを含んでいなければなりません:

version - スキーマのバージョンを表す整数値に設定されます。現在有効な値は 1 だけですが、このキーがあることで、このスキーマは後方互換性を保ちながら発展できます。

その他すべてのキーは省略可能ですが、与えられたなら以下に記述するように解釈されます。以下のすべての場合において、 '環境設定辞書' と記載されている所では、その辞書に特殊な '()' キーがあるかを調べることで、カスタムのインスタント化が必要であるか判断されます。その場合は、以下の ユーザ定義オブジェクト で記述されている機構がインスタンス生成に使われます。そうでなければ、インスタンス化するべきものを決定するのにコンテキストが使われます。

formatters - 対応する値は辞書で、そのそれぞれのキーがフォーマッタ id になり、それぞれの値が対応する Formatter インスタンスをどのように環境設定するかを記述する辞書になります。

環境設定辞書から、 (デフォルトが None の) キー format と datefmt を検索し、それらが Formatter インスタンスを構成するのに使われます。

バージョン 3.8 で変更: a validate key (with default of True) can be added into the formatters section of the configuring dict, this is to validate the format.

filters - 対応する値は辞書で、そのそれぞれのキーがフィルタ id になり、それぞれの値が対応する Filter インスタンスをどのように環境設定するかを記述する辞書になります。

環境設定辞書は、(デフォルトが空文字列の) キー name を検索され、それらが logging.Filter インスタンスを構成するのに使われます。

handlers - 対応する値は辞書で、そのそれぞれのキーがハンドラ id になり、それぞれの値が対応する Handler インスタンスをどのように環境設定するかを記述する辞書になります。

環境設定辞書は、以下のキーを検索されます:

class (必須)。これはハンドラクラスの完全に修飾された名前です。

level (任意)。ハンドラのレベルです。

formatter (任意)。このハンドラへのフォーマッタの id です。

filters (任意)。このハンドラへのフィルタの id のリストです。

その他の すべての キーは、ハンドラのコンストラクタにキーワード引数として渡されます。例えば、以下のコード片が与えられたとすると:

handlers:
  console:
    class : logging.StreamHandler
    formatter: brief
    level   : INFO
    filters: [allow_foo]
    stream  : ext://sys.stdout
  file:
    class : logging.handlers.RotatingFileHandler
    formatter: precise
    filename: logconfig.log
    maxBytes: 1024
    backupCount: 3
id が console であるハンドラが、 sys.stdout を根底のストリームにして、 logging.StreamHandler としてインスタンス化されます。id が file であるハンドラが、 filename='logconfig.log', maxBytes=1024, backupCount=3 をキーワード引数にして、 logging.handlers.RotatingFileHandler としてインスタンス化されます。

loggers - 対応する値は辞書で、そのそれぞれのキーがロガー名になり、それぞれの値が対応する Logger インスタンスをどのように環境設定するかを記述する辞書になります。

環境設定辞書は、以下のキーを検索されます:

level (任意)。ロガーのレベルです。

propagate (任意)。ロガーの伝播の設定です。

filters (任意)。このロガーへのフィルタの id のリストです。

handlers (任意)。このロガーへのハンドラの id のリストです。

指定されたロガーは、指定されたレベル、伝播、ハンドラに従って環境設定されます。

root - これは、ルートロガーへの設定になります。この環境設定の進行は、propagate 設定が適用されないことを除き、他のロガーと同じです。

incremental - この環境設定が既存の環境設定に対する増分として解釈されるかどうかです。この値のデフォルトは False で、指定された環境設定は、既存の fileConfig() API によって使われているのと同じ意味上で、既存の環境設定を置き換えます。

指定された値が True なら、環境設定は 増分設定 の節で記述されているように進行します。

disable_existing_loggers - whether any existing non-root loggers are to be disabled. This setting mirrors the parameter of the same name in fileConfig(). If absent, this parameter defaults to True. This value is ignored if incremental is True.

増分設定
増分設定に完全な柔軟性を提供するのは難しいです。例えば、フィルタやフォーマッタのようなオブジェクトは匿名なので、一旦環境設定がなされると、設定を拡張するときにそのような匿名オブジェクトを参照することができません。

さらに、一旦環境設定がなされた後、実行時にロガー、ハンドラ、フィルタ、フォーマッタのオブジェクトグラフを任意に変えなければならない例もありません。ロガーとハンドラの冗長性は、レベル (または、ロガーの場合には、伝播フラグ) を設定することによってのみ制御できます。安全な方法でオブジェクトグラフを任意に変えることは、マルチスレッド環境で問題となります。不可能ではないですが、その効用は実装に加えられる複雑さに見合いません。

従って、環境設定辞書の incremental キーが与えられ、これが True であるとき、システムは formatters と filters の項目を完全に無視し、handlers の項目の level 設定と、loggers と root の項目の level と propagate 設定のみを処理します。

環境設定辞書の値を使うことで、設定は pickle 化された辞書としてネットワークを通してソケットリスナに送ることができます。これにより、長時間起動するアプリケーションのロギングの冗長性を、アプリケーションを止めて再起動する必要なしに、いつでも変更することができます。

オブジェクトの接続
このスキーマは、ロギングオブジェクトの一揃い - ロガー、ハンドラ、フォーマッタ、フィルタ - について記述します。これらは、オブジェクトグラフ上でお互い接続されます。従って、このスキーマは、オブジェクト間の接続を表現しなければなりません。例えば、環境設定で、特定のロガーが特定のハンドラに取り付けられたとします。この議論では、ロガーとハンドラが、これら 2 つの接続のそれぞれ送信元と送信先であるといえます。もちろん、この設定オブジェクト中では、これはハンドラへの参照を保持しているロガーで表されます。設定辞書中で、これは次のようになされます。まず、送信先オブジェクトを曖昧さなく指定する id を与えます。そして、その id を送信元オブジェクトの環境設定で使い、送信元とその id をもつ送信先が接続されていることを示します。

ですから、例えば、以下の YAML のコード片を例にとると:

formatters:
  brief:
    # configuration for formatter with id 'brief' goes here
  precise:
    # configuration for formatter with id 'precise' goes here
handlers:
  h1: #This is an id
   # configuration of handler with id 'h1' goes here
   formatter: brief
  h2: #This is another id
   # configuration of handler with id 'h2' goes here
   formatter: precise
loggers:
  foo.bar.baz:
    # other configuration for logger 'foo.bar.baz'
    handlers: [h1, h2]
(注釈: YAML がここで使われているのは、辞書の等価な Python 形式よりもこちらのほうが少し読みやすいからです。)

ロガーの id は、プログラム上でロガーへの参照を得るために使われるロガー名で、たとえば foo.bar.baz です。フォーマッタとフィルタの id は、(上の brief, precise のような) 任意の文字列値にできます。これらは一時的なもので、環境設定辞書の処理にのみ意味があり、オブジェクト間の接続を決定するのに使われます。また、これらは設定の呼び出しが完了したとき、どこにも残りません。

上記のコード片は、foo.bar.baz というの名ロガーに、ハンドラ id h1 と h2 で表される 2 つのハンドラを接続することを示します。h1 のフォーマッタは id brief で記述されるもので、h2 のフォーマッタは id precise で記述されるものです。

ユーザ定義オブジェクト
このスキーマは、ハンドラ、フィルタ、フォーマッタのための、ユーザ定義オブジェクトをサポートします。(ロガーは、異なるインスタンスに対して異なる型を持つ必要はないので、この環境設定スキーマは、ユーザ定義ロガークラスをサポートしていません。)

設定されるオブジェクトは、それらの設定を詳述する辞書によって記述されます。場所によっては、あるオブジェクトがどのようにインスタンス化されるかというコンテキストを、ロギングシステムが推測できます。しかし、ユーザ定義オブジェクトがインスタンス化されるとき、システムはどのようにこれを行うかを知りません。ユーザ定義オブジェクトのインスタンス化を完全に柔軟なものにするため、ユーザは 'ファクトリ' - 設定辞書を引数として呼ばれ、インスタンス化されたオブジェクトを返す呼び出し可能オブジェクト - を提供する必要があります。これは特殊キー '()' で利用できる、ファクトリへの絶対インポートパスによって合図されます。ここに具体的な例を挙げます:

formatters:
  brief:
    format: '%(message)s'
  default:
    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'
    datefmt: '%Y-%m-%d %H:%M:%S'
  custom:
      (): my.package.customFormatterFactory
      bar: baz
      spam: 99.9
      answer: 42
上記の YAML コード片は 3 つのフォーマッタを定義します。 1 つ目は、id が brief で、指定されたフォーマット文字列をもつ、標準 logging.Formatter インスタンスです。 2 つ目は、id が default で、長いフォーマットを持ち、時間フォーマットも定義していて、結果はその 2 つのフォーマット文字列で初期化された logging.Formatter になります。Python ソース形式で見ると、 brief と default フォーマッタは、それぞれ設定の部分辞書:

{
  'format' : '%(message)s'
}
および:

{
  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',
  'datefmt' : '%Y-%m-%d %H:%M:%S'
}
を持ち、これらの辞書が特殊キー '()' を持たないので、インスタンス化はコンテキストから推測され、結果として標準の logging.Formatter インスタンスが生成されます。id が custom である、3 つ目のフォーマッタの設定をする部分辞書は:

{
  '()' : 'my.package.customFormatterFactory',
  'bar' : 'baz',
  'spam' : 99.9,
  'answer' : 42
}
で、ユーザ定義のインスタンス化が望まれることを示す特殊キー '()' を含みます。この場合、指定された呼び出し可能ファクトリオブジェクトが使われます。これが実際の呼び出し可能オブジェクトであれば、それが直接使われます - そうではなく、(この例でのように) 文字列を指定したなら、実際の呼び出し可能オブジェクトは、通常のインポート機構を使って検索されます。その呼び出し可能オブジェクトは、環境設定の部分辞書の、残りの 要素をキーワード引数として呼ばれます。上記の例では、id が custom のフォーマッタは、以下の呼び出しによって返されるものとみなされます:

my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)
キー '()' が特殊キーとして使われるのは、キーワードパラメータ名として不正で、呼び出しに使われるキーワード引数と衝突し得ないからです。'()' はまた、対応する値が呼び出し可能オブジェクトであると覚えやすくします。

外部オブジェクトへのアクセス
環境設定が、例えば sys.stderr のような、設定の外部のオブジェクトへの参照を必要とすることがあります。設定辞書が Python コードで構成されていれば話は簡単ですが、これがテキストファイル (JSON, YAML 等) を通して提供されていると問題となります。テキストファイルでは、sys.stderr をリテラル文字列 'sys.stderr' と区別する標準の方法がありません。この区別を容易にするため、環境設定システムは、文字列中の特定の特殊接頭辞を見つけ、それらを特殊に扱います。例えば、リテラル文字列 'ext://sys.stderr' が設定中の値として与えられたら、この ext:// は剥ぎ取られ、この値の残りが普通のインポート機構で処理されます。

このような接頭辞の処理は、プロトコルの処理と同じようになされます。どちらの機構も、正規表現 ^(?P<prefix>[a-z]+)://(?P<suffix>.*)$ にマッチする接頭辞を検索し、それによって prefix が認識されたなら、接頭辞に応じたやり方で suffix が処理され、その処理の結果によって文字列値が置き換えられます。接頭辞が認識されなければ、その文字列値はそのまま残されます。

内部オブジェクトへのアクセス
外部オブジェクトと同様、環境設定内部のオブジェクトへのアクセスを必要とすることもあります。これは、その各オブジェクトを司る環境設定システムによって暗黙に行われます。例えば、ロガーやハンドラの level に対する文字列値 'DEBUG' は、自動的に値 logging.DEBUG に変換されますし、handlers, filters および formatter の項目は、オブジェクト id を取って、適切な送信先オブジェクトを決定します。

However, a more generic mechanism is needed for user-defined objects which are not known to the logging module. For example, consider logging.handlers.MemoryHandler, which takes a target argument which is another handler to delegate to. Since the system already knows about this class, then in the configuration, the given target just needs to be the object id of the relevant target handler, and the system will resolve to the handler from the id. If, however, a user defines a my.package.MyHandler which has an alternate handler, the configuration system would not know that the alternate referred to a handler. To cater for this, a generic resolution system allows the user to specify:

handlers:
  file:
    # configuration of file handler goes here

  custom:
    (): my.package.MyHandler
    alternate: cfg://handlers.file
The literal string 'cfg://handlers.file' will be resolved in an analogous way to strings with the ext:// prefix, but looking in the configuration itself rather than the import namespace. The mechanism allows access by dot or by index, in a similar way to that provided by str.format. Thus, given the following snippet:

handlers:
  email:
    class: logging.handlers.SMTPHandler
    mailhost: localhost
    fromaddr: my_app@domain.tld
    toaddrs:
      - support_team@domain.tld
      - dev_team@domain.tld
    subject: Houston, we have a problem.
文字列 'cfg://handlers' は、キー handlers をもつ辞書であると分析され、文字列 'cfg://handlers.email' は、handlers 辞書内の、email キーをもつ辞書であると分析されます。文字列 'cfg://handlers.email.toaddrs[1] は、'dev_team@domain.tld' と分析され、'cfg://handlers.email.toaddrs[0]' は値 'support_team@domain.tld' と分析されます。subject の値には、'cfg://handlers.email.subject' または等価な 'cfg://handlers.email[subject]' でアクセスできます。後者が必要なのは、キーがスペースや非アルファベット文字を含むときのみです。インデックス値が十進数字のみで構成されているなら、まず対応する整数値を使ってアクセスが試みられ、必要なら文字列値で代替します。

文字列 cfg://handlers.myhandler.mykey.123 が与えられると、これは config_dict['handlers']['myhandler']['mykey']['123'] と分析されます。文字列が cfg://handlers.myhandler.mykey[123] と指定されたら、システムは config_dict['handlers']['myhandler']['mykey'][123] から値を引き出そうとし、失敗したら config_dict['handlers']['myhandler']['mykey']['123'] で代替します。

インポート解決とカスタムインポーター
インポート解決は、デフォルトではインポートを行うために __import__() 組み込み関数を使用します。これを独自のインポートメカニズムに置き換えたいと思うかもしれません: もしそうなら、 DictConfigurator あるいはその上位クラスである BaseConfigurator クラスの importer 属性を置換することができます。ただし、この関数はクラスからディスクリプタ経由でアクセスされる点に注意する必要があります。インポートを行うために Python callable を使用していて、それをインスタンスレベルではなくクラスレベルで定義したければ、 staticmethod() でそれをラップする必要があります。例えば:

from importlib import import_module
from logging.config import BaseConfigurator

BaseConfigurator.importer = staticmethod(import_module)
configurator インスタンス に対してインポート callable をセットする場合は、 staticmethod() でラップする必要はありません。

環境設定ファイルの書式
fileConfig() が解釈できる環境設定ファイルの形式は、 configparser の機能に基づいています。ファイルには、 [loggers], [handlers], [formatters] といったセクションが入っていなければならず、各セクションではファイル中で定義されている各タイプのエンティティを名前で指定しています。こうしたエンティティの各々について、そのエンティティをどう設定するかを示した個別のセクションがあります。すなわち、 log01 という名前の [loggers] セクションにあるロガーに対しては、対応する詳細設定がセクション [logger_log01] に収められています。同様に、 hand01 という名前の [handlers] セクションにあるハンドラは [handler_hand01] と呼ばれるセクションに設定をもつことになり、 [formatters] セクションにある form01 は [formatter_form01] というセクションで設定が指定されています。ルートロガーの設定は [logger_root] と呼ばれるセクションで指定されていなければなりません。

注釈 fileConfig() API は dictConfig() API よりも古く、ロギングのある種の側面についてカバーする機能に欠けています。たとえば fileConfig() では数値レベルを超えたメッセージを単に拾うフィルタリングを行う Filter オブジェクトを構成出来ません。 Filter のインスタンスをロギングの設定において持つ必要があるならば、 dictConfig() を使う必要があるでしょう。設定の機能における将来の拡張は dictConfig() に対して行われることに注意してください。ですから、そうするのが便利であるときに新しい API に乗り換えるのは良い考えです。
ファイルにおけるこれらのセクションの例を以下に示します。

[loggers]
keys=root,log02,log03,log04,log05,log06,log07

[handlers]
keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09

[formatters]
keys=form01,form02,form03,form04,form05,form06,form07,form08,form09
ルートロガーでは、レベルとハンドラのリストを指定しなければなりません。ルートロガーのセクションの例を以下に示します。

[logger_root]
level=NOTSET
handlers=hand01
level エントリは DEBUG, INFO, WARNING, ERROR, CRITICAL のうちの一つか、 NOTSET になります。ルートロガーの場合にのみ、 NOTSET はすべてのメッセージがログ記録されることを意味します。レベル値は logging パッケージの名前空間のコンテキストにおいて eval() されます。

handlers エントリはコンマで区切られたハンドラ名からなるリストで、[handlers] セクションになくてはなりません。また、これらの各ハンドラの名前に対応するセクションが設定ファイルに存在しなければなりません。

ルートロガー以外のロガーでは、いくつか追加の情報が必要になります。これは以下の例のように表されます。

[logger_parser]
level=DEBUG
handlers=hand01
propagate=1
qualname=compiler.parser
level および handlers エントリはルートロガーのエントリと同様に解釈されますが、非ルートロガーのレベルが NOTSET に指定された場合、ロギングシステムはロガー階層のより上位のロガーにロガーの実効レベルを問い合わせるところが違います。propagate エントリは、メッセージをロガー階層におけるこのロガーの上位のハンドラに伝播させることを示す 1 に設定されるか、メッセージを階層の上位に伝播 しない ことを示す 0 に設定されます。qualname エントリはロガーのチャネル名を階層的に表したもの、すなわちアプリケーションがこのロガーを取得する際に使う名前になります。

ハンドラの環境設定を指定しているセクションは以下の例のようになります。

[handler_hand01]
class=StreamHandler
level=NOTSET
formatter=form01
args=(sys.stdout,)
class エントリはハンドラのクラス (logging パッケージの名前空間において eval() で決定されます) を示します。 level はロガーの場合と同じように解釈され、 NOTSET は "すべてを記録する (log everything)" と解釈されます。

formatter エントリはこのハンドラのフォーマッタに対するキー名を表します。空文字列の場合、デフォルトのフォーマッタ (logging._defaultFormatter) が使われます。名前が指定されている場合、その名前は [formatters] セクションになくてはならず、対応するセクションが設定ファイル中になければなりません。

The args entry, when eval()uated in the context of the logging package's namespace, is the list of arguments to the constructor for the handler class. Refer to the constructors for the relevant handlers, or to the examples below, to see how typical entries are constructed. If not provided, it defaults to ().

The optional kwargs entry, when eval()uated in the context of the logging package's namespace, is the keyword argument dict to the constructor for the handler class. If not provided, it defaults to {}.

[handler_hand02]
class=FileHandler
level=DEBUG
formatter=form02
args=('python.log', 'w')

[handler_hand03]
class=handlers.SocketHandler
level=INFO
formatter=form03
args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)

[handler_hand04]
class=handlers.DatagramHandler
level=WARN
formatter=form04
args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)

[handler_hand05]
class=handlers.SysLogHandler
level=ERROR
formatter=form05
args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)

[handler_hand06]
class=handlers.NTEventLogHandler
level=CRITICAL
formatter=form06
args=('Python Application', '', 'Application')

[handler_hand07]
class=handlers.SMTPHandler
level=WARN
formatter=form07
args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')
kwargs={'timeout': 10.0}

[handler_hand08]
class=handlers.MemoryHandler
level=NOTSET
formatter=form08
target=
args=(10, ERROR)

[handler_hand09]
class=handlers.HTTPHandler
level=NOTSET
formatter=form09
args=('localhost:9022', '/log', 'GET')
kwargs={'secure': True}
フォーマッタの環境設定を指定しているセクションは以下のような形式です。

[formatter_form01]
format=F1 %(asctime)s %(levelname)s %(message)s
datefmt=
class=logging.Formatter
The format entry is the overall format string, and the datefmt entry is the strftime()-compatible date/time format string. If empty, the package substitutes something which is almost equivalent to specifying the date format string '%Y-%m-%d %H:%M:%S'. This format also specifies milliseconds, which are appended to the result of using the above format string, with a comma separator. An example time in this format is 2003-01-23 00:29:50,411.

class エントリはオプションです。これはフォーマッタクラスの名前を (モジュール名とクラス名をドットでつないだもので) 指し示すものです。このオプションは Formatter の子クラスをインスタンス化するのに便利です。 Formatter の子クラスが、展開もしくは要約された形式の例外トレースバックを表示することができます。

注釈 eval() を使用していることで、上述のようにソケット経由で設定を送受信するために listen() を使用していることに起因する潜在的なセキュリティリスクがあります。そのリスクは、相互に信頼できない多数のユーザが同じマシン上でコードを実行する場合に制限されています; 詳細は listen() ドキュメンテーションを参照してください。
参考
logging モジュール
logging モジュールの API リファレンス。

logging.handlers モジュール
logging モジュールに含まれる、便利なハンドラです。

logging.handlers --- ロギングハンドラ
ソースコード: Lib/logging/handlers.py

Important

このページには、リファレンス情報だけが含まれています。チュートリアルは、以下のページを参照してください

基本チュートリアル

上級チュートリアル

ロギングクックブック

このパッケージでは、以下の便利なハンドラが提供されています。なお、これらのハンドラのうち、3 つ (StreamHandler, FileHandler および NullHandler) は、実際には logging モジュール自身で定義されていますが、他のハンドラと一緒にここでドキュメント化します。

StreamHandler
logging コアパッケージに含まれる StreamHandler クラスは、ログ出力を sys.stdout, sys.stderr あるいは何らかのファイル風 (file-like) オブジェクト (あるいは、より正確に言えば write() および flush() メソッドをサポートする何らかのオブジェクト) といったストリームに送信します。

class logging.StreamHandler(stream=None)
StreamHandler クラスの新たなインスタンスを返します。 stream が指定された場合、インスタンスはログ出力先として指定されたストリームを使います; そうでない場合、 sys.stderr が使われます。

emit(record)
If a formatter is specified, it is used to format the record. The record is then written to the stream followed by terminator. If exception information is present, it is formatted using traceback.print_exception() and appended to the stream.

flush()
ストリームの flush() メソッドを呼び出してバッファをフラッシュします。 close() メソッドは Handler から継承しているため何も出力を行わないので、 flush() 呼び出しを明示的に行う必要があるかもしれません。

setStream(stream)
このインスタンスの stream と指定された値が異なる場合、指定された値に設定します。 新しい stream を設定する前に、古い stream はフラッシュされます。

パラメータ
stream -- ハンドラがこれから使う stream 。

戻り値
stream が変更された場合は古い stream 、そうでない場合は None 。

バージョン 3.7 で追加.

terminator
String used as the terminator when writing a formatted record to a stream. Default value is '\n'.

If you don't want a newline termination, you can set the handler instance's terminator attribute to the empty string.

In earlier versions, the terminator was hardcoded as '\n'.

バージョン 3.2 で追加.

FileHandler
logging コアパッケージに含まれる FileHandler クラスは、ログ出力をディスク上のファイルに送信します。このクラスは出力機能を StreamHandler から継承しています。

class logging.FileHandler(filename, mode='a', encoding=None, delay=False, errors=None)
Returns a new instance of the FileHandler class. The specified file is opened and used as the stream for logging. If mode is not specified, 'a' is used. If encoding is not None, it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to emit(). By default, the file grows indefinitely. If errors is specified, it's used to determine how encoding errors are handled.

バージョン 3.6 で変更: 文字列値に加え、 Path オブジェクトも filename 引数が受け取るようになりました。

バージョン 3.9 で変更: The errors parameter was added.

close()
ファイルを閉じます。

emit(record)
record をファイルに出力します。

NullHandler
バージョン 3.1 で追加.

logging コアパッケージに含まれる NullHandler クラスは、いかなる書式化も出力も行いません。これは本質的には、ライブラリ開発者に使われる 'no-op' ハンドラです。

class logging.NullHandler
NullHandler クラスの新しいインスタンスを返します。

emit(record)
このメソッドは何もしません。

handle(record)
このメソッドは何もしません。

createLock()
アクセスが特殊化される必要がある I/O が下にないので、このメソッドはロックに対して None を返します。

NullHandler の使い方の詳しい情報は、 ライブラリのためのロギングの設定 を参照してください。

WatchedFileHandler
logging.handlers モジュールに含まれる WatchedFileHandler クラスは、ログ記録先のファイルを監視する FileHandler の一種です。ファイルが変更された場合、ファイルを閉じてからファイル名を使って開き直します。

ファイルはログファイルをローテーションさせる newsyslog や logrotate のようなプログラムを使うことで変更されることがあります。このハンドラは、 Unix/Linux で使われることを意図していますが、ファイルが最後にログを出力してから変わったかどうかを監視します。 (ファイルはデバイスや inode が変わることで変わったと判断します。) ファイルが変わったら古いファイルのストリームは閉じて、現在のファイルを新しいストリームを取得するために開きます。

このハンドラを Windows で使うことは適切ではありません。というのも Windows では開いているログファイルを移動したり削除したりできないからです - logging はファイルを排他的ロックを掛けて開きます - そのためこうしたハンドラは必要ないのです。さらに、 Windows では ST_INO がサポートされていません; stat() はこの値として常に 0 を返します。

class logging.handlers.WatchedFileHandler(filename, mode='a', encoding=None, delay=False, errors=None)
Returns a new instance of the WatchedFileHandler class. The specified file is opened and used as the stream for logging. If mode is not specified, 'a' is used. If encoding is not None, it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to emit(). By default, the file grows indefinitely. If errors is provided, it determines how encoding errors are handled.

バージョン 3.6 で変更: 文字列値に加え、 Path オブジェクトも filename 引数が受け取るようになりました。

バージョン 3.9 で変更: The errors parameter was added.

reopenIfNeeded()
ファイルが変更されていないかチェックします。 もし変更されていれば、手始めにレコードをファイルに出力し、既存のストリームはフラッシュして閉じられ、ファイルが再度開かれます。

バージョン 3.6 で追加.

emit(record)
レコードをファイルに出力しますが、最初に reopenIfNeeded() を呼び出して、変更があった場合はファイルを再度開きます。

BaseRotatingHandler
logging.handlers モジュールに存在する BaseRotatingHandler クラスは、ローテートを行うファイルハンドラ RotatingFileHandler と TimedRotatingFileHandler のベースクラスです。このクラスをインスタンス化する必要はありませんが、オーバーライドすることになるかもしれない属性とメソッドを持っています。

class logging.handlers.BaseRotatingHandler(filename, mode, encoding=None, delay=False, errors=None)
パラメータは FileHandler と同じです。属性は次の通りです:

namer
この属性に callable がセットされた場合、 rotation_filename() メソッドはこの callable に委譲されます。 callable に渡されるパラメータは rotation_filename() に渡されたものです。

注釈 namer 関数はロールオーバー中にかなりの回数呼ばれます。そのため、できるだけ単純で、速くあるべきです。さらに、それは与えられた入力に対しては常に同じ出力を返すべきです。そうでなければ、ロールオーバーの振る舞いは期待通りに動かないかもしれません。
バージョン 3.3 で追加.

rotator
この属性に callable がセットされた場合、 rotate() メソッドはこの callable に委譲されます。 callable に渡されるパラメータは rotate() に渡されたものです。

バージョン 3.3 で追加.

rotation_filename(default_name)
ローテートを行う際にログファイルのファイル名を変更します。

このメソッドは、ファイル名をカスタマイズするために提供されます。

デフォルト実装は、ハンドラの 'namer' 属性が callable だった場合、その callable を呼んでデフォルト名を渡します。属性が callable でない場合 (デフォルトは None です)、名前は変更せずに返されます。

パラメータ
default_name -- ログファイルのデフォルトのファイル名。

バージョン 3.3 で追加.

rotate(source, dest)
ローテートが行われる時、現在のログをローテートします。

デフォルト実装は、 ハンドラの 'rotator' 属性が callable だった場合、その callable を呼んで source と dest 引数を渡します。属性が callable でない場合 (デフォルトは None です)、単に source が destination に改名されます。

パラメータ
source -- ソースファイル名。これは通常ベースファイル名 、例えば 'test.log' となります。

dest -- 変更先ファイル名。これは通常ソースファイルをローテートしたもの (例えば 'test.log.1') です。

バージョン 3.3 で追加.

これらの属性が存在する理由は、サブクラス化を省略できるようにするためです。 RotatingFileHandler と TimedRotatingFileHandler のインスタンスに対して同じ callable が使えます。もし namer や rotator callable が例外を上げれば、 emit() 呼び出しで発生した他の例外と同じ方法で、つまりハンドラの handleError() メソッドによって扱われます。

ローテート処理に大幅な変更を加える必要があれば、メソッドをオーバーライドすることができます。

例えば、 rotator と namer を使ってログローテートをカスタマイズする を参照してください。

RotatingFileHandler
logging.handlers モジュールに含まれる RotatingFileHandler クラスは、ディスク上のログファイルに対するローテーション処理をサポートします。

class logging.handlers.RotatingFileHandler(filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=False, errors=None)
Returns a new instance of the RotatingFileHandler class. The specified file is opened and used as the stream for logging. If mode is not specified, 'a' is used. If encoding is not None, it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to emit(). By default, the file grows indefinitely. If errors is provided, it determines how encoding errors are handled.

maxBytes および backupCount 値を指定することで、あらかじめ決められたサイズでファイルをロールオーバ (rollover) させることができます。 指定サイズを超えそうになると、ファイルは閉じられ、暗黙のうちに新たなファイルが開かれます。 ロールオーバは現在のログファイルの長さが maxBytes に近くなると常に起きますが、 maxBytes または backupCount がゼロならロールオーバは起きなくなってしまうので、一般的には backupCount を少なくとも 1 に設定し maxBytes を非ゼロにするのが良いでしょう。 backupCount が非ゼロのとき、システムは古いログファイルをファイル名に ".1", ".2" といった拡張子を追加して保存します。 例えば、 backupCount が 5 で、基本のファイル名が app.log なら、 app.log, app.log.1, app.log.2 ... と続き、 app.log.5 までを得ることになります。 ログの書き込み対象になるファイルは常に app.log です。このファイルが満杯になると、ファイルは閉じられ、 app.log.1 に名前が変更されます。 app.log.1, app.log.2 などが存在する場合、それらのファイルはそれぞれ app.log.2, app.log.3 といった具合に名前が変更されます。

バージョン 3.6 で変更: 文字列値に加え、 Path オブジェクトも filename 引数が受け取るようになりました。

バージョン 3.9 で変更: The errors parameter was added.

doRollover()
上述のような方法でロールオーバを行います。

emit(record)
上述のようなロールオーバを行いながら、レコードをファイルに出力します。

TimedRotatingFileHandler
logging.handlers モジュールに含まれる TimedRotatingFileHandler クラスは、特定の時間間隔でのログローテーションをサポートしています。

class logging.handlers.TimedRotatingFileHandler(filename, when='h', interval=1, backupCount=0, encoding=None, delay=False, utc=False, atTime=None, errors=None)
TimedRotatingFileHandler クラスの新たなインスタンスを返します。 filename に指定したファイルを開き、ログ出力先のストリームとして使います。ログファイルのローテーション時には、ファイル名に拡張子 (suffix) をつけます。ログファイルのローテーションは when および interval の積に基づいて行います。

when は interval の単位を指定するために使います。使える値は下表の通りです。大小文字の区別は行いません。

値

interval の単位

atTime の使用有無/使用方法

'S'

秒

無視

'M'

分

無視

'H'

時間

無視

'D'

日

無視

'W0'-'W6'

曜日 (0=月曜)

初期のロールオーバー時刻の算出に使用

'midnight'

atTime が指定されなかった場合は深夜に、そうでない場合は atTime の時刻にロールオーバーされます

初期のロールオーバー時刻の算出に使用

曜日ベースのローテーションを使う場合は、月曜として 'W0' を、火曜として 'W1' を、…、日曜として 'W6' を指定します。このケースの場合は、 interval は使われません。

古いログファイルの保存時、ロギングシステムによりファイル名に拡張子が付けられます。 ロールオーバ間隔によって、strftime の %Y-%m-%d_%H-%M-%S 形式またはその前方の一部を使って、日付と時間に基づいた拡張子が付けられます。

最初に次のロールオーバー時間を計算するとき (ハンドラが生成されるとき)、次のローテーションがいつ起こるかを計算するために、既存のログファイルの最終変更時刻または現在の時間が使用されます。

utc 引数が true の場合時刻は UTC になり、それ以外では現地時間が使われます。

backupCount がゼロでない場合、保存されるファイル数は高々 backupCount 個で、それ以上のファイルがロールオーバされる時に作られるならば、一番古いものが削除されます。削除のロジックは interval で決まるファイルを削除するので、 interval を変えると古いファイルが残ったままになることもあります。

delay が true なら、ファイルを開くのは emit() の最初の呼び出しまで延期されます。

If atTime is not None, it must be a datetime.time instance which specifies the time of day when rollover occurs, for the cases where rollover is set to happen "at midnight" or "on a particular weekday". Note that in these cases, the atTime value is effectively used to compute the initial rollover, and subsequent rollovers would be calculated via the normal interval calculation.

If errors is specified, it's used to determine how encoding errors are handled.

注釈 Calculation of the initial rollover time is done when the handler is initialised. Calculation of subsequent rollover times is done only when rollover occurs, and rollover occurs only when emitting output. If this is not kept in mind, it might lead to some confusion. For example, if an interval of "every minute" is set, that does not mean you will always see log files with times (in the filename) separated by a minute; if, during application execution, logging output is generated more frequently than once a minute, then you can expect to see log files with times separated by a minute. If, on the other hand, logging messages are only output once every five minutes (say), then there will be gaps in the file times corresponding to the minutes where no output (and hence no rollover) occurred.
バージョン 3.4 で変更: atTime パラメータが追加されました。

バージョン 3.6 で変更: 文字列値に加え、 Path オブジェクトも filename 引数が受け取るようになりました。

バージョン 3.9 で変更: The errors parameter was added.

doRollover()
上述のような方法でロールオーバを行います。

emit(record)
上で説明した方法でロールオーバを行いながら、レコードをファイルに出力します。

SocketHandler
logging.handlers モジュールに含まれる SocketHandler クラスは、ログ出力をネットワークソケットに送信します。基底クラスでは TCP ソケットを用います。

class logging.handlers.SocketHandler(host, port)
アドレスが host および port で与えられた遠隔のマシンと通信するようにした SocketHandler クラスのインスタンスを生成して返します。

バージョン 3.4 で変更: port に None を指定すると、Unix ドメインソケットが host 値を用いて作られます - そうでない場合は TCP ソケットが作られます。

close()
ソケットを閉じます。

emit()
レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle して LogRecord にするには、 makeLogRecord() 関数を使ってください。

handleError()
emit() の処理中に発生したエラーを処理します。よくある原因は接続の消失です。次のイベント発生時に再試行できるようにソケットを閉じます。

makeSocket()
サブクラスで必要なソケット形式を詳細に定義できるようにするためのファクトリメソッドです。デフォルトの実装では、 TCP ソケット (socket.SOCK_STREAM) を生成します。

makePickle(record)
レコードの属性辞書をバイナリ形式に pickle したものの先頭に長さ情報を付け、ソケットを介して送信できるようにして返します。 この操作の詳細は次のコードと同等です:

data = pickle.dumps(record_attr_dict, 1)
datalen = struct.pack('>L', len(data))
return datalen + data
pickle が完全に安全というわけではないことに注意してください。セキュリティに関して心配なら、より安全なメカニズムを実装するためにこのメソッドをオーバーライドすると良いでしょう。例えば、 HMAC を使って pickle に署名して、受け取る側ではそれを検証することができます。あるいはまた、受け取る側でグローバルなオブジェクトの unpickle を無効にすることができます。

send(packet)
pickle したバイト文字列 packet をソケットに送信します。 送信するバイト文字列のフォーマットは、 makePickle() のドキュメントで解説されています。

この関数はネットワークがビジーの時に発生する部分的送信に対応しています。

createSocket()
ソケットの生成を試みます。失敗時には、指数的な減速アルゴリズムを使います。最初の失敗時には、ハンドラは送ろうとしていたメッセージを落とします。続くメッセージが同じインスタンスで扱われたとき、幾らかの時間が経過するまで接続を試みません。デフォルトのパラメタは、最初の遅延時間が 1 秒で、その遅延時間の後でそれでも接続が確保できないなら、遅延時間は 2 倍づつになり、最大で 30 秒になります。

この働きは、以下のハンドラ属性で制御されます:

retryStart (最初の遅延時間、デフォルトは 1.0 秒)。

retryFactor (乗数、デフォルトは 2.0)。

retryMax (最大遅延時間、デフォルトは 30.0 秒)。

つまり、ハンドラが使われた 後に リモートリスナが起動した場合、メッセージが失われてしまうことがあります (ハンドラは、遅延時間が経過するまで接続を試みようとさえせず、その遅延時間中に通知なくメッセージを捨てるので)。

DatagramHandler
logging.handlers モジュールに含まれる DatagramHandler クラスは、 SocketHandler を継承しており、 UDP ソケットを介したログ記録メッセージの送信をサポートしています。

class logging.handlers.DatagramHandler(host, port)
アドレスが host および port で与えられた遠隔のマシンと通信するようにした DatagramHandler クラスのインスタンスを生成して返します。

バージョン 3.4 で変更: port に None を指定すると、Unix ドメインソケットが host 値を用いて作られます - そうでない場合は UDP ソケットが作られます。

emit()
レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle して LogRecord にするには、 makeLogRecord() 関数を使ってください。

makeSocket()
ここで SocketHandler のファクトリメソッドをオーバライドして、 UDP ソケット (socket.SOCK_DGRAM) を生成しています。

send(s)
pickle したバイト文字列をソケットに送信します。 送信するバイト文字列のフォーマットは、 SocketHandler.makePickle() のドキュメントで解説されています。

SysLogHandler
logging.handlers モジュールに含まれる SysLogHandler クラスは、ログ記録メッセージを遠隔またはローカルの Unix syslog に送信する機能をサポートしています。

class logging.handlers.SysLogHandler(address=('localhost', SYSLOG_UDP_PORT), facility=LOG_USER, socktype=socket.SOCK_DGRAM)
遠隔の Unix マシンと通信するための、 SysLogHandler クラスの新たなインスタンスを返します。マシンのアドレスは (host, port) のタプル形式をとる address で与えられます。 address が指定されない場合、 ('localhost', 514) が使われます。アドレスは UDP ソケットを使って開かれます。 (host, port) のタプル形式の代わりに文字列で "/dev/log" のように与えることもできます。この場合、 Unix ドメインソケットが syslog にメッセージを送るのに使われます。 facility が指定されない場合、 LOG_USER が使われます。開かれるソケットの型は、 socktype 引数に依り、デフォルトは socket.SOCK_DGRAM で、UDP ソケットを開きます。 (rsyslog のような新しい syslog デーモンと使うために) TCP ソケットを開くには、 socket.SOCK_STREAM の値を指定してください。

使用中のサーバが UDP ポート 514 を待機していない場合、 SysLogHandler が正常に動作していないように見える場合があります。その場合、ドメインソケットに使うべきアドレスを調べてください。そのアドレスはシステムによって異なります。例えば、Linux システムでは通常 '/dev/log' ですが、 OS X では '/var/run/syslog' です。プラットフォームを確認し、適切なアドレスを使う必要があります (アプリケーションを複数のプラットフォーム上で動作させる必要がある場合、実行時に確認する必要があるかもしれません)。Windows では、多くの場合、UDP オプションを使用する必要があります。

バージョン 3.2 で変更: socktype が追加されました。

close()
遠隔ホストへのソケットを閉じます。

emit(record)
レコードは書式化された後、 syslog サーバに送信されます。例外情報が存在しても、サーバには 送信されません 。

バージョン 3.2.1 で変更: (参照: bpo-12168) 初期のバージョンでは、 syslog デーモンに送られるメッセージは常に NUL バイトで終端していました。初期のバージョンの syslog デーモンが NUL 終端されたメッセージを期待していたからです - たとえ、それが適切な仕様 (RFC 5424) にはなかったとしても。 syslog デーモンの新しいバージョンは NUL バイトを期待せず、代わりにもしそれがある場合は削除します。さらに、より最近のデーモン (RFC 5424 により忠実なバージョン) は、メッセージの一部として NUL バイトを通します。

このような異なるデーモンの振る舞いすべてに対して syslog メッセージの取り扱いをより容易にするため、 NUL バイトの追加はクラスレベル属性 append_nul を使用して設定できるようになりました。これはデフォルトで True (既存の振る舞いを保持) ですが、 SysLogHandler インスタンスが NUL 終端文字を追加 しない ように False にセットすることができます。

バージョン 3.3 で変更: (参照: bpo-12419) 以前のバージョンでは、メッセージソースを識別するための "ident" あるいは "tag" プリフィックス機能はありませんでした。これは、今ではクラスレベル属性を使用して指定することができるようになりました。デフォルトでは既存の振る舞いを保持するために "" ですが、特定の SysLogHandler インスタンスが扱うすべてのメッセージに識別子を前置するようにそれをオーバーライドすることができます。識別子はバイトではなくテキストでなければならず、正確にそのままメッセージに前置されることに注意してください。

encodePriority(facility, priority)
ファシリティおよび優先度を整数に符号化します。値は文字列でも整数でも渡すことができます。文字列が渡された場合、内部の対応付け辞書が使われ、整数に変換されます。

シンボリックな LOG_ 値は SysLogHandler で定義されています。これは sys/syslog.h ヘッダーファイルで定義された値を反映しています。

優先度

名前 (文字列)

シンボル値

alert

LOG_ALERT

crit or critical

LOG_CRIT

debug

LOG_DEBUG

emerg or panic

LOG_EMERG

err or error

LOG_ERR

info

LOG_INFO

notice

LOG_NOTICE

warn or warning

LOG_WARNING

ファシリティ

名前 (文字列)

シンボル値

auth

LOG_AUTH

authpriv

LOG_AUTHPRIV

cron

LOG_CRON

daemon

LOG_DAEMON

ftp

LOG_FTP

kern

LOG_KERN

lpr

LOG_LPR

mail

LOG_MAIL

news

LOG_NEWS

syslog

LOG_SYSLOG

user

LOG_USER

uucp

LOG_UUCP

local0

LOG_LOCAL0

local1

LOG_LOCAL1

local2

LOG_LOCAL2

local3

LOG_LOCAL3

local4

LOG_LOCAL4

local5

LOG_LOCAL5

local6

LOG_LOCAL6

local7

LOG_LOCAL7

mapPriority(levelname)
ログレベル名を syslog 優先度名に対応付けます。カスタムレベルを使用している場合や、デフォルトアルゴリズムがニーズに適していない場合には、このメソッドをオーバーライドする必要があるかもしれません。デフォルトアルゴリズムは、 DEBUG, INFO, WARNING, ERROR, CRITICAL を等価な syslog 名に、他のすべてのレベル名を "warning" に対応付けます。

NTEventLogHandler
logging.handlers モジュールに含まれる NTEventLogHandler クラスは、ログ記録メッセージをローカルな Windows NT, Windows 2000, または Windows XP のイベントログに送信する機能をサポートします。この機能を使えるようにするには、 Mark Hammond による Python 用 Win32 拡張パッケージをインストールする必要があります。

class logging.handlers.NTEventLogHandler(appname, dllname=None, logtype='Application')
NTEventLogHandler クラスの新たなインスタンスを返します。 appname はイベントログに表示する際のアプリケーション名を定義するために使われます。この名前を使って適切なレジストリエントリが生成されます。 dllname はログに保存するメッセージ定義の入った .dll または .exe ファイルへの完全修飾パス名を与えなければなりません (指定されない場合、 'win32service.pyd' が使われます - このライブラリは Win32 拡張とともにインストールされ、いくつかのプレースホルダとなるメッセージ定義を含んでいます)。これらのプレースホルダを利用すると、メッセージの発信源全体がログに記録されるため、イベントログは巨大になるので注意してください。 logtype は 'Application', 'System', 'Security' のいずれかで、デフォルトは 'Application' です。

close()
現時点では、イベントログエントリの発信源としてのアプリケーション名をレジストリから除去することはできます。しかしこれを行うと、イベントログビューアで意図した通りにログが見えなくなるでしょう - これはイベントログが .dll 名を取得するためにレジストリにアクセスできなければならないからです。現在のバージョンではこの操作を行いません。

emit(record)
メッセージ ID、イベントカテゴリ、イベント型を決定し、メッセージを NT イベントログに記録します。

getEventCategory(record)
レコードに対するイベントカテゴリを返します。自作のカテゴリを指定したい場合、このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは 0 を返します。

getEventType(record)
レコードのイベント型を返します。自作の型を指定したい場合、このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは、ハンドラの typemap 属性を使って対応付けを行います。この属性は __init__() で初期化され、 DEBUG, INFO, WARNING, ERROR, CRITICAL が入っています。自作のレベルを使っているのなら、このメソッドをオーバライドするか、ハンドラの typemap 属性に適切な辞書を配置する必要があるでしょう。

getMessageID(record)
レコードのメッセージ ID を返します。自作のメッセージを使っているのなら、ロガーに渡される msg を書式化文字列ではなく ID にします。その上で、辞書参照を行ってメッセージ ID を得ます。このクラスのバージョンでは 1 を返します。この値は win32service.pyd における基本メッセージ ID です。

SMTPHandler
logging.handlers モジュールに含まれる SMTPHandler クラスは、 SMTP を介したログ記録メッセージの送信機能をサポートします。

class logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0)
新たな SMTPHandler クラスのインスタンスを返します。インスタンスは email の from および to アドレス行、および subject 行とともに初期化されます。 toaddrs は文字列からなるリストでなければなりません。非標準の SMTP ポートを指定するには、 mailhost 引数に (host, port) のタプル形式を指定します。文字列を使った場合、標準の SMTP ポートが使われます。もし SMTP サーバが認証を必要とするならば、 (username, password) のタプル形式を credentials 引数に指定することができます。

セキュアプロトコル (TLS) の使用を指定するには secure 引数にタプルを渡してください。これは認証情報が渡された場合のみ使用されます。タプルは、空のタプルか、キーファイルの名前を持つ1要素のタプルか、またはキーファイルと証明書ファイルの名前を持つ2要素のタプルのいずれかでなければなりません。 (このタプルは smtplib.SMTP.starttls() メソッドに渡されます。)

SMTP サーバとのコミュニケーションのために、 timeout 引数を使用してタイムアウトを指定することができます。

バージョン 3.3 で追加: timeout 引数が追加されました。

emit(record)
レコードを書式化し、指定されたアドレスに送信します。

getSubject(record)
レコードに応じたサブジェクト行を指定したいなら、このメソッドをオーバライドしてください。

MemoryHandler
logging.handlers モジュールに含まれる MemoryHandler は、ログ記録するレコードをメモリ上にバッファリングし、定期的にその内容をターゲット (target) となるハンドラにフラッシュする機能をサポートしています。フラッシュ処理はバッファが一杯になるか、ある深刻度かそれ以上のレベルを持つイベントが観測された際に行われます。

MemoryHandler はより一般的な抽象クラス、 BufferingHandler のサブクラスです。この抽象クラスでは、ログ記録するレコードをメモリ上にバッファリングします。各レコードがバッファに追加される毎に、 shouldFlush() を呼び出してバッファをフラッシュすべきかどうか調べます。フラッシュする必要がある場合、 flush() がフラッシュ処理を行うものと想定されます。

class logging.handlers.BufferingHandler(capacity)
Initializes the handler with a buffer of the specified capacity. Here, capacity means the number of logging records buffered.

emit(record)
Append the record to the buffer. If shouldFlush() returns true, call flush() to process the buffer.

flush()
このメソッドをオーバライドして、自作のフラッシュ動作を実装することができます。このクラスのバージョンのメソッドでは、単にバッファの内容を削除して空にします。

shouldFlush(record)
Return True if the buffer is up to capacity. This method can be overridden to implement custom flushing strategies.

class logging.handlers.MemoryHandler(capacity, flushLevel=ERROR, target=None, flushOnClose=True)
Returns a new instance of the MemoryHandler class. The instance is initialized with a buffer size of capacity (number of records buffered). If flushLevel is not specified, ERROR is used. If no target is specified, the target will need to be set using setTarget() before this handler does anything useful. If flushOnClose is specified as False, then the buffer is not flushed when the handler is closed. If not specified or specified as True, the previous behaviour of flushing the buffer will occur when the handler is closed.

バージョン 3.6 で変更: flushOnClose パラメータが追加されました。

close()
flush() を呼び出し、ターゲットを None に設定してバッファを消去します。

flush()
MemoryHandler の場合、フラッシュ処理は単に、バッファされたレコードをターゲットがあれば送信することを意味します。これと異なる動作を行いたい場合、オーバライドしてください。

setTarget(target)
ターゲットハンドラをこのハンドラに設定します。

shouldFlush(record)
バッファが一杯になっているか、 flushLevel またはそれ以上のレコードでないかを調べます。

HTTPHandler
logging.handlers モジュールに含まれる HTTPHandler クラスは、ログ記録メッセージを GET または POST セマンティクスを使って Web サーバに送信する機能をサポートしています。

class logging.handlers.HTTPHandler(host, url, method='GET', secure=False, credentials=None, context=None)
HTTPHandler クラスの新たなインスタンスを返します。特別なポートを使う必要がある場合、host は host:port の形式で使うことができます。 method が指定されない場合、 GET が使われます。 secure が真の場合、HTTPS 接続が使われます。 HTTPS 接続で使用する SSL 設定のために context 引数を ssl.SSLContext のインスタンスに設定することができます。 credentials を指定する場合、BASIC 認証の際の HTTP 'Authorization' ヘッダに使われるユーザIDとパスワードからなる 2要素タプルを渡してください。 credentials を指定する場合、ユーザIDとパスワードが通信中に平文として剥き出しにならないよう、secure=True も指定すべきです。

バージョン 3.5 で変更: context パラメータが追加されました。

mapLogRecord(record)
URL エンコードされて Web サーバに送信することになる、 record に基づく辞書を供給します。デフォルトの実装では単に record.__dict__ を返します。例えば LogRecord のサブセットのみを Web サーバに送信する場合や、 サーバーに送信する内容を特別にカスタマイズする必要がある場合には、このメソッドをオーバライドできます。

emit(record)
レコードを URL エンコードされた辞書形式で Web サーバに送信します。レコードを送信のために辞書に変換するために mapLogRecord() が呼び出されます。

注釈 Web server に送信するためのレコードを準備することは一般的な書式化操作とは同じではありませんので、 setFormatter() を使って Formatter を指定することは、 HTTPHandler には効果はありません。 format() を呼び出す代わりに、このハンドラは mapLogRecord() を呼び出し、その後その返却辞書を Web server に送信するのに適した様式にエンコードするために urllib.parse.urlencode() を呼び出します。
QueueHandler
バージョン 3.2 で追加.

logging.handlers モジュールに含まれる QueueHandler クラスは、 queue モジュールや multiprocessing のモジュールで実装されるようなキューにログメッセージを送信する機能をサポートしています。

QueueListener クラスとともに QueueHandler を使うと、ロギングを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。これは、クライアントに対してサービスするスレッドができるだけ速く応答する必要がある一方、別のスレッド上で (SMTPHandler によって電子メールを送信するような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他のサービスアプリケーションにおいて重要です。

class logging.handlers.QueueHandler(queue)
Returns a new instance of the QueueHandler class. The instance is initialized with the queue to send messages to. The queue can be any queue-like object; it's used as-is by the enqueue() method, which needs to know how to send messages to it. The queue is not required to have the task tracking API, which means that you can use SimpleQueue instances for queue.

emit(record)
Enqueues the result of preparing the LogRecord. Should an exception occur (e.g. because a bounded queue has filled up), the handleError() method is called to handle the error. This can result in the record silently being dropped (if logging.raiseExceptions is False) or a message printed to sys.stderr (if logging.raiseExceptions is True).

prepare(record)
キューに追加するためレコードを準備します。このメソッドが返したオブジェクトがキューに追加されます。

メッセージと、引数と、もしあれば例外の情報を合成するためにレコードを書式化して、レコードから pickle 不可能なアイテムを in-place で取り除くベース実装です。

レコードを dict や JSON 文字列に変換したい場合や、オリジナルのレコードを変更せずに修正済のコピーを送りたい場合は、このメソッドをオーバーライドすると良いでしょう。

enqueue(record)
キューにレコードを put_nowait() を使ってエンキューします; ブロッキングやタイムアウト、あるいはなにか特別なキューの実装を使いたければ、これをオーバライドしてみてください。

QueueListener
バージョン 3.2 で追加.

logging.handlers モジュールに含まれる QueueListener クラスは、 queue モジュールや multiprocessing のモジュールで実装されるようなキューからログメッセージを受信する機能をサポートしています。メッセージは内部スレッドのキューから受信され、同じスレッド上の複数のハンドラに渡されて処理されます。 QueueListener それ自体はハンドラではありませんが、 QueueHandler と連携して動作するのでここで文書化されています。

QueueHandler クラスとともに QueueListener を使うと、ロギングを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。これは、クライアントに対してサービスするスレッドができるだけ速く応答する必要がある一方、別のスレッド上で (SMTPHandler によって電子メールを送信するような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他のサービスアプリケーションにおいて重要です。

class logging.handlers.QueueListener(queue, *handlers, respect_handler_level=False)
Returns a new instance of the QueueListener class. The instance is initialized with the queue to send messages to and a list of handlers which will handle entries placed on the queue. The queue can be any queue-like object; it's passed as-is to the dequeue() method, which needs to know how to get messages from it. The queue is not required to have the task tracking API (though it's used if available), which means that you can use SimpleQueue instances for queue.

If respect_handler_level is True, a handler's level is respected (compared with the level for the message) when deciding whether to pass messages to that handler; otherwise, the behaviour is as in previous Python versions - to always pass each message to each handler.

バージョン 3.5 で変更: The respect_handler_level argument was added.

dequeue(block)
キューからレコードを取り除き、それを返します。ブロッキングすることがあります。

ベース実装は get() を使用します。タイムアウトを有効にしたい場合や、カスタムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。

prepare(record)
レコードを扱うための準備をします。

この実装は渡されたレコードをそのまま返します。その値をハンドラに渡す前に何らかのカスタムな整列化 (marshalling) あるいはレコードに対する操作を行う必要があれば、このメソッドをオーバーライドすると良いでしょう。

handle(record)
レコードを処理します。

これは、ハンドラをループしてそれらに処理すべきレコードを渡します。ハンドラに渡される実際のオブジェクトは、 prepare() から返されたものです。

start()
リスナーを開始します。

これは、 LogRecord を処理するキューを監視するために、バックグラウンドスレッドを開始します。

stop()
リスナーを停止します。

スレッドに終了するように依頼し、終了するまで待ちます。アプリケーションの終了前にこのメソッドを呼ばないと、いくつかのレコードがキューに残り、処理されなくなるかもしれないことに注意してください。

enqueue_sentinel()
リスナーに停止するように指示するためキューに番兵を書き込みます。この実装は put_nowait() を使用します。タイムアウトを有効にしたい場合や、カスタムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。

バージョン 3.3 で追加.

参考
logging モジュール
logging モジュールの API リファレンス。

logging.config モジュール
logging モジュールの環境設定 API です。

getpass --- 可搬性のあるパスワード入力機構
ソースコード: Lib/getpass.py

getpass モジュールは二つの関数を提供します:

getpass.getpass(prompt='Password: ', stream=None)
エコーなしでユーザーにパスワードを入力させるプロンプト。ユーザーは prompt の文字列をプロンプトに使え、デフォルトは 'Password: ' です。 Unixではプロンプトはファイルに似たオブジェクト stream へ、必要なら置き換えられたエラーハンドラを使って出力されます。 stream のデフォルトは、制御端末(/dev/tty)か、それが利用できない場合は sys.stderr です (この引数は Windowsでは無視されます)。

もしエコーなしで入力が利用できない場合は、 getpass() は stream に警告メッセージを出力し、 sys.stdin から読み込み、 GetPassWarning 警告を発生させます。

注釈 IDLE から getpass を呼び出した場合、入力はIDLEのウィンドウではなく、IDLE を起動したターミナルから行われます。
exception getpass.GetPassWarning
UserWarning のサブクラスで、入力がエコーされてしまった場合に発生します。

getpass.getuser()
ユーザーの "ログイン名"を返します。

この関数は環境変数 LOGNAME USER LNAME USERNAME の順序でチェックして、最初の空ではない文字列が設定された値を返します。もし、なにも設定されていない場合は pwd モジュールが提供するシステム上のパスワードデータベースから返します。それ以外は、例外が上がります。

一般的に、この関数は os.getlogin() よりも優先されるべきです。

curses --- 文字セル表示を扱うための端末操作
curses モジュールは、可搬性のある高度な端末操作のデファクトスタンダードである、curses ライブラリへのインタフェースを提供します。

curses が最も広く用いられているのは Unix 環境ですが、Windows、DOS で利用できるバージョンもあり、おそらく他のシステムで利用できるバージョンもあります。この拡張モジュールは Linux および BSD 系の Unixで動作するオープンソースの curses ライブラリである ncurses の API に合致するように設計されています。

注釈 Whenever the documentation mentions a character it can be specified as an integer, a one-character Unicode string or a one-byte byte string.
Whenever the documentation mentions a character string it can be specified as a Unicode string or a byte string.

注釈 version 5.4 から、ncurses ライブラリは nl_langinfo 関数を利用して非 ASCII データをどう解釈するかを決定するようになりました。これは、アプリケーションは locale.setlocale() 関数を呼び出して、Unicode 文字列をシステムの利用可能なエンコーディングのどれかでエンコードする必要があることを意味します。この例では、システムのデフォルトエンコーディングを利用しています:
import locale
locale.setlocale(locale.LC_ALL, '')
code = locale.getpreferredencoding()
この後、str.encode() を呼び出すときに code を利用します。

参考
curses.ascii モジュール
ロケール設定に関わらず ASCII 文字を扱うためのユーティリティ。

curses.panel モジュール
curses ウィンドウにデプス機能を追加するパネルスタック拡張。

curses.textpad モジュール
Emacs ライクなキーバインディングをサポートする編集可能な curses 用テキストウィジェット。

Python で Curses プログラミング
Andrew Kuchling および Eric Raymond によって書かれた、curses を Python で使うためのチュートリアルです。

Python ソースコードの Tools/demo/ ディレクトリには、このモジュールで提供されている curses バインディングを使ったプログラム例がいくつか収められています。

関数
curses モジュールでは以下の例外を定義しています:

exception curses.error
curses ライブラリ関数がエラーを返した際に送出される例外です。

注釈 関数やメソッドにおけるオプションの引数 x および y がある場合、デフォルト値は常に現在のカーソルになります。オプションの attr がある場合、デフォルト値は A_NORMAL です。
curses では以下の関数を定義しています:

curses.baudrate()
端末の出力速度をビット/秒で返します。ソフトウェア端末エミュレータの場合、これは固定の高い値を持つことになります。この関数は歴史的な理由で入れられています; かつては、この関数は時間遅延を生成するための出力ループを書くために用いられたり、行速度に応じてインタフェースを切り替えたりするために用いられたりしていました。

curses.beep()
注意を促す短い音を鳴らします。

curses.can_change_color()
端末に表示される色をプログラマが変更できるか否かによって、True または False を返します。

curses.cbreak()
cbreak モードに入ります。cbreak モード ("rare" モードと呼ばれることもあります) では、通常の tty 行バッファリングはオフにされ、文字を一文字一文字読むことができます。ただし、raw モードとは異なり、特殊文字 (割り込み:interrupt、終了:quit、一時停止:suspend、およびフロー制御) については、tty ドライバおよび呼び出し側のプログラムに対する通常の効果をもっています。まず raw() を呼び出し、次いで cbreak() を呼び出すと、端末を cbreak モードにします。

curses.color_content(color_number)
Return the intensity of the red, green, and blue (RGB) components in the color color_number, which must be between 0 and COLORS - 1. Return a 3-tuple, containing the R,G,B values for the given color, which will be between 0 (no component) and 1000 (maximum amount of component).

curses.color_pair(pair_number)
Return the attribute value for displaying text in the specified color pair. Only the first 256 color pairs are supported. This attribute value can be combined with A_STANDOUT, A_REVERSE, and the other A_* attributes. pair_number() is the counterpart to this function.

curses.curs_set(visibility)
Set the cursor state. visibility can be set to 0, 1, or 2, for invisible, normal, or very visible. If the terminal supports the visibility requested, return the previous cursor state; otherwise raise an exception. On many terminals, the "visible" mode is an underline cursor and the "very visible" mode is a block cursor.

curses.def_prog_mode()
現在の端末属性を、稼動中のプログラムが curses を使う際のモードである "プログラム" モードとして保存します。(このモードの反対は、プログラムが curses を使わない "シェル" モードです。) その後 reset_prog_mode() を呼ぶとこのモードを復旧します。

curses.def_shell_mode()
現在の端末属性を、稼動中のプログラムが curses を使っていないときのモードである "シェル" モードとして保存します。(このモードの反対は、プログラムが curses 機能を利用している "プログラム" モードです。) その後 reset_shell_mode() を呼ぶとこのモードを復旧します。

curses.delay_output(ms)
出力に ms ミリ秒の一時停止を入れます。

curses.doupdate()
物理スクリーンを更新します。curses ライブラリは、現在の物理スクリーンの内容と、次の状態として要求されている仮想スクリーンをそれぞれ表す、2 つのデータ構造を保持しています。doupdate() は更新を適用し、物理スクリーンを仮想スクリーンに一致させます。

The virtual screen may be updated by a noutrefresh() call after write operations such as addstr() have been performed on a window. The normal refresh() call is simply noutrefresh() followed by doupdate(); if you have to update multiple windows, you can speed performance and perhaps reduce screen flicker by issuing noutrefresh() calls on all windows, followed by a single doupdate().

curses.echo()
echo モードに入ります。echo モードでは、各文字入力はスクリーン上に入力された通りにエコーバックされます。

curses.endwin()
ライブラリの非初期化を行い、端末を通常の状態に戻します。

curses.erasechar()
Return the user's current erase character as a one-byte bytes object. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself.

curses.filter()
The filter() routine, if used, must be called before initscr() is called. The effect is that, during those calls, LINES is set to 1; the capabilities clear, cup, cud, cud1, cuu1, cuu, vpa are disabled; and the home string is set to the value of cr. The effect is that the cursor is confined to the current line, and so are screen updates. This may be used for enabling character-at-a-time line editing without touching the rest of the screen.

curses.flash()
スクリーンを点滅します。すなわち、画面を色反転して、短時間でもとにもどします。人によっては、beep() で生成される注意音よりも、このような "目に見えるベル" を好みます。

curses.flushinp()
すべての入力バッファをフラッシュします。この関数は、ユーザによってすでに入力されているが、まだプログラムによって処理されていないすべての先行入力文字を破棄します。

curses.getmouse()
After getch() returns KEY_MOUSE to signal a mouse event, this method should be called to retrieve the queued mouse event, represented as a 5-tuple (id, x, y, z, bstate). id is an ID value used to distinguish multiple devices, and x, y, z are the event's coordinates. (z is currently unused.) bstate is an integer value whose bits will be set to indicate the type of event, and will be the bitwise OR of one or more of the following constants, where n is the button number from 1 to 4: BUTTONn_PRESSED, BUTTONn_RELEASED, BUTTONn_CLICKED, BUTTONn_DOUBLE_CLICKED, BUTTONn_TRIPLE_CLICKED, BUTTON_SHIFT, BUTTON_CTRL, BUTTON_ALT.

curses.getsyx()
Return the current coordinates of the virtual screen cursor as a tuple (y, x). If leaveok is currently True, then return (-1, -1).

curses.getwin(file)
以前の putwin() 呼び出しでファイルに保存されている、ウィンドウ関連データを読み出します。次に、このルーチンはそのデータを使って新たなウィンドウを生成し初期化して、その新規ウィンドウオブジェクトを返します。

curses.has_colors()
端末が色表示を行える場合には True を返します。そうでない場合には False を返します。

curses.has_ic()
端末が文字の挿入/削除機能を持つ場合に True を返します。最近の端末エミュレータはどれもこの機能を持っており、この関数は歴史的な理由のためだけに存在しています。

curses.has_il()
端末が行の挿入/削除機能を持つ場合に True を返します。最近の端末エミュレータはどれもこの機能を持っていて、この関数は歴史的な理由のためだけに存在しています。

curses.has_key(ch)
キー値 ch をとり、現在の端末タイプがその値のキーを認識できる場合に True を返します。

curses.halfdelay(tenths)
Used for half-delay mode, which is similar to cbreak mode in that characters typed by the user are immediately available to the program. However, after blocking for tenths tenths of seconds, raise an exception if nothing has been typed. The value of tenths must be a number between 1 and 255. Use nocbreak() to leave half-delay mode.

curses.init_color(color_number, r, g, b)
Change the definition of a color, taking the number of the color to be changed followed by three RGB values (for the amounts of red, green, and blue components). The value of color_number must be between 0 and COLORS - 1. Each of r, g, b, must be a value between 0 and 1000. When init_color() is used, all occurrences of that color on the screen immediately change to the new definition. This function is a no-op on most terminals; it is active only if can_change_color() returns True.

curses.init_pair(pair_number, fg, bg)
Change the definition of a color-pair. It takes three arguments: the number of the color-pair to be changed, the foreground color number, and the background color number. The value of pair_number must be between 1 and COLOR_PAIRS - 1 (the 0 color pair is wired to white on black and cannot be changed). The value of fg and bg arguments must be between 0 and COLORS - 1, or, after calling use_default_colors(), -1. If the color-pair was previously initialized, the screen is refreshed and all occurrences of that color-pair are changed to the new definition.

curses.initscr()
Initialize the library. Return a window object which represents the whole screen.

注釈 端末のオープン時にエラーが発生した場合、curses ライブラリによってインタープリタが終了される場合があります。
curses.is_term_resized(nlines, ncols)
resize_term() によってウィンドウ構造が変更されている場合に True を、そうでない場合は False を返します。

curses.isendwin()
endwin() がすでに呼び出されている (すなわち、curses ライブラリが非初期化されてしまっている) 場合に True を返します。

curses.keyname(k)
Return the name of the key numbered k as a bytes object. The name of a key generating printable ASCII character is the key's character. The name of a control-key combination is a two-byte bytes object consisting of a caret (b'^') followed by the corresponding printable ASCII character. The name of an alt-key combination (128--255) is a bytes object consisting of the prefix b'M-' followed by the name of the corresponding ASCII character.

curses.killchar()
Return the user's current line kill character as a one-byte bytes object. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself.

curses.longname()
Return a bytes object containing the terminfo long name field describing the current terminal. The maximum length of a verbose description is 128 characters. It is defined only after the call to initscr().

curses.meta(flag)
If flag is True, allow 8-bit characters to be input. If flag is False, allow only 7-bit chars.

curses.mouseinterval(interval)
ボタンが押されてから離されるまでの時間をマウスクリック一回として認識する最大の時間間隔をミリ秒で設定します。返り値は以前の内部設定値になります。デフォルトは 200 ミリ秒 (5 分の 1 秒) です。

curses.mousemask(mousemask)
Set the mouse events to be reported, and return a tuple (availmask, oldmask). availmask indicates which of the specified mouse events can be reported; on complete failure it returns 0. oldmask is the previous value of the given window's mouse event mask. If this function is never called, no mouse events are ever reported.

curses.napms(ms)
ms ミリ秒間スリープします。

curses.newpad(nlines, ncols)
Create and return a pointer to a new pad data structure with the given number of lines and columns. Return a pad as a window object.

A pad is like a window, except that it is not restricted by the screen size, and is not necessarily associated with a particular part of the screen. Pads can be used when a large window is needed, and only a part of the window will be on the screen at one time. Automatic refreshes of pads (such as from scrolling or echoing of input) do not occur. The refresh() and noutrefresh() methods of a pad require 6 arguments to specify the part of the pad to be displayed and the location on the screen to be used for the display. The arguments are pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol; the p arguments refer to the upper left corner of the pad region to be displayed and the s arguments define a clipping box on the screen within which the pad region is to be displayed.

curses.newwin(nlines, ncols)
curses.newwin(nlines, ncols, begin_y, begin_x)
Return a new window, whose left-upper corner is at (begin_y, begin_x), and whose height/width is nlines/ncols.

デフォルトでは、ウィンドウは指定された位置からスクリーンの右下まで広がります。

curses.nl()
newlime モードに入ります。このモードはリターンキーを入力中の改行として変換し、出力時に改行文字を復帰 (return) と改行 (line-feed) に変換します。newline モードは初期化時にはオンになっています。

curses.nocbreak()
cbreak モードを終了します。行バッファリングを行う通常の "cooked" モードに戻ります。

curses.noecho()
echo モードを終了します。入力のエコーバックはオフにされます。

curses.nonl()
newline モードを終了します。入力時のリターンキーから改行への変換、および出力時の改行から復帰/改行への低レベル変換を無効化します (ただし、addch('\n') の振る舞いは変更せず、仮想スクリーン上では常に復帰と改行に等しくなります)。変換をオフにすることで、curses は水平方向の動きを少しだけ高速化できることがあります; また、入力中のリターンキーの検出ができるようになります。

curses.noqiflush()
When the noqiflush() routine is used, normal flush of input and output queues associated with the INTR, QUIT and SUSP characters will not be done. You may want to call noqiflush() in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits.

curses.noraw()
raw モードから離れます。行バッファリングを行う通常の "cooked" モードに戻ります。

curses.pair_content(pair_number)
Return a tuple (fg, bg) containing the colors for the requested color pair. The value of pair_number must be between 0 and COLOR_PAIRS - 1.

curses.pair_number(attr)
attr に対する色ペアセットの番号を返します。color_pair() はこの関数の逆に相当します。

curses.putp(str)
tputs(str, 1, putchar) と等価です; 現在の端末における、指定された terminfo 機能の値を出力します。putp() の出力は常に標準出力に送られるので注意して下さい。

curses.qiflush([flag])
flag が False なら、noqiflush() を呼ぶのとと同じ効果です。flag が True か、引数が与えられていない場合、制御文字が読み出された最にキューはフラッシュされます。

curses.raw()
raw モードに入ります。raw モードでは、通常の行バッファリングと割り込み (interrupt)、終了 (quit)、一時停止 (suspend)、およびフロー制御キーはオフになります; 文字は curses 入力関数に一文字づつ渡されます。

curses.reset_prog_mode()
端末を "program" モードに復旧し、あらかじめ def_prog_mode() で保存した内容に戻します。

curses.reset_shell_mode()
端末を "shell" モードに復旧し、あらかじめ def_shell_mode() で保存した内容に戻します。

curses.resetty()
端末モードの状態を最後に savetty() を呼び出した時の状態に戻します。

curses.resize_term(nlines, ncols)
Backend function used by resizeterm(), performing most of the work; when resizing the windows, resize_term() blank-fills the areas that are extended. The calling application should fill in these areas with appropriate data. The resize_term() function attempts to resize all windows. However, due to the calling convention of pads, it is not possible to resize these without additional interaction with the application.

curses.resizeterm(nlines, ncols)
現在の標準ウィンドウのサイズを指定された寸法に変更し、curses ライブラリが使用する、その他のウィンドウサイズを記憶しているデータ (特に SIGWINCH ハンドラ) を調整します。

curses.savetty()
resetty() で使用される、バッファ内の端末モードの現在の状態を保存します。

curses.get_escdelay()
Retrieves the value set by set_escdelay().

バージョン 3.9 で追加.

curses.set_escdelay(ms)
Sets the number of milliseconds to wait after reading an escape character, to distinguish between an individual escape character entered on the keyboard from escape sequences sent by cursor and function keys.

バージョン 3.9 で追加.

curses.get_tabsize()
Retrieves the value set by set_tabsize().

バージョン 3.9 で追加.

curses.set_tabsize(size)
Sets the number of columns used by the curses library when converting a tab character to spaces as it adds the tab to a window.

バージョン 3.9 で追加.

curses.setsyx(y, x)
Set the virtual screen cursor to y, x. If y and x are both -1, then leaveok is set True.

curses.setupterm(term=None, fd=-1)
Initialize the terminal. term is a string giving the terminal name, or None; if omitted or None, the value of the TERM environment variable will be used. fd is the file descriptor to which any initialization sequences will be sent; if not supplied or -1, the file descriptor for sys.stdout will be used.

curses.start_color()
プログラマがカラーを利用したい場合で、かつ他の何らかのカラー操作ルーチンを呼び出す前に呼び出さなくてはなりません。この関数は initscr() を呼んだ直後に呼ぶようにしておくとよいでしょう。

start_color() は 8 つの基本色 (黒、赤、緑、黄、青、マゼンタ、シアン、および白) と、色数の最大値と端末がサポートする色ペアの最大数が入っている、curses モジュールにおける二つのグローバル変数、COLORS および COLOR_PAIRS を初期化します。この関数はまた、色設定を端末のスイッチが入れられたときの状態に戻します。

curses.termattrs()
端末がサポートするすべてのビデオ属性を論理和した値を返します。この情報は、curses プログラムがスクリーンの見え方を完全に制御する必要がある場合に便利です。

curses.termname()
Return the value of the environment variable TERM, as a bytes object, truncated to 14 characters.

curses.tigetflag(capname)
Return the value of the Boolean capability corresponding to the terminfo capability name capname as an integer. Return the value -1 if capname is not a Boolean capability, or 0 if it is canceled or absent from the terminal description.

curses.tigetnum(capname)
Return the value of the numeric capability corresponding to the terminfo capability name capname as an integer. Return the value -2 if capname is not a numeric capability, or -1 if it is canceled or absent from the terminal description.

curses.tigetstr(capname)
Return the value of the string capability corresponding to the terminfo capability name capname as a bytes object. Return None if capname is not a terminfo "string capability", or is canceled or absent from the terminal description.

curses.tparm(str[, ...])
Instantiate the bytes object str with the supplied parameters, where str should be a parameterized string obtained from the terminfo database. E.g. tparm(tigetstr("cup"), 5, 3) could result in b'\033[6;4H', the exact result depending on terminal type.

curses.typeahead(fd)
先読みチェックに使うためのファイル記述子 fd を指定します。fd が -1 の場合、先読みチェックは行われません。

curses ライブラリはスクリーンを更新する間、先読み文字列を定期的に検索することで "行はみ出し最適化 (line-breakout optimization)" を行います。入力が得られ、かつ入力は端末からのものである場合、現在行おうとしている更新は refresh や doupdate を再度呼び出すまで先送りにします。この関数は異なるファイル記述子で先読みチェックを行うように指定することができます。

curses.unctrl(ch)
Return a bytes object which is a printable representation of the character ch. Control characters are represented as a caret followed by the character, for example as b'^C'. Printing characters are left as they are.

curses.ungetch(ch)
Push ch so the next getch() will return it.

注釈 Only one ch can be pushed before getch() is called.
curses.update_lines_cols()
LINES と COLS についての更新。マニュアルでスクリーンのサイズを変更したことを検知するために有用です。

バージョン 3.5 で追加.

curses.unget_wch(ch)
Push ch so the next get_wch() will return it.

注釈 Only one ch can be pushed before get_wch() is called.
バージョン 3.3 で追加.

curses.ungetmouse(id, x, y, z, bstate)
与えられた状態データが関連付けられた KEY_MOUSE イベントを入力キューにプッシュします。

curses.use_env(flag)
この関数を使う場合、initscr() または newterm を呼ぶ前に呼び出さなくてはなりません。flag が False の場合、環境変数 LINES および COLUMNS の値 (デフォルトで使用されます) の値が設定されていたり、curses がウィンドウ内で動作して (この場合 LINES や COLUMNS が設定されていないとウィンドウのサイズを使います) いても、terminfo データベースに指定された lines および columns の値を使います。

curses.use_default_colors()
Allow use of default values for colors on terminals supporting this feature. Use this to support transparency in your application. The default color is assigned to the color number -1. After calling this function, init_pair(x, curses.COLOR_RED, -1) initializes, for instance, color pair x to a red foreground color on the default background.

curses.wrapper(func, /, *args, **kwargs)
Initialize curses and call another callable object, func, which should be the rest of your curses-using application. If the application raises an exception, this function will restore the terminal to a sane state before re-raising the exception and generating a traceback. The callable object func is then passed the main window 'stdscr' as its first argument, followed by any other arguments passed to wrapper(). Before calling func, wrapper() turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.

Window オブジェクト
上記の initscr() や newwin() が返すウィンドウは、以下のメソッドと属性を持ちます:

window.addch(ch[, attr])
window.addch(y, x, ch[, attr])
Paint character ch at (y, x) with attributes attr, overwriting any character previously painted at that location. By default, the character position and attributes are the current settings for the window object.

注釈 Writing outside the window, subwindow, or pad raises a curses.error. Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the character is printed.
window.addnstr(str, n[, attr])
window.addnstr(y, x, str, n[, attr])
Paint at most n characters of the character string str at (y, x) with attributes attr, overwriting anything previously on the display.

window.addstr(str[, attr])
window.addstr(y, x, str[, attr])
Paint the character string str at (y, x) with attributes attr, overwriting anything previously on the display.

注釈
Writing outside the window, subwindow, or pad raises curses.error. Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the string is printed.

A bug in ncurses, the backend for this Python module, can cause SegFaults when resizing windows. This is fixed in ncurses-6.1-20190511. If you are stuck with an earlier ncurses, you can avoid triggering this if you do not call addstr() with a str that has embedded newlines. Instead, call addstr() separately for each line.

window.attroff(attr)
現在のウィンドウに書き込まれたすべての内容に対し "バックグラウンド" に設定された属性 attr を除去します。

window.attron(attr)
現在のウィンドウに書き込まれたすべての内容に対し "バックグラウンド" に属性 attr を追加します。

window.attrset(attr)
Set the "background" set of attributes to attr. This set is initially 0 (no attributes).

window.bkgd(ch[, attr])
ウィンドウ上の背景プロパティを、attr を属性とする文字 ch に設定します。変更はそのウィンドウ中のすべての文字に以下のようにして適用されます:

ウィンドウ中のすべての文字の属性が新たな背景属性に変更されます。

以前の背景文字が出現すると、常に新たな背景文字に変更されます。

window.bkgdset(ch[, attr])
ウィンドウの背景を設定します。ウィンドウの背景は、文字と何らかの属性の組み合わせから成り立ちます。背景情報の属性の部分は、ウィンドウ上に描画されている空白でないすべての文字と組み合わされ (OR され) ます。空白文字には文字部分と属性部分の両方が組み合わされます。背景は文字のプロパティとなり、スクロールや行/文字の挿入/削除操作の際には文字と一緒に移動します。

window.border([ls[, rs[, ts[, bs[, tl[, tr[, bl[, br]]]]]]]])
Draw a border around the edges of the window. Each parameter specifies the character to use for a specific part of the border; see the table below for more details.

注釈 どの引数も、0 を指定した場合デフォルトの文字が使われるようになります。キーワード引数は使うことが できません。デフォルトはテーブル内で示しています:
引数

説明

デフォルト値

ls

左側

ACS_VLINE

rs

右側

ACS_VLINE

ts

上側

ACS_HLINE

bs

下側

ACS_HLINE

tl

左上の角

ACS_ULCORNER

tr

右上の角

ACS_URCORNER

bl

左下の角

ACS_LLCORNER

br

右下の角

ACS_LRCORNER

window.box([vertch, horch])
border() と同様ですが、ls および rs は共に vertch で、ts および bs は共に horch です。この関数では、角に使われるデフォルト文字が常に使用されます。

window.chgat(attr)
window.chgat(num, attr)
window.chgat(y, x, attr)
window.chgat(y, x, num, attr)
Set the attributes of num characters at the current cursor position, or at position (y, x) if supplied. If num is not given or is -1, the attribute will be set on all the characters to the end of the line. This function moves cursor to position (y, x) if supplied. The changed line will be touched using the touchline() method so that the contents will be redisplayed by the next window refresh.

window.clear()
erase() に似ていますが、次に refresh() が呼び出された際にすべてのウィンドウを再描画するようにします。

window.clearok(flag)
If flag is True, the next call to refresh() will clear the window completely.

window.clrtobot()
カーソルの位置からウィンドウの端までを消去します: カーソル以降のすべての行が削除されるため、clrtoeol() と等価です。

window.clrtoeol()
カーソル位置から行末までを消去します。

window.cursyncup()
ウィンドウのすべての親ウィンドウについて、現在のカーソル位置を反映するよう更新します。

window.delch([y, x])
(y, x) にある文字を削除します。

window.deleteln()
カーソルの下にある行を削除します。後続の行はすべて 1 行上に移動します。

window.derwin(begin_y, begin_x)
window.derwin(nlines, ncols, begin_y, begin_x)
"derive window (ウィンドウを派生する)" の短縮形です。derwin() は subwin() と同じですが、begin_y および begin_x はスクリーン全体の原点ではなく、ウィンドウの原点からの相対位置です。派生したウィンドウオブジェクトが返されます。

window.echochar(ch[, attr])
文字 ch に属性 attr を付与し、即座に refresh() をウィンドウに対して呼び出します。

window.enclose(y, x)
与えられた文字セル座標をスクリーン原点から相対的なものとし、ウィンドウの中に含まれるかを調べて、True または False を返します。スクリーン上のウィンドウの一部がマウスイベントの発生場所を含むかどうかを調べる上で便利です。

window.encoding
encode メソッドの引数 (Unicode 文字列および文字) で使用されるエンコーディングです。例えば window.subwin() などでサブウィンドウを生成した時、エンコーディング属性は親ウィンドウから継承します。デフォルトでは、そのロケールのエンコーディングが使用されます (locale.getpreferredencoding() 参照)。

バージョン 3.3 で追加.

window.erase()
ウィンドウをクリアします。

window.getbegyx()
左上の角の座標をあらわすタプル (y, x) を返します。

window.getbkgd()
与えられたウィンドウの現在の背景文字と属性のペアを返します。

window.getch([y, x])
Get a character. Note that the integer returned does not have to be in ASCII range: function keys, keypad keys and so on are represented by numbers higher than 255. In no-delay mode, return -1 if there is no input, otherwise wait until a key is pressed.

window.get_wch([y, x])
Get a wide character. Return a character for most keys, or an integer for function keys, keypad keys, and other special keys. In no-delay mode, raise an exception if there is no input.

バージョン 3.3 で追加.

window.getkey([y, x])
Get a character, returning a string instead of an integer, as getch() does. Function keys, keypad keys and other special keys return a multibyte string containing the key name. In no-delay mode, raise an exception if there is no input.

window.getmaxyx()
ウィンドウの高さおよび幅を表すタプル (y, x) を返します。

window.getparyx()
Return the beginning coordinates of this window relative to its parent window as a tuple (y, x). Return (-1, -1) if this window has no parent.

window.getstr()
window.getstr(n)
window.getstr(y, x)
window.getstr(y, x, n)
Read a bytes object from the user, with primitive line editing capacity.

window.getyx()
ウィンドウの左上角からの相対で表した現在のカーソル位置をタプル (y, x) で返します。

window.hline(ch, n)
window.hline(y, x, ch, n)
(y, x) から始まり、n の長さを持つ、文字 ch で作られる水平線を表示します。

window.idcok(flag)
flag が False の場合、curses は端末のハードウェアによる文字挿入/削除機能を使おうとしなくなります; flag が True ならば、文字挿入/削除は有効にされます。curses が最初に初期化された際には文字挿入/削除はデフォルトで有効になっています。

window.idlok(flag)
If flag is True, curses will try and use hardware line editing facilities. Otherwise, line insertion/deletion are disabled.

window.immedok(flag)
flag が True ならば、ウィンドウイメージ内における何らかの変更があるとウィンドウを更新するようになります; すなわち、refresh() を自分で呼ばなくても良くなります。とはいえ、wrefresh を繰り返し呼び出すことになるため、この操作はかなりパフォーマンスを低下させます。デフォルトでは無効になっています。

window.inch([y, x])
ウィンドウの指定の位置の文字を返します。下位 8 ビットが本来の文字で、それより上のビットは属性です。

window.insch(ch[, attr])
window.insch(y, x, ch[, attr])
(y, x) に文字 ch を属性 attr で描画し、行の x からの内容を 1 文字分右にずらします。

window.insdelln(nlines)
nlines 行を指定されたウィンドウの現在の行の上に挿入します。その下にある nlines 行は失われます。負の nlines を指定すると、カーソルのある行以降の nlines を削除し、削除された行の後ろに続く内容が上に来ます。その下にある nlines は消去されます。現在のカーソル位置はそのままです。

window.insertln()
カーソルの下に空行を 1 行入れます。それ以降の行は 1 行づつ下に移動します。

window.insnstr(str, n[, attr])
window.insnstr(y, x, str, n[, attr])
文字列をカーソルの下にある文字の前に (一行に収まるだけ) 最大 n 文字挿入します。n がゼロまたは負の値の場合、文字列全体が挿入されます。カーソルの右にあるすべての文字は右に移動し、行の左端にある文字は失われます。カーソル位置は (y, x が指定されていた場合はそこに移動しますが、その後は) 変化しません。

window.insstr(str[, attr])
window.insstr(y, x, str[, attr])
キャラクタ文字列を (行に収まるだけ) カーソルより前に挿入します。カーソルの右側にある文字はすべて右にシフトし、行の右端の文字は失われます。カーソル位置は (y, x が指定されていた場合はそこに移動しますが、その後は) 変化しません。

window.instr([n])
window.instr(y, x[, n])
Return a bytes object of characters, extracted from the window starting at the current cursor position, or at y, x if specified. Attributes are stripped from the characters. If n is specified, instr() returns a string at most n characters long (exclusive of the trailing NUL).

window.is_linetouched(line)
指定した行が、最後に refresh() を呼んだ時から変更されている場合に True を返します; そうでない場合には False を返します。line が現在のウィンドウ上の有効な行でない場合、curses.error 例外を送出します。

window.is_wintouched()
指定したウィンドウが、最後に refresh() を呼んだ時から変更されている場合に True を返します; そうでない場合には False を返します。

window.keypad(flag)
If flag is True, escape sequences generated by some keys (keypad, function keys) will be interpreted by curses. If flag is False, escape sequences will be left as is in the input stream.

window.leaveok(flag)
If flag is True, cursor is left where it is on update, instead of being at "cursor position." This reduces cursor movement where possible. If possible the cursor will be made invisible.

If flag is False, cursor will always be at "cursor position" after an update.

window.move(new_y, new_x)
カーソルを (new_y, new_x) に移動します。

window.mvderwin(y, x)
ウィンドウを親ウィンドウの中で移動します。ウィンドウのスクリーン相対となるパラメタ群は変化しません。このルーチンは親ウィンドウの一部をスクリーン上の同じ物理位置に表示する際に用いられます。

window.mvwin(new_y, new_x)
ウィンドウの左上角が (new_y, new_x) になるように移動します。

window.nodelay(flag)
If flag is True, getch() will be non-blocking.

window.notimeout(flag)
If flag is True, escape sequences will not be timed out.

If flag is False, after a few milliseconds, an escape sequence will not be interpreted, and will be left in the input stream as is.

window.noutrefresh()
更新をマークはしますが待機します。この関数はウィンドウのデータ構造を表現したい内容を反映するように更新しますが、物理スクリーン上に反映させるための強制更新を行いません。更新を行うためには doupdate() を呼び出します。

window.overlay(destwin[, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])
ウィンドウを destwin の上に重ね書き (overlay) します。ウィンドウは同じサイズである必要はなく、重なっている領域だけが複写されます。この複写は非破壊的です。これは現在の背景文字が destwin の内容を上書きしないことを意味します。

複写領域をきめ細かく制御するために、overlay() の第二形式を使うことができます。sminrow および smincol は元のウィンドウの左上の座標で、他の変数は destwin 内の矩形を表します。

window.overwrite(destwin[, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])
destwin の上にウィンドウの内容を上書き (overwrite) します。ウィンドウは同じサイズである必要はなく、重なっている領域だけが複写されます。この複写は破壊的です。これは現在の背景文字が destwin の内容を上書きすることを意味します。

複写領域をきめ細かく制御するために、overwrite() の第二形式を使うことができます。sminrow および smincol は元のウィンドウの左上の座標で、他の変数は destwin 内の矩形を表します。

window.putwin(file)
ウィンドウに関連付けられているすべてのデータを与えられたファイルオブジェクトに書き込みます。この情報は後に getwin() 関数を使って取得することができます。

window.redrawln(beg, num)
beg 行から始まる num スクリーン行の表示内容が壊れており、次の refresh() 呼び出しで完全に再描画されなければならないことを通知します。

window.redrawwin()
ウィンドウ全体を更新 (touch) し、次の refresh() 呼び出しで完全に再描画されるようにします。

window.refresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])
ディスプレイを即時更新し (実際のウィンドウとこれまでの描画/削除メソッドの内容とを同期し) ます。

6 つのオプション引数はウィンドウが newpad() で生成された場合にのみ指定することができます。追加の引数はパッドやスクリーンのどの部分が含まれるのかを示すために必要です。pminrow および pmincol にはパッドが表示されている矩形の左上角を指定します。sminrow, smincol, smaxrow, および smaxcol には、スクリーン上に表示される矩形の縁を指定します。パッド内に表示される矩形の右下角はスクリーン座標から計算されるので、矩形は同じサイズでなければなりません。矩形は両方とも、それぞれのウィンドウ構造内に完全に含まれていなければなりません。pminrow, pmincol, sminrow, または smincol に負の値を指定すると、ゼロを指定したものとして扱われます。

window.resize(nlines, ncols)
curses ウィンドウの記憶域を、指定値のサイズに調整するため再割当てします。サイズが現在の値より大きい場合、ウィンドウのデータは現在の背景設定 (bkgdset() で設定) で埋められマージされます。

window.scroll([lines=1])
スクリーンまたはスクロール領域を上に lines 行スクロールします。

window.scrollok(flag)
Control what happens when the cursor of a window is moved off the edge of the window or scrolling region, either as a result of a newline action on the bottom line, or typing the last character of the last line. If flag is False, the cursor is left on the bottom line. If flag is True, the window is scrolled up one line. Note that in order to get the physical scrolling effect on the terminal, it is also necessary to call idlok().

window.setscrreg(top, bottom)
スクロール領域を top から bottom に設定します。スクロール動作はすべてこの領域で行われます。

window.standend()
A_STANDOUT 属性をオフにします。端末によっては、この操作ですべての属性をオフにする副作用が発生します。

window.standout()
A_STANDOUT 属性をオンにします。

window.subpad(begin_y, begin_x)
window.subpad(nlines, ncols, begin_y, begin_x)
左上の角が (begin_y, begin_x) にあり、幅/高さがそれぞれ ncols / nlines であるようなサブウィンドウを返します。

window.subwin(begin_y, begin_x)
window.subwin(nlines, ncols, begin_y, begin_x)
左上の角が (begin_y, begin_x) にあり、幅/高さがそれぞれ ncols / nlines であるようなサブウィンドウを返します。

デフォルトでは、サブウィンドウは指定された場所からウィンドウの右下角まで広がります。

window.syncdown()
このウィンドウの上位のウィンドウのいずれかで更新(touch)された各場所をこのウィンドウ内でも更新します。このルーチンは refresh() から呼び出されるので、手動で呼び出す必要はほとんどないはずです。

window.syncok(flag)
If flag is True, then syncup() is called automatically whenever there is a change in the window.

window.syncup()
ウィンドウ内で更新 (touch) した場所を、上位のすべてのウィンドウ内でも更新します。

window.timeout(delay)
Set blocking or non-blocking read behavior for the window. If delay is negative, blocking read is used (which will wait indefinitely for input). If delay is zero, then non-blocking read is used, and getch() will return -1 if no input is waiting. If delay is positive, then getch() will block for delay milliseconds, and return -1 if there is still no input at the end of that time.

window.touchline(start, count[, changed])
Pretend count lines have been changed, starting with line start. If changed is supplied, it specifies whether the affected lines are marked as having been changed (changed=True) or unchanged (changed=False).

window.touchwin()
描画を最適化するために、すべてのウィンドウが変更されたかのように振舞わせます。

window.untouchwin()
ウィンドウ内のすべての行を、最後に refresh() を呼んだ際から変更されていないものとしてマークします。

window.vline(ch, n)
window.vline(y, x, ch, n)
(y, x) から始まり、n の長さを持つ、文字 ch で作られる垂直線を表示します。

定数
curses モジュールでは以下のデータメンバを定義しています:

curses.ERR
Some curses routines that return an integer, such as getch(), return ERR upon failure.

curses.OK
napms() のような整数を返す curses ルーチンのいくつかは、成功した際に OK を返します。

curses.version
A bytes object representing the current version of the module. Also available as __version__.

curses.ncurses_version
A named tuple containing the three components of the ncurses library version: major, minor, and patch. All values are integers. The components can also be accessed by name, so curses.ncurses_version[0] is equivalent to curses.ncurses_version.major and so on.

Availability: if the ncurses library is used.

バージョン 3.8 で追加.

Some constants are available to specify character cell attributes. The exact constants available are system dependent.

属性

意味

A_ALTCHARSET

Alternate character set mode

A_BLINK

Blink mode

A_BOLD

Bold mode

A_DIM

Dim mode

A_INVIS

Invisible or blank mode

A_ITALIC

Italic mode

A_NORMAL

Normal attribute

A_PROTECT

Protected mode

A_REVERSE

Reverse background and foreground colors

A_STANDOUT

Standout mode

A_UNDERLINE

Underline mode

A_HORIZONTAL

Horizontal highlight

A_LEFT

Left highlight

A_LOW

Low highlight

A_RIGHT

Right highlight

A_TOP

Top highlight

A_VERTICAL

Vertical highlight

A_CHARTEXT

Bit-mask to extract a character

バージョン 3.7 で追加: A_ITALIC was added.

Several constants are available to extract corresponding attributes returned by some methods.

Bit-mask

意味

A_ATTRIBUTES

Bit-mask to extract attributes

A_CHARTEXT

Bit-mask to extract a character

A_COLOR

Bit-mask to extract color-pair field information

キーは KEY_ で始まる名前をもつ整数定数です。利用可能なキーキャップはシステムに依存します。

キー定数

キー

KEY_MIN

最小のキー値

KEY_BREAK

ブレークキー (Break, 信頼できません)

KEY_DOWN

下矢印

KEY_UP

上矢印

KEY_LEFT

左矢印

KEY_RIGHT

右矢印

KEY_HOME

ホームキー (Home, または上左矢印)

KEY_BACKSPACE

バックスペース (Backspace, 信頼できません)

KEY_F0

ファンクションキー。64 個までサポートされています。

KEY_Fn

ファンクションキー n の値

KEY_DL

行削除 (Delete line)

KEY_IL

行挿入 (Insert line)

KEY_DC

文字削除 (Delete char)

KEY_IC

文字挿入、または文字挿入モードへ入る

KEY_EIC

文字挿入モードから抜ける

KEY_CLEAR

画面消去

KEY_EOS

画面の末端まで消去

KEY_EOL

行末端まで消去

KEY_SF

前に 1 行スクロール

KEY_SR

後ろ (逆方向) に 1 行スクロール

KEY_NPAGE

次のページ (Page Next)

KEY_PPAGE

前のページ (Page Prev)

KEY_STAB

タブ設定

KEY_CTAB

タブリセット

KEY_CATAB

すべてのタブをリセット

KEY_ENTER

入力または送信 (信頼できません)

KEY_SRESET

ソフトウェア (部分的) リセット (信頼できません)

KEY_RESET

リセットまたはハードリセット (信頼できません)

KEY_PRINT

印刷 (Print)

KEY_LL

下ホーム (Home down) または最下行 (左下)

KEY_A1

キーパッドの左上キー

KEY_A3

キーパッドの右上キー

KEY_B2

キーパッドの中央キー

KEY_C1

キーパッドの左下キー

KEY_C3

キーパッドの右下キー

KEY_BTAB

Back tab

KEY_BEG

開始 (Beg)

KEY_CANCEL

キャンセル (Cancel)

KEY_CLOSE

Close [閉じる]

KEY_COMMAND

コマンド (Cmd)

KEY_COPY

Copy [コピー]

KEY_CREATE

生成 (Create)

KEY_END

終了 (End)

KEY_EXIT

Exit [終了]

KEY_FIND

検索 (Find)

KEY_HELP

ヘルプ (Help)

KEY_MARK

マーク (Mark)

KEY_MESSAGE

メッセージ (Message)

KEY_MOVE

移動 (Move)

KEY_NEXT

次へ (Next)

KEY_OPEN

開く (Open)

KEY_OPTIONS

オプション

KEY_PREVIOUS

前へ (Prev)

KEY_REDO

Redo [やり直し]

KEY_REFERENCE

参照 (Ref)

KEY_REFRESH

更新 (Refresh)

KEY_REPLACE

置換 (Replace)

KEY_RESTART

再起動 (Restart)

KEY_RESUME

再開 (Resume)

KEY_SAVE

Save [保存]

KEY_SBEG

シフト付き Beg

KEY_SCANCEL

シフト付き Cancel

KEY_SCOMMAND

シフト付き Command

KEY_SCOPY

シフト付き Copy

KEY_SCREATE

シフト付き Create

KEY_SDC

シフト付き Delete char

KEY_SDL

シフト付き Delete line

KEY_SELECT

選択 (Select)

KEY_SEND

シフト付き End

KEY_SEOL

シフト付き Clear line

KEY_SEXIT

シフト付き Exit

KEY_SFIND

シフト付き Find

KEY_SHELP

シフト付き Help

KEY_SHOME

シフト付き Home

KEY_SIC

シフト付き Input

KEY_SLEFT

シフト付き Left arrow

KEY_SMESSAGE

シフト付き Message

KEY_SMOVE

シフト付き Move

KEY_SNEXT

シフト付き Next

KEY_SOPTIONS

シフト付き Options

KEY_SPREVIOUS

シフト付き Prev

KEY_SPRINT

シフト付き Print

KEY_SREDO

シフト付き Redo

KEY_SREPLACE

シフト付き Replace

KEY_SRIGHT

シフト付き Right arrow

KEY_SRSUME

シフト付き Resume

KEY_SSAVE

シフト付き Save

KEY_SSUSPEND

シフト付き Suspend

KEY_SUNDO

シフト付き Undo

KEY_SUSPEND

一時停止 (Suspend)

KEY_UNDO

Undo [元に戻す]

KEY_MOUSE

マウスイベント通知

KEY_RESIZE

端末リサイズイベント

KEY_MAX

最大キー値

VT100 や、X 端末エミュレータのようなソフトウェアエミュレーションでは、通常少なくとも 4 つのファンクションキー (KEY_F1, KEY_F2, KEY_F3, KEY_F4) が利用可能で、矢印キーは KEY_UP, KEY_DOWN, KEY_LEFT および KEY_RIGHT が対応付けられています。計算機に PC キーボードが付属している場合、矢印キーと 12 個のファンクションキー (古い PC キーボードには 10 個しかファンクションキーがないかもしれません) が利用できると考えてよいでしょう; また、以下のキーパッド対応付けは標準的なものです:

キーキャップ

定数

Insert

KEY_IC

Delete

KEY_DC

Home

KEY_HOME

End

KEY_END

Page Up

KEY_PPAGE

Page Down

KEY_NPAGE

代替文字セットを以下の表に列挙します。これらは VT100 端末から継承したものであり、X 端末のようなソフトウェアエミュレーション上で一般に利用可能なものです。グラフィックが利用できない場合、curses は印字可能 ASCII文字による粗雑な近似出力を行います。

注釈 これらは initscr() が呼び出された後でしか利用できません。
ACS コード

意味

ACS_BBSS

右上角の別名

ACS_BLOCK

黒四角ブロック

ACS_BOARD

白四角ブロック

ACS_BSBS

水平線の別名

ACS_BSSB

左上角の別名

ACS_BSSS

上向き T 字罫線の別名

ACS_BTEE

下向き T 字罫線

ACS_BULLET

黒丸(bullet)

ACS_CKBOARD

チェッカーボードパタン (点描)

ACS_DARROW

下向き矢印

ACS_DEGREE

度記号

ACS_DIAMOND

ダイアモンド

ACS_GEQUAL

大なりイコール

ACS_HLINE

水平線

ACS_LANTERN

ランタン(lantern) シンボル

ACS_LARROW

左向き矢印

ACS_LEQUAL

小なりイコール

ACS_LLCORNER

左下角

ACS_LRCORNER

右下角

ACS_LTEE

左向き T 字罫線

ACS_NEQUAL

不等号

ACS_PI

パイ記号

ACS_PLMINUS

プラスマイナス記号

ACS_PLUS

大プラス記号

ACS_RARROW

右向き矢印

ACS_RTEE

右向き T 字罫線

ACS_S1

スキャンライン 1

ACS_S3

スキャンライン 3

ACS_S7

スキャンライン 7

ACS_S9

スキャンライン 9

ACS_SBBS

右下角の別名

ACS_SBSB

垂直線の別名

ACS_SBSS

右向き T 字罫線の別名

ACS_SSBB

左下角の別名

ACS_SSBS

下向き T 字罫線の別名

ACS_SSSB

左向き T 字罫線の別名

ACS_SSSS

交差罫線または大プラス記号の別名

ACS_STERLING

ポンドスターリング記号

ACS_TTEE

上向き T 字罫線

ACS_UARROW

上向き矢印

ACS_ULCORNER

左上角

ACS_URCORNER

右上角

ACS_VLINE

垂直線

以下のテーブルは定義済みの色を列挙したものです:

定数

色

COLOR_BLACK

黒

COLOR_BLUE

青

COLOR_CYAN

シアン (薄く緑がかった青)

COLOR_GREEN

緑

COLOR_MAGENTA

マゼンタ (紫がかった赤)

COLOR_RED

赤

COLOR_WHITE

白

COLOR_YELLOW

黄色

curses.textpad --- curses プログラムのためのテキスト入力ウィジェット
curses.textpad モジュールでは、curses ウィンドウ内での基本的なテキスト編集を処理し、Emacs に似た (すなわち Netscape Navigator, BBedit 6.x, FrameMaker, その他諸々のプログラムとも似た) キーバインドをサポートしている Textbox クラスを提供します。このモジュールではまた、テキストボックスを枠で囲むなどの目的のために有用な、矩形描画関数を提供しています。

curses.textpad モジュールでは以下の関数を定義しています:

curses.textpad.rectangle(win, uly, ulx, lry, lrx)
矩形を描画します。最初の引数はウィンドウオブジェクトでなければなりません; 残りの引数はそのウィンドウからの相対座標になります。2 番目および 3 番目の引数は描画すべき矩形の左上角の y および x 座標です; 4 番目および 5 番目の引数は右下角の y および x 座標です。矩形は、VT100/IBM PC におけるフォーム文字を利用できる端末 (xterm やその他のほとんどのソフトウェア端末エミュレータを含む) ではそれを使って描画されます。そうでなければ ASCII 文字のダッシュ、垂直バー、およびプラス記号で描画されます。

Textbox オブジェクト
以下のような Textbox オブジェクトをインスタンス生成することができます:

class curses.textpad.Textbox(win)
Return a textbox widget object. The win argument should be a curses window object in which the textbox is to be contained. The edit cursor of the textbox is initially located at the upper left hand corner of the containing window, with coordinates (0, 0). The instance's stripspaces flag is initially on.

Textbox オブジェクトは以下のメソッドを持ちます:

edit([validator])
普段使うことになるエントリポイントです。終了キーストロークの一つが入力されるまで編集キーストロークを受け付けます。validator を与える場合、関数でなければなりません。validator はキーストロークが入力されるたびにそのキーストロークが引数となって呼び出されます; 返された値に対して、コマンドキーストロークとして解釈が行われます。このメソッドはウィンドウの内容を文字列として返します; ウィンドウ内の空白が含められるかどうかは stripspaces 属性で決められます。

do_command(ch)
単一のコマンドキーストロークを処理します。以下にサポートされている特殊キーストロークを示します:

キーストローク

動作

Control-A

ウィンドウの左端に移動します。

Control-B

カーソルを左へ移動し、必要なら前の行に折り返します。

Control-D

カーソル下の文字を削除します。

Control-E

右端 (stripspaces がオフのとき) または行末 (stripspaces がオンのとき) に移動します。

Control-F

カーソルを右に移動し、必要なら次の行に折り返します。

Control-G

ウィンドウを終了し、その内容を返します。

Control-H

逆方向に文字を削除します。

Control-J

ウィンドウが 1 行であれば終了し、そうでなければ新しい行を挿入します。

Control-K

行が空白行ならその行全体を削除し、そうでなければカーソル以降行末までを消去します。

Control-L

スクリーンを更新します。

Control-N

カーソルを下に移動します; 1 行下に移動します。

Control-O

カーソルの場所に空行を 1 行挿入します。

Control-P

カーソルを上に移動します; 1 行上に移動します。

移動操作は、カーソルがウィンドウの縁にあって移動ができない場合には何も行いません。場合によっては、以下のような同義のキーストロークがサポートされています:

定数

キーストローク

KEY_LEFT

Control-B

KEY_RIGHT

Control-F

KEY_UP

Control-P

KEY_DOWN

Control-N

KEY_BACKSPACE

Control-h

他のキーストロークは、与えられた文字を挿入し、(行折り返し付きで) 右に移動するコマンドとして扱われます。

gather()
ウィンドウの内容を文字列として返します; ウィンドウ内の空白が含められるかどうかは stripspaces メンバ変数で決められます。

stripspaces
この属性はウィンドウ内の空白領域の解釈方法を制御するためのフラグです。フラグがオンに設定されている場合、各行の末端にある空白領域は無視されます; すなわち、末端空白領域にカーソルが入ると、その場所の代わりに行の末尾にカーソルが移動します。また、末端の空白領域はウィンドウの内容を取得する際に剥ぎ取られます。

curses.ascii --- ASCII 文字に関するユーティリティ
curses.ascii モジュールでは、 ASCII 文字を指す名前定数と、様々な ASCII 文字区分についてある文字が帰属するかどうかを調べる関数を提供します。このモジュールで提供されている定数は以下の制御文字の名前です:

名前

意味

NUL

SOH

ヘディング開始、コンソール割り込み

STX

テキスト開始

ETX

テキスト終了

EOT

テキスト伝送終了

ENQ

問い合わせ、 ACK フロー制御時に使用

ACK

肯定応答

BEL

ベル

BS

一文字後退

TAB

タブ

HT

TAB の別名: "水平タブ"

LF

改行

NL

LF の別名: "改行"

VT

垂直タブ

FF

改頁

CR

復帰

SO

シフトアウト、他の文字セットの開始

SI

シフトイン、標準の文字セットに復帰

DLE

データリンクでのエスケープ

DC1

装置制御 1、フロー制御のための XON

DC2

装置制御 2、ブロックモードフロー制御

DC3

装置制御 3、フロー制御のための XOFF

DC4

装置制御 4

NAK

否定応答

SYN

同期信号

ETB

ブロック転送終了

CAN

キャンセル (Cancel)

EM

媒体終端

SUB

代入文字

ESC

エスケープ文字

FS

ファイル区切り文字

GS

グループ区切り文字

RS

レコード区切り文字、ブロックモード終了子

US

単位区切り文字

SP

空白文字

DEL

削除

これらの大部分は、最近は実際に定数の意味通りに使われることがほとんどないので注意してください。これらのニーモニック符号はデジタル計算機より前のテレプリンタにおける慣習から付けられたものです。

このモジュールでは、標準 C ライブラリの関数を雛型とする以下の関数をサポートしています:

curses.ascii.isalnum(c)
ASCII 英数文字かどうかを調べます; isalpha(c) or isdigit(c) と等価です。

curses.ascii.isalpha(c)
ASCII アルファベット文字かどうかを調べます; isupper(c) or islower(c) と等価です。

curses.ascii.isascii(c)
文字が 7 ビット ASCII 文字に合致するかどうかを調べます。

curses.ascii.isblank(c)
ASCII 余白文字、すなわち空白または水平タブかどうかを調べます。

curses.ascii.iscntrl(c)
ASCII 制御文字 (0x00 から 0x1f の範囲または 0x7f) かどうかを調べます。

curses.ascii.isdigit(c)
ASCII 10 進数字、すなわち '0' から '9' までの文字かどうかを調べます。c in string.digits と等価です。

curses.ascii.isgraph(c)
空白以外の ASCII 印字可能文字かどうかを調べます。

curses.ascii.islower(c)
ASCII 小文字かどうかを調べます。

curses.ascii.isprint(c)
空白文字を含め、ASCII 印字可能文字かどうかを調べます。

curses.ascii.ispunct(c)
空白または英数字以外の ASCII 印字可能文字かどうかを調べます。

curses.ascii.isspace(c)
ASCII 余白文字、すなわち空白、改行、復帰、改頁、水平タブ、垂直タブかどうかを調べます。

curses.ascii.isupper(c)
ASCII 大文字かどうかを調べます。

curses.ascii.isxdigit(c)
ASCII 16 進数字かどうかを調べます。c in string.hexdigits と等価です。

curses.ascii.isctrl(c)
ASCII 制御文字 (0 から 31 までの値) かどうかを調べます。

curses.ascii.ismeta(c)
非 ASCII 文字 (0x80 またはそれ以上の値) かどうかを調べます。

これらの関数は数字も 1 文字の文字列も使えます; 引数を文字列にした場合、組み込み関数 ord() を使って変換されます。

これらの関数は全て、関数に渡した文字列の文字から得られたビット値を調べるので注意してください; 関数はホスト計算機で使われている文字列エンコーディングについて何ら関知しません。

以下の 2 つの関数は、引数として 1 文字の文字列または整数で表したバイト値のどちらでもとり得ます; これらの関数は引数と同じ型で値を返します。

curses.ascii.ascii(c)
ASCII 値を返します。c の下位 7 ビットに対応します。

curses.ascii.ctrl(c)
与えた文字に対応する制御文字を返します (0x1f とビット単位で論理積を取ります)。

curses.ascii.alt(c)
与えた文字に対応する 8 ビット文字を返します (0x80 とビット単位で論理和を取ります)。

以下の関数は 1 文字からなる文字列値または整数値を引数に取り、文字列を返します。

curses.ascii.unctrl(c)
ASCII 文字 c の文字列表現を返します。 もし c が印字可能文字であれば、返される文字列は c そのものになります。 もし c が制御文字 (0x00--0x1f) であれば、キャレット ('^') と、その後ろに続く c に対応した大文字からなる文字列になります。 c が ASCII 削除文字 (0x7f) であれば、文字列は '^?' になります。 c のメタビット (0x80) がセットされていれば、メタビットは取り去られ、前述のルールが適用され、'!' が前につけられます。

curses.ascii.controlnames
0 (NUL) から 0x1f (US) までの 32 の ASCII 制御文字と、空白文字 SP のニーモニック符号名からなる 33 要素の文字列によるシーケンスです。

curses.panel --- curses のためのパネルスタック拡張
パネルは深さ (depth) の機能が追加されたウィンドウです。これにより、ウィンドウをお互いに重ね合わせることができ、各ウィンドウの可視部分だけが表示されます。パネルはスタック中に追加したり、スタック内で上下移動させたり、スタックから除去することができます。

関数
curses.panel では以下の関数を定義しています:

curses.panel.bottom_panel()
パネルスタックの最下層のパネルを返します。

curses.panel.new_panel(win)
与えられたウィンドウ win に関連付けられたパネルオブジェクトを返します。返されたパネルオブジェクトを参照しておく必要があることに注意してください。もし参照しなければ、パネルオブジェクトはガベージコレクションされてパネルスタックから削除されます。

curses.panel.top_panel()
パネルスタックの最上層のパネルを返します。

curses.panel.update_panels()
仮想スクリーンをパネルスタック変更後の状態に更新します。この関数では curses.doupdate() を呼ばないので、ユーザは自分で呼び出す必要があります。

Panel オブジェクト
上記の new_panel() が返す Panel オブジェクトはスタック順の概念を持つウィンドウです。ウィンドウはパネルに関連付けられており、表示する内容を決定している一方、パネルのメソッドはパネルスタック中のウィンドウの深さ管理を担います。

Panel オブジェクトは以下のメソッドを持っています:

Panel.above()
現在のパネルの上にあるパネルを返します。

Panel.below()
現在のパネルの下にあるパネルを返します。

Panel.bottom()
パネルをスタックの最下層にプッシュします。

Panel.hidden()
パネルが隠れている (不可視である) 場合に True を返し、そうでない場合 False を返します。

Panel.hide()
パネルを隠します。この操作ではオブジェクトは消去されず、スクリーン上のウィンドウを不可視にするだけです。

Panel.move(y, x)
パネルをスクリーン座標 (y, x) に移動します。

Panel.replace(win)
パネルに関連付けられたウィンドウを win に変更します。

Panel.set_userptr(obj)
パネルのユーザポインタを obj に設定します。このメソッドは任意のデータをパネルに関連付けるために使われ、任意の Python オブジェクトにすることができます。

Panel.show()
(隠れているはずの) パネルを表示します。

Panel.top()
パネルをスタックの最上層にプッシュします。

Panel.userptr()
パネルのユーザポインタを返します。任意の Python オブジェクトです。

Panel.window()
パネルに関連付けられているウィンドウオブジェクトを返します。

platform --- 実行中プラットフォームの固有情報を参照する
ソースコード: Lib/platform.py

注釈 プラットフォーム毎にアルファベット順に並べています。Linuxについては Unixセクションを参照してください。
クロスプラットフォーム
platform.architecture(executable=sys.executable, bits='', linkage='')
executable で指定した実行可能ファイル（省略時はPythonインタープリタのバイナリ）の各種アーキテクチャ情報を調べます。

戻り値はタプル (bits, linkage) で、アーキテクチャのビット数と実行可能ファイルのリンク形式を示します。どちらの値も文字列で返ります。

値を決定できない場合はパラメータプリセットから与えられる値を返します。bits に '' を与えた場合、サポートされているポインタサイズを知るために sizeof(pointer) (Python バージョン < 1.5.2 では sizeof(long)) が使用されます。

この関数は、システムの file コマンドを使用します。 file はほとんどのUnixプラットフォームと一部の非Unixプラットフォームで利用可能ですが、 file コマンドが利用できず、かつ executable が Pythonインタープリタでない場合には適切なデフォルト値が返ります。

注釈 Mac OS X (とひょっとすると他のプラットフォーム) では、実行可能ファイルは複数のアーキテクチャを含んだユニバーサル形式かもしれません。
現在のインタプリタが "64-bit" であるかどうかを調べるには、 sys.maxsize の方が信頼できます:

is_64bits = sys.maxsize > 2**32
platform.machine()
'i386' のような、機種を返します。不明な場合は空文字列を返します。

platform.node()
コンピュータのネットワーク名を返します。ネットワーク名は完全修飾名とは限りません。不明な場合は空文字列を返します。

platform.platform(aliased=0, terse=0)
実行中プラットフォームを識別する文字列を返します。この文字列には、有益な情報をできるだけ多く付加しています。

戻り値は機械で処理しやすい形式ではなく、人間にとって読みやすい 形式となっています。異なったプラットフォームでは異なった戻り値となるようになっています。

aliased が真なら、システムの名称として一般的な名称ではなく、別名を使用して結果を返します。たとえば、SunOS は Solaris となります。この機能は system_alias() で実装されています。

terse が真なら、プラットフォームを特定するために最低限必要な情報だけを返します。

バージョン 3.8 で変更: macOSでは、 mac_ver() が空でないリリース文字列を返すとき、darwin のバージョンではなく macOS のバージョンを取得するために、この関数は mac_ver() を使うようになりました。

platform.processor()
'amdk6' のような、（現実の）プロセッサ名を返します。

不明な場合は空文字列を返します。NetBSDのようにこの情報を提供しない、または machine() と同じ値しか返さないプラットフォームも多く存在しますので、注意してください。

platform.python_build()
Pythonのビルド番号と日付を、(buildno, builddate) のタプルで返します。

platform.python_compiler()
Pythonをコンパイルする際に使用したコンパイラを示す文字列を返します。

platform.python_branch()
Python実装のバージョン管理システム上のブランチを特定する文字列を返します。

platform.python_implementation()
Python実装を指定する文字列を返します。戻り値は: 'CPython', 'IronPython', 'Jython', 'PyPy' のいずれかです。

platform.python_revision()
Python実装のバージョン管理システム上のリビジョンを特定する文字列を返します。

platform.python_version()
Python のバージョンを、'major.minor.patchlevel' 形式の文字列で返します。

sys.version と異なり、patchlevel（デフォルトでは0)も必ず含まれています。

platform.python_version_tuple()
Pythonのバージョンを、文字列のタプル (major, minor, patchlevel) で返します。

sys.version と異なり、patchlevel（デフォルトでは '0')も必ず含まれています。

platform.release()
'2.2.0' や 'NT' のような、システムのリリース情報を返します。不明な場合は空文字列を返します。

platform.system()
'Linux' 、 'Darwin' 、 'Java' 、 'Windows' のような、システム/OS 名を返します。不明な場合は空文字列を返します。

platform.system_alias(system, release, version)
マーケティング目的で使われる一般的な別名に変換して (system, release, version) を返します。混乱を避けるために、情報を並べなおす場合があります。

platform.version()
'#3 on degas' のような、システムのリリース情報を返します。不明な場合は空文字列を返します。

platform.uname()
極めて可搬性の高い uname インタフェースです。 system, node, release, version, machine, processor の6つの属性を持った namedtuple() を返します。

この関数が os.uname() の結果には含まれない 6番目の属性 (processor) を追加することに注意してください。さらに、最初の2つの属性については属性名が異なります; os.uname() はそれらを sysname と nodename と命名します。

不明な項目は '' となります。

バージョン 3.3 で変更: 結果が tuple から namedtuple に変更されました。

Java プラットフォーム
platform.java_ver(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))
Jython用のバージョンインターフェースです。

タプル (release, vendor, vminfo, osinfo) を返します。vminfo はタプル (vm_name, vm_release, vm_vendor)、osinfo はタプル (os_name, os_version, os_arch) です。不明な項目は引数で指定した値(デフォルトは '') となります。

Windows プラットフォーム
platform.win32_ver(release='', version='', csd='', ptype='')
Windows レジストリから追加のバージョン情報を取得して、タプル (release, version, csd, ptype) を返します。それぞれ、OS リリース、バージョン番号、CSD レベル (サービスパック)、OS タイプ (マルチ/シングルプロセッサー) を指しています。

参考: ptype はシングルプロセッサのNT上では 'Uniprocessor Free'、マルチプロセッサでは 'Multiprocessor Free' となります。'Free' がついている場合はデバッグ用のコードが含まれていないことを示し、'Checked' がついていれば引数や範囲のチェックなどのデバッグ用コードが含まれていることを示します。

platform.win32_edition()
現在の Windows のエディションの文字列表現を返します。取りうる返り値には 'Enterprise' 、 'IoTUAP' 、 'ServerStandard' 、 'nanoserver' がありますが、これらに限定されません。

バージョン 3.8 で追加.

platform.win32_is_iot()
win32_edition() によって返された Windows のエディションが IoT エディションの時 True を返します。

バージョン 3.8 で追加.

Mac OS プラットフォーム
platform.mac_ver(release='', versioninfo=('', '', ''), machine='')
Mac OSのバージョン情報を、タプル (release, versioninfo, machine) で返します。versioninfo は、タプル (version, dev_stage, non_release_version) です。

不明な項目は '' となります。タプルの要素は全て文字列です。

Unix プラットフォーム
platform.libc_ver(executable=sys.executable, lib='', version='', chunksize=16384)
executableで指定したファイル（省略時はPythonインタープリタ）がリンクしているlibcバージョンの取得を試みます。戻り値は文字列のタプル (lib, version) で、不明な項目は引数で指定した値となります。

この関数は、実行形式に追加されるシンボルの細かな違いによって、libcのバージョンを特定します。この違いは gcc でコンパイルされた実行可能ファイルでのみ有効だと思われます。

chunksize にはファイルから情報を取得するために読み込むバイト数を指定します。

errno --- 標準の errno システムシンボル
このモジュールから標準の errno システムシンボルを取得することができます。個々のシンボルの値は errno に対応する整数値です。これらのシンボルの名前は、 linux/include/errno.h から借用されており、かなり網羅的なはずです。

errno.errorcode
errno 値を背後のシステムにおける文字列表現に対応付ける辞書です。例えば、errno.errorcode[errno.EPERM] は 'EPERM' に対応付けられます。

数値のエラーコードをエラーメッセージに変換するには、 os.strerror() を使ってください。

以下のリストの内、現在のプラットフォームで使われていないシンボルはモジュール上で定義されていません。定義されているシンボルだけを挙げたリストは errno.errorcode.keys() として取得することができます。取得できるシンボルには以下のようなものがあります:

errno.EPERM
許可されていない操作です (Operation not permitted)

errno.ENOENT
そのようなファイルまたはディレクトリは存在しません (No such file or directory)

errno.ESRCH
指定したプロセスは存在しません (No such process)

errno.EINTR
システムコールが中断されました (Interrupted system call)

参考 このエラーは例外 InterruptedError にマップされます。
errno.EIO
I/O エラーです (I/O error)

errno.ENXIO
そのようなデバイスまたはアドレスは存在しません (No such device or address)

errno.E2BIG
引数リストが長すぎます (Arg list too long)

errno.ENOEXEC
実行形式にエラーがあります (Exec format error)

errno.EBADF
ファイル番号が間違っています (Bad file number)

errno.ECHILD
子プロセスがありません (No child processes)

errno.EAGAIN
再試行してください (Try again)

errno.ENOMEM
空きメモリがありません (Out of memory)

errno.EACCES
許可がありません (Permission denied)

errno.EFAULT
不正なアドレスです (Bad address)

errno.ENOTBLK
ブロックデバイスが必要です (Block device required)

errno.EBUSY
そのデバイスまたはリソースは使用中です (Device or resource busy)

errno.EEXIST
ファイルがすでに存在します (File exists)

errno.EXDEV
デバイスをまたいだリンクです (Cross-device link)

errno.ENODEV
そのようなデバイスはありません (No such device)

errno.ENOTDIR
ディレクトリではありません (Not a directory)

errno.EISDIR
ディレクトリです (Is a directory)

errno.EINVAL
無効な引数です (Invalid argument)

errno.ENFILE
ファイルテーブルがオーバフローしています (File table overflow)

errno.EMFILE
開かれたファイルが多すぎます (Too many open files)

errno.ENOTTY
タイプライタではありません (Not a typewriter)

errno.ETXTBSY
テキストファイルが使用中です (Text file busy)

errno.EFBIG
ファイルが大きすぎます (File too large)

errno.ENOSPC
デバイス上に空きがありません (No space left on device)

errno.ESPIPE
不正なシークです (Illegal seek)

errno.EROFS
リードオンリーのファイルシステムです (Read-only file system)

errno.EMLINK
リンクが多すぎます (Too many links)

errno.EPIPE
壊れたパイプです (Broken pipe)

errno.EDOM
数学引数が関数の定義域を越えています (Math argument out of domain of func)

errno.ERANGE
表現できない数学演算結果になりました (Math result not representable)

errno.EDEADLK
リソースのデッドロックが起きます (Resource deadlock would occur)

errno.ENAMETOOLONG
ファイル名が長すぎます (File name too long)

errno.ENOLCK
レコードロッキングが利用できません (No record locks available)

errno.ENOSYS
実装されていない機能です (Function not implemented)

errno.ENOTEMPTY
ディレクトリが空ではありません (Directory not empty)

errno.ELOOP
これ以上シンボリックリンクを追跡できません (Too many symbolic links encountered)

errno.EWOULDBLOCK
操作がブロックします (Operation would block)

errno.ENOMSG
指定された型のメッセージはありません (No message of desired type)

errno.EIDRM
識別子が除去されました (Identifier removed)

errno.ECHRNG
チャネル番号が範囲を超えました (Channel number out of range)

errno.EL2NSYNC
レベル 2 で同期がとれていません (Level 2 not synchronized)

errno.EL3HLT
レベル 3 で終了しました (Level 3 halted)

errno.EL3RST
レベル 3 でリセットしました (Level 3 reset)

errno.ELNRNG
リンク番号が範囲を超えています (Link number out of range)

errno.EUNATCH
プロトコルドライバが接続されていません (Protocol driver not attached)

errno.ENOCSI
CSI 構造体がありません (No CSI structure available)

errno.EL2HLT
レベル 2 で終了しました (Level 2 halted)

errno.EBADE
無効な変換です (Invalid exchange)

errno.EBADR
無効な要求記述子です (Invalid request descriptor)

errno.EXFULL
変換テーブルが一杯です (Exchange full)

errno.ENOANO
陰極がありません (No anode)

errno.EBADRQC
無効なリクエストコードです (Invalid request code)

errno.EBADSLT
無効なスロットです (Invalid slot)

errno.EDEADLOCK
ファイルロックにおけるデッドロックエラーです (File locking deadlock error)

errno.EBFONT
フォントファイル形式が間違っています (Bad font file format)

errno.ENOSTR
ストリーム型でないデバイスです (Device not a stream)

errno.ENODATA
利用可能なデータがありません (No data available)

errno.ETIME
時間切れです (Timer expired)

errno.ENOSR
ストリームリソースを使い切りました (Out of streams resources)

errno.ENONET
計算機はネットワーク上にありません (Machine is not on the network)

errno.ENOPKG
パッケージがインストールされていません (Package not installed)

errno.EREMOTE
対象物は遠隔にあります (Object is remote)

errno.ENOLINK
リンクが切られました (Link has been severed)

errno.EADV
Advertise エラーです (Advertise error)

errno.ESRMNT
Srmount エラーです (Srmount error)

errno.ECOMM
送信時の通信エラーです (Communication error on send)

errno.EPROTO
プロトコルエラーです (Protocol error)

errno.EMULTIHOP
多重ホップを試みました (Multihop attempted)

errno.EDOTDOT
RFS 特有のエラーです (RFS specific error)

errno.EBADMSG
データメッセージではありません (Not a data message)

errno.EOVERFLOW
定義されたデータ型にとって大きすぎる値です (Value too large for defined data type)

errno.ENOTUNIQ
名前がネットワーク上で一意でありません (Name not unique on network)

errno.EBADFD
ファイル記述子の状態が不正です (File descriptor in bad state)

errno.EREMCHG
遠隔のアドレスが変更されました (Remote address changed)

errno.ELIBACC
必要な共有ライブラリにアクセスできません (Can not access a needed shared library)

errno.ELIBBAD
壊れた共有ライブラリにアクセスしています (Accessing a corrupted shared library)

errno.ELIBSCN
a.out の .lib セクションが壊れています (.lib section in a.out corrupted)

errno.ELIBMAX
リンクを試みる共有ライブラリが多すぎます (Attempting to link in too many shared libraries)

errno.ELIBEXEC
共有ライブラリを直接実行することができません (Cannot exec a shared library directly)

errno.EILSEQ
不正なバイト列です (Illegal byte sequence)

errno.ERESTART
割り込みシステムコールを復帰しなければなりません (Interrupted system call should be restarted)

errno.ESTRPIPE
ストリームパイプのエラーです (Streams pipe error)

errno.EUSERS
ユーザが多すぎます (Too many users)

errno.ENOTSOCK
非ソケットに対するソケット操作です (Socket operation on non-socket)

errno.EDESTADDRREQ
目的アドレスが必要です (Destination address required)

errno.EMSGSIZE
メッセージが長すぎます (Message too long)

errno.EPROTOTYPE
ソケットに対して不正なプロトコル型です (Protocol wrong type for socket)

errno.ENOPROTOOPT
利用できないプロトコルです (Protocol not available)

errno.EPROTONOSUPPORT
サポートされていないプロトコルです (Protocol not supported)

errno.ESOCKTNOSUPPORT
サポートされていないソケット型です (Socket type not supported)

errno.EOPNOTSUPP
通信端点に対してサポートされていない操作です (Operation not supported on transport endpoint)

errno.EPFNOSUPPORT
サポートされていないプロトコルファミリです (Protocol family not supported)

errno.EAFNOSUPPORT
プロトコルでサポートされていないアドレスファミリです (Address family not supported by protocol)

errno.EADDRINUSE
アドレスは使用中です (Address already in use)

errno.EADDRNOTAVAIL
要求されたアドレスを割り当てできません (Cannot assign requested address)

errno.ENETDOWN
ネットワークがダウンしています (Network is down)

errno.ENETUNREACH
ネットワークに到達できません (Network is unreachable)

errno.ENETRESET
リセットによってネットワーク接続が切られました (Network dropped connection because of reset)

errno.ECONNABORTED
ソフトウェアによって接続が終了されました (Software caused connection abort)

errno.ECONNRESET
接続がピアによってリセットされました (Connection reset by peer)

errno.ENOBUFS
バッファに空きがありません (No buffer space available)

errno.EISCONN
通信端点がすでに接続されています (Transport endpoint is already connected)

errno.ENOTCONN
通信端点が接続されていません (Transport endpoint is not connected)

errno.ESHUTDOWN
通信端点のシャットダウン後は送信できません (Cannot send after transport endpoint shutdown)

errno.ETOOMANYREFS
参照が多すぎます: 接続できません (Too many references: cannot splice)

errno.ETIMEDOUT
接続がタイムアウトしました (Connection timed out)

errno.ECONNREFUSED
接続を拒否されました (Connection refused)

errno.EHOSTDOWN
ホストはシステムダウンしています (Host is down)

errno.EHOSTUNREACH
ホストへの経路がありません (No route to host)

errno.EALREADY
すでに処理中です (Operation already in progress)

errno.EINPROGRESS
現在処理中です (Operation now in progress)

errno.ESTALE
無効な NFS ファイルハンドルです (Stale NFS file handle)

errno.EUCLEAN
構造のクリーニングが必要です (Structure needs cleaning)

errno.ENOTNAM
XENIX 名前付きファイルではありません (Not a XENIX named type file)

errno.ENAVAIL
XENIX セマフォは利用できません (No XENIX semaphores available)

errno.EISNAM
名前付きファイルです (Is a named type file)

errno.EREMOTEIO
遠隔側の I/O エラーです (Remote I/O error)

errno.EDQUOT
ディスククオータを超えました (Quota exceeded)

ctypes --- Pythonのための外部関数ライブラリ
ctypes は Python のための外部関数ライブラリです。このライブラリは C と互換性のあるデータ型を提供し、動的リンク/共有ライブラリ内の関数呼び出しを可能にします。動的リンク/共有ライブラリを純粋な Python でラップするために使うことができます。

ctypesチュートリアル
注意: このチュートリアルのコードサンプルは動作確認のために doctest を使います。コードサンプルの中には Linux、 Windows、あるいは Mac OS X 上で異なる動作をするものがあるため、サンプルのコメントに doctest 命令を入れてあります。

注意: いくつかのコードサンプルで ctypes の c_int 型を参照しています。 sizeof(long) == sizeof(int) であるようなプラットフォームでは、この型は c_long のエイリアスです。そのため、 c_int 型を想定しているときに c_long が表示されたとしても、混乱しないようにしてください --- 実際には同じ型なのです。

動的リンクライブラリをロードする
動的リンクライブラリをロードするために、 ctypes は cdll をエクスポートします。 Windows では windll と oledll オブジェクトをエクスポートします。

これらのオブジェクトの属性としてライブラリにアクセスすることでライブラリをロードします。 cdll は、標準 cdecl 呼び出し規約を用いて関数をエクスポートしているライブラリをロードします。それに対して、 windll ライブラリは stdcall 呼び出し規約を用いる関数を呼び出します。 oledll も stdcall 呼び出し規約を使いますが、関数が Windows HRESULT エラーコードを返すことを想定しています。このエラーコードは関数呼び出しが失敗したとき、 OSError 例外を自動的に送出させるために使われます。

バージョン 3.3 で変更: Windows エラーは以前は WindowsError を送出していましたが、これは現在では OSError の別名になっています。

Windows用の例ですが、 msvcrt はほとんどの標準 C 関数が含まれている MS 標準 C ライブラリであり、 cdecl 呼び出し規約を使うことに注意してください:

>>>
>>> from ctypes import *
>>> print(windll.kernel32)  
<WinDLL 'kernel32', handle ... at ...>
>>> print(cdll.msvcrt)      
<CDLL 'msvcrt', handle ... at ...>
>>> libc = cdll.msvcrt      
>>>
Windows では通常の .dll ファイル拡張子を自動的に追加します。

注釈 cdll.msvcrt 経由で標準 C ライブラリにアクセスすると、Python が使用しているライブラリとは互換性のない可能性のある、古いバージョンのライブラリが使用されます。可能な場合には、ネイティブ Python の機能を使用するか、msvcrt モジュールをインポートして使用してください。
Linux ではライブラリをロードするために拡張子を 含む ファイル名を指定する必要があるので、ロードしたライブラリに対する属性アクセスはできません。 dll ローダーの LoadLibrary() メソッドを使うか、コンストラクタを呼び出して CDLL のインスタンスを作ることでライブラリをロードするかのどちらかを行わなければなりません:

>>>
>>> cdll.LoadLibrary("libc.so.6")  
<CDLL 'libc.so.6', handle ... at ...>
>>> libc = CDLL("libc.so.6")       
>>> libc                           
<CDLL 'libc.so.6', handle ... at ...>
>>>
ロードしたdllから関数にアクセスする
dll オブジェクトの属性として関数にアクセスします:

>>>
>>> from ctypes import *
>>> libc.printf
<_FuncPtr object at 0x...>
>>> print(windll.kernel32.GetModuleHandleA)  
<_FuncPtr object at 0x...>
>>> print(windll.kernel32.MyOwnFunction)     
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "ctypes.py", line 239, in __getattr__
    func = _StdcallFuncPtr(name, self)
AttributeError: function 'MyOwnFunction' not found
>>>
kernel32 や user32 のような win32 システム dll は、多くの場合関数の UNICODE バージョンに加えて ANSI バージョンもエクスポートすることに注意してください。 UNICODE バージョンは後ろに W が付いた名前でエクスポートされ、 ANSI バージョンは A が付いた名前でエクスポートされます。与えられたモジュールの モジュールハンドル を返す win32 GetModuleHandle 関数は次のような C プロトタイプを持ちます。 UNICODE バージョンが定義されているかどうかにより GetModuleHandle としてどちらか一つを公開するためにマクロが使われます:

/* ANSI version */
HMODULE GetModuleHandleA(LPCSTR lpModuleName);
/* UNICODE version */
HMODULE GetModuleHandleW(LPCWSTR lpModuleName);
windll は魔法を使ってどちらか一つを選ぶようなことはしません。GetModuleHandleA もしくは GetModuleHandleW を明示的に指定して必要とするバージョンにアクセスし、バイト列か文字列を使ってそれぞれ呼び出さなければなりません。

時には、 dll が関数を "??2@YAPAXI@Z" のような Python 識別子として有効でない名前でエクスポートすることがあります。このような場合に関数を取り出すには、 getattr() を使わなければなりません。:

>>>
>>> getattr(cdll.msvcrt, "??2@YAPAXI@Z")  
<_FuncPtr object at 0x...>
>>>
Windows では、名前ではなく序数によって関数をエクスポートする dll もあります。こうした関数には序数を使って dll オブジェクトにインデックス指定することでアクセスします:

>>>
>>> cdll.kernel32[1]  
<_FuncPtr object at 0x...>
>>> cdll.kernel32[0]  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "ctypes.py", line 310, in __getitem__
    func = _StdcallFuncPtr(name, self)
AttributeError: function ordinal 0 not found
>>>
関数を呼び出す
これらの関数は他の Python 呼び出し可能オブジェクトと同じように呼び出すことができます。この例では time() 関数 (Unixエポックからのシステム時間を秒単位で返す) と、 GetModuleHandleA() 関数 (win32モジュールハンドルを返す) を使います。

この例は両方の関数を NULL ポインタとともに呼び出します (None を NULL ポインタとして使う必要があります):

>>>
>>> print(libc.time(None))  
1150640792
>>> print(hex(windll.kernel32.GetModuleHandleA(None)))  
0x1d000000
>>>
cdecl 呼び出し規約を使って stdcall 関数を呼び出したときには、 ValueError が送出されます。逆の場合も同様です:

>>>
>>> cdll.kernel32.GetModuleHandleA(None)  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Procedure probably called with not enough arguments (4 bytes missing)
>>>

>>> windll.msvcrt.printf(b"spam")  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Procedure probably called with too many arguments (4 bytes in excess)
>>>
正しい呼び出し規約を知るためには、呼び出したい関数についての C ヘッダファイルもしくはドキュメントを見なければなりません。

Windows では、関数が無効な引数とともに呼び出された場合の一般保護例外によるクラッシュを防ぐために、 ctypes は win32 構造化例外処理を使います:

>>>
>>> windll.kernel32.GetModuleHandleA(32)  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OSError: exception: access violation reading 0x00000020
>>>
しかしそれでも他に ctypes で Python がクラッシュする状況はあるので、どちらにせよ気を配るべきです。クラッシュのデバッグには、 faulthandler モジュールが役に立つ場合があります (例えば、誤った C ライブラリ呼び出しによって引き起こされたセグメンテーション違反) 。

None 、整数、バイト列オブジェクトおよび (Unicode) 文字列だけが、こうした関数呼び出しにおいてパラメータとして直接使えるネイティブの Python オブジェクトです。 None は C の NULL ポインタとして渡され、バイト文字列とユニコード文字列はそのデータを含むメモリブロックへのポインタ (char * または wchar_t *) として渡されます。 Python 整数はプラットホームのデフォルトの C int 型として渡され、その値は C int 型に合うようにマスクされます。

他のパラメータ型をもつ関数呼び出しに移る前に、 ctypes データ型についてさらに学ぶ必要があります。

基本データ型
ctypes ではいくつもの C 互換のプリミティブなデータ型を定義しています:

ctypes の型

C の型

Python の型

c_bool

_Bool

bool (1)

c_char

char

1文字のバイト列オブジェクト

c_wchar

wchar_t

1文字の文字列

c_byte

char

int

c_ubyte

unsigned char

int

c_short

short

int

c_ushort

unsigned short

int

c_int

int

int

c_uint

unsigned int

int

c_long

long

int

c_ulong

unsigned long

int

c_longlong

__int64 または long long

int

c_ulonglong

unsigned __int64 または unsigned long long

int

c_size_t

size_t

int

c_ssize_t

ssize_t または Py_ssize_t

int

c_float

float

浮動小数点数

c_double

double

浮動小数点数

c_longdouble

long double

浮動小数点数

c_char_p

char * (NUL 終端)

バイト列オブジェクトまたは None

c_wchar_p

wchar_t * (NUL 終端)

文字列または None

c_void_p

void *

整数または None

コンストラクタは任意のオブジェクトをその真偽値として受け取ります。

これら全ての型はその型を呼び出すことによって作成でき、オプションとして型と値が合っている初期化子を指定することができます:

>>>
>>> c_int()
c_long(0)
>>> c_wchar_p("Hello, World")
c_wchar_p(140018365411392)
>>> c_ushort(-3)
c_ushort(65533)
>>>
これらの型は変更可能であり、値を後で変更することもできます:

>>>
>>> i = c_int(42)
>>> print(i)
c_long(42)
>>> print(i.value)
42
>>> i.value = -99
>>> print(i.value)
-99
>>>
新しい値をポインタ型 c_char_p, c_wchar_p および c_void_p のインスタンスへ代入すると、変わるのは指している メモリ位置 であって、メモリブロックの 内容ではありません (これは当然で、なぜなら、 Python バイト列オブジェクトは変更不可能だからです):

>>>
>>> s = "Hello, World"
>>> c_s = c_wchar_p(s)
>>> print(c_s)
c_wchar_p(139966785747344)
>>> print(c_s.value)
Hello World
>>> c_s.value = "Hi, there"
>>> print(c_s)              # the memory location has changed
c_wchar_p(139966783348904)
>>> print(c_s.value)
Hi, there
>>> print(s)                # first object is unchanged
Hello, World
>>>
しかし、変更可能なメモリを指すポインタであることを想定している関数へそれらを渡さないように注意すべきです。もし変更可能なメモリブロックが必要なら、 ctypes には create_string_buffer() 関数があり、いろいろな方法で作成することできます。現在のメモリブロックの内容は raw プロパティを使ってアクセス (あるいは変更) することができます。もし現在のメモリブロックに NUL 終端文字列としてアクセスしたいなら、 value プロパティを使ってください:

>>>
>>> from ctypes import *
>>> p = create_string_buffer(3)            # create a 3 byte buffer, initialized to NUL bytes
>>> print(sizeof(p), repr(p.raw))
3 b'\x00\x00\x00'
>>> p = create_string_buffer(b"Hello")     # create a buffer containing a NUL terminated string
>>> print(sizeof(p), repr(p.raw))
6 b'Hello\x00'
>>> print(repr(p.value))
b'Hello'
>>> p = create_string_buffer(b"Hello", 10) # create a 10 byte buffer
>>> print(sizeof(p), repr(p.raw))
10 b'Hello\x00\x00\x00\x00\x00'
>>> p.value = b"Hi"
>>> print(sizeof(p), repr(p.raw))
10 b'Hi\x00lo\x00\x00\x00\x00\x00'
>>>
create_string_buffer() 関数は初期の ctypes リリースにあった c_string() 関数だけでなく、 (エイリアスとしてはまだ利用できる) c_buffer() 関数をも置き換えるものです。 C の型 wchar_t の Unicode 文字を含む変更可能なメモリブロックを作成するには、 create_unicode_buffer() 関数を使ってください。

続・関数を呼び出す
printf は sys.stdout では なく 、本物の標準出力チャンネルへプリントすることに注意してください。したがって、これらの例はコンソールプロンプトでのみ動作し、 IDLE や PythonWin では動作しません。:

>>>
>>> printf = libc.printf
>>> printf(b"Hello, %s\n", b"World!")
Hello, World!
14
>>> printf(b"Hello, %S\n", "World!")
Hello, World!
14
>>> printf(b"%d bottles of beer\n", 42)
42 bottles of beer
19
>>> printf(b"%f bottles of beer\n", 42.5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ArgumentError: argument 2: exceptions.TypeError: Don't know how to convert parameter 2
>>>
前に述べたように、必要な C のデータ型へ変換できるようにするためには、整数、文字列およびバイト列オブジェクトを除くすべての Python 型を対応する ctypes 型でラップしなければなりません:

>>>
>>> printf(b"An int %d, a double %f\n", 1234, c_double(3.14))
An int 1234, a double 3.140000
31
>>>
自作のデータ型とともに関数を呼び出す
自作のクラスのインスタンスを関数引数として使えるように、 ctypes 引数変換をカスタマイズすることもできます。 ctypes は _as_parameter_ 属性を探し出し、関数引数として使います。もちろん、整数、文字列もしくはバイト列オブジェクトの中の一つでなければなりません:

>>>
>>> class Bottles:
...     def __init__(self, number):
...         self._as_parameter_ = number
...
>>> bottles = Bottles(42)
>>> printf(b"%d bottles of beer\n", bottles)
42 bottles of beer
19
>>>
_as_parameter_ インスタンス変数にインスタンスのデータを保持したくない場合は、必要に応じて利用できる属性を作る property を定義しても構いません。

要求される引数の型を指定する (関数プロトタイプ)
argtypes 属性を設定することによって、 DLL からエクスポートされている関数に要求される引数の型を指定することができます。

argtypes は C データ型のシーケンスでなければなりません (この場合 printf 関数はおそらく良い例ではありません。なぜなら、引数の数が可変であり、フォーマット文字列に依存した異なる型のパラメータを取るからです。一方では、この機能の実験にはとても便利です)。:

>>>
>>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]
>>> printf(b"String '%s', Int %d, Double %f\n", b"Hi", 10, 2.2)
String 'Hi', Int 10, Double 2.200000
37
>>>
(C の関数のプロトタイプのように) 書式を指定すると互換性のない引数型になるのを防ぎ、引数を有効な型へ変換しようとします。:

>>>
>>> printf(b"%d %d %d", 1, 2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ArgumentError: argument 2: exceptions.TypeError: wrong type
>>> printf(b"%s %d %f\n", b"X", 2, 3)
X 2 3.000000
13
>>>
関数呼び出しへ渡す自作のクラスを定義した場合には、 argtypes シーケンスの中で使えるようにするために、そのクラスに from_param() クラスメソッドを実装しなければなりません。 from_param() クラスメソッドは関数呼び出しへ渡された Python オブジェクトを受け取り、型チェックもしくはこのオブジェクトが受け入れ可能であると確かめるために必要なことはすべて行ってから、オブジェクト自身、 _as_parameter_ 属性、あるいは、この場合に C 関数引数として渡したい何かの値を返さなければなりません。繰り返しになりますが、その返される結果は整数、文字列、バイト列、 ctypes インスタンス、あるいは _as_parameter_ 属性をもつオブジェクトであるべきです。

戻り値の型
デフォルトでは、関数は C int を返すと仮定されます。他の戻り値の型を指定するには、関数オブジェクトの restype 属性に設定します。

さらに高度な例として、 strchr 関数を使います。この関数は文字列ポインタと char を受け取り、文字列へのポインタを返します。:

>>>
>>> strchr = libc.strchr
>>> strchr(b"abcdef", ord("d"))  
8059983
>>> strchr.restype = c_char_p    # c_char_p is a pointer to a string
>>> strchr(b"abcdef", ord("d"))
b'def'
>>> print(strchr(b"abcdef", ord("x")))
None
>>>
上の ord("x") 呼び出しを避けたいなら、 argtypes 属性を設定することができます。二番目の引数が一文字の Python バイト列オブジェクトから C の char へ変換されます:

>>>
>>> strchr.restype = c_char_p
>>> strchr.argtypes = [c_char_p, c_char]
>>> strchr(b"abcdef", b"d")
'def'
>>> strchr(b"abcdef", b"def")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ArgumentError: argument 2: exceptions.TypeError: one character string expected
>>> print(strchr(b"abcdef", b"x"))
None
>>> strchr(b"abcdef", b"d")
'def'
>>>
外部関数が整数を返す場合は、 restype 属性として呼び出し可能な Python オブジェクト (例えば、関数またはクラス) を使うこともできます。呼び出し可能オブジェクトは C 関数が返す 整数 とともに呼び出され、この呼び出しの結果は関数呼び出しの結果として使われるでしょう。これはエラーの戻り値をチェックして自動的に例外を送出させるために役に立ちます。:

>>>
>>> GetModuleHandle = windll.kernel32.GetModuleHandleA  
>>> def ValidHandle(value):
...     if value == 0:
...         raise WinError()
...     return value
...
>>>
>>> GetModuleHandle.restype = ValidHandle  
>>> GetModuleHandle(None)  
486539264
>>> GetModuleHandle("something silly")  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in ValidHandle
OSError: [Errno 126] The specified module could not be found.
>>>
WinError はエラーコードの文字列表現を得るために Windows の FormatMessage() api を呼び出し、例外を 返す 関数です。 WinError はオプションでエラーコードパラメータを取ります。このパラメータが使われない場合は、エラーコードを取り出すために GetLastError() を呼び出します。

errcheck 属性によってもっと強力なエラーチェック機構を利用できることに注意してください。詳細はリファレンスマニュアルを参照してください。

ポインタを渡す(または、パラメータの参照渡し)
時には、 C api 関数がパラメータのデータ型として ポインタ を想定していることがあります。おそらくパラメータと同一の場所に書き込むためか、もしくはそのデータが大きすぎて値渡しできない場合です。これは パラメータの参照渡し としても知られています。

ctypes は byref() 関数をエクスポートしており、パラメータを参照渡しするために使用します。 pointer() 関数を使っても同じ効果が得られます。しかし、 pointer() は本当のポインタオブジェクトを構築するためより多くの処理を行うことから、 Python 側でポインタオブジェクト自体を必要としないならば byref() を使う方がより高速です。:

>>>
>>> i = c_int()
>>> f = c_float()
>>> s = create_string_buffer(b'\000' * 32)
>>> print(i.value, f.value, repr(s.value))
0 0.0 b''
>>> libc.sscanf(b"1 3.14 Hello", b"%d %f %s",
...             byref(i), byref(f), s)
3
>>> print(i.value, f.value, repr(s.value))
1 3.1400001049 b'Hello'
>>>
構造体と共用体
構造体と共用体は ctypes モジュールに定義されている Structure および Union ベースクラスからの派生クラスでなければなりません。それぞれのサブクラスは _fields_ 属性を定義する必要があります。 _fields_ は フィールド名 と フィールド型 を持つ 2要素タプル のリストでなければなりません。

フィールド型は c_int か他の ctypes 型 (構造体、共用体、配列、ポインタ) から派生した ctypes 型である必要があります。

以下は、 x と y という名前の二つの整数からなる簡単な POINT 構造体の例です。コンストラクタで構造体を初期化する方法も説明しています:

>>>
>>> from ctypes import *
>>> class POINT(Structure):
...     _fields_ = [("x", c_int),
...                 ("y", c_int)]
...
>>> point = POINT(10, 20)
>>> print(point.x, point.y)
10 20
>>> point = POINT(y=5)
>>> print(point.x, point.y)
0 5
>>> POINT(1, 2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: too many initializers
>>>
しかし、もっと複雑な構造体を構築することもできます。ある構造体は、他の構造体をフィールド型として使うことで、他の構造体を含むことができます。

upperleft と lowerright という名前の二つの POINT を持つ RECT 構造体です。:

>>>
>>> class RECT(Structure):
...     _fields_ = [("upperleft", POINT),
...                 ("lowerright", POINT)]
...
>>> rc = RECT(point)
>>> print(rc.upperleft.x, rc.upperleft.y)
0 5
>>> print(rc.lowerright.x, rc.lowerright.y)
0 0
>>>
入れ子になった構造体はいくつかの方法を用いてコンストラクタで初期化することができます。:

>>>
>>> r = RECT(POINT(1, 2), POINT(3, 4))
>>> r = RECT((1, 2), (3, 4))
フィールド descriptor (記述子)は クラス から取り出せます。デバッグするときに役に立つ情報を得ることができます:

>>>
>>> print(POINT.x)
<Field type=c_long, ofs=0, size=4>
>>> print(POINT.y)
<Field type=c_long, ofs=4, size=4>
>>>
警告 ctypes では、ビットフィールドのある共用体や構造体の関数への値渡しはサポートしていません。これは 32-bit の x86 環境では動くかもしれませんが、このライブラリでは一般の場合に動作することは保証していません。
構造体/共用体アライメントとバイトオーダー
デフォルトでは、構造体 (Structure) と共用体(Union) のフィールドは C コンパイラが行うのと同じ方法でアライメントされています。サブクラスを定義するときに _pack_ クラス属性を指定することでこの動作を変えることは可能です。このクラス属性には正の整数を設定する必要があり、フィールドの最大アライメントを指定します。これは MSVC で #pragma pack(n) が行っていること同じです。

ctypes は Structure と Union に対してネイティブのバイトオーダーを使います。ネイティブではないバイトオーダーの構造体を作成するには、 BigEndianStructure, LittleEndianStructure, BigEndianUnion および LittleEndianUnion ベースクラスの中の一つを使います。これらのクラスにポインタフィールドを持たせることはできません。

構造体と共用体におけるビットフィールド
ビットフィールドを含む構造体と共用体を作ることができます。ビットフィールドは整数フィールドに対してのみ作ることができ、ビット幅は _fields_ タプルの第三要素で指定します。:

>>>
>>> class Int(Structure):
...     _fields_ = [("first_16", c_int, 16),
...                 ("second_16", c_int, 16)]
...
>>> print(Int.first_16)
<Field type=c_long, ofs=0:0, bits=16>
>>> print(Int.second_16)
<Field type=c_long, ofs=0:16, bits=16>
>>>
配列
配列 (Array) はシーケンスであり、決まった数の同じ型のインスタンスを持ちます。

推奨されている配列の作成方法はデータ型に正の整数を掛けることです。:

TenPointsArrayType = POINT * 10
ややわざとらしいデータ型の例になりますが、他のものに混ざって 4 個の POINT がある構造体です:

>>>
>>> from ctypes import *
>>> class POINT(Structure):
...     _fields_ = ("x", c_int), ("y", c_int)
...
>>> class MyStruct(Structure):
...     _fields_ = [("a", c_int),
...                 ("b", c_float),
...                 ("point_array", POINT * 4)]
>>>
>>> print(len(MyStruct().point_array))
4
>>>
インスタンスはクラスを呼び出す通常の方法で作成します。:

arr = TenPointsArrayType()
for pt in arr:
    print(pt.x, pt.y)
上記のコードは 0 0 という行が並んだものを表示します。配列の要素がゼロで初期化されているためです。

正しい型の初期化子を指定することもできます。:

>>>
>>> from ctypes import *
>>> TenIntegers = c_int * 10
>>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
>>> print(ii)
<c_long_Array_10 object at 0x...>
>>> for i in ii: print(i, end=" ")
...
1 2 3 4 5 6 7 8 9 10
>>>
ポインタ
ポインタのインスタンスは ctypes 型に対して pointer() 関数を呼び出して作成します。:

>>>
>>> from ctypes import *
>>> i = c_int(42)
>>> pi = pointer(i)
>>>
次のように、ポインタインスタンスは、ポインタが指すオブジェクト (上の例では i) を返す contents 属性を持ちます:

>>>
>>> pi.contents
c_long(42)
>>>
ctypes は OOR (original object return 、元のオブジェクトを返すこと) ではないことに注意してください。属性を取り出す度に、新しい同等のオブジェクトを作成しているのです。:

>>>
>>> pi.contents is i
False
>>> pi.contents is pi.contents
False
>>>
別の c_int インスタンスがポインタの contents 属性に代入されると、これが記憶されているメモリ位置を指すポインタに変化します。:

>>>
>>> i = c_int(99)
>>> pi.contents = i
>>> pi.contents
c_long(99)
>>>
ポインタインスタンスは整数でインデックス指定することもできます。:

>>>
>>> pi[0]
99
>>>
整数インデックスへ代入するとポインタが指す値が変更されます。:

>>>
>>> print(i)
c_long(99)
>>> pi[0] = 22
>>> print(i)
c_long(22)
>>>
0 ではないインデックスを使うこともできますが、 C の場合と同じように自分が何をしているかを理解している必要があります。任意のメモリ位置にアクセスもしくは変更できるのです。一般的にこの機能を使うのは、 C 関数からポインタを受け取り、そのポインタが単一の要素ではなく実際に配列を指していると 分かっている 場合だけです。

舞台裏では、 pointer() 関数は単にポインタインスタンスを作成するという以上のことを行っています。はじめにポインタ 型 を作成する必要があります。これは任意の ctypes 型を受け取る POINTER() 関数を使って行われ、新しい型を返します:

>>>
>>> PI = POINTER(c_int)
>>> PI
<class 'ctypes.LP_c_long'>
>>> PI(42)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: expected c_long instead of int
>>> PI(c_int(42))
<ctypes.LP_c_long object at 0x...>
>>>
ポインタ型を引数なしで呼び出すと NULL ポインタを作成します。 NULL ポインタは False ブール値を持っています。:

>>>
>>> null_ptr = POINTER(c_int)()
>>> print(bool(null_ptr))
False
>>>
ctypes はポインタの指す値を取り出すときに NULL かどうかを調べます(しかし、 NULL でない不正なポインタの指す値の取り出す行為は Python をクラッシュさせるでしょう)。:

>>>
>>> null_ptr[0]
Traceback (most recent call last):
    ....
ValueError: NULL pointer access
>>>

>>> null_ptr[0] = 1234
Traceback (most recent call last):
    ....
ValueError: NULL pointer access
>>>
型変換
たいていの場合、 ctypes は厳密な型チェックを行います。これが意味するのは、関数の argtypes リスト内に、もしくは、構造体定義におけるメンバーフィールドの型として POINTER(c_int) がある場合、厳密に同じ型のインスタンスだけを受け取るということです。このルールには ctypes が他のオブジェクトを受け取る場合に例外がいくつかあります。例えば、ポインタ型の代わりに互換性のある配列インスタンスを渡すことができます。このように、 POINTER(c_int) に対して、 ctypes は c_int の配列を受け取ります。:

>>>
>>> class Bar(Structure):
...     _fields_ = [("count", c_int), ("values", POINTER(c_int))]
...
>>> bar = Bar()
>>> bar.values = (c_int * 3)(1, 2, 3)
>>> bar.count = 3
>>> for i in range(bar.count):
...     print(bar.values[i])
...
1
2
3
>>>
それに加えて、 argtypes で関数の引数が明示的に (POINTER(c_int) などの) ポインタ型であると宣言されていた場合、ポインタ型が指し示している型のオブジェクト (この場合では c_int) を関数に渡すことができます。この場合 ctypes は、必要となる byref() での変換を自動的に適用します。

POINTER型フィールドを NULL に設定するために、 None を代入してもかまいません。:

>>>
>>> bar.values = None
>>>
時には、非互換な型のインスタンスであることもあります。 C では、ある型を他の型へキャストすることができます。 ctypes は同じやり方で使える cast() 関数を提供しています。上で定義した Bar 構造体は POINTER(c_int) ポインタまたは c_int 配列を values フィールドに対して受け取り、他の型のインスタンスは受け取りません:

>>>
>>> bar.values = (c_byte * 4)()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance
>>>
このような場合には、 cast() 関数が便利です。

cast() 関数は ctypes インスタンスを異なる ctypes データ型を指すポインタへキャストするために使えます。 cast() は二つのパラメータ、ある種のポインタかそのポインタへ変換できる ctypes オブジェクトと、 ctypes ポインタ型を取ります。そして、第二引数のインスタンスを返します。このインスタンスは第一引数と同じメモリブロックを参照しています:

>>>
>>> a = (c_byte * 4)()
>>> cast(a, POINTER(c_int))
<ctypes.LP_c_long object at ...>
>>>
したがって、 cast() を Bar 構造体の values フィールドへ代入するために使うことができます:

>>>
>>> bar = Bar()
>>> bar.values = cast((c_byte * 4)(), POINTER(c_int))
>>> print(bar.values[0])
0
>>>
不完全型
不完全型 はメンバーがまだ指定されていない構造体、共用体もしくは配列です。 C では、前方宣言により指定され、後で定義されます。:

struct cell; /* forward declaration */

struct cell {
    char *name;
    struct cell *next;
};
ctypes コードへの直接的な変換ではこうなるでしょう。しかし、動作しません:

>>>
>>> class cell(Structure):
...     _fields_ = [("name", c_char_p),
...                 ("next", POINTER(cell))]
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in cell
NameError: name 'cell' is not defined
>>>
なぜなら、新しい class cell はクラス文自体の中では利用できないからです。 ctypes では、 cell クラスを定義して、 _fields_ 属性をクラス文の後で設定することができます。:

>>>
>>> from ctypes import *
>>> class cell(Structure):
...     pass
...
>>> cell._fields_ = [("name", c_char_p),
...                  ("next", POINTER(cell))]
>>>
試してみましょう。 cell のインスタンスを二つ作り、互いに参照し合うようにします。最後に、つながったポインタを何度かたどります。:

>>>
>>> c1 = cell()
>>> c1.name = "foo"
>>> c2 = cell()
>>> c2.name = "bar"
>>> c1.next = pointer(c2)
>>> c2.next = pointer(c1)
>>> p = c1
>>> for i in range(8):
...     print(p.name, end=" ")
...     p = p.next[0]
...
foo bar foo bar foo bar foo bar
>>>
コールバック関数
ctypes は C の呼び出し可能な関数ポインタを Python 呼び出し可能オブジェクトから作成できるようにします。これらは コールバック関数 と呼ばれることがあります。

最初に、コールバック関数のためのクラスを作る必要があります。そのクラスには呼び出し規約、戻り値の型およびこの関数が受け取る引数の数と型についての情報があります。

CFUNCTYPE() ファクトリ関数は通常の cdecl 呼び出し規約を用いてコールバック関数のための型を作成します。 Windows では、 WINFUNCTYPE() ファクトリ関数が stdcall 呼び出し規約を用いてコールバック関数の型を作成します。

これらのファクトリ関数はともに最初の引数に戻り値の型、残りの引数としてコールバック関数が想定する引数の型を渡して呼び出されます。

標準 C ライブラリの qsort() 関数を使う例を示します。これはコールバック関数の助けをかりて要素をソートするために使われます。 qsort() は整数の配列をソートするために使われます:

>>>
>>> IntArray5 = c_int * 5
>>> ia = IntArray5(5, 1, 7, 33, 99)
>>> qsort = libc.qsort
>>> qsort.restype = None
>>>
qsort() はソートするデータを指すポインタ、データ配列の要素の数、要素の一つの大きさ、およびコールバック関数である比較関数へのポインタを引数に渡して呼び出さなければなりません。そして、コールバック関数は要素を指す二つのポインタを渡されて呼び出され、一番目が二番目より小さいなら負の数を、等しいならゼロを、それ以外なら正の数を返さなければなりません。

コールバック関数は整数へのポインタを受け取り、整数を返す必要があります。まず、コールバック関数のための type を作成します。:

>>>
>>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
>>>
まず初めに、これが受け取った変数を表示するだけのシンプルなコールバックです:

>>>
>>> def py_cmp_func(a, b):
...     print("py_cmp_func", a[0], b[0])
...     return 0
...
>>> cmp_func = CMPFUNC(py_cmp_func)
>>>
結果は以下の通りです:

>>>
>>> qsort(ia, len(ia), sizeof(c_int), cmp_func)  
py_cmp_func 5 1
py_cmp_func 33 99
py_cmp_func 7 33
py_cmp_func 5 7
py_cmp_func 1 7
>>>
ここで 2 つの要素を実際に比較し、役に立つ結果を返します:

>>>
>>> def py_cmp_func(a, b):
...     print("py_cmp_func", a[0], b[0])
...     return a[0] - b[0]
...
>>>
>>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) 
py_cmp_func 5 1
py_cmp_func 33 99
py_cmp_func 7 33
py_cmp_func 1 7
py_cmp_func 5 7
>>>
簡単に確認できるように、配列を次のようにソートしました:

>>>
>>> for i in ia: print(i, end=" ")
...
1 5 7 33 99
>>>
関数ファクトリはデコレータファクトリとしても使えるので、次のようにも書けます:

>>>
>>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
... def py_cmp_func(a, b):
...     print("py_cmp_func", a[0], b[0])
...     return a[0] - b[0]
...
>>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)
py_cmp_func 5 1
py_cmp_func 33 99
py_cmp_func 7 33
py_cmp_func 1 7
py_cmp_func 5 7
>>>
注釈 C コードから CFUNCTYPE() オブジェクトが使用される限り、そのオブジェクトへの参照を確実に保持してください。 ctypes は参照を保持しないため、あなたが参照を保持しないと、オブジェクトはガベージコレクションの対象となり、コールバックが行われたときにプログラムをクラッシュさせる場合があります。
同様に、コールバック関数が Python の管理外 (例えば、コールバックを呼び出す外部のコード) で作られたスレッドで呼び出された場合、 ctypes は全ての呼び出しごとに新しいダミーの Python スレッドを作成することに注意してください。 この動作はほとんどの目的に対して正しいものですが、同じ C スレッドからの呼び出しだったとしても、 threading.local で格納された値は異なるコールバックをまたいで生存は しません 。

dllからエクスポートされた値へアクセスする
共有ライブラリの一部は関数だけでなく変数もエクスポートしています。 Python ライブラリにある例としては Py_OptimizeFlag 、起動時の -O または -OO フラグに依存して、 0 , 1 または 2 が設定される整数があります。

ctypes は型の in_dll() クラスメソッドを使ってこのように値にアクセスできます。 pythonapi はPython C api へアクセスできるようにするための予め定義されたシンボルです。:

>>>
>>> opt_flag = c_int.in_dll(pythonapi, "Py_OptimizeFlag")
>>> print(opt_flag)
c_long(0)
>>>
インタープリタが -O を指定されて動き始めた場合、サンプルは c_long(1) を表示するでしょうし、 -OO が指定されたならば c_long(2) を表示するでしょう。

ポインタの使い方を説明する拡張例では、 Python がエクスポートする PyImport_FrozenModules ポインタにアクセスします。

この値のドキュメントから引用すると:

このポインタは struct _frozen のレコードからなり、終端の要素のメンバが NULL かゼロになっているような配列を指すよう初期化されます。 フリーズされたモジュールをインポートするとき、このテーブルを検索します。 サードパーティ製のコードからこのポインタに仕掛けを講じて、動的に生成されたフリーズ化モジュールの集合を提供するようにできます。

これで、このポインタを操作することが役に立つことを証明できるでしょう。例の大きさを制限するために、このテーブルを ctypes を使って読む方法だけを示します。:

>>>
>>> from ctypes import *
>>>
>>> class struct_frozen(Structure):
...     _fields_ = [("name", c_char_p),
...                 ("code", POINTER(c_ubyte)),
...                 ("size", c_int)]
...
>>>
私たちは struct _frozen データ型を定義済みなので、このテーブルを指すポインタを得ることができます:

>>>
>>> FrozenTable = POINTER(struct_frozen)
>>> table = FrozenTable.in_dll(pythonapi, "PyImport_FrozenModules")
>>>
table が struct_frozen レコードの配列への pointer なので、その配列に対して反復処理を行えます。しかし、ループが確実に終了するようにする必要があります。なぜなら、ポインタに大きさの情報がないからです。遅かれ早かれ、アクセス違反か何かでクラッシュすることになるでしょう。 NULL エントリに達したときはループを抜ける方が良いです:

>>>
>>> for item in table:
...     if item.name is None:
...         break
...     print(item.name.decode("ascii"), item.size)
...
_frozen_importlib 31764
_frozen_importlib_external 41499
__hello__ 161
__phello__ -161
__phello__.spam 161
>>>
標準 Python はフローズンモジュールとフローズンパッケージ (負の size メンバーで表されています) を持っているという事実はあまり知られておらず、テストにだけ使われています。例えば、 import __hello__ を試してみてください。

びっくり仰天
There are some edges in ctypes where you might expect something other than what actually happens.

次に示す例について考えてみてください。:

>>>
>>> from ctypes import *
>>> class POINT(Structure):
...     _fields_ = ("x", c_int), ("y", c_int)
...
>>> class RECT(Structure):
...     _fields_ = ("a", POINT), ("b", POINT)
...
>>> p1 = POINT(1, 2)
>>> p2 = POINT(3, 4)
>>> rc = RECT(p1, p2)
>>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)
1 2 3 4
>>> # now swap the two points
>>> rc.a, rc.b = rc.b, rc.a
>>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)
3 4 3 4
>>>
うーん、最後の文に 3 4 1 2 と表示されることを期待していたはずです。何が起きたのでしょうか? 上の行の rc.a, rc.b = rc.b, rc.a の各段階はこのようになります。:

>>>
>>> temp0, temp1 = rc.b, rc.a
>>> rc.a = temp0
>>> rc.b = temp1
>>>
temp0 と temp1 は前記の rc オブジェクトの内部バッファでまだ使われているオブジェクトです。したがって、 rc.a = temp0 を実行すると temp0 のバッファ内容が rc のバッファへコピーされます。さらに、これは temp1 の内容を変更します。そのため、最後の代入 rc.b = temp1 は、期待する結果にはならないのです。

Structure 、 Union および Array のサブオブジェクトを取り出しても、そのサブオブジェクトが コピー されるわけではなく、ルートオブジェクトの内部バッファにアクセスするラッパーオブジェクトを取り出すことを覚えておいてください。

期待とは違う振る舞いをする別の例はこれです:

>>>
>>> s = c_char_p()
>>> s.value = b"abc def ghi"
>>> s.value
b'abc def ghi'
>>> s.value is s.value
False
>>>
注釈 c_char_p からインスタンス化されたオブジェクトは、bytes または整数に設定された値しか持てません。
なぜ False と表示されるのでしょうか? ctypes インスタンスはメモリと、メモリの内容にアクセスするいくつかの descriptor (記述子)を含むオブジェクトです。メモリブロックに Python オブジェクトを保存してもオブジェクト自身が保存される訳ではなく、オブジェクトの contents が保存されます。その contents に再アクセスすると新しい Python オブジェクトがその度に作られます。

可変サイズのデータ型
ctypes は可変サイズの配列と構造体をサポートしています。

resize() 関数は既存の ctypes オブジェクトのメモリバッファのサイズを変更したい場合に使えます。この関数は第一引数にオブジェクト、第二引数に要求されたサイズをバイト単位で指定します。メモリブロックはオブジェクト型で指定される通常のメモリブロックより小さくすることはできません。これをやろうとすると、 ValueError が送出されます。:

>>>
>>> short_array = (c_short * 4)()
>>> print(sizeof(short_array))
8
>>> resize(short_array, 4)
Traceback (most recent call last):
    ...
ValueError: minimum size is 8
>>> resize(short_array, 32)
>>> sizeof(short_array)
32
>>> sizeof(type(short_array))
8
>>>
これはこれで上手くいっていますが、この配列の追加した要素へどうやってアクセスするのでしょうか? この型は要素の数が 4 個であるとまだ認識しているので、他の要素にアクセスするとエラーになります。:

>>>
>>> short_array[:]
[0, 0, 0, 0]
>>> short_array[7]
Traceback (most recent call last):
    ...
IndexError: invalid index
>>>
ctypes で可変サイズのデータ型を使うもう一つの方法は、必要なサイズが分かった後に Python の動的性質を使って一つ一つデータ型を(再)定義することです。

ctypesリファレンス
共有ライブラリを見つける
コンパイルされる言語でプログラミングしている場合、共有ライブラリはプログラムをコンパイル/リンクしているときと、そのプログラムが動作しているときにアクセスされます。

ctypes ライブラリローダーはプログラムが動作しているときのように振る舞い、ランタイムローダーを直接呼び出すのに対し、 find_library() 関数の目的はコンパイラまたはランタイムローダーが行うのと似た方法でライブラリを探し出すことです。 (複数のバージョンの共有ライブラリがあるプラットホームでは、一番最近に見つかったものがロードされます)。

ctypes.util モジュールはロードするライブラリを決めるのに役立つ関数を提供します。

ctypes.util.find_library(name)
ライブラリを見つけてパス名を返そうと試みます。 name は lib のような接頭辞、 .so, .dylib のような接尾辞、あるいは、バージョン番号が何も付いていないライブラリの名前です (これは posix リンカのオプション -l に使われている形式です)。 ライブラリが見つからないときは None を返します。

厳密な機能はシステムに依存します。

Linux では、 find_library() はライブラリファイルを見つけるために外部プログラム (/sbin/ldconfig, gcc, objdump と ld) を実行しようとします。ライブラリファイルのファイル名を返します。

バージョン 3.6 で変更: Linux では、ライブラリを検索する際に、他の方法でライブラリが見つけられない場合は、 LD_LIBRARY_PATH 環境変数の値が使われます

ここに例があります:

>>>
>>> from ctypes.util import find_library
>>> find_library("m")
'libm.so.6'
>>> find_library("c")
'libc.so.6'
>>> find_library("bz2")
'libbz2.so.1.0'
>>>
OS X では、 find_library() はライブラリの位置を探すために、予め定義された複数の命名方法とパスを試し、成功すればフルパスを返します。:

>>>
>>> from ctypes.util import find_library
>>> find_library("c")
'/usr/lib/libc.dylib'
>>> find_library("m")
'/usr/lib/libm.dylib'
>>> find_library("bz2")
'/usr/lib/libbz2.dylib'
>>> find_library("AGL")
'/System/Library/Frameworks/AGL.framework/AGL'
>>>
Windows では、 find_library() はシステムの探索パスに沿って探し、フルパスを返します。しかし、予め定義された命名方法がないため、 find_library("c") のような呼び出しは失敗し、 None を返します。

ctypes で共有ライブラリをラップする場合、 find_library() を使って実行時にライブラリの場所を特定するのではなく、共有ライブラリの名前を開発時に決めておいて、ラッパーモジュールにハードコードする方が良い かもしれません 。

共有ライブラリをロードする
共有ライブラリを Python プロセスへロードする方法はいくつかあります。一つの方法は下記のクラスの一つをインスタンス化することです:

class ctypes.CDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False, winmode=0)
このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は標準 C 呼び出し規約を使用し、 int を返すと仮定されます。

On Windows creating a CDLL instance may fail even if the DLL name exists. When a dependent DLL of the loaded DLL is not found, a OSError error is raised with the message "[WinError 126] The specified module could not be found". This error message does not contain the name of the missing DLL because the Windows API does not return this information making this error hard to diagnose. To resolve this error and determine which DLL is not found, you need to find the list of dependent DLLs and determine which one is not found using Windows debugging and tracing tools.

参考 Microsoft DUMPBIN tool -- A tool to find DLL dependents.
class ctypes.OleDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False, winmode=0)
Windows 用: このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は stdcall 呼び出し規約を使用し、 windows 固有の HRESULT コードを返すと仮定されます。 HRESULT 値には関数呼び出しが失敗したのか成功したのかを特定する情報とともに、補足のエラーコードが含まれます。戻り値が失敗を知らせたならば、 OSError が自動的に送出されます。

バージョン 3.3 で変更: 以前は WindowsError を送出していました。

class ctypes.WinDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False, winmode=0)
Windows 用: このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は stdcall 呼び出し規約を使用し、デフォルトでは int を返すと仮定されます。

Windows CE では標準呼び出し規約だけが使われます。便宜上、このプラットフォームでは、 WinDLL と OleDLL が標準呼び出し規約を使用します。

これらのライブラリがエクスポートするどの関数でも呼び出す前に Python global interpreter lock は解放され、後でまた獲得されます。

class ctypes.PyDLL(name, mode=DEFAULT_MODE, handle=None)
Python GIL が関数呼び出しの間解放 されず 、関数実行の後に Python エラーフラグがチェックされるということを除けば、このクラスのインスタンスは CDLL インスタンスのように振る舞います。エラーフラグがセットされた場合、 Python 例外が送出されます。

要するに、これは Python C api 関数を直接呼び出すのに便利だというだけです。

これらすべてのクラスは少なくとも一つの引数、すなわちロードする共有ライブラリのパスを渡して呼び出すことでインスタンス化されます。すでにロード済みの共有ライブラリへのハンドルがあるなら、 handle 名前付き引数として渡すことができます。土台となっているプラットフォームの dlopen または LoadLibrary 関数がプロセスへライブラリをロードするために使われ、そのライブラリに対するハンドルを得ます。

mode パラメータを使うと、ライブラリがどうやってロードされたかを特定できます。 詳細は dlopen(3) マニュアルページを参考にしてください。 Windows では mode は無視されます。 POSIX システムでは RTLD_NOW が常に追加され、設定変更はできません。

use_errno 変数が真に設定されたとき、システムの errno エラーナンバーに安全にアクセスする ctypes の仕組みが有効化されます。 ctypes はシステムの errno 変数のスレッド限定のコピーを管理します。もし、 use_errno=True の状態で作られた外部関数を呼び出したなら、関数呼び出し前の errno 変数は ctypes のプライベートコピーと置き換えられ、同じことが関数呼び出しの直後にも発生します。

ctypes.get_errno() 関数は ctypes のプライベートコピーの値を返します。そして、 ctypes.set_errno() 関数は ctypes のプライベートコピーを置き換え、以前の値を返します。

use_last_error パラメータは、真に設定されたとき、 GetLastError() と SetLastError() Windows API によって管理される Windows エラーコードに対するのと同じ仕組みが有効化されます。 ctypes.get_last_error() と ctypes.set_last_error() は Windows エラーコードの ctypes プライベートコピーを変更したり要求したりするのに使われます。

The winmode parameter is used on Windows to specify how the library is loaded (since mode is ignored). It takes any value that is valid for the Win32 API LoadLibraryEx flags parameter. When omitted, the default is to use the flags that result in the most secure DLL load to avoiding issues such as DLL hijacking. Passing the full path to the DLL is the safest way to ensure the correct library and dependencies are loaded.

バージョン 3.8 で変更: Added winmode parameter.

ctypes.RTLD_GLOBAL
mode パラメータとして使うフラグ。このフラグが利用できないプラットフォームでは、整数のゼロと定義されています。

ctypes.RTLD_LOCAL
mode パラメータとして使うフラグ。これが利用できないプラットフォームでは、 RTLD_GLOBAL と同様です。

ctypes.DEFAULT_MODE
共有ライブラリをロードするために使われるデフォルトモード。 OSX 10.3 では RTLD_GLOBAL であり、そうでなければ RTLD_LOCAL と同じです。

これらのクラスのインスタンスには公開メソッドはありません。 共有ライブラリからエクスポートされた関数は、属性として、もしくは添字でアクセスできます。 属性を通した関数へのアクセスは結果がキャッシュされ、従って繰り返しアクセスされると毎回同じオブジェクトを返すことに注意してください。 それとは反対に、添字を通したアクセスは毎回新しいオブジェクトを返します:

>>>
>>> from ctypes import CDLL
>>> libc = CDLL("libc.so.6")  # On Linux
>>> libc.time == libc.time
True
>>> libc['time'] == libc['time']
False
次に述べる公開属性が利用できます。それらの名前はエクスポートされた関数名に衝突しないように下線で始まります。:

PyDLL._handle
ライブラリへのアクセスに用いられるシステムハンドル。

PyDLL._name
コンストラクタに渡されたライブラリの名前。

共有ライブラリは (LibraryLoader クラスのインスタンスである) 前もって作られたオブジェクトの一つを使うことによってロードすることもできます。それらの LoadLibrary() メソッドを呼び出すか、ローダーインスタンスの属性としてライブラリを取り出すかのどちらかによりロードします。

class ctypes.LibraryLoader(dlltype)
共有ライブラリをロードするクラス。 dlltype は CDLL 、 PyDLL 、 WinDLL もしくは OleDLL 型の一つであるべきです。

__getattr__() は次のような特別なはたらきをします。ライブラリローダーインスタンスの属性として共有ライブラリにアクセスするとそれがロードされるということを可能にします。結果はキャッシュされます。そのため、繰り返し属性アクセスを行うといつも同じライブラリが返されます。

LoadLibrary(name)
共有ライブラリをプロセスへロードし、それを返します。このメソッドはライブラリの新しいインスタンスを常に返します。

これらの前もって作られたライブラリローダーを利用することができます。:

ctypes.cdll
CDLL インスタンスを作ります。

ctypes.windll
Windows 用: WinDLL インスタンスを作ります。

ctypes.oledll
Windows 用: OleDLL インスタンスを作ります。

ctypes.pydll
PyDLL インスタンスを作ります。

C Python api に直接アクセスするために、すぐに使用できる Python 共有ライブラリオブジェクトが次のように用意されています。

ctypes.pythonapi
属性として Python C api 関数を公開する PyDLL のインスタンス。これらすべての関数は C int を返すと仮定されますが、もちろん常に正しいとは限りません。そのため、これらの関数を使うためには正しい restype 属性を代入しなければなりません。

Loading a library through any of these objects raises an auditing event ctypes.dlopen with string argument name, the name used to load the library.

Accessing a function on a loaded library raises an auditing event ctypes.dlsym with arguments library (the library object) and name (the symbol's name as a string or integer).

In cases when only the library handle is available rather than the object, accessing a function raises an auditing event ctypes.dlsym/handle with arguments handle (the raw library handle) and name.

外部関数
前節で説明した通り、外部関数はロードされた共有ライブラリの属性としてアクセスできます。デフォルトではこの方法で作成された関数オブジェクトはどんな数の引数でも受け取り、引数としてどんな ctypes データのインスタンスをも受け取り、そして、ライブラリローダーが指定したデフォルトの結果の値の型を返します。関数オブジェクトはプライベートクラスのインスタンスです。:

class ctypes._FuncPtr
C の呼び出し可能外部関数のためのベースクラス。

外部関数のインスタンスも C 互換データ型です。それらは C の関数ポインタを表しています。

この振る舞いは外部関数オブジェクトの特別な属性に代入することによって、カスタマイズすることができます。

restype
外部関数の結果の型を指定するために ctypes 型を代入する。何も返さない関数を表す void に対しては None を使います。

ctypes 型ではない呼び出し可能な Python オブジェクトを代入することは可能です。このような場合、関数が C int を返すと仮定され、呼び出し可能オブジェクトはこの整数を引数に呼び出されます。さらに処理を行ったり、エラーチェックをしたりできるようにするためです。これの使用は推奨されません。より柔軟な後処理やエラーチェックのためには restype として ctypes 型を使い、 errcheck 属性へ呼び出し可能オブジェクトを代入してください。

argtypes
関数が受け取る引数の型を指定するために ctypes 型のタプルを代入します。stdcall 呼び出し規約を使う関数はこのタプルの長さと同じ数の引数で呼び出されます。C 呼び出し規約を使う関数は、追加の不特定の引数も取ります。

外部関数が呼ばれたとき、それぞれの実引数は argtypes タプルの要素の from_param() クラスメソッドへ渡されます。このメソッドは実引数を外部関数が受け取るオブジェクトに合わせて変えられるようにします。例えば、 argtypes タプルの c_char_p 要素は、 ctypes 変換規則にしたがって引数として渡された文字列をバイト列オブジェクトへ変換するでしょう。

新: ctypes 型でない要素を argtypes に入れることができますが、個々の要素は引数として使える値 (整数、文字列、 ctypes インスタンス) を返す from_param() メソッドを持っていなければなりません。これにより関数パラメータとしてカスタムオブジェクトを適合するように変更できるアダプタが定義可能となります。

errcheck
Python 関数または他の呼び出し可能オブジェクトをこの属性に代入します。呼び出し可能オブジェクトは三つ以上の引数とともに呼び出されます。

callable(result, func, arguments)
result は外部関数が返すもので、 restype 属性で指定されます。

func は外部関数オブジェクト自身で、これにより複数の関数の処理結果をチェックまたは後処理するために、同じ呼び出し可能オブジェクトを再利用できるようになります。

arguments は関数呼び出しに最初に渡されたパラメータが入ったタプルです。これにより使われた引数に基づいた特別な振る舞いをさせることができるようになります。

この関数が返すオブジェクトは外部関数呼び出しから返された値でしょう。しかし、戻り値をチェックして、外部関数呼び出しが失敗しているなら例外を送出させることもできます。

exception ctypes.ArgumentError
この例外は外部関数呼び出しが渡された引数を変換できなかったときに送出されます。

On Windows, when a foreign function call raises a system exception (for example, due to an access violation), it will be captured and replaced with a suitable Python exception. Further, an auditing event ctypes.seh_exception with argument code will be raised, allowing an audit hook to replace the exception with its own.

Some ways to invoke foreign function calls may raise an auditing event ctypes.call_function with arguments function pointer and arguments.

関数プロトタイプ
外部関数は関数プロトタイプをインスタンス化することによって作成されます。 関数プロトタイプは C の関数プロトタイプと似ています。実装は定義せずに、関数 (返り値の型、引数の型、呼び出し規約) を記述します。 ファクトリ関数は、その関数に要求される返り値の型と引数の型とともに呼び出されます。そしてこの関数はデコレータファクトリとしても使え、 @wrapper 構文で他の関数に適用できます。 例については コールバック関数 を参照してください。

ctypes.CFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)
返された関数プロトタイプは標準 C 呼び出し規約をつかう関数を作成します。関数は呼び出されている間 GIL を解放します。 use_errno が真に設定されれば、呼び出しの前後で System 変数 errno の ctypesプライベートコピーは本当の errno の値と交換されます。 use_last_error も Windows エラーコードに対するのと同様です。

ctypes.WINFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)
Windows のみ: 返された関数プロトタイプは stdcall 呼び出し規約を使う関数を作成します。ただし、 WINFUNCTYPE() が CFUNCTYPE() と同じである Windows CE を除きます。関数は呼び出されている間 GIL を解放します。 use_errno と use_last_error は前述と同じ意味を持ちます。

ctypes.PYFUNCTYPE(restype, *argtypes)
返された関数プロトタイプは Python 呼び出し規約を使う関数を作成します。関数は呼び出されている間 GIL を解放 しません。

ファクトリ関数によって作られた関数プロトタイプは呼び出しのパラメータの型と数に依存した別の方法でインスタンス化することができます。 :

prototype(address)
指定されたアドレス(整数でなくてはなりません)の外部関数を返します。

prototype(callable)
Python の callable から C の呼び出し可能関数(コールバック関数) を作成します。

prototype(func_spec[, paramflags])
共有ライブラリがエクスポートしている外部関数を返します。 func_spec は 2 要素タプル (name_or_ordinal, library) でなければなりません。第一要素はエクスポートされた関数の名前である文字列、またはエクスポートされた関数の序数である小さい整数です。第二要素は共有ライブラリインスタンスです。

prototype(vtbl_index, name[, paramflags[, iid]])
COM メソッドを呼び出す外部関数を返します。 vtbl_index は仮想関数テーブルのインデックスで、非負の小さい整数です。 name は COM メソッドの名前です。 iid はオプションのインターフェイス識別子へのポインタで、拡張されたエラー情報の提供のために使われます。

COM メソッドは特殊な呼び出し規約を用います。このメソッドは argtypes タプルに指定されたパラメータに加えて、第一引数として COM インターフェイスへのポインタを必要とします。

オプションの paramflags パラメータは上述した機能より多機能な外部関数ラッパーを作成します。

paramflags は argtypes と同じ長さのタプルでなければなりません。

このタプルの個々の要素はパラメータについてのより詳細な情報を持ち、 1 、 2 もしくは 3 要素を含むタプルでなければなりません。

第一要素はパラメータについてのフラグの組み合わせを含んだ整数です。

1
入力パラメータを関数に指定します。

2
出力パラメータ。外部関数が値を書き込みます。

4
デフォルトで整数ゼロになる入力パラメータ。

オプションの第二要素はパラメータ名の文字列です。これが指定された場合は、外部関数を名前付きパラメータで呼び出すことができます。

オプションの第三要素はこのパラメータのデフォルト値です。

この例では、デフォルトパラメータと名前付き引数をサポートするために Windows の MessageBoxW 関数をラップする方法を示します。 windows のヘッダファイルの C の宣言は次の通りです:

WINUSERAPI int WINAPI
MessageBoxW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);
ctypes を使ってラップします。:

>>>
>>> from ctypes import c_int, WINFUNCTYPE, windll
>>> from ctypes.wintypes import HWND, LPCWSTR, UINT
>>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)
>>> paramflags = (1, "hwnd", 0), (1, "text", "Hi"), (1, "caption", "Hello from ctypes"), (1, "flags", 0)
>>> MessageBox = prototype(("MessageBoxW", windll.user32), paramflags)
これで外部関数の MessageBox を次のような方法で呼び出すことができるようになりました:

>>>
>>> MessageBox()
>>> MessageBox(text="Spam, spam, spam")
>>> MessageBox(flags=2, text="foo bar")
二番目の例は出力パラメータについて説明します。 win32 の GetWindowRect 関数は、指定されたウィンドウの大きさを呼び出し側が与える RECT 構造体へコピーすることで取り出します。 C の宣言はこうです。:

WINUSERAPI BOOL WINAPI
GetWindowRect(
     HWND hWnd,
     LPRECT lpRect);
ctypes を使ってラップします。:

>>>
>>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError
>>> from ctypes.wintypes import BOOL, HWND, RECT
>>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))
>>> paramflags = (1, "hwnd"), (2, "lprect")
>>> GetWindowRect = prototype(("GetWindowRect", windll.user32), paramflags)
>>>
出力パラメータを持つ関数は、単一のパラメータがある場合にはその出力パラメータ値を、複数のパラメータがある場合には出力パラメータ値が入ったタプルを、それぞれ自動的に返します。そのため、GetWindowRect 関数は呼び出されると RECT インスタンスを返します。

さらに出力処理やエラーチェックを行うために、出力パラメータを errcheck プロトコルと組み合わせることができます。 win32 GetWindowRect api 関数は成功したか失敗したかを知らせるために BOOL を返します。そのため、この関数はエラーチェックを行って、 api 呼び出しが失敗した場合に例外を送出させることができます。:

>>>
>>> def errcheck(result, func, args):
...     if not result:
...         raise WinError()
...     return args
...
>>> GetWindowRect.errcheck = errcheck
>>>
errcheck 関数が受け取った引数タプルを変更なしに返した場合、 ctypes は出力パラメータに対する通常の処理を続けます。 RECT インスタンスの代わりに window 座標のタプルを返すには、関数のフィールドを取り出し、代わりにそれらを返すことができます。この場合、通常処理は行われなくなります:

>>>
>>> def errcheck(result, func, args):
...     if not result:
...         raise WinError()
...     rc = args[1]
...     return rc.left, rc.top, rc.bottom, rc.right
...
>>> GetWindowRect.errcheck = errcheck
>>>
ユーティリティー関数
ctypes.addressof(obj)
メモリバッファのアドレスを示す整数を返します。 obj は ctypes 型のインスタンスでなければなりません。

Raises an auditing event ctypes.addressof with argument obj.

ctypes.alignment(obj_or_type)
ctypes 型のアライメントの必要条件を返します。 obj_or_type は ctypes 型またはインスタンスでなければなりません。

ctypes.byref(obj[, offset])
obj (ctypes 型のインスタンスでなければならない) への軽量ポインタを返します。 offset はデフォルトでは 0 で、内部ポインターへ加算される整数です。

byref(obj, offset) は、 C コードとしては、以下のようにみなされます。:

(((char *)&obj) + offset)
返されるオブジェクトは外部関数呼び出しのパラメータとしてのみ使用できます。pointer(obj) と似たふるまいをしますが、作成が非常に速く行えます。

ctypes.cast(obj, type)
この関数は C のキャスト演算子に似ています。obj と同じメモリブロックを指している type の新しいインスタンスを返します。type はポインタ型でなければならず、obj はポインタとして解釈できるオブジェクトでなければなりません。

ctypes.create_string_buffer(init_or_size, size=None)
この関数は変更可能な文字バッファを作成します。返されるオブジェクトは c_char の ctypes 配列です。

init_or_size は配列のサイズを指定する整数もしくは配列要素を初期化するために使われるバイト列オブジェクトである必要があります。

バイト列オブジェクトが第一引数として指定されていた場合、配列の最後の要素が NUL 終端文字となるように、バイト列オブジェクトの長さより 1 つ長いバッファを作成します。バイト列の長さを使うべきではない場合は、第二引数として整数を渡して、配列の長さを指定することができます。

Raises an auditing event ctypes.create_string_buffer with arguments init, size.

ctypes.create_unicode_buffer(init_or_size, size=None)
この関数は変更可能な Unicode 文字バッファを作成します。返されるオブジェクトは c_wchar の ctypes 配列です。

init_or_size は配列のサイズを指定する整数もしくは配列要素を初期化するために使われる文字列である必要があります。

第一引数として文字列が指定された場合は、バッファが文字列の長さより一要素分大きく作られます。配列の最後の要素が NUL 終端文字であるためです。文字列の長さを使うべきでない場合は、配列のサイズを指定するために整数を第二引数として渡すことができます。

Raises an auditing event ctypes.create_unicode_buffer with arguments init, size.

ctypes.DllCanUnloadNow()
Windows 用: この関数は ctypes をつかってインプロセス COM サーバーを実装できるようにするためのフックです。_ctypes 拡張 dll がエクスポートしている DllCanUnloadNow 関数から呼び出されます。

ctypes.DllGetClassObject()
Windows 用: この関数は ctypes をつかってインプロセス COM サーバーを実装できるようにするためのフックです。_ctypes 拡張 dll がエクスポートしている DllGetClassObject 関数から呼び出されます。

ctypes.util.find_library(name)
ライブラリを検索し、パス名を返します。 name は lib のような接頭辞、 .so や .dylib のような接尾辞、そして、バージョンナンバーを除くライブラリ名です (これは posix のリンカーオプション -l で使われる書式です) 。もしライブラリが見つからなければ、 None を返します。

厳密な機能はシステムに依存します。

ctypes.util.find_msvcrt()
Windows 用: Python と拡張モジュールで使われる VC ランタイムライブラリのファイル名を返します。もしライブラリ名が同定できなければ、 None を返します。

もし、例えば拡張モジュールにより割り付けられたメモリを free(void *) で解放する必要があるなら、メモリ割り付けを行ったのと同じライブラリの関数を使うことが重要です。

ctypes.FormatError([code])
Windows 用: エラーコード code の説明文を返します。エラーコードが指定されない場合は、 Windows api 関数 GetLastError を呼び出して、もっとも新しいエラーコードが使われます。

ctypes.GetLastError()
Windows 用: 呼び出し側のスレッド内で Windows によって設定された最新のエラーコードを返します。この関数は Windows の GetLastError() 関数を直接実行します。 ctypes のプライベートなエラーコードのコピーを返したりはしません。

ctypes.get_errno()
システムの errno 変数の、スレッドローカルなプライベートコピーを返します。

Raises an auditing event ctypes.get_errno with no arguments.

ctypes.get_last_error()
Windows 用: システムの LastError 変数の、スレッドローカルなプライベートコピーを返します。

Raises an auditing event ctypes.get_last_error with no arguments.

ctypes.memmove(dst, src, count)
標準 C の memmove ライブラリ関数と同じものです。: count バイトを src から dst へコピーします。 dst と src はポインタへ変換可能な整数または ctypes インスタンスでなければなりません。

ctypes.memset(dst, c, count)
標準 C の memset ライブラリ関数と同じものです。: アドレス dst のメモリブロックを値 c を count バイト分書き込みます。 dst はアドレスを指定する整数または ctypes インスタンスである必要があります。

ctypes.POINTER(type)
このファクトリ関数は新しい ctypes ポインタ型を作成して返します。ポインタ型はキャッシュされ、内部で再利用されます。したがって、この関数を繰り返し呼び出してもコストは小さいです。type は ctypes 型でなければなりません。

ctypes.pointer(obj)
この関数は obj を指す新しいポインタインスタンスを作成します。戻り値は POINTER(type(obj)) 型のオブジェクトです。

注意: 外部関数呼び出しへオブジェクトへのポインタを渡したいだけなら、はるかに高速な byref(obj) を使うべきです。

ctypes.resize(obj, size)
この関数は obj の内部メモリバッファのサイズを変更します。 obj は ctypes 型のインスタンスでなければなりません。バッファを sizeof(type(obj)) で与えられるオブジェクト型の本来のサイズより小さくすることはできませんが、バッファを拡大することはできます。

ctypes.set_errno(value)
システム変数 errno の、呼び出し元スレッドでの ctypes のプライベートコピーの現在値を value に設定し、前の値を返します。

Raises an auditing event ctypes.set_errno with argument errno.

ctypes.set_last_error(value)
Windows 用: システム変数 LastError の、呼び出し元スレッドでの ctypes のプライベートコピーの現在値を value に設定し、前の値を返します。

Raises an auditing event ctypes.set_last_error with argument error.

ctypes.sizeof(obj_or_type)
ctypes の型やインスタンスのメモリバッファのサイズをバイト数で返します。C の sizeof 演算子と同様の動きをします。

ctypes.string_at(address, size=-1)
この関数はメモリアドレス address から始まる C 文字列を返します。size が指定された場合はサイズとして使われます。指定されなければ、文字列がゼロ終端されていると仮定します。

Raises an auditing event ctypes.string_at with arguments address, size.

ctypes.WinError(code=None, descr=None)
Windows 用: この関数はおそらく ctypes の中で最悪の名前でしょう。これは OSError のインスタンスを作成します。 code が指定されていなかった場合、エラーコードを判別するために GetLastError が呼び出されます。 descr が指定されていなかった場合、エラーの説明文を得るために FormatError() が呼び出されます。

バージョン 3.3 で変更: 以前は WindowsError インスタンスが作成されていました。

ctypes.wstring_at(address, size=-1)
この関数は文字列としてメモリアドレス address から始まるワイドキャラクタ文字列を返します。size が指定されたならば、文字列の文字数として使われます。指定されなければ、文字列がゼロ終端されていると仮定します。

Raises an auditing event ctypes.wstring_at with arguments address, size.

データ型
class ctypes._CData
この非公開クラスはすべての ctypes データ型の共通のベースクラスです。他のことはさておき、すべての ctypes 型インスタンスは C 互換データを保持するメモリブロックを内部に持ちます。このメモリブロックのアドレスは addressof() ヘルパー関数が返します。別のインスタンス変数が _objects として公開されます。これはメモリブロックがポインタを含む場合に存続し続ける必要のある他の Python オブジェクトを含んでいます。

ctypes データ型の共通メソッド、すべてのクラスメソッドが存在します (正確には、 メタクラス のメソッドです):

from_buffer(source[, offset])
このメソッドは source オブジェクトのバッファを共有する ctypes のインスタンスを返します。 source オブジェクトは書き込み可能バッファインターフェースをサポートしている必要があります。オプションの offset 引数では source バッファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし source バッファが十分に大きくなければ、 ValueError が送出されます。

Raises an auditing event ctypes.cdata/buffer with arguments pointer, size, offset.

from_buffer_copy(source[, offset])
このメソッドは source オブジェクトの読み出し可能バッファをコピーすることで、ctypes のインスタンスを生成します。オプションの offset 引数では source バッファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし source バッファが十分に大きくなければ、 ValueError が送出されます。

Raises an auditing event ctypes.cdata/buffer with arguments pointer, size, offset.

from_address(address)
このメソッドは address で指定されたメモリを使って ctypes 型のインスタンスを返します。 address は整数でなければなりません。

This method, and others that indirectly call this method, raises an auditing event ctypes.cdata with argument address.

from_param(obj)
このメソッドは obj を ctypes 型に適合させます。外部関数の argtypes タプルに、その型があるとき、外部関数呼び出しで実際に使われるオブジェクトと共に呼び出されます。

すべての ctypes のデータ型は、それが型のインスタンスであれば、 obj を返すこのクラスメソッドのデフォルトの実装を持ちます。いくつかの型は、別のオブジェクトも受け付けます。

in_dll(library, name)
このメソッドは、共有ライブラリによってエクスポートされた ctypes 型のインスタンスを返します。 name はエクスポートされたデータの名前で、 library はロードされた共有ライブラリです。

ctypes データ型共通のインスタンス変数:

_b_base_
ctypes 型データのインスタンスは、それ自身のメモリブロックを持たず、基底オブジェクトのメモリブロックの一部を共有することがあります。 _b_base_ 読み出し専用属性は、メモリブロックを保持する ctypes の基底オブジェクトです。

_b_needsfree_
この読み出し専用の変数は、 ctypes データインスタンスが、それ自身に割り当てられたメモリブロックを持つとき true になります。それ以外の場合は false になります。

_objects
このメンバは None 、または、メモリブロックの内容が正しく保つために、生存させておかなくてはならない Python オブジェクトを持つディクショナリです。このオブジェクトはデバッグでのみ使われます。決してディクショナリの内容を変更しないで下さい。

基本データ型
class ctypes._SimpleCData
この非公開クラスは、全ての基本的な ctypes データ型の基底クラスです。これは基本的な ctypes データ型に共通の属性を持っているので、ここで触れておきます。 _SimpleCData は _CData の子クラスなので、そのメソッドと属性を継承しています。ポインタでないかポインタを含まない ctypes データ型は、現在は pickle 化できます。

インスタンスは一つだけ属性を持ちます:

value
この属性は、インスタンスの実際の値を持ちます。整数型とポインタ型に対しては整数型、文字型に対しては一文字のバイト列オブジェクト、文字へのポインタに対しては Python のバイト列オブジェクトもしくは文字列となります。

value 属性が ctypes インスタンスより参照されたとき、大抵の場合はそれぞれに対し新しいオブジェクトを返します。 ctypes はオリジナルのオブジェクトを返す実装にはなって おらず 新しいオブジェクトを構築します。同じことが他の ctypes オブジェクトインスタンスに対しても言えます。

基本データ型は、外部関数呼び出しの結果として返されたときや、例えば構造体のフィールドメンバーや配列要素を取り出すときに、ネイティブの Python 型へ透過的に変換されます。言い換えると、外部関数が c_char_p の restype を持つ場合は、 c_char_p インスタンスでは なく 常に Python バイト列オブジェクトを受け取ることでしょう。

基本データ型のサブクラスはこの振る舞いを継承 しません 。したがって、外部関数の restype が c_void_p のサブクラスならば、関数呼び出しからこのサブクラスのインスタンスを受け取ります。もちろん、 value 属性にアクセスしてポインタの値を得ることができます。

これらが基本 ctypes データ型です:

class ctypes.c_byte
C の signed char データ型を表し、小整数として値を解釈します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_char
C char データ型を表し、単一の文字として値を解釈します。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の長さちょうど一文字である必要があります。

class ctypes.c_char_p
C char * データ型を表し、ゼロ終端文字列へのポインタでなければなりません。バイナリデータを指す可能性のある一般的なポインタに対しては POINTER(c_char) を使わなければなりません。コンストラクタは整数のアドレスもしくはバイト列オブジェクトを受け取ります。

class ctypes.c_double
C double データ型を表します。コンストラクタはオプションの浮動小数点数初期化子を受け取ります。

class ctypes.c_longdouble
C long double データ型を表します。コンストラクタはオプションで浮動小数点数初期化子を受け取ります。 sizeof(long double) == sizeof(double) であるプラットフォームでは c_double の別名です。

class ctypes.c_float
C float データ型を表します。コンストラクタはオプションの浮動小数点数初期化子を受け取ります。

class ctypes.c_int
C signed int データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。 sizeof(int) == sizeof(long) であるプラットフォームでは、 c_long の別名です。

class ctypes.c_int8
C 8-bit signed int データ型を表します。たいていは、 c_byte の別名です。

class ctypes.c_int16
C 16-bit signed int データ型を表します。たいていは、 c_short の別名です。

class ctypes.c_int32
C 32-bit signed int データ型を表します。たいていは、 c_int の別名です。

class ctypes.c_int64
C 64-bit signed int データ型を表します。たいていは、 c_longlong の別名です。

class ctypes.c_long
C signed long データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_longlong
C signed long long データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_short
C signed short データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_size_t
C size_t データ型を表します。

class ctypes.c_ssize_t
C ssize_t データ型を表します。

バージョン 3.2 で追加.

class ctypes.c_ubyte
C の unsigned char データ型を表し、小さな整数として値を解釈します。コンストラクタはオプションの整数初期化子を受け取ります; オーバーフローのチェックは行われません。

class ctypes.c_uint
C の unsigned int データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります; オーバーフローのチェックは行われません。これは、 sizeof(int) == sizeof(long) であるプラットフォームでは c_ulong の別名です。

class ctypes.c_uint8
C 8-bit unsigned int データ型を表します。たいていは、 c_ubyte の別名です。

class ctypes.c_uint16
C 16-bit unsigned int データ型を表します。たいていは、 c_ushort の別名です。

class ctypes.c_uint32
C 32-bit unsigned int データ型を表します。たいていは、 c_uint の別名です。

class ctypes.c_uint64
C 64-bit unsigned int データ型を表します。たいていは、 c_ulonglong の別名です。

class ctypes.c_ulong
C unsigned long データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_ulonglong
C unsigned long long データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_ushort
C unsigned short データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。

class ctypes.c_void_p
C void * データ型を表します。値は整数として表されます。コンストラクタはオプションの整数初期化子を受け取ります。

class ctypes.c_wchar
C wchar_t データ型を表し、値は Unicode 文字列の単一の文字として解釈されます。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の長さはちょうど一文字である必要があります。

class ctypes.c_wchar_p
C wchar_t * データ型を表し、ゼロ終端ワイド文字列へのポインタでなければなりません。コンストラクタは整数のアドレスもしくは文字列を受け取ります。

class ctypes.c_bool
C の bool データ型 (より正確には、 C99 以降の _Bool) を表します。 True または False の値を持ち、コンストラクタは真偽値と解釈できるオブジェクトを受け取ります。

class ctypes.HRESULT
Windows用: HRESULT 値を表し、関数またはメソッド呼び出しに対する成功またはエラーの情報を含んでいます。

class ctypes.py_object
C PyObject * データ型を表します。引数なしでこれを呼び出すと NULL PyObject * ポインタを作成します。

ctypes.wintypes モジュールは他の Windows 固有のデータ型を提供します。例えば、 HWND, WPARAM, DWORD です。 MSG や RECT のような有用な構造体も定義されています。

構造化データ型
class ctypes.Union(*args, **kw)
ネイティブのバイトオーダーでの共用体のための抽象ベースクラス。

class ctypes.BigEndianStructure(*args, **kw)
ビックエンディアン バイトオーダーでの構造体のための抽象ベースクラス。

class ctypes.LittleEndianStructure(*args, **kw)
リトルエンディアン バイトオーダーでの構造体のための抽象ベースクラス。

ネイティブではないバイトオーダーを持つ構造体にポインタ型フィールドあるいはポインタ型フィールドを含む他のどんなデータ型をも入れることはできません。

class ctypes.Structure(*args, **kw)
ネイティブ のバイトオーダーでの構造体のための抽象ベースクラス。

具象構造体型と具象共用体型はこれらの型の一つをサブクラス化することで作らなければなりません。少なくとも、 _fields_ クラス変数を定義する必要があります。 ctypes は、属性に直接アクセスしてフィールドを読み書きできるようにする デスクリプタ を作成するでしょう。これらは、

_fields_
構造体のフィールドを定義するシーケンス。要素は2要素タプルか3要素タプルでなければなりません。第一要素はフィールドの名前です。第二要素はフィールドの型を指定します。それはどんな ctypes データ型でも構いません。

c_int のような整数型のために、オプションの第三要素を与えることができます。フィールドのビット幅を定義する正の小整数である必要があります。

一つの構造体と共用体の中で、フィールド名はただ一つである必要があります。これはチェックされません。名前が繰り返しでてきたときにアクセスできるのは一つのフィールドだけです。

Structure サブクラスを定義するクラス文の 後で 、 _fields_ クラス変数を定義することができます。これにより、次のように自身を直接または間接的に参照するデータ型を作成できるようになります:

class List(Structure):
    pass
List._fields_ = [("pnext", POINTER(List)),
                 ...
                ]
しかし、 _fields_ クラス変数はその型が最初に使われる (インスタンスが作成される、それに対して sizeof() が呼び出されるなど) より前に定義されていなければなりません。その後 _fields_ クラス変数へ代入すると AttributeError が送出されます。

構造体型のサブクラスのサブクラスを定義することもでき、もしあるならサブクラスのサブクラス内で定義された _fields_ に加えて、基底クラスのフィールドも継承します。

_pack_
インスタンスの構造体フィールドのアライメントを上書きできるようにするオブションの小整数。 _pack_ は _fields_ が代入されたときすでに定義されていなければなりません。そうでなければ、何の効果もありません。

_anonymous_
無名 (匿名) フィールドの名前が並べあげられたオプションのシーケンス。 _fields_ が代入されたとき、 _anonymous_ がすでに定義されていなければなりません。そうでなければ、何ら影響はありません。

この変数に並べあげられたフィールドは構造体型もしくは共用体型フィールドである必要があります。構造体フィールドまたは共用体フィールドを作る必要なく、入れ子になったフィールドに直接アクセスできるようにするために、 ctypes は構造体型の中に記述子を作成します。

型の例です (Windows):

class _U(Union):
    _fields_ = [("lptdesc", POINTER(TYPEDESC)),
                ("lpadesc", POINTER(ARRAYDESC)),
                ("hreftype", HREFTYPE)]

class TYPEDESC(Structure):
    _anonymous_ = ("u",)
    _fields_ = [("u", _U),
                ("vt", VARTYPE)]
TYPEDESC 構造体はCOMデータ型を表現しており、 vt フィールドは共用体フィールドのどれが有効であるかを指定します。 u フィールドは匿名フィールドとして定義されているため、 TYPEDESC インスタンスから取り除かれてそのメンバーへ直接アクセスできます。 td.lptdesc と td.u.lptdesc は同等ですが、前者がより高速です。なぜなら一時的な共用体インスタンスを作る必要がないためです。:

td = TYPEDESC()
td.vt = VT_PTR
td.lptdesc = POINTER(some_type)
td.u.lptdesc = POINTER(some_type)
構造体のサブクラスのサブクラスを定義することができ、基底クラスのフィールドを継承します。 サブクラス定義に別の _fields_ 変数がある場合は、この中で指定されたフィールドは基底クラスのフィールドへ追加されます。

構造体と共用体のコンストラクタは位置引数とキーワード引数の両方を受け取ります。位置引数は _fields_ の中に現れたのと同じ順番でメンバーフィールドを初期化するために使われます。コンストラクタのキーワード引数は属性代入として解釈され、そのため、同じ名前をもつ _fields_ を初期化するか、 _fields_ に存在しない名前に対しては新しい属性を作ります。

配列とポインタ
class ctypes.Array(*args)
配列のための抽象基底クラスです。

具象配列型を作成するための推奨される方法は、任意の ctypes データ型に正の整数を乗算することです。代わりに、この型のサブクラスを作成し、 _length_ と _type_ のクラス変数を定義することもできます。配列の要素は、標準の添え字とスライスによるアクセスを使用して読み書きを行うことができます。スライスの読み込みでは、結果のオブジェクト自体は Array ではありません。

_length_
配列の要素数を指定する正の整数。範囲外の添え字を指定すると、 IndexError が送出されます。len() がこの整数を返します。

_type_
配列内の各要素の型を指定します。

配列のサブクラスのコンストラクタは、位置引数を受け付けて、配列を順番に初期化するために使用します。

class ctypes._Pointer
ポインタのためのプライベートな抽象基底クラスです。

具象ポインタ型は、ポイント先の型を持つ POINTER() を呼び出すことで、作成できます。これは、 pointer() により自動的に行われます。

ポインタが配列を指す場合、その配列の要素は、標準の添え字とスライスによるアクセスを使用して読み書きが行えます。ポインタオブジェクトには、サイズがないため、 len() 関数は TypeError を送出します。負の添え字は、(C と同様に) ポインタの 前 のメモリから読み込み、範囲外の添え字はおそらく (幸運な場合でも) アクセス違反によりクラッシュを起こします。

_type_
ポイント先の型を指定します。

contents
ポインタが指すオブジェクトを返します。この属性に割り当てると、ポインタが割り当てられたオブジェクトを指すようになります。


