\chapter{ソートとアルゴリズム選択}

今回は、ソートアルゴリズムを題材にして、
**アルゴリズム選択**を考えてみます。

## ソートとは？

**ソート(整列)**{sort} とは、順番をそろえて並び替える操作です。

例えば、 次のような数列を**昇順に**ソートすると:

**(Before)**
\[
5, 3, 1, 9, 8, 0, 4, 2, 7, 6
\]

**(After)**
\[
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
\]

\begin{lbox}{ソートの順序}
日常よく用いる「小さい順」と呼ばず、
英語圏の「値が大きくなっていく様子」から昇順と呼びます。

* **昇順ソート**{ascending sort} -- $x < y$ の順序で並べる
* **降順ソート**{descending sort} -- $x > y$ の順序で並べる
\end{lbox}

ランキングや大学入試の合格者判定など、
ソートは日常のあらゆる場面で活用されているアルゴリズムと言えます。

## ソート・ライブラリ

Pythonは、リストに対してソートを行う手段を２つ提供しています。

**メソッド**: リスト`L`を書き換えてソートする
```py
L.sort()
```
**組込み関数**: リスト`L`を書き換えず、
ソートされた新しいリストを返す
```py
L2 = sorted(L)
```

ソートは、数値だけでなく、$x < y$ が定義されている集まり、
つまり**全順序集合**{total ordered set}に対して行うことができます。
Python では、文字列もタプルも比較演算子で比較できるため、
リストの要素が全て比較できるときはソート可能です。

```py
"A" < "B"
```
```py
(1, 1) < (1, 2)
```

日常のPython プログラミングでは、
このようなソート・ライブラリを活用すれば充分です。


\HBold{例題（ソート）}
Aさん、Bさん、Cさん、Dさん、Eさんの成績データがリストSで与えられています。
成績の良い順に並べて表示してみてください。

```py
S = [
('A', 75), ('B', 66), ('C', 75), ('D', 95), ('E', 83)
]
```


そのまま、Sをソートすると名前順で並べらられるので、
(75, 'A')の順でペアを作り直して、ソートします。

\Run{点数が高い方からソートする}
```py
I = []
for name, score in S:
I.append((score, name))
I.sort() #ソートする
I.reverse() #逆順に
for score, name in I:
print(name, score)
```
\Out
```py
D 95
E 83
C 75
A 75
B 66
```

このようにデータ構造の方を工夫すると、
ソートライブラリで活用して解くことができます。

<div class="alert alert-info">

車輪を再発明しない

まずは、既存のライブラリを最大限活用する方法を考えよう
</div>

授業でアルゴリズムを学ぶと、アルゴリズムは自分で実装した方がいいと
勘違いして、そのまま社会人になったりします。
「車輪を再発明しない」は、**そうじゃないんだよ**という格言です。
ただし、皆さんは、まだまだ教育リーグにいるので、
**アルゴリズムの理解を深めるために**
車輪を再発明してみないと理解できません。

## ソート・アルゴリズム

ソート・アルゴリズムは、ソートを実現するための手順です。
ソートは、{\CS}の題材として研究が行われ、
様々な種類のアルゴリズムが考案されてきました。

**本講義で扱うアルゴリム**
* 選択ソート（本章）
* バブルソート（本章）
* クイックソート（本章）
* マージソート（次章）


**有名なアルゴリム**
* 挿入ソート
* ヒープソート
* ビンソート
* ボゴソート

<div class="alert alert-info">

まだまだあります

\url{http://ja.wikipedia.org/wiki/ソート}
</div>

### 準備：スワップ操作


ソートアルゴリズムでは、
共通する操作として**スワップ**{swap}が登場します。

**スワップ** : 2つの変数の値を入れ替える操作


\begin{center}
\includegraphics[width=0.20\paperwidth]{figs/swap1.pdf}
\end{center}


スワップは、次の２通りの方法で行えます。

**一時変数(temp)を用いる**
```py
temp = x
x = y
y = temp
```
**多重代入を用いる**
```py
x, y = y, x
```

Python は、多重代入できるので、多重代入を用います。
ただし、多重代入が使えない言語もあるので、一時変数を用いる方法も覚えておきましょう。

ソートアルゴリズムでは、リスト要素のスワップを頻繁に用いることになります。
リストの要素は、変数と同様に多重代入でスワップできます。

\begin{center}
\includegraphics[width=0.38\paperwidth]{figs/swap2.pdf}
\end{center}
```py
a[i], a[j] = a[j], a[i]
```


\HBold{例題（リストの逆順）}
スワップを用いて、リストを逆順に変換してみよう。

**(Before)**
\[
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\]

**(After)**
\[
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
\]


\HBold{ヒント} Python では、`a[-1]`は最後尾の要素になります。

```py
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in range(len(a)//2):
a[i], a[-(1+i)] = a[-(1+i)], a[i]
print(a)
```
```py



[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```





## 選択ソート

**選択ソート**{selection sort} は、
配列 a の中から一番小さな要素を探し、それを先頭の要素とスワップすることでソートします。
**もっとも人間の思考に近い**ソートアルゴリズムと言えます。

\begin{center}
\includegraphics[width=9cm]{figs/selectSort.pdf}
\end{center}

最も小さいソートを先頭にもってくることができたら、
先頭をひとつ進め、同じ要領で繰り返していきます。
次は、まずstart以降のリストaの要素から
最小となる位置を探す関数`find_min_index(a, start)`を定義しています。

\Run{関数定義}
```py
def find_min_index(a, start):
mini = start
for i in range(start+1, len(a)):
if a[i] < a[mini]:
mini = i
return mini

def select_sort(a):
for i in range(len(a)-1):
mini = find_min_index(a, i)
a[i], a[mini] = a[mini], a[i]
print(f'@{i}', a) #デバッグ用の表示
```

\Run{実行}
```py
a = [5, 3, 1, 9, 8, 0, 4, 2, 7, 6]
select_sort(a)
```
\Out
```py
@0 [0, 3, 1, 9, 8, 5, 4, 2, 7, 6]
@1 [0, 1, 3, 9, 8, 5, 4, 2, 7, 6]
@2 [0, 1, 2, 9, 8, 5, 4, 3, 7, 6]
@3 [0, 1, 2, 3, 8, 5, 4, 9, 7, 6]
@4 [0, 1, 2, 3, 4, 5, 8, 9, 7, 6]
@5 [0, 1, 2, 3, 4, 5, 8, 9, 7, 6]
@6 [0, 1, 2, 3, 4, 5, 6, 9, 7, 8]
@7 [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
@8 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

次は、先頭より小さい値がみつかったら、直ぐに先頭とスワップするバージョンです。

\Run{関数定義(別実装)}
```py
def select_sort(a):
for i in range(len(a)-1):
# a[i+1], ..,  a[-1] の中で 一番小さい値を a[i]に選択する
for j in range(i+1, len(a)):
if a[i] > a[j]:
a[i], a[j] = a[j], a[i]
```


## バブルソート

**バブルソート**{bubble sort}は、もっとも実装が簡単（と言われている）ソートアルゴリズムです。

**アルゴリズム**
* 隣り合った**2つの要素 a[i] と a[i+1]** を比較して、a[i] $>$ a[i+1] なら両者をスワップする
* 以上をスワップする必要がなくなるまで繰り返す

\begin{center}
\includegraphics[width=7cm]{figs/bubbleSort.pdf}
\end{center}

<div class="alert alert-info">

Let's try

まず、`i=0` から `i=len(a)-1`まで、一巡、スワップしてみましょう。
</div>

\Run{関数定義(一巡スワップする)}
```py
def bubble_sort(a):
for i in range(len(a)-1):
if a[i] > a[i+1]:
a[i], a[i+1] = a[i+1], a[i]
print(f'@{i}', a)
```


\Run{実行}
```py
a = [5, 3, 1, 9, 8, 0, 4, 2, 7, 6]
bubble_sort(a)
```
\Out
```py
@0 [3, 5, 1, 9, 8, 0, 4, 2, 7, 6]
@1 [3, 1, 5, 9, 8, 0, 4, 2, 7, 6]
@2 [3, 1, 5, 9, 8, 0, 4, 2, 7, 6]
@3 [3, 1, 5, 8, 9, 0, 4, 2, 7, 6]
@4 [3, 1, 5, 8, 0, 9, 4, 2, 7, 6]
@5 [3, 1, 5, 8, 0, 4, 9, 2, 7, 6]
@6 [3, 1, 5, 8, 0, 4, 2, 9, 7, 6]
@7 [3, 1, 5, 8, 0, 4, 2, 7, 9, 6]
@8 [3, 1, 5, 8, 0, 4, 2, 7, 6, 9]
```

まだ、リストのソートは完了していません。
ソートが完了するまで、`bubble_sort(n)`のループを繰り返すことになります。

<div class="alert alert-info">

考えてみよう

何回、ループを繰り返せばよいでしょうか？
</div>

リストa の中で**一番大きな値**(上の例では`9`)に注目してみてください。
リスト a を先頭から最後まで`a[i] > a[i+1]`のとき、スワップ操作をすると、
最終的に、必ず一番大きな値が最後尾にきます。

<div class="alert alert-info">

バブルソートの由来

大きな値が最後尾にくる様子が、\\
バブル（泡）が浮き上がってくるのに似ているため
</div>

バブルソートの名前とともに、
\textbf{「先頭から最後尾まで１回隣り合う要素を比較してスワップすると、
最後尾は最大値になる」}と覚えておきましょう。
こう覚えておくと、ループはトータルで何回まわすべきかわかります。

```py
def bubble_sort(a):
for j in range(1, len(a)):
for i in range(len(a)-j):
if a[i] > a[i+1]:
a[i], a[i+1] = a[i+1], a[i]
print(f'@{j}', a)
```

\Run{実行}
```py
a = [5, 3, 1, 9, 8, 0, 4, 2, 7, 6]
bubble_sort(a)
```
\Out
```py
@1 [3, 1, 5, 8, 0, 4, 2, 7, 6, 9]
@2 [1, 3, 5, 0, 4, 2, 7, 6, 8, 9]
@3 [1, 3, 0, 4, 2, 5, 6, 7, 8, 9]
@4 [1, 0, 3, 2, 4, 5, 6, 7, 8, 9]
@5 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
@6 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
@7 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
@8 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
@9 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## クイックソート

クイックは、1960年、Antony Hoare が考案した高速かつエレガントなアルゴリズムです。
ソートアルゴリズムの代名詞になっています。

* 適当な数(**ピボット**{pivot}と呼ぶ)を選択する
* ピボットより小さい要素の集合、大きい要素の集合に分割する
* 2分割された各々の配列を、それぞれ分割できなくなるまで繰り返す
\vspace{1cm}
\begin{center}
\includegraphics[width=12cm]{figs/quickSort.pdf}
\end{center}

\vspace{-0.5cm}
<div class="alert alert-info">

情報系院試験頻出

アルゴリズムといえば、まずクイックソートというくらい頻出
</div>

### クイックソートの実装

クイックソートは、
メモリ効率を考えなければ、それほど難しくありません。

\Run{クイックソート(メモリ効率を考えない場合)}
```py
def quick_sort(a):
if len(a)>1:
# 先頭と最後尾の平均をpivot にする
pivot = (a[0] + a[-1]) / 2

# pivot より大小で二つにわける
b = [x for x in a if x <= pivot]
c = [x for x in a if x > pivot]
print(a, f'={pivot}=>', b, c)　 # 動作確認用

# 分割したリストをそれぞれ再帰的にソート
return quick_sort(b) + quick_sort(c)
return a
```

\Out
```py
[5, 3, 1, 9, 8, 0, 4, 2, 7, 6] =5.5=> [5, 3, 1, 0, 4, 2] [9, 8, 7, 6]
[5, 3, 1, 0, 4, 2] =3.5=> [3, 1, 0, 2] [5, 4]
[3, 1, 0, 2] =2.5=> [1, 0, 2] [3]
[1, 0, 2] =1.5=> [1, 0] [2]
[1, 0] =0.5=> [0] [1]
[5, 4] =4.5=> [4] [5]
[9, 8, 7, 6] =7.5=> [7, 6] [9, 8]
[7, 6] =6.5=> [6] [7]
[9, 8] =8.5=> [8] [9]
```

クイックソートが長らくソートアルゴリズムの代名詞とされてきたのは、
単に高速なだけでなく、メモリ効率も優れていたからです。
（昔のコンピュータはメモリが高価でした。）

次は、メモリ効率よくクイックソートを書いた例です。

\Run{クイックソート(メモリ効率のよい分割)}
```py
def quick_sort(a, start, end):
if start < end:
left, right = start, end-1
pivot = (a[start] + a[right]) // 2
while True:
# a[left] >= pivot となる位置を検索
while a[left] < pivot:
left += 1
# a[right] <= pivot となる位置を検索
while pivot < a[right]:
right -= 1
if left >= right: break
a[left], a[right] = a[right], a[left]
left += 1
right -= 1
# 分割した左を再帰的にソート
quick_sort(a, start, left)
# 分割した右を再帰的にソート
quick_sort(a, right+1, end)
```

<div class="alert alert-info">

比較してみよう

どこが違うのか比較してみよう
</div>

最初のクイックソートは、分割するときに、新しくリストを２つ作っています。
少なくとも、この段階でメモリは２倍必要になります。
一方、あとのクイックソートは、リスト上の先端(start)と終端(end)の位置をもって、
分割したとき新しいリストを作りません。
その代わり、リストの両端(left, right)から比較して、(` left > right`)になったとき分割しています。


なお、クイックソートは**かなり難しい実装**に分類されます。
すんなり書ける人はそんなにいません。
本稿のソースコードも何度も直していますし、まだバグがあるかもしれません。

## アルゴリズム選択

ソートアルゴリズムは、
同じ問題に対して異なる手順の解法が複数あることを示しています。
すると、「**どのアルゴリズムを選んだいいのだろうか？**」と考える必要が生じます。

アルゴリズムの評価基準は、アルゴリズムを選択する上でヒントとなります。\\

**アルゴリズムの評価基準**
* 正当性
* c.f. 正しさの証明があるか
* 仕事量
* ステップ数，計算量と複雑さ (complexity)，平均ケースと最悪ケース
* 使用領域量
* 単純さ，わかりやすさ，**プログラムの簡単さ**
* 健全性，完全性，誤差の少なさ
* 最適性

計算量と複雑さは、アルゴリズムの性能を評価する重要な指標となります。
（詳しくは、次回に譲ります。）
しかし、性能だけが全てではありません。
**実装のしやすさ**も実は重要です。
シンプルなアルゴリズムがバグも少なく、実装しやすいので好まれます。

また、時代とともにアルゴリズムのトレンドが変わることもあります。
昔は、ソートアルゴリズムといえば、ほぼクイックソートでした。
しかし、最近はメモリの価格が大幅に下がったため、
マージソートの方が望ましいアルゴリズムとされることが増えています。



