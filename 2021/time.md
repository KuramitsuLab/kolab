\chapter{計算量と複雑さ}

計算量解析は、アルゴリズムの効率を見積もり、アルゴリズムを選択する助けとなります。
計算量と複雑さの考え方を理解しておきましょう。

## プログラムの効率

プログラムの効率は、次の２つの側面から評価できます。

* {\em コードの効率}
* プログラミングの{\em 経験的な知見}に基づく
* アーキテクチャやコンパイラ最適化、プログラミング言語の知識に基づく
* {\em アルゴリズムの効率}
* アルゴリズムの効率は、より普遍的で理論的な考察に基づく
* コンピュータの種類やプログラミング言語に依存しない

<div class="alert alert-info">

コードの効率：どちらが高速？

プログラムの性能は、コードの細かい書き方によって実行性能が影響をうける場合があります。
\begin{C++}
n * 4
\end{C++}


\begin{C++}
n << 2
\end{C++}
%\caption{どちらが高速？}
</div>

## ベンチマーク

ベンチマークとは、処理時間（実行時間）を計測して、プログラムの性能を測る手段です。

### コンピュータの性能指標

ベンチマークは、コンピュータの性能によって左右されます。
論文やレポートにベンチマーク結果を示すときは、必ず前提条件として、
コンピュータの性能指標を記載するようにしましょう。\\

\Run{{\Colab}上でCPU性能を調べる手段}
```py
!cat /proc/cpuinfo
```

```py
vendor_id	: GenuineIntel
cpu family	: 6
model		: 79
model name	: Intel(R) Xeon(R) CPU @ 2.20GHz
cpu MHz		: 2199.998
cache size	: 56320 KB
bogomips	: 4399.99
cache_alignment	: 64
```

\Run{{\Colab}上でメモリ性能を調べる手段}
```py
!cat /proc/meminfo
```

```py
MemTotal:       13341992 kB
MemFree:         8670124 kB
MemAvailable:   12753184 kB
```

### 処理時間の計測

Python では、`time`モジュールを用いて、
プログラムの処理時間を計測します。

原理は簡単で、`time.time()`で時刻を２回計測し、
その差分から処理にかかった時間を得ます。

```py
import time

t0 = time.time()  # 処理前の時刻

#
# 計測したい処理をここに書く
#

t1 = time.time()　# 処理後の時刻

delta = t1 - t0　　# 経過時間を表示
print(f"経過時間：{delta} [s]")
```

**注意**

コンピュータで計測される時刻は精度の限界があります。
極端に短い時間（ミリ秒以下）はあまり信用できません。

\begin{lbox}{ベンチマークの正しい取り方}
* ベンチマークのデータを多くする
* 複数回測定し、平均をとる
\end{lbox}

\hr
\HBold{例題（ソートの処理時間）}
リストのソート（メソッド）の実行時間を測定せよ。

\hr

まず、実験データを用意します。
ここでは、少し大きめなリストを`range`で生成し、
ランダムにシャッフルしておきます。

```py
import random
data = list(range(100_0000))
random.shuffle(data)
```

10回くらい計測して平均をとってみましょう。
`time.time()`の計測単位は、秒です。

```py
import time

ts = []
for i in range(10):
random.shuffle(data)
t0 = time.time()
# 計測したい処理のみ書く
data.sort()
t1 = time.time()
delta = t1 - t0
print(f"経過時間：{i+1} {delta}")
ts.append(elapsed_time)
print(f"平均：{sum(ts)/len(ts)}")
```
\Out
```py
経過時間：1 0.6613478660583496
経過時間：2 0.682361364364624
経過時間：3 0.6679091453552246
経過時間：4 0.6855053901672363
経過時間：5 0.6730430126190186
経過時間：6 0.6826703548431396
経過時間：7 0.6903061866760254
経過時間：8 0.665369987487793
経過時間：9 0.6954135894775391
経過時間：10 0.6668949127197266
平均：0.6770821809768677
```


\if0
Jupyter や Google Colaboratory では、
`%%timeit` という便利なマジックも利用できます。

```py
%% timeit
import random
array = list(range(100000))
random.shuffle(array)

array.sort()
```
\fi

## 計算量の表記

実測によるプログラムの処理時間は、
コンピュータの性能が変わると大きく変わります。

計算量は、プログラムに対する\textbf{入力データが増えると、
どのように処理量が増えるか}という視点で理論的に見積もります。

<div class="alert alert-info">

線形処理

入力のデータサイズが2倍に増えたとき、処理量が2倍程度の増加する
</div>

処理量は、時間（処理時間）と空間（使用メモリ量）で測ります。

* **時間計算量**{time complexity}
* プログラムの実行に必要な時間の見積もり
* **空間計算量**{space complexity}
* プログラムの実行に必要なメモリ使用量の見積もり

<div class="alert alert-info">

一般に、計算量といえば

**時間計算量**のことになる：時間複雑さともいう
</div>

###  $O$記法：漸近的計算量解析

{\CS}では、計算量を表す記法として、$O$記法（ランダウの記法、オーダー記法）を用います。

\begin{lbox}{$O$記法}
入力規模$n$に対する計算量の増加程度を示す記法
* 影響力の大きい（次数の大きい）項以外は無視する
* 定数倍の差は無視する
\end{lbox}

あるサイズ$n$ の問題を解く手順数が{\em $T(n)=4n^2-2n+2$ }であるとき:

* $n$ を次第に大きくしていくと $n^2$ の項ばかり効い て、他の項はほとんど無視できる
* このアルゴリズムの計算量は$O(n^2)$($n^2$ のオーダー)である

### 代表的なアルゴリズムと計算量

\begin{center}
\begin{tabular}{cll}
\hline
オーダ記法 & 時間 & アルゴリズム例 \\
$O(1)$ & 定数時間 & 偶数奇数判定 \\
$O(log n)$ & 対数時間 & 二分探索 \\
$O(n)$ & 線形時間 & 線形探索 \\
$O(n\;log n)$ & 線形対数時間 & クイックソート、マージソート \\
\hline
$O(n^2)$ & 二乗時間 & 選択ソート、バブルソート \\
$O(n^k)$ & 多項式時間 &  \\
\hline
$O(2^n)$ & 指数時間 & バックトラック法 \\
$O(n!)$ & 階乗時間 &  完全マッチング問題 ($n$人の男性と$n$人の女性)\\
\hline
\end{tabular}
\end{center}

<div class="alert alert-info">

暗記モノではないが.. 

アルゴリズムを覚えたら、計算量も覚えておくとよい
</div>

### 指数時間

データ量が増えてプログラムが動かなくなる様子は、「指数爆発した」と形容されます。
どうして爆発と形容されるのでしょうか？

$O(2^n)$のアルゴリズムがあったとします。

* 比較的小さな入力数 n = 100 のとき
* 1秒間に$10^{10}$(10G)回計算できるコンピュータを用いても
*  $4 \times 10^{12}$年かかる

<div class="alert alert-info">

指数時間

簡単に宇宙の寿命を超えてしまう
</div>

宇宙の寿命と言われても実感がわかないと思います。
そこで、簡単に指数時間コストのプログラムを書いて試してみましょう。
次は、おなじみのフィボナッチ数を求める再帰関数です。

```py
def fibo(n):
if n == 1 or n == 2: return 1
return fibo(n-1) + fibo(n-2)
```

実は、このフィボナッチ関数の入力$n$に対する計算量は
$O(\left\{\frac{1+\sqrt{5}}{2}\right\}^n)$で指数時間アルゴリズムになります。

<div class="alert alert-info">

Let's try

フィボナッチ関数の$n$に対する実行時間を測定してみよう\\
</div>



\vspace{1cm}
指数時間なので、間違ってもいきなり$n=100$とかフィボナッチ数を計算しないでください。
測定した実行時間を\fbox{matplotlib}で表示すると、次のようなグラフになります。

\begin{center}
\includegraphics[width=6cm]{figs/fibotime.png}
\end{center}

\fbox{matplotlib}の使い方は、３年生の数値計算法Iで学びます。


\begin{lbox}{フィボナッチ・ベンチマーク}
フィボナッチの再帰関数は、簡単なプログラムで簡単に負荷がかけられるので、
プログラミング言語を最初のベンチマークとして重宝されてきました。\\
\end{lbox}

## 時間計算量の見積もり

前回、学んだソートアルゴリズムを使って、時間計算量の見積もりをみていきましょう。

### ループを見る

時間計算量は、**入力サイズ$N$に依存して繰り返しの回数が決まるループ**に着目します。

バブルソートでは、
長さ$N$のリストを**$N$回繰り返す２重ループ**を用いて比較しています。
ループが2重なので、時間計算量は$O(N^2)$となります。
（外側のループは$N-1$回などと細かいことを考える必要はありません。）

**バブルソート: 2重ループ**

```py
for i in range(N):
for j in range(N-1):
if a[j] > a[j+1]:
a[j], a[j+1] = a[j+1], a[j]
```

\HBold{注意}
`a[i]`（配列の要素への参照）は$O(1)$
\begin{center}
\includegraphics[width=0.25\paperwidth]{figs/Onn.pdf}
\end{center}

### 分割に着目する

入力データを分割する処理があるときは、
後述する「分割統治法」の可能性があります。

例えば、クリックソートでは、$N$回繰り返すループをまわす度に、
入力データを（平均して）$N/2$と半分に分割していきます。
この場合は、分割する回数は$O(\log{N})$となります。
最終的には、$O(N\;\log{N})$となります。

**クイックソート: 分割**
```py
def qsort(a, left, right):
if left < right:
i, j = left, right
pivot = a[left+right//2]
...
# 左側を再帰的にソート
qsort(a, left, i - 1)
# 右側を再帰的にソート
qsort(a, j + 1, right)
```
\begin{center}
\includegraphics[width=0.30\paperwidth]{figs/Onlogn.pdf}
\end{center}

クイックソートの計算量解析は注意するところがあります。
分割するとき、常にN/2に分割されません。
pivot の値次第では、$N-1$ と $1$に分割されることもあります。
そこで、計算量を解析するときは、平均的なケースと**最悪のケース**に分けて考えます。

<div class="alert alert-info">

クイックソートのアルゴリズム

* {\em 最良計算量} $O(N\; \mathrm{log}\; N)$ -- 理想的に($N/2, N/2$)で分割される
* {\em 平均計算量} $O(N\; \mathrm{log}\; N)$ -- 平均的な計算量
* {\em 最悪計算量} $O(N^2)$ -- 常に$(N-1, 1)$で分割される
</div>

最悪計算量は、滅多に起こり得ないケースといえますが、
攻撃者が意図的に狙って攻撃してきてセキュリティ脆弱性になることもあります。
計算量が入力データ（ケース）に依存しないアルゴリズムがより理想的といえます。

<div class="alert alert-info">

安定アルゴリズム

計算量が入力データに依存しないアルゴリズム
</div>

### マージソート

次は、
倉光が効率を気にせずにお気楽に書いたマージソートの実装です。

```py
def merge_sort(a):
if len(a) > 1:
sep = len(a)//2
b = merge_sort(a[:sep])
c = merge_sort(a[sep:])
a.clear()
while len(b) > 0 and len(c) > 0:
# b, c の先頭をみて
b0 = b[0]
c0 = c[0]
# 小さい方を追加する
if b0 < c0:
a.append(b0)
b.pop(0)
else:
a.append(c0)
c.pop(0)
# b, c のどちらかは空
a.extend(b)
a.extend(c)
return a
```

<div class="alert alert-info">

Let's try

マージソートのコードを分析して、平均計算量と最悪計算量を求めてみよう
</div>

実は、倉光のコードはお気楽に書き過ぎていて、落とし穴があります。
マージソートの教科書的な計算量は$O(N\;\log{N})$ですが、
`b.pop(0)`と`c.pop(0)`は$O(1)$でなく、(たぶん)$O(N)$です。
Python の怖いところは、
**便利なメソッドに突然計算量の大きい操作が紛れている**点です。

### 帰着

最後に、同等な計算量のアルゴリズムに帰着して考える方法をみてみましょう。


\HBold{例題}
大きさ$N$の数列aの中央値を求める計算量は？


数列aの中央値は、aが整列されているのなら`a[len(a)//2]`となります。
しかし、数列aが**常に整列されていると仮定できない**ので、
まず整列しなければなりません。
したがって、ソートアルゴリズムの計算量$O(N\;\log{N})$に帰着されます。

<div class="alert alert-info">

ちょっと疑問

本当に$O(N\;\log{N})$より、効率のよいアルゴリズムはないのか？
</div>

「もっと効率の良いアルゴリズムはない」ことは証明できません。

中央値の問題は、ソートを用いず、
「n個の要素をもつ集合のi番目に小さい要素を計算量O(n)で計算するアルゴリズム」に帰着させれば、
線形最悪時間で解くこともできるようです。

## 分割統治法

計算量は、入力データのサイズ$N$に依存することがわかってきた思います。
効率のよいアルゴリズムのコツは、
入力データのサイズを分割して、$N$のファクターを下げることです。
このようなアルゴリズム・デザインの戦略を**分割倒置法**{divide-and-conquer}と呼びます。\\

**分割統治法**

* 二分探索
* クイックソート
* マージソート

分割統治法のコツは、
並列アルゴリズムのように単に入力データを分割するだけでなく、
分割を再帰的に繰り返し、$N/2$, $N/4$, $N/8$と細かくしていくことです。


\HBold{例題（分割統治法）}   $m^n (~ pow(m , n))$を分割統治法で効率よく計算してみよう


ヒント：$\times$ の回数を少なくする

\HBold{答え($m^n$の再帰構造)}

\begin{equation}
\begin{array}{lcl}
3^{16} & =  & 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \\
& =  & (3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3) ^ 2  \\
& =  & ((3 \times 3 \times 3 \times 3) ^ 2) ^ 2 \\
& =  & (((3 \times 3 ) ^ 2 ) ^ 2) ^ 2 \\
\end{array}
\notag
\end{equation}

これを一般化すると、

\begin{lbox}{$pow(m, n)$: 繰り返し二乗法}

\begin{equation}
pow(m, n) = \left \{
\begin{array}{lr}
m　&(n = 1 \mbox{のとき}) \\
pow(m^2, n/2)　&(n \mbox{が偶数のとき}) \\
pow(m^2, n/2) \times m　&(n \mbox{が奇数のとき})
\end{array}
\right. \notag
\end{equation}
\end{lbox}

## NPと計算困難性

アルゴリズムの計算量（複雑さ）に関する研究が進むにつれて
**ある種の問題は、多項式時間アルゴリズムが見つからない**ことが明らかになってきました。

\begin{lbox}{**NP完全問題**{NP complete problem}}
さらに、同じ難しさのクラスだとわかってきた.
* 多項式時間アルゴリズムが見つからない
* 「多項式時間アルゴリズムが存在しない」と証明されたわけではない

\end{lbox}

### NP 完全問題

* **巡回セールスマン問題**\\
$n$個の都市に対する距離の集合と上限$D$が与えられる. $d\le D$となる巡回路$d$は存在するか？
* **ハミルトン閉路問題**\\
有向グラフGが与えられたとき、ハミルトン閉路を存在するか？
* 3次元マッチング問題
* グラフ彩色問題(４色予想)

* **部分集合和問題**（$\sim$ナップサック問題の一般化) \\
整数$w_1,..., w_n$と目標値$W$が与えられる.
このとき、$\{w_1,..., w_n\}$の部分集合で合計が$W$となるものは存在するか？
* **制約充足問題**（3-SAT) \\
変数の集合$X=\{x_1, .., x_n\}$上の長さ3節の $C_1, .., C_k$が与えられる.
このとき全てを充足する真偽値割り当ては存在するか？

### NP予想

* クラス$P$ -- 多項式時間で解ける問題クラス
* クラス$NP$ -- NP完全問題クラス

<div class="alert alert-info">

$P \ne NP$予想

$P \ne NP$と信じられているが、証明されていない

* アルゴリズムの本質な問題
* 計算機科学の有名問題のひとつ
</div>

%\subsection{解けない問題}

\section*{演習問題}

\HBold{チャレンジ課題（ソートライブラリの計算量）}
Pythonのソートライブラリは、二乗時間オーダー$O(n^2)$でないことを
ベンチマークによって確認せよ。
自分で**matplotlib**の使い方を調べて、実行結果を図示できると良いです。

